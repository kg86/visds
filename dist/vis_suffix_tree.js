/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/strlib.ts":
/*!***********************!*\
  !*** ./src/strlib.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lcp = void 0;
const lcp = (x, y) => {
    const n = Math.min(x.length, y.length);
    let i = 0;
    for (; i < n; i++) {
        if (x[i] !== y[i])
            break;
    }
    return i;
};
exports.lcp = lcp;


/***/ }),

/***/ "./src/suffix_tree.ts":
/*!****************************!*\
  !*** ./src/suffix_tree.ts ***!
  \****************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.suffix_tree = void 0;
const strlib_1 = __webpack_require__(/*! ./strlib */ "./src/strlib.ts");
class Node {
    constructor(birth_time, to_edge_label, value) {
        this.to_edge_label = to_edge_label;
        this.children = new Map();
        this.birth_time = birth_time;
        this.value = value;
    }
    get is_leaf() {
        return Object.keys(this.children).length === 0;
    }
    get depth() {
        if (this.children.size === 0)
            return 0;
        else
            return Math.max(...Array.from(this.children.values()).map((child) => child.depth));
    }
}
class StrTree {
    constructor() {
        this.nodes = [];
        this.root = this.create_node("root");
        this.slinks = new Map();
    }
    create_node(to_edge_label, value = -1) {
        const node = new Node(this.nodes.length, to_edge_label, value);
        this.nodes.push(node);
        return node;
    }
    /**
     * split the edge at match_len, and return the branch node
     *
     * @param {Node} parent - parent node of the edge being splitted.
     * @param {Node} child - child node of the edge being splitted.
     * @param {number} match_len - the position of the edge being splitted from parent.
     */
    split(parent, child, match_len) {
        if (match_len === 0)
            return child;
        console.assert(match_len < child.to_edge_label.length, match_len.toString(), child.to_edge_label.length);
        const branch_node = this.create_node(child.to_edge_label.substr(0, match_len));
        parent.children.set(branch_node.to_edge_label[0], branch_node);
        child.to_edge_label = child.to_edge_label.substr(match_len);
        branch_node.children.set(child.to_edge_label[0], child);
        return branch_node;
    }
    find_branch(parent, text, match_len_all = 0) {
        if (text.length === 0 || parent.children.get(text[0]) === undefined) {
            return [parent, null, 0, match_len_all];
        }
        const child = parent.children.get(text[0]);
        const match_len = (0, strlib_1.lcp)(child.to_edge_label, text);
        if (match_len < child.to_edge_label.length) {
            return [parent, child, match_len, match_len_all + match_len];
        }
        else {
            return this.find_branch(child, text.substr(match_len), match_len_all + match_len);
        }
    }
    insert(text, value) {
        const [parent, child, match_len, match_len_all] = this.find_branch(this.root, text);
        // console.log('insert', text, parent, child, match_len, match_len_all)
        if (match_len_all < text.length) {
            const branch_node = child === null ? parent : this.split(parent, child, match_len);
            const leaf = this.create_node(text.substr(match_len_all), value);
            branch_node.children.set(leaf.to_edge_label[0], leaf);
        }
    }
    print_tree(node = this.root, pre = "") {
        console.log(pre + " " + node.to_edge_label + ": " + node.birth_time);
        node.children.forEach((child) => this.print_tree(child, pre + "--"));
    }
    build_suffix_links(node, node_label, reverse = false) {
        if (node === undefined || node_label === undefined) {
            node = this.root;
            node_label = "";
            this.slinks = new Map();
        }
        if (node !== this.root) {
            const [parent, child] = this.find_branch(this.root, node_label.substr(1));
            if (child === null) {
                if (reverse)
                    this.slinks.set(parent, node);
                else
                    this.slinks.set(node, parent);
            }
        }
        node.children.forEach((child) => this.build_suffix_links(child, node_label + child.to_edge_label, reverse));
    }
    json() {
        const nodes = [];
        let edges = [];
        const nid = new Map();
        const create_json_node = (node, level) => {
            if (!nid.has(node)) {
                nid.set(node, node.birth_time);
                const ndic = {
                    label: node.value === -1 ? "" : "" + node.value,
                    id: nid.get(node),
                    level,
                    shape: node.is_leaf ? "box" : undefined,
                };
                nodes.push(ndic);
            }
        };
        const rec = (parent, level) => {
            create_json_node(parent, level);
            parent.children.forEach((child) => {
                create_json_node(child, level + 1);
                const edge = {
                    from: nid.get(parent),
                    to: nid.get(child),
                    id: nid.get(parent) + "-" + nid.get(child),
                    label: child.to_edge_label,
                    font: { align: "top" },
                };
                edges.push(edge);
                rec(child, level + 1);
            });
        };
        rec(this.root, 0);
        // compute suffix links
        const slinks = [];
        for (const [from_node, to_node] of this.slinks.entries()) {
            const slink = {
                from: nid.get(from_node),
                to: nid.get(to_node),
                id: "s" + nid.get(from_node) + "-" + nid.get(to_node),
                dashes: true,
                color: { color: "#ff0000" },
                smooth: { type: "curvedCW", roundness: 0.4 },
            };
            slinks.push(slink);
        }
        edges = edges.concat(slinks);
        return { root: nid.get(this.root), nodes, edges };
    }
}
function suffix_tree(text, build_suffix_links) {
    const st = new StrTree();
    for (let i = 0; i < text.length; i++) {
        st.insert(text.substr(i), i);
    }
    if (build_suffix_links)
        st.build_suffix_links();
    return st;
}
exports.suffix_tree = suffix_tree;
const main = (text) => {
    const st = new StrTree();
    for (let i = 0; i < text.length; i++) {
        st.insert(text.substr(i), i);
        st.print_tree();
    }
    console.log(st.json());
};
if (__webpack_require__.c[__webpack_require__.s] === module) {
    if (process.argv.length === 3) {
        main(process.argv[2]);
    }
    else {
        const usage = process.argv[1] +
            " input_str\n" +
            "\tbuild suffix tree of input_str and show the structure in json format.";
        console.log(usage);
    }
}


/***/ }),

/***/ "./src/vis_suffix_tree.ts":
/*!********************************!*\
  !*** ./src/vis_suffix_tree.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const standalone_1 = __webpack_require__(/*! vis-network/standalone */ "./node_modules/vis-network/standalone/index.js");
const suffix_tree_1 = __webpack_require__(/*! ./suffix_tree */ "./src/suffix_tree.ts");
const visjs_default_options = __webpack_require__(/*! ./visjs_default_options */ "./src/visjs_default_options.ts");
const options = visjs_default_options.options;
const container = document.getElementById("network");
const network = new standalone_1.Network(container, {}, options);
let networkData = {
    nodes: new standalone_1.DataSet([]),
    edges: new standalone_1.DataSet([]),
};
let stree = (0, suffix_tree_1.suffix_tree)("", false);
const load_params_from_url = () => {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    let params = {
        input_text: "cocoa",
        show_suffix_links: true,
    };
    const urlkey = urlParams.get("input_text");
    if (urlkey !== null)
        params.input_text = urlkey;
    params.show_suffix_links = urlParams.get("show_suffix_links") === "true";
    return params;
};
const load_params_from_html = () => {
    const input_text = document.getElementById("input_text")
        .value;
    const show_suffix_links = document.getElementById("show_suffix_links").checked;
    const params = {
        input_text: input_text,
        show_suffix_links: show_suffix_links,
    };
    return params;
};
const set_params_to_url = (params) => {
    const url = new URL(window.location.toString());
    for (let key of Object.keys(params)) {
        url.searchParams.set(key, params[key].toString());
    }
    history.replaceState({}, "", url.toString());
};
const set_params_to_html = (params) => {
    const input_text = document.getElementById("input_text");
    const show_suffix_links = document.getElementById("show_suffix_links");
    const implicit_cdawg = document.getElementById("implicit_cdawg");
    input_text.value = params.input_text;
    show_suffix_links.checked = params.show_suffix_links;
};
const redraw = () => {
    // set params to url
    const params = load_params_from_html();
    set_params_to_url(params);
    console.log("input_text", params.input_text);
    console.log("show_suffix_links", params.show_suffix_links);
    stree = (0, suffix_tree_1.suffix_tree)(params.input_text, params.show_suffix_links);
    console.log("st", stree);
    const json = stree.json();
    console.log("json", json);
    networkData = {
        nodes: new standalone_1.DataSet(json.nodes),
        edges: new standalone_1.DataSet(json.edges),
    };
    network.setData(networkData);
};
const show_node_str = (nid) => {
    const elm = document.getElementById("node_str");
    const nstr = nid ? node_str(nid) : "";
    elm.innerText = nstr;
};
/**
 * Make a map from node id to the string from root to the node.
 */
const make_nstr = () => {
    const json = stree.json();
    const map = new Map();
    const rec = (nid, prefix) => {
        map.set(nid, prefix);
        for (let edge of json.edges) {
            if (edge.from !== nid)
                continue;
            rec(edge.to, prefix + edge.label);
        }
    };
    rec(json.root, "");
    return map;
};
const node_str = (nid) => {
    const nstr = make_nstr();
    return nstr.get(nid);
};
const main = () => {
    // set event listener
    const input_text = document.getElementById("input_text");
    input_text.addEventListener("input", redraw);
    input_text.addEventListener("propertychange", redraw);
    const show_sl_btn = document.getElementById("show_suffix_links");
    show_sl_btn.addEventListener("change", redraw);
    network.on("hoverEdge", (e) => {
        console.log("hoverEdge", e);
        // @ts-ignore
        networkData.edges.update({ id: e.edge, font: { size: 34 } });
        // @ts-ignore
        const nid = networkData.edges.get(e.edge).to;
        show_node_str(nid);
    });
    network.on("blurEdge", (e) => {
        console.log("blurEdge");
        // @ts-ignore
        networkData.edges.update({ id: e.edge, font: { size: 14 } });
        show_node_str(null);
    });
    network.on("hoverNode", (n) => {
        show_node_str(n.node);
    });
    network.on("blurNode", (n) => {
        show_node_str(null);
    });
    // load and set parameters
    const params = load_params_from_url();
    set_params_to_html(params);
    redraw();
};
main();


/***/ }),

/***/ "./src/visjs_default_options.ts":
/*!**************************************!*\
  !*** ./src/visjs_default_options.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.options = void 0;
exports.options = {
    height: "100%",
    layout: {
        hierarchical: {
            // enabled: true
            // direction: 'UD',
            direction: "LR",
            // sortMethod: 'directed',
            treeSpacing: 185,
            levelSeparation: 95,
            nodeSpacing: 40,
        },
    },
    nodes: {
        size: 10,
    },
    edges: {
        arrows: {
            to: {
                enabled: true,
                scaleFactor: 0.5,
            },
        },
        // edge label is not displayed at the center of the edge
        // if `smooth` is specified
        smooth: {
            enabled: true,
            // type: 'dynamic',
            type: "vertical",
            // type: 'horizontal', // This is better for UD
            // type: 'continuous',
            // type: 'curvedCCW',
            // type: 'straightCross',
            roundness: 1.0,
        },
    },
    interaction: {
        hover: true,
        navigationButtons: true,
    },
    physics: false,
};


/***/ }),

/***/ "./node_modules/vis-network/standalone/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/vis-network/standalone/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.DataSet),
/* harmony export */   "DataView": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.DataView),
/* harmony export */   "Network": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.Network),
/* harmony export */   "NetworkImages": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.NetworkImages),
/* harmony export */   "Queue": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.Queue),
/* harmony export */   "data": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.data),
/* harmony export */   "networkDOTParser": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkDOTParser),
/* harmony export */   "networkGephiParser": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkGephiParser),
/* harmony export */   "networkOptions": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkOptions),
/* harmony export */   "parseDOTNetwork": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.parseGephiNetwork)
/* harmony export */ });
/* harmony import */ var _vis_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vis-network */ "./node_modules/vis-network/standalone/esm/vis-network.js");



/***/ }),

/***/ "./node_modules/vis-network/standalone/esm/vis-network.js":
/*!****************************************************************!*\
  !*** ./node_modules/vis-network/standalone/esm/vis-network.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* binding */ DataSet),
/* harmony export */   "DataView": () => (/* binding */ DataView),
/* harmony export */   "Network": () => (/* binding */ Network),
/* harmony export */   "NetworkImages": () => (/* binding */ Images),
/* harmony export */   "Queue": () => (/* binding */ Queue),
/* harmony export */   "data": () => (/* binding */ index),
/* harmony export */   "networkDOTParser": () => (/* binding */ dotparser),
/* harmony export */   "networkGephiParser": () => (/* binding */ gephiParser),
/* harmony export */   "networkOptions": () => (/* binding */ options),
/* harmony export */   "parseDOTNetwork": () => (/* binding */ parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* binding */ parseGephi)
/* harmony export */ });
/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.1.2
 * @date    2022-03-28T20:13:51.046Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global$P = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

var fails$t = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$s = fails$t;
var functionBindNative = !fails$s(function () {
  var test = function () {
    /* empty */
  }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$4 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$6 = FunctionPrototype$3.apply;
var call$d = FunctionPrototype$3.call; // eslint-disable-next-line es/no-reflect -- safe

var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$d.bind(apply$6) : function () {
  return call$d.apply(apply$6, arguments);
});

var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$d = FunctionPrototype$2.bind;
var call$c = FunctionPrototype$2.call;
var uncurryThis$w = NATIVE_BIND$3 && bind$d.bind(call$c, call$c);
var functionUncurryThis = NATIVE_BIND$3 ? function (fn) {
  return fn && uncurryThis$w(fn);
} : function (fn) {
  return fn && function () {
    return call$c.apply(fn, arguments);
  };
};

// https://tc39.es/ecma262/#sec-iscallable

var isCallable$h = function (argument) {
  return typeof argument == 'function';
};

var objectGetOwnPropertyDescriptor = {};

var fails$r = fails$t; // Detect IE8's incomplete defineProperty implementation

var descriptors = !fails$r(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] != 7;
});

var NATIVE_BIND$2 = functionBindNative;
var call$b = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$b.bind(call$b) : function () {
  return call$b.apply(call$b, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor$8 && !$propertyIsEnumerable$2.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$8(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;

var createPropertyDescriptor$5 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var uncurryThis$v = functionUncurryThis;
var toString$a = uncurryThis$v({}.toString);
var stringSlice$1 = uncurryThis$v(''.slice);

var classofRaw$1 = function (it) {
  return stringSlice$1(toString$a(it), 8, -1);
};

var global$O = global$P;
var uncurryThis$u = functionUncurryThis;
var fails$q = fails$t;
var classof$f = classofRaw$1;
var Object$a = global$O.Object;
var split = uncurryThis$u(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails$q(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object$a('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$f(it) == 'String' ? split(it, '') : Object$a(it);
} : Object$a;

var global$N = global$P;
var TypeError$j = global$N.TypeError; // `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible

var requireObjectCoercible$5 = function (it) {
  if (it == undefined) throw TypeError$j("Can't call method on " + it);
  return it;
};

var IndexedObject$3 = indexedObject;
var requireObjectCoercible$4 = requireObjectCoercible$5;

var toIndexedObject$b = function (it) {
  return IndexedObject$3(requireObjectCoercible$4(it));
};

var isCallable$g = isCallable$h;

var isObject$j = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$g(it);
};

var path$y = {};

var path$x = path$y;
var global$M = global$P;
var isCallable$f = isCallable$h;

var aFunction = function (variable) {
  return isCallable$f(variable) ? variable : undefined;
};

var getBuiltIn$9 = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path$x[namespace]) || aFunction(global$M[namespace]) : path$x[namespace] && path$x[namespace][method] || global$M[namespace] && global$M[namespace][method];
};

var uncurryThis$t = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$t({}.isPrototypeOf);

var getBuiltIn$8 = getBuiltIn$9;
var engineUserAgent = getBuiltIn$8('navigator', 'userAgent') || '';

var global$L = global$P;
var userAgent$3 = engineUserAgent;
var process = global$L.process;
var Deno = global$L.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us

  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
} // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0


if (!version && userAgent$3) {
  match = userAgent$3.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent$3.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

var engineV8Version = version;

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION$2 = engineV8Version;
var fails$p = fails$t; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$p(function () {
  var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
});

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL$2 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

var global$K = global$P;
var getBuiltIn$7 = getBuiltIn$9;
var isCallable$e = isCallable$h;
var isPrototypeOf$m = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$9 = global$K.Object;
var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$7('Symbol');
  return isCallable$e($Symbol) && isPrototypeOf$m($Symbol.prototype, Object$9(it));
};

var global$J = global$P;
var String$4 = global$J.String;

var tryToString$4 = function (argument) {
  try {
    return String$4(argument);
  } catch (error) {
    return 'Object';
  }
};

var global$I = global$P;
var isCallable$d = isCallable$h;
var tryToString$3 = tryToString$4;
var TypeError$i = global$I.TypeError; // `Assert: IsCallable(argument) is true`

var aCallable$7 = function (argument) {
  if (isCallable$d(argument)) return argument;
  throw TypeError$i(tryToString$3(argument) + ' is not a function');
};

var aCallable$6 = aCallable$7; // `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod

var getMethod$3 = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable$6(func);
};

var global$H = global$P;
var call$a = functionCall;
var isCallable$c = isCallable$h;
var isObject$i = isObject$j;
var TypeError$h = global$H.TypeError; // `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive

var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$c(fn = input.toString) && !isObject$i(val = call$a(fn, input))) return val;
  if (isCallable$c(fn = input.valueOf) && !isObject$i(val = call$a(fn, input))) return val;
  if (pref !== 'string' && isCallable$c(fn = input.toString) && !isObject$i(val = call$a(fn, input))) return val;
  throw TypeError$h("Can't convert object to primitive value");
};

var shared$4 = {exports: {}};

var global$G = global$P; // eslint-disable-next-line es/no-object-defineproperty -- safe

var defineProperty$e = Object.defineProperty;

var setGlobal$1 = function (key, value) {
  try {
    defineProperty$e(global$G, key, {
      value: value,
      configurable: true,
      writable: true
    });
  } catch (error) {
    global$G[key] = value;
  }

  return value;
};

var global$F = global$P;
var setGlobal = setGlobal$1;
var SHARED = '__core-js_shared__';
var store$3 = global$F[SHARED] || setGlobal(SHARED, {});
var sharedStore = store$3;

var store$2 = sharedStore;
(shared$4.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.21.1',
  mode: 'pure' ,
  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var global$E = global$P;
var requireObjectCoercible$3 = requireObjectCoercible$5;
var Object$8 = global$E.Object; // `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject

var toObject$e = function (argument) {
  return Object$8(requireObjectCoercible$3(argument));
};

var uncurryThis$s = functionUncurryThis;
var toObject$d = toObject$e;
var hasOwnProperty = uncurryThis$s({}.hasOwnProperty); // `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty

var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$d(it), key);
};

var uncurryThis$r = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$9 = uncurryThis$r(1.0.toString);

var uid$4 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$9(++id$2 + postfix, 36);
};

var global$D = global$P;
var shared$3 = shared$4.exports;
var hasOwn$h = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL$1 = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore$1 = shared$3('wks');
var Symbol$3 = global$D.Symbol;
var symbolFor = Symbol$3 && Symbol$3['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$3;

var wellKnownSymbol$j = function (name) {
  if (!hasOwn$h(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name] == 'string')) {
    var description = 'Symbol.' + name;

    if (NATIVE_SYMBOL$1 && hasOwn$h(Symbol$3, name)) {
      WellKnownSymbolsStore$1[name] = Symbol$3[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore$1[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
    }
  }

  return WellKnownSymbolsStore$1[name];
};

var global$C = global$P;
var call$9 = functionCall;
var isObject$h = isObject$j;
var isSymbol$2 = isSymbol$3;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$i = wellKnownSymbol$j;
var TypeError$g = global$C.TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$i('toPrimitive'); // `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive

var toPrimitive$1 = function (input, pref) {
  if (!isObject$h(input) || isSymbol$2(input)) return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
  var result;

  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$9(exoticToPrim, input, pref);
    if (!isObject$h(result) || isSymbol$2(result)) return result;
    throw TypeError$g("Can't convert object to primitive value");
  }

  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol$1 = isSymbol$3; // `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey

var toPropertyKey$4 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol$1(key) ? key : key + '';
};

var global$B = global$P;
var isObject$g = isObject$j;
var document$1 = global$B.document; // typeof document.createElement is 'object' in old IE

var EXISTS$1 = isObject$g(document$1) && isObject$g(document$1.createElement);

var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};

var DESCRIPTORS$h = descriptors;
var fails$o = fails$t;
var createElement = documentCreateElement$1; // Thanks to IE8 for its funny defineProperty

var ie8DomDefine = !DESCRIPTORS$h && !fails$o(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var DESCRIPTORS$g = descriptors;
var call$8 = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$a = toIndexedObject$b;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$g = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$a(O);
  P = toPropertyKey$3(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$2(O, P);
  } catch (error) {
    /* empty */
  }
  if (hasOwn$g(O, P)) return createPropertyDescriptor$4(!call$8(propertyIsEnumerableModule$2.f, O, P), O[P]);
};

var fails$n = fails$t;
var isCallable$b = isCallable$h;
var replacement = /#|\.prototype\./;

var isForced$1 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$n(detection) : !!detection;
};

var normalize = isForced$1.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = 'N';
var POLYFILL = isForced$1.POLYFILL = 'P';
var isForced_1 = isForced$1;

var uncurryThis$q = functionUncurryThis;
var aCallable$5 = aCallable$7;
var NATIVE_BIND$1 = functionBindNative;
var bind$c = uncurryThis$q(uncurryThis$q.bind); // optional / simple context binding

var functionBindContext = function (fn, that) {
  aCallable$5(fn);
  return that === undefined ? fn : NATIVE_BIND$1 ? bind$c(fn, that) : function
    /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

var objectDefineProperty = {};

var DESCRIPTORS$f = descriptors;
var fails$m = fails$t; // V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334

var v8PrototypeDefineBug = DESCRIPTORS$f && fails$m(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {
    /* empty */
  }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var global$A = global$P;
var isObject$f = isObject$j;
var String$3 = global$A.String;
var TypeError$f = global$A.TypeError; // `Assert: Type(argument) is Object`

var anObject$d = function (argument) {
  if (isObject$f(argument)) return argument;
  throw TypeError$f(String$3(argument) + ' is not an object');
};

var global$z = global$P;
var DESCRIPTORS$e = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$c = anObject$d;
var toPropertyKey$2 = toPropertyKey$4;
var TypeError$e = global$z.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable'; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty

objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$2(P);
  anObject$c(Attributes);

  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);

    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }

  return $defineProperty$1(O, P, Attributes);
} : $defineProperty$1 : function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$2(P);
  anObject$c(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty$1(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError$e('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$d = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;
var createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var global$y = global$P;
var apply$5 = functionApply;
var uncurryThis$p = functionUncurryThis;
var isCallable$a = isCallable$h;
var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
var isForced = isForced_1;
var path$w = path$y;
var bind$b = functionBindContext;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$f = hasOwnProperty_1;

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();

        case 1:
          return new NativeConstructor(a);

        case 2:
          return new NativeConstructor(a, b);
      }

      return new NativeConstructor(a, b, c);
    }

    return apply$5(NativeConstructor, this, arguments);
  };

  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/


var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? global$y : STATIC ? global$y[TARGET] : (global$y[TARGET] || {}).prototype;
  var target = GLOBAL ? path$w : path$w[TARGET] || createNonEnumerableProperty$5(path$w, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native

    USE_NATIVE = !FORCED && nativeSource && hasOwn$f(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE) if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$7(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key]; // export native or implementation

    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue; // bind timers to global for call from export context

    if (options.bind && USE_NATIVE) resultProperty = bind$b(sourceProperty, global$y); // wrap global constructors for prevent changs in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods
    else if (PROTO && isCallable$a(sourceProperty)) resultProperty = uncurryThis$p(sourceProperty); // default case
    else resultProperty = sourceProperty; // add a flag to not completely full polyfills

    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$5(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty$5(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';

      if (!hasOwn$f(path$w, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty$5(path$w, VIRTUAL_PROTOTYPE, {});
      } // export virtual prototype methods


      createNonEnumerableProperty$5(path$w[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods

      if (options.real && targetPrototype && !targetPrototype[key]) {
        createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);
      }
    }
  }
};

var ceil = Math.ceil;
var floor$1 = Math.floor; // `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity

var toIntegerOrInfinity$4 = function (argument) {
  var number = +argument; // eslint-disable-next-line no-self-compare -- safe

  return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
};

var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$3 = Math.max;
var min$2 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

var toAbsoluteIndex$5 = function (index, length) {
  var integer = toIntegerOrInfinity$3(index);
  return integer < 0 ? max$3(integer + length, 0) : min$2(integer, length);
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$1 = Math.min; // `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength

var toLength$1 = function (argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength = toLength$1; // `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike

var lengthOfArrayLike$d = function (obj) {
  return toLength(obj.length);
};

var toIndexedObject$9 = toIndexedObject$b;
var toAbsoluteIndex$4 = toAbsoluteIndex$5;
var lengthOfArrayLike$c = lengthOfArrayLike$d; // `Array.prototype.{ indexOf, includes }` methods implementation

var createMethod$5 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$9($this);
    var length = lengthOfArrayLike$c(O);
    var index = toAbsoluteIndex$4(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$5(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$5(false)
};

var hiddenKeys$6 = {};

var uncurryThis$o = functionUncurryThis;
var hasOwn$e = hasOwnProperty_1;
var toIndexedObject$8 = toIndexedObject$b;
var indexOf$4 = arrayIncludes.indexOf;
var hiddenKeys$5 = hiddenKeys$6;
var push$5 = uncurryThis$o([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$8(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !hasOwn$e(hiddenKeys$5, key) && hasOwn$e(O, key) && push$5(result, key); // Don't enum bug & hidden keys


  while (names.length > i) if (hasOwn$e(O, key = names[i++])) {
    ~indexOf$4(result, key) || push$5(result, key);
  }

  return result;
};

var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3; // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe

var objectKeys$4 = Object.keys || function keys(O) {
  return internalObjectKeys$1(O, enumBugKeys$2);
};

var objectGetOwnPropertySymbols = {};

objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var DESCRIPTORS$c = descriptors;
var uncurryThis$n = functionUncurryThis;
var call$7 = functionCall;
var fails$l = fails$t;
var objectKeys$3 = objectKeys$4;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var toObject$c = toObject$e;
var IndexedObject$2 = indexedObject; // eslint-disable-next-line es/no-object-assign -- safe

var $assign = Object.assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

var defineProperty$d = Object.defineProperty;
var concat$6 = uncurryThis$n([].concat); // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign

var objectAssign = !$assign || fails$l(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS$c && $assign({
    b: 1
  }, $assign(defineProperty$d({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty$d(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

  var A = {};
  var B = {}; // eslint-disable-next-line es/no-symbol -- safe

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys$3($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject$c(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
  var propertyIsEnumerable = propertyIsEnumerableModule$1.f;

  while (argumentsLength > index) {
    var S = IndexedObject$2(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat$6(objectKeys$3(S), getOwnPropertySymbols(S)) : objectKeys$3(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS$c || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

var $$J = _export;
var assign$5 = objectAssign; // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing

$$J({
  target: 'Object',
  stat: true,
  forced: Object.assign !== assign$5
}, {
  assign: assign$5
});

var path$v = path$y;
var assign$4 = path$v.Object.assign;

var parent$1a = assign$4;
var assign$3 = parent$1a;

var assign$2 = assign$3;

var uncurryThis$m = functionUncurryThis;
var arraySlice$5 = uncurryThis$m([].slice);

var global$x = global$P;
var uncurryThis$l = functionUncurryThis;
var aCallable$4 = aCallable$7;
var isObject$e = isObject$j;
var hasOwn$d = hasOwnProperty_1;
var arraySlice$4 = arraySlice$5;
var NATIVE_BIND = functionBindNative;
var Function$2 = global$x.Function;
var concat$5 = uncurryThis$l([].concat);
var join = uncurryThis$l([].join);
var factories = {};

var construct$4 = function (C, argsLength, args) {
  if (!hasOwn$d(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';

    factories[argsLength] = Function$2('C,a', 'return new C(' + join(list, ',') + ')');
  }

  return factories[argsLength](C, args);
}; // `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind


var functionBind = NATIVE_BIND ? Function$2.bind : function bind(that
/* , ...args */
) {
  var F = aCallable$4(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice$4(arguments, 1);

  var boundFunction = function
    /* args... */
  bound() {
    var args = concat$5(partArgs, arraySlice$4(arguments));
    return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);
  };

  if (isObject$e(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};

var $$I = _export;
var bind$a = functionBind; // `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind

$$I({
  target: 'Function',
  proto: true,
  forced: Function.bind !== bind$a
}, {
  bind: bind$a
});

var path$u = path$y;

var entryVirtual$l = function (CONSTRUCTOR) {
  return path$u[CONSTRUCTOR + 'Prototype'];
};

var entryVirtual$k = entryVirtual$l;
var bind$9 = entryVirtual$k('Function').bind;

var isPrototypeOf$l = objectIsPrototypeOf;
var method$h = bind$9;
var FunctionPrototype$1 = Function.prototype;

var bind$8 = function (it) {
  var own = it.bind;
  return it === FunctionPrototype$1 || isPrototypeOf$l(FunctionPrototype$1, it) && own === FunctionPrototype$1.bind ? method$h : own;
};

var parent$19 = bind$8;
var bind$7 = parent$19;

var bind$6 = bind$7;

/**
 * Draw a circle.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the circle.
 */
function drawCircle(ctx, x, y, r) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI, false);
  ctx.closePath();
}
/**
 * Draw a square.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the square.
 */

function drawSquare(ctx, x, y, r) {
  ctx.beginPath();
  ctx.rect(x - r, y - r, r * 2, r * 2);
  ctx.closePath();
}
/**
 * Draw an equilateral triangle standing on a side.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */

function drawTriangle(ctx, x, y, r) {
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 1.15;
  y += 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle

  var h = Math.sqrt(s * s - s2 * s2); // height

  ctx.moveTo(x, y - (h - ir));
  ctx.lineTo(x + s2, y + ir);
  ctx.lineTo(x - s2, y + ir);
  ctx.lineTo(x, y - (h - ir));
  ctx.closePath();
}
/**
 * Draw an equilateral triangle standing on a vertex.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */

function drawTriangleDown(ctx, x, y, r) {
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 1.15;
  y -= 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle

  var h = Math.sqrt(s * s - s2 * s2); // height

  ctx.moveTo(x, y + (h - ir));
  ctx.lineTo(x + s2, y - ir);
  ctx.lineTo(x - s2, y - ir);
  ctx.lineTo(x, y + (h - ir));
  ctx.closePath();
}
/**
 * Draw a star.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The outer radius of the star.
 */

function drawStar(ctx, x, y, r) {
  // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 0.82;
  y += 0.1 * r;

  for (var n = 0; n < 10; n++) {
    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
  }

  ctx.closePath();
}
/**
 * Draw a diamond.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the diamond.
 * @remarks
 * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
 */

function drawDiamond(ctx, x, y, r) {
  ctx.beginPath();
  ctx.lineTo(x, y + r);
  ctx.lineTo(x + r, y);
  ctx.lineTo(x, y - r);
  ctx.lineTo(x - r, y);
  ctx.closePath();
}
/**
 * Draw a rectangle with rounded corners.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the rectangle.
 * @param h - The height of the rectangle.
 * @param r - The radius of the corners.
 * @remarks
 * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
 */

function drawRoundRect(ctx, x, y, w, h, r) {
  var r2d = Math.PI / 180;

  if (w - 2 * r < 0) {
    r = w / 2;
  } //ensure that the radius isn't too large for x


  if (h - 2 * r < 0) {
    r = h / 2;
  } //ensure that the radius isn't too large for y


  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
  ctx.lineTo(x + w, y + h - r);
  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
  ctx.lineTo(x + r, y + h);
  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
  ctx.lineTo(x, y + r);
  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
  ctx.closePath();
}
/**
 * Draw an ellipse.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the ellipse.
 * @param h - The height of the ellipse.
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 *
 * Postfix '_vis' added to discern it from standard method ellipse().
 */

function drawEllipse(ctx, x, y, w, h) {
  var kappa = 0.5522848,
      ox = w / 2 * kappa,
      // control point offset horizontal
  oy = h / 2 * kappa,
      // control point offset vertical
  xe = x + w,
      // x-end
  ye = y + h,
      // y-end
  xm = x + w / 2,
      // x-middle
  ym = y + h / 2; // y-middle

  ctx.beginPath();
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
}
/**
 * Draw an isometric cylinder.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the database.
 * @param h - The height of the database.
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 */

function drawDatabase(ctx, x, y, w, h) {
  var f = 1 / 3;
  var wEllipse = w;
  var hEllipse = h * f;
  var kappa = 0.5522848,
      ox = wEllipse / 2 * kappa,
      // control point offset horizontal
  oy = hEllipse / 2 * kappa,
      // control point offset vertical
  xe = x + wEllipse,
      // x-end
  ye = y + hEllipse,
      // y-end
  xm = x + wEllipse / 2,
      // x-middle
  ym = y + hEllipse / 2,
      // y-middle
  ymb = y + (h - hEllipse / 2),
      // y-midlle, bottom ellipse
  yeb = y + h; // y-end, bottom ellipse

  ctx.beginPath();
  ctx.moveTo(xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.lineTo(xe, ymb);
  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);
  ctx.lineTo(x, ym);
}
/**
 * Draw a dashed line.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The start position on the x axis.
 * @param y - The start position on the y axis.
 * @param x2 - The end position on the x axis.
 * @param y2 - The end position on the y axis.
 * @param pattern - List of lengths starting with line and then alternating between space and line.
 * @author David Jordan
 * @remarks
 * date 2012-08-08
 * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
 */

function drawDashedLine(ctx, x, y, x2, y2, pattern) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  var patternLength = pattern.length;
  var dx = x2 - x;
  var dy = y2 - y;
  var slope = dy / dx;
  var distRemaining = Math.sqrt(dx * dx + dy * dy);
  var patternIndex = 0;
  var draw = true;
  var xStep = 0;
  var dashLength = +pattern[0];

  while (distRemaining >= 0.1) {
    dashLength = +pattern[patternIndex++ % patternLength];

    if (dashLength > distRemaining) {
      dashLength = distRemaining;
    }

    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    xStep = dx < 0 ? -xStep : xStep;
    x += xStep;
    y += slope * xStep;

    if (draw === true) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
    }

    distRemaining -= dashLength;
    draw = !draw;
  }
}
/**
 * Draw a hexagon.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the hexagon.
 */

function drawHexagon(ctx, x, y, r) {
  ctx.beginPath();
  var sides = 6;
  var a = Math.PI * 2 / sides;
  ctx.moveTo(x + r, y);

  for (var i = 1; i < sides; i++) {
    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
  }

  ctx.closePath();
}
var shapeMap = {
  circle: drawCircle,
  dashedLine: drawDashedLine,
  database: drawDatabase,
  diamond: drawDiamond,
  ellipse: drawEllipse,
  ellipse_vis: drawEllipse,
  hexagon: drawHexagon,
  roundRect: drawRoundRect,
  square: drawSquare,
  star: drawStar,
  triangle: drawTriangle,
  triangleDown: drawTriangleDown
};
/**
 * Returns either custom or native drawing function base on supplied name.
 *
 * @param name - The name of the function. Either the name of a
 * CanvasRenderingContext2D property or an export from shapes.ts without the
 * draw prefix.
 * @returns The function that can be used for rendering. In case of native
 * CanvasRenderingContext2D function the API is normalized to
 * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.
 */

function getShape(name) {
  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {
    return shapeMap[name];
  } else {
    return function (ctx) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      CanvasRenderingContext2D.prototype[name].call(ctx, args);
    };
  }
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$6 = ".vis-overlay {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";
styleInject(css_248z$6);

var css_248z$5 = "/* override some bootstrap styles screwing up the timelines css */\n\n.vis [class*=\"span\"] {\n  min-height: 0;\n  width: auto;\n}\n";
styleInject(css_248z$5);

var css_248z$4 = "div.vis-color-picker {\n  position: absolute;\n  top: 0px;\n  left: 30px;\n  margin-top: -140px;\n  margin-left: 30px;\n  width: 310px;\n  height: 444px;\n  z-index: 1;\n  padding: 10px;\n  border-radius: 15px;\n  background-color: #ffffff;\n  display: none;\n  box-shadow: rgba(0, 0, 0, 0.5) 0px 0px 10px 0px;\n}\n\ndiv.vis-color-picker div.vis-arrow {\n  position: absolute;\n  top: 147px;\n  left: 5px;\n}\n\ndiv.vis-color-picker div.vis-arrow::after,\ndiv.vis-color-picker div.vis-arrow::before {\n  right: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\ndiv.vis-color-picker div.vis-arrow:after {\n  border-color: rgba(255, 255, 255, 0);\n  border-right-color: #ffffff;\n  border-width: 30px;\n  margin-top: -30px;\n}\n\ndiv.vis-color-picker div.vis-color {\n  position: absolute;\n  width: 289px;\n  height: 289px;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-brightness {\n  position: absolute;\n  top: 313px;\n}\n\ndiv.vis-color-picker div.vis-opacity {\n  position: absolute;\n  top: 350px;\n}\n\ndiv.vis-color-picker div.vis-selector {\n  position: absolute;\n  top: 137px;\n  left: 137px;\n  width: 15px;\n  height: 15px;\n  border-radius: 15px;\n  border: 1px solid #ffffff;\n  background: #4c4c4c; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #4c4c4c),\n    color-stop(12%, #595959),\n    color-stop(25%, #666666),\n    color-stop(39%, #474747),\n    color-stop(50%, #2c2c2c),\n    color-stop(51%, #000000),\n    color-stop(60%, #111111),\n    color-stop(76%, #2b2b2b),\n    color-stop(91%, #1c1c1c),\n    color-stop(100%, #131313)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */\n}\n\ndiv.vis-color-picker div.vis-new-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 159px;\n  text-align: right;\n  padding-right: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-initial-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 10px;\n  text-align: left;\n  padding-left: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-label {\n  position: absolute;\n  width: 300px;\n  left: 10px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-brightness {\n  top: 300px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-opacity {\n  top: 338px;\n}\n\ndiv.vis-color-picker div.vis-button {\n  position: absolute;\n  width: 68px;\n  height: 25px;\n  border-radius: 10px;\n  vertical-align: middle;\n  text-align: center;\n  line-height: 25px;\n  top: 410px;\n  border: 2px solid #d9d9d9;\n  background-color: #f7f7f7;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-button.vis-cancel {\n  /*border:2px solid #ff4e33;*/\n  /*background-color: #ff7761;*/\n  left: 5px;\n}\ndiv.vis-color-picker div.vis-button.vis-load {\n  /*border:2px solid #a153e6;*/\n  /*background-color: #cb8dff;*/\n  left: 82px;\n}\ndiv.vis-color-picker div.vis-button.vis-apply {\n  /*border:2px solid #4588e6;*/\n  /*background-color: #82b6ff;*/\n  left: 159px;\n}\ndiv.vis-color-picker div.vis-button.vis-save {\n  /*border:2px solid #45e655;*/\n  /*background-color: #6dff7c;*/\n  left: 236px;\n}\n\ndiv.vis-color-picker input.vis-range {\n  width: 290px;\n  height: 20px;\n}\n\n/* TODO: is this redundant?\ndiv.vis-color-picker input.vis-range-brightness {\n  width: 289px !important;\n}\n\n\ndiv.vis-color-picker input.vis-saturation-range {\n  width: 289px !important;\n}*/\n";
styleInject(css_248z$4);

var css_248z$3 = "div.vis-configuration {\n  position: relative;\n  display: block;\n  float: left;\n  font-size: 12px;\n}\n\ndiv.vis-configuration-wrapper {\n  display: block;\n  width: 700px;\n}\n\ndiv.vis-configuration-wrapper::after {\n  clear: both;\n  content: \"\";\n  display: block;\n}\n\ndiv.vis-configuration.vis-config-option-container {\n  display: block;\n  width: 495px;\n  background-color: #ffffff;\n  border: 2px solid #f7f8fa;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n}\n\ndiv.vis-configuration.vis-config-button {\n  display: block;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n  background-color: #f7f8fa;\n  border: 2px solid #ceced0;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n  cursor: pointer;\n  margin-bottom: 30px;\n}\n\ndiv.vis-configuration.vis-config-button.hover {\n  background-color: #4588e6;\n  border: 2px solid #214373;\n  color: #ffffff;\n}\n\ndiv.vis-configuration.vis-config-item {\n  display: block;\n  float: left;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-item.vis-config-s2 {\n  left: 10px;\n  background-color: #f7f8fa;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s3 {\n  left: 20px;\n  background-color: #e4e9f0;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s4 {\n  left: 30px;\n  background-color: #cfd8e6;\n  padding-left: 5px;\n  border-radius: 3px;\n}\n\ndiv.vis-configuration.vis-config-header {\n  font-size: 18px;\n  font-weight: bold;\n}\n\ndiv.vis-configuration.vis-config-label {\n  width: 120px;\n  height: 25px;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-label.vis-config-s3 {\n  width: 110px;\n}\ndiv.vis-configuration.vis-config-label.vis-config-s4 {\n  width: 100px;\n}\n\ndiv.vis-configuration.vis-config-colorBlock {\n  top: 1px;\n  width: 30px;\n  height: 19px;\n  border: 1px solid #444444;\n  border-radius: 2px;\n  padding: 0px;\n  margin: 0px;\n  cursor: pointer;\n}\n\ninput.vis-configuration.vis-config-checkbox {\n  left: -5px;\n}\n\ninput.vis-configuration.vis-config-rangeinput {\n  position: relative;\n  top: -5px;\n  width: 60px;\n  /*height:13px;*/\n  padding: 1px;\n  margin: 0;\n  pointer-events: none;\n}\n\ninput.vis-configuration.vis-config-range {\n  /*removes default webkit styles*/\n  -webkit-appearance: none;\n\n  /*fix for FF unable to apply focus style bug */\n  border: 0px solid white;\n  background-color: rgba(0, 0, 0, 0);\n\n  /*required for proper track sizing in FF*/\n  width: 300px;\n  height: 20px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-runnable-track {\n  width: 300px;\n  height: 5px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  border: 1px solid #14334b;\n  height: 17px;\n  width: 17px;\n  border-radius: 50%;\n  background: #3876c2; /* Old browsers */\n  background: -moz-linear-gradient(top, #3876c2 0%, #385380 100%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #3876c2),\n    color-stop(100%, #385380)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #3876c2 0%, #385380 100%); /* IE10+ */\n  background: linear-gradient(to bottom, #3876c2 0%, #385380 100%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */\n  box-shadow: #111927 0px 0px 1px 0px;\n  margin-top: -7px;\n}\ninput.vis-configuration.vis-config-range:focus {\n  outline: none;\n}\ninput.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {\n  background: #9d9d9d; /* Old browsers */\n  background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #9d9d9d),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #9d9d9d 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n}\n\ninput.vis-configuration.vis-config-range::-moz-range-track {\n  width: 300px;\n  height: 10px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-moz-range-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n\n  border-radius: 50%;\n  background: #385380;\n}\n\n/*hide the outline behind the border*/\ninput.vis-configuration.vis-config-range:-moz-focusring {\n  outline: 1px solid white;\n  outline-offset: -1px;\n}\n\ninput.vis-configuration.vis-config-range::-ms-track {\n  width: 300px;\n  height: 5px;\n\n  /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */\n  background: transparent;\n\n  /*leave room for the larger thumb to overflow with a transparent border */\n  border-color: transparent;\n  border-width: 6px 0;\n\n  /*remove default tick marks*/\n  color: transparent;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-lower {\n  background: #777;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-upper {\n  background: #ddd;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n  border-radius: 50%;\n  background: #385380;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-lower {\n  background: #888;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-upper {\n  background: #ccc;\n}\n\n.vis-configuration-popup {\n  position: absolute;\n  background: rgba(57, 76, 89, 0.85);\n  border: 2px solid #f2faff;\n  line-height: 30px;\n  height: 30px;\n  width: 150px;\n  text-align: center;\n  color: #ffffff;\n  font-size: 14px;\n  border-radius: 4px;\n  -webkit-transition: opacity 0.3s ease-in-out;\n  -moz-transition: opacity 0.3s ease-in-out;\n  transition: opacity 0.3s ease-in-out;\n}\n.vis-configuration-popup:after,\n.vis-configuration-popup:before {\n  left: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.vis-configuration-popup:after {\n  border-color: rgba(136, 183, 213, 0);\n  border-left-color: rgba(57, 76, 89, 0.85);\n  border-width: 8px;\n  margin-top: -8px;\n}\n.vis-configuration-popup:before {\n  border-color: rgba(194, 225, 245, 0);\n  border-left-color: #f2faff;\n  border-width: 12px;\n  margin-top: -12px;\n}\n";
styleInject(css_248z$3);

var css_248z$2 = "div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size: 14px;\n  color: #000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";
styleInject(css_248z$2);

var componentEmitter = {exports: {}};

(function (module) {
  /**
   * Expose `Emitter`.
   */
  {
    module.exports = Emitter;
  }
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */


  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    } // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.


    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1),
        callbacks = this._callbacks['$' + event];

    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */


  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };
})(componentEmitter);

var Emitter = componentEmitter.exports;

var wellKnownSymbol$h = wellKnownSymbol$j;
var TO_STRING_TAG$3 = wellKnownSymbol$h('toStringTag');
var test$2 = {};
test$2[TO_STRING_TAG$3] = 'z';
var toStringTagSupport = String(test$2) === '[object z]';

var global$w = global$P;
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$9 = isCallable$h;
var classofRaw = classofRaw$1;
var wellKnownSymbol$g = wellKnownSymbol$j;
var TO_STRING_TAG$2 = wellKnownSymbol$g('toStringTag');
var Object$7 = global$w.Object; // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof$e = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object$7(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && isCallable$9(O.callee) ? 'Arguments' : result;
};

var global$v = global$P;
var classof$d = classof$e;
var String$2 = global$v.String;

var toString$8 = function (argument) {
  if (classof$d(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String$2(argument);
};

var uncurryThis$k = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$7 = toString$8;
var requireObjectCoercible$2 = requireObjectCoercible$5;
var charAt$3 = uncurryThis$k(''.charAt);
var charCodeAt$1 = uncurryThis$k(''.charCodeAt);
var stringSlice = uncurryThis$k(''.slice);

var createMethod$4 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$7(requireObjectCoercible$2($this));
    var position = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt$1(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$3(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$4(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$4(true)
};

var uncurryThis$j = functionUncurryThis;
var isCallable$8 = isCallable$h;
var store$1 = sharedStore;
var functionToString = uncurryThis$j(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

if (!isCallable$8(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$2 = store$1.inspectSource;

var global$u = global$P;
var isCallable$7 = isCallable$h;
var inspectSource$1 = inspectSource$2;
var WeakMap$1 = global$u.WeakMap;
var nativeWeakMap = isCallable$7(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));

var shared$2 = shared$4.exports;
var uid$2 = uid$4;
var keys$7 = shared$2('keys');

var sharedKey$4 = function (key) {
  return keys$7[key] || (keys$7[key] = uid$2(key));
};

var NATIVE_WEAK_MAP$1 = nativeWeakMap;
var global$t = global$P;
var uncurryThis$i = functionUncurryThis;
var isObject$d = isObject$j;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var hasOwn$c = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$4 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$d = global$t.TypeError;
var WeakMap = global$t.WeakMap;
var set$3, get$6, has;

var enforce = function (it) {
  return has(it) ? get$6(it) : set$3(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject$d(it) || (state = get$6(it)).type !== TYPE) {
      throw TypeError$d('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (NATIVE_WEAK_MAP$1 || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap());
  var wmget = uncurryThis$i(store.get);
  var wmhas = uncurryThis$i(store.has);
  var wmset = uncurryThis$i(store.set);

  set$3 = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$d(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };

  get$6 = function (it) {
    return wmget(store, it) || {};
  };

  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$3('state');
  hiddenKeys$4[STATE] = true;

  set$3 = function (it, metadata) {
    if (hasOwn$c(it, STATE)) throw new TypeError$d(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$4(it, STATE, metadata);
    return metadata;
  };

  get$6 = function (it) {
    return hasOwn$c(it, STATE) ? it[STATE] : {};
  };

  has = function (it) {
    return hasOwn$c(it, STATE);
  };
}

var internalState = {
  set: set$3,
  get: get$6,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var DESCRIPTORS$b = descriptors;
var hasOwn$b = hasOwnProperty_1;
var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$b(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

var PROPER = EXISTS && function something() {
  /* empty */
}.name === 'something';

var CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype, 'name').configurable);
var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var objectDefineProperties = {};

var DESCRIPTORS$a = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$b = anObject$d;
var toIndexedObject$7 = toIndexedObject$b;
var objectKeys$2 = objectKeys$4; // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe

objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$b(O);
  var props = toIndexedObject$7(Properties);
  var keys = objectKeys$2(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) definePropertyModule$3.f(O, key = keys[index++], props[key]);

  return O;
};

var getBuiltIn$6 = getBuiltIn$9;
var html$1 = getBuiltIn$6('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */
var anObject$a = anObject$d;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$3 = hiddenKeys$6;
var html = html$1;
var documentCreateElement = documentCreateElement$1;
var sharedKey$2 = sharedKey$4;
var GT = '>';
var LT = '<';
var PROTOTYPE$1 = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$2('IE_PROTO');

var EmptyConstructor = function () {
  /* empty */
};

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak

  return temp;
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
}; // Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug


var activeXDocument;

var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) {
    /* ignore */
  }

  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

  var length = enumBugKeys$1.length;

  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];

  return NullProtoObject();
};

hiddenKeys$3[IE_PROTO$1] = true; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$a(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();

  return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);
};

var fails$k = fails$t;
var correctPrototypeGetter = !fails$k(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var global$s = global$P;
var hasOwn$a = hasOwnProperty_1;
var isCallable$6 = isCallable$h;
var toObject$b = toObject$e;
var sharedKey$1 = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var IE_PROTO = sharedKey$1('IE_PROTO');
var Object$6 = global$s.Object;
var ObjectPrototype$2 = Object$6.prototype; // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$6.getPrototypeOf : function (O) {
  var object = toObject$b(O);
  if (hasOwn$a(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;

  if (isCallable$6(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }

  return object instanceof Object$6 ? ObjectPrototype$2 : null;
};

var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

var redefine$4 = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty$3(target, key, value);
};

var fails$j = fails$t;
var isCallable$5 = isCallable$h;
var create$a = objectCreate;
var getPrototypeOf$8 = objectGetPrototypeOf;
var redefine$3 = redefine$4;
var wellKnownSymbol$f = wellKnownSymbol$j;
var ITERATOR$6 = wellKnownSymbol$f('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object

var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$8(getPrototypeOf$8(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$j(function () {
  var test = {}; // FF44- legacy iterators case

  return IteratorPrototype$1[ITERATOR$6].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};else IteratorPrototype$1 = create$a(IteratorPrototype$1); // `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

if (!isCallable$5(IteratorPrototype$1[ITERATOR$6])) {
  redefine$3(IteratorPrototype$1, ITERATOR$6, function () {
    return this;
  });
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$c = classof$e; // `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring

var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return '[object ' + classof$c(this) + ']';
};

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineProperty$c = objectDefineProperty.f;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var hasOwn$9 = hasOwnProperty_1;
var toString$6 = objectToString;
var wellKnownSymbol$e = wellKnownSymbol$j;
var TO_STRING_TAG$1 = wellKnownSymbol$e('toStringTag');

var setToStringTag$5 = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;

    if (!hasOwn$9(target, TO_STRING_TAG$1)) {
      defineProperty$c(target, TO_STRING_TAG$1, {
        configurable: true,
        value: TAG
      });
    }

    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty$2(target, 'toString', toString$6);
    }
  }
};

var iterators = {};

var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$9 = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;
var setToStringTag$4 = setToStringTag$5;
var Iterators$5 = iterators;

var returnThis$1 = function () {
  return this;
};

var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$9(IteratorPrototype, {
    next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)
  });
  setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators$5[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var global$r = global$P;
var isCallable$4 = isCallable$h;
var String$1 = global$r.String;
var TypeError$c = global$r.TypeError;

var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$4(argument)) return argument;
  throw TypeError$c("Can't set " + String$1(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */
var uncurryThis$h = functionUncurryThis;
var anObject$9 = anObject$d;
var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe

var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis$h(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject$9(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var $$H = _export;
var call$6 = functionCall;
var FunctionName = functionName;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$7 = objectGetPrototypeOf;
var setToStringTag$3 = setToStringTag$5;
var redefine$2 = redefine$4;
var wellKnownSymbol$d = wellKnownSymbol$j;
var Iterators$4 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$5 = wellKnownSymbol$d('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () {
  return this;
};

var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$5] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$7(anyNativeIterator.call(new Iterable()));

    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {


      setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      Iterators$4[TO_STRING_TAG] = returnThis;
    }
  } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    {
      INCORRECT_VALUES_NAME = true;

      defaultIterator = function values() {
        return call$6(nativeIterator, this);
      };
    }
  } // export additional methods


  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine$2(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$H({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  } // define iterator


  if ((FORCED) && IterablePrototype[ITERATOR$5] !== defaultIterator) {
    redefine$2(IterablePrototype, ITERATOR$5, defaultIterator, {
      name: DEFAULT
    });
  }

  Iterators$4[NAME] = defaultIterator;
  return methods;
};

var charAt$2 = stringMultibyte.charAt;
var toString$5 = toString$8;
var InternalStateModule$5 = internalState;
var defineIterator$2 = defineIterator$3;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator

defineIterator$2(String, 'String', function (iterated) {
  setInternalState$5(this, {
    type: STRING_ITERATOR,
    string: toString$5(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt$2(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

var call$5 = functionCall;
var anObject$8 = anObject$d;
var getMethod$1 = getMethod$3;

var iteratorClose$2 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$8(iterator);

  try {
    innerResult = getMethod$1(iterator, 'return');

    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }

    innerResult = call$5(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }

  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$8(innerResult);
  return value;
};

var anObject$7 = anObject$d;
var iteratorClose$1 = iteratorClose$2; // call something on iterator step with safe closing on error

var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject$7(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose$1(iterator, 'throw', error);
  }
};

var wellKnownSymbol$c = wellKnownSymbol$j;
var Iterators$3 = iterators;
var ITERATOR$4 = wellKnownSymbol$c('iterator');
var ArrayPrototype$i = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod$2 = function (it) {
  return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$i[ITERATOR$4] === it);
};

var uncurryThis$g = functionUncurryThis;
var fails$i = fails$t;
var isCallable$3 = isCallable$h;
var classof$b = classof$e;
var getBuiltIn$5 = getBuiltIn$9;
var inspectSource = inspectSource$2;

var noop = function () {
  /* empty */
};

var empty = [];
var construct$3 = getBuiltIn$5('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$g(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$3(argument)) return false;

  try {
    construct$3(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$3(argument)) return false;

  switch (classof$b(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction':
      return false;
  }

  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor

var isConstructor$4 = !construct$3 || fails$i(function () {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;

var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;

var createProperty$6 = function (object, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object) definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$1(0, value));else object[propertyKey] = value;
};

var classof$a = classof$e;
var getMethod = getMethod$3;
var Iterators$2 = iterators;
var wellKnownSymbol$b = wellKnownSymbol$j;
var ITERATOR$3 = wellKnownSymbol$b('iterator');

var getIteratorMethod$8 = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR$3) || getMethod(it, '@@iterator') || Iterators$2[classof$a(it)];
};

var global$q = global$P;
var call$4 = functionCall;
var aCallable$3 = aCallable$7;
var anObject$6 = anObject$d;
var tryToString$2 = tryToString$4;
var getIteratorMethod$7 = getIteratorMethod$8;
var TypeError$b = global$q.TypeError;

var getIterator$7 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;
  if (aCallable$3(iteratorMethod)) return anObject$6(call$4(iteratorMethod, argument));
  throw TypeError$b(tryToString$2(argument) + ' is not iterable');
};

var global$p = global$P;
var bind$5 = functionBindContext;
var call$3 = functionCall;
var toObject$a = toObject$e;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$3 = isConstructor$4;
var lengthOfArrayLike$b = lengthOfArrayLike$d;
var createProperty$5 = createProperty$6;
var getIterator$6 = getIterator$7;
var getIteratorMethod$6 = getIteratorMethod$8;
var Array$5 = global$p.Array; // `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from

var arrayFrom = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject$a(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$3(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind$5(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod$6(O);
  var index = 0;
  var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod && !(this == Array$5 && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator = getIterator$6(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];

    for (; !(step = call$3(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$5(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$b(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array$5(length);

    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$5(result, index, value);
    }
  }

  result.length = index;
  return result;
};

var wellKnownSymbol$a = wellKnownSymbol$j;
var ITERATOR$2 = wellKnownSymbol$a('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

var $$G = _export;
var from$6 = arrayFrom;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
}); // `Array.from` method
// https://tc39.es/ecma262/#sec-array.from

$$G({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from$6
});

var path$t = path$y;
var from$5 = path$t.Array.from;

var parent$18 = from$5;
var from$4 = parent$18;

var from$3 = from$4;

var toIndexedObject$6 = toIndexedObject$b;
var Iterators$1 = iterators;
var InternalStateModule$4 = internalState;
objectDefineProperty.f;
var defineIterator$1 = defineIterator$3;
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$1 = InternalStateModule$4.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator

defineIterator$1(Array, 'Array', function (iterated, kind) {
  setInternalState$4(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$6(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject

Iterators$1.Arguments = Iterators$1.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var getIteratorMethod$5 = getIteratorMethod$8;
var getIteratorMethod_1 = getIteratorMethod$5;

// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

var DOMIterables$4 = domIterables;
var global$o = global$P;
var classof$9 = classof$e;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var Iterators = iterators;
var wellKnownSymbol$9 = wellKnownSymbol$j;
var TO_STRING_TAG = wellKnownSymbol$9('toStringTag');

for (var COLLECTION_NAME in DOMIterables$4) {
  var Collection = global$o[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype && classof$9(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }

  Iterators[COLLECTION_NAME] = Iterators.Array;
}

var parent$17 = getIteratorMethod_1;
var getIteratorMethod$4 = parent$17;

var parent$16 = getIteratorMethod$4;
var getIteratorMethod$3 = parent$16;

var parent$15 = getIteratorMethod$3;
var getIteratorMethod$2 = parent$15;

var getIteratorMethod$1 = getIteratorMethod$2;

var classof$8 = classofRaw$1; // `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe

var isArray$d = Array.isArray || function isArray(argument) {
  return classof$8(argument) == 'Array';
};

var objectGetOwnPropertyNames = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe

objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys$2);
};

var objectGetOwnPropertyNamesExternal = {};

var global$n = global$P;
var toAbsoluteIndex$3 = toAbsoluteIndex$5;
var lengthOfArrayLike$a = lengthOfArrayLike$d;
var createProperty$4 = createProperty$6;
var Array$4 = global$n.Array;
var max$2 = Math.max;

var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$a(O);
  var k = toAbsoluteIndex$3(start, length);
  var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);
  var result = Array$4(max$2(fin - k, 0));

  for (var n = 0; k < fin; k++, n++) createProperty$4(result, n, O[k]);

  result.length = n;
  return result;
};

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof$7 = classofRaw$1;
var toIndexedObject$5 = toIndexedObject$b;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$3 = arraySliceSimple;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error) {
    return arraySlice$3(windowNames);
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
  return windowNames && classof$7(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$5(it));
};

var wellKnownSymbolWrapped = {};

var wellKnownSymbol$8 = wellKnownSymbol$j;
wellKnownSymbolWrapped.f = wellKnownSymbol$8;

var path$s = path$y;
var hasOwn$8 = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$b = objectDefineProperty.f;

var defineWellKnownSymbol$l = function (NAME) {
  var Symbol = path$s.Symbol || (path$s.Symbol = {});
  if (!hasOwn$8(Symbol, NAME)) defineProperty$b(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule$1.f(NAME)
  });
};

var global$m = global$P;
var isArray$c = isArray$d;
var isConstructor$2 = isConstructor$4;
var isObject$c = isObject$j;
var wellKnownSymbol$7 = wellKnownSymbol$j;
var SPECIES$3 = wellKnownSymbol$7('species');
var Array$3 = global$m.Array; // a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

var arraySpeciesConstructor$1 = function (originalArray) {
  var C;

  if (isArray$c(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (isConstructor$2(C) && (C === Array$3 || isArray$c(C.prototype))) C = undefined;else if (isObject$c(C)) {
      C = C[SPECIES$3];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array$3 : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1; // `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate$4 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind$4 = functionBindContext;
var uncurryThis$f = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$9 = toObject$e;
var lengthOfArrayLike$9 = lengthOfArrayLike$d;
var arraySpeciesCreate$3 = arraySpeciesCreate$4;
var push$4 = uncurryThis$f([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

var createMethod$3 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$9($this);
    var self = IndexedObject$1(O);
    var boundFunction = bind$4(callbackfn, that);
    var length = lengthOfArrayLike$9(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate$3;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);

      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3:
            return true;
          // some

          case 5:
            return value;
          // find

          case 6:
            return index;
          // findIndex

          case 2:
            push$4(target, value);
          // filter
        } else switch (TYPE) {
          case 4:
            return false;
          // every

          case 7:
            push$4(target, value);
          // filterReject
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$3(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$3(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$3(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$3(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$3(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$3(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$3(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$3(7)
};

var $$F = _export;
var global$l = global$P;
var getBuiltIn$4 = getBuiltIn$9;
var apply$4 = functionApply;
var call$2 = functionCall;
var uncurryThis$e = functionUncurryThis;
var DESCRIPTORS$9 = descriptors;
var NATIVE_SYMBOL = nativeSymbol;
var fails$h = fails$t;
var hasOwn$7 = hasOwnProperty_1;
var isArray$b = isArray$d;
var isCallable$2 = isCallable$h;
var isObject$b = isObject$j;
var isPrototypeOf$k = objectIsPrototypeOf;
var isSymbol = isSymbol$3;
var anObject$5 = anObject$d;
var toObject$8 = toObject$e;
var toIndexedObject$4 = toIndexedObject$b;
var toPropertyKey = toPropertyKey$4;
var $toString = toString$8;
var createPropertyDescriptor = createPropertyDescriptor$5;
var nativeObjectCreate = objectCreate;
var objectKeys$1 = objectKeys$4;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var arraySlice$2 = arraySlice$5;
var redefine$1 = redefine$4;
var shared = shared$4.exports;
var sharedKey = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$1 = uid$4;
var wellKnownSymbol$6 = wellKnownSymbol$j;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$k = defineWellKnownSymbol$l;
var setToStringTag$2 = setToStringTag$5;
var InternalStateModule$3 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol$6('toPrimitive');
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState = InternalStateModule$3.getterFor(SYMBOL);
var ObjectPrototype$1 = Object[PROTOTYPE];
var $Symbol = global$l.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError$a = global$l.TypeError;
var QObject = global$l.QObject;
var $stringify$1 = getBuiltIn$4('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;
var nativeDefineProperty = definePropertyModule$1.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push$3 = uncurryThis$e([].push);
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks'); // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = DESCRIPTORS$9 && fails$h(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () {
      return nativeDefineProperty(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
  nativeDefineProperty(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap$1 = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState$3(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS$9) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject$5(O);
  var key = toPropertyKey(P);
  anObject$5(Attributes);

  if (hasOwn$7(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$7(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$7(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject$5(O);
  var properties = toIndexedObject$4(Properties);
  var keys = objectKeys$1(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys, function (key) {
    if (!DESCRIPTORS$9 || call$2($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call$2(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype$1 && hasOwn$7(AllSymbols, P) && !hasOwn$7(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn$7(this, P) || !hasOwn$7(AllSymbols, P) || hasOwn$7(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject$4(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype$1 && hasOwn$7(AllSymbols, key) && !hasOwn$7(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && hasOwn$7(AllSymbols, key) && !(hasOwn$7(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (!hasOwn$7(AllSymbols, key) && !hasOwn$7(hiddenKeys$1, key)) push$3(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (hasOwn$7(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$7(ObjectPrototype$1, key))) {
      push$3(result, AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor


if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf$k(SymbolPrototype, this)) throw TypeError$a('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid$1(description);

    var setter = function (value) {
      if (this === ObjectPrototype$1) call$2(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$7(this, HIDDEN) && hasOwn$7(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (DESCRIPTORS$9 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, {
      configurable: true,
      set: setter
    });
    return wrap$1(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];
  redefine$1(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });
  redefine$1($Symbol, 'withoutSetter', function (description) {
    return wrap$1(uid$1(description), description);
  });
  propertyIsEnumerableModule.f = $propertyIsEnumerable$1;
  definePropertyModule$1.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$1.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap$1(wellKnownSymbol$6(name), name);
  };

  if (DESCRIPTORS$9) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
  }
}

$$F({
  global: true,
  wrap: true,
  forced: !NATIVE_SYMBOL,
  sham: !NATIVE_SYMBOL
}, {
  Symbol: $Symbol
});
$forEach$1(objectKeys$1(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol$k(name);
});
$$F({
  target: SYMBOL,
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = $toString(key);
    if (hasOwn$7(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError$a(sym + ' is not a symbol');
    if (hasOwn$7(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () {
    USE_SETTER = true;
  },
  useSimple: function () {
    USE_SETTER = false;
  }
});
$$F({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL,
  sham: !DESCRIPTORS$9
}, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$F({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

$$F({
  target: 'Object',
  stat: true,
  forced: fails$h(function () {
    getOwnPropertySymbolsModule$1.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule$1.f(toObject$8(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify

if ($stringify$1) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$h(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return $stringify$1([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || $stringify$1({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || $stringify$1(Object(symbol)) != '{}';
  });
  $$F({
    target: 'JSON',
    stat: true,
    forced: FORCED_JSON_STRINGIFY
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice$2(arguments);
      var $replacer = replacer;
      if (!isObject$b(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!isArray$b(replacer)) replacer = function (key, value) {
        if (isCallable$2($replacer)) value = call$2($replacer, this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return apply$4($stringify$1, null, args);
    }
  });
} // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


if (!SymbolPrototype[TO_PRIMITIVE]) {
  var valueOf = SymbolPrototype.valueOf; // eslint-disable-next-line no-unused-vars -- required for .length

  redefine$1(SymbolPrototype, TO_PRIMITIVE, function (hint) {
    // TODO: improve hint logic
    return call$2(valueOf, this);
  });
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag$2($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;

var path$r = path$y;
var getOwnPropertySymbols$2 = path$r.Object.getOwnPropertySymbols;

var parent$14 = getOwnPropertySymbols$2;
var getOwnPropertySymbols$1 = parent$14;

var getOwnPropertySymbols = getOwnPropertySymbols$1;

var getOwnPropertyDescriptor$6 = {exports: {}};

var $$E = _export;
var fails$g = fails$t;
var toIndexedObject$3 = toIndexedObject$b;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$8 = descriptors;
var FAILS_ON_PRIMITIVES$4 = fails$g(function () {
  nativeGetOwnPropertyDescriptor(1);
});
var FORCED$6 = !DESCRIPTORS$8 || FAILS_ON_PRIMITIVES$4; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

$$E({
  target: 'Object',
  stat: true,
  forced: FORCED$6,
  sham: !DESCRIPTORS$8
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject$3(it), key);
  }
});

var path$q = path$y;
var Object$5 = path$q.Object;

var getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor(it, key) {
  return Object$5.getOwnPropertyDescriptor(it, key);
};

if (Object$5.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$5.sham = true;

var parent$13 = getOwnPropertyDescriptor$6.exports;
var getOwnPropertyDescriptor$4 = parent$13;

var getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$4;

var getBuiltIn$3 = getBuiltIn$9;
var uncurryThis$d = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$4 = anObject$d;
var concat$4 = uncurryThis$d([].concat); // all object keys, includes non-enumerable and symbols

var ownKeys$a = getBuiltIn$3('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule$1.f(anObject$4(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$4(keys, getOwnPropertySymbols(it)) : keys;
};

var $$D = _export;
var DESCRIPTORS$7 = descriptors;
var ownKeys$9 = ownKeys$a;
var toIndexedObject$2 = toIndexedObject$b;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var createProperty$3 = createProperty$6; // `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors

$$D({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS$7
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject$2(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
    var keys = ownKeys$9(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty$3(result, key, descriptor);
    }

    return result;
  }
});

var path$p = path$y;
var getOwnPropertyDescriptors$2 = path$p.Object.getOwnPropertyDescriptors;

var parent$12 = getOwnPropertyDescriptors$2;
var getOwnPropertyDescriptors$1 = parent$12;

var getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;

var defineProperties$4 = {exports: {}};

var $$C = _export;
var DESCRIPTORS$6 = descriptors;
var defineProperties$3 = objectDefineProperties.f; // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe

$$C({
  target: 'Object',
  stat: true,
  forced: Object.defineProperties !== defineProperties$3,
  sham: !DESCRIPTORS$6
}, {
  defineProperties: defineProperties$3
});

var path$o = path$y;
var Object$4 = path$o.Object;

var defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {
  return Object$4.defineProperties(T, D);
};

if (Object$4.defineProperties.sham) defineProperties$2.sham = true;

var parent$11 = defineProperties$4.exports;
var defineProperties$1 = parent$11;

var defineProperties = defineProperties$1;

var defineProperty$a = {exports: {}};

var $$B = _export;
var DESCRIPTORS$5 = descriptors;
var defineProperty$9 = objectDefineProperty.f; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe

$$B({
  target: 'Object',
  stat: true,
  forced: Object.defineProperty !== defineProperty$9,
  sham: !DESCRIPTORS$5
}, {
  defineProperty: defineProperty$9
});

var path$n = path$y;
var Object$3 = path$n.Object;

var defineProperty$8 = defineProperty$a.exports = function defineProperty(it, key, desc) {
  return Object$3.defineProperty(it, key, desc);
};

if (Object$3.defineProperty.sham) defineProperty$8.sham = true;

var parent$10 = defineProperty$a.exports;
var defineProperty$7 = parent$10;

var defineProperty$6 = defineProperty$7;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var parent$$ = defineProperty$7;
var defineProperty$5 = parent$$;

var parent$_ = defineProperty$5;
var defineProperty$4 = parent$_;

var defineProperty$3 = defineProperty$4;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;

    defineProperty$3(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);

  defineProperty$3(Constructor, "prototype", {
    writable: false
  });

  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    defineProperty$3(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var $$A = _export;
var isArray$a = isArray$d; // `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray

$$A({
  target: 'Array',
  stat: true
}, {
  isArray: isArray$a
});

var path$m = path$y;
var isArray$9 = path$m.Array.isArray;

var parent$Z = isArray$9;
var isArray$8 = parent$Z;

var parent$Y = isArray$8;
var isArray$7 = parent$Y;

var parent$X = isArray$7;
var isArray$6 = parent$X;

var isArray$5 = isArray$6;

function _arrayWithHoles(arr) {
  if (isArray$5(arr)) return arr;
}

var fails$f = fails$t;
var wellKnownSymbol$5 = wellKnownSymbol$j;
var V8_VERSION$1 = engineV8Version;
var SPECIES$2 = wellKnownSymbol$5('species');

var arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION$1 >= 51 || !fails$f(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES$2] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var $$z = _export;
var global$k = global$P;
var fails$e = fails$t;
var isArray$4 = isArray$d;
var isObject$a = isObject$j;
var toObject$7 = toObject$e;
var lengthOfArrayLike$8 = lengthOfArrayLike$d;
var createProperty$2 = createProperty$6;
var arraySpeciesCreate$2 = arraySpeciesCreate$4;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$4 = wellKnownSymbol$j;
var V8_VERSION = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$4('isConcatSpreadable');
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
var TypeError$9 = global$k.TypeError; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$e(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$4('concat');

var isConcatSpreadable = function (O) {
  if (!isObject$a(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray$4(O);
};

var FORCED$5 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

$$z({
  target: 'Array',
  proto: true,
  forced: FORCED$5
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$7(this);
    var A = arraySpeciesCreate$2(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$8(E);
        if (n + len > MAX_SAFE_INTEGER$1) throw TypeError$9(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) if (k in E) createProperty$2(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER$1) throw TypeError$9(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty$2(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

var defineWellKnownSymbol$j = defineWellKnownSymbol$l; // `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator

defineWellKnownSymbol$j('asyncIterator');

var defineWellKnownSymbol$i = defineWellKnownSymbol$l; // `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance

defineWellKnownSymbol$i('hasInstance');

var defineWellKnownSymbol$h = defineWellKnownSymbol$l; // `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable

defineWellKnownSymbol$h('isConcatSpreadable');

var defineWellKnownSymbol$g = defineWellKnownSymbol$l; // `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator

defineWellKnownSymbol$g('iterator');

var defineWellKnownSymbol$f = defineWellKnownSymbol$l; // `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match

defineWellKnownSymbol$f('match');

var defineWellKnownSymbol$e = defineWellKnownSymbol$l; // `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall

defineWellKnownSymbol$e('matchAll');

var defineWellKnownSymbol$d = defineWellKnownSymbol$l; // `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace

defineWellKnownSymbol$d('replace');

var defineWellKnownSymbol$c = defineWellKnownSymbol$l; // `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search

defineWellKnownSymbol$c('search');

var defineWellKnownSymbol$b = defineWellKnownSymbol$l; // `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species

defineWellKnownSymbol$b('species');

var defineWellKnownSymbol$a = defineWellKnownSymbol$l; // `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split

defineWellKnownSymbol$a('split');

var defineWellKnownSymbol$9 = defineWellKnownSymbol$l; // `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive

defineWellKnownSymbol$9('toPrimitive');

var defineWellKnownSymbol$8 = defineWellKnownSymbol$l; // `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag

defineWellKnownSymbol$8('toStringTag');

var defineWellKnownSymbol$7 = defineWellKnownSymbol$l; // `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables

defineWellKnownSymbol$7('unscopables');

var global$j = global$P;
var setToStringTag$1 = setToStringTag$5; // JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag

setToStringTag$1(global$j.JSON, 'JSON', true);

var path$l = path$y;
var symbol$5 = path$l.Symbol;

var parent$W = symbol$5;
var symbol$4 = parent$W;

var parent$V = symbol$4;
var symbol$3 = parent$V;

var defineWellKnownSymbol$6 = defineWellKnownSymbol$l; // `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-using-statement

defineWellKnownSymbol$6('asyncDispose');

var defineWellKnownSymbol$5 = defineWellKnownSymbol$l; // `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-using-statement

defineWellKnownSymbol$5('dispose');

var defineWellKnownSymbol$4 = defineWellKnownSymbol$l; // `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching

defineWellKnownSymbol$4('matcher');

var defineWellKnownSymbol$3 = defineWellKnownSymbol$l; // `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators

defineWellKnownSymbol$3('metadata');

var defineWellKnownSymbol$2 = defineWellKnownSymbol$l; // `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable

defineWellKnownSymbol$2('observable');

var defineWellKnownSymbol$1 = defineWellKnownSymbol$l; // `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching

defineWellKnownSymbol$1('patternMatch');

var defineWellKnownSymbol = defineWellKnownSymbol$l;
defineWellKnownSymbol('replaceAll');

var parent$U = symbol$3; // TODO: Remove from `core-js@4`
// TODO: Remove from `core-js@4`

var symbol$2 = parent$U;

var symbol$1 = symbol$2;

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof symbol$1 !== "undefined" && getIteratorMethod$1(arr) || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var $$y = _export;
var global$i = global$P;
var isArray$3 = isArray$d;
var isConstructor$1 = isConstructor$4;
var isObject$9 = isObject$j;
var toAbsoluteIndex$2 = toAbsoluteIndex$5;
var lengthOfArrayLike$7 = lengthOfArrayLike$d;
var toIndexedObject$1 = toIndexedObject$b;
var createProperty$1 = createProperty$6;
var wellKnownSymbol$3 = wellKnownSymbol$j;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var un$Slice = arraySlice$5;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3('slice');
var SPECIES$1 = wellKnownSymbol$3('species');
var Array$2 = global$i.Array;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

$$y({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$3
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject$1(this);
    var length = lengthOfArrayLike$7(O);
    var k = toAbsoluteIndex$2(start, length);
    var fin = toAbsoluteIndex$2(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray$3(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (isConstructor$1(Constructor) && (Constructor === Array$2 || isArray$3(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject$9(Constructor)) {
        Constructor = Constructor[SPECIES$1];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array$2 || Constructor === undefined) {
        return un$Slice(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array$2 : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$1(result, n, O[k]);

    result.length = n;
    return result;
  }
});

var entryVirtual$j = entryVirtual$l;
var slice$6 = entryVirtual$j('Array').slice;

var isPrototypeOf$j = objectIsPrototypeOf;
var method$g = slice$6;
var ArrayPrototype$h = Array.prototype;

var slice$5 = function (it) {
  var own = it.slice;
  return it === ArrayPrototype$h || isPrototypeOf$j(ArrayPrototype$h, it) && own === ArrayPrototype$h.slice ? method$g : own;
};

var parent$T = slice$5;
var slice$4 = parent$T;

var parent$S = slice$4;
var slice$3 = parent$S;

var parent$R = slice$3;
var slice$2 = parent$R;

var slice$1 = slice$2;

var parent$Q = from$4;
var from$2 = parent$Q;

var parent$P = from$2;
var from$1 = parent$P;

var from = from$1;

function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$9(o, minLen) {
  var _context;

  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);

  var n = slice$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);

  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest();
}

var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var iterator$5 = WrappedWellKnownSymbolModule.f('iterator');

var parent$O = iterator$5;
var iterator$4 = parent$O;

var parent$N = iterator$4;
var iterator$3 = parent$N;

var parent$M = iterator$3;
var iterator$2 = parent$M;

var iterator$1 = iterator$2;

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof symbol$1 && "symbol" == typeof iterator$1 ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _arrayWithoutHoles(arr) {
  if (isArray$5(arr)) return _arrayLikeToArray$9(arr);
}

function _iterableToArray(iter) {
  if (typeof symbol$1 !== "undefined" && getIteratorMethod$1(iter) != null || iter["@@iterator"] != null) return from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread();
}

var symbol = symbol$4;

var entryVirtual$i = entryVirtual$l;
var concat$3 = entryVirtual$i('Array').concat;

var isPrototypeOf$i = objectIsPrototypeOf;
var method$f = concat$3;
var ArrayPrototype$g = Array.prototype;

var concat$2 = function (it) {
  var own = it.concat;
  return it === ArrayPrototype$g || isPrototypeOf$i(ArrayPrototype$g, it) && own === ArrayPrototype$g.concat ? method$f : own;
};

var parent$L = concat$2;
var concat$1 = parent$L;

var concat = concat$1;

var slice = slice$4;

var $$x = _export;
var ownKeys$8 = ownKeys$a; // `Reflect.ownKeys` method
// https://tc39.es/ecma262/#sec-reflect.ownkeys

$$x({
  target: 'Reflect',
  stat: true
}, {
  ownKeys: ownKeys$8
});

var path$k = path$y;
var ownKeys$7 = path$k.Reflect.ownKeys;

var parent$K = ownKeys$7;
var ownKeys$6 = parent$K;

var ownKeys$5 = ownKeys$6;

var isArray$2 = isArray$8;

var $$w = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2('map'); // `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species

$$w({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$2
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$h = entryVirtual$l;
var map$6 = entryVirtual$h('Array').map;

var isPrototypeOf$h = objectIsPrototypeOf;
var method$e = map$6;
var ArrayPrototype$f = Array.prototype;

var map$5 = function (it) {
  var own = it.map;
  return it === ArrayPrototype$f || isPrototypeOf$h(ArrayPrototype$f, it) && own === ArrayPrototype$f.map ? method$e : own;
};

var parent$J = map$5;
var map$4 = parent$J;

var map$3 = map$4;

var $$v = _export;
var toObject$6 = toObject$e;
var nativeKeys = objectKeys$4;
var fails$d = fails$t;
var FAILS_ON_PRIMITIVES$3 = fails$d(function () {
  nativeKeys(1);
}); // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys

$$v({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$3
}, {
  keys: function keys(it) {
    return nativeKeys(toObject$6(it));
  }
});

var path$j = path$y;
var keys$6 = path$j.Object.keys;

var parent$I = keys$6;
var keys$5 = parent$I;

var keys$4 = keys$5;

var $$u = _export;
var global$h = global$P;
var uncurryThis$c = functionUncurryThis;
var Date$1 = global$h.Date;
var getTime = uncurryThis$c(Date$1.prototype.getTime); // `Date.now` method
// https://tc39.es/ecma262/#sec-date.now

$$u({
  target: 'Date',
  stat: true
}, {
  now: function now() {
    return getTime(new Date$1());
  }
});

var path$i = path$y;
var now$3 = path$i.Date.now;

var parent$H = now$3;
var now$2 = parent$H;

var now$1 = now$2;

var fails$c = fails$t;

var arrayMethodIsStrict$6 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$c(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () {
      return 1;
    }, 1);
  });
};

var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$6;
var STRICT_METHOD$5 = arrayMethodIsStrict$5('forEach'); // `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach

var arrayForEach = !STRICT_METHOD$5 ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;

var $$t = _export;
var forEach$6 = arrayForEach; // `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe

$$t({
  target: 'Array',
  proto: true,
  forced: [].forEach != forEach$6
}, {
  forEach: forEach$6
});

var entryVirtual$g = entryVirtual$l;
var forEach$5 = entryVirtual$g('Array').forEach;

var parent$G = forEach$5;
var forEach$4 = parent$G;

var classof$6 = classof$e;
var hasOwn$6 = hasOwnProperty_1;
var isPrototypeOf$g = objectIsPrototypeOf;
var method$d = forEach$4;
var ArrayPrototype$e = Array.prototype;
var DOMIterables$3 = {
  DOMTokenList: true,
  NodeList: true
};

var forEach$3 = function (it) {
  var own = it.forEach;
  return it === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.forEach || hasOwn$6(DOMIterables$3, classof$6(it)) ? method$d : own;
};

var forEach$2 = forEach$3;

var $$s = _export;
var uncurryThis$b = functionUncurryThis;
var isArray$1 = isArray$d;
var un$Reverse = uncurryThis$b([].reverse);
var test$1 = [1, 2]; // `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794

$$s({
  target: 'Array',
  proto: true,
  forced: String(test$1) === String(test$1.reverse())
}, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray$1(this)) this.length = this.length;
    return un$Reverse(this);
  }
});

var entryVirtual$f = entryVirtual$l;
var reverse$3 = entryVirtual$f('Array').reverse;

var isPrototypeOf$f = objectIsPrototypeOf;
var method$c = reverse$3;
var ArrayPrototype$d = Array.prototype;

var reverse$2 = function (it) {
  var own = it.reverse;
  return it === ArrayPrototype$d || isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.reverse ? method$c : own;
};

var parent$F = reverse$2;
var reverse$1 = parent$F;

var reverse = reverse$1;

var $$r = _export;
var global$g = global$P;
var toAbsoluteIndex$1 = toAbsoluteIndex$5;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var lengthOfArrayLike$6 = lengthOfArrayLike$d;
var toObject$5 = toObject$e;
var arraySpeciesCreate$1 = arraySpeciesCreate$4;
var createProperty = createProperty$6;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('splice');
var TypeError$8 = global$g.TypeError;
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species

$$r({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$1
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject$5(this);
    var len = lengthOfArrayLike$6(O);
    var actualStart = toAbsoluteIndex$1(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError$8(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate$1(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var entryVirtual$e = entryVirtual$l;
var splice$4 = entryVirtual$e('Array').splice;

var isPrototypeOf$e = objectIsPrototypeOf;
var method$b = splice$4;
var ArrayPrototype$c = Array.prototype;

var splice$3 = function (it) {
  var own = it.splice;
  return it === ArrayPrototype$c || isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.splice ? method$b : own;
};

var parent$E = splice$3;
var splice$2 = parent$E;

var splice$1 = splice$2;

var $$q = _export;
var $includes = arrayIncludes.includes;
// https://tc39.es/ecma262/#sec-array.prototype.includes

$$q({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var entryVirtual$d = entryVirtual$l;
var includes$4 = entryVirtual$d('Array').includes;

var isObject$8 = isObject$j;
var classof$5 = classofRaw$1;
var wellKnownSymbol$2 = wellKnownSymbol$j;
var MATCH$1 = wellKnownSymbol$2('match'); // `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp

var isRegexp = function (it) {
  var isRegExp;
  return isObject$8(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$5(it) == 'RegExp');
};

var global$f = global$P;
var isRegExp = isRegexp;
var TypeError$7 = global$f.TypeError;

var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw TypeError$7("The method doesn't accept regular expressions");
  }

  return it;
};

var wellKnownSymbol$1 = wellKnownSymbol$j;
var MATCH = wellKnownSymbol$1('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) {
      /* empty */
    }
  }

  return false;
};

var $$p = _export;
var uncurryThis$a = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible$1 = requireObjectCoercible$5;
var toString$4 = toString$8;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$a(''.indexOf); // `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes

$$p({
  target: 'String',
  proto: true,
  forced: !correctIsRegExpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~stringIndexOf(toString$4(requireObjectCoercible$1(this)), toString$4(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$c = entryVirtual$l;
var includes$3 = entryVirtual$c('String').includes;

var isPrototypeOf$d = objectIsPrototypeOf;
var arrayMethod = includes$4;
var stringMethod = includes$3;
var ArrayPrototype$b = Array.prototype;
var StringPrototype = String.prototype;

var includes$2 = function (it) {
  var own = it.includes;
  if (it === ArrayPrototype$b || isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.includes) return arrayMethod;

  if (typeof it == 'string' || it === StringPrototype || isPrototypeOf$d(StringPrototype, it) && own === StringPrototype.includes) {
    return stringMethod;
  }

  return own;
};

var parent$D = includes$2;
var includes$1 = parent$D;

var includes = includes$1;

var $$o = _export;
var fails$b = fails$t;
var toObject$4 = toObject$e;
var nativeGetPrototypeOf = objectGetPrototypeOf;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$2 = fails$b(function () {
  nativeGetPrototypeOf(1);
}); // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

$$o({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$2,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$4(it));
  }
});

var path$h = path$y;
var getPrototypeOf$6 = path$h.Object.getPrototypeOf;

var parent$C = getPrototypeOf$6;
var getPrototypeOf$5 = parent$C;

var getPrototypeOf$4 = getPrototypeOf$5;

var $$n = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species

$$n({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$b = entryVirtual$l;
var filter$3 = entryVirtual$b('Array').filter;

var isPrototypeOf$c = objectIsPrototypeOf;
var method$a = filter$3;
var ArrayPrototype$a = Array.prototype;

var filter$2 = function (it) {
  var own = it.filter;
  return it === ArrayPrototype$a || isPrototypeOf$c(ArrayPrototype$a, it) && own === ArrayPrototype$a.filter ? method$a : own;
};

var parent$B = filter$2;
var filter$1 = parent$B;

var filter = filter$1;

var DESCRIPTORS$4 = descriptors;
var uncurryThis$9 = functionUncurryThis;
var objectKeys = objectKeys$4;
var toIndexedObject = toIndexedObject$b;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable = uncurryThis$9($propertyIsEnumerable);
var push$2 = uncurryThis$9([].push); // `Object.{ entries, values }` methods implementation

var createMethod$2 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS$4 || propertyIsEnumerable(O, key)) {
        push$2(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod$2(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod$2(false)
};

var $$m = _export;
var $values = objectToArray.values; // `Object.values` method
// https://tc39.es/ecma262/#sec-object.values

$$m({
  target: 'Object',
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});

var path$g = path$y;
path$g.Object.values;

var whitespaces$4 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var uncurryThis$8 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$5;
var toString$3 = toString$8;
var whitespaces$3 = whitespaces$4;
var replace$1 = uncurryThis$8(''.replace);
var whitespace = '[' + whitespaces$3 + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$1 = function (TYPE) {
  return function ($this) {
    var string = toString$3(requireObjectCoercible($this));
    if (TYPE & 1) string = replace$1(string, ltrim, '');
    if (TYPE & 2) string = replace$1(string, rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3)
};

var global$e = global$P;
var fails$a = fails$t;
var uncurryThis$7 = functionUncurryThis;
var toString$2 = toString$8;
var trim$1 = stringTrim.trim;
var whitespaces$2 = whitespaces$4;
var $parseInt$1 = global$e.parseInt;
var Symbol$2 = global$e.Symbol;
var ITERATOR$1 = Symbol$2 && Symbol$2.iterator;
var hex = /^[+-]?0x/i;
var exec$1 = uncurryThis$7(hex.exec);
var FORCED$4 = $parseInt$1(whitespaces$2 + '08') !== 8 || $parseInt$1(whitespaces$2 + '0x16') !== 22 // MS Edge 18- broken with boxed symbols
|| ITERATOR$1 && !fails$a(function () {
  $parseInt$1(Object(ITERATOR$1));
}); // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

var numberParseInt = FORCED$4 ? function parseInt(string, radix) {
  var S = trim$1(toString$2(string));
  return $parseInt$1(S, radix >>> 0 || (exec$1(hex, S) ? 16 : 10));
} : $parseInt$1;

var $$l = _export;
var $parseInt = numberParseInt; // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

$$l({
  global: true,
  forced: parseInt != $parseInt
}, {
  parseInt: $parseInt
});

var path$f = path$y;
var _parseInt$2 = path$f.parseInt;

var parent$A = _parseInt$2;
var _parseInt$1 = parent$A;

var _parseInt = _parseInt$1;

/* eslint-disable es/no-array-prototype-indexof -- required for testing */


var $$k = _export;
var uncurryThis$6 = functionUncurryThis;
var $IndexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$6;
var un$IndexOf = uncurryThis$6([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
var STRICT_METHOD$4 = arrayMethodIsStrict$4('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof

$$k({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || !STRICT_METHOD$4
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
    return NEGATIVE_ZERO // convert -0 to +0
    ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
  }
});

var entryVirtual$a = entryVirtual$l;
var indexOf$3 = entryVirtual$a('Array').indexOf;

var isPrototypeOf$b = objectIsPrototypeOf;
var method$9 = indexOf$3;
var ArrayPrototype$9 = Array.prototype;

var indexOf$2 = function (it) {
  var own = it.indexOf;
  return it === ArrayPrototype$9 || isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.indexOf ? method$9 : own;
};

var parent$z = indexOf$2;
var indexOf$1 = parent$z;

var indexOf = indexOf$1;

var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$9 = fails$t;
var whitespaces$1 = whitespaces$4;
var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
// of whitespaces and has a correct name

var stringTrimForced = function (METHOD_NAME) {
  return fails$9(function () {
    return !!whitespaces$1[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces$1[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $$j = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced; // `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim

$$j({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
});

var entryVirtual$9 = entryVirtual$l;
entryVirtual$9('String').trim;

var $$i = _export;
var DESCRIPTORS$3 = descriptors;
var create$8 = objectCreate; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

$$i({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS$3
}, {
  create: create$8
});

var path$e = path$y;
var Object$2 = path$e.Object;

var create$7 = function create(P, D) {
  return Object$2.create(P, D);
};

var parent$y = create$7;
var create$6 = parent$y;

var create$5 = create$6;

var $$h = _export;
var global$d = global$P;
var getBuiltIn$2 = getBuiltIn$9;
var apply$3 = functionApply;
var uncurryThis$5 = functionUncurryThis;
var fails$8 = fails$t;
var Array$1 = global$d.Array;
var $stringify = getBuiltIn$2('JSON', 'stringify');
var exec = uncurryThis$5(/./.exec);
var charAt$1 = uncurryThis$5(''.charAt);
var charCodeAt = uncurryThis$5(''.charCodeAt);
var replace = uncurryThis$5(''.replace);
var numberToString = uncurryThis$5(1.0.toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var fix = function (match, offset, string) {
  var prev = charAt$1(string, offset - 1);
  var next = charAt$1(string, offset + 1);

  if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  }

  return match;
};

var FORCED$3 = fails$8(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
});

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  // https://github.com/tc39/proposal-well-formed-stringify
  $$h({
    target: 'JSON',
    stat: true,
    forced: FORCED$3
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++) args[i] = arguments[i];

      var result = apply$3($stringify, null, args);
      return typeof result == 'string' ? replace(result, tester, fix) : result;
    }
  });
}

var path$d = path$y;
var apply$2 = functionApply; // eslint-disable-next-line es/no-json -- safe

if (!path$d.JSON) path$d.JSON = {
  stringify: JSON.stringify
}; // eslint-disable-next-line no-unused-vars -- required for `.length`

var stringify$3 = function stringify(it, replacer, space) {
  return apply$2(path$d.JSON.stringify, null, arguments);
};

var parent$x = stringify$3;
var stringify$2 = parent$x;

var stringify$1 = stringify$2;

var global$c = global$P;
var TypeError$6 = global$c.TypeError;

var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw TypeError$6('Not enough arguments');
  return passed;
};

var $$g = _export;
var global$b = global$P;
var apply$1 = functionApply;
var isCallable$1 = isCallable$h;
var userAgent$2 = engineUserAgent;
var arraySlice$1 = arraySlice$5;
var validateArgumentsLength = validateArgumentsLength$1;
var MSIE = /MSIE .\./.test(userAgent$2); // <- dirty ie9- check

var Function$1 = global$b.Function;

var wrap = function (scheduler) {
  return function (handler, timeout
  /* , ...arguments */
  ) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
    var fn = isCallable$1(handler) ? handler : Function$1(handler);
    var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      apply$1(fn, this, args);
    } : fn, timeout);
  };
}; // ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


$$g({
  global: true,
  bind: true,
  forced: MSIE
}, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global$b.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global$b.setInterval)
});

var path$c = path$y;
var setTimeout$2 = path$c.setTimeout;

var setTimeout$1 = setTimeout$2;

var toObject$3 = toObject$e;
var toAbsoluteIndex = toAbsoluteIndex$5;
var lengthOfArrayLike$5 = lengthOfArrayLike$d; // `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill

var arrayFill = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject$3(this);
  var length = lengthOfArrayLike$5(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

var $$f = _export;
var fill$4 = arrayFill;
// https://tc39.es/ecma262/#sec-array.prototype.fill

$$f({
  target: 'Array',
  proto: true
}, {
  fill: fill$4
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var entryVirtual$8 = entryVirtual$l;
var fill$3 = entryVirtual$8('Array').fill;

var isPrototypeOf$a = objectIsPrototypeOf;
var method$8 = fill$3;
var ArrayPrototype$8 = Array.prototype;

var fill$2 = function (it) {
  var own = it.fill;
  return it === ArrayPrototype$8 || isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.fill ? method$8 : own;
};

var parent$w = fill$2;
var fill$1 = parent$w;

var fill = fill$1;

/*! Hammer.JS - v2.0.17-rc - 2019-12-16
 * http://naver.github.io/egjs
 *
 * Forked By Naver egjs
 * Copyright (c) hammerjs
 * Licensed under the MIT license */
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */


var assign;

if (typeof Object.assign !== 'function') {
  assign = function assign(target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];

      if (source !== undefined && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
} else {
  assign = Object.assign;
}

var assign$1 = assign;
var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = typeof document === "undefined" ? {
  style: {}
} : document.createElement('div');
var TYPE_FUNCTION = 'function';
var round = Math.round,
    abs$1 = Math.abs;
var now = Date.now;
/**
 * @private
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */

function prefixed(obj, property) {
  var prefix;
  var prop;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;

  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;

    if (prop in obj) {
      return prop;
    }

    i++;
  }

  return undefined;
}
/* eslint-disable no-new-func, no-nested-ternary */


var win;

if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {};
} else {
  win = window;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }

  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
    // If css.supports is not supported but there is native touch-action assume it supports
    // all values. This is the case for IE 10 and 11.
    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
  });
  return touchMap;
}

var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = ('ontouchstart' in win);
var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];
/**
 * @private
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */

function each(obj, iterator, context) {
  var i;

  if (!obj) {
    return;
  }

  if (obj.forEach) {
    obj.forEach(iterator, context);
  } else if (obj.length !== undefined) {
    i = 0;

    while (i < obj.length) {
      iterator.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
  }
}
/**
 * @private
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */


function boolOrFn(val, args) {
  if (typeof val === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || undefined : undefined, args);
  }

  return val;
}
/**
 * @private
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */


function inStr(str, find) {
  return str.indexOf(find) > -1;
}
/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */


function cleanTouchActions(actions) {
  // none
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }

  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
  // for different directions, e.g. horizontal pan but vertical swipe?)
  // we need none (as otherwise with pan-x pan-y combined none of these
  // recognizers will work, since the browser would handle all panning

  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  } // pan-x OR pan-y


  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  } // manipulation


  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }

  return TOUCH_ACTION_AUTO;
}
/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */


var TouchAction = /*#__PURE__*/function () {
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  /**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */


  var _proto = TouchAction.prototype;

  _proto.set = function set(value) {
    // find out the touch-action by the event handlers
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }

    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
    }

    this.actions = value.toLowerCase().trim();
  };
  /**
   * @private
   * just re-set the touchAction value
   */


  _proto.update = function update() {
    this.set(this.manager.options.touchAction);
  };
  /**
   * @private
   * compute the value for the touchAction property based on the recognizer's settings
   * @returns {String} value
   */


  _proto.compute = function compute() {
    var actions = [];
    each(this.manager.recognizers, function (recognizer) {
      if (boolOrFn(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return cleanTouchActions(actions.join(' '));
  };
  /**
   * @private
   * this method is called on each input cycle and provides the preventing of the browser behavior
   * @param {Object} input
   */


  _proto.preventDefaults = function preventDefaults(input) {
    var srcEvent = input.srcEvent;
    var direction = input.offsetDirection; // if the touch action did prevented once this session

    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }

    var actions = this.actions;
    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

    if (hasNone) {
      // do not prevent defaults if this is a tap gesture
      var isTapPointer = input.pointers.length === 1;
      var isTapMovement = input.distance < 2;
      var isTapTouchTime = input.deltaTime < 250;

      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }

    if (hasPanX && hasPanY) {
      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
      return;
    }

    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  };
  /**
   * @private
   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
   * @param {Object} srcEvent
   */


  _proto.preventSrc = function preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  };

  return TouchAction;
}();
/**
 * @private
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */


function hasParent(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}
/**
 * @private
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */


function getCenter(pointers) {
  var pointersLength = pointers.length; // no need to loop when only one touch

  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }

  var x = 0;
  var y = 0;
  var i = 0;

  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }

  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}
/**
 * @private
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */


function simpleCloneInputData(input) {
  // make a simple copy of the pointers because we will get a reference if we don't
  // we only need clientXY for the calculations
  var pointers = [];
  var i = 0;

  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }

  return {
    timeStamp: now(),
    pointers: pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
/**
 * @private
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */


function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x * x + y * y);
}
/**
 * @private
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */


function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}
/**
 * @private
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */


function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }

  if (abs$1(x) >= abs$1(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }

  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

function computeDeltaXY(session, input) {
  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
  // jscs throwing error on defalut destructured values and without defaults tests fail

  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};

  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }

  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
/**
 * @private
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */


function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}
/**
 * @private
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */


function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
/**
 * @private
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */


function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
/**
 * @private
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */


function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;

  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    // use latest velocity info if it doesn't overtake a minimum period
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }

  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
/**
* @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */


function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length; // store the first input to calculate the distance and direction

  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  } // to compute scale and rotation we need to store the multiple touches


  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }

  var firstInput = session.firstInput,
      firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input); // find the correct target

  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;

  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = srcEvent.target;
  }

  if (hasParent(srcEventTarget, target)) {
    target = srcEventTarget;
  }

  input.target = target;
}
/**
 * @private
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */


function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;

  if (isFirst) {
    manager.session = {};
  } // source event is the normalized value of the domEvents
  // like 'touchstart, mouseup, pointerdown'


  input.eventType = eventType; // compute scale, rotation etc

  computeInputData(manager, input); // emit secret event

  manager.emit('hammer.input', input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
/**
 * @private
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */


function splitStr(str) {
  return str.trim().split(/\s+/g);
}
/**
 * @private
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function addEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.addEventListener(type, handler, false);
  });
}
/**
 * @private
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function removeEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.removeEventListener(type, handler, false);
  });
}
/**
 * @private
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */


function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
/**
 * @private
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */


var Input = /*#__PURE__*/function () {
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }
  /**
   * @private
   * should handle the inputEvent data and trigger the callback
   * @virtual
   */


  var _proto = Input.prototype;

  _proto.handler = function handler() {};
  /**
   * @private
   * bind the events
   */


  _proto.init = function init() {
    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  /**
   * @private
   * unbind the events
   */


  _proto.destroy = function destroy() {
    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };

  return Input;
}();
/**
 * @private
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */


function inArray(src, find, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find);
  } else {
    var i = 0;

    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
        // do not use === here, test fails
        return i;
      }

      i++;
    }

    return -1;
  }
}

var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
}; // in IE10 the pointer types is defined as an enum

var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

};
var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

if (win.MSPointerEvent && !win.PointerEvent) {
  POINTER_ELEMENT_EVENTS = 'MSPointerDown';
  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}
/**
 * @private
 * Pointer events input
 * @constructor
 * @extends Input
 */


var PointerEventInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(PointerEventInput, _Input);

  function PointerEventInput() {
    var _this;

    var proto = PointerEventInput.prototype;
    proto.evEl = POINTER_ELEMENT_EVENTS;
    proto.evWin = POINTER_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = PointerEventInput.prototype;

  _proto.handler = function handler(ev) {
    var store = this.store;
    var removePointer = false;
    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      removePointer = true;
    } // it not found, so the pointer hasn't been down (so it's probably a hover)


    if (storeIndex < 0) {
      return;
    } // update the event in the store


    store[storeIndex] = ev;
    this.callback(this.manager, eventType, {
      pointers: store,
      changedPointers: [ev],
      pointerType: pointerType,
      srcEvent: ev
    });

    if (removePointer) {
      // remove from the store
      store.splice(storeIndex, 1);
    }
  };

  return PointerEventInput;
}(Input);
/**
 * @private
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */


function toArray(obj) {
  return Array.prototype.slice.call(obj, 0);
}
/**
 * @private
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */


function uniqueArray(src, key, sort) {
  var results = [];
  var values = [];
  var i = 0;

  while (i < src.length) {
    var val = key ? src[i][key] : src[i];

    if (inArray(values, val) < 0) {
      results.push(src[i]);
    }

    values[i] = val;
    i++;
  }

  if (sort) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function (a, b) {
        return a[key] > b[key];
      });
    }
  }

  return results;
}

var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */

var TouchInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(TouchInput, _Input);

  function TouchInput() {
    var _this;

    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

    return _this;
  }

  var _proto = TouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = TOUCH_INPUT_MAP[ev.type];
    var touches = getTouches.call(this, ev, type);

    if (!touches) {
      return;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return TouchInput;
}(Input);

function getTouches(ev, type) {
  var allTouches = toArray(ev.touches);
  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }

  var i;
  var targetTouches;
  var changedTouches = toArray(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target; // get target touches from touches

  targetTouches = allTouches.filter(function (touch) {
    return hasParent(touch.target, target);
  }); // collect touches

  if (type === INPUT_START) {
    i = 0;

    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  } // filter changed touches to only contain touches that exist in the collected target ids


  i = 0;

  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    } // cleanup removed touches


    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }

    i++;
  }

  if (!changedTargetTouches.length) {
    return;
  }

  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
}

var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
/**
 * @private
 * Mouse events input
 * @constructor
 * @extends Input
 */

var MouseInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(MouseInput, _Input);

  function MouseInput() {
    var _this;

    var proto = MouseInput.prototype;
    proto.evEl = MOUSE_ELEMENT_EVENTS;
    proto.evWin = MOUSE_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.pressed = false; // mousedown state

    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = MouseInput.prototype;

  _proto.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

    if (eventType & INPUT_START && ev.button === 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which !== 1) {
      eventType = INPUT_END;
    } // mouse must be down


    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: INPUT_TYPE_MOUSE,
      srcEvent: ev
    });
  };

  return MouseInput;
}(Input);
/**
 * @private
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */


var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers,
      touch = _eventData$changedPoi[0];

  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);

    var removeLastTouch = function removeLastTouch() {
      var i = lts.indexOf(lastTouch);

      if (i > -1) {
        lts.splice(i, 1);
      }
    };

    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}

function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}

function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;

  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);

    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }

  return false;
}

var TouchMouseInput = /*#__PURE__*/function () {
  var TouchMouseInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(TouchMouseInput, _Input);

    function TouchMouseInput(_manager, callback) {
      var _this;

      _this = _Input.call(this, _manager, callback) || this;

      _this.handler = function (manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


        if (isTouch) {
          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {
          return;
        }

        _this.callback(manager, inputEvent, inputData);
      };

      _this.touch = new TouchInput(_this.manager, _this.handler);
      _this.mouse = new MouseInput(_this.manager, _this.handler);
      _this.primaryTouch = null;
      _this.lastTouches = [];
      return _this;
    }
    /**
     * @private
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */


    var _proto = TouchMouseInput.prototype;
    /**
     * @private
     * remove the event listeners
     */

    _proto.destroy = function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    };

    return TouchMouseInput;
  }(Input);

  return TouchMouseInput;
}();
/**
 * @private
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */


function createInputInstance(manager) {
  var Type; // let inputClass = manager.options.inputClass;

  var inputClass = manager.options.inputClass;

  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }

  return new Type(manager, inputHandler);
}
/**
 * @private
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */


function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }

  return false;
}

var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
/**
 * @private
 * get a unique id
 * @returns {number} uniqueId
 */

var _uniqueId = 1;

function uniqueId() {
  return _uniqueId++;
}
/**
 * @private
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */


function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;

  if (manager) {
    return manager.get(otherRecognizer);
  }

  return otherRecognizer;
}
/**
 * @private
 * get a usable string, used as event postfix
 * @param {constant} state
 * @returns {String} state
 */


function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return 'cancel';
  } else if (state & STATE_ENDED) {
    return 'end';
  } else if (state & STATE_CHANGED) {
    return 'move';
  } else if (state & STATE_BEGAN) {
    return 'start';
  }

  return '';
}
/**
 * @private
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */

/**
 * @private
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */


var Recognizer = /*#__PURE__*/function () {
  function Recognizer(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = _extends({
      enable: true
    }, options);
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @return {Recognizer}
   */


  var _proto = Recognizer.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

    this.manager && this.manager.touchAction.update();
    return this;
  };
  /**
   * @private
   * recognize simultaneous with an other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.recognizeWith = function recognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
      return this;
    }

    var simultaneous = this.simultaneous;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }

    return this;
  };
  /**
   * @private
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    delete this.simultaneous[otherRecognizer.id];
    return this;
  };
  /**
   * @private
   * recognizer can only run when an other is failing
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.requireFailure = function requireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
      return this;
    }

    var requireFail = this.requireFail;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (inArray(requireFail, otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }

    return this;
  };
  /**
   * @private
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    var index = inArray(this.requireFail, otherRecognizer);

    if (index > -1) {
      this.requireFail.splice(index, 1);
    }

    return this;
  };
  /**
   * @private
   * has require failures boolean
   * @returns {boolean}
   */


  _proto.hasRequireFailures = function hasRequireFailures() {
    return this.requireFail.length > 0;
  };
  /**
   * @private
   * if the recognizer can recognize simultaneous with an other recognizer
   * @param {Recognizer} otherRecognizer
   * @returns {Boolean}
   */


  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
    return !!this.simultaneous[otherRecognizer.id];
  };
  /**
   * @private
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   * @param {Object} input
   */


  _proto.emit = function emit(input) {
    var self = this;
    var state = this.state;

    function emit(event) {
      self.manager.emit(event, input);
    } // 'panstart' and 'panmove'


    if (state < STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }

    emit(self.options.event); // simple 'eventName' events

    if (input.additionalEvent) {
      // additional event(panleft, panright, pinchin, pinchout...)
      emit(input.additionalEvent);
    } // panend and pancancel


    if (state >= STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }
  };
  /**
   * @private
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   * @param {Object} input
   */


  _proto.tryEmit = function tryEmit(input) {
    if (this.canEmit()) {
      return this.emit(input);
    } // it's failing anyway


    this.state = STATE_FAILED;
  };
  /**
   * @private
   * can we emit?
   * @returns {boolean}
   */


  _proto.canEmit = function canEmit() {
    var i = 0;

    while (i < this.requireFail.length) {
      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
        return false;
      }

      i++;
    }

    return true;
  };
  /**
   * @private
   * update the recognizer
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    // make a new copy of the inputData
    // so we can change the inputData without messing up the other recognizers
    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?

    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
      this.reset();
      this.state = STATE_FAILED;
      return;
    } // reset when we've reached the end


    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
      this.state = STATE_POSSIBLE;
    }

    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
    // so trigger an event

    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
      this.tryEmit(inputDataClone);
    }
  };
  /**
   * @private
   * return the state of the recognizer
   * the actual recognizing happens in this method
   * @virtual
   * @param {Object} inputData
   * @returns {constant} STATE
   */

  /* jshint ignore:start */


  _proto.process = function process(inputData) {};
  /* jshint ignore:end */

  /**
   * @private
   * return the preferred touch-action
   * @virtual
   * @returns {Array}
   */


  _proto.getTouchAction = function getTouchAction() {};
  /**
   * @private
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   * @virtual
   */


  _proto.reset = function reset() {};

  return Recognizer;
}();
/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */


var TapRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(TapRecognizer, _Recognizer);

  function TapRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
    }, options)) || this; // previous time and center,
    // used for tap counting

    _this.pTime = false;
    _this.pCenter = false;
    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }

  var _proto = TapRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTouchTime = input.deltaTime < options.time;
    this.reset();

    if (input.eventType & INPUT_START && this.count === 0) {
      return this.failTimeout();
    } // we only allow little movement
    // and we've reached an end event, so a tap is possible


    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== INPUT_END) {
        return this.failTimeout();
      }

      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;

      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }

      this._input = input; // if tap count matches we have recognized it,
      // else it has began recognizing...

      var tapCount = this.count % options.taps;

      if (tapCount === 0) {
        // no failing requirements, immediately trigger the tap event
        // or wait as long as the multitap interval to trigger
        if (!this.hasRequireFailures()) {
          return STATE_RECOGNIZED;
        } else {
          this._timer = setTimeout(function () {
            _this2.state = STATE_RECOGNIZED;

            _this2.tryEmit();
          }, options.interval);
          return STATE_BEGAN;
        }
      }
    }

    return STATE_FAILED;
  };

  _proto.failTimeout = function failTimeout() {
    var _this3 = this;

    this._timer = setTimeout(function () {
      _this3.state = STATE_FAILED;
    }, this.options.interval);
    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit() {
    if (this.state === STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  };

  return TapRecognizer;
}(Recognizer);
/**
 * @private
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */


var AttrRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(AttrRecognizer, _Recognizer);

  function AttrRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _Recognizer.call(this, _extends({
      pointers: 1
    }, options)) || this;
  }
  /**
   * @private
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {Boolean} recognized
   */


  var _proto = AttrRecognizer.prototype;

  _proto.attrTest = function attrTest(input) {
    var optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  };
  /**
   * @private
   * Process the input and return the state for the recognizer
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {*} State
   */


  _proto.process = function process(input) {
    var state = this.state;
    var eventType = input.eventType;
    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
      return state | STATE_CANCELLED;
    } else if (isRecognized || isValid) {
      if (eventType & INPUT_END) {
        return state | STATE_ENDED;
      } else if (!(state & STATE_BEGAN)) {
        return STATE_BEGAN;
      }

      return state | STATE_CHANGED;
    }

    return STATE_FAILED;
  };

  return AttrRecognizer;
}(Recognizer);
/**
 * @private
 * direction cons to string
 * @param {constant} direction
 * @returns {String}
 */


function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return 'down';
  } else if (direction === DIRECTION_UP) {
    return 'up';
  } else if (direction === DIRECTION_LEFT) {
    return 'left';
  } else if (direction === DIRECTION_RIGHT) {
    return 'right';
  }

  return '';
}
/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(PanRecognizer, _AttrRecognizer);

  function PanRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _AttrRecognizer.call(this, _extends({
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    }, options)) || this;
    _this.pX = null;
    _this.pY = null;
    return _this;
  }

  var _proto = PanRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    var direction = this.options.direction;
    var actions = [];

    if (direction & DIRECTION_HORIZONTAL) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }

    if (direction & DIRECTION_VERTICAL) {
      actions.push(TOUCH_ACTION_PAN_X);
    }

    return actions;
  };

  _proto.directionTest = function directionTest(input) {
    var options = this.options;
    var hasMoved = true;
    var distance = input.distance;
    var direction = input.direction;
    var x = input.deltaX;
    var y = input.deltaY; // lock to axis?

    if (!(direction & options.direction)) {
      if (options.direction & DIRECTION_HORIZONTAL) {
        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        hasMoved = x !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        hasMoved = y !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }

    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  };

  _proto.attrTest = function attrTest(input) {
    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
  };

  _proto.emit = function emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    var direction = directionStr(input.direction);

    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PanRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);

  function SwipeRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    }, options)) || this;
  }

  var _proto = SwipeRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return PanRecognizer.prototype.getTouchAction.call(this);
  };

  _proto.attrTest = function attrTest(input) {
    var direction = this.options.direction;
    var velocity;

    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
      velocity = input.overallVelocity;
    } else if (direction & DIRECTION_HORIZONTAL) {
      velocity = input.overallVelocityX;
    } else if (direction & DIRECTION_VERTICAL) {
      velocity = input.overallVelocityY;
    }

    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;
  };

  _proto.emit = function emit(input) {
    var direction = directionStr(input.offsetDirection);

    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }

    this.manager.emit(this.options.event, input);
  };

  return SwipeRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */


var PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(PinchRecognizer, _AttrRecognizer);

  function PinchRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'pinch',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = PinchRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
  };

  _proto.emit = function emit(input) {
    if (input.scale !== 1) {
      var inOut = input.scale < 1 ? 'in' : 'out';
      input.additionalEvent = this.options.event + inOut;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PinchRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */


var RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(RotateRecognizer, _AttrRecognizer);

  function RotateRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'rotate',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = RotateRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
  };

  return RotateRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */


var PressRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(PressRecognizer, _Recognizer);

  function PressRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
    }, options)) || this;
    _this._timer = null;
    _this._input = null;
    return _this;
  }

  var _proto = PressRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_AUTO];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTime = input.deltaTime > options.time;
    this._input = input; // we only allow little movement
    // and we've reached an end event, so a tap is possible

    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
      this.reset();
    } else if (input.eventType & INPUT_START) {
      this.reset();
      this._timer = setTimeout(function () {
        _this2.state = STATE_RECOGNIZED;

        _this2.tryEmit();
      }, options.time);
    } else if (input.eventType & INPUT_END) {
      return STATE_RECOGNIZED;
    }

    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit(input) {
    if (this.state !== STATE_RECOGNIZED) {
      return;
    }

    if (input && input.eventType & INPUT_END) {
      this.manager.emit(this.options.event + "up", input);
    } else {
      this._input.timeStamp = now();
      this.manager.emit(this.options.event, this._input);
    }
  };

  return PressRecognizer;
}(Recognizer);

var defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,

  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,

  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,

  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,

  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,

  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: "none",

    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: "none",

    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: "none",

    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: "none",

    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: "none",

    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
/**
 * @private
 * Default recognizer setup when calling `Hammer()`
 * When creating a new Manager these will be skipped.
 * This is separated with other defaults because of tree-shaking.
 * @type {Array}
 */

var preset = [[RotateRecognizer, {
  enable: false
}], [PinchRecognizer, {
  enable: false
}, ['rotate']], [SwipeRecognizer, {
  direction: DIRECTION_HORIZONTAL
}], [PanRecognizer, {
  direction: DIRECTION_HORIZONTAL
}, ['swipe']], [TapRecognizer], [TapRecognizer, {
  event: 'doubletap',
  taps: 2
}, ['tap']], [PressRecognizer]];
var STOP = 1;
var FORCED_STOP = 2;
/**
 * @private
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */

function toggleCssProps(manager, add) {
  var element = manager.element;

  if (!element.style) {
    return;
  }

  var prop;
  each(manager.options.cssProps, function (value, name) {
    prop = prefixed(element.style, name);

    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || "";
    }
  });

  if (!add) {
    manager.oldCssProps = {};
  }
}
/**
 * @private
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */


function triggerDomEvent(event, data) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data;
  data.target.dispatchEvent(gestureEvent);
}
/**
* @private
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Manager = /*#__PURE__*/function () {
  function Manager(element, options) {
    var _this = this;

    this.options = assign$1({}, defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = _this.add(new item[0](item[1]));

      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @returns {Manager}
   */


  var _proto = Manager.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // Options that need a little more setup

    if (options.touchAction) {
      this.touchAction.update();
    }

    if (options.inputTarget) {
      // Clean up existing event listeners and reinitialize
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }

    return this;
  };
  /**
   * @private
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   * @param {Boolean} [force]
   */


  _proto.stop = function stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  };
  /**
   * @private
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    var session = this.session;

    if (session.stopped) {
      return;
    } // run the touch-action polyfill


    this.touchAction.preventDefaults(inputData);
    var recognizer;
    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
    // if no recognizer is detecting a thing, it is set to `null`

    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
    // or when we're in a new session

    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
      session.curRecognizer = null;
      curRecognizer = null;
    }

    var i = 0;

    while (i < recognizers.length) {
      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
      // 1.   allow if the session is NOT forced stopped (see the .stop() method)
      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
      //      that is being recognized.
      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
      //      this can be setup with the `recognizeWith()` method on the recognizer.

      if (session.stopped !== FORCED_STOP && ( // 1
      !curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        // 3
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
      // current active recognizer. but only if we don't already have an active recognizer


      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
        session.curRecognizer = recognizer;
        curRecognizer = recognizer;
      }

      i++;
    }
  };
  /**
   * @private
   * get a recognizer by its event name.
   * @param {Recognizer|String} recognizer
   * @returns {Recognizer|Null}
   */


  _proto.get = function get(recognizer) {
    if (recognizer instanceof Recognizer) {
      return recognizer;
    }

    var recognizers = this.recognizers;

    for (var i = 0; i < recognizers.length; i++) {
      if (recognizers[i].options.event === recognizer) {
        return recognizers[i];
      }
    }

    return null;
  };
  /**
   * @private add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   * @param {Recognizer} recognizer
   * @returns {Recognizer|Manager}
   */


  _proto.add = function add(recognizer) {
    if (invokeArrayArg(recognizer, "add", this)) {
      return this;
    } // remove existing


    var existing = this.get(recognizer.options.event);

    if (existing) {
      this.remove(existing);
    }

    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  };
  /**
   * @private
   * remove a recognizer by name or instance
   * @param {Recognizer|String} recognizer
   * @returns {Manager}
   */


  _proto.remove = function remove(recognizer) {
    if (invokeArrayArg(recognizer, "remove", this)) {
      return this;
    }

    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

    if (recognizer) {
      var recognizers = this.recognizers;
      var index = inArray(recognizers, targetRecognizer);

      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }

    return this;
  };
  /**
   * @private
   * bind event
   * @param {String} events
   * @param {Function} handler
   * @returns {EventEmitter} this
   */


  _proto.on = function on(events, handler) {
    if (events === undefined || handler === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    });
    return this;
  };
  /**
   * @private unbind event, leave emit blank to remove all handlers
   * @param {String} events
   * @param {Function} [handler]
   * @returns {EventEmitter} this
   */


  _proto.off = function off(events, handler) {
    if (events === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      if (!handler) {
        delete handlers[event];
      } else {
        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
      }
    });
    return this;
  };
  /**
   * @private emit event to the listeners
   * @param {String} event
   * @param {Object} data
   */


  _proto.emit = function emit(event, data) {
    // we also want to trigger dom events
    if (this.options.domEvents) {
      triggerDomEvent(event, data);
    } // no handlers, so skip it all


    var handlers = this.handlers[event] && this.handlers[event].slice();

    if (!handlers || !handlers.length) {
      return;
    }

    data.type = event;

    data.preventDefault = function () {
      data.srcEvent.preventDefault();
    };

    var i = 0;

    while (i < handlers.length) {
      handlers[i](data);
      i++;
    }
  };
  /**
   * @private
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */


  _proto.destroy = function destroy() {
    this.element && toggleCssProps(this, false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  };

  return Manager;
}();

var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Touch events input
 * @constructor
 * @extends Input
 */

var SingleTouchInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(SingleTouchInput, _Input);

  function SingleTouchInput() {
    var _this;

    var proto = SingleTouchInput.prototype;
    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.started = false;
    return _this;
  }

  var _proto = SingleTouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

    if (type === INPUT_START) {
      this.started = true;
    }

    if (!this.started) {
      return;
    }

    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
      this.started = false;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return SingleTouchInput;
}(Input);

function normalizeSingleTouches(ev, type) {
  var all = toArray(ev.touches);
  var changed = toArray(ev.changedTouches);

  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), 'identifier', true);
  }

  return [all, changed];
}
/**
 * @private
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */


function deprecate(method, name, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
  return function () {
    var e = new Error('get-stack-trace');
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
    var log = window.console && (window.console.warn || window.console.log);

    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }

    return method.apply(this, arguments);
  };
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */


var extend = deprecate(function (dest, src, merge) {
  var keys = Object.keys(src);
  var i = 0;

  while (i < keys.length) {
    if (!merge || merge && dest[keys[i]] === undefined) {
      dest[keys[i]] = src[keys[i]];
    }

    i++;
  }

  return dest;
}, 'extend', 'Use `assign`.');
/**
 * @private
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */

var merge$2 = deprecate(function (dest, src) {
  return extend(dest, src, true);
}, 'merge', 'Use `assign`.');
/**
 * @private
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */

function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;

  if (properties) {
    assign$1(childP, properties);
  }
}
/**
 * @private
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */


function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
/**
 * @private
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Hammer$2 = /*#__PURE__*/function () {
  var Hammer =
  /**
    * @private
    * @const {string}
    */
  function Hammer(element, options) {
    if (options === void 0) {
      options = {};
    }

    return new Manager(element, _extends({
      recognizers: preset.concat()
    }, options));
  };

  Hammer.VERSION = "2.0.17-rc";
  Hammer.DIRECTION_ALL = DIRECTION_ALL;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Hammer.DIRECTION_UP = DIRECTION_UP;
  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Hammer.DIRECTION_NONE = DIRECTION_NONE;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.INPUT_START = INPUT_START;
  Hammer.INPUT_MOVE = INPUT_MOVE;
  Hammer.INPUT_END = INPUT_END;
  Hammer.INPUT_CANCEL = INPUT_CANCEL;
  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
  Hammer.STATE_BEGAN = STATE_BEGAN;
  Hammer.STATE_CHANGED = STATE_CHANGED;
  Hammer.STATE_ENDED = STATE_ENDED;
  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
  Hammer.STATE_CANCELLED = STATE_CANCELLED;
  Hammer.STATE_FAILED = STATE_FAILED;
  Hammer.Manager = Manager;
  Hammer.Input = Input;
  Hammer.TouchAction = TouchAction;
  Hammer.TouchInput = TouchInput;
  Hammer.MouseInput = MouseInput;
  Hammer.PointerEventInput = PointerEventInput;
  Hammer.TouchMouseInput = TouchMouseInput;
  Hammer.SingleTouchInput = SingleTouchInput;
  Hammer.Recognizer = Recognizer;
  Hammer.AttrRecognizer = AttrRecognizer;
  Hammer.Tap = TapRecognizer;
  Hammer.Pan = PanRecognizer;
  Hammer.Swipe = SwipeRecognizer;
  Hammer.Pinch = PinchRecognizer;
  Hammer.Rotate = RotateRecognizer;
  Hammer.Press = PressRecognizer;
  Hammer.on = addEventListeners;
  Hammer.off = removeEventListeners;
  Hammer.each = each;
  Hammer.merge = merge$2;
  Hammer.extend = extend;
  Hammer.bindFn = bindFn;
  Hammer.assign = assign$1;
  Hammer.inherit = inherit;
  Hammer.bindFn = bindFn;
  Hammer.prefixed = prefixed;
  Hammer.toArray = toArray;
  Hammer.inArray = inArray;
  Hammer.uniqueArray = uniqueArray;
  Hammer.splitStr = splitStr;
  Hammer.boolOrFn = boolOrFn;
  Hammer.hasParent = hasParent;
  Hammer.addEventListeners = addEventListeners;
  Hammer.removeEventListeners = removeEventListeners;
  Hammer.defaults = assign$1({}, defaults, {
    preset: preset
  });
  return Hammer;
}(); //  style loader but by script tag, not by the loader.
var RealHammer = Hammer$2;

function _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$8(o, minLen) { var _context21; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = slice(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Use this symbol to delete properies in deepObjectAssign.
 */

var DELETE = symbol("DELETE");
/**
 * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.
 *
 * @param base - The base object that fullfils the whole interface T.
 * @param updates - Updates that may change or delete props.
 * @returns A brand new instance with all the supplied objects deeply merged.
 */


function pureDeepObjectAssign(base) {
  var _context;

  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    updates[_key - 1] = arguments[_key];
  }

  return deepObjectAssign.apply(void 0, concat(_context = [{}, base]).call(_context, updates));
}
/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @param values - Objects to be deeply merged.
 * @returns The first object from values.
 */


function deepObjectAssign() {
  var merged = deepObjectAssignNonentry.apply(void 0, arguments);
  stripDelete(merged);
  return merged;
}
/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @remarks
 * This doesn't strip the DELETE symbols so they may end up in the final object.
 * @param values - Objects to be deeply merged.
 * @returns The first object from values.
 */


function deepObjectAssignNonentry() {
  for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values[_key2] = arguments[_key2];
  }

  if (values.length < 2) {
    return values[0];
  } else if (values.length > 2) {
    var _context2;

    return deepObjectAssignNonentry.apply(void 0, concat(_context2 = [deepObjectAssign(values[0], values[1])]).call(_context2, _toConsumableArray(slice(values).call(values, 2))));
  }

  var a = values[0];
  var b = values[1];

  var _iterator = _createForOfIteratorHelper$8(ownKeys$5(b)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prop = _step.value;
      if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;else if (b[prop] === DELETE) {
        delete a[prop];
      } else if (a[prop] !== null && b[prop] !== null && _typeof(a[prop]) === "object" && _typeof(b[prop]) === "object" && !isArray$2(a[prop]) && !isArray$2(b[prop])) {
        a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
      } else {
        a[prop] = clone(b[prop]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return a;
}
/**
 * Deep clone given object or array. In case of primitive simply return.
 *
 * @param a - Anything.
 * @returns Deep cloned object/array or unchanged a.
 */


function clone(a) {
  if (isArray$2(a)) {
    return map$3(a).call(a, function (value) {
      return clone(value);
    });
  } else if (_typeof(a) === "object" && a !== null) {
    return deepObjectAssignNonentry({}, a);
  } else {
    return a;
  }
}
/**
 * Strip DELETE from given object.
 *
 * @param a - Object which may contain DELETE but won't after this is executed.
 */


function stripDelete(a) {
  for (var _i = 0, _Object$keys = keys$4(a); _i < _Object$keys.length; _i++) {
    var prop = _Object$keys[_i];

    if (a[prop] === DELETE) {
      delete a[prop];
    } else if (_typeof(a[prop]) === "object" && a[prop] !== null) {
      stripDelete(a[prop]);
    }
  }
}
/**
 * Seedable, fast and reasonably good (not crypto but more than okay for our
 * needs) random number generator.
 *
 * @remarks
 * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.
 * Original algorithm created by Johannes BaagÃ¸e \<baagoe\@baagoe.com\> in 2010.
 */

/**
 * Create a seeded pseudo random generator based on Alea by Johannes BaagÃ¸e.
 *
 * @param seed - All supplied arguments will be used as a seed. In case nothing
 * is supplied the current time will be used to seed the generator.
 * @returns A ready to use seeded generator.
 */


function Alea() {
  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    seed[_key3] = arguments[_key3];
  }

  return AleaImplementation(seed.length ? seed : [now$1()]);
}
/**
 * An implementation of [[Alea]] without user input validation.
 *
 * @param seed - The data that will be used to seed the generator.
 * @returns A ready to use seeded generator.
 */


function AleaImplementation(seed) {
  var _mashSeed = mashSeed(seed),
      _mashSeed2 = _slicedToArray(_mashSeed, 3),
      s0 = _mashSeed2[0],
      s1 = _mashSeed2[1],
      s2 = _mashSeed2[2];

  var c = 1;

  var random = function random() {
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    s0 = s1;
    s1 = s2;
    return s2 = t - (c = t | 0);
  };

  random.uint32 = function () {
    return random() * 0x100000000;
  }; // 2^32


  random.fract53 = function () {
    return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16;
  }; // 2^-53


  random.algorithm = "Alea";
  random.seed = seed;
  random.version = "0.9";
  return random;
}
/**
 * Turn arbitrary data into values [[AleaImplementation]] can use to generate
 * random numbers.
 *
 * @param seed - Arbitrary data that will be used as the seed.
 * @returns Three numbers to use as initial values for [[AleaImplementation]].
 */


function mashSeed() {
  var mash = Mash();
  var s0 = mash(" ");
  var s1 = mash(" ");
  var s2 = mash(" ");

  for (var i = 0; i < arguments.length; i++) {
    s0 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s0 < 0) {
      s0 += 1;
    }

    s1 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s1 < 0) {
      s1 += 1;
    }

    s2 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s2 < 0) {
      s2 += 1;
    }
  }

  return [s0, s1, s2];
}
/**
 * Create a new mash function.
 *
 * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns
 * them into numbers.
 */


function Mash() {
  var n = 0xefc8249d;
  return function (data) {
    var string = data.toString();

    for (var i = 0; i < string.length; i++) {
      n += string.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };
}
/**
 * Setup a mock hammer.js object, for unit testing.
 *
 * Inspiration: https://github.com/uber/deck.gl/pull/658
 *
 * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
 */


function hammerMock() {
  var noop = function noop() {};

  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,
    get: function get() {
      return {
        set: noop
      };
    }
  };
}

var Hammer$1 = typeof window !== "undefined" ? window.Hammer || RealHammer : function () {
  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
  return hammerMock();
};
/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 *
 * @param {Element} container
 * @class Activator
 */

function Activator$1(container) {
  var _this = this,
      _context3;

  this._cleanupQueue = [];
  this.active = false;
  this._dom = {
    container: container,
    overlay: document.createElement("div")
  };

  this._dom.overlay.classList.add("vis-overlay");

  this._dom.container.appendChild(this._dom.overlay);

  this._cleanupQueue.push(function () {
    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);
  });

  var hammer = Hammer$1(this._dom.overlay);
  hammer.on("tap", bind$6(_context3 = this._onTapOverlay).call(_context3, this));

  this._cleanupQueue.push(function () {
    hammer.destroy(); // FIXME: cleaning up hammer instances doesn't work (Timeline not removed
    // from memory)
  }); // block all touch events (except tap)


  var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];

  forEach$2(events).call(events, function (event) {
    hammer.on(event, function (event) {
      event.srcEvent.stopPropagation();
    });
  }); // attach a click event to the window, in order to deactivate when clicking outside the timeline


  if (document && document.body) {
    this._onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        _this.deactivate();
      }
    };

    document.body.addEventListener("click", this._onClick);

    this._cleanupQueue.push(function () {
      document.body.removeEventListener("click", _this._onClick);
    });
  } // prepare escape key listener for deactivating when active


  this._escListener = function (event) {
    if ("key" in event ? event.key === "Escape" : event.keyCode === 27
    /* the keyCode is for IE11 */
    ) {
      _this.deactivate();
    }
  };
} // turn into an event emitter


Emitter(Activator$1.prototype); // The currently active activator

Activator$1.current = null;
/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */

Activator$1.prototype.destroy = function () {
  var _context4, _context5;

  this.deactivate();

  var _iterator2 = _createForOfIteratorHelper$8(reverse(_context4 = splice$1(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var callback = _step2.value;
      callback();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};
/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */


Activator$1.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator$1.current) {
    Activator$1.current.deactivate();
  }

  Activator$1.current = this;
  this.active = true;
  this._dom.overlay.style.display = "none";

  this._dom.container.classList.add("vis-active");

  this.emit("change");
  this.emit("activate"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event

  document.body.addEventListener("keydown", this._escListener);
};
/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */


Activator$1.prototype.deactivate = function () {
  this.active = false;
  this._dom.overlay.style.display = "block";

  this._dom.container.classList.remove("vis-active");

  document.body.removeEventListener("keydown", this._escListener);
  this.emit("change");
  this.emit("deactivate");
};
/**
 * Handle a tap event: activate the container
 *
 * @param {Event}  event   The event
 * @private
 */


Activator$1.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.srcEvent.stopPropagation();
};
/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 *
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */


function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }

    element = element.parentNode;
  }

  return false;
} // utility functions

var fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var rgbRE = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;
var rgbaRE = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;
/**
 * Remove everything in the DOM object.
 *
 * @param DOMobject - Node whose child nodes will be recursively deleted.
 */


function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      var child = DOMobject.firstChild;

      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
/**
 * Test whether given object is a string.
 *
 * @param value - Input value of unknown type.
 * @returns True if string, false otherwise.
 */


function isString(value) {
  return value instanceof String || typeof value === "string";
}
/**
 * Test whether given object is a object (not primitive or null).
 *
 * @param value - Input value of unknown type.
 * @returns True if not null object, false otherwise.
 */


function isObject$7(value) {
  return _typeof(value) === "object" && value !== null;
}
/**
 * Copy property from b to a if property present in a.
 * If property in b explicitly set to null, delete it if `allowDeletion` set.
 *
 * Internal helper routine, should not be exported. Not added to `exports` for that reason.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param prop - Name of property to copy from b to a.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 */


function copyOrDelete(a, b, prop, allowDeletion) {
  var doDeletion = false;

  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== undefined;
  }

  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop]; // Remember, this is a reference copy!
  }
}
/**
 * Fill an object with a possibly partially defined other object.
 *
 * Only copies values for the properties already present in a.
 * That means an object is not created on a property if only the b object has it.
 *
 * @param a - The object that will have it's properties updated.
 * @param b - The object with property updates.
 * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.
 */


function fillIfDefined(a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // NOTE: iteration of properties of a
  // NOTE: prototype properties iterated over as well
  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (b[prop] === null || _typeof(b[prop]) !== "object") {
        // Note: typeof null === 'object'
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        var aProp = a[prop];
        var bProp = b[prop];

        if (isObject$7(aProp) && isObject$7(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
/**
 * Extend object a with selected properties of object b.
 * Only properties with defined values are copied.
 *
 * @remarks
 * Previous version of this routine implied that multiple source objects could
 * be used; however, the implementation was **wrong**. Since multiple (\>1)
 * sources weren't used anywhere in the `vis.js` code, this has been removed
 * @param props - Names of first-level properties to copy over.
 * @param a - Target object.
 * @param b - Source object.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 * @returns Argument a.
 */


function selectiveDeepExtend(props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  if (isArray$2(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }

  for (var p = 0; p < props.length; p++) {
    var prop = props[p];

    if (Object.prototype.hasOwnProperty.call(b, prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }

        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$2(b[prop])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Extend object `a` with properties of object `b`, ignoring properties which
 * are explicitly specified to be excluded.
 *
 * @remarks
 * The properties of `b` are considered for copying. Properties which are
 * themselves objects are are also extended. Only properties with defined
 * values are copied.
 * @param propsToExclude - Names of properties which should *not* be copied.
 * @param a - Object to extend.
 * @param b - Object to take properties from for extension.
 * @param allowDeletion - If true, delete properties in a that are explicitly
 * set to null in b.
 * @returns Argument a.
 */


function selectiveNotDeepExtend(propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  // NOTE: array properties have an else-below; apparently, there is a problem here.
  if (isArray$2(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }

  for (var prop in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop)) {
      continue;
    } // Handle local properties only


    if (includes(propsToExclude).call(propsToExclude, prop)) {
      continue;
    } // In exclusion list, skip


    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === undefined) {
        a[prop] = {};
      }

      if (a[prop].constructor === Object) {
        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (isArray$2(b[prop])) {
      a[prop] = [];

      for (var i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }

  return a;
}
/**
 * Deep extend an object a with the properties of object b.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param protoExtend - If true, the prototype values will also be extended.
 * (That is the options objects that inherit from others will also get the
 * inherited options).
 * @param allowDeletion - If true, the values of fields that are null will be deleted.
 * @returns Argument a.
 */


function deepExtend(a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var prop in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {
      if (_typeof(b[prop]) === "object" && b[prop] !== null && getPrototypeOf$4(b[prop]) === Object.prototype) {
        if (a[prop] === undefined) {
          a[prop] = deepExtend({}, b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else if (_typeof(a[prop]) === "object" && a[prop] !== null && getPrototypeOf$4(a[prop]) === Object.prototype) {
          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$2(b[prop])) {
        var _context6;

        a[prop] = slice(_context6 = b[prop]).call(_context6);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - First part.
 * @param newValue - The value to be aadded into the array.
 * @returns A new array with all items from arr and newValue (which is last).
 */


function copyAndExtendArray(arr, newValue) {
  var _context7;

  return concat(_context7 = []).call(_context7, _toConsumableArray(arr), [newValue]);
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - The array to be copied.
 * @returns Shallow copy of arr.
 */


function copyArray(arr) {
  return slice(arr).call(arr);
}
/**
 * Retrieve the absolute left value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 * @returns The absolute left position of this element in the browser page.
 */


function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
/**
 * Retrieve the absolute top value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 * @returns The absolute top position of this element in the browser page.
 */


function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).
 * In case of an Object, the method loops over all properties of the object.
 *
 * @param object - An Object or Array to be iterated over.
 * @param callback - Array.forEach-like callback.
 */


function forEach$1(object, callback) {
  if (isArray$2(object)) {
    // array
    var len = object.length;

    for (var i = 0; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }
}
/**
 * Add and event listener. Works for all browsers.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.addEventListener(action, â, â).
 * @param listener - Same as Element.addEventListener(â, listener, â).
 * @param useCapture - Same as Element.addEventListener(â, â, useCapture).
 */


function addEventListener(element, action, listener, useCapture) {
  if (element.addEventListener) {
    var _context8;

    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === "mousewheel" && includes(_context8 = navigator.userAgent).call(_context8, "Firefox")) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    // @TODO: IE types? Does anyone care?
    element.attachEvent("on" + action, listener); // IE browsers
  }
}
/**
 * Remove an event listener from an element.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.removeEventListener(action, â, â).
 * @param listener - Same as Element.removeEventListener(â, listener, â).
 * @param useCapture - Same as Element.removeEventListener(â, â, useCapture).
 */


function removeEventListener(element, action, listener, useCapture) {
  if (element.removeEventListener) {
    var _context9;

    // non-IE browsers
    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === "mousewheel" && includes(_context9 = navigator.userAgent).call(_context9, "Firefox")) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // @TODO: IE types? Does anyone care?
    element.detachEvent("on" + action, listener); // IE browsers
  }
}
/**
 * Convert hex color string into RGB color object.
 *
 * @remarks
 * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}
 * @param hex - Hex color string (3 or 6 digits, with or without #).
 * @returns RGB color object.
 */

function hexToRGB(hex) {
  var result;

  switch (hex.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1] + result[1], 16),
        g: _parseInt(result[2] + result[2], 16),
        b: _parseInt(result[3] + result[3], 16)
      } : null;

    case 6:
    case 7:
      result = fullHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1], 16),
        g: _parseInt(result[2], 16),
        b: _parseInt(result[3], 16)
      } : null;

    default:
      return null;
  }
}
/**
 * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.
 *
 * @param color - The color string (hex, RGB, RGBA).
 * @param opacity - The new opacity.
 * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.
 */


function overrideOpacity(color, opacity) {
  if (includes(color).call(color, "rgba")) {
    return color;
  } else if (includes(color).call(color, "rgb")) {
    var rgb = color.substr(indexOf(color).call(color, "(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var _rgb = hexToRGB(color);

    if (_rgb == null) {
      return color;
    } else {
      return "rgba(" + _rgb.r + "," + _rgb.g + "," + _rgb.b + "," + opacity + ")";
    }
  }
}
/**
 * Convert RGB \<0, 255\> into hex color string.
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 * @returns Hex color string (for example: '#0acdc0').
 */


function RGBToHex(red, green, blue) {
  var _context10;

  return "#" + slice(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);
}
/**
 * Parse a color property into an object with border, background, and highlight colors.
 *
 * @param inputColor - Shorthand color string or input color object.
 * @param defaultColor - Full color object to fill in missing values in inputColor.
 * @returns Color object.
 */


function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    var colorStr = inputColor;

    if (isValidRGB(colorStr)) {
      var _context11;

      var rgb = map$3(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(",")).call(_context11, function (value) {
        return _parseInt(value);
      });

      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);
    }

    if (isValidHex(colorStr) === true) {
      var hsv = hexToHSV(colorStr);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      var color = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color;
    } else {
      var _color = {
        background: inputColor.background || undefined,
        border: inputColor.border || undefined,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || undefined,
          border: inputColor.highlight && inputColor.highlight.border || undefined
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || undefined,
          background: inputColor.hover && inputColor.hover.background || undefined
        }
      };
      return _color;
    }
  }
}
/**
 * Convert RGB \<0, 255\> into HSV object.
 *
 * @remarks
 * {@link http://www.javascripter.net/faq/rgb2hsv.htm}
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 * @returns HSV color object.
 */


function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue)); // Black-gray-white

  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  } // Colors other than black-gray-white:


  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}
/**
 * Convert HSV \<0, 1\> into RGB color object.
 *
 * @remarks
 * {@link https://gist.github.com/mjijackson/5311256}
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 * @returns RGB color object.
 */


function HSVToRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;

    case 1:
      r = q, g = v, b = p;
      break;

    case 2:
      r = p, g = v, b = t;
      break;

    case 3:
      r = p, g = q, b = v;
      break;

    case 4:
      r = t, g = p, b = v;
      break;

    case 5:
      r = v, g = p, b = q;
      break;
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
/**
 * Convert HSV \<0, 1\> into hex color string.
 *
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 * @returns Hex color string.
 */


function HSVToHex(h, s, v) {
  var rgb = HSVToRGB(h, s, v);
  return RGBToHex(rgb.r, rgb.g, rgb.b);
}
/**
 * Convert hex color string into HSV \<0, 1\>.
 *
 * @param hex - Hex color string.
 * @returns HSV color object.
 */


function hexToHSV(hex) {
  var rgb = hexToRGB(hex);

  if (!rgb) {
    throw new TypeError("'".concat(hex, "' is not a valid color."));
  }

  return RGBToHSV(rgb.r, rgb.g, rgb.b);
}
/**
 * Validate hex color string.
 *
 * @param hex - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidHex(hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
}
/**
 * Validate RGB color string.
 *
 * @param rgb - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGB(rgb) {
  return rgbRE.test(rgb);
}
/**
 * Validate RGBA color string.
 *
 * @param rgba - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGBA(rgba) {
  return rgbaRE.test(rgba);
}
/**
 * This recursively redirects the prototype of JSON objects to the referenceObject.
 * This is used for default options.
 *
 * @param referenceObject - The original object.
 * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.
 */


function bridgeObject(referenceObject) {
  if (referenceObject === null || _typeof(referenceObject) !== "object") {
    return null;
  }

  if (referenceObject instanceof Element) {
    // Avoid bridging DOM objects
    return referenceObject;
  }

  var objectTo = create$5(referenceObject);

  for (var i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (_typeof(referenceObject[i]) == "object") {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }

  return objectTo;
}
/**
 * This is used to set the options of subobjects in the options object.
 *
 * A requirement of these subobjects is that they have an 'enabled' element
 * which is optional for the user but mandatory for the program.
 *
 * The added value here of the merge is that option 'enabled' is set as required.
 *
 * @param mergeTarget - Either this.options or the options used for the groups.
 * @param options - Options.
 * @param option - Option key in the options argument.
 * @param globalOptions - Global options, passed in to determine value of option 'enabled'.
 */


function mergeOptions(mergeTarget, options, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  // Local helpers
  var isPresent = function isPresent(obj) {
    return obj !== null && obj !== undefined;
  };

  var isObject = function isObject(obj) {
    return obj !== null && _typeof(obj) === "object";
  }; // https://stackoverflow.com/a/34491287/1223531


  var isEmpty = function isEmpty(obj) {
    for (var x in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x)) {
        return false;
      }
    }

    return true;
  }; // Guards


  if (!isObject(mergeTarget)) {
    throw new Error("Parameter mergeTarget must be an object");
  }

  if (!isObject(options)) {
    throw new Error("Parameter options must be an object");
  }

  if (!isPresent(option)) {
    throw new Error("Parameter option must have a value");
  }

  if (!isObject(globalOptions)) {
    throw new Error("Parameter globalOptions must be an object");
  } //
  // Actual merge routine, separated from main logic
  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.
  //


  var doMerge = function doMerge(target, options, option) {
    if (!isObject(target[option])) {
      target[option] = {};
    }

    var src = options[option];
    var dst = target[option];

    for (var prop in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop)) {
        dst[prop] = src[prop];
      }
    }
  }; // Local initialization


  var srcOption = options[option];
  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : undefined;
  var globalEnabled = globalOption ? globalOption.enabled : undefined; /////////////////////////////////////////
  // Main routine
  /////////////////////////////////////////

  if (srcOption === undefined) {
    return; // Nothing to do
  }

  if (typeof srcOption === "boolean") {
    if (!isObject(mergeTarget[option])) {
      mergeTarget[option] = {};
    }

    mergeTarget[option].enabled = srcOption;
    return;
  }

  if (srcOption === null && !isObject(mergeTarget[option])) {
    // If possible, explicit copy from globals
    if (isPresent(globalOption)) {
      mergeTarget[option] = create$5(globalOption);
    } else {
      return; // Nothing to do
    }
  }

  if (!isObject(srcOption)) {
    return;
  } //
  // Ensure that 'enabled' is properly set. It is required internally
  // Note that the value from options will always overwrite the existing value
  //


  var enabled = true; // default value

  if (srcOption.enabled !== undefined) {
    enabled = srcOption.enabled;
  } else {
    // Take from globals, if present
    if (globalEnabled !== undefined) {
      enabled = globalOption.enabled;
    }
  }

  doMerge(mergeTarget, options, option);
  mergeTarget[option].enabled = enabled;
}
/*
 * Easing Functions.
 * Only considering the t value for the range [0, 1] => [0, 1].
 *
 * Inspiration: from http://gizma.com/easing/
 * https://gist.github.com/gre/1650294
 */


var easingFunctions = {
  /**
   * Provides no easing and no acceleration.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  linear: function linear(t) {
    return t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
// It works only for single property objects,
// otherwise it combines all of the types in a union.
// export function topMost<K1 extends string, V1> (
//   pile: Record<K1, undefined | V1>[],
//   accessors: K1 | [K1]
// ): undefined | V1
// export function topMost<K1 extends string, K2 extends string, V1, V2> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],
//   accessors: [K1, K2]
// ): undefined | V1 | V2
// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],
//   accessors: [K1, K2, K3]
// ): undefined | V1 | V2 | V3

/**
 * Get the top most property value from a pile of objects.
 *
 * @param pile - Array of objects, no required format.
 * @param accessors - Array of property names.
 * For example `object['foo']['bar']` â `['foo', 'bar']`.
 * @returns Value of the property with given accessors path from the first pile item where it's not undefined.
 */


function topMost(pile, accessors) {
  var candidate;

  if (!isArray$2(accessors)) {
    accessors = [accessors];
  }

  var _iterator3 = _createForOfIteratorHelper$8(pile),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var member = _step3.value;

      if (member) {
        candidate = member[accessors[0]];

        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }

        if (typeof candidate !== "undefined") {
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return candidate;
}

var htmlColors = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
};
/**
 * @param {number} [pixelRatio=1]
 */

var ColorPicker$1 = /*#__PURE__*/function () {
  /**
   * @param {number} [pixelRatio=1]
   */
  function ColorPicker$1() {
    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    _classCallCheck(this, ColorPicker$1);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.hueCircle = undefined;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.previousColor = undefined;
    this.applied = false; // bound by

    this.updateCallback = function () {};

    this.closeCallback = function () {}; // create all DOM elements


    this._create();
  }
  /**
   * this inserts the colorPicker into a div from the DOM
   *
   * @param {Element} container
   */


  _createClass(ColorPicker$1, [{
    key: "insertTo",
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }

      this.container = container;
      this.container.appendChild(this.frame);

      this._bindHammer();

      this._setSize();
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */

  }, {
    key: "setUpdateCallback",
    value: function setUpdateCallback(callback) {
      if (typeof callback === "function") {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker update callback is not a function.");
      }
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */

  }, {
    key: "setCloseCallback",
    value: function setCloseCallback(callback) {
      if (typeof callback === "function") {
        this.closeCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
      }
    }
    /**
     *
     * @param {string} color
     * @returns {string}
     * @private
     */

  }, {
    key: "_isColorString",
    value: function _isColorString(color) {
      if (typeof color === "string") {
        return htmlColors[color];
      }
    }
    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     *
     * @param {string | object} color
     * @param {boolean} [setInitial=true]
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (color === "none") {
        return;
      }

      var rgba; // if a html color shorthand is used, convert to hex

      var htmlColor = this._isColorString(color);

      if (htmlColor !== undefined) {
        color = htmlColor;
      } // check format


      if (isString(color) === true) {
        if (isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
          rgba = {
            r: rgbaArray[0],
            g: rgbaArray[1],
            b: rgbaArray[2],
            a: 1.0
          };
        } else if (isValidRGBA(color) === true) {
          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");

          rgba = {
            r: _rgbaArray[0],
            g: _rgbaArray[1],
            b: _rgbaArray[2],
            a: _rgbaArray[3]
          };
        } else if (isValidHex(color) === true) {
          var rgbObj = hexToRGB(color);
          rgba = {
            r: rgbObj.r,
            g: rgbObj.g,
            b: rgbObj.b,
            a: 1.0
          };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : "1.0";
            rgba = {
              r: color.r,
              g: color.g,
              b: color.b,
              a: alpha
            };
          }
        }
      } // set color


      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + stringify$1(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }
    /**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */

  }, {
    key: "show",
    value: function show() {
      if (this.closeCallback !== undefined) {
        this.closeCallback();
        this.closeCallback = undefined;
      }

      this.applied = false;
      this.frame.style.display = "block";

      this._generateHueCircle();
    } // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     *
     * @param {boolean} [storePrevious=true]
     * @private
     */

  }, {
    key: "_hide",
    value: function _hide() {
      var _this2 = this;

      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = assign$2({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = "none"; // call the closing callback, restoring the onclick method.
      // this is in a setTimeout because it will trigger the show again before the click is done.

      setTimeout$1(function () {
        if (_this2.closeCallback !== undefined) {
          _this2.closeCallback();

          _this2.closeCallback = undefined;
        }
      }, 0);
    }
    /**
     * bound to the save button. Saves and hides.
     *
     * @private
     */

  }, {
    key: "_save",
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;

      this._hide();
    }
    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     *
     * @private
     */

  }, {
    key: "_apply",
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);

      this._updatePicker(this.color);
    }
    /**
     * load the color from the previous session.
     *
     * @private
     */

  }, {
    key: "_loadLast",
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }
    /**
     * set the color, place the picker
     *
     * @param {object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */

  }, {
    key: "_setColor",
    value: function _setColor(rgba) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // store the initial color
      if (setInitial === true) {
        this.initialColor = assign$2({}, rgba);
      }

      this.color = rgba;
      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";

      this._updatePicker(rgba);
    }
    /**
     * bound to opacity control
     *
     * @param {number} value
     * @private
     */

  }, {
    key: "_setOpacity",
    value: function _setOpacity(value) {
      this.color.a = value / 100;

      this._updatePicker(this.color);
    }
    /**
     * bound to brightness control
     *
     * @param {number} value
     * @private
     */

  }, {
    key: "_setBrightness",
    value: function _setBrightness(value) {
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba["a"] = this.color.a;
      this.color = rgba;

      this._updatePicker();
    }
    /**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     *
     * @param {object} rgba
     * @private
     */

  }, {
    key: "_updatePicker",
    value: function _updatePicker() {
      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;
      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext("2d");

      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);

      fill(ctx).call(ctx);

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;
      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
    /**
     * used by create to set the size of the canvas.
     *
     * @private
     */

  }, {
    key: "_setSize",
    value: function _setSize() {
      this.colorPickerCanvas.style.width = "100%";
      this.colorPickerCanvas.style.height = "100%";
      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }
    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     *
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      var _context16, _context17, _context18, _context19;

      this.frame = document.createElement("div");
      this.frame.className = "vis-color-picker";
      this.colorPickerDiv = document.createElement("div");
      this.colorPickerSelector = document.createElement("div");
      this.colorPickerSelector.className = "vis-selector";
      this.colorPickerDiv.appendChild(this.colorPickerSelector);
      this.colorPickerCanvas = document.createElement("canvas");
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = "vis-color";
      this.opacityDiv = document.createElement("div");
      this.opacityDiv.className = "vis-opacity";
      this.brightnessDiv = document.createElement("div");
      this.brightnessDiv.className = "vis-brightness";
      this.arrowDiv = document.createElement("div");
      this.arrowDiv.className = "vis-arrow";
      this.opacityRange = document.createElement("input");

      try {
        this.opacityRange.type = "range"; // Not supported on IE9

        this.opacityRange.min = "0";
        this.opacityRange.max = "100";
      } catch (err) {// TODO: Add some error handling.
      }

      this.opacityRange.value = "100";
      this.opacityRange.className = "vis-range";
      this.brightnessRange = document.createElement("input");

      try {
        this.brightnessRange.type = "range"; // Not supported on IE9

        this.brightnessRange.min = "0";
        this.brightnessRange.max = "100";
      } catch (err) {// TODO: Add some error handling.
      }

      this.brightnessRange.value = "100";
      this.brightnessRange.className = "vis-range";
      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);
      var me = this;

      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };

      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };

      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };

      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerText = "brightness:";
      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerText = "opacity:";
      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerText = "new";
      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerText = "initial";
      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerText = "cancel";
      this.cancelButton.onclick = bind$6(_context16 = this._hide).call(_context16, this, false);
      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerText = "apply";
      this.applyButton.onclick = bind$6(_context17 = this._apply).call(_context17, this);
      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerText = "save";
      this.saveButton.onclick = bind$6(_context18 = this._save).call(_context18, this);
      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerText = "load last";
      this.loadButton.onclick = bind$6(_context19 = this._loadLast).call(_context19, this);
      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);
      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }
    /**
     * bind hammer to the color picker
     *
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer$1(this.colorPickerCanvas);
      this.hammer.get("pinch").set({
        enable: true
      });
      this.hammer.on("hammer.input", function (event) {
        if (event.isFirst) {
          _this3._moveSelector(event);
        }
      });
      this.hammer.on("tap", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panstart", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panmove", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panend", function (event) {
        _this3._moveSelector(event);
      });
    }
    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     *
     * @private
     */

  }, {
    key: "_generateHueCircle",
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext("2d");

        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }

        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // draw hue circle

        var x, y, hue, sat;
        this.centerCoordinates = {
          x: w * 0.5,
          y: h * 0.5
        };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb;

        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }

        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();
        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }

      this.generated = true;
    }
    /**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_moveSelector",
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;
      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;
      var x = left - centerX;
      var y = top - centerY;
      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;
      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px"; // set color

      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba["a"] = this.color.a;
      this.color = rgba; // update previews

      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
  }]);

  return ColorPicker$1;
}();
/**
 * Wrap given text (last argument) in HTML elements (all preceding arguments).
 *
 * @param {...any} rest - List of tag names followed by inner text.
 * @returns An element or a text node.
 */


function wrapInTag() {
  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }

  if (rest.length < 1) {
    throw new TypeError("Invalid arguments.");
  } else if (rest.length === 1) {
    return document.createTextNode(rest[0]);
  } else {
    var element = document.createElement(rest[0]);
    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray(slice(rest).call(rest, 1))));
    return element;
  }
}
/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 */


var Configurator$1 = /*#__PURE__*/function () {
  /**
   * @param {object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {object} defaultContainer    | the default container of the module
   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   * @param {Function} hideOption        | custom logic to dynamically hide options
   */
  function Configurator$1(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var hideOption = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
      return false;
    };

    _classCallCheck(this, Configurator$1);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.hideOption = hideOption;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };

    assign$2(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker$1(pixelRatio);
    this.wrapper = undefined;
  }
  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {object} options
   */


  _createClass(Configurator$1, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};

        this._removePopup();

        var enabled = true;

        if (typeof options === "string") {
          this.options.filter = options;
        } else if (isArray$2(options)) {
          this.options.filter = options.join();
        } else if (_typeof(options) === "object") {
          if (options == null) {
            throw new TypeError("options cannot be null");
          }

          if (options.container !== undefined) {
            this.options.container = options.container;
          }

          if (filter(options) !== undefined) {
            this.options.filter = filter(options);
          }

          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }

          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === "boolean") {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === "function") {
          this.options.filter = options;
          enabled = true;
        }

        if (filter(this.options) === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }

      this._clean();
    }
    /**
     *
     * @param {object} moduleOptions
     */

  }, {
    key: "setModuleOptions",
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;

      if (this.options.enabled === true) {
        this._clean();

        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }

        this._create();
      }
    }
    /**
     * Create all DOM elements
     *
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      this._clean();

      this.changedOptions = [];

      var filter$1 = filter(this.options);

      var counter = 0;
      var show = false;

      for (var _option in this.configureOptions) {
        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {
          this.allowCreation = false;
          show = false;

          if (typeof filter$1 === "function") {
            show = filter$1(_option, []);
            show = show || this._handleObject(this.configureOptions[_option], [_option], true);
          } else if (filter$1 === true || indexOf(filter$1).call(filter$1, _option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true; // linebreak between categories

            if (counter > 0) {
              this._makeItem([]);
            } // a header for the category


            this._makeHeader(_option); // get the sub options


            this._handleObject(this.configureOptions[_option], [_option]);
          }

          counter++;
        }
      }

      this._makeButton();

      this._push(); //~ this.colorPicker.insertTo(this.container);

    }
    /**
     * draw all DOM elements on the screen
     *
     * @private
     */

  }, {
    key: "_push",
    value: function _push() {
      this.wrapper = document.createElement("div");
      this.wrapper.className = "vis-configuration-wrapper";
      this.container.appendChild(this.wrapper);

      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }
    /**
     * delete all DOM elements
     *
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }

      this.domElements = [];

      this._removePopup();
    }
    /**
     * get the value from the actualOptions if it exists
     *
     * @param {Array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */

  }, {
    key: "_getValue",
    value: function _getValue(path) {
      var base = this.moduleOptions;

      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }

      return base;
    }
    /**
     * all option elements are wrapped in an item
     *
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */

  }, {
    key: "_makeItem",
    value: function _makeItem(path) {
      if (this.allowCreation === true) {
        var item = document.createElement("div");
        item.className = "vis-configuration vis-config-item vis-config-s" + path.length;

        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          domElements[_key6 - 1] = arguments[_key6];
        }

        forEach$2(domElements).call(domElements, function (element) {
          item.appendChild(element);
        });

        this.domElements.push(item);
        return this.domElements.length;
      }

      return 0;
    }
    /**
     * header for major subjects
     *
     * @param {string} name
     * @private
     */

  }, {
    key: "_makeHeader",
    value: function _makeHeader(name) {
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-header";
      div.innerText = name;

      this._makeItem([], div);
    }
    /**
     * make a label, if it is an object label, it gets different styling.
     *
     * @param {string} name
     * @param {Array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_makeLabel",
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-label vis-config-s" + path.length;

      if (objectLabel === true) {
        while (div.firstChild) {
          div.removeChild(div.firstChild);
        }

        div.appendChild(wrapInTag("i", "b", name));
      } else {
        div.innerText = name + ":";
      }

      return div;
    }
    /**
     * make a dropdown list for multiple possible string optoins
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeDropdown",
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement("select");
      select.className = "vis-configuration vis-config-select";
      var selectedValue = 0;

      if (value !== undefined) {
        if (indexOf(arr).call(arr, value) !== -1) {
          selectedValue = indexOf(arr).call(arr, value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var _option2 = document.createElement("option");

        _option2.value = arr[i];

        if (i === selectedValue) {
          _option2.selected = "selected";
        }

        _option2.innerText = arr[i];
        select.appendChild(_option2);
      }

      var me = this;

      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, select);
    }
    /**
     * make a range object for numeric options
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeRange",
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement("input");
      range.className = "vis-configuration vis-config-range";

      try {
        range.type = "range"; // not supported on IE9

        range.min = min;
        range.max = max;
      } catch (err) {// TODO: Add some error handling.
      }

      range.step = step; // set up the popup settings in case they are needed.

      var popupString = "";
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.2;

        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = "range increased";
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = "range increased";
        }

        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = "range increased";
        }

        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement("input");
      input.className = "vis-configuration vis-config-rangeinput";
      input.value = range.value;
      var me = this;

      range.onchange = function () {
        input.value = this.value;

        me._update(Number(this.value), path);
      };

      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);

      var itemIndex = this._makeItem(path, label, range, input); // if a popup is needed AND it has not been shown for this value, show it.


      if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;

        this._setupPopup(popupString, itemIndex);
      }
    }
    /**
     * make a button object
     *
     * @private
     */

  }, {
    key: "_makeButton",
    value: function _makeButton() {
      var _this4 = this;

      if (this.options.showButton === true) {
        var generateButton = document.createElement("div");
        generateButton.className = "vis-configuration vis-config-button";
        generateButton.innerText = "generate options";

        generateButton.onclick = function () {
          _this4._printOptions();
        };

        generateButton.onmouseover = function () {
          generateButton.className = "vis-configuration vis-config-button hover";
        };

        generateButton.onmouseout = function () {
          generateButton.className = "vis-configuration vis-config-button";
        };

        this.optionsContainer = document.createElement("div");
        this.optionsContainer.className = "vis-configuration vis-config-option-container";
        this.domElements.push(this.optionsContainer);
        this.domElements.push(generateButton);
      }
    }
    /**
     * prepare the popup
     *
     * @param {string} string
     * @param {number} index
     * @private
     */

  }, {
    key: "_setupPopup",
    value: function _setupPopup(string, index) {
      var _this5 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerText = string;

        div.onclick = function () {
          _this5._removePopup();
        };

        this.popupCounter += 1;
        this.popupDiv = {
          html: div,
          index: index
        };
      }
    }
    /**
     * remove the popup from the dom
     *
     * @private
     */

  }, {
    key: "_removePopup",
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }
    /**
     * Show the popup if it is needed.
     *
     * @private
     */

  }, {
    key: "_showPopupIfNeeded",
    value: function _showPopupIfNeeded() {
      var _this6 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;

        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout$1(function () {
          _this6.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout$1(function () {
          _this6._removePopup();
        }, 1800);
      }
    }
    /**
     * make a checkbox for boolean options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeCheckbox",
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "vis-configuration vis-config-checkbox";
      checkbox.checked = defaultValue;

      if (value !== undefined) {
        checkbox.checked = value;

        if (value !== defaultValue) {
          if (_typeof(defaultValue) === "object") {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({
                path: path,
                value: value
              });
            }
          } else {
            this.changedOptions.push({
              path: path,
              value: value
            });
          }
        }
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a text input field for string options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeTextInput",
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement("input");
      checkbox.type = "text";
      checkbox.className = "vis-configuration vis-config-text";
      checkbox.value = value;

      if (value !== defaultValue) {
        this.changedOptions.push({
          path: path,
          value: value
        });
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a color field with a color picker for color fields
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeColorField",
    value: function _makeColorField(arr, value, path) {
      var _this7 = this;

      var defaultColor = arr[1];
      var div = document.createElement("div");
      value = value === undefined ? defaultColor : value;

      if (value !== "none") {
        div.className = "vis-configuration vis-config-colorBlock";
        div.style.backgroundColor = value;
      } else {
        div.className = "vis-configuration vis-config-colorBlock none";
      }

      value = value === undefined ? defaultColor : value;

      div.onclick = function () {
        _this7._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, div);
    }
    /**
     * used by the color buttons to call the color picker.
     *
     * @param {number} value
     * @param {HTMLElement} div
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_showColorPicker",
    value: function _showColorPicker(value, div, path) {
      var _this8 = this;

      // clear the callback from this div
      div.onclick = function () {};

      this.colorPicker.insertTo(div);
      this.colorPicker.show();
      this.colorPicker.setColor(value);
      this.colorPicker.setUpdateCallback(function (color) {
        var colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
        div.style.backgroundColor = colorString;

        _this8._update(colorString, path);
      }); // on close of the colorpicker, restore the callback.

      this.colorPicker.setCloseCallback(function () {
        div.onclick = function () {
          _this8._showColorPicker(value, div, path);
        };
      });
    }
    /**
     * parse an object and draw the correct items
     *
     * @param {object} obj
     * @param {Array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_handleObject",
    value: function _handleObject(obj) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var show = false;

      var filter$1 = filter(this.options);

      var visibleInSet = false;

      for (var subObj in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = copyAndExtendArray(path, subObj);

          if (typeof filter$1 === "function") {
            show = filter$1(subObj, path); // if needed we must go deeper into the object.

            if (show === false) {
              if (!isArray$2(item) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;

            var value = this._getValue(newPath);

            if (isArray$2(item)) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === "string") {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === "boolean") {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // skip the options that are not enabled
              if (!this.hideOption(path, subObj, this.moduleOptions)) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = copyAndExtendArray(newPath, "enabled");

                  var enabledValue = this._getValue(enabledPath);

                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);

                    this._makeItem(newPath, label);

                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var _label = this._makeLabel(subObj, newPath, true);

                  this._makeItem(newPath, _label);

                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error("dont know how to handle", item, subObj, newPath);
            }
          }
        }
      }

      return visibleInSet;
    }
    /**
     * handle the array type of option
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_handleArray",
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === "string" && arr[0] === "color") {
        this._makeColorField(arr, value, path);

        if (arr[1] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === "string") {
        this._makeDropdown(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === "number") {
        this._makeRange(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: Number(value)
          });
        }
      }
    }
    /**
     * called to update the network with the new settings.
     *
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_update",
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }

      this.initialized = true;
      this.parent.setOptions(options);
    }
    /**
     *
     * @param {string | boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */

  }, {
    key: "_constructOptions",
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var pointer = optionsObj; // when dropdown boxes can be string or boolean, we typecast it into correct types

      value = value === "true" ? true : value;
      value = value === "false" ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== "global") {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }

          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }

      return optionsObj;
    }
    /**
     * @private
     */

  }, {
    key: "_printOptions",
    value: function _printOptions() {
      var options = this.getOptions();

      while (this.optionsContainer.firstChild) {
        this.optionsContainer.removeChild(this.optionsContainer.firstChild);
      }

      this.optionsContainer.appendChild(wrapInTag("pre", "const options = " + stringify$1(options, null, 2)));
    }
    /**
     *
     * @returns {{}} options
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = {};

      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }

      return options;
    }
  }]);

  return Configurator$1;
}();
/**
 * Popup is a class to create a popup window with some text
 */


var Popup$1 = /*#__PURE__*/function () {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')
   */
  function Popup$1(container, overflowMethod) {
    _classCallCheck(this, Popup$1);

    this.container = container;
    this.overflowMethod = overflowMethod || "cap";
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false; // create the frame

    this.frame = document.createElement("div");
    this.frame.className = "vis-tooltip";
    this.container.appendChild(this.frame);
  }
  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */


  _createClass(Popup$1, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.x = _parseInt(x);
      this.y = _parseInt(y);
    }
    /**
     * Set the content for the popup window. This can be HTML code or text.
     *
     * @param {string | Element} content
     */

  }, {
    key: "setText",
    value: function setText(content) {
      if (content instanceof Element) {
        while (this.frame.firstChild) {
          this.frame.removeChild(this.frame.firstChild);
        }

        this.frame.appendChild(content);
      } else {
        // String containing literal text, element has to be used for HTML due to
        // XSS risks associated with innerHTML (i.e. prevent XSS by accident).
        this.frame.innerText = content;
      }
    }
    /**
     * Show the popup window
     *
     * @param {boolean} [doShow]    Show or hide the window
     */

  }, {
    key: "show",
    value: function show(doShow) {
      if (doShow === undefined) {
        doShow = true;
      }

      if (doShow === true) {
        var height = this.frame.clientHeight;
        var width = this.frame.clientWidth;
        var maxHeight = this.frame.parentNode.clientHeight;
        var maxWidth = this.frame.parentNode.clientWidth;
        var left = 0,
            top = 0;

        if (this.overflowMethod == "flip") {
          var isLeft = false,
              isTop = true; // Where around the position it's located

          if (this.y - height < this.padding) {
            isTop = false;
          }

          if (this.x + width > maxWidth - this.padding) {
            isLeft = true;
          }

          if (isLeft) {
            left = this.x - width;
          } else {
            left = this.x;
          }

          if (isTop) {
            top = this.y - height;
          } else {
            top = this.y;
          }
        } else {
          top = this.y - height;

          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }

          if (top < this.padding) {
            top = this.padding;
          }

          left = this.x;

          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }

          if (left < this.padding) {
            left = this.padding;
          }
        }

        this.frame.style.left = left + "px";
        this.frame.style.top = top + "px";
        this.frame.style.visibility = "visible";
        this.hidden = false;
      } else {
        this.hide();
      }
    }
    /**
     * Hide the popup window
     */

  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
      this.frame.style.left = "0";
      this.frame.style.top = "0";
      this.frame.style.visibility = "hidden";
    }
    /**
     * Remove the popup window
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM
    }
  }]);

  return Popup$1;
}();

var errorFound = false;
var allOptions$1;
var VALIDATOR_PRINT_STYLE$1 = "background: #FFeeee; color: #dd0000";
/**
 *  Used to validate options.
 */

var Validator$1 = /*#__PURE__*/function () {
  function Validator$1() {
    _classCallCheck(this, Validator$1);
  }

  _createClass(Validator$1, null, [{
    key: "validate",
    value:
    /**
     * Main function to be called
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {object} subObject
     * @returns {boolean}
     * @static
     */
    function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions$1 = referenceOptions;
      var usedOptions = referenceOptions;

      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }

      Validator$1.parse(options, usedOptions, []);
      return errorFound;
    }
    /**
     * Will traverse an object recursively and check every value
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "parse",
    value: function parse(options, referenceOptions, path) {
      for (var _option3 in options) {
        if (Object.prototype.hasOwnProperty.call(options, _option3)) {
          Validator$1.check(_option3, options, referenceOptions, path);
        }
      }
    }
    /**
     * Check every value. If the value is an object, call the parse function on that object.
     *
     * @param {string} option
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "check",
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator$1.getSuggestion(option, referenceOptions, path);
        return;
      }

      var referenceOption = option;
      var is_object = true;

      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // NOTE: This only triggers if the __any__ is in the top level of the options object.
        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!
        // TODO: Examine if needed, remove if possible
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        referenceOption = "__any__"; // if the any-subgroup is not a predefined object in the configurator,
        // we do not look deeper into the object.

        is_object = Validator$1.getType(options[option]) === "object";
      }

      var refOptionObj = referenceOptions[referenceOption];

      if (is_object && refOptionObj.__type__ !== undefined) {
        refOptionObj = refOptionObj.__type__;
      }

      Validator$1.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
    }
    /**
     *
     * @param {string}  option           | the option property
     * @param {object}  options          | The supplied options object
     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */

  }, {
    key: "checkFields",
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var log = function log(message) {
        console.error("%c" + message + Validator$1.printLocation(path, option), VALIDATOR_PRINT_STYLE$1);
      };

      var optionType = Validator$1.getType(options[option]);
      var refOptionType = refOptionObj[optionType];

      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator$1.getType(refOptionType) === "array" && indexOf(refOptionType).call(refOptionType, options[option]) === -1) {
          log('Invalid option detected in "' + option + '".' + " Allowed values are:" + Validator$1.print(refOptionType) + ' not "' + options[option] + '". ');
          errorFound = true;
        } else if (optionType === "object" && referenceOption !== "__any__") {
          path = copyAndExtendArray(path, option);
          Validator$1.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj["any"] === undefined) {
        // type of the field is incorrect and the field cannot be any
        log('Invalid type received for "' + option + '". Expected: ' + Validator$1.print(keys$4(refOptionObj)) + ". Received [" + optionType + '] "' + options[option] + '"');
        errorFound = true;
      }
    }
    /**
     *
     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object
     * @returns {string}
     * @static
     */

  }, {
    key: "getType",
    value: function getType(object) {
      var type = _typeof(object);

      if (type === "object") {
        if (object === null) {
          return "null";
        }

        if (object instanceof Boolean) {
          return "boolean";
        }

        if (object instanceof Number) {
          return "number";
        }

        if (object instanceof String) {
          return "string";
        }

        if (isArray$2(object)) {
          return "array";
        }

        if (object instanceof Date) {
          return "date";
        }

        if (object.nodeType !== undefined) {
          return "dom";
        }

        if (object._isAMomentObject === true) {
          return "moment";
        }

        return "object";
      } else if (type === "number") {
        return "number";
      } else if (type === "boolean") {
        return "boolean";
      } else if (type === "string") {
        return "string";
      } else if (type === undefined) {
        return "undefined";
      }

      return type;
    }
    /**
     * @param {string} option
     * @param {object} options
     * @param {Array.<string>} path
     * @static
     */

  }, {
    key: "getSuggestion",
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator$1.findInOptions(option, options, path, false);
      var globalSearch = Validator$1.findInOptions(option, allOptions$1, [], true);
      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;
      var msg;

      if (localSearch.indexMatch !== undefined) {
        msg = " in " + Validator$1.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        msg = " in " + Validator$1.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator$1.printLocation(globalSearch.path, globalSearch.closestMatch, "");
      } else if (localSearch.distance <= localSearchThreshold) {
        msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator$1.printLocation(localSearch.path, option);
      } else {
        msg = ". Did you mean one of these: " + Validator$1.print(keys$4(options)) + Validator$1.printLocation(path, option);
      }

      console.error('%cUnknown option detected: "' + option + '"' + msg, VALIDATOR_PRINT_STYLE$1);
      errorFound = true;
    }
    /**
     * traverse the options in search for a match.
     *
     * @param {string} option
     * @param {object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */

  }, {
    key: "findInOptions",
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var min = 1e9;
      var closestMatch = "";
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;

      for (var op in options) {
        var distance = void 0;

        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator$1.findInOptions(option, options[op], copyAndExtendArray(path, op));

          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          var _context20;

          if (indexOf(_context20 = op.toLowerCase()).call(_context20, lowerCaseOption) !== -1) {
            indexMatch = op;
          }

          distance = Validator$1.levenshteinDistance(option, op);

          if (min > distance) {
            closestMatch = op;
            closestMatchPath = copyArray(path);
            min = distance;
          }
        }
      }

      return {
        closestMatch: closestMatch,
        path: closestMatchPath,
        distance: min,
        indexMatch: indexMatch
      };
    }
    /**
     * @param {Array.<string>} path
     * @param {object} option
     * @param {string} prefix
     * @returns {string}
     * @static
     */

  }, {
    key: "printLocation",
    value: function printLocation(path, option) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Problem value found at: \n";
      var str = "\n\n" + prefix + "options = {\n";

      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += "  ";
        }

        str += path[i] + ": {\n";
      }

      for (var _j = 0; _j < path.length + 1; _j++) {
        str += "  ";
      }

      str += option + "\n";

      for (var _i3 = 0; _i3 < path.length + 1; _i3++) {
        for (var _j2 = 0; _j2 < path.length - _i3; _j2++) {
          str += "  ";
        }

        str += "}\n";
      }

      return str + "\n\n";
    }
    /**
     * @param {object} options
     * @returns {string}
     * @static
     */

  }, {
    key: "print",
    value: function print(options) {
      return stringify$1(options).replace(/(")|(\[)|(\])|(,"__type__")/g, "").replace(/(,)/g, ", ");
    }
    /**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */

  }, {
    key: "levenshteinDistance",
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      var matrix = []; // increment along the first column of each row

      var i;

      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      } // increment each column in the first row


      var j;

      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      } // Fill in the rest of the matrix


      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator$1;
}();

var Activator = Activator$1;
var Configurator = Configurator$1;
var Hammer = Hammer$1;
var Popup = Popup$1;
var VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;
var Validator = Validator$1;

/* eslint-disable no-prototype-builtins */

/* eslint-disable no-unused-vars */

/* eslint-disable no-var */

/**
 * Parse a text source containing data in DOT language into a JSON object.
 * The object contains two lists: one with nodes and one with edges.
 *
 * DOT language reference: http://www.graphviz.org/doc/info/lang.html
 *
 * DOT language attributes: http://graphviz.org/content/attrs
 *
 * @param {string} data     Text containing a graph in DOT-notation
 * @returns {object} graph   An object containing two parameters:
 *                          {Object[]} nodes
 *                          {Object[]} edges
 *
 * -------------------------------------------
 * TODO
 * ====
 *
 * For label handling, this is an incomplete implementation. From docs (quote #3015):
 *
 * > the escape sequences "\n", "\l" and "\r" divide the label into lines, centered,
 * > left-justified, and right-justified, respectively.
 *
 * Source: http://www.graphviz.org/content/attrs#kescString
 *
 * > As another aid for readability, dot allows double-quoted strings to span multiple physical
 * > lines using the standard C convention of a backslash immediately preceding a newline
 * > character
 * > In addition, double-quoted strings can be concatenated using a '+' operator.
 * > As HTML strings can contain newline characters, which are used solely for formatting,
 * > the language does not allow escaped newlines or concatenation operators to be used
 * > within them.
 *
 * - Currently, only '\\n' is handled
 * - Note that text explicitly says 'labels'; the dot parser currently handles escape
 *   sequences in **all** strings.
 */
function parseDOT(data) {
  dot = data;
  return parseGraph();
} // mapping of attributes from DOT (the keys) to vis.js (the values)

var NODE_ATTR_MAPPING = {
  fontsize: "font.size",
  fontcolor: "font.color",
  labelfontcolor: "font.color",
  fontname: "font.face",
  color: ["color.border", "color.background"],
  fillcolor: "color.background",
  tooltip: "title",
  labeltooltip: "title"
};

var EDGE_ATTR_MAPPING = create$5(NODE_ATTR_MAPPING);

EDGE_ATTR_MAPPING.color = "color.color";
EDGE_ATTR_MAPPING.style = "dashes"; // token types enumeration

var TOKENTYPE = {
  NULL: 0,
  DELIMITER: 1,
  IDENTIFIER: 2,
  UNKNOWN: 3
}; // map with all delimiters

var DELIMITERS = {
  "{": true,
  "}": true,
  "[": true,
  "]": true,
  ";": true,
  "=": true,
  ",": true,
  "->": true,
  "--": true
};
var dot = ""; // current dot file

var index$1 = 0; // current index in dot file

var c = ""; // current token character in expr

var token = ""; // current token

var tokenType = TOKENTYPE.NULL; // type of the token

/**
 * Get the first character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */

function first() {
  index$1 = 0;
  c = dot.charAt(0);
}
/**
 * Get the next character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */


function next() {
  index$1++;
  c = dot.charAt(index$1);
}
/**
 * Preview the next character from the dot file.
 *
 * @returns {string} cNext
 */


function nextPreview() {
  return dot.charAt(index$1 + 1);
}
/**
 * Test whether given character is alphabetic or numeric ( a-zA-Z_0-9.:# )
 *
 * @param {string} c
 * @returns {boolean} isAlphaNumeric
 */


function isAlphaNumeric(c) {
  var charCode = c.charCodeAt(0);

  if (charCode < 47) {
    // #.
    return charCode === 35 || charCode === 46;
  }

  if (charCode < 59) {
    // 0-9 and :
    return charCode > 47;
  }

  if (charCode < 91) {
    // A-Z
    return charCode > 64;
  }

  if (charCode < 96) {
    // _
    return charCode === 95;
  }

  if (charCode < 123) {
    // a-z
    return charCode > 96;
  }

  return false;
}
/**
 * Merge all options of object b into object b
 *
 * @param {object} a
 * @param {object} b
 * @returns {object} a
 */


function merge$1(a, b) {
  if (!a) {
    a = {};
  }

  if (b) {
    for (var name in b) {
      if (b.hasOwnProperty(name)) {
        a[name] = b[name];
      }
    }
  }

  return a;
}
/**
 * Set a value in an object, where the provided parameter name can be a
 * path with nested parameters. For example:
 *
 *     var obj = {a: 2};
 *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
 *
 * @param {object} obj
 * @param {string} path  A parameter name or dot-separated parameter path,
 *                      like "color.highlight.border".
 * @param {*} value
 */


function setValue(obj, path, value) {
  var keys = path.split(".");
  var o = obj;

  while (keys.length) {
    var key = keys.shift();

    if (keys.length) {
      // this isn't the end point
      if (!o[key]) {
        o[key] = {};
      }

      o = o[key];
    } else {
      // this is the end point
      o[key] = value;
    }
  }
}
/**
 * Add a node to a graph object. If there is already a node with
 * the same id, their attributes will be merged.
 *
 * @param {object} graph
 * @param {object} node
 */


function addNode(graph, node) {
  var i, len;
  var current = null; // find root graph (in case of subgraph)

  var graphs = [graph]; // list with all graphs from current graph to root graph

  var root = graph;

  while (root.parent) {
    graphs.push(root.parent);
    root = root.parent;
  } // find existing node (at root level) by its id


  if (root.nodes) {
    for (i = 0, len = root.nodes.length; i < len; i++) {
      if (node.id === root.nodes[i].id) {
        current = root.nodes[i];
        break;
      }
    }
  }

  if (!current) {
    // this is a new node
    current = {
      id: node.id
    };

    if (graph.node) {
      // clone default attributes
      current.attr = merge$1(current.attr, graph.node);
    }
  } // add node to this (sub)graph and all its parent graphs


  for (i = graphs.length - 1; i >= 0; i--) {
    var _context;

    var g = graphs[i];

    if (!g.nodes) {
      g.nodes = [];
    }

    if (indexOf(_context = g.nodes).call(_context, current) === -1) {
      g.nodes.push(current);
    }
  } // merge attributes


  if (node.attr) {
    current.attr = merge$1(current.attr, node.attr);
  }
}
/**
 * Add an edge to a graph object
 *
 * @param {object} graph
 * @param {object} edge
 */


function addEdge(graph, edge) {
  if (!graph.edges) {
    graph.edges = [];
  }

  graph.edges.push(edge);

  if (graph.edge) {
    var attr = merge$1({}, graph.edge); // clone default attributes

    edge.attr = merge$1(attr, edge.attr); // merge attributes
  }
}
/**
 * Create an edge to a graph object
 *
 * @param {object} graph
 * @param {string | number | object} from
 * @param {string | number | object} to
 * @param {string} type
 * @param {object | null} attr
 * @returns {object} edge
 */


function createEdge(graph, from, to, type, attr) {
  var edge = {
    from: from,
    to: to,
    type: type
  };

  if (graph.edge) {
    edge.attr = merge$1({}, graph.edge); // clone default attributes
  }

  edge.attr = merge$1(edge.attr || {}, attr); // merge attributes
  // Move arrows attribute from attr to edge temporally created in
  // parseAttributeList().

  if (attr != null) {
    if (attr.hasOwnProperty("arrows") && attr["arrows"] != null) {
      edge["arrows"] = {
        to: {
          enabled: true,
          type: attr.arrows.type
        }
      };
      attr["arrows"] = null;
    }
  }

  return edge;
}
/**
 * Get next token in the current dot file.
 * The token and token type are available as token and tokenType
 */


function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = ""; // skip over whitespaces

  while (c === " " || c === "\t" || c === "\n" || c === "\r") {
    // space, tab, enter
    next();
  }

  do {
    var isComment = false; // skip comment

    if (c === "#") {
      // find the previous non-space character
      var i = index$1 - 1;

      while (dot.charAt(i) === " " || dot.charAt(i) === "\t") {
        i--;
      }

      if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
        // the # is at the start of a line, this is indeed a line comment
        while (c != "" && c != "\n") {
          next();
        }

        isComment = true;
      }
    }

    if (c === "/" && nextPreview() === "/") {
      // skip line comment
      while (c != "" && c != "\n") {
        next();
      }

      isComment = true;
    }

    if (c === "/" && nextPreview() === "*") {
      // skip block comment
      while (c != "") {
        if (c === "*" && nextPreview() === "/") {
          // end of block comment found. skip these last two characters
          next();
          next();
          break;
        } else {
          next();
        }
      }

      isComment = true;
    } // skip over whitespaces


    while (c === " " || c === "\t" || c === "\n" || c === "\r") {
      // space, tab, enter
      next();
    }
  } while (isComment); // check for end of dot file


  if (c === "") {
    // token is still empty
    tokenType = TOKENTYPE.DELIMITER;
    return;
  } // check for delimiters consisting of 2 characters


  var c2 = c + nextPreview();

  if (DELIMITERS[c2]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c2;
    next();
    next();
    return;
  } // check for delimiters consisting of 1 character


  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  } // check for an identifier (number or string)
  // TODO: more precise parsing of numbers/strings (and the port separator ':')


  if (isAlphaNumeric(c) || c === "-") {
    token += c;
    next();

    while (isAlphaNumeric(c)) {
      token += c;
      next();
    }

    if (token === "false") {
      token = false; // convert to boolean
    } else if (token === "true") {
      token = true; // convert to boolean
    } else if (!isNaN(Number(token))) {
      token = Number(token); // convert to number
    }

    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  } // check for a string enclosed by double quotes


  if (c === '"') {
    next();

    while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
      if (c === '"') {
        // skip the escape character
        token += c;
        next();
      } else if (c === "\\" && nextPreview() === "n") {
        // Honor a newline escape sequence
        token += "\n";
        next();
      } else {
        token += c;
      }

      next();
    }

    if (c != '"') {
      throw newSyntaxError('End of string " expected');
    }

    next();
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  } // something unknown is found, wrong characters, a syntax error


  tokenType = TOKENTYPE.UNKNOWN;

  while (c != "") {
    token += c;
    next();
  }

  throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
}
/**
 * Parse a graph.
 *
 * @returns {object} graph
 */


function parseGraph() {
  var graph = {};
  first();
  getToken(); // optional strict keyword

  if (token === "strict") {
    graph.strict = true;
    getToken();
  } // graph or digraph keyword


  if (token === "graph" || token === "digraph") {
    graph.type = token;
    getToken();
  } // optional graph id


  if (tokenType === TOKENTYPE.IDENTIFIER) {
    graph.id = token;
    getToken();
  } // open angle bracket


  if (token != "{") {
    throw newSyntaxError("Angle bracket { expected");
  }

  getToken(); // statements

  parseStatements(graph); // close angle bracket

  if (token != "}") {
    throw newSyntaxError("Angle bracket } expected");
  }

  getToken(); // end of file

  if (token !== "") {
    throw newSyntaxError("End of file expected");
  }

  getToken(); // remove temporary default options

  delete graph.node;
  delete graph.edge;
  delete graph.graph;
  return graph;
}
/**
 * Parse a list with statements.
 *
 * @param {object} graph
 */


function parseStatements(graph) {
  while (token !== "" && token != "}") {
    parseStatement(graph);

    if (token === ";") {
      getToken();
    }
  }
}
/**
 * Parse a single statement. Can be a an attribute statement, node
 * statement, a series of node statements and edge statements, or a
 * parameter.
 *
 * @param {object} graph
 */


function parseStatement(graph) {
  // parse subgraph
  var subgraph = parseSubgraph(graph);

  if (subgraph) {
    // edge statements
    parseEdge(graph, subgraph);
    return;
  } // parse an attribute statement


  var attr = parseAttributeStatement(graph);

  if (attr) {
    return;
  } // parse node


  if (tokenType != TOKENTYPE.IDENTIFIER) {
    throw newSyntaxError("Identifier expected");
  }

  var id = token; // id can be a string or a number

  getToken();

  if (token === "=") {
    // id statement
    getToken();

    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError("Identifier expected");
    }

    graph[id] = token;
    getToken(); // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
  } else {
    parseNodeStatement(graph, id);
  }
}
/**
 * Parse a subgraph
 *
 * @param {object} graph    parent graph object
 * @returns {object | null} subgraph
 */


function parseSubgraph(graph) {
  var subgraph = null; // optional subgraph keyword

  if (token === "subgraph") {
    subgraph = {};
    subgraph.type = "subgraph";
    getToken(); // optional graph id

    if (tokenType === TOKENTYPE.IDENTIFIER) {
      subgraph.id = token;
      getToken();
    }
  } // open angle bracket


  if (token === "{") {
    getToken();

    if (!subgraph) {
      subgraph = {};
    }

    subgraph.parent = graph;
    subgraph.node = graph.node;
    subgraph.edge = graph.edge;
    subgraph.graph = graph.graph; // statements

    parseStatements(subgraph); // close angle bracket

    if (token != "}") {
      throw newSyntaxError("Angle bracket } expected");
    }

    getToken(); // remove temporary default options

    delete subgraph.node;
    delete subgraph.edge;
    delete subgraph.graph;
    delete subgraph.parent; // register at the parent graph

    if (!graph.subgraphs) {
      graph.subgraphs = [];
    }

    graph.subgraphs.push(subgraph);
  }

  return subgraph;
}
/**
 * parse an attribute statement like "node [shape=circle fontSize=16]".
 * Available keywords are 'node', 'edge', 'graph'.
 * The previous list with default attributes will be replaced
 *
 * @param {object} graph
 * @returns {string | null} keyword Returns the name of the parsed attribute
 *                                  (node, edge, graph), or null if nothing
 *                                  is parsed.
 */


function parseAttributeStatement(graph) {
  // attribute statements
  if (token === "node") {
    getToken(); // node attributes

    graph.node = parseAttributeList();
    return "node";
  } else if (token === "edge") {
    getToken(); // edge attributes

    graph.edge = parseAttributeList();
    return "edge";
  } else if (token === "graph") {
    getToken(); // graph attributes

    graph.graph = parseAttributeList();
    return "graph";
  }

  return null;
}
/**
 * parse a node statement
 *
 * @param {object} graph
 * @param {string | number} id
 */


function parseNodeStatement(graph, id) {
  // node statement
  var node = {
    id: id
  };
  var attr = parseAttributeList();

  if (attr) {
    node.attr = attr;
  }

  addNode(graph, node); // edge statements

  parseEdge(graph, id);
}
/**
 * Parse an edge or a series of edges
 *
 * @param {object} graph
 * @param {string | number} from        Id of the from node
 */


function parseEdge(graph, from) {
  while (token === "->" || token === "--") {
    var to;
    var type = token;
    getToken();
    var subgraph = parseSubgraph(graph);

    if (subgraph) {
      to = subgraph;
    } else {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Identifier or subgraph expected");
      }

      to = token;
      addNode(graph, {
        id: to
      });
      getToken();
    } // parse edge attributes


    var attr = parseAttributeList(); // create edge

    var edge = createEdge(graph, from, to, type, attr);
    addEdge(graph, edge);
    from = to;
  }
}
/**
 * Parse a set with attributes,
 * for example [label="1.000", shape=solid]
 *
 * @returns {object | null} attr
 */


function parseAttributeList() {
  var i;
  var attr = null; // edge styles of dot and vis

  var edgeStyles = {
    dashed: true,
    solid: false,
    dotted: [1, 5]
  };
  /**
   * Define arrow types.
   * vis currently supports types defined in 'arrowTypes'.
   * Details of arrow shapes are described in
   * http://www.graphviz.org/content/arrow-shapes
   */

  var arrowTypes = {
    dot: "circle",
    box: "box",
    crow: "crow",
    curve: "curve",
    icurve: "inv_curve",
    normal: "triangle",
    inv: "inv_triangle",
    diamond: "diamond",
    tee: "bar",
    vee: "vee"
  };
  /**
   * 'attr_list' contains attributes for checking if some of them are affected
   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined
   * in DOT) make changes to 'arrows' attribute in vis.
   */

  var attr_list = new Array();
  var attr_names = new Array(); // used for checking the case.
  // parse attributes

  while (token === "[") {
    getToken();
    attr = {};

    while (token !== "" && token != "]") {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute name expected");
      }

      var name = token;
      getToken();

      if (token != "=") {
        throw newSyntaxError("Equal sign = expected");
      }

      getToken();

      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute value expected");
      }

      var value = token; // convert from dot style to vis

      if (name === "style") {
        value = edgeStyles[value];
      }

      var arrowType;

      if (name === "arrowhead") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          to: {
            enabled: true,
            type: arrowType
          }
        };
      }

      if (name === "arrowtail") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          from: {
            enabled: true,
            type: arrowType
          }
        };
      }

      attr_list.push({
        attr: attr,
        name: name,
        value: value
      });
      attr_names.push(name);
      getToken();

      if (token == ",") {
        getToken();
      }
    }

    if (token != "]") {
      throw newSyntaxError("Bracket ] expected");
    }

    getToken();
  }
  /**
   * As explained in [1], graphviz has limitations for combination of
   * arrow[head|tail] and dir. If attribute list includes 'dir',
   * following cases just be supported.
   *   1. both or none + arrowhead, arrowtail
   *   2. forward + arrowhead (arrowtail is not affedted)
   *   3. back + arrowtail (arrowhead is not affected)
   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note
   */


  if (includes(attr_names).call(attr_names, "dir")) {
    var idx = {}; // get index of 'arrows' and 'dir'

    idx.arrows = {};

    for (i = 0; i < attr_list.length; i++) {
      if (attr_list[i].name === "arrows") {
        if (attr_list[i].value.to != null) {
          idx.arrows.to = i;
        } else if (attr_list[i].value.from != null) {
          idx.arrows.from = i;
        } else {
          throw newSyntaxError("Invalid value of arrows");
        }
      } else if (attr_list[i].name === "dir") {
        idx.dir = i;
      }
    } // first, add default arrow shape if it is not assigned to avoid error


    var dir_type = attr_list[idx.dir].value;

    if (!includes(attr_names).call(attr_names, "arrows")) {
      if (dir_type === "both") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "forward") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
      } else if (dir_type === "back") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "none") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: ""
        });
        idx.arrows.to = attr_list.length - 1;
      } else {
        throw newSyntaxError('Invalid dir type "' + dir_type + '"');
      }
    }

    var from_type;
    var to_type; // update 'arrows' attribute from 'dir'.

    if (dir_type === "both") {
      // both of shapes of 'from' and 'to' are given
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };

        splice$1(attr_list).call(attr_list, idx.arrows.from, 1); // shape of 'to' is assigned and use default to 'from'

      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "arrow";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // only shape of 'from' is assigned and use default for 'to'
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
    } else if (dir_type === "back") {
      // given both of shapes, but use only 'from'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // given shape of 'to', but does not use it
      } else if (idx.arrows.to) {
        to_type = "";
        from_type = "arrow";
        idx.arrows.from = idx.arrows.to;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // assign given 'from' shape
      } else if (idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }

      attr_list[idx.arrows.from] = {
        attr: attr_list[idx.arrows.from].attr,
        name: attr_list[idx.arrows.from].name,
        value: {
          from: {
            enabled: true,
            type: attr_list[idx.arrows.from].value.from.type
          }
        }
      };
    } else if (dir_type === "none") {
      var idx_arrow;

      if (idx.arrows.to) {
        idx_arrow = idx.arrows.to;
      } else {
        idx_arrow = idx.arrows.from;
      }

      attr_list[idx_arrow] = {
        attr: attr_list[idx_arrow].attr,
        name: attr_list[idx_arrow].name,
        value: ""
      };
    } else if (dir_type === "forward") {
      // given both of shapes, but use only 'to'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // assign given 'to' shape
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // given shape of 'from', but does not use it
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = "";
        idx.arrows.to = idx.arrows.from;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }

      attr_list[idx.arrows.to] = {
        attr: attr_list[idx.arrows.to].attr,
        name: attr_list[idx.arrows.to].name,
        value: {
          to: {
            enabled: true,
            type: attr_list[idx.arrows.to].value.to.type
          }
        }
      };
    } else {
      throw newSyntaxError('Invalid dir type "' + dir_type + '"');
    } // remove 'dir' attribute no need anymore


    splice$1(attr_list).call(attr_list, idx.dir, 1);
  } // parse 'penwidth'


  var nof_attr_list;

  if (includes(attr_names).call(attr_names, "penwidth")) {
    var tmp_attr_list = [];
    nof_attr_list = attr_list.length;

    for (i = 0; i < nof_attr_list; i++) {
      // exclude 'width' from attr_list if 'penwidth' exists
      if (attr_list[i].name !== "width") {
        if (attr_list[i].name === "penwidth") {
          attr_list[i].name = "width";
        }

        tmp_attr_list.push(attr_list[i]);
      }
    }

    attr_list = tmp_attr_list;
  }

  nof_attr_list = attr_list.length;

  for (i = 0; i < nof_attr_list; i++) {
    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
  }

  return attr;
}
/**
 * Create a syntax error with extra information on current token and index.
 *
 * @param {string} message
 * @returns {SyntaxError} err
 */


function newSyntaxError(message) {
  return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index$1 + ")");
}
/**
 * Chop off text after a maximum length
 *
 * @param {string} text
 * @param {number} maxLength
 * @returns {string}
 */


function chop(text, maxLength) {
  return text.length <= maxLength ? text : text.substr(0, 27) + "...";
}
/**
 * Execute a function fn for each pair of elements in two arrays
 *
 * @param {Array | *} array1
 * @param {Array | *} array2
 * @param {Function} fn
 */


function forEach2(array1, array2, fn) {
  if (isArray$2(array1)) {
    forEach$2(array1).call(array1, function (elem1) {
      if (isArray$2(array2)) {
        forEach$2(array2).call(array2, function (elem2) {
          fn(elem1, elem2);
        });
      } else {
        fn(elem1, array2);
      }
    });
  } else {
    if (isArray$2(array2)) {
      forEach$2(array2).call(array2, function (elem2) {
        fn(array1, elem2);
      });
    } else {
      fn(array1, array2);
    }
  }
}
/**
 * Set a nested property on an object
 * When nested objects are missing, they will be created.
 * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
 *
 * @param {object} object
 * @param {string} path   A dot separated string like 'font.color'
 * @param {*} value       Value for the property
 * @returns {object} Returns the original object, allows for chaining.
 */


function setProp(object, path, value) {
  var names = path.split(".");
  var prop = names.pop(); // traverse over the nested objects

  var obj = object;

  for (var i = 0; i < names.length; i++) {
    var name = names[i];

    if (!(name in obj)) {
      obj[name] = {};
    }

    obj = obj[name];
  } // set the property value


  obj[prop] = value;
  return object;
}
/**
 * Convert an object with DOT attributes to their vis.js equivalents.
 *
 * @param {object} attr     Object with DOT attributes
 * @param {object} mapping
 * @returns {object}         Returns an object with vis.js attributes
 */


function convertAttr(attr, mapping) {
  var converted = {};

  for (var prop in attr) {
    if (attr.hasOwnProperty(prop)) {
      var visProp = mapping[prop];

      if (isArray$2(visProp)) {
        forEach$2(visProp).call(visProp, function (visPropI) {
          setProp(converted, visPropI, attr[prop]);
        });
      } else if (typeof visProp === "string") {
        setProp(converted, visProp, attr[prop]);
      } else {
        setProp(converted, prop, attr[prop]);
      }
    }
  }

  return converted;
}
/**
 * Convert a string containing a graph in DOT language into a map containing
 * with nodes and edges in the format of graph.
 *
 * @param {string} data         Text containing a graph in DOT-notation
 * @returns {object} graphData
 */


function DOTToGraph(data) {
  // parse the DOT file
  var dotData = parseDOT(data);
  var graphData = {
    nodes: [],
    edges: [],
    options: {}
  }; // copy the nodes

  if (dotData.nodes) {
    var _context2;

    forEach$2(_context2 = dotData.nodes).call(_context2, function (dotNode) {
      var graphNode = {
        id: dotNode.id,
        label: String(dotNode.label || dotNode.id)
      };
      merge$1(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));

      if (graphNode.image) {
        graphNode.shape = "image";
      }

      graphData.nodes.push(graphNode);
    });
  } // copy the edges


  if (dotData.edges) {
    var _context3;

    /**
     * Convert an edge in DOT format to an edge with VisGraph format
     *
     * @param {object} dotEdge
     * @returns {object} graphEdge
     */
    var convertEdge = function convertEdge(dotEdge) {
      var graphEdge = {
        from: dotEdge.from,
        to: dotEdge.to
      };
      merge$1(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING)); // Add arrows attribute to default styled arrow.
      // The reason why default style is not added in parseAttributeList() is
      // because only default is cleared before here.

      if (graphEdge.arrows == null && dotEdge.type === "->") {
        graphEdge.arrows = "to";
      }

      return graphEdge;
    };

    forEach$2(_context3 = dotData.edges).call(_context3, function (dotEdge) {
      var from, to;

      if (dotEdge.from instanceof Object) {
        from = dotEdge.from.nodes;
      } else {
        from = {
          id: dotEdge.from
        };
      }

      if (dotEdge.to instanceof Object) {
        to = dotEdge.to.nodes;
      } else {
        to = {
          id: dotEdge.to
        };
      }

      if (dotEdge.from instanceof Object && dotEdge.from.edges) {
        var _context4;

        forEach$2(_context4 = dotEdge.from.edges).call(_context4, function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }

      forEach2(from, to, function (from, to) {
        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
        var graphEdge = convertEdge(subEdge);
        graphData.edges.push(graphEdge);
      });

      if (dotEdge.to instanceof Object && dotEdge.to.edges) {
        var _context5;

        forEach$2(_context5 = dotEdge.to.edges).call(_context5, function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
    });
  } // copy the options


  if (dotData.attr) {
    graphData.options = dotData.attr;
  }

  return graphData;
}
/* eslint-enable no-var */

/* eslint-enable no-unused-vars */

/* eslint-enable no-prototype-builtins */

var dotparser = /*#__PURE__*/Object.freeze({
	__proto__: null,
	parseDOT: parseDOT,
	DOTToGraph: DOTToGraph
});

/**
 * Convert Gephi to Vis.
 *
 * @param gephiJSON - The parsed JSON data in Gephi format.
 * @param optionsObj - Additional options.
 * @returns The converted data ready to be used in Vis.
 */
function parseGephi(gephiJSON, optionsObj) {
  var _context;

  var options = {
    edges: {
      inheritColor: false
    },
    nodes: {
      fixed: false,
      parseColor: false
    }
  };

  if (optionsObj != null) {
    if (optionsObj.fixed != null) {
      options.nodes.fixed = optionsObj.fixed;
    }

    if (optionsObj.parseColor != null) {
      options.nodes.parseColor = optionsObj.parseColor;
    }

    if (optionsObj.inheritColor != null) {
      options.edges.inheritColor = optionsObj.inheritColor;
    }
  }

  var gEdges = gephiJSON.edges;

  var vEdges = map$3(gEdges).call(gEdges, function (gEdge) {
    var vEdge = {
      from: gEdge.source,
      id: gEdge.id,
      to: gEdge.target
    };

    if (gEdge.attributes != null) {
      vEdge.attributes = gEdge.attributes;
    }

    if (gEdge.label != null) {
      vEdge.label = gEdge.label;
    }

    if (gEdge.attributes != null && gEdge.attributes.title != null) {
      vEdge.title = gEdge.attributes.title;
    }

    if (gEdge.type === "Directed") {
      vEdge.arrows = "to";
    } // edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;
    // edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;


    if (gEdge.color && options.edges.inheritColor === false) {
      vEdge.color = gEdge.color;
    }

    return vEdge;
  });

  var vNodes = map$3(_context = gephiJSON.nodes).call(_context, function (gNode) {
    var vNode = {
      id: gNode.id,
      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null
    };

    if (gNode.attributes != null) {
      vNode.attributes = gNode.attributes;
    }

    if (gNode.label != null) {
      vNode.label = gNode.label;
    }

    if (gNode.size != null) {
      vNode.size = gNode.size;
    }

    if (gNode.attributes != null && gNode.attributes.title != null) {
      vNode.title = gNode.attributes.title;
    }

    if (gNode.title != null) {
      vNode.title = gNode.title;
    }

    if (gNode.x != null) {
      vNode.x = gNode.x;
    }

    if (gNode.y != null) {
      vNode.y = gNode.y;
    }

    if (gNode.color != null) {
      if (options.nodes.parseColor === true) {
        vNode.color = gNode.color;
      } else {
        vNode.color = {
          background: gNode.color,
          border: gNode.color,
          highlight: {
            background: gNode.color,
            border: gNode.color
          },
          hover: {
            background: gNode.color,
            border: gNode.color
          }
        };
      }
    }

    return vNode;
  });

  return {
    nodes: vNodes,
    edges: vEdges
  };
}

var gephiParser = /*#__PURE__*/Object.freeze({
	__proto__: null,
	parseGephi: parseGephi
});

// English
var en = {
  addDescription: "Click in an empty space to place a new node.",
  addEdge: "Add Edge",
  addNode: "Add Node",
  back: "Back",
  close: "Close",
  createEdgeError: "Cannot link edges to a cluster.",
  del: "Delete selected",
  deleteClusterError: "Clusters cannot be deleted.",
  edgeDescription: "Click on a node and drag the edge to another node to connect them.",
  edit: "Edit",
  editClusterError: "Clusters cannot be edited.",
  editEdge: "Edit Edge",
  editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
  editNode: "Edit Node"
}; // German

var de = {
  addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
  addEdge: "Kante hinzuf\xFCgen",
  addNode: "Knoten hinzuf\xFCgen",
  back: "Zur\xFCck",
  close: "SchlieÃen",
  createEdgeError: "Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.",
  del: "L\xF6sche Auswahl",
  deleteClusterError: "Cluster k\xF6nnen nicht gel\xF6scht werden.",
  edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
  edit: "Editieren",
  editClusterError: "Cluster k\xF6nnen nicht editiert werden.",
  editEdge: "Kante editieren",
  editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
  editNode: "Knoten editieren"
}; // Spanish

var es = {
  addDescription: "Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.",
  addEdge: "A\xF1adir arista",
  addNode: "A\xF1adir nodo",
  back: "Atr\xE1s",
  close: "Cerrar",
  createEdgeError: "No se puede conectar una arista a un grupo.",
  del: "Eliminar selecci\xF3n",
  deleteClusterError: "No es posible eliminar grupos.",
  edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
  edit: "Editar",
  editClusterError: "No es posible editar grupos.",
  editEdge: "Editar arista",
  editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
  editNode: "Editar nodo"
}; //Italiano

var it = {
  addDescription: "Clicca per aggiungere un nuovo nodo",
  addEdge: "Aggiungi un vertice",
  addNode: "Aggiungi un nodo",
  back: "Indietro",
  close: "Chiudere",
  createEdgeError: "Non si possono collegare vertici ad un cluster",
  del: "Cancella la selezione",
  deleteClusterError: "I cluster non possono essere cancellati",
  edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
  edit: "Modifica",
  editClusterError: "I clusters non possono essere modificati.",
  editEdge: "Modifica il vertice",
  editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
  editNode: "Modifica il nodo"
}; // Dutch

var nl = {
  addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
  addEdge: "Link toevoegen",
  addNode: "Node toevoegen",
  back: "Terug",
  close: "Sluiten",
  createEdgeError: "Kan geen link maken naar een cluster.",
  del: "Selectie verwijderen",
  deleteClusterError: "Clusters kunnen niet worden verwijderd.",
  edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
  edit: "Wijzigen",
  editClusterError: "Clusters kunnen niet worden aangepast.",
  editEdge: "Link wijzigen",
  editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
  editNode: "Node wijzigen"
}; // Portuguese Brazil

var pt = {
  addDescription: "Clique em um espaÃ§o em branco para adicionar um novo nÃ³",
  addEdge: "Adicionar aresta",
  addNode: "Adicionar nÃ³",
  back: "Voltar",
  close: "Fechar",
  createEdgeError: "NÃ£o foi possÃ­vel linkar arestas a um cluster.",
  del: "Remover selecionado",
  deleteClusterError: "Clusters nÃ£o puderam ser removidos.",
  edgeDescription: "Clique em um nÃ³ e arraste a aresta atÃ© outro nÃ³ para conectÃ¡-los",
  edit: "Editar",
  editClusterError: "Clusters nÃ£o puderam ser editados.",
  editEdge: "Editar aresta",
  editEdgeDescription: "Clique nos pontos de controle e os arraste para um nÃ³ para conectÃ¡-los",
  editNode: "Editar nÃ³"
}; // Russian

var ru = {
  addDescription: "ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð² ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ðµ Ð¼ÐµÑÑÐ¾, ÑÑÐ¾Ð±Ñ Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð½Ð¾Ð²ÑÐ¹ ÑÐ·ÐµÐ».",
  addEdge: "ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐµÐ±ÑÐ¾",
  addNode: "ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐ·ÐµÐ»",
  back: "ÐÐ°Ð·Ð°Ð´",
  close: "ÐÐ°ÐºÑÑÐ²Ð°ÑÑ",
  createEdgeError: "ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ ÑÐµÐ±ÑÐ° Ð² ÐºÐ»Ð°ÑÑÐµÑ.",
  del: "Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ðµ",
  deleteClusterError: "ÐÐ»Ð°ÑÑÐµÑÑ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐ´Ð°Ð»ÐµÐ½Ñ",
  edgeDescription: "ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÑÐ·ÐµÐ» Ð¸ Ð¿ÑÐ¾ÑÑÐ½Ð¸ÑÐµ ÑÐµÐ±ÑÐ¾ Ðº Ð´ÑÑÐ³Ð¾Ð¼Ñ ÑÐ·Ð»Ñ, ÑÑÐ¾Ð±Ñ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ Ð¸Ñ.",
  edit: "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ",
  editClusterError: "ÐÐ»Ð°ÑÑÐµÑÑ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ.",
  editEdge: "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐµÐ±ÑÐ¾",
  editEdgeDescription: "ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½ÑÐµ ÑÐ¾ÑÐºÐ¸ Ð¸ Ð¿ÐµÑÐµÑÐ°ÑÐ¸ÑÐµ Ð¸Ñ Ð² ÑÐ·ÐµÐ», ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ Ðº Ð½ÐµÐ¼Ñ.",
  editNode: "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ·ÐµÐ»"
}; // Chinese

var cn = {
  addDescription: "åå»ç©ºç½å¤æ¾ç½®æ°èç¹ã",
  addEdge: "æ·»å è¿æ¥çº¿",
  addNode: "æ·»å èç¹",
  back: "è¿å",
  close: "éé",
  createEdgeError: "æ æ³å°è¿æ¥çº¿è¿æ¥å°ç¾¤éã",
  del: "å é¤éå®",
  deleteClusterError: "æ æ³å é¤ç¾¤éã",
  edgeDescription: "åå»æä¸ªèç¹å¹¶å°è¯¥è¿æ¥çº¿æå¨å°å¦ä¸ä¸ªèç¹ä»¥è¿æ¥å®ä»¬ã",
  edit: "ç¼è¾",
  editClusterError: "æ æ³ç¼è¾ç¾¤éã",
  editEdge: "ç¼è¾è¿æ¥çº¿",
  editEdgeDescription: "åå»æ§å¶èç¹å¹¶å°å®ä»¬æå°èç¹ä¸è¿æ¥ã",
  editNode: "ç¼è¾èç¹"
}; // Ukrainian

var uk = {
  addDescription: "KÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ»ÑÐ½Ðµ Ð¼ÑÑÑÐµ, ÑÐ¾Ð± Ð´Ð¾Ð´Ð°ÑÐ¸ Ð½Ð¾Ð²Ð¸Ð¹ Ð²ÑÐ·Ð¾Ð».",
  addEdge: "ÐÐ¾Ð´Ð°ÑÐ¸ ÐºÑÐ°Ð¹",
  addNode: "ÐÐ¾Ð´Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»",
  back: "ÐÐ°Ð·Ð°Ð´",
  close: "ÐÐ°ÐºÑÐ¸ÑÐ¸",
  createEdgeError: "ÐÐµ Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð¾Ð±'ÑÐ´Ð½Ð°ÑÐ¸ ÐºÑÐ°Ñ Ð² Ð³ÑÑÐ¿Ñ.",
  del: "ÐÐ¸Ð´Ð°Ð»Ð¸ÑÐ¸ Ð¾Ð±ÑÐ°Ð½Ðµ",
  deleteClusterError: "ÐÑÑÐ¿Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÑÑÑ Ð±ÑÑÐ¸ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ñ.",
  edgeDescription: "ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ·Ð¾Ð» Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÐºÑÐ°Ð¹ Ð´Ð¾ ÑÐ½ÑÐ¾Ð³Ð¾ Ð²ÑÐ·Ð»Ð°, ÑÐ¾Ð± ÑÑ Ð·'ÑÐ´Ð½Ð°ÑÐ¸.",
  edit: "Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸",
  editClusterError: "ÐÑÑÐ¿Ð¸ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°Ð³ÑÐ²Ð°Ð½Ð½Ñ.",
  editEdge: "Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ ÐºÑÐ°Ð¹",
  editEdgeDescription: "ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½Ñ ÑÐ¾ÑÐºÐ¸ Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÑÑ Ñ Ð²ÑÐ·Ð¾Ð», ÑÐ¾Ð± Ð¿ÑÐ´ÐºÐ»ÑÑÐ¸ÑÐ¸ÑÑ Ð´Ð¾ Ð½ÑÐ¾Ð³Ð¾.",
  editNode: "Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»"
}; // French

var fr = {
  addDescription: "Cliquez dans un endroit vide pour placer un nÅud.",
  addEdge: "Ajouter un lien",
  addNode: "Ajouter un nÅud",
  back: "Retour",
  close: "Fermer",
  createEdgeError: "Impossible de crÃ©er un lien vers un cluster.",
  del: "Effacer la sÃ©lection",
  deleteClusterError: "Les clusters ne peuvent pas Ãªtre effacÃ©s.",
  edgeDescription: "Cliquez sur un nÅud et glissez le lien vers un autre nÅud pour les connecter.",
  edit: "Ãditer",
  editClusterError: "Les clusters ne peuvent pas Ãªtre Ã©ditÃ©s.",
  editEdge: "Ãditer le lien",
  editEdgeDescription: "Cliquez sur les points de contrÃ´le et glissez-les pour connecter un nÅud.",
  editNode: "Ãditer le nÅud"
}; // Czech

var cs = {
  addDescription: "KluknutÃ­m do prÃ¡zdnÃ©ho prostoru mÅ¯Å¾ete pÅidat novÃ½ vrchol.",
  addEdge: "PÅidat hranu",
  addNode: "PÅidat vrchol",
  back: "ZpÄt",
  close: "ZavÅÃ­t",
  createEdgeError: "Nelze pÅipojit hranu ke shluku.",
  del: "Smazat vÃ½bÄr",
  deleteClusterError: "Nelze mazat shluky.",
  edgeDescription: "PÅetaÅ¾enÃ­m z jednoho vrcholu do druhÃ©ho mÅ¯Å¾ete spojit tyto vrcholy novou hranou.",
  edit: "Upravit",
  editClusterError: "Nelze upravovat shluky.",
  editEdge: "Upravit hranu",
  editEdgeDescription: "PÅetaÅ¾enÃ­m kontrolnÃ­ho vrcholu hrany ji mÅ¯Å¾ete pÅipojit k jinÃ©mu vrcholu.",
  editNode: "Upravit vrchol"
};

var locales = /*#__PURE__*/Object.freeze({
	__proto__: null,
	en: en,
	de: de,
	es: es,
	it: it,
	nl: nl,
	pt: pt,
	ru: ru,
	cn: cn,
	uk: uk,
	fr: fr,
	cs: cs
});

/**
 * Normalizes language code into the format used internally.
 *
 * @param locales - All the available locales.
 * @param rawCode - The original code as supplied by the user.
 * @returns Language code in the format language-COUNTRY or language, eventually
 * fallbacks to en.
 */
function normalizeLanguageCode(locales, rawCode) {
  try {
    var _rawCode$split = rawCode.split(/[-_ /]/, 2),
        _rawCode$split2 = _slicedToArray(_rawCode$split, 2),
        rawLanguage = _rawCode$split2[0],
        rawCountry = _rawCode$split2[1];

    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;
    var country = rawCountry != null ? rawCountry.toUpperCase() : null;

    if (language && country) {
      var code = language + "-" + country;

      if (Object.prototype.hasOwnProperty.call(locales, code)) {
        return code;
      } else {
        var _context;

        console.warn(concat(_context = "Unknown variant ".concat(country, " of language ")).call(_context, language, "."));
      }
    }

    if (language) {
      var _code = language;

      if (Object.prototype.hasOwnProperty.call(locales, _code)) {
        return _code;
      } else {
        console.warn("Unknown language ".concat(language));
      }
    }

    console.warn("Unknown locale ".concat(rawCode, ", falling back to English."));
    return "en";
  } catch (error) {
    console.error(error);
    console.warn("Unexpected error while normalizing locale ".concat(rawCode, ", falling back to English."));
    return "en";
  }
}

/**
 * Associates a canvas to a given image, containing a number of renderings
 * of the image at various sizes.
 *
 * This technique is known as 'mipmapping'.
 *
 * NOTE: Images can also be of type 'data:svg+xml`. This code also works
 *       for svg, but the mipmapping may not be necessary.
 *
 * @param {Image} image
 */
var CachedImage = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function CachedImage() {
    _classCallCheck(this, CachedImage);

    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array

    this.image = new Image();
    this.canvas = document.createElement("canvas");
  }
  /**
   * Called when the image has been successfully loaded.
   */


  _createClass(CachedImage, [{
    key: "init",
    value: function init() {
      if (this.initialized()) return;
      this.src = this.image.src; // For same interface with Image

      var w = this.image.width;
      var h = this.image.height; // Ease external access

      this.width = w;
      this.height = h;
      var h2 = Math.floor(h / 2);
      var h4 = Math.floor(h / 4);
      var h8 = Math.floor(h / 8);
      var h16 = Math.floor(h / 16);
      var w2 = Math.floor(w / 2);
      var w4 = Math.floor(w / 4);
      var w8 = Math.floor(w / 8);
      var w16 = Math.floor(w / 16); // Make canvas as small as possible

      this.canvas.width = 3 * w4;
      this.canvas.height = h2; // Coordinates and sizes of images contained in the canvas
      // Values per row:  [top x, left y, width, height]

      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];

      this._fillMipMap();
    }
    /**
     * @returns {boolean} true if init() has been called, false otherwise.
     */

  }, {
    key: "initialized",
    value: function initialized() {
      return this.coordinates !== undefined;
    }
    /**
     * Redraw main image in various sizes to the context.
     *
     * The rationale behind this is to reduce artefacts due to interpolation
     * at differing zoom levels.
     *
     * Source: http://stackoverflow.com/q/18761404/1223531
     *
     * This methods takes the resizing out of the drawing loop, in order to
     * reduce performance overhead.
     *
     * TODO: The code assumes that a 2D context can always be gotten. This is
     *       not necessarily true! OTOH, if not true then usage of this class
     *       is senseless.
     *
     * @private
     */

  }, {
    key: "_fillMipMap",
    value: function _fillMipMap() {
      var ctx = this.canvas.getContext("2d"); // First zoom-level comes from the image

      var to = this.coordinates[0];
      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]); // The rest are copy actions internal to the canvas/context

      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
        var from = this.coordinates[iterations - 1];
        var _to = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);
      }
    }
    /**
     * Draw the image, using the mipmap if necessary.
     *
     * MipMap is only used if param factor > 2; otherwise, original bitmap
     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
     *
     * Credits to 'Alex de Mulder' for original implementation.
     *
     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
     * @param {Float} factor scale factor at which to draw
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     */

  }, {
    key: "drawImageAtPosition",
    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
      if (!this.initialized()) return; //can't draw image yet not intialized

      if (factor > 2) {
        // Determine which zoomed image to use
        factor *= 0.5;
        var iterations = 0;

        while (factor > 2 && iterations < this.NUM_ITERATIONS) {
          factor *= 0.5;
          iterations += 1;
        }

        if (iterations >= this.NUM_ITERATIONS) {
          iterations = this.NUM_ITERATIONS - 1;
        } //console.log("iterations: " + iterations);


        var from = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);
      } else {
        // Draw image directly
        ctx.drawImage(this.image, left, top, width, height);
      }
    }
  }]);

  return CachedImage;
}();

/**
 * This callback is a callback that accepts an Image.
 *
 * @callback ImageCallback
 * @param {Image} image
 */

/**
 * This class loads images and keeps them stored.
 *
 * @param {ImageCallback} callback
 */

var Images = /*#__PURE__*/function () {
  /**
   * @param {ImageCallback} callback
   */
  function Images(callback) {
    _classCallCheck(this, Images);

    this.images = {};
    this.imageBroken = {};
    this.callback = callback;
  }
  /**
   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
   * @param {string} brokenUrl                Url the broken image to try and load
   * @param {Image} imageToLoadBrokenUrlOn   The image object
   */


  _createClass(Images, [{
    key: "_tryloadBrokenUrl",
    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
      //If these parameters aren't specified then exit the function because nothing constructive can be done
      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;

      if (brokenUrl === undefined) {
        console.warn("No broken url image defined");
        return;
      } //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl


      imageToLoadBrokenUrlOn.image.onerror = function () {
        console.error("Could not load brokenImage:", brokenUrl); // cache item will contain empty image, this should be OK for default
      }; //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image


      imageToLoadBrokenUrlOn.image.src = brokenUrl;
    }
    /**
     *
     * @param {vis.Image} imageToRedrawWith
     * @private
     */

  }, {
    key: "_redrawWithImage",
    value: function _redrawWithImage(imageToRedrawWith) {
      if (this.callback) {
        this.callback(imageToRedrawWith);
      }
    }
    /**
     * @param {string} url          Url of the image
     * @param {string} brokenUrl    Url of an image to use if the url image is not found
     * @returns {Image} img          The image object
     */

  }, {
    key: "load",
    value: function load(url, brokenUrl) {
      var _this = this;

      //Try and get the image from the cache, if successful then return the cached image
      var cachedImage = this.images[url];
      if (cachedImage) return cachedImage; //Create a new image

      var img = new CachedImage(); // Need to add to cache here, otherwise final return will spawn different copies of the same image,
      // Also, there will be multiple loads of the same image.

      this.images[url] = img; //Subscribe to the event that is raised if the image loads successfully

      img.image.onload = function () {
        // Properly init the cached item and then request a redraw
        _this._fixImageCoordinates(img.image);

        img.init();

        _this._redrawWithImage(img);
      }; //Subscribe to the event that is raised if the image fails to load


      img.image.onerror = function () {
        console.error("Could not load image:", url); //Try and load the image specified by the brokenUrl using

        _this._tryloadBrokenUrl(url, brokenUrl, img);
      }; //Set the source of the image to the url, this is what actually kicks off the loading of the image


      img.image.src = url; //Return the new image

      return img;
    }
    /**
     * IE11 fix -- thanks dponch!
     *
     * Local helper function
     *
     * @param {vis.Image} imageToCache
     * @private
     */

  }, {
    key: "_fixImageCoordinates",
    value: function _fixImageCoordinates(imageToCache) {
      if (imageToCache.width === 0) {
        document.body.appendChild(imageToCache);
        imageToCache.width = imageToCache.offsetWidth;
        imageToCache.height = imageToCache.offsetHeight;
        document.body.removeChild(imageToCache);
      }
    }
  }]);

  return Images;
}();

var internalMetadata = {exports: {}};

var fails$7 = fails$t;
var arrayBufferNonExtensible = fails$7(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8); // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe

    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
      value: 8
    });
  }
});

var fails$6 = fails$t;
var isObject$6 = isObject$j;
var classof$4 = classofRaw$1;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible; // eslint-disable-next-line es/no-object-isextensible -- safe

var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$1 = fails$6(function () {
  $isExtensible(1);
}); // `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible

var objectIsExtensible = FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$6(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$4(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

var fails$5 = fails$t;
var freezing = !fails$5(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});

var $$e = _export;
var uncurryThis$4 = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$5 = isObject$j;
var hasOwn$5 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid = uid$4;
var FREEZING = freezing;
var REQUIRED = false;
var METADATA = uid('meta');
var id$1 = 0;

var setMetadata = function (it) {
  defineProperty$2(it, METADATA, {
    value: {
      objectID: 'O' + id$1++,
      // object ID
      weakData: {} // weak collections IDs

    }
  });
};

var fastKey$1 = function (it, create) {
  // return a primitive with prefix
  if (!isObject$5(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!hasOwn$5(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible$1(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMetadata(it); // return object ID
  }

  return it[METADATA].objectID;
};

var getWeakData$1 = function (it, create) {
  if (!hasOwn$5(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible$1(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMetadata(it); // return the store of weak collections IDs
  }

  return it[METADATA].weakData;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible$1(it) && !hasOwn$5(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () {
    /* empty */
  };

  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis$4([].splice);
  var test = {};
  test[METADATA] = 1; // prevent exposing of metadata key

  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);

      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      }

      return result;
    };

    $$e({
      target: 'Object',
      stat: true,
      forced: true
    }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = internalMetadata.exports = {
  enable: enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

var global$a = global$P;
var bind$3 = functionBindContext;
var call$1 = functionCall;
var anObject$3 = anObject$d;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$d;
var isPrototypeOf$9 = objectIsPrototypeOf;
var getIterator$5 = getIterator$7;
var getIteratorMethod = getIteratorMethod$8;
var iteratorClose = iteratorClose$2;
var TypeError$5 = global$a.TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

var iterate$3 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$3(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }

    return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError$5(tryToString$1(iterable) + ' is not iterable'); // optimisation for array iterators

    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$4(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$9(ResultPrototype, result)) return result;
      }

      return new Result(false);
    }

    iterator = getIterator$5(iterable, iterFn);
  }

  next = iterator.next;

  while (!(step = call$1(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }

    if (typeof result == 'object' && result && isPrototypeOf$9(ResultPrototype, result)) return result;
  }

  return new Result(false);
};

var global$9 = global$P;
var isPrototypeOf$8 = objectIsPrototypeOf;
var TypeError$4 = global$9.TypeError;

var anInstance$3 = function (it, Prototype) {
  if (isPrototypeOf$8(Prototype, it)) return it;
  throw TypeError$4('Incorrect invocation');
};

var $$d = _export;
var global$8 = global$P;
var InternalMetadataModule$1 = internalMetadata.exports;
var fails$4 = fails$t;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var iterate$2 = iterate$3;
var anInstance$2 = anInstance$3;
var isCallable = isCallable$h;
var isObject$4 = isObject$j;
var setToStringTag = setToStringTag$5;
var defineProperty$1 = objectDefineProperty.f;
var forEach = arrayIteration.forEach;
var DESCRIPTORS$2 = descriptors;
var InternalStateModule$2 = internalState;
var setInternalState$2 = InternalStateModule$2.set;
var internalStateGetterFor$2 = InternalStateModule$2.getterFor;

var collection$3 = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global$8[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var exported = {};
  var Constructor;

  if (!DESCRIPTORS$2 || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$4(function () {
    new NativeConstructor().entries().next();
  }))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else {
    Constructor = wrapper(function (target, iterable) {
      setInternalState$2(anInstance$2(target, Prototype), {
        type: CONSTRUCTOR_NAME,
        collection: new NativeConstructor()
      });
      if (iterable != undefined) iterate$2(iterable, target[ADDER], {
        that: target,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor$2(CONSTRUCTOR_NAME);
    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';

      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
        createNonEnumerableProperty(Prototype, KEY, function (a, b) {
          var collection = getInternalState(this).collection;
          if (!IS_ADDER && IS_WEAK && !isObject$4(a)) return KEY == 'get' ? undefined : false;
          var result = collection[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      }
    });
    IS_WEAK || defineProperty$1(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).collection.size;
      }
    });
  }

  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$d({
    global: true,
    forced: true
  }, exported);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var redefine = redefine$4;

var redefineAll$3 = function (target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);
  }

  return target;
};

var getBuiltIn$1 = getBuiltIn$9;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol = wellKnownSymbol$j;
var DESCRIPTORS$1 = descriptors;
var SPECIES = wellKnownSymbol('species');

var setSpecies$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$1(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty = objectDefineProperty.f;
var create$4 = objectCreate;
var redefineAll$2 = redefineAll$3;
var bind$2 = functionBindContext;
var anInstance$1 = anInstance$3;
var iterate$1 = iterate$3;
var defineIterator = defineIterator$3;
var setSpecies = setSpecies$1;
var DESCRIPTORS = descriptors;
var fastKey = internalMetadata.exports.fastKey;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor$1 = InternalStateModule$1.getterFor;
var collectionStrong$2 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        index: create$4(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate$1(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll$2(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;else that.size--;
        }

        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bind$2(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll$2(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$1(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) entry = entry.previous; // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species

    setSpecies(CONSTRUCTOR_NAME);
  }
};

var collection$2 = collection$3;
var collectionStrong$1 = collectionStrong$2; // `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects

collection$2('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong$1);

var path$b = path$y;
var map$2 = path$b.Map;

var parent$v = map$2;
var map$1 = parent$v;

var map = map$1;

/**
 * This class can store groups and options specific for groups.
 */
var Groups = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function Groups() {
    _classCallCheck(this, Groups);

    this.clear();
    this._defaultIndex = 0;
    this._groupIndex = 0;
    this._defaultGroups = [{
      border: "#2B7CE9",
      background: "#97C2FC",
      highlight: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      },
      hover: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      }
    }, // 0: blue
    {
      border: "#FFA500",
      background: "#FFFF00",
      highlight: {
        border: "#FFA500",
        background: "#FFFFA3"
      },
      hover: {
        border: "#FFA500",
        background: "#FFFFA3"
      }
    }, // 1: yellow
    {
      border: "#FA0A10",
      background: "#FB7E81",
      highlight: {
        border: "#FA0A10",
        background: "#FFAFB1"
      },
      hover: {
        border: "#FA0A10",
        background: "#FFAFB1"
      }
    }, // 2: red
    {
      border: "#41A906",
      background: "#7BE141",
      highlight: {
        border: "#41A906",
        background: "#A1EC76"
      },
      hover: {
        border: "#41A906",
        background: "#A1EC76"
      }
    }, // 3: green
    {
      border: "#E129F0",
      background: "#EB7DF4",
      highlight: {
        border: "#E129F0",
        background: "#F0B3F5"
      },
      hover: {
        border: "#E129F0",
        background: "#F0B3F5"
      }
    }, // 4: magenta
    {
      border: "#7C29F0",
      background: "#AD85E4",
      highlight: {
        border: "#7C29F0",
        background: "#D3BDF0"
      },
      hover: {
        border: "#7C29F0",
        background: "#D3BDF0"
      }
    }, // 5: purple
    {
      border: "#C37F00",
      background: "#FFA807",
      highlight: {
        border: "#C37F00",
        background: "#FFCA66"
      },
      hover: {
        border: "#C37F00",
        background: "#FFCA66"
      }
    }, // 6: orange
    {
      border: "#4220FB",
      background: "#6E6EFD",
      highlight: {
        border: "#4220FB",
        background: "#9B9BFD"
      },
      hover: {
        border: "#4220FB",
        background: "#9B9BFD"
      }
    }, // 7: darkblue
    {
      border: "#FD5A77",
      background: "#FFC0CB",
      highlight: {
        border: "#FD5A77",
        background: "#FFD1D9"
      },
      hover: {
        border: "#FD5A77",
        background: "#FFD1D9"
      }
    }, // 8: pink
    {
      border: "#4AD63A",
      background: "#C2FABC",
      highlight: {
        border: "#4AD63A",
        background: "#E6FFE3"
      },
      hover: {
        border: "#4AD63A",
        background: "#E6FFE3"
      }
    }, // 9: mint
    {
      border: "#990000",
      background: "#EE0000",
      highlight: {
        border: "#BB0000",
        background: "#FF3333"
      },
      hover: {
        border: "#BB0000",
        background: "#FF3333"
      }
    }, // 10:bright red
    {
      border: "#FF6000",
      background: "#FF6000",
      highlight: {
        border: "#FF6000",
        background: "#FF6000"
      },
      hover: {
        border: "#FF6000",
        background: "#FF6000"
      }
    }, // 12: real orange
    {
      border: "#97C2FC",
      background: "#2B7CE9",
      highlight: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      },
      hover: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      }
    }, // 13: blue
    {
      border: "#399605",
      background: "#255C03",
      highlight: {
        border: "#399605",
        background: "#255C03"
      },
      hover: {
        border: "#399605",
        background: "#255C03"
      }
    }, // 14: green
    {
      border: "#B70054",
      background: "#FF007E",
      highlight: {
        border: "#B70054",
        background: "#FF007E"
      },
      hover: {
        border: "#B70054",
        background: "#FF007E"
      }
    }, // 15: magenta
    {
      border: "#AD85E4",
      background: "#7C29F0",
      highlight: {
        border: "#D3BDF0",
        background: "#7C29F0"
      },
      hover: {
        border: "#D3BDF0",
        background: "#7C29F0"
      }
    }, // 16: purple
    {
      border: "#4557FA",
      background: "#000EA1",
      highlight: {
        border: "#6E6EFD",
        background: "#000EA1"
      },
      hover: {
        border: "#6E6EFD",
        background: "#000EA1"
      }
    }, // 17: darkblue
    {
      border: "#FFC0CB",
      background: "#FD5A77",
      highlight: {
        border: "#FFD1D9",
        background: "#FD5A77"
      },
      hover: {
        border: "#FFD1D9",
        background: "#FD5A77"
      }
    }, // 18: pink
    {
      border: "#C2FABC",
      background: "#74D66A",
      highlight: {
        border: "#E6FFE3",
        background: "#74D66A"
      },
      hover: {
        border: "#E6FFE3",
        background: "#74D66A"
      }
    }, // 19: mint
    {
      border: "#EE0000",
      background: "#990000",
      highlight: {
        border: "#FF3333",
        background: "#BB0000"
      },
      hover: {
        border: "#FF3333",
        background: "#BB0000"
      }
    } // 20:bright red
    ];
    this.options = {};
    this.defaultOptions = {
      useDefaultGroups: true
    };

    assign$2(this.options, this.defaultOptions);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(Groups, [{
    key: "setOptions",
    value: function setOptions(options) {
      var optionFields = ["useDefaultGroups"];

      if (options !== undefined) {
        for (var groupName in options) {
          if (Object.prototype.hasOwnProperty.call(options, groupName)) {
            if (indexOf(optionFields).call(optionFields, groupName) === -1) {
              var group = options[groupName];
              this.add(groupName, group);
            }
          }
        }
      }
    }
    /**
     * Clear all groups
     */

  }, {
    key: "clear",
    value: function clear() {
      this._groups = new map();
      this._groupNames = [];
    }
    /**
     * Get group options of a groupname.
     * If groupname is not found, a new group may be created.
     *
     * @param {*}       groupname     Can be a number, string, Date, etc.
     * @param {boolean} [shouldCreate=true] If true, create a new group
     * @returns {object} The found or created group
     */

  }, {
    key: "get",
    value: function get(groupname) {
      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var group = this._groups.get(groupname);

      if (group === undefined && shouldCreate) {
        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {
          // create new group
          var index = this._groupIndex % this._groupNames.length;
          ++this._groupIndex;
          group = {};
          group.color = this._groups.get(this._groupNames[index]);

          this._groups.set(groupname, group);
        } else {
          // create new group
          var _index = this._defaultIndex % this._defaultGroups.length;

          this._defaultIndex++;
          group = {};
          group.color = this._defaultGroups[_index];

          this._groups.set(groupname, group);
        }
      }

      return group;
    }
    /**
     * Add custom group style.
     *
     * @param {string} groupName - The name of the group, a new group will be
     * created if a group with the same name doesn't exist, otherwise the old
     * groups style will be overwritten.
     * @param {object} style - An object containing borderColor, backgroundColor,
     * etc.
     * @returns {object} The created group object.
     */

  }, {
    key: "add",
    value: function add(groupName, style) {
      // Only push group name once to prevent duplicates which would consume more
      // RAM and also skew the distribution towards more often updated groups,
      // neither of which is desirable.
      if (!this._groups.has(groupName)) {
        this._groupNames.push(groupName);
      }

      this._groups.set(groupName, style);

      return style;
    }
  }]);

  return Groups;
}();

var $$c = _export; // `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan

$$c({
  target: 'Number',
  stat: true
}, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return number != number;
  }
});

var path$a = path$y;
var isNan$2 = path$a.Number.isNaN;

var parent$u = isNan$2;
var isNan$1 = parent$u;

var isNan = isNan$1;

var global$7 = global$P;
var globalIsFinite = global$7.isFinite; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe

var numberIsFinite$1 = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};

var $$b = _export;
var numberIsFinite = numberIsFinite$1; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite

$$b({
  target: 'Number',
  stat: true
}, {
  isFinite: numberIsFinite
});

var path$9 = path$y;
var _isFinite$2 = path$9.Number.isFinite;

var parent$t = _isFinite$2;
var _isFinite$1 = parent$t;

var _isFinite = _isFinite$1;

var $$a = _export;
var $some = arrayIteration.some;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$6;
var STRICT_METHOD$3 = arrayMethodIsStrict$3('some'); // `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some

$$a({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$3
}, {
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$7 = entryVirtual$l;
var some$3 = entryVirtual$7('Array').some;

var isPrototypeOf$7 = objectIsPrototypeOf;
var method$7 = some$3;
var ArrayPrototype$7 = Array.prototype;

var some$2 = function (it) {
  var own = it.some;
  return it === ArrayPrototype$7 || isPrototypeOf$7(ArrayPrototype$7, it) && own === ArrayPrototype$7.some ? method$7 : own;
};

var parent$s = some$2;
var some$1 = parent$s;

var some = some$1;

var global$6 = global$P;
var isConstructor = isConstructor$4;
var tryToString = tryToString$4;
var TypeError$3 = global$6.TypeError; // `Assert: IsConstructor(argument) is true`

var aConstructor$1 = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError$3(tryToString(argument) + ' is not a constructor');
};

var $$9 = _export;
var getBuiltIn = getBuiltIn$9;
var apply = functionApply;
var bind$1 = functionBind;
var aConstructor = aConstructor$1;
var anObject$2 = anObject$d;
var isObject$3 = isObject$j;
var create$3 = objectCreate;
var fails$3 = fails$t;
var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push$1 = [].push; // `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails$3(function () {
  function F() {
    /* empty */
  }

  return !(nativeConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$3(function () {
  nativeConstruct(function () {
    /* empty */
  });
});
var FORCED$2 = NEW_TARGET_BUG || ARGS_BUG;
$$9({
  target: 'Reflect',
  stat: true,
  forced: FORCED$2,
  sham: FORCED$2
}, {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aConstructor(Target);
    anObject$2(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      apply(push$1, $args, args);
      return new (apply(bind$1, Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create$3(isObject$3(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject$3(result) ? result : instance;
  }
});

var path$8 = path$y;
var construct$2 = path$8.Reflect.construct;

var parent$r = construct$2;
var construct$1 = parent$r;

var construct = construct$1;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var parent$q = create$6;
var create$2 = parent$q;

var parent$p = create$2;
var create$1 = parent$p;

var create = create$1;

var $$8 = _export;
var setPrototypeOf$5 = objectSetPrototypeOf; // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof

$$8({
  target: 'Object',
  stat: true
}, {
  setPrototypeOf: setPrototypeOf$5
});

var path$7 = path$y;
var setPrototypeOf$4 = path$7.Object.setPrototypeOf;

var parent$o = setPrototypeOf$4;
var setPrototypeOf$3 = parent$o;

var parent$n = setPrototypeOf$3;
var setPrototypeOf$2 = parent$n;

var parent$m = setPrototypeOf$2;
var setPrototypeOf$1 = parent$m;

var setPrototypeOf = setPrototypeOf$1;

function _setPrototypeOf(o, p) {
  _setPrototypeOf = setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });

  defineProperty$3(subClass, "prototype", {
    writable: false
  });

  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

var parent$l = getPrototypeOf$5;
var getPrototypeOf$3 = parent$l;

var parent$k = getPrototypeOf$3;
var getPrototypeOf$2 = parent$k;

var getPrototypeOf$1 = getPrototypeOf$2;

function _getPrototypeOf(o) {
  _getPrototypeOf = setPrototypeOf ? getPrototypeOf$1 : function _getPrototypeOf(o) {
    return o.__proto__ || getPrototypeOf$1(o);
  };
  return _getPrototypeOf(o);
}

var runtime = {exports: {}};

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function () {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function (record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
})(runtime);

var regenerator = runtime.exports;

var global$5 = global$P;
var aCallable$2 = aCallable$7;
var toObject$2 = toObject$e;
var IndexedObject = indexedObject;
var lengthOfArrayLike$3 = lengthOfArrayLike$d;
var TypeError$2 = global$5.TypeError; // `Array.prototype.{ reduce, reduceRight }` methods implementation

var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable$2(callbackfn);
    var O = toObject$2(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike$3(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError$2('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

var classof$3 = classofRaw$1;
var global$4 = global$P;
var engineIsNode = classof$3(global$4.process) == 'process';

var $$7 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$6;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD$2 = arrayMethodIsStrict$2('reduce'); // Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce

$$7({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$2 || CHROME_BUG
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$6 = entryVirtual$l;
var reduce$3 = entryVirtual$6('Array').reduce;

var isPrototypeOf$6 = objectIsPrototypeOf;
var method$6 = reduce$3;
var ArrayPrototype$6 = Array.prototype;

var reduce$2 = function (it) {
  var own = it.reduce;
  return it === ArrayPrototype$6 || isPrototypeOf$6(ArrayPrototype$6, it) && own === ArrayPrototype$6.reduce ? method$6 : own;
};

var parent$j = reduce$2;
var reduce$1 = parent$j;

var reduce = reduce$1;

var global$3 = global$P;
var isArray = isArray$d;
var lengthOfArrayLike$2 = lengthOfArrayLike$d;
var bind = functionBindContext;
var TypeError$1 = global$3.TypeError; // `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var flattenIntoArray$1 = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        elementLen = lengthOfArrayLike$2(element);
        targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$1('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
};

var flattenIntoArray_1 = flattenIntoArray$1;

var $$6 = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$1 = aCallable$7;
var toObject$1 = toObject$e;
var lengthOfArrayLike$1 = lengthOfArrayLike$d;
var arraySpeciesCreate = arraySpeciesCreate$4; // `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap

$$6({
  target: 'Array',
  proto: true
}, {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject$1(this);
    var sourceLen = lengthOfArrayLike$1(O);
    var A;
    aCallable$1(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});

var entryVirtual$5 = entryVirtual$l;
var flatMap$3 = entryVirtual$5('Array').flatMap;

var isPrototypeOf$5 = objectIsPrototypeOf;
var method$5 = flatMap$3;
var ArrayPrototype$5 = Array.prototype;

var flatMap$2 = function (it) {
  var own = it.flatMap;
  return it === ArrayPrototype$5 || isPrototypeOf$5(ArrayPrototype$5, it) && own === ArrayPrototype$5.flatMap ? method$5 : own;
};

var parent$i = flatMap$2;
var flatMap$1 = parent$i;

var flatMap = flatMap$1;

var collection$1 = collection$3;
var collectionStrong = collectionStrong$2; // `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects

collection$1('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

var path$6 = path$y;
var set$2 = path$6.Set;

var parent$h = set$2;
var set$1 = parent$h;

var set = set$1;

var iterator = iterator$4;

var getIterator$4 = getIterator$7;
var getIterator_1 = getIterator$4;

var parent$g = getIterator_1;
var getIterator$3 = parent$g;

var parent$f = getIterator$3;
var getIterator$2 = parent$f;

var parent$e = getIterator$2;
var getIterator$1 = parent$e;

var getIterator = getIterator$1;

var arraySlice = arraySliceSimple;
var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];

    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }

    if (j !== i++) array[j] = element;
  }

  return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
  }

  return array;
};

var arraySort = mergeSort;

var userAgent$1 = engineUserAgent;
var firefox = userAgent$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];

var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

var userAgent = engineUserAgent;
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];

var $$5 = _export;
var uncurryThis$3 = functionUncurryThis;
var aCallable = aCallable$7;
var toObject = toObject$e;
var lengthOfArrayLike = lengthOfArrayLike$d;
var toString$1 = toString$8;
var fails$2 = fails$t;
var internalSort = arraySort;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$6;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var un$Sort = uncurryThis$3(test.sort);
var push = uncurryThis$3(test.push); // IE8-

var FAILS_ON_UNDEFINED = fails$2(function () {
  test.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails$2(function () {
  test.sort(null);
}); // Old WebKit

var STRICT_METHOD$1 = arrayMethodIsStrict$1('sort');
var STABLE_SORT = !fails$2(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;
  var result = '';
  var code, chr, value, index; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)

  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;

      case 68:
      case 71:
        value = 4;
        break;

      default:
        value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({
        k: chr + index,
        v: value
      });
    }
  }

  test.sort(function (a, b) {
    return b.v - a.v;
  });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString$1(x) > toString$1(y) ? 1 : -1;
  };
}; // `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort


$$5({
  target: 'Array',
  proto: true,
  forced: FORCED$1
}, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);
    var array = toObject(this);
    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];

    while (index < arrayLength) delete array[index++];

    return array;
  }
});

var entryVirtual$4 = entryVirtual$l;
var sort$3 = entryVirtual$4('Array').sort;

var isPrototypeOf$4 = objectIsPrototypeOf;
var method$4 = sort$3;
var ArrayPrototype$4 = Array.prototype;

var sort$2 = function (it) {
  var own = it.sort;
  return it === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.sort ? method$4 : own;
};

var parent$d = sort$2;
var sort$1 = parent$d;

var sort = sort$1;

var entryVirtual$3 = entryVirtual$l;
var keys$3 = entryVirtual$3('Array').keys;

var parent$c = keys$3;
var keys$2 = parent$c;

var classof$2 = classof$e;
var hasOwn$4 = hasOwnProperty_1;
var isPrototypeOf$3 = objectIsPrototypeOf;
var method$3 = keys$2;
var ArrayPrototype$3 = Array.prototype;
var DOMIterables$2 = {
  DOMTokenList: true,
  NodeList: true
};

var keys$1 = function (it) {
  var own = it.keys;
  return it === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.keys || hasOwn$4(DOMIterables$2, classof$2(it)) ? method$3 : own;
};

var keys = keys$1;

var entryVirtual$2 = entryVirtual$l;
var values$3 = entryVirtual$2('Array').values;

var parent$b = values$3;
var values$2 = parent$b;

var classof$1 = classof$e;
var hasOwn$3 = hasOwnProperty_1;
var isPrototypeOf$2 = objectIsPrototypeOf;
var method$2 = values$2;
var ArrayPrototype$2 = Array.prototype;
var DOMIterables$1 = {
  DOMTokenList: true,
  NodeList: true
};

var values$1 = function (it) {
  var own = it.values;
  return it === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.values || hasOwn$3(DOMIterables$1, classof$1(it)) ? method$2 : own;
};

var values = values$1;

var entryVirtual$1 = entryVirtual$l;
var entries$3 = entryVirtual$1('Array').entries;

var parent$a = entries$3;
var entries$2 = parent$a;

var classof = classof$e;
var hasOwn$2 = hasOwnProperty_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var method$1 = entries$2;
var ArrayPrototype$1 = Array.prototype;
var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

var entries$1 = function (it) {
  var own = it.entries;
  return it === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.entries || hasOwn$2(DOMIterables, classof(it)) ? method$1 : own;
};

var entries = entries$1;

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

var _Symbol$iterator;

function ownKeys$4(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var _context32, _context33; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context32 = ownKeys$4(Object(source), !0)).call(_context32, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context33 = ownKeys$4(Object(source))).call(_context33, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$7(o, minLen) { var _context31; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = slice(_context31 = Object.prototype.toString.call(o)).call(_context31, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Create new data pipe.
 *
 * @param from - The source data set or data view.
 * @remarks
 * Example usage:
 * ```typescript
 * interface AppItem {
 *   whoami: string;
 *   appData: unknown;
 *   visData: VisItem;
 * }
 * interface VisItem {
 *   id: number;
 *   label: string;
 *   color: string;
 *   x: number;
 *   y: number;
 * }
 *
 * const ds1 = new DataSet<AppItem, "whoami">([], { fieldId: "whoami" });
 * const ds2 = new DataSet<VisItem, "id">();
 *
 * const pipe = createNewDataPipeFrom(ds1)
 *   .filter((item): boolean => item.enabled === true)
 *   .map<VisItem, "id">((item): VisItem => item.visData)
 *   .to(ds2);
 *
 * pipe.start();
 * ```
 * @returns A factory whose methods can be used to configure the pipe.
 */

function createNewDataPipeFrom(from) {
  return new DataPipeUnderConstruction(from);
}
/**
 * Internal implementation of the pipe. This should be accessible only through
 * `createNewDataPipeFrom` from the outside.
 *
 * @typeParam SI - Source item type.
 * @typeParam SP - Source item type's id property name.
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */


var SimpleDataPipe = /*#__PURE__*/function () {
  /**
   * Bound listeners for use with `DataInterface['on' | 'off']`.
   */

  /**
   * Create a new data pipe.
   *
   * @param _source - The data set or data view that will be observed.
   * @param _transformers - An array of transforming functions to be used to
   * filter or transform the items in the pipe.
   * @param _target - The data set or data view that will receive the items.
   */
  function SimpleDataPipe(_source, _transformers, _target) {
    var _context, _context2, _context3;

    _classCallCheck(this, SimpleDataPipe);

    _defineProperty(this, "_source", void 0);

    _defineProperty(this, "_transformers", void 0);

    _defineProperty(this, "_target", void 0);

    _defineProperty(this, "_listeners", {
      add: bind$6(_context = this._add).call(_context, this),
      remove: bind$6(_context2 = this._remove).call(_context2, this),
      update: bind$6(_context3 = this._update).call(_context3, this)
    });

    this._source = _source;
    this._transformers = _transformers;
    this._target = _target;
  }
  /** @inheritDoc */


  _createClass(SimpleDataPipe, [{
    key: "all",
    value: function all() {
      this._target.update(this._transformItems(this._source.get()));

      return this;
    }
    /** @inheritDoc */

  }, {
    key: "start",
    value: function start() {
      this._source.on("add", this._listeners.add);

      this._source.on("remove", this._listeners.remove);

      this._source.on("update", this._listeners.update);

      return this;
    }
    /** @inheritDoc */

  }, {
    key: "stop",
    value: function stop() {
      this._source.off("add", this._listeners.add);

      this._source.off("remove", this._listeners.remove);

      this._source.off("update", this._listeners.update);

      return this;
    }
    /**
     * Apply the transformers to the items.
     *
     * @param items - The items to be transformed.
     * @returns The transformed items.
     */

  }, {
    key: "_transformItems",
    value: function _transformItems(items) {
      var _context4;

      return reduce(_context4 = this._transformers).call(_context4, function (items, transform) {
        return transform(items);
      }, items);
    }
    /**
     * Handle an add event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the added items.
     */

  }, {
    key: "_add",
    value: function _add(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.add(this._transformItems(this._source.get(payload.items)));
    }
    /**
     * Handle an update event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the updated items.
     */

  }, {
    key: "_update",
    value: function _update(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.update(this._transformItems(this._source.get(payload.items)));
    }
    /**
     * Handle a remove event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the data of the removed items.
     */

  }, {
    key: "_remove",
    value: function _remove(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.remove(this._transformItems(payload.oldData));
    }
  }]);

  return SimpleDataPipe;
}();
/**
 * Internal implementation of the pipe factory. This should be accessible
 * only through `createNewDataPipeFrom` from the outside.
 *
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */


var DataPipeUnderConstruction = /*#__PURE__*/function () {
  /**
   * Array transformers used to transform items within the pipe. This is typed
   * as any for the sake of simplicity.
   */

  /**
   * Create a new data pipe factory. This is an internal constructor that
   * should never be called from outside of this file.
   *
   * @param _source - The source data set or data view for this pipe.
   */
  function DataPipeUnderConstruction(_source) {
    _classCallCheck(this, DataPipeUnderConstruction);

    _defineProperty(this, "_source", void 0);

    _defineProperty(this, "_transformers", []);

    this._source = _source;
  }
  /**
   * Filter the items.
   *
   * @param callback - A filtering function that returns true if given item
   * should be piped and false if not.
   * @returns This factory for further configuration.
   */


  _createClass(DataPipeUnderConstruction, [{
    key: "filter",
    value: function filter$1(callback) {
      this._transformers.push(function (input) {
        return filter(input).call(input, callback);
      });

      return this;
    }
    /**
     * Map each source item to a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * corresponding mapped item.
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     * @returns This factory for further configuration.
     */

  }, {
    key: "map",
    value: function map(callback) {
      this._transformers.push(function (input) {
        return map$3(input).call(input, callback);
      });

      return this;
    }
    /**
     * Map each source item to zero or more items of a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * an array of corresponding mapped items.
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     * @returns This factory for further configuration.
     */

  }, {
    key: "flatMap",
    value: function flatMap$1(callback) {
      this._transformers.push(function (input) {
        return flatMap(input).call(input, callback);
      });

      return this;
    }
    /**
     * Connect this pipe to given data set.
     *
     * @param target - The data set that will receive the items from this pipe.
     * @returns The pipe connected between given data sets and performing
     * configured transformation on the processed items.
     */

  }, {
    key: "to",
    value: function to(target) {
      return new SimpleDataPipe(this._source, this._transformers, target);
    }
  }]);

  return DataPipeUnderConstruction;
}();
/**
 * Determine whether a value can be used as an id.
 *
 * @param value - Input value of unknown type.
 * @returns True if the value is valid id, false otherwise.
 */


function isId(value) {
  return typeof value === "string" || typeof value === "number";
}
/**
 * A queue.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */


var Queue = /*#__PURE__*/function () {
  /** Delay in milliseconds. If defined the queue will be periodically flushed. */

  /** Maximum number of entries in the queue before it will be flushed. */

  /**
   * Construct a new Queue.
   *
   * @param options - Queue configuration.
   */
  function Queue(options) {
    _classCallCheck(this, Queue);

    _defineProperty(this, "delay", void 0);

    _defineProperty(this, "max", void 0);

    _defineProperty(this, "_queue", []);

    _defineProperty(this, "_timeout", null);

    _defineProperty(this, "_extended", null);

    // options
    this.delay = null;
    this.max = Infinity;
    this.setOptions(options);
  }
  /**
   * Update the configuration of the queue.
   *
   * @param options - Queue configuration.
   */


  _createClass(Queue, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options && typeof options.delay !== "undefined") {
        this.delay = options.delay;
      }

      if (options && typeof options.max !== "undefined") {
        this.max = options.max;
      }

      this._flushIfNeeded();
    }
    /**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     * @returns The created queue.
     */

  }, {
    key: "destroy",
    value:
    /**
     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
     */
    function destroy() {
      this.flush();

      if (this._extended) {
        var object = this._extended.object;
        var methods = this._extended.methods;

        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];

          if (method.original) {
            // @TODO: better solution?
            object[method.name] = method.original;
          } else {
            // @TODO: better solution?
            delete object[method.name];
          }
        }

        this._extended = null;
      }
    }
    /**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */

  }, {
    key: "replace",
    value: function replace(object, method) {
      /* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */
      var me = this;
      var original = object[method];

      if (!original) {
        throw new Error("Method " + method + " undefined");
      }

      object[method] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // add this call to the queue
        me.queue({
          args: args,
          fn: original,
          context: this
        });
      };
    }
    /**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */

  }, {
    key: "queue",
    value: function queue(entry) {
      if (typeof entry === "function") {
        this._queue.push({
          fn: entry
        });
      } else {
        this._queue.push(entry);
      }

      this._flushIfNeeded();
    }
    /**
     * Check whether the queue needs to be flushed.
     */

  }, {
    key: "_flushIfNeeded",
    value: function _flushIfNeeded() {
      var _this = this;

      // flush when the maximum is exceeded.
      if (this._queue.length > this.max) {
        this.flush();
      } // flush after a period of inactivity when a delay is configured


      if (this._timeout != null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }

      if (this.queue.length > 0 && typeof this.delay === "number") {
        this._timeout = setTimeout$1(function () {
          _this.flush();
        }, this.delay);
      }
    }
    /**
     * Flush all queued calls
     */

  }, {
    key: "flush",
    value: function flush() {
      var _context5, _context6;

      forEach$2(_context5 = splice$1(_context6 = this._queue).call(_context6, 0)).call(_context5, function (entry) {
        entry.fn.apply(entry.context || entry.fn, entry.args || []);
      });
    }
  }], [{
    key: "extend",
    value: function extend(object, options) {
      var queue = new Queue(options);

      if (object.flush !== undefined) {
        throw new Error("Target object already has a property flush");
      }

      object.flush = function () {
        queue.flush();
      };

      var methods = [{
        name: "flush",
        original: undefined
      }];

      if (options && options.replace) {
        for (var i = 0; i < options.replace.length; i++) {
          var name = options.replace[i];
          methods.push({
            name: name,
            // @TODO: better solution?
            original: object[name]
          }); // @TODO: better solution?

          queue.replace(object, name);
        }
      }

      queue._extended = {
        object: object,
        methods: methods
      };
      return queue;
    }
  }]);

  return Queue;
}();
/**
 * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSetPart = /*#__PURE__*/function () {
  function DataSetPart() {
    _classCallCheck(this, DataSetPart);

    _defineProperty(this, "_subscribers", {
      "*": [],
      add: [],
      remove: [],
      update: []
    });

    _defineProperty(this, "subscribe", DataSetPart.prototype.on);

    _defineProperty(this, "unsubscribe", DataSetPart.prototype.off);
  }

  _createClass(DataSetPart, [{
    key: "_trigger",
    value:
    /**
     * Trigger an event
     *
     * @param event - Event name.
     * @param payload - Event payload.
     * @param senderId - Id of the sender.
     */
    function _trigger(event, payload, senderId) {
      var _context7, _context8;

      if (event === "*") {
        throw new Error("Cannot trigger event *");
      }

      forEach$2(_context7 = concat(_context8 = []).call(_context8, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers["*"]))).call(_context7, function (subscriber) {
        subscriber(event, payload, senderId != null ? senderId : null);
      });
    }
    /**
     * Subscribe to an event, add an event listener.
     *
     * @remarks Non-function callbacks are ignored.
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "on",
    value: function on(event, callback) {
      if (typeof callback === "function") {
        this._subscribers[event].push(callback);
      } // @TODO: Maybe throw for invalid callbacks?

    }
    /**
     * Unsubscribe from an event, remove an event listener.
     *
     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "off",
    value: function off(event, callback) {
      var _context9;

      this._subscribers[event] = filter(_context9 = this._subscribers[event]).call(_context9, function (subscriber) {
        return subscriber !== callback;
      });
    }
    /**
     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
     */

  }]);

  return DataSetPart;
}();
/**
 * Data stream
 *
 * @remarks
 * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
 * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
 * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
 * @typeParam Item - The item type this stream is going to work with.
 */


_Symbol$iterator = iterator;

var DataStream = /*#__PURE__*/function () {
  /**
   * Create a new data stream.
   *
   * @param pairs - The id, item pairs.
   */
  function DataStream(pairs) {
    _classCallCheck(this, DataStream);

    _defineProperty(this, "_pairs", void 0);

    this._pairs = pairs;
  }
  /**
   * Return an iterable of key, value pairs for every entry in the stream.
   */


  _createClass(DataStream, [{
    key: _Symbol$iterator,
    value:
    /*#__PURE__*/
    regenerator.mark(function value() {
      var _iterator, _step, _step$value, id, item;

      return regenerator.wrap(function value$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$7(this._pairs);
              _context10.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context10.next = 9;
                break;
              }

              _step$value = _slicedToArray(_step.value, 2), id = _step$value[0], item = _step$value[1];
              _context10.next = 7;
              return [id, item];

            case 7:
              _context10.next = 3;
              break;

            case 9:
              _context10.next = 14;
              break;

            case 11:
              _context10.prev = 11;
              _context10.t0 = _context10["catch"](1);

              _iterator.e(_context10.t0);

            case 14:
              _context10.prev = 14;

              _iterator.f();

              return _context10.finish(14);

            case 17:
            case "end":
              return _context10.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */

  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    regenerator.mark(function entries() {
      var _iterator2, _step2, _step2$value, id, item;

      return regenerator.wrap(function entries$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper$7(this._pairs);
              _context11.prev = 1;

              _iterator2.s();

            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context11.next = 9;
                break;
              }

              _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], item = _step2$value[1];
              _context11.next = 7;
              return [id, item];

            case 7:
              _context11.next = 3;
              break;

            case 9:
              _context11.next = 14;
              break;

            case 11:
              _context11.prev = 11;
              _context11.t0 = _context11["catch"](1);

              _iterator2.e(_context11.t0);

            case 14:
              _context11.prev = 14;

              _iterator2.f();

              return _context11.finish(14);

            case 17:
            case "end":
              return _context11.stop();
          }
        }
      }, entries, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of keys in the stream.
     */

  }, {
    key: "keys",
    value:
    /*#__PURE__*/
    regenerator.mark(function keys() {
      var _iterator3, _step3, _step3$value, id;

      return regenerator.wrap(function keys$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper$7(this._pairs);
              _context12.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context12.next = 9;
                break;
              }

              _step3$value = _slicedToArray(_step3.value, 1), id = _step3$value[0];
              _context12.next = 7;
              return id;

            case 7:
              _context12.next = 3;
              break;

            case 9:
              _context12.next = 14;
              break;

            case 11:
              _context12.prev = 11;
              _context12.t0 = _context12["catch"](1);

              _iterator3.e(_context12.t0);

            case 14:
              _context12.prev = 14;

              _iterator3.f();

              return _context12.finish(14);

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, keys, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of values in the stream.
     */

  }, {
    key: "values",
    value:
    /*#__PURE__*/
    regenerator.mark(function values() {
      var _iterator4, _step4, _step4$value, item;

      return regenerator.wrap(function values$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper$7(this._pairs);
              _context13.prev = 1;

              _iterator4.s();

            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context13.next = 9;
                break;
              }

              _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];
              _context13.next = 7;
              return item;

            case 7:
              _context13.next = 3;
              break;

            case 9:
              _context13.next = 14;
              break;

            case 11:
              _context13.prev = 11;
              _context13.t0 = _context13["catch"](1);

              _iterator4.e(_context13.t0);

            case 14:
              _context13.prev = 14;

              _iterator4.f();

              return _context13.finish(14);

            case 17:
            case "end":
              return _context13.stop();
          }
        }
      }, values, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an array containing all the ids in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all ids from this stream.
     */

  }, {
    key: "toIdArray",
    value: function toIdArray() {
      var _context14;

      return map$3(_context14 = _toConsumableArray(this._pairs)).call(_context14, function (pair) {
        return pair[0];
      });
    }
    /**
     * Return an array containing all the items in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all items from this stream.
     */

  }, {
    key: "toItemArray",
    value: function toItemArray() {
      var _context15;

      return map$3(_context15 = _toConsumableArray(this._pairs)).call(_context15, function (pair) {
        return pair[1];
      });
    }
    /**
     * Return an array containing all the entries in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all entries from this stream.
     */

  }, {
    key: "toEntryArray",
    value: function toEntryArray() {
      return _toConsumableArray(this._pairs);
    }
    /**
     * Return an object map containing all the items in this stream accessible by ids.
     *
     * @remarks
     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
     * @returns The object map of all id â item pairs from this stream.
     */

  }, {
    key: "toObjectMap",
    value: function toObjectMap() {
      var map = create$5(null);

      var _iterator5 = _createForOfIteratorHelper$7(this._pairs),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              id = _step5$value[0],
              item = _step5$value[1];

          map[id] = item;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return map;
    }
    /**
     * Return a map containing all the items in this stream accessible by ids.
     *
     * @returns The map of all id â item pairs from this stream.
     */

  }, {
    key: "toMap",
    value: function toMap() {
      return new map(this._pairs);
    }
    /**
     * Return a set containing all the (unique) ids in this stream.
     *
     * @returns The set of all ids from this stream.
     */

  }, {
    key: "toIdSet",
    value: function toIdSet() {
      return new set(this.toIdArray());
    }
    /**
     * Return a set containing all the (unique) items in this stream.
     *
     * @returns The set of all items from this stream.
     */

  }, {
    key: "toItemSet",
    value: function toItemSet() {
      return new set(this.toItemArray());
    }
    /**
     * Cache the items from this stream.
     *
     * @remarks
     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
     * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
     *
     * ## Example
     * ```javascript
     * const ds = new DataSet([â¦])
     *
     * const cachedStream = ds.stream()
     *   .filter(â¦)
     *   .sort(â¦)
     *   .map(â¦)
     *   .cached(â¦) // Data are fetched, processed and cached here.
     *
     * ds.clear()
     * chachedStream // Still has all the items.
     * ```
     * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
     */

  }, {
    key: "cache",
    value: function cache() {
      return new DataStream(_toConsumableArray(this._pairs));
    }
    /**
     * Get the distinct values of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @typeParam T - The type of the distinct value.
     * @returns A set of all distinct properties.
     */

  }, {
    key: "distinct",
    value: function distinct(callback) {
      var set$1 = new set();

      var _iterator6 = _createForOfIteratorHelper$7(this._pairs),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _step6$value = _slicedToArray(_step6.value, 2),
              id = _step6$value[0],
              item = _step6$value[1];

          set$1.add(callback(item, id));
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return set$1;
    }
    /**
     * Filter the items of the stream.
     *
     * @param callback - The function that decides whether an item will be included.
     * @returns A new data stream with the filtered items.
     */

  }, {
    key: "filter",
    value: function filter(callback) {
      var pairs = this._pairs;
      return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
        var _iterator7, _step7, _step7$value, id, item;

        return regenerator.wrap(function _callee$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _iterator7 = _createForOfIteratorHelper$7(pairs);
                _context16.prev = 1;

                _iterator7.s();

              case 3:
                if ((_step7 = _iterator7.n()).done) {
                  _context16.next = 10;
                  break;
                }

                _step7$value = _slicedToArray(_step7.value, 2), id = _step7$value[0], item = _step7$value[1];

                if (!callback(item, id)) {
                  _context16.next = 8;
                  break;
                }

                _context16.next = 8;
                return [id, item];

              case 8:
                _context16.next = 3;
                break;

              case 10:
                _context16.next = 15;
                break;

              case 12:
                _context16.prev = 12;
                _context16.t0 = _context16["catch"](1);

                _iterator7.e(_context16.t0);

              case 15:
                _context16.prev = 15;

                _iterator7.f();

                return _context16.finish(15);

              case 18:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee, null, [[1, 12, 15, 18]]);
      })));
    }
    /**
     * Execute a callback for each item of the stream.
     *
     * @param callback - The function that will be invoked for each item.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _iterator8 = _createForOfIteratorHelper$7(this._pairs),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _step8$value = _slicedToArray(_step8.value, 2),
              id = _step8$value[0],
              item = _step8$value[1];

          callback(item, id);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     * Map the items into a different type.
     *
     * @param callback - The function that does the conversion.
     * @typeParam Mapped - The type of the item after mapping.
     * @returns A new data stream with the mapped items.
     */

  }, {
    key: "map",
    value: function map(callback) {
      var pairs = this._pairs;
      return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee2() {
        var _iterator9, _step9, _step9$value, id, item;

        return regenerator.wrap(function _callee2$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _iterator9 = _createForOfIteratorHelper$7(pairs);
                _context17.prev = 1;

                _iterator9.s();

              case 3:
                if ((_step9 = _iterator9.n()).done) {
                  _context17.next = 9;
                  break;
                }

                _step9$value = _slicedToArray(_step9.value, 2), id = _step9$value[0], item = _step9$value[1];
                _context17.next = 7;
                return [id, callback(item, id)];

              case 7:
                _context17.next = 3;
                break;

              case 9:
                _context17.next = 14;
                break;

              case 11:
                _context17.prev = 11;
                _context17.t0 = _context17["catch"](1);

                _iterator9.e(_context17.t0);

              case 14:
                _context17.prev = 14;

                _iterator9.f();

                return _context17.finish(14);

              case 17:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee2, null, [[1, 11, 14, 17]]);
      })));
    }
    /**
     * Get the item with the maximum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the maximum if found otherwise null.
     */

  }, {
    key: "max",
    value: function max(callback) {
      var iter = getIterator(this._pairs);

      var curr = iter.next();

      if (curr.done) {
        return null;
      }

      var maxItem = curr.value[1];
      var maxValue = callback(curr.value[1], curr.value[0]);

      while (!(curr = iter.next()).done) {
        var _curr$value = _slicedToArray(curr.value, 2),
            id = _curr$value[0],
            item = _curr$value[1];

        var _value = callback(item, id);

        if (_value > maxValue) {
          maxValue = _value;
          maxItem = item;
        }
      }

      return maxItem;
    }
    /**
     * Get the item with the minimum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the minimum if found otherwise null.
     */

  }, {
    key: "min",
    value: function min(callback) {
      var iter = getIterator(this._pairs);

      var curr = iter.next();

      if (curr.done) {
        return null;
      }

      var minItem = curr.value[1];
      var minValue = callback(curr.value[1], curr.value[0]);

      while (!(curr = iter.next()).done) {
        var _curr$value2 = _slicedToArray(curr.value, 2),
            id = _curr$value2[0],
            item = _curr$value2[1];

        var _value2 = callback(item, id);

        if (_value2 < minValue) {
          minValue = _value2;
          minItem = item;
        }
      }

      return minItem;
    }
    /**
     * Reduce the items into a single value.
     *
     * @param callback - The function that does the reduction.
     * @param accumulator - The initial value of the accumulator.
     * @typeParam T - The type of the accumulated value.
     * @returns The reduced value.
     */

  }, {
    key: "reduce",
    value: function reduce(callback, accumulator) {
      var _iterator10 = _createForOfIteratorHelper$7(this._pairs),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _step10$value = _slicedToArray(_step10.value, 2),
              id = _step10$value[0],
              item = _step10$value[1];

          accumulator = callback(accumulator, item, id);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      return accumulator;
    }
    /**
     * Sort the items.
     *
     * @param callback - Item comparator.
     * @returns A new stream with sorted items.
     */

  }, {
    key: "sort",
    value: function sort$1(callback) {
      var _this2 = this;

      return new DataStream(_defineProperty({}, iterator, function () {
        var _context18;

        return getIterator(sort(_context18 = _toConsumableArray(_this2._pairs)).call(_context18, function (_ref, _ref2) {
          var _ref3 = _slicedToArray(_ref, 2),
              idA = _ref3[0],
              itemA = _ref3[1];

          var _ref4 = _slicedToArray(_ref2, 2),
              idB = _ref4[0],
              itemB = _ref4[1];

          return callback(itemA, itemB, idA, idB);
        }));
      }));
    }
  }]);

  return DataStream;
}();
/**
 * Add an id to given item if it doesn't have one already.
 *
 * @remarks
 * The item will be modified.
 * @param item - The item that will have an id after a call to this function.
 * @param idProp - The key of the id property.
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 * @returns true
 */


function ensureFullItem(item, idProp) {
  if (item[idProp] == null) {
    // generate an id
    item[idProp] = v4();
  }

  return item;
}
/**
 * # DataSet
 *
 * Vis.js comes with a flexible DataSet, which can be used to hold and
 * manipulate unstructured data and listen for changes in the data. The DataSet
 * is key/value based. Data items can be added, updated and removed from the
 * DataSet, and one can subscribe to changes in the DataSet. The data in the
 * DataSet can be filtered and ordered. Data can be normalized when appending it
 * to the DataSet as well.
 *
 * ## Example
 *
 * The following example shows how to use a DataSet.
 *
 * ```javascript
 * // create a DataSet
 * var options = {};
 * var data = new vis.DataSet(options);
 *
 * // add items
 * // note that the data items can contain different properties and data formats
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // subscribe to any change in the DataSet
 * data.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an existing item
 * data.update({id: 2, group: 1});
 *
 * // remove an item
 * data.remove(4);
 *
 * // get all ids
 * var ids = data.getIds();
 * console.log('ids', ids);
 *
 * // get a specific item
 * var item1 = data.get(1);
 * console.log('item1', item1);
 *
 * // retrieve a filtered subset of the data
 * var items = data.get({
 *   filter: function (item) {
 *     return item.group == 1;
 *   }
 * });
 * console.log('filtered items', items);
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSet = /*#__PURE__*/function (_DataSetPart) {
  _inherits(DataSet, _DataSetPart);

  var _super = _createSuper$t(DataSet);

  /**
   * Construct a new DataSet.
   *
   * @param data - Initial data or options.
   * @param options - Options (type error if data is also options).
   */
  function DataSet(data, options) {
    var _this3;

    _classCallCheck(this, DataSet);

    _this3 = _super.call(this); // correctly read optional arguments

    _defineProperty(_assertThisInitialized(_this3), "flush", void 0);

    _defineProperty(_assertThisInitialized(_this3), "length", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_options", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_data", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_idProp", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_queue", null);

    if (data && !isArray$2(data)) {
      options = data;
      data = [];
    }

    _this3._options = options || {};
    _this3._data = new map(); // map with data indexed by id

    _this3.length = 0; // number of items in the DataSet

    _this3._idProp = _this3._options.fieldId || "id"; // name of the field containing id
    // add initial data when provided

    if (data && data.length) {
      _this3.add(data);
    }

    _this3.setOptions(options);

    return _this3;
  }
  /**
   * Set new options.
   *
   * @param options - The new options.
   */


  _createClass(DataSet, [{
    key: "idProp",
    get:
    /** Flush all queued calls. */

    /** @inheritDoc */

    /** @inheritDoc */
    function get() {
      return this._idProp;
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options && options.queue !== undefined) {
        if (options.queue === false) {
          // delete queue if loaded
          if (this._queue) {
            this._queue.destroy();

            this._queue = null;
          }
        } else {
          // create queue and update its options
          if (!this._queue) {
            this._queue = Queue.extend(this, {
              replace: ["add", "update", "remove"]
            });
          }

          if (options.queue && _typeof(options.queue) === "object") {
            this._queue.setOptions(options.queue);
          }
        }
      }
    }
    /**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     * @throws When an item with the same id as any of the added items already exists.
     */

  }, {
    key: "add",
    value: function add(data, senderId) {
      var _this4 = this;

      var addedIds = [];
      var id;

      if (isArray$2(data)) {
        // Array
        var idsToAdd = map$3(data).call(data, function (d) {
          return d[_this4._idProp];
        });

        if (some(idsToAdd).call(idsToAdd, function (id) {
          return _this4._data.has(id);
        })) {
          throw new Error("A duplicate id was found in the parameter array.");
        }

        for (var i = 0, len = data.length; i < len; i++) {
          id = this._addItem(data[i]);
          addedIds.push(id);
        }
      } else if (data && _typeof(data) === "object") {
        // Single item
        id = this._addItem(data);
        addedIds.push(id);
      } else {
        throw new Error("Unknown dataType");
      }

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      return addedIds;
    }
    /**
     * Update existing items. When an item does not exist, it will be created.
     *
     * @remarks
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * ## Warning for TypeScript users
     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     * @throws When the supplied data is neither an item nor an array of items.
     */

  }, {
    key: "update",
    value: function update(data, senderId) {
      var _this5 = this;

      var addedIds = [];
      var updatedIds = [];
      var oldData = [];
      var updatedData = [];
      var idProp = this._idProp;

      var addOrUpdate = function addOrUpdate(item) {
        var origId = item[idProp];

        if (origId != null && _this5._data.has(origId)) {
          var fullItem = item; // it has an id, therefore it is a fullitem

          var oldItem = assign$2({}, _this5._data.get(origId)); // update item


          var id = _this5._updateItem(fullItem);

          updatedIds.push(id);
          updatedData.push(fullItem);
          oldData.push(oldItem);
        } else {
          // add new item
          var _id = _this5._addItem(item);

          addedIds.push(_id);
        }
      };

      if (isArray$2(data)) {
        // Array
        for (var i = 0, len = data.length; i < len; i++) {
          if (data[i] && _typeof(data[i]) === "object") {
            addOrUpdate(data[i]);
          } else {
            console.warn("Ignoring input item, which is not an object at index " + i);
          }
        }
      } else if (data && _typeof(data) === "object") {
        // Single item
        addOrUpdate(data);
      } else {
        throw new Error("Unknown dataType");
      }

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        var props = {
          items: updatedIds,
          oldData: oldData,
          data: updatedData
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger("update", props, senderId);
      }

      return concat(addedIds).call(addedIds, updatedIds);
    }
    /**
     * Update existing items. When an item does not exist, an error will be thrown.
     *
     * @remarks
     * The provided properties will be deeply merged into the existing item.
     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
     *
     * After the items are updated, the DataSet will trigger an event `update`.
     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' },
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' }, // works
     *   // { id: 4, text: 'item 4 (new)' }, // would throw
     *   // { text: 'item 4 (new)' }, // would also throw
     * ])
     *
     * console.log(ids) // [2]
     * ```
     * @param data - Updates (the id and optionally other props) to the items in this data set.
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the updated items.
     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
     */

  }, {
    key: "updateOnly",
    value: function updateOnly(data, senderId) {
      var _context19,
          _this6 = this;

      if (!isArray$2(data)) {
        data = [data];
      }

      var updateEventData = map$3(_context19 = map$3(data).call(data, function (update) {
        var oldData = _this6._data.get(update[_this6._idProp]);

        if (oldData == null) {
          throw new Error("Updating non-existent items is not allowed.");
        }

        return {
          oldData: oldData,
          update: update
        };
      })).call(_context19, function (_ref5) {
        var oldData = _ref5.oldData,
            update = _ref5.update;
        var id = oldData[_this6._idProp];
        var updatedData = pureDeepObjectAssign(oldData, update);

        _this6._data.set(id, updatedData);

        return {
          id: id,
          oldData: oldData,
          updatedData: updatedData
        };
      });

      if (updateEventData.length) {
        var props = {
          items: map$3(updateEventData).call(updateEventData, function (value) {
            return value.id;
          }),
          oldData: map$3(updateEventData).call(updateEventData, function (value) {
            return value.oldData;
          }),
          data: map$3(updateEventData).call(updateEventData, function (value) {
            return value.updatedData;
          })
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger("update", props, senderId);

        return props.items;
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "get",
    value: function get(first, second) {
      // @TODO: Woudn't it be better to split this into multiple methods?
      // parse the arguments
      var id = undefined;
      var ids = undefined;
      var options = undefined;

      if (isId(first)) {
        // get(id [, options])
        id = first;
        options = second;
      } else if (isArray$2(first)) {
        // get(ids [, options])
        ids = first;
        options = second;
      } else {
        // get([, options])
        options = first;
      } // determine the return type


      var returnType = options && options.returnType === "Object" ? "Object" : "Array"; // @TODO: WTF is this? Or am I missing something?
      // var returnType
      // if (options && options.returnType) {
      //   var allowedValues = ['Array', 'Object']
      //   returnType =
      //     allowedValues.indexOf(options.returnType) == -1
      //       ? 'Array'
      //       : options.returnType
      // } else {
      //   returnType = 'Array'
      // }
      // build options

      var filter$1 = options && filter(options);

      var items = [];
      var item = undefined;
      var itemIds = undefined;
      var itemId = undefined; // convert items

      if (id != null) {
        // return a single item
        item = this._data.get(id);

        if (item && filter$1 && !filter$1(item)) {
          item = undefined;
        }
      } else if (ids != null) {
        // return a subset of items
        for (var i = 0, len = ids.length; i < len; i++) {
          item = this._data.get(ids[i]);

          if (item != null && (!filter$1 || filter$1(item))) {
            items.push(item);
          }
        }
      } else {
        var _context20;

        // return all items
        itemIds = _toConsumableArray(keys(_context20 = this._data).call(_context20));

        for (var _i = 0, _len2 = itemIds.length; _i < _len2; _i++) {
          itemId = itemIds[_i];
          item = this._data.get(itemId);

          if (item != null && (!filter$1 || filter$1(item))) {
            items.push(item);
          }
        }
      } // order the results


      if (options && options.order && id == undefined) {
        this._sort(items, options.order);
      } // filter fields of the items


      if (options && options.fields) {
        var fields = options.fields;

        if (id != undefined && item != null) {
          item = this._filterFields(item, fields);
        } else {
          for (var _i2 = 0, _len3 = items.length; _i2 < _len3; _i2++) {
            items[_i2] = this._filterFields(items[_i2], fields);
          }
        }
      } // return the results


      if (returnType == "Object") {
        var result = {};

        for (var _i3 = 0, _len4 = items.length; _i3 < _len4; _i3++) {
          var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?
          // result[resultant.id] = resultant

          var _id2 = resultant[this._idProp];
          result[_id2] = resultant;
        }

        return result;
      } else {
        if (id != null) {
          var _item;

          // a single item
          return (_item = item) !== null && _item !== void 0 ? _item : null;
        } else {
          // just return our array
          return items;
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      var data = this._data;

      var filter$1 = options && filter(options);

      var order = options && options.order;

      var itemIds = _toConsumableArray(keys(data).call(data));

      var ids = [];

      if (filter$1) {
        // get filtered items
        if (order) {
          // create ordered list
          var items = [];

          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id = itemIds[i];

            var item = this._data.get(id);

            if (item != null && filter$1(item)) {
              items.push(item);
            }
          }

          this._sort(items, order);

          for (var _i4 = 0, _len5 = items.length; _i4 < _len5; _i4++) {
            ids.push(items[_i4][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i5 = 0, _len6 = itemIds.length; _i5 < _len6; _i5++) {
            var _id3 = itemIds[_i5];

            var _item2 = this._data.get(_id3);

            if (_item2 != null && filter$1(_item2)) {
              ids.push(_item2[this._idProp]);
            }
          }
        }
      } else {
        // get all items
        if (order) {
          // create an ordered list
          var _items = [];

          for (var _i6 = 0, _len7 = itemIds.length; _i6 < _len7; _i6++) {
            var _id4 = itemIds[_i6];

            _items.push(data.get(_id4));
          }

          this._sort(_items, order);

          for (var _i7 = 0, _len8 = _items.length; _i7 < _len8; _i7++) {
            ids.push(_items[_i7][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i8 = 0, _len9 = itemIds.length; _i8 < _len9; _i8++) {
            var _id5 = itemIds[_i8];

            var _item3 = data.get(_id5);

            if (_item3 != null) {
              ids.push(_item3[this._idProp]);
            }
          }
        }
      }

      return ids;
    }
    /** @inheritDoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this;
    }
    /** @inheritDoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      var filter$1 = options && filter(options);

      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data));

      if (options && options.order) {
        // execute forEach on ordered list
        var items = this.get(options);

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var id = item[this._idProp];
          callback(item, id);
        }
      } else {
        // unordered
        for (var _i9 = 0, _len10 = itemIds.length; _i9 < _len10; _i9++) {
          var _id6 = itemIds[_i9];

          var _item4 = this._data.get(_id6);

          if (_item4 != null && (!filter$1 || filter$1(_item4))) {
            callback(_item4, _id6);
          }
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      var filter$1 = options && filter(options);

      var mappedItems = [];
      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data)); // convert and filter items


      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];

        var item = this._data.get(id);

        if (item != null && (!filter$1 || filter$1(item))) {
          mappedItems.push(callback(item, id));
        }
      } // order items


      if (options && options.order) {
        this._sort(mappedItems, options.order);
      }

      return mappedItems;
    }
    /**
     * Filter the fields of an item.
     *
     * @param item - The item whose fields should be filtered.
     * @param fields - The names of the fields that will be kept.
     * @typeParam K - Field name type.
     * @returns The item without any additional fields.
     */

  }, {
    key: "_filterFields",
    value: function _filterFields(item, fields) {
      var _context21;

      if (!item) {
        // item is null
        return item;
      }

      return reduce(_context21 = isArray$2(fields) ? // Use the supplied array
      fields : // Use the keys of the supplied object
      keys$4(fields)).call(_context21, function (filteredItem, field) {
        filteredItem[field] = item[field];
        return filteredItem;
      }, {});
    }
    /**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     * @typeParam T - The type of the items in the items array.
     */

  }, {
    key: "_sort",
    value: function _sort(items, order) {
      if (typeof order === "string") {
        // order by provided field name
        var name = order; // field name

        sort(items).call(items, function (a, b) {
          // @TODO: How to treat missing properties?
          var av = a[name];
          var bv = b[name];
          return av > bv ? 1 : av < bv ? -1 : 0;
        });
      } else if (typeof order === "function") {
        // order by sort function
        sort(items).call(items, order);
      } else {
        // TODO: extend order by an Object {field:string, direction:string}
        //       where direction can be 'asc' or 'desc'
        throw new TypeError("Order must be a function or a string");
      }
    }
    /**
     * Remove an item or multiple items by âreferenceâ (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     * @returns The ids of the removed items.
     */

  }, {
    key: "remove",
    value: function remove(id, senderId) {
      var removedIds = [];
      var removedItems = []; // force everything to be an array for simplicity

      var ids = isArray$2(id) ? id : [id];

      for (var i = 0, len = ids.length; i < len; i++) {
        var item = this._remove(ids[i]);

        if (item) {
          var itemId = item[this._idProp];

          if (itemId != null) {
            removedIds.push(itemId);
            removedItems.push(item);
          }
        }
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }

      return removedIds;
    }
    /**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     * @returns The removed item if removed, null otherwise.
     */

  }, {
    key: "_remove",
    value: function _remove(id) {
      // @TODO: It origianlly returned the item although the docs say id.
      // The code expects the item, so probably an error in the docs.
      var ident; // confirm the id to use based on the args type

      if (isId(id)) {
        ident = id;
      } else if (id && _typeof(id) === "object") {
        ident = id[this._idProp]; // look for the identifier field using ._idProp
      } // do the removing if the item is found


      if (ident != null && this._data.has(ident)) {
        var item = this._data.get(ident) || null;

        this._data.delete(ident);

        --this.length;
        return item;
      }

      return null;
    }
    /**
     * Clear the entire data set.
     *
     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     * @returns removedIds - The ids of all removed items.
     */

  }, {
    key: "clear",
    value: function clear(senderId) {
      var _context22;

      var ids = _toConsumableArray(keys(_context22 = this._data).call(_context22));

      var items = [];

      for (var i = 0, len = ids.length; i < len; i++) {
        items.push(this._data.get(ids[i]));
      }

      this._data.clear();

      this.length = 0;

      this._trigger("remove", {
        items: ids,
        oldData: items
      }, senderId);

      return ids;
    }
    /**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     * @returns Item containing max value, or null if no items.
     */

  }, {
    key: "max",
    value: function max(field) {
      var _context23;

      var max = null;
      var maxField = null;

      var _iterator11 = _createForOfIteratorHelper$7(values(_context23 = this._data).call(_context23)),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var item = _step11.value;
          var itemField = item[field];

          if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
            max = item;
            maxField = itemField;
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return max || null;
    }
    /**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     * @returns Item containing min value, or null if no items.
     */

  }, {
    key: "min",
    value: function min(field) {
      var _context24;

      var min = null;
      var minField = null;

      var _iterator12 = _createForOfIteratorHelper$7(values(_context24 = this._data).call(_context24)),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var item = _step12.value;
          var itemField = item[field];

          if (typeof itemField === "number" && (minField == null || itemField < minField)) {
            min = item;
            minField = itemField;
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      return min || null;
    }
    /**
     * Find all distinct values of a specified field
     *
     * @param prop - The property name whose distinct values should be returned.
     * @returns Unordered array containing all distinct values. Items without specified property are ignored.
     */

  }, {
    key: "distinct",
    value: function distinct(prop) {
      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data));

      var values = [];
      var count = 0;

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];
        var item = data.get(id);
        var _value3 = item[prop];
        var exists = false;

        for (var j = 0; j < count; j++) {
          if (values[j] == _value3) {
            exists = true;
            break;
          }
        }

        if (!exists && _value3 !== undefined) {
          values[count] = _value3;
          count++;
        }
      }

      return values;
    }
    /**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     * @returns Added item's id. An id is generated when it is not present in the item.
     */

  }, {
    key: "_addItem",
    value: function _addItem(item) {
      var fullItem = ensureFullItem(item, this._idProp);
      var id = fullItem[this._idProp]; // check whether this id is already taken

      if (this._data.has(id)) {
        // item already exists
        throw new Error("Cannot add item: item with id " + id + " already exists");
      }

      this._data.set(id, fullItem);

      ++this.length;
      return id;
    }
    /**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param update - The new item
     * @returns The id of the updated item.
     */

  }, {
    key: "_updateItem",
    value: function _updateItem(update) {
      var id = update[this._idProp];

      if (id == null) {
        throw new Error("Cannot update item: item has no id (item: " + stringify$1(update) + ")");
      }

      var item = this._data.get(id);

      if (!item) {
        // item doesn't exist
        throw new Error("Cannot update item: no item with id " + id + " found");
      }

      this._data.set(id, _objectSpread$4(_objectSpread$4({}, item), update));

      return id;
    }
    /** @inheritDoc */

  }, {
    key: "stream",
    value: function stream(ids) {
      if (ids) {
        var data = this._data;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee3() {
          var _iterator13, _step13, id, item;

          return regenerator.wrap(function _callee3$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  _iterator13 = _createForOfIteratorHelper$7(ids);
                  _context25.prev = 1;

                  _iterator13.s();

                case 3:
                  if ((_step13 = _iterator13.n()).done) {
                    _context25.next = 11;
                    break;
                  }

                  id = _step13.value;
                  item = data.get(id);

                  if (!(item != null)) {
                    _context25.next = 9;
                    break;
                  }

                  _context25.next = 9;
                  return [id, item];

                case 9:
                  _context25.next = 3;
                  break;

                case 11:
                  _context25.next = 16;
                  break;

                case 13:
                  _context25.prev = 13;
                  _context25.t0 = _context25["catch"](1);

                  _iterator13.e(_context25.t0);

                case 16:
                  _context25.prev = 16;

                  _iterator13.f();

                  return _context25.finish(16);

                case 19:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee3, null, [[1, 13, 16, 19]]);
        })));
      } else {
        var _context26;

        return new DataStream(_defineProperty({}, iterator, bind$6(_context26 = entries(this._data)).call(_context26, this._data)));
      }
    }
  }]);

  return DataSet;
}(DataSetPart);
/**
 * DataView
 *
 * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
 *
 * ## Example
 * ```javascript
 * // create a DataSet
 * var data = new vis.DataSet();
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // create a DataView
 * // the view will only contain items having a property group with value 1,
 * // and will only output fields id, text, and date.
 * var view = new vis.DataView(data, {
 *   filter: function (item) {
 *     return (item.group == 1);
 *   },
 *   fields: ['id', 'text', 'date']
 * });
 *
 * // subscribe to any change in the DataView
 * view.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an item in the data set
 * data.update({id: 2, group: 1});
 *
 * // get all ids in the view
 * var ids = view.getIds();
 * console.log('ids', ids); // will output [1, 2]
 *
 * // get all items in the view
 * var items = view.get();
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataView = /*#__PURE__*/function (_DataSetPart2) {
  _inherits(DataView, _DataSetPart2);

  var _super2 = _createSuper$t(DataView);

  /**
   * Create a DataView.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @param options - Options to configure this data view.
   */
  function DataView(data, options) {
    var _context27;

    var _this7;

    _classCallCheck(this, DataView);

    _this7 = _super2.call(this);

    _defineProperty(_assertThisInitialized(_this7), "length", 0);

    _defineProperty(_assertThisInitialized(_this7), "_listener", void 0);

    _defineProperty(_assertThisInitialized(_this7), "_data", void 0);

    _defineProperty(_assertThisInitialized(_this7), "_ids", new set());

    _defineProperty(_assertThisInitialized(_this7), "_options", void 0);

    _this7._options = options || {};
    _this7._listener = bind$6(_context27 = _this7._onEvent).call(_context27, _assertThisInitialized(_this7));

    _this7.setData(data);

    return _this7;
  } // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @remarks
   * Note that when the data view is bound to a data set it won't be garbage
   * collected unless the data set is too. Use `dataView.setData(null)` or
   * `dataView.dispose()` to enable garbage collection before you lose the last
   * reference.
   */


  _createClass(DataView, [{
    key: "idProp",
    get:
    /** @inheritDoc */

    /** @inheritDoc */
    function get() {
      return this.getDataSet().idProp;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      if (this._data) {
        // unsubscribe from current dataset
        if (this._data.off) {
          this._data.off("*", this._listener);
        } // trigger a remove of all items in memory


        var ids = this._data.getIds({
          filter: filter(this._options)
        });

        var items = this._data.get(ids);

        this._ids.clear();

        this.length = 0;

        this._trigger("remove", {
          items: ids,
          oldData: items
        });
      }

      if (data != null) {
        this._data = data; // trigger an add of all added items

        var _ids = this._data.getIds({
          filter: filter(this._options)
        });

        for (var i = 0, len = _ids.length; i < len; i++) {
          var id = _ids[i];

          this._ids.add(id);
        }

        this.length = _ids.length;

        this._trigger("add", {
          items: _ids
        });
      } else {
        this._data = new DataSet();
      } // subscribe to new dataset


      if (this._data.on) {
        this._data.on("*", this._listener);
      }
    }
    /**
     * Refresh the DataView.
     * Useful when the DataView has a filter function containing a variable parameter.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var ids = this._data.getIds({
        filter: filter(this._options)
      });

      var oldIds = _toConsumableArray(this._ids);

      var newIds = {};
      var addedIds = [];
      var removedIds = [];
      var removedItems = []; // check for additions

      for (var i = 0, len = ids.length; i < len; i++) {
        var id = ids[i];
        newIds[id] = true;

        if (!this._ids.has(id)) {
          addedIds.push(id);

          this._ids.add(id);
        }
      } // check for removals


      for (var _i10 = 0, _len11 = oldIds.length; _i10 < _len11; _i10++) {
        var _id7 = oldIds[_i10];

        var item = this._data.get(_id7);

        if (item == null) {
          // @TODO: Investigate.
          // Doesn't happen during tests or examples.
          // Is it really impossible or could it eventually happen?
          // How to handle it if it does? The types guarantee non-nullable items.
          console.error("If you see this, report it please.");
        } else if (!newIds[_id7]) {
          removedIds.push(_id7);
          removedItems.push(item);

          this._ids.delete(_id7);
        }
      }

      this.length += addedIds.length - removedIds.length; // trigger events

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        });
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        });
      }
    }
    /** @inheritDoc */

  }, {
    key: "get",
    value: function get(first, second) {
      if (this._data == null) {
        return null;
      } // parse the arguments


      var ids = null;
      var options;

      if (isId(first) || isArray$2(first)) {
        ids = first;
        options = second;
      } else {
        options = first;
      } // extend the options with the default options and provided options


      var viewOptions = assign$2({}, this._options, options); // create a combined filter method when needed


      var thisFilter = filter(this._options);

      var optionsFilter = options && filter(options);

      if (thisFilter && optionsFilter) {
        viewOptions.filter = function (item) {
          return thisFilter(item) && optionsFilter(item);
        };
      }

      if (ids == null) {
        return this._data.get(viewOptions);
      } else {
        return this._data.get(ids, viewOptions);
      }
    }
    /** @inheritDoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      if (this._data.length) {
        var defaultFilter = filter(this._options);

        var optionsFilter = options != null ? filter(options) : null;
        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        return this._data.getIds({
          filter: filter$1,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      if (this._data) {
        var _context28;

        var defaultFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        forEach$2(_context28 = this._data).call(_context28, callback, {
          filter: filter$1,
          order: options && options.order
        });
      }
    }
    /** @inheritDoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      if (this._data) {
        var _context29;

        var defaultFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        return map$3(_context29 = this._data).call(_context29, callback, {
          filter: filter$1,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this._data.getDataSet();
    }
    /** @inheritDoc */

  }, {
    key: "stream",
    value: function stream(ids) {
      var _context30;

      return this._data.stream(ids || _defineProperty({}, iterator, bind$6(_context30 = keys(this._ids)).call(_context30, this._ids)));
    }
    /**
     * Render the instance unusable prior to garbage collection.
     *
     * @remarks
     * The intention of this method is to help discover scenarios where the data
     * view is being used when the programmer thinks it has been garbage collected
     * already. It's stricter version of `dataView.setData(null)`.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var _this$_data;

      if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {
        this._data.off("*", this._listener);
      }

      var message = "This data view has already been disposed of.";
      var replacement = {
        get: function get() {
          throw new Error(message);
        },
        set: function set() {
          throw new Error(message);
        },
        configurable: false
      };

      var _iterator14 = _createForOfIteratorHelper$7(ownKeys$5(DataView.prototype)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var key = _step14.value;

          defineProperty$6(this, key, replacement);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    /**
     * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
     *
     * @param event - The name of the event.
     * @param params - Parameters of the event.
     * @param senderId - Id supplied by the sender.
     */

  }, {
    key: "_onEvent",
    value: function _onEvent(event, params, senderId) {
      if (!params || !params.items || !this._data) {
        return;
      }

      var ids = params.items;
      var addedIds = [];
      var updatedIds = [];
      var removedIds = [];
      var oldItems = [];
      var updatedItems = [];
      var removedItems = [];

      switch (event) {
        case "add":
          // filter the ids of the added items
          for (var i = 0, len = ids.length; i < len; i++) {
            var id = ids[i];
            var item = this.get(id);

            if (item) {
              this._ids.add(id);

              addedIds.push(id);
            }
          }

          break;

        case "update":
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (var _i11 = 0, _len12 = ids.length; _i11 < _len12; _i11++) {
            var _id8 = ids[_i11];

            var _item5 = this.get(_id8);

            if (_item5) {
              if (this._ids.has(_id8)) {
                updatedIds.push(_id8);
                updatedItems.push(params.data[_i11]);
                oldItems.push(params.oldData[_i11]);
              } else {
                this._ids.add(_id8);

                addedIds.push(_id8);
              }
            } else {
              if (this._ids.has(_id8)) {
                this._ids.delete(_id8);

                removedIds.push(_id8);
                removedItems.push(params.oldData[_i11]);
              }
            }
          }

          break;

        case "remove":
          // filter the ids of the removed items
          for (var _i12 = 0, _len13 = ids.length; _i12 < _len13; _i12++) {
            var _id9 = ids[_i12];

            if (this._ids.has(_id9)) {
              this._ids.delete(_id9);

              removedIds.push(_id9);
              removedItems.push(params.oldData[_i12]);
            }
          }

          break;
      }

      this.length += addedIds.length - removedIds.length;

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        this._trigger("update", {
          items: updatedIds,
          oldData: oldItems,
          data: updatedItems
        }, senderId);
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }
    }
  }]);

  return DataView;
}(DataSetPart);
/**
 * Check that given value is compatible with Vis Data Set interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 * @returns True if all expected values and methods match, false otherwise.
 */


function isDataSetLike(idProp, v) {
  return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof v.add === "function" && typeof v.clear === "function" && typeof v.distinct === "function" && typeof forEach$2(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.max === "function" && typeof v.min === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.remove === "function" && typeof v.setOptions === "function" && typeof v.stream === "function" && typeof v.update === "function" && typeof v.updateOnly === "function";
}
/**
 * Check that given value is compatible with Vis Data View interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 * @returns True if all expected values and methods match, false otherwise.
 */


function isDataViewLike(idProp, v) {
  return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof forEach$2(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.stream === "function" && isDataSetLike(idProp, v.getDataSet());
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DELETE: DELETE,
	DataSet: DataSet,
	DataStream: DataStream,
	DataView: DataView,
	Queue: Queue,
	createNewDataPipeFrom: createNewDataPipeFrom,
	isDataSetLike: isDataSetLike,
	isDataViewLike: isDataViewLike
});

var global$2 = global$P;
var fails$1 = fails$t;
var uncurryThis$2 = functionUncurryThis;
var toString = toString$8;
var trim = stringTrim.trim;
var whitespaces = whitespaces$4;
var charAt = uncurryThis$2(''.charAt);
var n$ParseFloat = global$2.parseFloat;
var Symbol$1 = global$2.Symbol;
var ITERATOR = Symbol$1 && Symbol$1.iterator;
var FORCED = 1 / n$ParseFloat(whitespaces + '-0') !== -Infinity // MS Edge 18- broken with boxed symbols
|| ITERATOR && !fails$1(function () {
  n$ParseFloat(Object(ITERATOR));
}); // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

var numberParseFloat = FORCED ? function parseFloat(string) {
  var trimmedString = trim(toString(string));
  var result = n$ParseFloat(trimmedString);
  return result === 0 && charAt(trimmedString, 0) == '-' ? -0 : result;
} : n$ParseFloat;

var $$4 = _export;
var $parseFloat = numberParseFloat; // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

$$4({
  global: true,
  forced: parseFloat != $parseFloat
}, {
  parseFloat: $parseFloat
});

var path$5 = path$y;
var _parseFloat$2 = path$5.parseFloat;

var parent$9 = _parseFloat$2;
var _parseFloat$1 = parent$9;

var _parseFloat = _parseFloat$1;

var $$3 = _export;
var fails = fails$t;
var getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f; // eslint-disable-next-line es/no-object-getownpropertynames -- required for testing

var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames

$$3({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: getOwnPropertyNames$3
});

var path$4 = path$y;
var Object$1 = path$4.Object;

var getOwnPropertyNames$2 = function getOwnPropertyNames(it) {
  return Object$1.getOwnPropertyNames(it);
};

var parent$8 = getOwnPropertyNames$2;
var getOwnPropertyNames$1 = parent$8;

var getOwnPropertyNames = getOwnPropertyNames$1;

/**
 * Helper functions for components
 */

/**
 * Determine values to use for (sub)options of 'chosen'.
 *
 * This option is either a boolean or an object whose values should be examined further.
 * The relevant structures are:
 *
 * - chosen: <boolean value>
 * - chosen: { subOption: <boolean or function> }
 *
 * Where subOption is 'node', 'edge' or 'label'.
 *
 * The intention of this method appears to be to set a specific priority to the options;
 * Since most properties are either bridged or merged into the local options objects, there
 * is not much point in handling them separately.
 * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we
 *       should be able to get rid of this method.
 *
 * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'
 * @param {object}  pile       array of options objects to consider
 * @returns {boolean | Function}  value for passed subOption of 'chosen' to use
 */

function choosify(subOption, pile) {
  // allowed values for subOption
  var allowed = ["node", "edge", "label"];
  var value = true;
  var chosen = topMost(pile, "chosen");

  if (typeof chosen === "boolean") {
    value = chosen;
  } else if (_typeof(chosen) === "object") {
    if (indexOf(allowed).call(allowed, subOption) === -1) {
      throw new Error("choosify: subOption '" + subOption + "' should be one of " + "'" + allowed.join("', '") + "'");
    }

    var chosenEdge = topMost(pile, ["chosen", subOption]);

    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
      value = chosenEdge;
    }
  }

  return value;
}
/**
 * Check if the point falls within the given rectangle.
 *
 * @param {rect} rect
 * @param {point} point
 * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.
 * @returns {boolean}  true if point within rectangle, false otherwise
 */

function pointInRect(rect, point, rotationPoint) {
  if (rect.width <= 0 || rect.height <= 0) {
    return false; // early out
  }

  if (rotationPoint !== undefined) {
    // Rotate the point the same amount as the rectangle
    var tmp = {
      x: point.x - rotationPoint.x,
      y: point.y - rotationPoint.y
    };

    if (rotationPoint.angle !== 0) {
      // In order to get the coordinates the same, you need to
      // rotate in the reverse direction
      var angle = -rotationPoint.angle;
      var tmp2 = {
        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
      };
      point = tmp2;
    } else {
      point = tmp;
    } // Note that if a rotation is specified, the rectangle coordinates
    // are **not* the full canvas coordinates. They are relative to the
    // rotationPoint. Hence, the point coordinates need not be translated
    // back in this case.

  }

  var right = rect.x + rect.width;
  var bottom = rect.y + rect.width;
  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
}
/**
 * Check if given value is acceptable as a label text.
 *
 * @param {*} text value to check; can be anything at this point
 * @returns {boolean} true if valid label value, false otherwise
 */

function isValidLabel(text) {
  // Note that this is quite strict: types that *might* be converted to string are disallowed
  return typeof text === "string" && text !== "";
}
/**
 * Returns x, y of self reference circle based on provided angle
 *
 * @param {object} ctx
 * @param {number} angle
 * @param {number} radius
 * @param {VisNode} node
 * @returns {object} x and y coordinates
 */

function getSelfRefCoordinates(ctx, angle, radius, node) {
  var x = node.x;
  var y = node.y;

  if (typeof node.distanceToBorder === "function") {
    //calculating opposite and adjacent
    //distaneToBorder becomes Hypotenuse.
    //Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse
    var toBorderDist = node.distanceToBorder(ctx, angle);
    var yFromNodeCenter = Math.sin(angle) * toBorderDist;
    var xFromNodeCenter = Math.cos(angle) * toBorderDist; //xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means
    //that y does not need calculation because it is equal node.height / 2 or node.y
    //same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means
    //that x is equal node.width / 2 or node.x

    if (xFromNodeCenter === toBorderDist) {
      x += toBorderDist;
      y = node.y;
    } else if (yFromNodeCenter === toBorderDist) {
      x = node.x;
      y -= toBorderDist;
    } else {
      x += xFromNodeCenter;
      y -= yFromNodeCenter;
    }
  } else if (node.shape.width > node.shape.height) {
    x = node.x + node.shape.width * 0.5;
    y = node.y - radius;
  } else {
    x = node.x + radius;
    y = node.y - node.shape.height * 0.5;
  }

  return {
    x: x,
    y: y
  };
}

/**
 * Callback to determine text dimensions, using the parent label settings.
 *
 * @callback MeasureText
 * @param {text} text
 * @param {text} mod
 * @returns {object} { width, values} width in pixels and font attributes
 */

/**
 * Helper class for Label which collects results of splitting labels into lines and blocks.
 *
 * @private
 */
var LabelAccumulator = /*#__PURE__*/function () {
  /**
   * @param {MeasureText} measureText
   */
  function LabelAccumulator(measureText) {
    _classCallCheck(this, LabelAccumulator);

    this.measureText = measureText;
    this.current = 0;
    this.width = 0;
    this.height = 0;
    this.lines = [];
  }
  /**
   * Append given text to the given line.
   *
   * @param {number}  l    index of line to add to
   * @param {string}  text string to append to line
   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
   * @private
   */


  _createClass(LabelAccumulator, [{
    key: "_add",
    value: function _add(l, text) {
      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "normal";

      if (this.lines[l] === undefined) {
        this.lines[l] = {
          width: 0,
          height: 0,
          blocks: []
        };
      } // We still need to set a block for undefined and empty texts, hence return at this point
      // This is necessary because we don't know at this point if we're at the
      // start of an empty line or not.
      // To compensate, empty blocks are removed in `finalize()`.
      //
      // Empty strings should still have a height


      var tmpText = text;
      if (text === undefined || text === "") tmpText = " "; // Determine width and get the font properties

      var result = this.measureText(tmpText, mod);

      var block = assign$2({}, values(result));

      block.text = text;
      block.width = result.width;
      block.mod = mod;

      if (text === undefined || text === "") {
        block.width = 0;
      }

      this.lines[l].blocks.push(block); // Update the line width. We need this for determining if a string goes over max width

      this.lines[l].width += block.width;
    }
    /**
     * Returns the width in pixels of the current line.
     *
     * @returns {number}
     */

  }, {
    key: "curWidth",
    value: function curWidth() {
      var line = this.lines[this.current];
      if (line === undefined) return 0;
      return line.width;
    }
    /**
     * Add text in block to current line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: "append",
    value: function append(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";

      this._add(this.current, text, mod);
    }
    /**
     * Add text in block to current line and start a new line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: "newLine",
    value: function newLine(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";

      this._add(this.current, text, mod);

      this.current++;
    }
    /**
     * Determine and set the heights of all the lines currently contained in this instance
     *
     * Note that width has already been set.
     *
     * @private
     */

  }, {
    key: "determineLineHeights",
    value: function determineLineHeights() {
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k]; // Looking for max height of blocks in line

        var height = 0;

        if (line.blocks !== undefined) {
          // Can happen if text contains e.g. '\n '
          for (var l = 0; l < line.blocks.length; l++) {
            var block = line.blocks[l];

            if (height < block.height) {
              height = block.height;
            }
          }
        }

        line.height = height;
      }
    }
    /**
     * Determine the full size of the label text, as determined by current lines and blocks
     *
     * @private
     */

  }, {
    key: "determineLabelSize",
    value: function determineLabelSize() {
      var width = 0;
      var height = 0;

      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];

        if (line.width > width) {
          width = line.width;
        }

        height += line.height;
      }

      this.width = width;
      this.height = height;
    }
    /**
     * Remove all empty blocks and empty lines we don't need
     *
     * This must be done after the width/height determination,
     * so that these are set properly for processing here.
     *
     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
     * @private
     */

  }, {
    key: "removeEmptyBlocks",
    value: function removeEmptyBlocks() {
      var tmpLines = [];

      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k]; // Note: an empty line in between text has width zero but is still relevant to layout.
        // So we can't use width for testing empty line here

        if (line.blocks.length === 0) continue; // Discard final empty line always

        if (k === this.lines.length - 1) {
          if (line.width === 0) continue;
        }

        var tmpLine = {};

        assign$2(tmpLine, line);

        tmpLine.blocks = [];
        var firstEmptyBlock = void 0;
        var tmpBlocks = [];

        for (var l = 0; l < line.blocks.length; l++) {
          var block = line.blocks[l];

          if (block.width !== 0) {
            tmpBlocks.push(block);
          } else {
            if (firstEmptyBlock === undefined) {
              firstEmptyBlock = block;
            }
          }
        } // Ensure that there is *some* text present


        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {
          tmpBlocks.push(firstEmptyBlock);
        }

        tmpLine.blocks = tmpBlocks;
        tmpLines.push(tmpLine);
      }

      return tmpLines;
    }
    /**
     * Set the sizes for all lines and the whole thing.
     *
     * @returns {{width: (number|*), height: (number|*), lines: Array}}
     */

  }, {
    key: "finalize",
    value: function finalize() {
      //console.log(JSON.stringify(this.lines, null, 2));
      this.determineLineHeights();
      this.determineLabelSize();
      var tmpLines = this.removeEmptyBlocks(); // Return a simple hash object for further processing.

      return {
        width: this.width,
        height: this.height,
        lines: tmpLines
      };
    }
  }]);

  return LabelAccumulator;
}();

var tagPattern = {
  // HTML
  "<b>": /<b>/,
  "<i>": /<i>/,
  "<code>": /<code>/,
  "</b>": /<\/b>/,
  "</i>": /<\/i>/,
  "</code>": /<\/code>/,
  // Markdown
  "*": /\*/,
  // bold
  _: /_/,
  // ital
  "`": /`/,
  // mono
  afterBold: /[^*]/,
  afterItal: /[^_]/,
  afterMono: /[^`]/
};
/**
 * Internal helper class for parsing the markup tags for HTML and Markdown.
 *
 * NOTE: Sequences of tabs and spaces are reduced to single space.
 *       Scan usage of `this.spacing` within method
 */

var MarkupAccumulator = /*#__PURE__*/function () {
  /**
   * Create an instance
   *
   * @param {string} text  text to parse for markup
   */
  function MarkupAccumulator(text) {
    _classCallCheck(this, MarkupAccumulator);

    this.text = text;
    this.bold = false;
    this.ital = false;
    this.mono = false;
    this.spacing = false;
    this.position = 0;
    this.buffer = "";
    this.modStack = [];
    this.blocks = [];
  }
  /**
   * Return the mod label currently on the top of the stack
   *
   * @returns {string}  label of topmost mod
   * @private
   */


  _createClass(MarkupAccumulator, [{
    key: "mod",
    value: function mod() {
      return this.modStack.length === 0 ? "normal" : this.modStack[0];
    }
    /**
     * Return the mod label currently active
     *
     * @returns {string}  label of active mod
     * @private
     */

  }, {
    key: "modName",
    value: function modName() {
      if (this.modStack.length === 0) return "normal";else if (this.modStack[0] === "mono") return "mono";else {
        if (this.bold && this.ital) {
          return "boldital";
        } else if (this.bold) {
          return "bold";
        } else if (this.ital) {
          return "ital";
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "emitBlock",
    value: function emitBlock() {
      if (this.spacing) {
        this.add(" ");
        this.spacing = false;
      }

      if (this.buffer.length > 0) {
        this.blocks.push({
          text: this.buffer,
          mod: this.modName()
        });
        this.buffer = "";
      }
    }
    /**
     * Output text to buffer
     *
     * @param {string} text  text to add
     * @private
     */

  }, {
    key: "add",
    value: function add(text) {
      if (text === " ") {
        this.spacing = true;
      }

      if (this.spacing) {
        this.buffer += " ";
        this.spacing = false;
      }

      if (text != " ") {
        this.buffer += text;
      }
    }
    /**
     * Handle parsing of whitespace
     *
     * @param {string} ch  the character to check
     * @returns {boolean} true if the character was processed as whitespace, false otherwise
     */

  }, {
    key: "parseWS",
    value: function parseWS(ch) {
      if (/[ \t]/.test(ch)) {
        if (!this.mono) {
          this.spacing = true;
        } else {
          this.add(ch);
        }

        return true;
      }

      return false;
    }
    /**
     * @param {string} tagName  label for block type to set
     * @private
     */

  }, {
    key: "setTag",
    value: function setTag(tagName) {
      this.emitBlock();
      this[tagName] = true;
      this.modStack.unshift(tagName);
    }
    /**
     * @param {string} tagName  label for block type to unset
     * @private
     */

  }, {
    key: "unsetTag",
    value: function unsetTag(tagName) {
      this.emitBlock();
      this[tagName] = false;
      this.modStack.shift();
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "parseStartTag",
    value: function parseStartTag(tagName, tag) {
      // Note: if 'mono' passed as tagName, there is a double check here. This is OK
      if (!this.mono && !this[tagName] && this.match(tag)) {
        this.setTag(tagName);
        return true;
      }

      return false;
    }
    /**
     * @param {string|RegExp} tag
     * @param {number} [advance=true] if set, advance current position in text
     * @returns {boolean} true if match at given position, false otherwise
     * @private
     */

  }, {
    key: "match",
    value: function match(tag) {
      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var _this$prepareRegExp = this.prepareRegExp(tag),
          _this$prepareRegExp2 = _slicedToArray(_this$prepareRegExp, 2),
          regExp = _this$prepareRegExp2[0],
          length = _this$prepareRegExp2[1];

      var matched = regExp.test(this.text.substr(this.position, length));

      if (matched && advance) {
        this.position += length - 1;
      }

      return matched;
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "parseEndTag",
    value: function parseEndTag(tagName, tag, nextTag) {
      var checkTag = this.mod() === tagName;

      if (tagName === "mono") {
        // special handling for 'mono'
        checkTag = checkTag && this.mono;
      } else {
        checkTag = checkTag && !this.mono;
      }

      if (checkTag && this.match(tag)) {
        if (nextTag !== undefined) {
          // Purpose of the following match is to prevent a direct unset/set of a given tag
          // E.g. '*bold **still bold*' => '*bold still bold*'
          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
            this.unsetTag(tagName);
          }
        } else {
          this.unsetTag(tagName);
        }

        return true;
      }

      return false;
    }
    /**
     * @param {string|RegExp} tag  string to match in text
     * @param {value} value  string to replace tag with, if found at current position
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "replace",
    value: function replace(tag, value) {
      if (this.match(tag)) {
        this.add(value);
        this.position += length - 1;
        return true;
      }

      return false;
    }
    /**
     * Create a regular expression for the tag if it isn't already one.
     *
     * The return value is an array `[RegExp, number]`, with exactly two value, where:
     *  - RegExp is the regular expression to use
     *  - number is the lenth of the input string to match
     *
     * @param {string|RegExp} tag  string to match in text
     * @returns {Array}  regular expression to use and length of input string to match
     * @private
     */

  }, {
    key: "prepareRegExp",
    value: function prepareRegExp(tag) {
      var length;
      var regExp;

      if (tag instanceof RegExp) {
        regExp = tag;
        length = 1; // ASSUMPTION: regexp only tests one character
      } else {
        // use prepared regexp if present
        var prepared = tagPattern[tag];

        if (prepared !== undefined) {
          regExp = prepared;
        } else {
          regExp = new RegExp(tag);
        }

        length = tag.length;
      }

      return [regExp, length];
    }
  }]);

  return MarkupAccumulator;
}();
/**
 * Helper class for Label which explodes the label text into lines and blocks within lines
 *
 * @private
 */


var LabelSplitter = /*#__PURE__*/function () {
  /**
   * @param {CanvasRenderingContext2D} ctx Canvas rendering context
   * @param {Label} parent reference to the Label instance using current instance
   * @param {boolean} selected
   * @param {boolean} hover
   */
  function LabelSplitter(ctx, parent, selected, hover) {
    var _this = this;

    _classCallCheck(this, LabelSplitter);

    this.ctx = ctx;
    this.parent = parent;
    this.selected = selected;
    this.hover = hover;
    /**
     * Callback to determine text width; passed to LabelAccumulator instance
     *
     * @param  {string} text string to determine width of
     * @param  {string} mod  font type to use for this text
     * @returns {object} { width, values} width in pixels and font attributes
     */

    var textWidth = function textWidth(text, mod) {
      if (text === undefined) return 0; // TODO: This can be done more efficiently with caching
      // This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.

      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);

      var width = 0;

      if (text !== "") {
        var measure = _this.ctx.measureText(text);

        width = measure.width;
      }

      return {
        width: width,
        values: values
      };
    };

    this.lines = new LabelAccumulator(textWidth);
  }
  /**
   * Split passed text of a label into lines and blocks.
   *
   * # NOTE
   *
   * The handling of spacing is option dependent:
   *
   * - if `font.multi : false`, all spaces are retained
   * - if `font.multi : true`, every sequence of spaces is compressed to a single space
   *
   * This might not be the best way to do it, but this is as it has been working till now.
   * In order not to break existing functionality, for the time being this behaviour will
   * be retained in any code changes.
   *
   * @param {string} text  text to split
   * @returns {Array<line>}
   */


  _createClass(LabelSplitter, [{
    key: "process",
    value: function process(text) {
      if (!isValidLabel(text)) {
        return this.lines.finalize();
      }

      var font = this.parent.fontOptions; // Normalize the end-of-line's to a single representation - order important

      text = text.replace(/\r\n/g, "\n"); // Dos EOL's

      text = text.replace(/\r/g, "\n"); // Mac EOL's
      // Note that at this point, there can be no \r's in the text.
      // This is used later on splitStringIntoLines() to split multifont texts.

      var nlLines = String(text).split("\n");
      var lineCount = nlLines.length;

      if (font.multi) {
        // Multi-font case: styling tags active
        for (var i = 0; i < lineCount; i++) {
          var blocks = this.splitBlocks(nlLines[i], font.multi); // Post: Sequences of tabs and spaces are reduced to single space

          if (blocks === undefined) continue;

          if (blocks.length === 0) {
            this.lines.newLine("");
            continue;
          }

          if (font.maxWdt > 0) {
            // widthConstraint.maximum defined
            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);
            for (var j = 0; j < blocks.length; j++) {
              var mod = blocks[j].mod;
              var _text = blocks[j].text;
              this.splitStringIntoLines(_text, mod, true);
            }
          } else {
            // widthConstraint.maximum NOT defined
            for (var _j = 0; _j < blocks.length; _j++) {
              var _mod = blocks[_j].mod;
              var _text2 = blocks[_j].text;
              this.lines.append(_text2, _mod);
            }
          }

          this.lines.newLine();
        }
      } else {
        // Single-font case
        if (font.maxWdt > 0) {
          // widthConstraint.maximum defined
          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);
          for (var _i = 0; _i < lineCount; _i++) {
            this.splitStringIntoLines(nlLines[_i]);
          }
        } else {
          // widthConstraint.maximum NOT defined
          for (var _i2 = 0; _i2 < lineCount; _i2++) {
            this.lines.newLine(nlLines[_i2]);
          }
        }
      }

      return this.lines.finalize();
    }
    /**
     * normalize the markup system
     *
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {string}
     */

  }, {
    key: "decodeMarkupSystem",
    value: function decodeMarkupSystem(markupSystem) {
      var system = "none";

      if (markupSystem === "markdown" || markupSystem === "md") {
        system = "markdown";
      } else if (markupSystem === true || markupSystem === "html") {
        system = "html";
      }

      return system;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: "splitHtmlBlocks",
    value: function splitHtmlBlocks(text) {
      var s = new MarkupAccumulator(text);

      var parseEntities = function parseEntities(ch) {
        if (/&/.test(ch)) {
          var parsed = s.replace(s.text, "&lt;", "<") || s.replace(s.text, "&amp;", "&");

          if (!parsed) {
            s.add("&");
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag("bold", "<b>") || s.parseStartTag("ital", "<i>") || s.parseStartTag("mono", "<code>") || s.parseEndTag("bold", "</b>") || s.parseEndTag("ital", "</i>") || s.parseEndTag("mono", "</code>")) || parseEntities(ch);

        if (!parsed) {
          s.add(ch);
        }

        s.position++;
      }

      s.emitBlock();
      return s.blocks;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: "splitMarkdownBlocks",
    value: function splitMarkdownBlocks(text) {
      var _this2 = this;

      var s = new MarkupAccumulator(text);
      var beginable = true;

      var parseOverride = function parseOverride(ch) {
        if (/\\/.test(ch)) {
          if (s.position < _this2.text.length + 1) {
            s.position++;
            ch = _this2.text.charAt(s.position);

            if (/ \t/.test(ch)) {
              s.spacing = true;
            } else {
              s.add(ch);
              beginable = false;
            }
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag("bold", "*") || s.parseStartTag("ital", "_") || s.parseStartTag("mono", "`")) || s.parseEndTag("bold", "*", "afterBold") || s.parseEndTag("ital", "_", "afterItal") || s.parseEndTag("mono", "`", "afterMono");

        if (!parsed) {
          s.add(ch);
          beginable = false;
        }

        s.position++;
      }

      s.emitBlock();
      return s.blocks;
    }
    /**
     * Explodes a piece of text into single-font blocks using a given markup
     *
     * @param {string} text
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {Array.<{text: string, mod: string}>}
     * @private
     */

  }, {
    key: "splitBlocks",
    value: function splitBlocks(text, markupSystem) {
      var system = this.decodeMarkupSystem(markupSystem);

      if (system === "none") {
        return [{
          text: text,
          mod: "normal"
        }];
      } else if (system === "markdown") {
        return this.splitMarkdownBlocks(text);
      } else if (system === "html") {
        return this.splitHtmlBlocks(text);
      }
    }
    /**
     * @param {string} text
     * @returns {boolean} true if text length over the current max with
     * @private
     */

  }, {
    key: "overMaxWidth",
    value: function overMaxWidth(text) {
      var width = this.ctx.measureText(text).width;
      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
    }
    /**
     * Determine the longest part of the sentence which still fits in the
     * current max width.
     *
     * @param {Array} words  Array of strings signifying a text lines
     * @returns {number}      index of first item in string making string go over max
     * @private
     */

  }, {
    key: "getLongestFit",
    value: function getLongestFit(words) {
      var text = "";
      var w = 0;

      while (w < words.length) {
        var pre = text === "" ? "" : " ";
        var newText = text + pre + words[w];
        if (this.overMaxWidth(newText)) break;
        text = newText;
        w++;
      }

      return w;
    }
    /**
     * Determine the longest part of the string which still fits in the
     * current max width.
     *
     * @param {Array} words Array of strings signifying a text lines
     * @returns {number} index of first item in string making string go over max
     */

  }, {
    key: "getLongestFitWord",
    value: function getLongestFitWord(words) {
      var w = 0;

      while (w < words.length) {
        if (this.overMaxWidth(slice(words).call(words, 0, w))) break;
        w++;
      }

      return w;
    }
    /**
     * Split the passed text into lines, according to width constraint (if any).
     *
     * The method assumes that the input string is a single line, i.e. without lines break.
     *
     * This method retains spaces, if still present (case `font.multi: false`).
     * A space which falls on an internal line break, will be replaced by a newline.
     * There is no special handling of tabs; these go along with the flow.
     *
     * @param {string} str
     * @param {string} [mod='normal']
     * @param {boolean} [appendLast=false]
     * @private
     */

  }, {
    key: "splitStringIntoLines",
    value: function splitStringIntoLines(str) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";
      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // Set the canvas context font, based upon the current selected/hover state
      // and the provided mod, so the text measurement performed by getLongestFit
      // will be accurate - and not just use the font of whoever last used the canvas.
      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod); // Still-present spaces are relevant, retain them

      str = str.replace(/^( +)/g, "$1\r");
      str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
      var words = str.split("\r");

      while (words.length > 0) {
        var w = this.getLongestFit(words);

        if (w === 0) {
          // Special case: the first word is already larger than the max width.
          var word = words[0]; // Break the word to the largest part that fits the line

          var x = this.getLongestFitWord(word);
          this.lines.newLine(slice(word).call(word, 0, x), mod); // Adjust the word, so that the rest will be done next iteration

          words[0] = slice(word).call(word, x);
        } else {
          // skip any space that is replaced by a newline
          var newW = w;

          if (words[w - 1] === " ") {
            w--;
          } else if (words[newW] === " ") {
            newW++;
          }

          var text = slice(words).call(words, 0, w).join("");

          if (w == words.length && appendLast) {
            this.lines.append(text, mod);
          } else {
            this.lines.newLine(text, mod);
          } // Adjust the word, so that the rest will be done next iteration


          words = slice(words).call(words, newW);
        }
      }
    }
  }]);

  return LabelSplitter;
}();

/**
 * List of special styles for multi-fonts
 *
 * @private
 */

var multiFontStyle = ["bold", "ital", "boldital", "mono"];
/**
 * A Label to be used for Nodes or Edges.
 */

var Label = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {object} options
   * @param {boolean} [edgelabel=false]
   */
  function Label(body, options) {
    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, Label);

    this.body = body;
    this.pointToSelf = false;
    this.baseSize = undefined;
    this.fontOptions = {}; // instance variable containing the *instance-local* font options

    this.setOptions(options);
    this.size = {
      top: 0,
      left: 0,
      width: 0,
      height: 0,
      yLine: 0
    };
    this.isEdgeLabel = edgelabel;
  }
  /**
   * @param {object} options the options of the parent Node-instance
   */


  _createClass(Label, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.elementOptions = options; // Reference to the options of the parent Node-instance

      this.initFontOptions(options.font);

      if (isValidLabel(options.label)) {
        this.labelDirty = true;
      } else {
        // Bad label! Change the option value to prevent bad stuff happening
        options.label = undefined;
      }

      if (options.font !== undefined && options.font !== null) {
        // font options can be deleted at various levels
        if (typeof options.font === "string") {
          this.baseSize = this.fontOptions.size;
        } else if (_typeof(options.font) === "object") {
          var size = options.font.size;

          if (size !== undefined) {
            this.baseSize = size;
          }
        }
      }
    }
    /**
     * Init the font Options structure.
     *
     * Member fontOptions serves as an accumulator for the current font options.
     * As such, it needs to be completely separated from the node options.
     *
     * @param {object} newFontOptions the new font options to process
     * @private
     */

  }, {
    key: "initFontOptions",
    value: function initFontOptions(newFontOptions) {
      var _this = this;

      // Prepare the multi-font option objects.
      // These will be filled in propagateFonts(), if required
      forEach$1(multiFontStyle, function (style) {
        _this.fontOptions[style] = {};
      }); // Handle shorthand option, if present

      if (Label.parseFontString(this.fontOptions, newFontOptions)) {
        this.fontOptions.vadjust = 0;
        return;
      } // Copy over the non-multifont options, if specified


      forEach$1(newFontOptions, function (prop, n) {
        if (prop !== undefined && prop !== null && _typeof(prop) !== "object") {
          _this.fontOptions[n] = prop;
        }
      });
    }
    /**
     * If in-variable is a string, parse it as a font specifier.
     *
     * Note that following is not done here and have to be done after the call:
     * - Not all font options are set (vadjust, mod)
     *
     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)
     * @param {object} inOptions  font options to parse
     * @returns {boolean} true if font parsed as string, false otherwise
     * @static
     */

  }, {
    key: "constrain",
    value:
    /**
     * Set the width and height constraints based on 'nearest' value
     *
     * @param {Array} pile array of option objects to consider
     * @returns {object} the actual constraint values to use
     * @private
     */
    function constrain(pile) {
      // NOTE: constrainWidth and  constrainHeight never set!
      // NOTE: for edge labels, only 'maxWdt' set
      // Node labels can set all the fields
      var fontOptions = {
        constrainWidth: false,
        maxWdt: -1,
        minWdt: -1,
        constrainHeight: false,
        minHgt: -1,
        valign: "middle"
      };
      var widthConstraint = topMost(pile, "widthConstraint");

      if (typeof widthConstraint === "number") {
        fontOptions.maxWdt = Number(widthConstraint);
        fontOptions.minWdt = Number(widthConstraint);
      } else if (_typeof(widthConstraint) === "object") {
        var widthConstraintMaximum = topMost(pile, ["widthConstraint", "maximum"]);

        if (typeof widthConstraintMaximum === "number") {
          fontOptions.maxWdt = Number(widthConstraintMaximum);
        }

        var widthConstraintMinimum = topMost(pile, ["widthConstraint", "minimum"]);

        if (typeof widthConstraintMinimum === "number") {
          fontOptions.minWdt = Number(widthConstraintMinimum);
        }
      }

      var heightConstraint = topMost(pile, "heightConstraint");

      if (typeof heightConstraint === "number") {
        fontOptions.minHgt = Number(heightConstraint);
      } else if (_typeof(heightConstraint) === "object") {
        var heightConstraintMinimum = topMost(pile, ["heightConstraint", "minimum"]);

        if (typeof heightConstraintMinimum === "number") {
          fontOptions.minHgt = Number(heightConstraintMinimum);
        }

        var heightConstraintValign = topMost(pile, ["heightConstraint", "valign"]);

        if (typeof heightConstraintValign === "string") {
          if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
            fontOptions.valign = heightConstraintValign;
          }
        }
      }

      return fontOptions;
    }
    /**
     * Set options and update internal state
     *
     * @param {object} options  options to set
     * @param {Array}  pile     array of option objects to consider for option 'chosen'
     */

  }, {
    key: "update",
    value: function update(options, pile) {
      this.setOptions(options, true);
      this.propagateFonts(pile);
      deepExtend(this.fontOptions, this.constrain(pile));
      this.fontOptions.chooser = choosify("label", pile);
    }
    /**
     * When margins are set in an element, adjust sizes is called to remove them
     * from the width/height constraints. This must be done prior to label sizing.
     *
     * @param {{top: number, right: number, bottom: number, left: number}} margins
     */

  }, {
    key: "adjustSizes",
    value: function adjustSizes(margins) {
      var widthBias = margins ? margins.right + margins.left : 0;

      if (this.fontOptions.constrainWidth) {
        this.fontOptions.maxWdt -= widthBias;
        this.fontOptions.minWdt -= widthBias;
      }

      var heightBias = margins ? margins.top + margins.bottom : 0;

      if (this.fontOptions.constrainHeight) {
        this.fontOptions.minHgt -= heightBias;
      }
    } /////////////////////////////////////////////////////////
    // Methods for handling options piles
    // Eventually, these will be moved to a separate class
    /////////////////////////////////////////////////////////

    /**
     * Add the font members of the passed list of option objects to the pile.
     *
     * @param {Pile} dstPile  pile of option objects add to
     * @param {Pile} srcPile  pile of option objects to take font options from
     * @private
     */

  }, {
    key: "addFontOptionsToPile",
    value: function addFontOptionsToPile(dstPile, srcPile) {
      for (var i = 0; i < srcPile.length; ++i) {
        this.addFontToPile(dstPile, srcPile[i]);
      }
    }
    /**
     * Add given font option object to the list of objects (the 'pile') to consider for determining
     * multi-font option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {object} options  instance to add to pile
     * @private
     */

  }, {
    key: "addFontToPile",
    value: function addFontToPile(pile, options) {
      if (options === undefined) return;
      if (options.font === undefined || options.font === null) return;
      var item = options.font;
      pile.push(item);
    }
    /**
     * Collect all own-property values from the font pile that aren't multi-font option objectss.
     *
     * @param {Pile} pile  pile of option objects to use
     * @returns {object} object with all current own basic font properties
     * @private
     */

  }, {
    key: "getBasicOptions",
    value: function getBasicOptions(pile) {
      var ret = {}; // Scans the whole pile to get all options present

      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n]; // Convert shorthand if necessary

        var tmpShorthand = {};

        if (Label.parseFontString(tmpShorthand, fontOptions)) {
          fontOptions = tmpShorthand;
        }

        forEach$1(fontOptions, function (opt, name) {
          if (opt === undefined) return; // multi-font option need not be present

          if (Object.prototype.hasOwnProperty.call(ret, name)) return; // Keep first value we encounter

          if (indexOf(multiFontStyle).call(multiFontStyle, name) !== -1) {
            // Skip multi-font properties but we do need the structure
            ret[name] = {};
          } else {
            ret[name] = opt;
          }
        });
      }

      return ret;
    }
    /**
     * Return the value for given option for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * ---------------------------------------------------------------------
     * ## Traversal of pile for multi-fonts
     *
     * The determination of multi-font option values is a special case, because any values not
     * present in the multi-font options should by definition be taken from the main font options,
     * i.e. from the current 'parent' object of the multi-font option.
     *
     * ### Search order for multi-fonts
     *
     * 'bold' used as example:
     *
     *   - search in option group 'bold' in local properties
     *   - search in main font option group in local properties
     *
     * ---------------------------------------------------------------------
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the multi-font
     * @param {string} option  the option to search for, for the given multi-font
     * @returns {string|number} the value for the given option
     * @private
     */

  }, {
    key: "getFontOption",
    value: function getFontOption(pile, multiName, option) {
      var multiFont; // Search multi font in local properties

      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];

        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {
          multiFont = fontOptions[multiName];
          if (multiFont === undefined || multiFont === null) continue; // Convert shorthand if necessary
          // TODO: inefficient to do this conversion every time; find a better way.

          var tmpShorthand = {};

          if (Label.parseFontString(tmpShorthand, multiFont)) {
            multiFont = tmpShorthand;
          }

          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {
            return multiFont[option];
          }
        }
      } // Option is not mentioned in the multi font options; take it from the parent font options.
      // These have already been converted with getBasicOptions(), so use the converted values.


      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {
        return this.fontOptions[option];
      } // A value **must** be found; you should never get here.


      throw new Error("Did not find value for multi-font for property: '" + option + "'");
    }
    /**
     * Return all options values for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the mod-font
     * @returns {MultiFontOptions}
     * @private
     */

  }, {
    key: "getFontOptions",
    value: function getFontOptions(pile, multiName) {
      var result = {};
      var optionNames = ["color", "size", "face", "mod", "vadjust"]; // List of allowed options per multi-font

      for (var i = 0; i < optionNames.length; ++i) {
        var mod = optionNames[i];
        result[mod] = this.getFontOption(pile, multiName, mod);
      }

      return result;
    } /////////////////////////////////////////////////////////
    // End methods for handling options piles
    /////////////////////////////////////////////////////////

    /**
     * Collapse the font options for the multi-font to single objects, from
     * the chain of option objects passed (the 'pile').
     *
     * @param {Pile} pile  sequence of option objects to consider.
     *                     First item in list assumed to be the newly set options.
     */

  }, {
    key: "propagateFonts",
    value: function propagateFonts(pile) {
      var _this2 = this;

      var fontPile = []; // sequence of font objects to consider, order important
      // Note that this.elementOptions is not used here.

      this.addFontOptionsToPile(fontPile, pile);
      this.fontOptions = this.getBasicOptions(fontPile); // We set multifont values even if multi === false, for consistency (things break otherwise)

      var _loop = function _loop(i) {
        var mod = multiFontStyle[i];
        var modOptions = _this2.fontOptions[mod];

        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod); // Copy over found values


        forEach$1(tmpMultiFontOptions, function (option, n) {
          modOptions[n] = option;
        });
        modOptions.size = Number(modOptions.size);
        modOptions.vadjust = Number(modOptions.vadjust);
      };

      for (var i = 0; i < multiFontStyle.length; ++i) {
        _loop(i);
      }
    }
    /**
     * Main function. This is called from anything that wants to draw a label.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} [baseline='middle']
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover) {
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "middle";
      // if no label, return
      if (this.elementOptions.label === undefined) return; // check if we have to render the label

      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return; // This ensures that there will not be HUGE letters on screen
      // by setting an upper limit on the visible text size (regardless of zoomLevel)

      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
      } // update the size cache if required


      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);

      this._drawBackground(ctx);

      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
    }
    /**
     * Draws the label background
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: "_drawBackground",
    value: function _drawBackground(ctx) {
      if (this.fontOptions.background !== undefined && this.fontOptions.background !== "none") {
        ctx.fillStyle = this.fontOptions.background;
        var size = this.getSize();
        ctx.fillRect(size.left, size.top, size.width, size.height);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} [baseline='middle']
     * @param {number} viewFontSize
     * @private
     */

  }, {
    key: "_drawText",
    value: function _drawText(ctx, x, y) {
      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "middle";
      var viewFontSize = arguments.length > 4 ? arguments[4] : undefined;

      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);

      var _this$_setAlignment2 = _slicedToArray(_this$_setAlignment, 2);

      x = _this$_setAlignment2[0];
      y = _this$_setAlignment2[1];
      ctx.textAlign = "left";
      x = x - this.size.width / 2; // Shift label 1/2-distance to the left

      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
        if (this.fontOptions.valign === "top") {
          y -= (this.size.height - this.size.labelHeight) / 2;
        }

        if (this.fontOptions.valign === "bottom") {
          y += (this.size.height - this.size.labelHeight) / 2;
        }
      } // draw the text


      for (var i = 0; i < this.lineCount; i++) {
        var line = this.lines[i];

        if (line && line.blocks) {
          var width = 0;

          if (this.isEdgeLabel || this.fontOptions.align === "center") {
            width += (this.size.width - line.width) / 2;
          } else if (this.fontOptions.align === "right") {
            width += this.size.width - line.width;
          }

          for (var j = 0; j < line.blocks.length; j++) {
            var block = line.blocks[j];
            ctx.font = block.font;

            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor),
                _this$_getColor2 = _slicedToArray(_this$_getColor, 2),
                fontColor = _this$_getColor2[0],
                strokeColor = _this$_getColor2[1];

            if (block.strokeWidth > 0) {
              ctx.lineWidth = block.strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = "round";
            }

            ctx.fillStyle = fontColor;

            if (block.strokeWidth > 0) {
              ctx.strokeText(block.text, x + width, y + block.vadjust);
            }

            ctx.fillText(block.text, x + width, y + block.vadjust);
            width += block.width;
          }

          y += line.height;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} baseline
     * @returns {Array.<number>}
     * @private
     */

  }, {
    key: "_setAlignment",
    value: function _setAlignment(ctx, x, y, baseline) {
      // check for label alignment (for edges)
      // TODO: make alignment for nodes
      if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
        x = 0;
        y = 0;
        var lineMargin = 2;

        if (this.fontOptions.align === "top") {
          ctx.textBaseline = "alphabetic";
          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
        } else if (this.fontOptions.align === "bottom") {
          ctx.textBaseline = "hanging";
          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
        } else {
          ctx.textBaseline = "middle";
        }
      } else {
        ctx.textBaseline = baseline;
      }

      return [x, y];
    }
    /**
     * fade in when relative scale is between threshold and threshold - 1.
     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
     *
     * @param {string} color  The font color to use
     * @param {number} viewFontSize
     * @param {string} initialStrokeColor
     * @returns {Array.<string>} An array containing the font color and stroke color
     * @private
     */

  }, {
    key: "_getColor",
    value: function _getColor(color, viewFontSize, initialStrokeColor) {
      var fontColor = color || "#000000";
      var strokeColor = initialStrokeColor || "#ffffff";

      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
        fontColor = overrideOpacity(fontColor, opacity);
        strokeColor = overrideOpacity(strokeColor, opacity);
      }

      return [fontColor, strokeColor];
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {{width: number, height: number}}
     */

  }, {
    key: "getTextSize",
    value: function getTextSize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._processLabel(ctx, selected, hover);

      return {
        width: this.size.width,
        height: this.size.height,
        lineCount: this.lineCount
      };
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      var lineMargin = 2;
      var x = this.size.left; // default values which might be overridden below

      var y = this.size.top - 0.5 * lineMargin; // idem

      if (this.isEdgeLabel) {
        var x2 = -this.size.width * 0.5;

        switch (this.fontOptions.align) {
          case "middle":
            x = x2;
            y = -this.size.height * 0.5;
            break;

          case "top":
            x = x2;
            y = -(this.size.height + lineMargin);
            break;

          case "bottom":
            x = x2;
            y = lineMargin;
            break;
        }
      }

      var ret = {
        left: x,
        top: y,
        width: this.size.width,
        height: this.size.height
      };
      return ret;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {'middle'|'hanging'} [baseline='middle']
     */

  }, {
    key: "calculateLabelSize",
    value: function calculateLabelSize(ctx, selected, hover) {
      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "middle";

      this._processLabel(ctx, selected, hover);

      this.size.left = x - this.size.width * 0.5;
      this.size.top = y - this.size.height * 0.5;
      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;

      if (baseline === "hanging") {
        this.size.top += 0.5 * this.fontOptions.size;
        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers

        this.size.yLine += 4; // distance from node
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} mod
     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
     */

  }, {
    key: "getFormattingValues",
    value: function getFormattingValues(ctx, selected, hover, mod) {
      var getValue = function getValue(fontOptions, mod, option) {
        if (mod === "normal") {
          if (option === "mod") return "";
          return fontOptions[option];
        }

        if (fontOptions[mod][option] !== undefined) {
          // Grumbl leaving out test on undefined equals false for ""
          return fontOptions[mod][option];
        } else {
          // Take from parent font option
          return fontOptions[option];
        }
      };

      var values = {
        color: getValue(this.fontOptions, mod, "color"),
        size: getValue(this.fontOptions, mod, "size"),
        face: getValue(this.fontOptions, mod, "face"),
        mod: getValue(this.fontOptions, mod, "mod"),
        vadjust: getValue(this.fontOptions, mod, "vadjust"),
        strokeWidth: this.fontOptions.strokeWidth,
        strokeColor: this.fontOptions.strokeColor
      };

      if (selected || hover) {
        if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
          values.mod = "bold";
        } else {
          if (typeof this.fontOptions.chooser === "function") {
            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);
          }
        }
      }

      var fontString = "";

      if (values.mod !== undefined && values.mod !== "") {
        // safeguard for undefined - this happened
        fontString += values.mod + " ";
      }

      fontString += values.size + "px " + values.face;
      ctx.font = fontString.replace(/"/g, "");
      values.font = ctx.font;
      values.height = values.size;
      return values;
    }
    /**
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     */

  }, {
    key: "differentState",
    value: function differentState(selected, hover) {
      return selected !== this.selectedState || hover !== this.hoverState;
    }
    /**
     * This explodes the passed text into lines and determines the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} inText  the text to explode
     * @returns {{width, height, lines}|*}
     * @private
     */

  }, {
    key: "_processLabelText",
    value: function _processLabelText(ctx, selected, hover, inText) {
      var splitter = new LabelSplitter(ctx, this, selected, hover);
      return splitter.process(inText);
    }
    /**
     * This explodes the label string into lines and sets the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_processLabel",
    value: function _processLabel(ctx, selected, hover) {
      if (this.labelDirty === false && !this.differentState(selected, hover)) return;

      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);

      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
        state.width = this.fontOptions.minWdt;
      }

      this.size.labelHeight = state.height;

      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
        state.height = this.fontOptions.minHgt;
      }

      this.lines = state.lines;
      this.lineCount = state.lines.length;
      this.size.width = state.width;
      this.size.height = state.height;
      this.selectedState = selected;
      this.hoverState = hover;
      this.labelDirty = false;
    }
    /**
     * Check if this label is visible
     *
     * @returns {boolean} true if this label will be show, false otherwise
     */

  }, {
    key: "visible",
    value: function visible() {
      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {
        return false; // nothing to display
      }

      var viewFontSize = this.fontOptions.size * this.body.view.scale;

      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
        return false; // Too small or too far away to show
      }

      return true;
    }
  }], [{
    key: "parseFontString",
    value: function parseFontString(outOptions, inOptions) {
      if (!inOptions || typeof inOptions !== "string") return false;
      var newOptionsArray = inOptions.split(" ");
      outOptions.size = +newOptionsArray[0].replace("px", "");
      outOptions.face = newOptionsArray[1];
      outOptions.color = newOptionsArray[2];
      return true;
    }
  }]);

  return Label;
}();

/**
 * The Base class for all Nodes.
 */
var NodeBase = /*#__PURE__*/function () {
  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function NodeBase(options, body, labelModule) {
    _classCallCheck(this, NodeBase);

    this.body = body;
    this.labelModule = labelModule;
    this.setOptions(options);
    this.top = undefined;
    this.left = undefined;
    this.height = undefined;
    this.width = undefined;
    this.radius = undefined;
    this.margin = undefined;
    this.refreshNeeded = true;
    this.boundingBox = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }
  /**
   *
   * @param {object} options
   */


  _createClass(NodeBase, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     *
     * @param {Label} labelModule
     * @private
     */

  }, {
    key: "_setMargins",
    value: function _setMargins(labelModule) {
      this.margin = {};

      if (this.options.margin) {
        if (_typeof(this.options.margin) == "object") {
          this.margin.top = this.options.margin.top;
          this.margin.right = this.options.margin.right;
          this.margin.bottom = this.options.margin.bottom;
          this.margin.left = this.options.margin.left;
        } else {
          this.margin.top = this.options.margin;
          this.margin.right = this.options.margin;
          this.margin.bottom = this.options.margin;
          this.margin.left = this.options.margin;
        }
      }

      labelModule.adjustSizes(this.margin);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     * @private
     */

  }, {
    key: "_distanceToBorder",
    value: function _distanceToBorder(ctx, angle) {
      var borderWidth = this.options.borderWidth;

      if (ctx) {
        this.resize(ctx);
      }

      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "enableBorderDashes",
    value: function enableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var dashes = values.borderDashes;

          if (dashes === true) {
            dashes = [5, 15];
          }

          ctx.setLineDash(dashes);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "disableBorderDashes",
    value: function disableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([0]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }
    /**
     * Determine if the shape of a node needs to be recalculated.
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     * @protected
     */

  }, {
    key: "needsRefresh",
    value: function needsRefresh(selected, hover) {
      if (this.refreshNeeded === true) {
        // This is probably not the best location to reset this member.
        // However, in the current logic, it is the most convenient one.
        this.refreshNeeded = false;
        return true;
      }

      return this.width === undefined || this.labelModule.differentState(selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "initContextForDraw",
    value: function initContextForDraw(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale;
      ctx.lineWidth = Math.min(this.width, borderWidth);
      ctx.strokeStyle = values.borderColor;
      ctx.fillStyle = values.color;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "performStroke",
    value: function performStroke(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale; //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.

      ctx.save(); // if borders are zero width, they will be drawn with width 1 by default. This prevents that

      if (borderWidth > 0) {
        this.enableBorderDashes(ctx, values); //draw the border

        ctx.stroke(); //disable dashed border for other elements

        this.disableBorderDashes(ctx, values);
      }

      ctx.restore();
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "performFill",
    value: function performFill(ctx, values) {
      ctx.save();
      ctx.fillStyle = values.color; // draw shadow if enabled

      this.enableShadow(ctx, values); // draw the background

      fill(ctx).call(ctx); // disable shadows for other elements.


      this.disableShadow(ctx, values);
      ctx.restore();
      this.performStroke(ctx, values);
    }
    /**
     *
     * @param {number} margin
     * @private
     */

  }, {
    key: "_addBoundingBoxMargin",
    value: function _addBoundingBoxMargin(margin) {
      this.boundingBox.left -= margin;
      this.boundingBox.top -= margin;
      this.boundingBox.bottom += margin;
      this.boundingBox.right += margin;
    }
    /**
     * Actual implementation of this method call.
     *
     * Doing it like this makes it easier to override
     * in the child classes.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_updateBoundingBox",
    value: function _updateBoundingBox(x, y, ctx, selected, hover) {
      if (ctx !== undefined) {
        this.resize(ctx, selected, hover);
      }

      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;
    }
    /**
     * Default implementation of this method call.
     * This acts as a stub which can be overridden.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);
    }
    /**
     * Determine the dimensions to use for nodes with an internal label
     *
     * Currently, these are: Circle, Ellipse, Database, Box
     * The other nodes have external labels, and will not call this method
     *
     * If there is no label, decent default values are supplied.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} [selected]
     * @param {boolean} [hover]
     * @returns {{width:number, height:number}}
     */

  }, {
    key: "getDimensionsFromLabel",
    value: function getDimensionsFromLabel(ctx, selected, hover) {
      // NOTE: previously 'textSize' was not put in 'this' for Ellipse
      // TODO: examine the consequences.
      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
      var width = this.textSize.width;
      var height = this.textSize.height;
      var DEFAULT_SIZE = 14;

      if (width === 0) {
        // This happens when there is no label text set
        width = DEFAULT_SIZE; // use a decent default

        height = DEFAULT_SIZE; // if width zero, then height also always zero
      }

      return {
        width: width,
        height: height
      };
    }
  }]);

  return NodeBase;
}();

function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Box Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Box$1 = /*#__PURE__*/function (_NodeBase) {
  _inherits(Box, _NodeBase);

  var _super = _createSuper$s(Box);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Box(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Box);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Box, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.width = dimensions.width + this.margin.right + this.margin.left;
        this.height = dimensions.height + this.margin.top + this.margin.bottom;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values.borderRadius);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);

      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box

      this._addBoundingBoxMargin(borderRadius);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }

      var borderWidth = this.options.borderWidth;
      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
  }]);

  return Box;
}(NodeBase);

function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * NOTE: This is a bad base class
 *
 * Child classes are:
 *
 *   Image       - uses *only* image methods
 *   Circle      - uses *only* _drawRawCircle
 *   CircleImage - uses all
 *
 * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase
 *       Rename this to ImageBase
 *       Consolidate common code in Image and CircleImage to base class
 *
 * @augments NodeBase
 */

var CircleImageBase = /*#__PURE__*/function (_NodeBase) {
  _inherits(CircleImageBase, _NodeBase);

  var _super = _createSuper$r(CircleImageBase);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function CircleImageBase(options, body, labelModule) {
    var _this;

    _classCallCheck(this, CircleImageBase);

    _this = _super.call(this, options, body, labelModule);
    _this.labelOffset = 0;
    _this.selected = false;
    return _this;
  }
  /**
   *
   * @param {object} options
   * @param {object} [imageObj]
   * @param {object} [imageObjAlt]
   */


  _createClass(CircleImageBase, [{
    key: "setOptions",
    value: function setOptions(options, imageObj, imageObjAlt) {
      this.options = options;

      if (!(imageObj === undefined && imageObjAlt === undefined)) {
        this.setImages(imageObj, imageObjAlt);
      }
    }
    /**
     * Set the images for this node.
     *
     * The images can be updated after the initial setting of options;
     * therefore, this method needs to be reentrant.
     *
     * For correct working in error cases, it is necessary to properly set
     * field 'nodes.brokenImage' in the options.
     *
     * @param {Image} imageObj  required; main image to show for this node
     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
     */

  }, {
    key: "setImages",
    value: function setImages(imageObj, imageObjAlt) {
      if (imageObjAlt && this.selected) {
        this.imageObj = imageObjAlt;
        this.imageObjAlt = imageObj;
      } else {
        this.imageObj = imageObj;
        this.imageObjAlt = imageObjAlt;
      }
    }
    /**
     * Set selection and switch between the base and the selected image.
     *
     * Do the switch only if imageObjAlt exists.
     *
     * @param {boolean} selected value of new selected state for current node
     */

  }, {
    key: "switchImages",
    value: function switchImages(selected) {
      var selection_changed = selected && !this.selected || !selected && this.selected;
      this.selected = selected; // Remember new selection

      if (this.imageObjAlt !== undefined && selection_changed) {
        var imageTmp = this.imageObj;
        this.imageObj = this.imageObjAlt;
        this.imageObjAlt = imageTmp;
      }
    }
    /**
     * Returns Image Padding from node options
     *
     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape
     * @private
     */

  }, {
    key: "_getImagePadding",
    value: function _getImagePadding() {
      var imgPadding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };

      if (this.options.imagePadding) {
        var optImgPadding = this.options.imagePadding;

        if (_typeof(optImgPadding) == "object") {
          imgPadding.top = optImgPadding.top;
          imgPadding.right = optImgPadding.right;
          imgPadding.bottom = optImgPadding.bottom;
          imgPadding.left = optImgPadding.left;
        } else {
          imgPadding.top = optImgPadding;
          imgPadding.right = optImgPadding;
          imgPadding.bottom = optImgPadding;
          imgPadding.left = optImgPadding;
        }
      }

      return imgPadding;
    }
    /**
     * Adjust the node dimensions for a loaded image.
     *
     * Pre: this.imageObj is valid
     */

  }, {
    key: "_resizeImage",
    value: function _resizeImage() {
      var width, height;

      if (this.options.shapeProperties.useImageSize === false) {
        // Use the size property
        var ratio_width = 1;
        var ratio_height = 1; // Only calculate the proper ratio if both width and height not zero

        if (this.imageObj.width && this.imageObj.height) {
          if (this.imageObj.width > this.imageObj.height) {
            ratio_width = this.imageObj.width / this.imageObj.height;
          } else {
            ratio_height = this.imageObj.height / this.imageObj.width;
          }
        }

        width = this.options.size * 2 * ratio_width;
        height = this.options.size * 2 * ratio_height;
      } else {
        // Use the image size with image padding
        var imgPadding = this._getImagePadding();

        width = this.imageObj.width + imgPadding.left + imgPadding.right;
        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;
      }

      this.width = width;
      this.height = height;
      this.radius = 0.5 * this.width;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: "_drawRawCircle",
    value: function _drawRawCircle(ctx, x, y, values) {
      this.initContextForDraw(ctx, values);
      drawCircle(ctx, x, y, values.size);
      this.performFill(ctx, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: "_drawImageAtPosition",
    value: function _drawImageAtPosition(ctx, values) {
      if (this.imageObj.width != 0) {
        // draw the image
        ctx.globalAlpha = values.opacity !== undefined ? values.opacity : 1; // draw shadow if enabled

        this.enableShadow(ctx, values);
        var factor = 1;

        if (this.options.shapeProperties.interpolation === true) {
          factor = this.imageObj.width / this.width / this.body.view.scale;
        }

        var imgPadding = this._getImagePadding();

        var imgPosLeft = this.left + imgPadding.left;
        var imgPosTop = this.top + imgPadding.top;
        var imgWidth = this.width - imgPadding.left - imgPadding.right;
        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;
        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_drawImageLabel",
    value: function _drawImageLabel(ctx, x, y, selected, hover) {
      var offset = 0;

      if (this.height !== undefined) {
        offset = this.height * 0.5;
        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);

        if (labelDimensions.lineCount >= 1) {
          offset += labelDimensions.height / 2;
        }
      }

      var yLabel = y + offset;

      if (this.options.label) {
        this.labelOffset = offset;
      }

      this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
    }
  }]);

  return CircleImageBase;
}(NodeBase);

function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Circle Node/Cluster shape.
 *
 * @augments CircleImageBase
 */

var Circle$1 = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(Circle, _CircleImageBase);

  var _super = _createSuper$q(Circle);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Circle(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Circle);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Circle, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box

        this.width = diameter;
        this.height = diameter;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._drawRawCircle(ctx, x, y, values);

      this.updateBoundingBox(x, y);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.width * 0.5;
    }
  }]);

  return Circle;
}(CircleImageBase);

function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A CircularImage Node/Cluster shape.
 *
 * @augments CircleImageBase
 */

var CircularImage = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(CircularImage, _CircleImageBase);

  var _super = _createSuper$p(CircularImage);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;

    _classCallCheck(this, CircularImage);

    _this = _super.call(this, options, body, labelModule);

    _this.setImages(imageObj, imageObjAlt);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(CircularImage, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var diameter = this.options.size * 2;
        this.width = diameter;
        this.height = diameter;
        this.radius = 0.5 * this.width;
        return;
      } // At this point, an image is present, i.e. this.imageObj is valid.


      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.switchImages(selected);
      this.resize();
      var labelX = x,
          labelY = y;

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      } // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.


      this._drawRawCircle(ctx, labelX, labelY, values); // now we draw in the circle, we save so we can revert the clip operation after drawing.


      ctx.save(); // clip is used to use the stroke in drawRawCircle as an area that we can draw in.

      ctx.clip(); // draw the image

      this._drawImageAtPosition(ctx, values); // restore so we can again draw on the full canvas


      ctx.restore();

      this._drawImageLabel(ctx, labelX, labelY, selected, hover);

      this.updateBoundingBox(x, y);
    } // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here

    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.boundingBox.top = y;
        this.boundingBox.left = x;
        this.boundingBox.right = x + this.options.size * 2;
        this.boundingBox.bottom = y + this.options.size * 2;
      } else {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
      } // TODO: compare with Image.updateBoundingBox(), consolidate?


      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.width * 0.5;
    }
  }]);

  return CircularImage;
}(CircleImageBase);

function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Base class for constructing Node/Cluster Shapes.
 *
 * @augments NodeBase
 */

var ShapeBase = /*#__PURE__*/function (_NodeBase) {
  _inherits(ShapeBase, _NodeBase);

  var _super = _createSuper$o(ShapeBase);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function ShapeBase(options, body, labelModule) {
    _classCallCheck(this, ShapeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   * @param {object} [values={size: this.options.size}]
   */


  _createClass(ShapeBase, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        size: this.options.size
      };

      if (this.needsRefresh(selected, hover)) {
        var _this$customSizeWidth, _this$customSizeHeigh;

        this.labelModule.getTextSize(ctx, selected, hover);
        var size = 2 * values.size;
        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;
        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} shape
     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "_drawShape",
    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {
      var _this = this;

      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      getShape(shape)(ctx, x, y, values.size);
      this.performFill(ctx, values);

      if (this.options.icon !== undefined) {
        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome");
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.options.icon.code, x, y);
        }
      }

      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this.options.label !== undefined) {
            // Need to call following here in order to ensure value for
            // `this.labelModule.size.height`.
            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, "hanging");

            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;

            _this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
          }

          _this.updateBoundingBox(x, y);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
      }
    }
  }]);

  return ShapeBase;
}(NodeBase);

function ownKeys$3(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context = ownKeys$3(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context2 = ownKeys$3(Object(source))).call(_context2, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A CustomShape Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var CustomShape = /*#__PURE__*/function (_ShapeBase) {
  _inherits(CustomShape, _ShapeBase);

  var _super = _createSuper$n(CustomShape);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Function} ctxRenderer
   */
  function CustomShape(options, body, labelModule, ctxRenderer) {
    var _this;

    _classCallCheck(this, CustomShape);

    _this = _super.call(this, options, body, labelModule, ctxRenderer);
    _this.ctxRenderer = ctxRenderer;
    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on different layers.
   */


  _createClass(CustomShape, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2; // Guard right away because someone may just draw in the function itself.

      ctx.save();
      var drawLater = this.ctxRenderer({
        ctx: ctx,
        id: this.options.id,
        x: x,
        y: y,
        state: {
          selected: selected,
          hover: hover
        },
        style: _objectSpread$3({}, values),
        label: this.options.label
      }); // Render the node shape bellow arrows.

      if (drawLater.drawNode != null) {
        drawLater.drawNode();
      }

      ctx.restore();

      if (drawLater.drawExternalLabel) {
        // Guard the external label (above arrows) drawing function.
        var drawExternalLabel = drawLater.drawExternalLabel;

        drawLater.drawExternalLabel = function () {
          ctx.save();
          drawExternalLabel();
          ctx.restore();
        };
      }

      if (drawLater.nodeDimensions) {
        this.customSizeWidth = drawLater.nodeDimensions.width;
        this.customSizeHeight = drawLater.nodeDimensions.height;
      }

      return drawLater;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return CustomShape;
}(ShapeBase);

function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Database Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Database = /*#__PURE__*/function (_NodeBase) {
  _inherits(Database, _NodeBase);

  var _super = _createSuper$m(Database);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Database(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Database);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  _createClass(Database, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var size = dimensions.width + this.margin.right + this.margin.left;
        this.width = size;
        this.height = size;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Database;
}(NodeBase);

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Diamond Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Diamond$1 = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Diamond, _ShapeBase);

  var _super = _createSuper$l(Diamond);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Diamond(options, body, labelModule) {
    _classCallCheck(this, Diamond);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Diamond, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "diamond", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Diamond;
}(ShapeBase);

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Dot Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Dot = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Dot, _ShapeBase);

  var _super = _createSuper$k(Dot);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Dot(options, body, labelModule) {
    _classCallCheck(this, Dot);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Dot, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "circle", 2, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.options.size;
    }
  }]);

  return Dot;
}(ShapeBase);

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Am Ellipse Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Ellipse = /*#__PURE__*/function (_NodeBase) {
  _inherits(Ellipse, _NodeBase);

  var _super = _createSuper$j(Ellipse);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Ellipse(options, body, labelModule) {
    _classCallCheck(this, Ellipse);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Ellipse, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.height = dimensions.height * 2;
        this.width = dimensions.width + dimensions.height;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width * 0.5;
      this.top = y - this.height * 0.5;
      this.initContextForDraw(ctx, values);
      drawEllipse(ctx, this.left, this.top, this.width, this.height);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, x, y, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }

      var a = this.width * 0.5;
      var b = this.height * 0.5;
      var w = Math.sin(angle) * a;
      var h = Math.cos(angle) * b;
      return a * b / Math.sqrt(w * w + h * h);
    }
  }]);

  return Ellipse;
}(NodeBase);

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An icon replacement for the default Node shape.
 *
 * @augments NodeBase
 */

var Icon = /*#__PURE__*/function (_NodeBase) {
  _inherits(Icon, _NodeBase);

  var _super = _createSuper$i(Icon);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Icon(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Icon);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Icon, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.iconSize = {
          width: Number(this.options.icon.size),
          height: Number(this.options.icon.size)
        };
        this.width = this.iconSize.width + this.margin.right + this.margin.left;
        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      var _this2 = this;

      this.resize(ctx, selected, hover);
      this.options.icon.size = this.options.icon.size || 50;
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._icon(ctx, x, y, selected, hover, values);

      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this2.options.label !== undefined) {
            var iconTextSpacing = 5;

            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);
          }

          _this2.updateBoundingBox(x, y);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.icon.size * 0.5;
      this.boundingBox.left = x - this.options.icon.size * 0.5;
      this.boundingBox.right = x + this.options.icon.size * 0.5;
      this.boundingBox.bottom = y + this.options.icon.size * 0.5;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        var iconTextSpacing = 5;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover - Unused
     * @param {ArrowOptions} values
     */

  }, {
    key: "_icon",
    value: function _icon(ctx, x, y, selected, hover, values) {
      var iconSize = Number(this.options.icon.size);

      if (this.options.icon.code !== undefined) {
        ctx.font = [this.options.icon.weight != null ? this.options.icon.weight : selected ? "bold" : "", // If the weight is forced (for example to make Font Awesome 5 work
        // properly) substitute slightly bigger size for bold font face.
        (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + "px", this.options.icon.face].join(" "); // draw icon

        ctx.fillStyle = this.options.icon.color || "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; // draw shadow if enabled

        this.enableShadow(ctx, values);
        ctx.fillText(this.options.icon.code, x, y); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      } else {
        console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Icon;
}(NodeBase);

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An image-based replacement for the default Node shape.
 *
 * @augments CircleImageBase
 */

var Image$2 = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(Image, _CircleImageBase);

  var _super = _createSuper$h(Image);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function Image(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;

    _classCallCheck(this, Image);

    _this = _super.call(this, options, body, labelModule);

    _this.setImages(imageObj, imageObjAlt);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Image, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var side = this.options.size * 2;
        this.width = side;
        this.height = side;
        return;
      }

      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      ctx.save();
      this.switchImages(selected);
      this.resize();
      var labelX = x,
          labelY = y;

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      }

      if (this.options.shapeProperties.useBorderWithImage === true) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);
        ctx.beginPath();
        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        if (values.opacity !== undefined) {
          strokeStyle = overrideOpacity(strokeStyle, values.opacity);
          fillStyle = overrideOpacity(fillStyle, values.opacity);
        } // setup the line properties.


        ctx.strokeStyle = strokeStyle; // set a fillstyle

        ctx.fillStyle = fillStyle; // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image

        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);

        fill(ctx).call(ctx);

        this.performStroke(ctx, values);
        ctx.closePath();
      }

      this._drawImageAtPosition(ctx, values);

      this._drawImageLabel(ctx, labelX, labelY, selected, hover);

      this.updateBoundingBox(x, y);
      ctx.restore();
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.resize();

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      }

      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Image;
}(CircleImageBase);

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Square Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Square = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Square, _ShapeBase);

  var _super = _createSuper$g(Square);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Square(options, body, labelModule) {
    _classCallCheck(this, Square);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Square, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "square", 2, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Square;
}(ShapeBase);

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Hexagon Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Hexagon = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Hexagon, _ShapeBase);

  var _super = _createSuper$f(Hexagon);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Hexagon(options, body, labelModule) {
    _classCallCheck(this, Hexagon);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Hexagon, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "hexagon", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Hexagon;
}(ShapeBase);

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Star Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Star = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Star, _ShapeBase);

  var _super = _createSuper$e(Star);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Star(options, body, labelModule) {
    _classCallCheck(this, Star);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Star, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "star", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Star;
}(ShapeBase);

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A text-based replacement for the default Node shape.
 *
 * @augments NodeBase
 */

var Text = /*#__PURE__*/function (_NodeBase) {
  _inherits(Text, _NodeBase);

  var _super = _createSuper$d(Text);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Text(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Text);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  _createClass(Text, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
        this.width = this.textSize.width + this.margin.right + this.margin.left;
        this.height = this.textSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2; // draw shadow if enabled

      this.enableShadow(ctx, values);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover); // disable shadows for other elements.

      this.disableShadow(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Text;
}(NodeBase);

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Triangle$1 = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Triangle, _ShapeBase);

  var _super = _createSuper$c(Triangle);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Triangle(options, body, labelModule) {
    _classCallCheck(this, Triangle);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Triangle, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "triangle", 3, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Triangle;
}(ShapeBase);

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A downward facing Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var TriangleDown = /*#__PURE__*/function (_ShapeBase) {
  _inherits(TriangleDown, _ShapeBase);

  var _super = _createSuper$b(TriangleDown);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function TriangleDown(options, body, labelModule) {
    _classCallCheck(this, TriangleDown);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(TriangleDown, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "triangleDown", 3, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return TriangleDown;
}(ShapeBase);

function ownKeys$2(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context5, _context6; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context5 = ownKeys$2(Object(source), !0)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context6 = ownKeys$2(Object(source))).call(_context6, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }
/**
 * A node. A node can be connected to other nodes via one or multiple edges.
 */

var Node = /*#__PURE__*/function () {
  /**
   *
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape
   *                              {string} image  An image url
   *                              {string} title  A title text, can be HTML
   *                              {anytype} group A group name or number
   * @param {object} body               Shared state of current network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image
   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options
   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance
   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype
   *                                    for parameter `globalOptions`.
   */
  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    _classCallCheck(this, Node);

    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;
    this.edges = []; // all edges connected to this node
    // set defaults for the options

    this.id = undefined;
    this.imagelist = imagelist;
    this.grouplist = grouplist; // state options

    this.x = undefined;
    this.y = undefined;
    this.baseSize = this.options.size;
    this.baseFontSize = this.options.font.size;
    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate

    this.selected = false;
    this.hover = false;
    this.labelModule = new Label(this.body, this.options, false
    /* Not edge label */
    );
    this.setOptions(options);
  }
  /**
   * Attach a edge to the node
   *
   * @param {Edge} edge
   */


  _createClass(Node, [{
    key: "attachEdge",
    value: function attachEdge(edge) {
      var _context;

      if (indexOf(_context = this.edges).call(_context, edge) === -1) {
        this.edges.push(edge);
      }
    }
    /**
     * Detach a edge from the node
     *
     * @param {Edge} edge
     */

  }, {
    key: "detachEdge",
    value: function detachEdge(edge) {
      var _context2;

      var index = indexOf(_context2 = this.edges).call(_context2, edge);

      if (index != -1) {
        var _context3;

        splice$1(_context3 = this.edges).call(_context3, index, 1);
      }
    }
    /**
     * Set or overwrite options for the node
     *
     * @param {object} options an object with options
     * @returns {null|boolean}
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var currentShape = this.options.shape;

      if (!options) {
        return; // Note that the return value will be 'undefined'! This is OK.
      } // Save the color for later.
      // This is necessary in order to prevent local color from being overwritten by group color.
      // TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.
      // This is not the only problem with current options handling.


      if (typeof options.color !== "undefined") {
        this._localColor = options.color;
      } // basic options


      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (this.id === undefined) {
        throw new Error("Node must have an id");
      }

      Node.checkMass(options, this.id); // set these options locally
      // clear x and y positions

      if (options.x !== undefined) {
        if (options.x === null) {
          this.x = undefined;
          this.predefinedPosition = false;
        } else {
          this.x = _parseInt(options.x);
          this.predefinedPosition = true;
        }
      }

      if (options.y !== undefined) {
        if (options.y === null) {
          this.y = undefined;
          this.predefinedPosition = false;
        } else {
          this.y = _parseInt(options.y);
          this.predefinedPosition = true;
        }
      }

      if (options.size !== undefined) {
        this.baseSize = options.size;
      }

      if (options.value !== undefined) {
        options.value = _parseFloat(options.value);
      } // this transforms all shorthands into fully defined options


      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);
      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("node", pile);

      this._load_images();

      this.updateLabelModule(options); // Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity

      if (options.opacity !== undefined && Node.checkOpacity(options.opacity)) {
        this.options.opacity = options.opacity;
      }

      this.updateShape(currentShape);
      return options.hidden !== undefined || options.physics !== undefined;
    }
    /**
     * Load the images from the options, for the nodes that need them.
     *
     * Images are always loaded, even if they are not used in the current shape.
     * The user may switch to an image shape later on.
     *
     * @private
     */

  }, {
    key: "_load_images",
    value: function _load_images() {
      if (this.options.shape === "circularImage" || this.options.shape === "image") {
        if (this.options.image === undefined) {
          throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
        }
      }

      if (this.options.image === undefined) {
        return;
      }

      if (this.imagelist === undefined) {
        throw new Error("Internal Error: No images provided");
      }

      if (typeof this.options.image === "string") {
        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
      } else {
        if (this.options.image.unselected === undefined) {
          throw new Error("No unselected image provided");
        }

        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);

        if (this.options.image.selected !== undefined) {
          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
        } else {
          this.imageObjAlt = undefined;
        }
      }
    }
    /**
     * Check that opacity is only between 0 and 1
     *
     * @param {number} opacity
     * @returns {boolean}
     */

  }, {
    key: "getFormattingValues",
    value:
    /**
     *
     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
     */
    function getFormattingValues() {
      var values = {
        color: this.options.color.background,
        opacity: this.options.opacity,
        borderWidth: this.options.borderWidth,
        borderColor: this.options.color.border,
        size: this.options.size,
        borderDashes: this.options.shapeProperties.borderDashes,
        borderRadius: this.options.shapeProperties.borderRadius,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y
      };

      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            if (this.options.borderWidthSelected != null) {
              values.borderWidth = this.options.borderWidthSelected;
            } else {
              values.borderWidth *= 2;
            }

            values.color = this.options.color.highlight.background;
            values.borderColor = this.options.color.highlight.border;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            values.color = this.options.color.hover.background;
            values.borderColor = this.options.color.hover.border;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === "function") {
          this.chooser(values, this.options.id, this.selected, this.hover);

          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
      }

      if (this.options.opacity !== undefined) {
        var opacity = this.options.opacity;
        values.borderColor = overrideOpacity(values.borderColor, opacity);
        values.color = overrideOpacity(values.color, opacity);
        values.shadowColor = overrideOpacity(values.shadowColor, opacity);
      }

      return values;
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      if (this.options.label === undefined || this.options.label === null) {
        this.options.label = "";
      }

      Node.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options), {}, {
        color: options && options.color || this._localColor || undefined
      }), this.grouplist); //
      // Note:The prototype chain for this.options is:
      //
      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions
      //                 (also: this.globalOptions)
      //
      // Note that the prototypes are mentioned explicitly in the pile list below;
      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.
      // This is a good indication that the prototype usage of options is deficient.
      //

      var currentGroup = this.grouplist.get(this.options.group, false);
      var pile = [options, // new options
      this.options, // current node options, see comment above for prototype
      currentGroup, // group options, if any
      this.globalOptions, // Currently set global node options
      this.defaultOptions // Default global node options
      ];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     *
     * @param {string} currentShape
     */

  }, {
    key: "updateShape",
    value: function updateShape(currentShape) {
      if (currentShape === this.options.shape && this.shape) {
        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
      } else {
        // choose draw method depending on the shape
        switch (this.options.shape) {
          case "box":
            this.shape = new Box$1(this.options, this.body, this.labelModule);
            break;

          case "circle":
            this.shape = new Circle$1(this.options, this.body, this.labelModule);
            break;

          case "circularImage":
            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;

          case "custom":
            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);
            break;

          case "database":
            this.shape = new Database(this.options, this.body, this.labelModule);
            break;

          case "diamond":
            this.shape = new Diamond$1(this.options, this.body, this.labelModule);
            break;

          case "dot":
            this.shape = new Dot(this.options, this.body, this.labelModule);
            break;

          case "ellipse":
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;

          case "icon":
            this.shape = new Icon(this.options, this.body, this.labelModule);
            break;

          case "image":
            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;

          case "square":
            this.shape = new Square(this.options, this.body, this.labelModule);
            break;

          case "hexagon":
            this.shape = new Hexagon(this.options, this.body, this.labelModule);
            break;

          case "star":
            this.shape = new Star(this.options, this.body, this.labelModule);
            break;

          case "text":
            this.shape = new Text(this.options, this.body, this.labelModule);
            break;

          case "triangle":
            this.shape = new Triangle$1(this.options, this.body, this.labelModule);
            break;

          case "triangleDown":
            this.shape = new TriangleDown(this.options, this.body, this.labelModule);
            break;

          default:
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
        }
      }

      this.needsRefresh();
    }
    /**
     * select this node
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
      this.needsRefresh();
    }
    /**
     * unselect this node
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
      this.needsRefresh();
    }
    /**
     * Reset the calculated size of the node, forces it to recalculate its size
     */

  }, {
    key: "needsRefresh",
    value: function needsRefresh() {
      this.shape.refreshNeeded = true;
    }
    /**
     * get the title of this node.
     *
     * @returns {string} title    The title of the node, or undefined when no title
     *                           has been set.
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.options.title;
    }
    /**
     * Calculate the distance to the border of the Node
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {number} angle        Angle in radians
     * @returns {number} distance   Distance to the border in pixels
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this.shape.distanceToBorder(ctx, angle);
    }
    /**
     * Check if this node has a fixed x and y position
     *
     * @returns {boolean}      true if fixed, false if not
     */

  }, {
    key: "isFixed",
    value: function isFixed() {
      return this.options.fixed.x && this.options.fixed.y;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the node. Can be undefined
     *
     * @returns {number} value
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */

  }, {
    key: "getLabelSize",
    value: function getLabelSize() {
      return this.labelModule.size();
    }
    /**
     * Adjust the value range of the node. The node will adjust it's size
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var sizeDiff = this.options.scaling.max - this.options.scaling.min;

        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }

        this.options.size = this.options.scaling.min + scale * sizeDiff;
      } else {
        this.options.size = this.baseSize;
        this.options.font.size = this.baseFontSize;
      }

      this.updateLabelModule();
    }
    /**
     * Draw this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var values = this.getFormattingValues();
      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values) || {};
    }
    /**
     * Update the bounding box of the shape
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(ctx) {
      this.shape.updateBoundingBox(this.x, this.y, ctx);
    }
    /**
     * Recalculate the size of this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "resize",
    value: function resize(ctx) {
      var values = this.getFormattingValues();
      this.shape.resize(ctx, this.selected, this.hover, values);
    }
    /**
     * Determine all visual elements of this node instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        if (pointInRect(this.labelModule.getSize(), point)) {
          ret.push({
            nodeId: this.id,
            labelId: 0
          });
        }
      }

      if (pointInRect(this.shape.boundingBox, point)) {
        ret.push({
          nodeId: this.id
        });
      }

      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */

  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */

  }, {
    key: "isBoundingBoxOverlappingWith",
    value: function isBoundingBoxOverlappingWith(obj) {
      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
    }
    /**
     * Check valid values for mass
     *
     * The mass may not be negative or zero. If it is, reset to 1
     *
     * @param {object} options
     * @param {Node.id} id
     * @static
     */

  }], [{
    key: "checkOpacity",
    value: function checkOpacity(opacity) {
      return 0 <= opacity && opacity <= 1;
    }
    /**
     * Check that origin is 'center' or 'top-left'
     *
     * @param {string} origin
     * @returns {boolean}
     */

  }, {
    key: "checkCoordinateOrigin",
    value: function checkCoordinateOrigin(origin) {
      return origin === undefined || origin === "center" || origin === "top-left";
    }
    /**
     * Copy group option values into the node options.
     *
     * The group options override the global node options, so the copy of group options
     *  must happen *after* the global node options have been set.
     *
     * This method must also be called also if the global node options have changed and the group options did not.
     *
     * @param {object} parentOptions
     * @param {object} newOptions  new values for the options, currently only passed in for check
     * @param {object} groupList
     */

  }, {
    key: "updateGroupOptions",
    value: function updateGroupOptions(parentOptions, newOptions, groupList) {
      var _context4;

      if (groupList === undefined) return; // No groups, nothing to do

      var group = parentOptions.group; // paranoia: the selected group is already merged into node options, check.

      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {
        throw new Error("updateGroupOptions: group values in options don't match.");
      }

      var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
      if (!hasGroup) return; // current node has no group, no need to merge

      var groupObj = groupList.get(group);

      if (groupObj.opacity !== undefined && newOptions.opacity === undefined) {
        if (!Node.checkOpacity(groupObj.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + groupObj.opacity);
          groupObj.opacity = undefined;
        }
      } // Skip any new option to avoid them being overridden by the group options.


      var skipProperties = filter(_context4 = getOwnPropertyNames(newOptions)).call(_context4, function (p) {
        return newOptions[p] != null;
      }); // Always skip merging group font options into parent; these are required to be distinct for labels


      skipProperties.push("font");
      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj); // the color object needs to be completely defined.
      // Since groups can partially overwrite the colors, we parse it again, just in case.

      parentOptions.color = parseColor(parentOptions.color);
    }
    /**
     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
     * Static so it can also be used by the handler.
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {object} [groupList]
     * @static
     */

  }, {
    key: "parseOptions",
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var groupList = arguments.length > 4 ? arguments[4] : undefined;
      var fields = ["color", "fixed", "shadow"];
      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
      Node.checkMass(newOptions);

      if (parentOptions.opacity !== undefined) {
        if (!Node.checkOpacity(parentOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + parentOptions.opacity);
          parentOptions.opacity = undefined;
        }
      }

      if (newOptions.opacity !== undefined) {
        if (!Node.checkOpacity(newOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + newOptions.opacity);
          newOptions.opacity = undefined;
        }
      }

      if (newOptions.shapeProperties && !Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {
        console.error("Invalid option for node coordinateOrigin, found: " + newOptions.shapeProperties.coordinateOrigin);
      } // merge the shadow options into the parent.


      mergeOptions(parentOptions, newOptions, "shadow", globalOptions); // individual shape newOptions

      if (newOptions.color !== undefined && newOptions.color !== null) {
        var parsedColor = parseColor(newOptions.color);
        fillIfDefined(parentOptions.color, parsedColor);
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options
      } // handle the fixed options


      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
        if (typeof newOptions.fixed === "boolean") {
          parentOptions.fixed.x = newOptions.fixed;
          parentOptions.fixed.y = newOptions.fixed;
        } else {
          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === "boolean") {
            parentOptions.fixed.x = newOptions.fixed.x;
          }

          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === "boolean") {
            parentOptions.fixed.y = newOptions.fixed.y;
          }
        }
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options
      }

      Node.updateGroupOptions(parentOptions, newOptions, groupList); // handle the scaling options, specifically the label part

      if (newOptions.scaling !== undefined) {
        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      }
    }
  }, {
    key: "checkMass",
    value: function checkMass(options, id) {
      if (options.mass !== undefined && options.mass <= 0) {
        var strId = "";

        if (id !== undefined) {
          strId = " in node id: " + id;
        }

        console.error("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", VALIDATOR_PRINT_STYLE);
        options.mass = 1;
      }
    }
  }]);

  return Node;
}();

function _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$6(o, minLen) { var _context4; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = slice(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Handler for Nodes
 */

var NodesHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Images} images
   * @param {Array.<Group>} groups
   * @param {LayoutEngine} layoutEngine
   */
  function NodesHandler(body, images, groups, layoutEngine) {
    var _context,
        _this = this;

    _classCallCheck(this, NodesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups;
    this.layoutEngine = layoutEngine; // create the node API in the body container

    this.body.functions.createNode = bind$6(_context = this.create).call(_context, this);
    this.nodesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items, params.data, params.oldData);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };
    this.defaultOptions = {
      borderWidth: 1,
      borderWidthSelected: undefined,
      brokenImage: undefined,
      color: {
        border: "#2B7CE9",
        background: "#97C2FC",
        highlight: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        },
        hover: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        }
      },
      opacity: undefined,
      // number between 0 and 1
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 0,
        // px
        strokeColor: "#ffffff",
        align: "center",
        vadjust: 0,
        multi: false,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "monospace",
          vadjust: 2
        }
      },
      group: undefined,
      hidden: false,
      icon: {
        face: "FontAwesome",
        //'FontAwesome',
        code: undefined,
        //'\uf007',
        size: 50,
        //50,
        color: "#2B7CE9" //'#aa00ff'

      },
      image: undefined,
      // --> URL
      imagePadding: {
        // only for image shape
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      label: undefined,
      labelHighlightBold: true,
      level: undefined,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      mass: 1,
      physics: true,
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: false,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      shape: "ellipse",
      shapeProperties: {
        borderDashes: false,
        // only for borders
        borderRadius: 6,
        // only for box shape
        interpolation: true,
        // only for image and circularImage shapes
        useImageSize: false,
        // only for image and circularImage shapes
        useBorderWithImage: false,
        // only for image shape
        coordinateOrigin: "center" // only for image and circularImage shapes

      },
      size: 25,
      title: undefined,
      value: undefined,
      x: undefined,
      y: undefined
    }; // Protect from idiocy

    if (this.defaultOptions.mass <= 0) {
      throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
    }

    this.options = bridgeObject(this.defaultOptions);
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(NodesHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _context2,
          _context3,
          _this2 = this;

      // refresh the nodes. Used when reverting from hierarchical layout
      this.body.emitter.on("refreshNodes", bind$6(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", bind$6(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function () {
        forEach$1(_this2.nodesListeners, function (callback, event) {
          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
        });
        delete _this2.body.functions.createNode;
        delete _this2.nodesListeners.add;
        delete _this2.nodesListeners.update;
        delete _this2.nodesListeners.remove;
        delete _this2.nodesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        Node.parseOptions(this.options, options); // Need to set opacity here because Node.parseOptions is also used for groups,
        // if you set opacity in Node.parseOptions it overwrites group opacity.

        if (options.opacity !== undefined) {
          if (isNan(options.opacity) || !_isFinite(options.opacity) || options.opacity < 0 || options.opacity > 1) {
            console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + options.opacity);
          } else {
            this.options.opacity = options.opacity;
          }
        } // update the shape in all nodes


        if (options.shape !== undefined) {
          for (var nodeId in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
              this.body.nodes[nodeId].updateShape();
            }
          }
        } // Update the labels of nodes if any relevant options changed.


        if (typeof options.font !== "undefined" || typeof options.widthConstraint !== "undefined" || typeof options.heightConstraint !== "undefined") {
          for (var _i = 0, _Object$keys = keys$4(this.body.nodes); _i < _Object$keys.length; _i++) {
            var _nodeId = _Object$keys[_i];

            this.body.nodes[_nodeId].updateLabelModule();

            this.body.nodes[_nodeId].needsRefresh();
          }
        } // update the shape size in all nodes


        if (options.size !== undefined) {
          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.body.nodes[_nodeId2].needsRefresh();
            }
          }
        } // update the state of the variables if needed


        if (options.hidden !== undefined || options.physics !== undefined) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Set a data set with nodes for the network
     *
     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */

  }, {
    key: "setData",
    value: function setData(nodes) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var oldNodesData = this.body.data.nodes;

      if (isDataViewLike("id", nodes)) {
        this.body.data.nodes = nodes;
      } else if (isArray$2(nodes)) {
        this.body.data.nodes = new DataSet();
        this.body.data.nodes.add(nodes);
      } else if (!nodes) {
        this.body.data.nodes = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      }

      if (oldNodesData) {
        // unsubscribe from old dataset
        forEach$1(this.nodesListeners, function (callback, event) {
          oldNodesData.off(event, callback);
        });
      } // remove drawn nodes


      this.body.nodes = {};

      if (this.body.data.nodes) {
        // subscribe to new dataset
        var me = this;
        forEach$1(this.nodesListeners, function (callback, event) {
          me.body.data.nodes.on(event, callback);
        }); // draw all new nodes

        var ids = this.body.data.nodes.getIds();
        this.add(ids, true);
      }

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add nodes
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: "add",
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var id;
      var newNodes = [];

      for (var i = 0; i < ids.length; i++) {
        id = ids[i];
        var properties = this.body.data.nodes.get(id);
        var node = this.create(properties);
        newNodes.push(node);
        this.body.nodes[id] = node; // note: this may replace an existing node
      }

      this.layoutEngine.positionInitially(newNodes);

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing nodes, or create them when not yet existing
     *
     * @param {number[] | string[]} ids id's of changed nodes
     * @param {Array} changedData array with changed data
     * @param {Array|undefined} oldData optional; array with previous data
     * @private
     */

  }, {
    key: "update",
    value: function update(ids, changedData, oldData) {
      var nodes = this.body.nodes;
      var dataChanged = false;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var node = nodes[id];
        var data = changedData[i];

        if (node !== undefined) {
          // update node
          if (node.setOptions(data)) {
            dataChanged = true;
          }
        } else {
          dataChanged = true; // create node

          node = this.create(data);
          nodes[id] = node;
        }
      }

      if (!dataChanged && oldData !== undefined) {
        // Check for any changes which should trigger a layout recalculation
        // For now, this is just 'level' for hierarchical layout
        // Assumption: old and new data arranged in same order; at time of writing, this holds.
        dataChanged = some(changedData).call(changedData, function (newValue, index) {
          var oldValue = oldData[index];
          return oldValue && oldValue.level !== newValue.level;
        });
      }

      if (dataChanged === true) {
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing nodes. If nodes do not exist, the method will just ignore it.
     *
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: "remove",
    value: function remove(ids) {
      var nodes = this.body.nodes;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        delete nodes[id];
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * create a node
     *
     * @param {object} properties
     * @param {class} [constructorClass=Node.default]
     * @returns {*}
     */

  }, {
    key: "create",
    value: function create(properties) {
      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;
      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
    }
    /**
     *
     * @param {boolean} [clearPositions=false]
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;

      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      forEach$1(this.body.nodes, function (node, nodeId) {
        var data = _this3.body.data.nodes.get(nodeId);

        if (data !== undefined) {
          if (clearPositions === true) {
            node.setOptions({
              x: null,
              y: null
            });
          }

          node.setOptions({
            fixed: false
          });
          node.setOptions(data);
        }
      });
    }
    /**
     * Returns the positions of the nodes.
     *
     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */

  }, {
    key: "getPositions",
    value: function getPositions(ids) {
      var dataArray = {};

      if (ids !== undefined) {
        if (isArray$2(ids) === true) {
          for (var i = 0; i < ids.length; i++) {
            if (this.body.nodes[ids[i]] !== undefined) {
              var node = this.body.nodes[ids[i]];
              dataArray[ids[i]] = {
                x: Math.round(node.x),
                y: Math.round(node.y)
              };
            }
          }
        } else {
          if (this.body.nodes[ids] !== undefined) {
            var _node = this.body.nodes[ids];
            dataArray[ids] = {
              x: Math.round(_node.x),
              y: Math.round(_node.y)
            };
          }
        }
      } else {
        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {
          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];
          dataArray[this.body.nodeIndices[_i2]] = {
            x: Math.round(_node2.x),
            y: Math.round(_node2.y)
          };
        }
      }

      return dataArray;
    }
    /**
     * Retrieves the x y position of a specific id.
     *
     * @param {string} id The id to retrieve.
     * @throws {TypeError} If no id is included.
     * @throws {ReferenceError} If an invalid id is provided.
     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.
     */

  }, {
    key: "getPosition",
    value: function getPosition(id) {
      if (id == undefined) {
        throw new TypeError("No id was specified for getPosition method.");
      } else if (this.body.nodes[id] == undefined) {
        throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(id));
      } else {
        return {
          x: Math.round(this.body.nodes[id].x),
          y: Math.round(this.body.nodes[id].y)
        };
      }
    }
    /**
     * Load the XY positions of the nodes into the dataset.
     */

  }, {
    key: "storePositions",
    value: function storePositions() {
      // todo: add support for clusters and hierarchical.
      var dataArray = [];
      var dataset = this.body.data.nodes.getDataSet();

      var _iterator = _createForOfIteratorHelper$6(dataset.get()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dsNode = _step.value;
          var id = dsNode.id;
          var bodyNode = this.body.nodes[id];
          var x = Math.round(bodyNode.x);
          var y = Math.round(bodyNode.y);

          if (dsNode.x !== x || dsNode.y !== y) {
            dataArray.push({
              id: id,
              x: x,
              y: y
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      dataset.update(dataArray);
    }
    /**
     * get the bounding box of a node.
     *
     * @param {Node.id} nodeId
     * @returns {j|*}
     */

  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].shape.boundingBox;
      }
    }
    /**
     * Get the Ids of nodes connected to this node.
     *
     * @param {Node.id} nodeId
     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
     *                                          Any other value returns both parent and child nodes.
     * @returns {Array}
     */

  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(nodeId, direction) {
      var nodeList = [];

      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];
        var nodeObj = {}; // used to quickly check if node already exists

        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];

          if (direction !== "to" && edge.toId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.fromId] === undefined) {
              nodeList.push(edge.fromId);
              nodeObj[edge.fromId] = true;
            }
          } else if (direction !== "from" && edge.fromId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.toId] === undefined) {
              nodeList.push(edge.toId);
              nodeObj[edge.toId] = true;
            }
          }
        }
      }

      return nodeList;
    }
    /**
     * Get the ids of the edges connected to this node.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: "getConnectedEdges",
    value: function getConnectedEdges(nodeId) {
      var edgeList = [];

      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];

        for (var i = 0; i < node.edges.length; i++) {
          edgeList.push(node.edges[i].id);
        }
      } else {
        console.error("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
      }

      return edgeList;
    }
    /**
     * Move a node.
     *
     * @param {Node.id} nodeId
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "moveNode",
    value: function moveNode(nodeId, x, y) {
      var _this4 = this;

      if (this.body.nodes[nodeId] !== undefined) {
        this.body.nodes[nodeId].x = Number(x);
        this.body.nodes[nodeId].y = Number(y);

        setTimeout$1(function () {
          _this4.body.emitter.emit("startSimulation");
        }, 0);
      } else {
        console.error("Node id supplied to moveNode does not exist. Provided: ", nodeId);
      }
    }
  }]);

  return NodesHandler;
}();

var hasOwn$1 = hasOwnProperty_1;

var isDataDescriptor$1 = function (descriptor) {
  return descriptor !== undefined && (hasOwn$1(descriptor, 'value') || hasOwn$1(descriptor, 'writable'));
};

var $$2 = _export;
var call = functionCall;
var isObject$2 = isObject$j;
var anObject$1 = anObject$d;
var isDataDescriptor = isDataDescriptor$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var getPrototypeOf = objectGetPrototypeOf; // `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get

function get$5(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject$1(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
  if (isObject$2(prototype = getPrototypeOf(target))) return get$5(prototype, propertyKey, receiver);
}

$$2({
  target: 'Reflect',
  stat: true
}, {
  get: get$5
});

var path$3 = path$y;
var get$4 = path$3.Reflect.get;

var parent$7 = get$4;
var get$3 = parent$7;

var parent$6 = get$3;
var get$2 = parent$6;

var parent$5 = get$2;
var get$1 = parent$5;

var get = get$1;

var parent$4 = getOwnPropertyDescriptor$4;
var getOwnPropertyDescriptor$2 = parent$4;

var parent$3 = getOwnPropertyDescriptor$2;
var getOwnPropertyDescriptor$1 = parent$3;

var getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && get) {
    _get = get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;

      var desc = getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

var $$1 = _export; // eslint-disable-next-line es/no-math-hypot -- required for testing

var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt; // Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546

var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot

$$1({
  target: 'Math',
  stat: true,
  forced: BUGGY
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});

var path$2 = path$y;
var hypot$2 = path$2.Math.hypot;

var parent$2 = hypot$2;
var hypot$1 = parent$2;

var hypot = hypot$1;

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Common methods for endpoints
 *
 * @class
 */

var EndPoint = /*#__PURE__*/function () {
  function EndPoint() {
    _classCallCheck(this, EndPoint);
  }

  _createClass(EndPoint, null, [{
    key: "transform",
    value:
    /**
     * Apply transformation on points for display.
     *
     * The following is done:
     * - rotate by the specified angle
     * - multiply the (normalized) coordinates by the passed length
     * - offset by the target coordinates
     *
     * @param points - The point(s) to be transformed.
     * @param arrowData - The data determining the result of the transformation.
     */
    function transform(points, arrowData) {
      if (!isArray$2(points)) {
        points = [points];
      }

      var x = arrowData.point.x;
      var y = arrowData.point.y;
      var angle = arrowData.angle;
      var length = arrowData.length;

      for (var i = 0; i < points.length; ++i) {
        var p = points[i];
        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);
        p.x = x + length * xt;
        p.y = y + length * yt;
      }
    }
    /**
     * Draw a closed path using the given real coordinates.
     *
     * @param ctx - The path will be rendered into this context.
     * @param points - The points of the path.
     */

  }, {
    key: "drawPath",
    value: function drawPath(ctx, points) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);

      for (var i = 1; i < points.length; ++i) {
        ctx.lineTo(points[i].x, points[i].y);
      }

      ctx.closePath();
    }
  }]);

  return EndPoint;
}();
/**
 * Drawing methods for the arrow endpoint.
 */


var Image$1 = /*#__PURE__*/function (_EndPoint) {
  _inherits(Image, _EndPoint);

  var _super = _createSuper$a(Image);

  function Image() {
    _classCallCheck(this, Image);

    return _super.apply(this, arguments);
  }

  _createClass(Image, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns False as there is no way to fill an image.
     */
    function draw(ctx, arrowData) {
      if (arrowData.image) {
        ctx.save();
        ctx.translate(arrowData.point.x, arrowData.point.y);
        ctx.rotate(Math.PI / 2 + arrowData.angle);
        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;
        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;
        arrowData.image.drawImageAtPosition(ctx, 1, // scale
        -width / 2, // x
        0, // y
        width, height);
        ctx.restore();
      }

      return false;
    }
  }]);

  return Image;
}(EndPoint);
/**
 * Drawing methods for the arrow endpoint.
 */


var Arrow = /*#__PURE__*/function (_EndPoint2) {
  _inherits(Arrow, _EndPoint2);

  var _super2 = _createSuper$a(Arrow);

  function Arrow() {
    _classCallCheck(this, Arrow);

    return _super2.apply(this, arguments);
  }

  _createClass(Arrow, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0,
        y: 0
      }, {
        x: -1,
        y: 0.3
      }, {
        x: -0.9,
        y: 0
      }, {
        x: -1,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Arrow;
}(EndPoint);
/**
 * Drawing methods for the crow endpoint.
 */


var Crow = /*#__PURE__*/function () {
  function Crow() {
    _classCallCheck(this, Crow);
  }

  _createClass(Crow, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: -1,
        y: 0
      }, {
        x: 0,
        y: 0.3
      }, {
        x: -0.4,
        y: 0
      }, {
        x: 0,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Crow;
}();
/**
 * Drawing methods for the curve endpoint.
 */


var Curve = /*#__PURE__*/function () {
  function Curve() {
    _classCallCheck(this, Curve);
  }

  _createClass(Curve, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = {
        x: -0.4,
        y: 0
      };
      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.

      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Define curve endpoint as semicircle.

      var pi = Math.PI;
      var startAngle = arrowData.angle - pi / 2;
      var endAngle = arrowData.angle + pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
      ctx.stroke();
      return true;
    }
  }]);

  return Curve;
}();
/**
 * Drawing methods for the inverted curve endpoint.
 */


var InvertedCurve = /*#__PURE__*/function () {
  function InvertedCurve() {
    _classCallCheck(this, InvertedCurve);
  }

  _createClass(InvertedCurve, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = {
        x: -0.3,
        y: 0
      };
      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.

      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Define inverted curve endpoint as semicircle.

      var pi = Math.PI;
      var startAngle = arrowData.angle + pi / 2;
      var endAngle = arrowData.angle + 3 * pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
      ctx.stroke();
      return true;
    }
  }]);

  return InvertedCurve;
}();
/**
 * Drawing methods for the trinagle endpoint.
 */


var Triangle = /*#__PURE__*/function () {
  function Triangle() {
    _classCallCheck(this, Triangle);
  }

  _createClass(Triangle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0.02,
        y: 0
      }, {
        x: -1,
        y: 0.3
      }, {
        x: -1,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Triangle;
}();
/**
 * Drawing methods for the inverted trinagle endpoint.
 */


var InvertedTriangle = /*#__PURE__*/function () {
  function InvertedTriangle() {
    _classCallCheck(this, InvertedTriangle);
  }

  _createClass(InvertedTriangle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0,
        y: 0.3
      }, {
        x: 0,
        y: -0.3
      }, {
        x: -1,
        y: 0
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return InvertedTriangle;
}();
/**
 * Drawing methods for the circle endpoint.
 */


var Circle = /*#__PURE__*/function () {
  function Circle() {
    _classCallCheck(this, Circle);
  }

  _createClass(Circle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var point = {
        x: -0.4,
        y: 0
      };
      EndPoint.transform(point, arrowData);
      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);
      return true;
    }
  }]);

  return Circle;
}();
/**
 * Drawing methods for the bar endpoint.
 */


var Bar = /*#__PURE__*/function () {
  function Bar() {
    _classCallCheck(this, Bar);
  }

  _createClass(Bar, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      /*
      var points = [
        {x:0, y:0.5},
        {x:0, y:-0.5}
      ];
           EndPoint.transform(points, arrowData);
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.stroke();
      */
      var points = [{
        x: 0,
        y: 0.5
      }, {
        x: 0,
        y: -0.5
      }, {
        x: -0.15,
        y: -0.5
      }, {
        x: -0.15,
        y: 0.5
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Bar;
}();
/**
 * Drawing methods for the box endpoint.
 */


var Box = /*#__PURE__*/function () {
  function Box() {
    _classCallCheck(this, Box);
  }

  _createClass(Box, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var points = [{
        x: 0,
        y: 0.3
      }, {
        x: 0,
        y: -0.3
      }, {
        x: -0.6,
        y: -0.3
      }, {
        x: -0.6,
        y: 0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Box;
}();
/**
 * Drawing methods for the diamond endpoint.
 */


var Diamond = /*#__PURE__*/function () {
  function Diamond() {
    _classCallCheck(this, Diamond);
  }

  _createClass(Diamond, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var points = [{
        x: 0,
        y: 0
      }, {
        x: -0.5,
        y: -0.3
      }, {
        x: -1,
        y: 0
      }, {
        x: -0.5,
        y: 0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Diamond;
}();
/**
 * Drawing methods for the vee endpoint.
 */


var Vee = /*#__PURE__*/function () {
  function Vee() {
    _classCallCheck(this, Vee);
  }

  _createClass(Vee, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: -1,
        y: 0.3
      }, {
        x: -0.5,
        y: 0
      }, {
        x: -1,
        y: -0.3
      }, {
        x: 0,
        y: 0
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Vee;
}();
/**
 * Drawing methods for the endpoints.
 */


var EndPoints = /*#__PURE__*/function () {
  function EndPoints() {
    _classCallCheck(this, EndPoints);
  }

  _createClass(EndPoints, null, [{
    key: "draw",
    value:
    /**
     * Draw an endpoint.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.
     */
    function draw(ctx, arrowData) {
      var type;

      if (arrowData.type) {
        type = arrowData.type.toLowerCase();
      }

      switch (type) {
        case "image":
          return Image$1.draw(ctx, arrowData);

        case "circle":
          return Circle.draw(ctx, arrowData);

        case "box":
          return Box.draw(ctx, arrowData);

        case "crow":
          return Crow.draw(ctx, arrowData);

        case "curve":
          return Curve.draw(ctx, arrowData);

        case "diamond":
          return Diamond.draw(ctx, arrowData);

        case "inv_curve":
          return InvertedCurve.draw(ctx, arrowData);

        case "triangle":
          return Triangle.draw(ctx, arrowData);

        case "inv_triangle":
          return InvertedTriangle.draw(ctx, arrowData);

        case "bar":
          return Bar.draw(ctx, arrowData);

        case "vee":
          return Vee.draw(ctx, arrowData);

        case "arrow": // fall-through

        default:
          return Arrow.draw(ctx, arrowData);
      }
    }
  }]);

  return EndPoints;
}();

function ownKeys$1(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context2 = ownKeys$1(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context3 = ownKeys$1(Object(source))).call(_context3, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }
/**
 * The Base Class for all edges.
 */

var EdgeBase = /*#__PURE__*/function () {
  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param _body - The body of the network.
   * @param _labelModule - Label module.
   */
  function EdgeBase(options, _body, _labelModule) {
    _classCallCheck(this, EdgeBase);

    this._body = _body;
    this._labelModule = _labelModule;
    this.color = {};
    this.colorDirty = true;
    this.hoverWidth = 1.5;
    this.selectionWidth = 2;
    this.setOptions(options);
    this.fromPoint = this.from;
    this.toPoint = this.to;
  }
  /** @inheritDoc */


  _createClass(EdgeBase, [{
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
    }
    /** @inheritDoc */

  }, {
    key: "cleanup",
    value: function cleanup() {
      return false;
    }
    /**
     * Set new edge options.
     *
     * @param options - The new edge options object.
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
      this.id = this.options.id;
    }
    /** @inheritDoc */

  }, {
    key: "drawLine",
    value: function drawLine(ctx, values, _selected, _hover) {
      var viaNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.getViaNode();
      // set style
      ctx.strokeStyle = this.getColor(ctx, values);
      ctx.lineWidth = values.width;

      if (values.dashes !== false) {
        this._drawDashedLine(ctx, values, viaNode);
      } else {
        this._drawLine(ctx, values, viaNode);
      }
    }
    /**
     * Draw a line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param fromPoint - TODO: Seems ignored, remove?
     * @param toPoint - TODO: Seems ignored, remove?
     */

  }, {
    key: "_drawLine",
    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {
      if (this.from != this.to) {
        // draw line
        this._line(ctx, values, viaNode, fromPoint, toPoint);
      } else {
        var _this$_getCircleData = this._getCircleData(ctx),
            _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),
            x = _this$_getCircleData2[0],
            y = _this$_getCircleData2[1],
            radius = _this$_getCircleData2[2];

        this._circle(ctx, values, x, y, radius);
      }
    }
    /**
     * Draw a dashed line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param _fromPoint - Ignored (TODO: remove in the future).
     * @param _toPoint - Ignored (TODO: remove in the future).
     */

  }, {
    key: "_drawDashedLine",
    value: function _drawDashedLine(ctx, values, viaNode, _fromPoint, _toPoint) {
      ctx.lineCap = "round";
      var pattern = isArray$2(values.dashes) ? values.dashes : [5, 5]; // only firefox and chrome support this method, else we use the legacy one.

      if (ctx.setLineDash !== undefined) {
        ctx.save(); // set dash settings for chrome or firefox

        ctx.setLineDash(pattern);
        ctx.lineDashOffset = 0; // draw the line

        if (this.from != this.to) {
          // draw line
          this._line(ctx, values, viaNode);
        } else {
          var _this$_getCircleData3 = this._getCircleData(ctx),
              _this$_getCircleData4 = _slicedToArray(_this$_getCircleData3, 3),
              x = _this$_getCircleData4[0],
              y = _this$_getCircleData4[1],
              radius = _this$_getCircleData4[2];

          this._circle(ctx, values, x, y, radius);
        } // restore the dash settings.


        ctx.setLineDash([0]);
        ctx.lineDashOffset = 0;
        ctx.restore();
      } else {
        // unsupporting smooth lines
        if (this.from != this.to) {
          // draw line
          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);
        } else {
          var _this$_getCircleData5 = this._getCircleData(ctx),
              _this$_getCircleData6 = _slicedToArray(_this$_getCircleData5, 3),
              _x = _this$_getCircleData6[0],
              _y = _this$_getCircleData6[1],
              _radius = _this$_getCircleData6[2];

          this._circle(ctx, values, _x, _y, _radius);
        } // draw shadow if enabled


        this.enableShadow(ctx, values);
        ctx.stroke(); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      }
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @param node - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */

  }, {
    key: "findBorderPosition",
    value: function findBorderPosition(node, ctx, options) {
      if (this.from != this.to) {
        return this._findBorderPosition(node, ctx, options);
      } else {
        return this._findBorderPositionCircle(node, ctx, options);
      }
    }
    /** @inheritDoc */

  }, {
    key: "findBorderPositions",
    value: function findBorderPositions(ctx) {
      if (this.from != this.to) {
        return {
          from: this._findBorderPosition(this.from, ctx),
          to: this._findBorderPosition(this.to, ctx)
        };
      } else {
        var _context;

        var _this$_getCircleData$ = slice(_context = this._getCircleData(ctx)).call(_context, 0, 2),
            _this$_getCircleData$2 = _slicedToArray(_this$_getCircleData$, 2),
            x = _this$_getCircleData$2[0],
            y = _this$_getCircleData$2[1];

        return {
          from: this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: 0.25,
            high: 0.6,
            direction: -1
          }),
          to: this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: 0.6,
            high: 0.8,
            direction: 1
          })
        };
      }
    }
    /**
     * Compute the center point and radius of an edge connected to the same node at both ends.
     *
     * @param ctx - The context that will be used for rendering.
     * @returns `[x, y, radius]`
     */

  }, {
    key: "_getCircleData",
    value: function _getCircleData(ctx) {
      var radius = this.options.selfReference.size;

      if (ctx !== undefined) {
        if (this.from.shape.width === undefined) {
          this.from.shape.resize(ctx);
        }
      } // get circle coordinates


      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);
      return [coordinates.x, coordinates.y, radius];
    }
    /**
     * Get a point on a circle.
     *
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     * @param position - Value between 0 (line start) and 1 (line end).
     * @returns Cartesian coordinates of requested point on the circle.
     */

  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x, y, radius, position) {
      var angle = position * 2 * Math.PI;
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @remarks
     * This function uses binary search to look for the point where the circle crosses the border of the node.
     * @param nearNode - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */

  }, {
    key: "_findBorderPositionCircle",
    value: function _findBorderPositionCircle(nearNode, ctx, options) {
      var x = options.x;
      var y = options.y;
      var low = options.low;
      var high = options.high;
      var direction = options.direction;
      var maxIterations = 10;
      var radius = this.options.selfReference.size;
      var threshold = 0.05;
      var pos;
      var middle = (low + high) * 0.5;
      var endPointOffset = 0;

      if (this.options.arrowStrikethrough === true) {
        if (direction === -1) {
          endPointOffset = this.options.endPointOffset.from;
        } else if (direction === 1) {
          endPointOffset = this.options.endPointOffset.to;
        }
      }

      var iteration = 0;

      do {
        middle = (low + high) * 0.5;
        pos = this._pointOnCircle(x, y, radius, middle);
        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);
        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));
        var difference = distanceToBorder - distanceToPoint;

        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference > 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (direction > 0) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (direction > 0) {
            high = middle;
          } else {
            low = middle;
          }
        }

        ++iteration;
      } while (low <= high && iteration < maxIterations);

      return _objectSpread$1(_objectSpread$1({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.
     *
     * @param selected - Determines wheter the line is selected.
     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.
     * @returns The width of the line.
     */

  }, {
    key: "getLineWidth",
    value: function getLineWidth(selected, hover) {
      if (selected === true) {
        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);
      } else if (hover === true) {
        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);
      } else {
        return Math.max(this.options.width, 0.3 / this._body.view.scale);
      }
    }
    /**
     * Compute the color or gradient for given edge.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param _selected - Ignored (TODO: remove in the future).
     * @param _hover - Ignored (TODO: remove in the future).
     * @returns Color string if single color is inherited or gradient if two.
     */

  }, {
    key: "getColor",
    value: function getColor(ctx, values) {
      if (values.inheritsColor !== false) {
        // when this is a loop edge, just use the 'from' method
        if (values.inheritsColor === "both" && this.from.id !== this.to.id) {
          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
          var fromColor = this.from.options.color.highlight.border;
          var toColor = this.to.options.color.highlight.border;

          if (this.from.selected === false && this.to.selected === false) {
            fromColor = overrideOpacity(this.from.options.color.border, values.opacity);
            toColor = overrideOpacity(this.to.options.color.border, values.opacity);
          } else if (this.from.selected === true && this.to.selected === false) {
            toColor = this.to.options.color.border;
          } else if (this.from.selected === false && this.to.selected === true) {
            fromColor = this.from.options.color.border;
          }

          grd.addColorStop(0, fromColor);
          grd.addColorStop(1, toColor); // -------------------- this returns -------------------- //

          return grd;
        }

        if (values.inheritsColor === "to") {
          return overrideOpacity(this.to.options.color.border, values.opacity);
        } else {
          // "from"
          return overrideOpacity(this.from.options.color.border, values.opacity);
        }
      } else {
        return overrideOpacity(values.color, values.opacity);
      }
    }
    /**
     * Draw a line from a node to itself, a circle.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     */

  }, {
    key: "_circle",
    value: function _circle(ctx, values, x, y, radius) {
      // draw shadow if enabled
      this.enableShadow(ctx, values); //full circle

      var angleFrom = 0;
      var angleTo = Math.PI * 2;

      if (!this.options.selfReference.renderBehindTheNode) {
        //render only parts which are not overlaping with parent node
        //need to find x,y of from point and x,y to point
        //calculating radians
        var low = this.options.selfReference.angle;
        var high = this.options.selfReference.angle + Math.PI;

        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: low,
          high: high,
          direction: -1
        });

        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: low,
          high: high,
          direction: 1
        });

        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);
        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);
      } // draw a circle


      ctx.beginPath();
      ctx.arc(x, y, radius, angleFrom, angleTo, false);
      ctx.stroke(); // disable shadows for other elements.

      this.disableShadow(ctx, values);
    }
    /**
     * @inheritDoc
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     */

  }, {
    key: "getDistanceToEdge",
    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      if (this.from != this.to) {
        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);
      } else {
        var _this$_getCircleData7 = this._getCircleData(undefined),
            _this$_getCircleData8 = _slicedToArray(_this$_getCircleData7, 3),
            x = _this$_getCircleData8[0],
            y = _this$_getCircleData8[1],
            radius = _this$_getCircleData8[2];

        var dx = x - x3;
        var dy = y - y3;
        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
      }
    }
    /**
     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).
     *
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @returns The distance between the line segment and the point.
     */

  }, {
    key: "_getDistanceToLine",
    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
      var px = x2 - x1;
      var py = y2 - y1;
      var something = px * px + py * py;
      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

      if (u > 1) {
        u = 1;
      } else if (u < 0) {
        u = 0;
      }

      var x = x1 + u * px;
      var y = y1 + u * py;
      var dx = x - x3;
      var dy = y - y3; //# Note: If the actual distance does not matter,
      //# if you only want to compare what this function
      //# returns to other results of this function, you
      //# can just return the squared distance instead
      //# (i.e. remove the sqrt) to gain a little performance

      return Math.sqrt(dx * dx + dy * dy);
    }
    /** @inheritDoc */

  }, {
    key: "getArrowData",
    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values) {
      // set lets
      var angle;
      var arrowPoint;
      var node1;
      var node2;
      var reversed;
      var scaleFactor;
      var type;
      var lineWidth = values.width;

      if (position === "from") {
        node1 = this.from;
        node2 = this.to;
        reversed = values.fromArrowScale < 0;
        scaleFactor = Math.abs(values.fromArrowScale);
        type = values.fromArrowType;
      } else if (position === "to") {
        node1 = this.to;
        node2 = this.from;
        reversed = values.toArrowScale < 0;
        scaleFactor = Math.abs(values.toArrowScale);
        type = values.toArrowType;
      } else {
        node1 = this.to;
        node2 = this.from;
        reversed = values.middleArrowScale < 0;
        scaleFactor = Math.abs(values.middleArrowScale);
        type = values.middleArrowType;
      }

      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.
      // if not connected to itself

      if (node1 != node2) {
        var approximateEdgeLength = hypot(node1.x - node2.x, node1.y - node2.y);

        var relativeLength = length / approximateEdgeLength;

        if (position !== "middle") {
          // draw arrow head
          if (this.options.smooth.enabled === true) {
            var pointT = this._findBorderPosition(node1, ctx, {
              via: viaNode
            });

            var guidePos = this.getPoint(pointT.t + relativeLength * (position === "from" ? 1 : -1), viaNode);
            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);
            arrowPoint = pointT;
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this._findBorderPosition(node1, ctx);
          }
        } else {
          // Negative half length reverses arrow direction.
          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;
          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);
          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);
          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);
          arrowPoint = this.getPoint(0.5, viaNode);
        }
      } else {
        // draw circle
        var _this$_getCircleData9 = this._getCircleData(ctx),
            _this$_getCircleData10 = _slicedToArray(_this$_getCircleData9, 3),
            x = _this$_getCircleData10[0],
            y = _this$_getCircleData10[1],
            radius = _this$_getCircleData10[2];

        if (position === "from") {
          var low = this.options.selfReference.angle;
          var high = this.options.selfReference.angle + Math.PI;

          var _pointT = this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: low,
            high: high,
            direction: -1
          });

          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
          arrowPoint = _pointT;
        } else if (position === "to") {
          var _low = this.options.selfReference.angle;

          var _high = this.options.selfReference.angle + Math.PI;

          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: _low,
            high: _high,
            direction: 1
          });

          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
          arrowPoint = _pointT2;
        } else {
          var pos = this.options.selfReference.angle / (2 * Math.PI);
          arrowPoint = this._pointOnCircle(x, y, radius, pos);
          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
        }
      }

      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
      var arrowCore = {
        x: xi,
        y: yi
      };
      return {
        point: arrowPoint,
        core: arrowCore,
        angle: angle,
        length: length,
        type: type
      };
    }
    /** @inheritDoc */

  }, {
    key: "drawArrowHead",
    value: function drawArrowHead(ctx, values, _selected, _hover, arrowData) {
      // set style
      ctx.strokeStyle = this.getColor(ctx, values);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = values.width;
      var canFill = EndPoints.draw(ctx, arrowData);

      if (canFill) {
        // draw shadow if enabled
        this.enableShadow(ctx, values);

        fill(ctx).call(ctx); // disable shadows for other elements.


        this.disableShadow(ctx, values);
      }
    }
    /**
     * Set the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */

  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }
    /**
     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */

  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     * Render the background according to the formatting values.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the background.
     */

  }, {
    key: "drawBackground",
    value: function drawBackground(ctx, values) {
      if (values.background !== false) {
        // save original line attrs
        var origCtxAttr = {
          strokeStyle: ctx.strokeStyle,
          lineWidth: ctx.lineWidth,
          dashes: ctx.dashes
        };
        ctx.strokeStyle = values.backgroundColor;
        ctx.lineWidth = values.backgroundSize;
        this.setStrokeDashed(ctx, values.backgroundDashes);
        ctx.stroke(); // restore original line attrs

        ctx.strokeStyle = origCtxAttr.strokeStyle;
        ctx.lineWidth = origCtxAttr.lineWidth;
        ctx.dashes = origCtxAttr.dashes;
        this.setStrokeDashed(ctx, values.dashes);
      }
    }
    /**
     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.
     *
     * @param ctx - The context that will be used for rendering.
     * @param dashes - The pattern [line, space, lineâ¦], true for default dashed line or false for normal line.
     */

  }, {
    key: "setStrokeDashed",
    value: function setStrokeDashed(ctx, dashes) {
      if (dashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var pattern = isArray$2(dashes) ? dashes : [5, 5];
          ctx.setLineDash(pattern);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      } else {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      }
    }
  }]);

  return EdgeBase;
}();

function ownKeys(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context2 = ownKeys(Object(source))).call(_context2, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * The Base Class for all Bezier edges.
 * Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var BezierEdgeBase = /*#__PURE__*/function (_EdgeBase) {
  _inherits(BezierEdgeBase, _EdgeBase);

  var _super = _createSuper$9(BezierEdgeBase);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeBase(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   * Find the intersection between the border of the node and the edge.
   *
   * @remarks
   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
   * @param nearNode - The node (either from or to node of the edge).
   * @param ctx - The context that will be used for rendering.
   * @param viaNode - Additional node(s) the edge passes through.
   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
   */


  _createClass(BezierEdgeBase, [{
    key: "_findBorderPositionBezier",
    value: function _findBorderPositionBezier(nearNode, ctx) {
      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();
      var maxIterations = 10;
      var threshold = 0.2;
      var from = false;
      var high = 1;
      var low = 0;
      var node = this.to;
      var pos;
      var middle;
      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;

      if (nearNode.id === this.from.id) {
        node = this.from;
        from = true;
        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;
      }

      if (this.options.arrowStrikethrough === false) {
        endPointOffset = 0;
      }

      var iteration = 0;

      do {
        middle = (low + high) * 0.5;
        pos = this.getPoint(middle, viaNode);
        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);
        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
        var difference = distanceToBorder - distanceToPoint;

        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference < 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (from === false) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (from === false) {
            high = middle;
          } else {
            low = middle;
          }
        }

        ++iteration;
      } while (low <= high && iteration < maxIterations);

      return _objectSpread(_objectSpread({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
     *
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @param via - The control point for the edge.
     * @returns The distance between the line segment and the point.
     */

  }, {
    key: "_getDistanceToBezierEdge",
    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var distance;
      var i, t, x, y;
      var lastX = x1;
      var lastY = y1;

      for (i = 1; i < 10; i++) {
        t = 0.1 * i;
        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;

        if (i > 0) {
          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }

        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
    /**
     * Render a bezier curve between two nodes.
     *
     * @remarks
     * The method accepts zero, one or two control points.
     * Passing zero control points just draws a straight line.
     * @param ctx - The context that will be used for rendering.
     * @param values - Style options for edge drawing.
     * @param viaNode1 - First control point for curve drawing.
     * @param viaNode2 - Second control point for curve drawing.
     */

  }, {
    key: "_bezierCurve",
    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

      if (viaNode1 != null && viaNode1.x != null) {
        if (viaNode2 != null && viaNode2.x != null) {
          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
        }
      } else {
        // fallback to normal straight edge
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
      } // draw a background


      this.drawBackground(ctx, values); // draw shadow if enabled

      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
  }]);

  return BezierEdgeBase;
}(EdgeBase);

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes. The Dynamic piece refers to how the curve
 * reacts to physics changes.
 *
 * @augments BezierEdgeBase
 */

var BezierEdgeDynamic = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(BezierEdgeDynamic, _BezierEdgeBase);

  var _super = _createSuper$8(BezierEdgeDynamic);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeDynamic(options, body, labelModule) {
    var _this;

    _classCallCheck(this, BezierEdgeDynamic);

    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.
    _this = _super.call(this, options, body, labelModule); // --> this calls the setOptions below

    _this.via = _this.via; // constructor â super â super â setOptions â setupSupportNode

    _this._boundFunction = function () {
      _this.positionBezierNode();
    };

    _this._body.emitter.on("_repositionBezierNodes", _this._boundFunction);

    return _this;
  }
  /** @inheritDoc */


  _createClass(BezierEdgeDynamic, [{
    key: "setOptions",
    value: function setOptions(options) {
      _get(_getPrototypeOf(BezierEdgeDynamic.prototype), "setOptions", this).call(this, options); // check if the physics has changed.


      var physicsChange = false;

      if (this.options.physics !== options.physics) {
        physicsChange = true;
      } // set the options and the to and from nodes


      this.options = options;
      this.id = this.options.id;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to]; // setup the support node and connect

      this.setupSupportNode();
      this.connect(); // when we change the physics state of the edge, we reposition the support node.

      if (physicsChange === true) {
        this.via.setOptions({
          physics: this.options.physics
        });
        this.positionBezierNode();
      }
    }
    /** @inheritDoc */

  }, {
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];

      if (this.from === undefined || this.to === undefined || this.options.physics === false) {
        this.via.setOptions({
          physics: false
        });
      } else {
        // fix weird behaviour where a self referencing node has physics enabled
        if (this.from.id === this.to.id) {
          this.via.setOptions({
            physics: false
          });
        } else {
          this.via.setOptions({
            physics: true
          });
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "cleanup",
    value: function cleanup() {
      this._body.emitter.off("_repositionBezierNodes", this._boundFunction);

      if (this.via !== undefined) {
        delete this._body.nodes[this.via.id];
        this.via = undefined;
        return true;
      }

      return false;
    }
    /**
     * Create and add a support node if not already present.
     *
     * @remarks
     * Bezier curves require an anchor point to calculate the smooth flow.
     * These points are nodes.
     * These nodes are invisible but are used for the force calculation.
     *
     * The changed data is not called, if needed, it is returned by the main edge constructor.
     */

  }, {
    key: "setupSupportNode",
    value: function setupSupportNode() {
      if (this.via === undefined) {
        var nodeId = "edgeId:" + this.id;

        var node = this._body.functions.createNode({
          id: nodeId,
          shape: "circle",
          physics: true,
          hidden: true
        });

        this._body.nodes[nodeId] = node;
        this.via = node;
        this.via.parentEdgeId = this.id;
        this.positionBezierNode();
      }
    }
    /**
     * Position bezier node.
     */

  }, {
    key: "positionBezierNode",
    value: function positionBezierNode() {
      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
        this.via.x = 0.5 * (this.from.x + this.to.x);
        this.via.y = 0.5 * (this.from.y + this.to.y);
      } else if (this.via !== undefined) {
        this.via.x = 0;
        this.via.y = 0;
      }
    }
    /** @inheritDoc */

  }, {
    key: "_line",
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      return this.via;
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this.via;
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;

      if (this.from === this.to) {
        var _this$_getCircleData = this._getCircleData(),
            _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),
            cx = _this$_getCircleData2[0],
            cy = _this$_getCircleData2[1],
            cr = _this$_getCircleData2[2];

        var a = 2 * Math.PI * (1 - position);
        return {
          x: cx + cr * Math.sin(a),
          y: cy + cr - cr * (1 - Math.cos(a))
        };
      } else {
        return {
          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,
          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y
        };
      }
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx, this.via);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
    }
  }]);

  return BezierEdgeDynamic;
}(BezierEdgeBase);

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var BezierEdgeStatic = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(BezierEdgeStatic, _BezierEdgeBase);

  var _super = _createSuper$7(BezierEdgeStatic);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeStatic(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeStatic);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(BezierEdgeStatic, [{
    key: "_line",
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /**
     * Compute the coordinates of the via node.
     *
     * @remarks
     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
     * @returns Cartesian coordinates of the via node.
     */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      // Assumption: x/y coordinates in from/to always defined
      var factor = this.options.smooth.roundness;
      var type = this.options.smooth.type;
      var dx = Math.abs(this.from.x - this.to.x);
      var dy = Math.abs(this.from.y - this.to.y);

      if (type === "discrete" || type === "diagonalCross") {
        var stepX;
        var stepY;

        if (dx <= dy) {
          stepX = stepY = factor * dy;
        } else {
          stepX = stepY = factor * dx;
        }

        if (this.from.x > this.to.x) {
          stepX = -stepX;
        }

        if (this.from.y >= this.to.y) {
          stepY = -stepY;
        }

        var xVia = this.from.x + stepX;
        var yVia = this.from.y + stepY;

        if (type === "discrete") {
          if (dx <= dy) {
            xVia = dx < factor * dy ? this.from.x : xVia;
          } else {
            yVia = dy < factor * dx ? this.from.y : yVia;
          }
        }

        return {
          x: xVia,
          y: yVia
        };
      } else if (type === "straightCross") {
        var _stepX = (1 - factor) * dx;

        var _stepY = (1 - factor) * dy;

        if (dx <= dy) {
          // up - down
          _stepX = 0;

          if (this.from.y < this.to.y) {
            _stepY = -_stepY;
          }
        } else {
          // left - right
          if (this.from.x < this.to.x) {
            _stepX = -_stepX;
          }

          _stepY = 0;
        }

        return {
          x: this.to.x + _stepX,
          y: this.to.y + _stepY
        };
      } else if (type === "horizontal") {
        var _stepX2 = (1 - factor) * dx;

        if (this.from.x < this.to.x) {
          _stepX2 = -_stepX2;
        }

        return {
          x: this.to.x + _stepX2,
          y: this.from.y
        };
      } else if (type === "vertical") {
        var _stepY2 = (1 - factor) * dy;

        if (this.from.y < this.to.y) {
          _stepY2 = -_stepY2;
        }

        return {
          x: this.from.x,
          y: this.to.y + _stepY2
        };
      } else if (type === "curvedCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var radius = Math.sqrt(dx * dx + dy * dy);
        var pi = Math.PI;
        var originalAngle = Math.atan2(dy, dx);
        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);
        return {
          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)
        };
      } else if (type === "curvedCCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;

        var _radius = Math.sqrt(dx * dx + dy * dy);

        var _pi = Math.PI;

        var _originalAngle = Math.atan2(dy, dx);

        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

        return {
          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)
        };
      } else {
        // continuous
        var _stepX3;

        var _stepY3;

        if (dx <= dy) {
          _stepX3 = _stepY3 = factor * dy;
        } else {
          _stepX3 = _stepY3 = factor * dx;
        }

        if (this.from.x > this.to.x) {
          _stepX3 = -_stepX3;
        }

        if (this.from.y >= this.to.y) {
          _stepY3 = -_stepY3;
        }

        var _xVia = this.from.x + _stepX3;

        var _yVia = this.from.y + _stepY3;

        if (dx <= dy) {
          if (this.from.x <= this.to.x) {
            _xVia = this.to.x < _xVia ? this.to.x : _xVia;
          } else {
            _xVia = this.to.x > _xVia ? this.to.x : _xVia;
          }
        } else {
          if (this.from.y >= this.to.y) {
            _yVia = this.to.y > _yVia ? this.to.y : _yVia;
          } else {
            _yVia = this.to.y < _yVia ? this.to.y : _yVia;
          }
        }

        return {
          x: _xVia,
          y: _yVia
        };
      }
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this._findBorderPositionBezier(nearNode, ctx, options.via);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();
      var t = position;
      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
      return {
        x: x,
        y: y
      };
    }
  }]);

  return BezierEdgeStatic;
}(BezierEdgeBase);

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model
 * smooth gradual curves in paths between nodes.
 *
 * @augments BezierEdgeBase
 */

var CubicBezierEdgeBase = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(CubicBezierEdgeBase, _BezierEdgeBase);

  var _super = _createSuper$6(CubicBezierEdgeBase);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function CubicBezierEdgeBase(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdgeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
   *
   * @remarks
   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
   * @param x1 - First end of the line segment on the x axis.
   * @param y1 - First end of the line segment on the y axis.
   * @param x2 - Second end of the line segment on the x axis.
   * @param y2 - Second end of the line segment on the y axis.
   * @param x3 - Position of the point on the x axis.
   * @param y3 - Position of the point on the y axis.
   * @param via1 - The first point this edge passes through.
   * @param via2 - The second point this edge passes through.
   * @returns The distance between the line segment and the point.
   */


  _createClass(CubicBezierEdgeBase, [{
    key: "_getDistanceToBezierEdge2",
    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var lastX = x1;
      var lastY = y1;
      var vec = [0, 0, 0, 0];

      for (var i = 1; i < 10; i++) {
        var t = 0.1 * i;
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;

        if (i > 0) {
          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);

          minDistance = distance < minDistance ? distance : minDistance;
        }

        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
  }]);

  return CubicBezierEdgeBase;
}(BezierEdgeBase);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var CubicBezierEdge = /*#__PURE__*/function (_CubicBezierEdgeBase) {
  _inherits(CubicBezierEdge, _CubicBezierEdgeBase);

  var _super = _createSuper$5(CubicBezierEdge);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function CubicBezierEdge(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdge);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(CubicBezierEdge, [{
    key: "_line",
    value: function _line(ctx, values, viaNodes) {
      // get the coordinates of the support points.
      var via1 = viaNodes[0];
      var via2 = viaNodes[1];

      this._bezierCurve(ctx, values, via1, via2);
    }
    /**
     * Compute the additional points the edge passes through.
     *
     * @returns Cartesian coordinates of the points the edge passes through.
     */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      var dx = this.from.x - this.to.x;
      var dy = this.from.y - this.to.y;
      var x1;
      var y1;
      var x2;
      var y2;
      var roundness = this.options.smooth.roundness; // horizontal if x > y or if direction is forced or if direction is horizontal

      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
        y1 = this.from.y;
        y2 = this.to.y;
        x1 = this.from.x - roundness * dx;
        x2 = this.to.x + roundness * dx;
      } else {
        y1 = this.from.y - roundness * dy;
        y2 = this.to.y + roundness * dy;
        x1 = this.from.x;
        x2 = this.to.x;
      }

      return [{
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      }];
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),
          _ref2 = _slicedToArray(_ref, 2),
          via1 = _ref2[0],
          via2 = _ref2[1];

      // x3,y3 is the point
      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),
          _ref4 = _slicedToArray(_ref3, 2),
          via1 = _ref4[0],
          via2 = _ref4[1];

      var t = position;
      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];
      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
      return {
        x: x,
        y: y
      };
    }
  }]);

  return CubicBezierEdge;
}(CubicBezierEdgeBase);

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Straight Edge.
 */

var StraightEdge = /*#__PURE__*/function (_EdgeBase) {
  _inherits(StraightEdge, _EdgeBase);

  var _super = _createSuper$4(StraightEdge);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function StraightEdge(options, body, labelModule) {
    _classCallCheck(this, StraightEdge);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(StraightEdge, [{
    key: "_line",
    value: function _line(ctx, values) {
      // draw a straight line
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
      ctx.lineTo(this.toPoint.x, this.toPoint.y); // draw shadow if enabled

      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return undefined;
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      return {
        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,
        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y
      };
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var node1 = this.to;
      var node2 = this.from;

      if (nearNode.id === this.from.id) {
        node1 = this.from;
        node2 = this.to;
      }

      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
      var toBorderDist = nearNode.distanceToBorder(ctx, angle);
      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
      return {
        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,
        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,
        t: 0
      };
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
    }
  }]);

  return StraightEdge;
}(EdgeBase);

/**
 * An edge connects two nodes and has a specific direction.
 */

var Edge = /*#__PURE__*/function () {
  /**
   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'
   * @param {object} body           shared state from Network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.
   * @param {object} globalOptions  options from the EdgesHandler instance
   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant
   */
  function Edge(options, body, imagelist, globalOptions, defaultOptions) {
    _classCallCheck(this, Edge);

    if (body === undefined) {
      throw new Error("No body provided");
    } // Since globalOptions is constant in values as well as reference,
    // Following needs to be done only once.


    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;
    this.imagelist = imagelist; // initialize variables

    this.id = undefined;
    this.fromId = undefined;
    this.toId = undefined;
    this.selected = false;
    this.hover = false;
    this.labelDirty = true;
    this.baseWidth = this.options.width;
    this.baseFontSize = this.options.font.size;
    this.from = undefined; // a node

    this.to = undefined; // a node

    this.edgeType = undefined;
    this.connected = false;
    this.labelModule = new Label(this.body, this.options, true
    /* It's an edge label */
    );
    this.setOptions(options);
  }
  /**
   * Set or overwrite options for the edge
   *
   * @param {object} options  an object with options
   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.
   */


  _createClass(Edge, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (!options) {
        return;
      } // Following options if changed affect the layout.


      var affectsLayout = typeof options.physics !== "undefined" && this.options.physics !== options.physics || typeof options.hidden !== "undefined" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== "undefined" && this.options.from !== options.from || typeof options.to !== "undefined" && this.options.to !== options.to;
      Edge.parseOptions(this.options, options, true, this.globalOptions);

      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (options.from !== undefined) {
        this.fromId = options.from;
      }

      if (options.to !== undefined) {
        this.toId = options.to;
      }

      if (options.title !== undefined) {
        this.title = options.title;
      }

      if (options.value !== undefined) {
        options.value = _parseFloat(options.value);
      }

      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("edge", pile); // update label Module

      this.updateLabelModule(options); // Update edge type, this if changed affects the layout.

      affectsLayout = this.updateEdgeType() || affectsLayout; // if anything has been updates, reset the selection width and the hover width

      this._setInteractionWidths(); // A node is connected when it has a from and to node that both exist in the network.body.nodes.


      this.connect();
      return affectsLayout;
    }
    /**
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {boolean} [copyFromGlobals=false]
     */

  }, {
    key: "getFormattingValues",
    value:
    /**
     *
     * @returns {ArrowOptions}
     */
    function getFormattingValues() {
      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
      var inheritsColor = this.options.color.inherit;
      var values = {
        toArrow: toArrow,
        toArrowScale: this.options.arrows.to.scaleFactor,
        toArrowType: this.options.arrows.to.type,
        toArrowSrc: this.options.arrows.to.src,
        toArrowImageWidth: this.options.arrows.to.imageWidth,
        toArrowImageHeight: this.options.arrows.to.imageHeight,
        middleArrow: middleArrow,
        middleArrowScale: this.options.arrows.middle.scaleFactor,
        middleArrowType: this.options.arrows.middle.type,
        middleArrowSrc: this.options.arrows.middle.src,
        middleArrowImageWidth: this.options.arrows.middle.imageWidth,
        middleArrowImageHeight: this.options.arrows.middle.imageHeight,
        fromArrow: fromArrow,
        fromArrowScale: this.options.arrows.from.scaleFactor,
        fromArrowType: this.options.arrows.from.type,
        fromArrowSrc: this.options.arrows.from.src,
        fromArrowImageWidth: this.options.arrows.from.imageWidth,
        fromArrowImageHeight: this.options.arrows.from.imageHeight,
        arrowStrikethrough: this.options.arrowStrikethrough,
        color: inheritsColor ? undefined : this.options.color.color,
        inheritsColor: inheritsColor,
        opacity: this.options.color.opacity,
        hidden: this.options.hidden,
        length: this.options.length,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y,
        dashes: this.options.dashes,
        width: this.options.width,
        background: this.options.background.enabled,
        backgroundColor: this.options.background.color,
        backgroundSize: this.options.background.size,
        backgroundDashes: this.options.background.dashes
      };

      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            var selectedWidth = this.options.selectionWidth;

            if (typeof selectedWidth === "function") {
              values.width = selectedWidth(values.width);
            } else if (typeof selectedWidth === "number") {
              values.width += selectedWidth;
            }

            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.highlight;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            var hoverWidth = this.options.hoverWidth;

            if (typeof hoverWidth === "function") {
              values.width = hoverWidth(values.width);
            } else if (typeof hoverWidth === "number") {
              values.width += hoverWidth;
            }

            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.hover;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === "function") {
          this.chooser(values, this.options.id, this.selected, this.hover);

          if (values.color !== undefined) {
            values.inheritsColor = false;
          }

          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
      }

      return values;
    }
    /**
     * update the options in the label module
     *
     * @param {object} options
     */

  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      var pile = [options, this.options, this.globalOptions, // Currently set global edge options
      this.defaultOptions];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     * update the edge type, set the options
     *
     * @returns {boolean}
     */

  }, {
    key: "updateEdgeType",
    value: function updateEdgeType() {
      var smooth = this.options.smooth;
      var dataChanged = false;
      var changeInType = true;

      if (this.edgeType !== undefined) {
        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
          changeInType = false;
        }

        if (changeInType === true) {
          dataChanged = this.cleanup();
        }
      }

      if (changeInType === true) {
        if (smooth.enabled === true) {
          if (smooth.type === "dynamic") {
            dataChanged = true;
            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
          } else if (smooth.type === "cubicBezier") {
            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
          } else {
            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
          }
        } else {
          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
        }
      } else {
        // if nothing changes, we just set the options.
        this.edgeType.setOptions(this.options);
      }

      return dataChanged;
    }
    /**
     * Connect an edge to its nodes
     */

  }, {
    key: "connect",
    value: function connect() {
      this.disconnect();
      this.from = this.body.nodes[this.fromId] || undefined;
      this.to = this.body.nodes[this.toId] || undefined;
      this.connected = this.from !== undefined && this.to !== undefined;

      if (this.connected === true) {
        this.from.attachEdge(this);
        this.to.attachEdge(this);
      } else {
        if (this.from) {
          this.from.detachEdge(this);
        }

        if (this.to) {
          this.to.detachEdge(this);
        }
      }

      this.edgeType.connect();
    }
    /**
     * Disconnect an edge from its nodes
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.from) {
        this.from.detachEdge(this);
        this.from = undefined;
      }

      if (this.to) {
        this.to.detachEdge(this);
        this.to = undefined;
      }

      this.connected = false;
    }
    /**
     * get the title of this edge.
     *
     * @returns {string} title    The title of the edge, or undefined when no title
     *                           has been set.
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.title;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the edge. Can be undefined
     *
     * @returns {number} value
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Adjust the value range of the edge. The edge will adjust it's width
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var widthDiff = this.options.scaling.max - this.options.scaling.min;

        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }

        this.options.width = this.options.scaling.min + scale * widthDiff;
      } else {
        this.options.width = this.baseWidth;
        this.options.font.size = this.baseFontSize;
      }

      this._setInteractionWidths();

      this.updateLabelModule();
    }
    /**
     *
     * @private
     */

  }, {
    key: "_setInteractionWidths",
    value: function _setInteractionWidths() {
      if (typeof this.options.hoverWidth === "function") {
        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
      } else {
        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
      }

      if (typeof this.options.selectionWidth === "function") {
        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
      } else {
        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
      }
    }
    /**
     * Redraw a edge
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var values = this.getFormattingValues();

      if (values.hidden) {
        return;
      } // get the via node from the edge type


      var viaNode = this.edgeType.getViaNode(); // draw line and label

      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);
      this.drawLabel(ctx, viaNode);
    }
    /**
     * Redraw arrows
     * Draw this arrows in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "drawArrows",
    value: function drawArrows(ctx) {
      var values = this.getFormattingValues();

      if (values.hidden) {
        return;
      } // get the via node from the edge type


      var viaNode = this.edgeType.getViaNode();
      var arrowData = {}; // restore edge targets to defaults

      this.edgeType.fromPoint = this.edgeType.from;
      this.edgeType.toPoint = this.edgeType.to; // from and to arrows give a different end point for edges. we set them here

      if (values.fromArrow) {
        arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;

        if (values.fromArrowSrc) {
          arrowData.from.image = this.imagelist.load(values.fromArrowSrc);
        }

        if (values.fromArrowImageWidth) {
          arrowData.from.imageWidth = values.fromArrowImageWidth;
        }

        if (values.fromArrowImageHeight) {
          arrowData.from.imageHeight = values.fromArrowImageHeight;
        }
      }

      if (values.toArrow) {
        arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;

        if (values.toArrowSrc) {
          arrowData.to.image = this.imagelist.load(values.toArrowSrc);
        }

        if (values.toArrowImageWidth) {
          arrowData.to.imageWidth = values.toArrowImageWidth;
        }

        if (values.toArrowImageHeight) {
          arrowData.to.imageHeight = values.toArrowImageHeight;
        }
      } // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.


      if (values.middleArrow) {
        arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values);

        if (values.middleArrowSrc) {
          arrowData.middle.image = this.imagelist.load(values.middleArrowSrc);
        }

        if (values.middleArrowImageWidth) {
          arrowData.middle.imageWidth = values.middleArrowImageWidth;
        }

        if (values.middleArrowImageHeight) {
          arrowData.middle.imageHeight = values.middleArrowImageHeight;
        }
      }

      if (values.fromArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);
      }

      if (values.middleArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);
      }

      if (values.toArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Node} viaNode
     */

  }, {
    key: "drawLabel",
    value: function drawLabel(ctx, viaNode) {
      if (this.options.label !== undefined) {
        // set style
        var node1 = this.from;
        var node2 = this.to;

        if (this.labelModule.differentState(this.selected, this.hover)) {
          this.labelModule.getTextSize(ctx, this.selected, this.hover);
        }

        var point;

        if (node1.id != node2.id) {
          this.labelModule.pointToSelf = false;
          point = this.edgeType.getPoint(0.5, viaNode);
          ctx.save();

          var rotationPoint = this._getRotation(ctx);

          if (rotationPoint.angle != 0) {
            ctx.translate(rotationPoint.x, rotationPoint.y);
            ctx.rotate(rotationPoint.angle);
          } // draw the label


          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
          /*
          // Useful debug code: draw a border around the label
          // This should **not** be enabled in production!
          var size = this.labelModule.getSize();; // ;; intentional so lint catches it
          ctx.strokeStyle = "#ff0000";
          ctx.strokeRect(size.left, size.top, size.width, size.height);
          // End  debug code
          */

          ctx.restore();
        } else {
          // Ignore the orientations.
          this.labelModule.pointToSelf = true; // get circle coordinates

          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);
          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
        }
      }
    }
    /**
     * Determine all visual elements of this edge instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        var rotationPoint = this._getRotation();

        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
          ret.push({
            edgeId: this.id,
            labelId: 0
          });
        }
      }

      var obj = {
        left: point.x,
        top: point.y
      };

      if (this.isOverlappingWith(obj)) {
        ret.push({
          edgeId: this.id
        });
      }

      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top
     * @returns {boolean}     True if location is located on the edge
     */

  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      if (this.connected) {
        var distMax = 10;
        var xFrom = this.from.x;
        var yFrom = this.from.y;
        var xTo = this.to.x;
        var yTo = this.to.y;
        var xObj = obj.left;
        var yObj = obj.top;
        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
        return dist < distMax;
      } else {
        return false;
      }
    }
    /**
     * Determine the rotation point, if any.
     *
     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
     * @private
     */

  }, {
    key: "_getRotation",
    value: function _getRotation(ctx) {
      var viaNode = this.edgeType.getViaNode();
      var point = this.edgeType.getPoint(0.5, viaNode);

      if (ctx !== undefined) {
        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
      }

      var ret = {
        x: point.x,
        y: this.labelModule.size.yLine,
        angle: 0
      };

      if (!this.labelModule.visible()) {
        return ret; // Don't even bother doing the atan2, there's nothing to draw
      }

      if (this.options.font.align === "horizontal") {
        return ret; // No need to calculate angle
      }

      var dy = this.from.y - this.to.y;
      var dx = this.from.x - this.to.x;
      var angle = Math.atan2(dy, dx); // radians
      // rotate so that label is readable

      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
        angle += Math.PI;
      }

      ret.angle = angle;
      return ret;
    }
    /**
     * Get a point on a circle
     *
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} angle
     * @returns {object} point
     * @private
     */

  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x, y, radius, angle) {
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }
    /**
     * Sets selected state to true
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
    }
    /**
     * Sets selected state to false
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
    }
    /**
     * cleans all required things on delete
     *
     * @returns {*}
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      return this.edgeType.cleanup();
    }
    /**
     * Remove edge from the list and perform necessary cleanup.
     */

  }, {
    key: "remove",
    value: function remove() {
      this.cleanup();
      this.disconnect();
      delete this.body.edges[this.id];
    }
    /**
     * Check if both connecting nodes exist
     *
     * @returns {boolean}
     */

  }, {
    key: "endPointsValid",
    value: function endPointsValid() {
      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;
    }
  }], [{
    key: "parseOptions",
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var fields = ["endPointOffset", "arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "selfReference", "to", "title", "value", "width", "font", "chosen", "widthConstraint"]; // only deep extend the items in the field array. These do not have shorthand.

      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion); // Only use endPointOffset values (from and to) if it's valid values

      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.from !== undefined) {
        if (_isFinite(newOptions.endPointOffset.from)) {
          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;
        } else {
          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== undefined ? globalOptions.endPointOffset.from : 0;
          console.error("endPointOffset.from is not a valid number");
        }
      }

      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.to !== undefined) {
        if (_isFinite(newOptions.endPointOffset.to)) {
          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;
        } else {
          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== undefined ? globalOptions.endPointOffset.to : 0;
          console.error("endPointOffset.to is not a valid number");
        }
      } // Only copy label if it's a legal value.


      if (isValidLabel(newOptions.label)) {
        parentOptions.label = newOptions.label;
      } else if (!isValidLabel(parentOptions.label)) {
        parentOptions.label = undefined;
      }

      mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
      mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
      mergeOptions(parentOptions, newOptions, "background", globalOptions);

      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
        parentOptions.dashes = newOptions.dashes;
      } else if (allowDeletion === true && newOptions.dashes === null) {
        parentOptions.dashes = create$5(globalOptions.dashes); // this sets the pointer of the option back to the global option.
      } // set the scaling newOptions


      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
        if (newOptions.scaling.min !== undefined) {
          parentOptions.scaling.min = newOptions.scaling.min;
        }

        if (newOptions.scaling.max !== undefined) {
          parentOptions.scaling.max = newOptions.scaling.max;
        }

        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      } else if (allowDeletion === true && newOptions.scaling === null) {
        parentOptions.scaling = create$5(globalOptions.scaling); // this sets the pointer of the option back to the global option.
      } // handle multiple input cases for arrows


      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
        if (typeof newOptions.arrows === "string") {
          var arrows = newOptions.arrows.toLowerCase();
          parentOptions.arrows.to.enabled = indexOf(arrows).call(arrows, "to") != -1;
          parentOptions.arrows.middle.enabled = indexOf(arrows).call(arrows, "middle") != -1;
          parentOptions.arrows.from.enabled = indexOf(arrows).call(arrows, "from") != -1;
        } else if (_typeof(newOptions.arrows) === "object") {
          mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
        } else {
          throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + stringify$1(newOptions.arrows));
        }
      } else if (allowDeletion === true && newOptions.arrows === null) {
        parentOptions.arrows = create$5(globalOptions.arrows); // this sets the pointer of the option back to the global option.
      } // handle multiple input cases for color


      if (newOptions.color !== undefined && newOptions.color !== null) {
        var fromColor = isString(newOptions.color) ? {
          color: newOptions.color,
          highlight: newOptions.color,
          hover: newOptions.color,
          inherit: false,
          opacity: 1
        } : newOptions.color;
        var toColor = parentOptions.color; // If passed, fill in values from default options - required in the case of no prototype bridging

        if (copyFromGlobals) {
          deepExtend(toColor, globalOptions.color, false, allowDeletion);
        } else {
          // Clear local properties - need to do it like this in order to retain prototype bridges
          for (var i in toColor) {
            if (Object.prototype.hasOwnProperty.call(toColor, i)) {
              delete toColor[i];
            }
          }
        }

        if (isString(toColor)) {
          toColor.color = toColor;
          toColor.highlight = toColor;
          toColor.hover = toColor;
          toColor.inherit = false;

          if (fromColor.opacity === undefined) {
            toColor.opacity = 1.0; // set default
          }
        } else {
          var colorsDefined = false;

          if (fromColor.color !== undefined) {
            toColor.color = fromColor.color;
            colorsDefined = true;
          }

          if (fromColor.highlight !== undefined) {
            toColor.highlight = fromColor.highlight;
            colorsDefined = true;
          }

          if (fromColor.hover !== undefined) {
            toColor.hover = fromColor.hover;
            colorsDefined = true;
          }

          if (fromColor.inherit !== undefined) {
            toColor.inherit = fromColor.inherit;
          }

          if (fromColor.opacity !== undefined) {
            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
          }

          if (colorsDefined === true) {
            toColor.inherit = false;
          } else {
            if (toColor.inherit === undefined) {
              toColor.inherit = "from"; // Set default
            }
          }
        }
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options
      }

      if (Object.prototype.hasOwnProperty.call(newOptions, "selfReferenceSize")) {
        console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}");
        parentOptions.selfReference.size = newOptions.selfReferenceSize;
      }
    }
  }]);

  return Edge;
}();

/**
 * Handler for Edges
 */

var EdgesHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Array.<Image>} images
   * @param {Array.<Group>} groups
   */
  function EdgesHandler(body, images, groups) {
    var _context,
        _this = this;

    _classCallCheck(this, EdgesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups; // create the edge API in the body container

    this.body.functions.createEdge = bind$6(_context = this.create).call(_context, this);
    this.edgesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };
    this.options = {};
    this.defaultOptions = {
      arrows: {
        to: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        from: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        }
      },
      endPointOffset: {
        from: 0,
        to: 0
      },
      arrowStrikethrough: true,
      color: {
        color: "#848484",
        highlight: "#848484",
        hover: "#848484",
        inherit: "from",
        opacity: 1.0
      },
      dashes: false,
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 2,
        // px
        strokeColor: "#ffffff",
        align: "horizontal",
        multi: false,
        vadjust: 0,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "courier new",
          vadjust: 2
        }
      },
      hidden: false,
      hoverWidth: 1.5,
      label: undefined,
      labelHighlightBold: true,
      length: undefined,
      physics: true,
      scaling: {
        min: 1,
        max: 15,
        label: {
          enabled: true,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      selectionWidth: 1.5,
      selfReference: {
        size: 20,
        angle: Math.PI / 4,
        renderBehindTheNode: true
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      background: {
        enabled: false,
        color: "rgba(111,111,111,1)",
        size: 10,
        dashes: false
      },
      smooth: {
        enabled: true,
        type: "dynamic",
        forceDirection: "none",
        roundness: 0.5
      },
      title: undefined,
      width: 1,
      value: undefined
    };
    deepExtend(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(EdgesHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this,
          _context2,
          _context3;

      // this allows external modules to force all dynamic curves to turn static.
      this.body.emitter.on("_forceDisableDynamicCurves", function (type) {
        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (type === "dynamic") {
          type = "continuous";
        }

        var dataChanged = false;

        for (var edgeId in _this2.body.edges) {
          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {
            var edge = _this2.body.edges[edgeId];

            var edgeData = _this2.body.data.edges.get(edgeId); // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
            // this is because a change in the global would not affect these curves.


            if (edgeData != null) {
              var smoothOptions = edgeData.smooth;

              if (smoothOptions !== undefined) {
                if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                  if (type === undefined) {
                    edge.setOptions({
                      smooth: false
                    });
                  } else {
                    edge.setOptions({
                      smooth: {
                        type: type
                      }
                    });
                  }

                  dataChanged = true;
                }
              }
            }
          }
        }

        if (emit === true && dataChanged === true) {
          _this2.body.emitter.emit("_dataChanged");
        }
      }); // this is called when options of EXISTING nodes or edges have changed.
      //
      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.
      //       See update() for logic.
      // TODO: Verify and examine the consequences of this. It might still trigger when
      //       non-option fields have changed, but then reconnecting edges is still useless.
      //       Alternatively, it might also be called when edges are removed.
      //

      this.body.emitter.on("_dataUpdated", function () {
        _this2.reconnectEdges();
      }); // refresh the edges. Used when reverting from hierarchical layout

      this.body.emitter.on("refreshEdges", bind$6(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", bind$6(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function () {
        forEach$1(_this2.edgesListeners, function (callback, event) {
          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
        });
        delete _this2.body.functions.createEdge;
        delete _this2.edgesListeners.add;
        delete _this2.edgesListeners.update;
        delete _this2.edgesListeners.remove;
        delete _this2.edgesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // use the parser from the Edge class to fill in all shorthand notations
        Edge.parseOptions(this.options, options, true, this.defaultOptions, true); // update smooth settings in all edges

        var dataChanged = false;

        if (options.smooth !== undefined) {
          for (var edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {
              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
            }
          }
        } // update fonts in all edges


        if (options.font !== undefined) {
          for (var _edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {
              this.body.edges[_edgeId].updateLabelModule();
            }
          }
        } // update the state of the variables if needed


        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Load edges by reading the data table
     *
     * @param {Array | DataSet | DataView} edges    The data containing the edges.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */

  }, {
    key: "setData",
    value: function setData(edges) {
      var _this3 = this;

      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var oldEdgesData = this.body.data.edges;

      if (isDataViewLike("id", edges)) {
        this.body.data.edges = edges;
      } else if (isArray$2(edges)) {
        this.body.data.edges = new DataSet();
        this.body.data.edges.add(edges);
      } else if (!edges) {
        this.body.data.edges = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      } // TODO: is this null or undefined or false?


      if (oldEdgesData) {
        // unsubscribe from old dataset
        forEach$1(this.edgesListeners, function (callback, event) {
          oldEdgesData.off(event, callback);
        });
      } // remove drawn edges


      this.body.edges = {}; // TODO: is this null or undefined or false?

      if (this.body.data.edges) {
        // subscribe to new dataset
        forEach$1(this.edgesListeners, function (callback, event) {
          _this3.body.data.edges.on(event, callback);
        }); // draw all new nodes

        var ids = this.body.data.edges.getIds();
        this.add(ids, true);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add edges
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: "add",
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var oldEdge = edges[id];

        if (oldEdge) {
          oldEdge.disconnect();
        }

        var data = edgesData.get(id, {
          showInternalIds: true
        });
        edges[id] = this.create(data);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing edges, or create them when not yet existing
     *
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: "update",
    value: function update(ids) {
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;
      var dataChanged = false;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = edgesData.get(id);
        var edge = edges[id];

        if (edge !== undefined) {
          // update edge
          edge.disconnect();
          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.

          edge.connect();
        } else {
          // create edge
          this.body.edges[id] = this.create(data);
          dataChanged = true;
        }
      }

      if (dataChanged === true) {
        this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing edges. Non existing ids will be ignored
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [emit=true]
     * @private
     */

  }, {
    key: "remove",
    value: function remove(ids) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (ids.length === 0) return; // early out

      var edges = this.body.edges;
      forEach$1(ids, function (id) {
        var edge = edges[id];

        if (edge !== undefined) {
          edge.remove();
        }
      });

      if (emit) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Refreshes Edge Handler
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this4 = this;

      forEach$1(this.body.edges, function (edge, edgeId) {
        var data = _this4.body.data.edges.get(edgeId);

        if (data !== undefined) {
          edge.setOptions(data);
        }
      });
    }
    /**
     *
     * @param {object} properties
     * @returns {Edge}
     */

  }, {
    key: "create",
    value: function create(properties) {
      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);
    }
    /**
     * Reconnect all edges
     *
     * @private
     */

  }, {
    key: "reconnectEdges",
    value: function reconnectEdges() {
      var id;
      var nodes = this.body.nodes;
      var edges = this.body.edges;

      for (id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          nodes[id].edges = [];
        }
      }

      for (id in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, id)) {
          var edge = edges[id];
          edge.from = null;
          edge.to = null;
          edge.connect();
        }
      }
    }
    /**
     *
     * @param {Edge.id} edgeId
     * @returns {Array}
     */

  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(edgeId) {
      var nodeList = [];

      if (this.body.edges[edgeId] !== undefined) {
        var edge = this.body.edges[edgeId];

        if (edge.fromId !== undefined) {
          nodeList.push(edge.fromId);
        }

        if (edge.toId !== undefined) {
          nodeList.push(edge.toId);
        }
      }

      return nodeList;
    }
    /**
     * There is no direct relation between the nodes and the edges DataSet,
     * so the right place to do call this is in the handler for event `_dataUpdated`.
     */

  }, {
    key: "_updateState",
    value: function _updateState() {
      this._addMissingEdges();

      this._removeInvalidEdges();
    }
    /**
     * Scan for missing nodes and remove corresponding edges, if any.
     *
     * @private
     */

  }, {
    key: "_removeInvalidEdges",
    value: function _removeInvalidEdges() {
      var _this5 = this;

      var edgesToDelete = [];
      forEach$1(this.body.edges, function (edge, id) {
        var toNode = _this5.body.nodes[edge.toId];
        var fromNode = _this5.body.nodes[edge.fromId]; // Skip clustering edges here, let the Clustering module handle those

        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {
          return;
        }

        if (toNode === undefined || fromNode === undefined) {
          edgesToDelete.push(id);
        }
      });
      this.remove(edgesToDelete, false);
    }
    /**
     * add all edges from dataset that are not in the cached state
     *
     * @private
     */

  }, {
    key: "_addMissingEdges",
    value: function _addMissingEdges() {
      var edgesData = this.body.data.edges;

      if (edgesData === undefined || edgesData === null) {
        return; // No edges DataSet yet; can happen on startup
      }

      var edges = this.body.edges;
      var addIds = [];

      forEach$2(edgesData).call(edgesData, function (edgeData, edgeId) {
        var edge = edges[edgeId];

        if (edge === undefined) {
          addIds.push(edgeId);
        }
      });

      this.add(addIds, true);
    }
  }]);

  return EdgesHandler;
}();

/**
 * Barnes Hut Solver
 */

var BarnesHutSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function BarnesHutSolver(body, physicsBody, options) {
    _classCallCheck(this, BarnesHutSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.barnesHutTree;
    this.setOptions(options);
    this._rng = Alea("BARNES HUT SOLVER"); // debug: show grid
    // this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
  }
  /**
   *
   * @param {object} options
   */


  _createClass(BarnesHutSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.thetaInversed = 1 / this.options.theta; // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius

      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
    }
    /**
     * This function calculates the forces the nodes apply on each other based on a gravitational model.
     * The Barnes Hut method is used to speed up this N-body simulation.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
        var node;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var nodeCount = nodeIndices.length; // create the tree

        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices); // for debugging


        this.barnesHutTree = barnesHutTree; // place the nodes one by one recursively

        for (var i = 0; i < nodeCount; i++) {
          node = nodes[nodeIndices[i]];

          if (node.options.mass > 0) {
            // starting with root is irrelevant, it never passes the BarnesHutSolver condition
            this._getForceContributions(barnesHutTree.root, node);
          }
        }
      }
    }
    /**
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_getForceContributions",
    value: function _getForceContributions(parentBranch, node) {
      this._getForceContribution(parentBranch.children.NW, node);

      this._getForceContribution(parentBranch.children.NE, node);

      this._getForceContribution(parentBranch.children.SW, node);

      this._getForceContribution(parentBranch.children.SE, node);
    }
    /**
     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
     * If a region contains a single node, we check if it is not itself, then we apply the force.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_getForceContribution",
    value: function _getForceContribution(parentBranch, node) {
      // we get no force contribution from an empty region
      if (parentBranch.childrenCount > 0) {
        // get the distance from the center of mass to the node.
        var dx = parentBranch.centerOfMass.x - node.x;
        var dy = parentBranch.centerOfMass.y - node.y;
        var distance = Math.sqrt(dx * dx + dy * dy); // BarnesHutSolver condition
        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
        // calcSize = 1/s --> d * 1/s > 1/theta = passed

        if (distance * parentBranch.calcSize > this.thetaInversed) {
          this._calculateForces(distance, dx, dy, node, parentBranch);
        } else {
          // Did not pass the condition, go into children if available
          if (parentBranch.childrenCount === 4) {
            this._getForceContributions(parentBranch, node);
          } else {
            // parentBranch must have only one node, if it was empty we wouldnt be here
            if (parentBranch.children.data.id != node.id) {
              // if it is not self
              this._calculateForces(distance, dx, dy, node, parentBranch);
            }
          }
        }
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Node} node
     * @param {object} parentBranch
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1;
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      } // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce


      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
    /**
     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
     *
     * @param {Array.<Node>} nodes
     * @param {Array.<number>} nodeIndices
     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
     * @private
     */

  }, {
    key: "_formBarnesHutTree",
    value: function _formBarnesHutTree(nodes, nodeIndices) {
      var node;
      var nodeCount = nodeIndices.length;
      var minX = nodes[nodeIndices[0]].x;
      var minY = nodes[nodeIndices[0]].y;
      var maxX = nodes[nodeIndices[0]].x;
      var maxY = nodes[nodeIndices[0]].y; // get the range of the nodes

      for (var i = 1; i < nodeCount; i++) {
        var _node = nodes[nodeIndices[i]];
        var x = _node.x;
        var y = _node.y;

        if (_node.options.mass > 0) {
          if (x < minX) {
            minX = x;
          }

          if (x > maxX) {
            maxX = x;
          }

          if (y < minY) {
            minY = y;
          }

          if (y > maxY) {
            maxY = y;
          }
        }
      } // make the range a square


      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y

      if (sizeDiff > 0) {
        minY -= 0.5 * sizeDiff;
        maxY += 0.5 * sizeDiff;
      } // xSize > ySize
      else {
        minX += 0.5 * sizeDiff;
        maxX -= 0.5 * sizeDiff;
      } // xSize < ySize


      var minimumTreeSize = 1e-5;
      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
      var halfRootSize = 0.5 * rootSize;
      var centerX = 0.5 * (minX + maxX),
          centerY = 0.5 * (minY + maxY); // construct the barnesHutTree

      var barnesHutTree = {
        root: {
          centerOfMass: {
            x: 0,
            y: 0
          },
          mass: 0,
          range: {
            minX: centerX - halfRootSize,
            maxX: centerX + halfRootSize,
            minY: centerY - halfRootSize,
            maxY: centerY + halfRootSize
          },
          size: rootSize,
          calcSize: 1 / rootSize,
          children: {
            data: null
          },
          maxWidth: 0,
          level: 0,
          childrenCount: 4
        }
      };

      this._splitBranch(barnesHutTree.root); // place the nodes one by one recursively


      for (var _i = 0; _i < nodeCount; _i++) {
        node = nodes[nodeIndices[_i]];

        if (node.options.mass > 0) {
          this._placeInTree(barnesHutTree.root, node);
        }
      } // make global


      return barnesHutTree;
    }
    /**
     * this updates the mass of a branch. this is increased by adding a node.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_updateBranchMass",
    value: function _updateBranchMass(parentBranch, node) {
      var centerOfMass = parentBranch.centerOfMass;
      var totalMass = parentBranch.mass + node.options.mass;
      var totalMassInv = 1 / totalMass;
      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
      centerOfMass.x *= totalMassInv;
      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
      centerOfMass.y *= totalMassInv;
      parentBranch.mass = totalMass;
      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
    }
    /**
     * determine in which branch the node will be placed.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {boolean} skipMassUpdate
     * @private
     */

  }, {
    key: "_placeInTree",
    value: function _placeInTree(parentBranch, node, skipMassUpdate) {
      if (skipMassUpdate != true || skipMassUpdate === undefined) {
        // update the mass of the branch.
        this._updateBranchMass(parentBranch, node);
      }

      var range = parentBranch.children.NW.range;
      var region;

      if (range.maxX > node.x) {
        // in NW or SW
        if (range.maxY > node.y) {
          region = "NW";
        } else {
          region = "SW";
        }
      } else {
        // in NE or SE
        if (range.maxY > node.y) {
          region = "NE";
        } else {
          region = "SE";
        }
      }

      this._placeInRegion(parentBranch, node, region);
    }
    /**
     * actually place the node in a region (or branch)
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: "_placeInRegion",
    value: function _placeInRegion(parentBranch, node, region) {
      var children = parentBranch.children[region];

      switch (children.childrenCount) {
        case 0:
          // place node here
          children.children.data = node;
          children.childrenCount = 1;

          this._updateBranchMass(children, node);

          break;

        case 1:
          // convert into children
          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
          // we move one node a little bit and we do not put it in the tree.
          if (children.children.data.x === node.x && children.children.data.y === node.y) {
            node.x += this._rng();
            node.y += this._rng();
          } else {
            this._splitBranch(children);

            this._placeInTree(children, node);
          }

          break;

        case 4:
          // place in branch
          this._placeInTree(children, node);

          break;
      }
    }
    /**
     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
     * after the split is complete.
     *
     * @param {object} parentBranch
     * @private
     */

  }, {
    key: "_splitBranch",
    value: function _splitBranch(parentBranch) {
      // if the branch is shaded with a node, replace the node in the new subset.
      var containedNode = null;

      if (parentBranch.childrenCount === 1) {
        containedNode = parentBranch.children.data;
        parentBranch.mass = 0;
        parentBranch.centerOfMass.x = 0;
        parentBranch.centerOfMass.y = 0;
      }

      parentBranch.childrenCount = 4;
      parentBranch.children.data = null;

      this._insertRegion(parentBranch, "NW");

      this._insertRegion(parentBranch, "NE");

      this._insertRegion(parentBranch, "SW");

      this._insertRegion(parentBranch, "SE");

      if (containedNode != null) {
        this._placeInTree(parentBranch, containedNode);
      }
    }
    /**
     * This function subdivides the region into four new segments.
     * Specifically, this inserts a single new segment.
     * It fills the children section of the parentBranch
     *
     * @param {object} parentBranch
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: "_insertRegion",
    value: function _insertRegion(parentBranch, region) {
      var minX, maxX, minY, maxY;
      var childSize = 0.5 * parentBranch.size;

      switch (region) {
        case "NW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;

        case "NE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;

        case "SW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;

        case "SE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
      }

      parentBranch.children[region] = {
        centerOfMass: {
          x: 0,
          y: 0
        },
        mass: 0,
        range: {
          minX: minX,
          maxX: maxX,
          minY: minY,
          maxY: maxY
        },
        size: 0.5 * parentBranch.size,
        calcSize: 2 * parentBranch.calcSize,
        children: {
          data: null
        },
        maxWidth: 0,
        level: parentBranch.level + 1,
        childrenCount: 0
      };
    } //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * This function is for debugging purposed, it draws the tree.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: "_debug",
    value: function _debug(ctx, color) {
      if (this.barnesHutTree !== undefined) {
        ctx.lineWidth = 1;

        this._drawBranch(this.barnesHutTree.root, ctx, color);
      }
    }
    /**
     * This function is for debugging purposes. It draws the branches recursively.
     *
     * @param {object} branch
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: "_drawBranch",
    value: function _drawBranch(branch, ctx, color) {
      if (color === undefined) {
        color = "#FF0000";
      }

      if (branch.childrenCount === 4) {
        this._drawBranch(branch.children.NW, ctx);

        this._drawBranch(branch.children.NE, ctx);

        this._drawBranch(branch.children.SE, ctx);

        this._drawBranch(branch.children.SW, ctx);
      }

      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.minY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.minY);
      ctx.stroke();
      /*
       if (branch.mass > 0) {
       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
       ctx.stroke();
       }
       */
    }
  }]);

  return BarnesHutSolver;
}();

/**
 * Repulsion Solver
 */

var RepulsionSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function RepulsionSolver(body, physicsBody, options) {
    _classCallCheck(this, RepulsionSolver);

    this._rng = Alea("REPULSION SOLVER");
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(RepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // repulsing forces between nodes

      var nodeDistance = this.options.nodeDistance; // approximation constants

      var a = -2 / 3 / nodeDistance;
      var b = 4 / 3; // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j

      for (var i = 0; i < nodeIndices.length - 1; i++) {
        node1 = nodes[nodeIndices[i]];

        for (var j = i + 1; j < nodeIndices.length; j++) {
          node2 = nodes[nodeIndices[j]];
          dx = node2.x - node1.x;
          dy = node2.y - node1.y;
          distance = Math.sqrt(dx * dx + dy * dy); // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.

          if (distance === 0) {
            distance = 0.1 * this._rng();
            dx = distance;
          }

          if (distance < 2 * nodeDistance) {
            if (distance < 0.5 * nodeDistance) {
              repulsingForce = 1.0;
            } else {
              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
            }

            repulsingForce = repulsingForce / distance;
            fx = dx * repulsingForce;
            fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);

  return RepulsionSolver;
}();

/**
 * Hierarchical Repulsion Solver
 */
var HierarchicalRepulsionSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function HierarchicalRepulsionSolver(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalRepulsionSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(HierarchicalRepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // repulsing forces between nodes

      var nodeDistance = this.options.nodeDistance; // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j

      for (var i = 0; i < nodeIndices.length - 1; i++) {
        var node1 = nodes[nodeIndices[i]];

        for (var j = i + 1; j < nodeIndices.length; j++) {
          var node2 = nodes[nodeIndices[j]]; // nodes only affect nodes on their level

          if (node1.level === node2.level) {
            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);
            var dx = node2.x - node1.x;
            var dy = node2.y - node1.y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            var steepness = 0.05;
            var repulsingForce = void 0;

            if (distance < theseNodesDistance) {
              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);
            } else {
              repulsingForce = 0;
            } // normalize force with


            if (distance !== 0) {
              repulsingForce = repulsingForce / distance;
            }

            var fx = dx * repulsingForce;
            var fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);

  return HierarchicalRepulsionSolver;
}();

/**
 * Spring Solver
 */
var SpringSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function SpringSolver(body, physicsBody, options) {
    _classCallCheck(this, SpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(SpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var edges = this.body.edges;
      var node1, node2, node3; // forces caused by the edges, modelled as springs

      for (var i = 0; i < edgeIndices.length; i++) {
        edge = edges[edgeIndices[i]];

        if (edge.connected === true && edge.toId !== edge.fromId) {
          // only calculate forces if nodes are in the same sector
          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
            if (edge.edgeType.via !== undefined) {
              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
              node1 = edge.to;
              node2 = edge.edgeType.via;
              node3 = edge.from;

              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);

              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
            } else {
              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;

              this._calculateSpringForce(edge.from, edge.to, edgeLength);
            }
          }
        }
      }
    }
    /**
     * This is the code actually performing the calculation for the function above.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @param {number} edgeLength
     * @private
     */

  }, {
    key: "_calculateSpringForce",
    value: function _calculateSpringForce(node1, node2, edgeLength) {
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01); // the 1/distance is so the fx and fy can be calculated without sine or cosine.

      var springForce = this.options.springConstant * (edgeLength - distance) / distance;
      var fx = dx * springForce;
      var fy = dy * springForce; // handle the case where one node is not part of the physcis

      if (this.physicsBody.forces[node1.id] !== undefined) {
        this.physicsBody.forces[node1.id].x += fx;
        this.physicsBody.forces[node1.id].y += fy;
      }

      if (this.physicsBody.forces[node2.id] !== undefined) {
        this.physicsBody.forces[node2.id].x -= fx;
        this.physicsBody.forces[node2.id].y -= fy;
      }
    }
  }]);

  return SpringSolver;
}();

/**
 * Hierarchical Spring Solver
 */
var HierarchicalSpringSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function HierarchicalSpringSolver(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalSpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(HierarchicalSpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var dx, dy, fx, fy, springForce, distance;
      var edges = this.body.edges;
      var factor = 0.5;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // initialize the spring force counters

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        forces[nodeId].springFx = 0;
        forces[nodeId].springFy = 0;
      } // forces caused by the edges, modelled as springs


      for (var _i = 0; _i < edgeIndices.length; _i++) {
        edge = edges[edgeIndices[_i]];

        if (edge.connected === true) {
          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
          dx = edge.from.x - edge.to.x;
          dy = edge.from.y - edge.to.y;
          distance = Math.sqrt(dx * dx + dy * dy);
          distance = distance === 0 ? 0.01 : distance; // the 1/distance is so the fx and fy can be calculated without sine or cosine.

          springForce = this.options.springConstant * (edgeLength - distance) / distance;
          fx = dx * springForce;
          fy = dy * springForce;

          if (edge.to.level != edge.from.level) {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].springFx -= fx;
              forces[edge.toId].springFy -= fy;
            }

            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].springFx += fx;
              forces[edge.fromId].springFy += fy;
            }
          } else {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].x -= factor * fx;
              forces[edge.toId].y -= factor * fy;
            }

            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].x += factor * fx;
              forces[edge.fromId].y += factor * fy;
            }
          }
        }
      } // normalize spring forces


      springForce = 1;
      var springFx, springFy;

      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
        var _nodeId = nodeIndices[_i2];
        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
        forces[_nodeId].x += springFx;
        forces[_nodeId].y += springFy;
      } // retain energy balance


      var totalFx = 0;
      var totalFy = 0;

      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
        var _nodeId2 = nodeIndices[_i3];
        totalFx += forces[_nodeId2].x;
        totalFy += forces[_nodeId2].y;
      }

      var correctionFx = totalFx / nodeIndices.length;
      var correctionFy = totalFy / nodeIndices.length;

      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
        var _nodeId3 = nodeIndices[_i4];
        forces[_nodeId3].x -= correctionFx;
        forces[_nodeId3].y -= correctionFy;
      }
    }
  }]);

  return HierarchicalSpringSolver;
}();

/**
 * Central Gravity Solver
 */
var CentralGravitySolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function CentralGravitySolver(body, physicsBody, options) {
    _classCallCheck(this, CentralGravitySolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(CentralGravitySolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculates forces for each node
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, node;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        node = nodes[nodeId];
        dx = -node.x;
        dy = -node.y;
        distance = Math.sqrt(dx * dx + dy * dy);

        this._calculateForces(distance, dx, dy, forces, node);
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {object<Node.id, vis.Node>} forces
     * @param {Node} node
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
      forces[node.id].x = dx * gravityForce;
      forces[node.id].y = dy * gravityForce;
    }
  }]);

  return CentralGravitySolver;
}();

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @augments BarnesHutSolver
 */

var ForceAtlas2BasedRepulsionSolver = /*#__PURE__*/function (_BarnesHutSolver) {
  _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver);

  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
    var _this;

    _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);

    _this = _super.call(this, body, physicsBody, options);
    _this._rng = Alea("FORCE ATLAS 2 BASED REPULSION SOLVER");
    return _this;
  }
  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {Node} node
   * @param {object} parentBranch
   * @private
   */


  _createClass(ForceAtlas2BasedRepulsionSolver, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1 * this._rng();
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      }

      var degree = node.edges.length + 1; // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce

      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
  }]);

  return ForceAtlas2BasedRepulsionSolver;
}(BarnesHutSolver);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @augments CentralGravitySolver
 */

var ForceAtlas2BasedCentralGravitySolver = /*#__PURE__*/function (_CentralGravitySolver) {
  _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver);

  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
    _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);

    return _super.call(this, body, physicsBody, options);
  }
  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {object<Node.id, Node>} forces
   * @param {Node} node
   * @private
   */


  _createClass(ForceAtlas2BasedCentralGravitySolver, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      if (distance > 0) {
        var degree = node.edges.length + 1;
        var gravityForce = this.options.centralGravity * degree * node.options.mass;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }
  }]);

  return ForceAtlas2BasedCentralGravitySolver;
}(CentralGravitySolver);

/**
 * The physics engine
 */

var PhysicsEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function PhysicsEngine(body) {
    _classCallCheck(this, PhysicsEngine);

    this.body = body;
    this.physicsBody = {
      physicsNodeIndices: [],
      physicsEdgeIndices: [],
      forces: {},
      velocities: {}
    };
    this.physicsEnabled = true;
    this.simulationInterval = 1000 / 60;
    this.requiresTimeout = true;
    this.previousStates = {};
    this.referenceState = {};
    this.freezeCache = {};
    this.renderTimer = undefined; // parameters for the adaptive timestep

    this.adaptiveTimestep = false;
    this.adaptiveTimestepEnabled = false;
    this.adaptiveCounter = 0;
    this.adaptiveInterval = 3;
    this.stabilized = false;
    this.startedStabilization = false;
    this.stabilizationIterations = 0;
    this.ready = false; // will be set to true if the stabilize
    // default options

    this.options = {};
    this.defaultOptions = {
      enabled: true,
      barnesHut: {
        theta: 0.5,
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 95,
        springConstant: 0.04,
        damping: 0.09,
        avoidOverlap: 0
      },
      forceAtlas2Based: {
        theta: 0.5,
        gravitationalConstant: -50,
        centralGravity: 0.01,
        springConstant: 0.08,
        springLength: 100,
        damping: 0.4,
        avoidOverlap: 0
      },
      repulsion: {
        centralGravity: 0.2,
        springLength: 200,
        springConstant: 0.05,
        nodeDistance: 100,
        damping: 0.09,
        avoidOverlap: 0
      },
      hierarchicalRepulsion: {
        centralGravity: 0.0,
        springLength: 100,
        springConstant: 0.01,
        nodeDistance: 120,
        damping: 0.09
      },
      maxVelocity: 50,
      minVelocity: 0.75,
      // px/s
      solver: "barnesHut",
      stabilization: {
        enabled: true,
        iterations: 1000,
        // maximum number of iteration to stabilize
        updateInterval: 50,
        onlyDynamicEdges: false,
        fit: true
      },
      timestep: 0.5,
      adaptiveTimestep: true,
      wind: {
        x: 0,
        y: 0
      }
    };

    assign$2(this.options, this.defaultOptions);

    this.timestep = 0.5;
    this.layoutFailed = false;
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(PhysicsEngine, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on("initPhysics", function () {
        _this.initPhysics();
      });
      this.body.emitter.on("_layoutFailed", function () {
        _this.layoutFailed = true;
      });
      this.body.emitter.on("resetPhysics", function () {
        _this.stopSimulation();

        _this.ready = false;
      });
      this.body.emitter.on("disablePhysics", function () {
        _this.physicsEnabled = false;

        _this.stopSimulation();
      });
      this.body.emitter.on("restorePhysics", function () {
        _this.setOptions(_this.options);

        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("startSimulation", function () {
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("stopSimulation", function () {
        _this.stopSimulation();
      });
      this.body.emitter.on("destroy", function () {
        _this.stopSimulation(false);

        _this.body.emitter.off();
      });
      this.body.emitter.on("_dataChanged", function () {
        // Nodes and/or edges have been added or removed, update shortcut lists.
        _this.updatePhysicsData();
      }); // debug: show forces
      // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
    }
    /**
     * set the physics options
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        if (options === false) {
          this.options.enabled = false;
          this.physicsEnabled = false;
          this.stopSimulation();
        } else if (options === true) {
          this.options.enabled = true;
          this.physicsEnabled = true;
          this.startSimulation();
        } else {
          this.physicsEnabled = true;
          selectiveNotDeepExtend(["stabilization"], this.options, options);
          mergeOptions(this.options, options, "stabilization");

          if (options.enabled === undefined) {
            this.options.enabled = true;
          }

          if (this.options.enabled === false) {
            this.physicsEnabled = false;
            this.stopSimulation();
          }

          var wind = this.options.wind;

          if (wind) {
            if (typeof wind.x !== "number" || isNan(wind.x)) {
              wind.x = 0;
            }

            if (typeof wind.y !== "number" || isNan(wind.y)) {
              wind.y = 0;
            }
          } // set the timestep


          this.timestep = this.options.timestep;
        }
      }

      this.init();
    }
    /**
     * configure the engine.
     */

  }, {
    key: "init",
    value: function init() {
      var options;

      if (this.options.solver === "forceAtlas2Based") {
        options = this.options.forceAtlas2Based;
        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "repulsion") {
        options = this.options.repulsion;
        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "hierarchicalRepulsion") {
        options = this.options.hierarchicalRepulsion;
        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else {
        // barnesHut
        options = this.options.barnesHut;
        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      }

      this.modelOptions = options;
    }
    /**
     * initialize the engine
     */

  }, {
    key: "initPhysics",
    value: function initPhysics() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        if (this.options.stabilization.enabled === true) {
          this.stabilize();
        } else {
          this.stabilized = false;
          this.ready = true;
          this.body.emitter.emit("fit", {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom

          this.startSimulation();
        }
      } else {
        this.ready = true;
        this.body.emitter.emit("fit");
      }
    }
    /**
     * Start the simulation
     */

  }, {
    key: "startSimulation",
    value: function startSimulation() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        this.stabilized = false; // when visible, adaptivity is disabled.

        this.adaptiveTimestep = false; // this sets the width of all nodes initially which could be required for the avoidOverlap

        this.body.emitter.emit("_resizeNodes");

        if (this.viewFunction === undefined) {
          var _context;

          this.viewFunction = bind$6(_context = this.simulationStep).call(_context, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      } else {
        this.body.emitter.emit("_redraw");
      }
    }
    /**
     * Stop the simulation, force stabilization.
     *
     * @param {boolean} [emit=true]
     */

  }, {
    key: "stopSimulation",
    value: function stopSimulation() {
      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.stabilized = true;

      if (emit === true) {
        this._emitStabilized();
      }

      if (this.viewFunction !== undefined) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.viewFunction = undefined;

        if (emit === true) {
          this.body.emitter.emit("_stopRendering");
        }
      }
    }
    /**
     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
     *
     */

  }, {
    key: "simulationStep",
    value: function simulationStep() {
      // check if the physics have settled
      var startTime = now$1();

      this.physicsTick();
      var physicsTime = now$1() - startTime; // run double speed if it is a little graph

      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
        this.physicsTick(); // this makes sure there is no jitter. The decision is taken once to run it at double speed.

        this.runDoubleSpeed = true;
      }

      if (this.stabilized === true) {
        this.stopSimulation();
      }
    }
    /**
     * trigger the stabilized event.
     *
     * @param {number} [amountOfIterations=this.stabilizationIterations]
     * @private
     */

  }, {
    key: "_emitStabilized",
    value: function _emitStabilized() {
      var _this2 = this;

      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;

      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
        setTimeout$1(function () {
          _this2.body.emitter.emit("stabilized", {
            iterations: amountOfIterations
          });

          _this2.startedStabilization = false;
          _this2.stabilizationIterations = 0;
        }, 0);
      }
    }
    /**
     * Calculate the forces for one physics iteration and move the nodes.
     *
     * @private
     */

  }, {
    key: "physicsStep",
    value: function physicsStep() {
      this.gravitySolver.solve();
      this.nodesSolver.solve();
      this.edgesSolver.solve();
      this.moveNodes();
    }
    /**
     * Make dynamic adjustments to the timestep, based on current state.
     *
     * Helper function for physicsTick().
     *
     * @private
     */

  }, {
    key: "adjustTimeStep",
    value: function adjustTimeStep() {
      var factor = 1.2; // Factor for increasing the timestep on success.
      // we compare the two steps. if it is acceptable we double the step.

      if (this._evaluateStepQuality() === true) {
        this.timestep = factor * this.timestep;
      } else {
        // if not, we decrease the step to a minimum of the options timestep.
        // if the decreased timestep is smaller than the options step, we do not reset the counter
        // we assume that the options timestep is stable enough.
        if (this.timestep / factor < this.options.timestep) {
          this.timestep = this.options.timestep;
        } else {
          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
          // that large instabilities do not form.
          this.adaptiveCounter = -1; // check again next iteration

          this.timestep = Math.max(this.options.timestep, this.timestep / factor);
        }
      }
    }
    /**
     * A single simulation step (or 'tick') in the physics simulation
     *
     * @private
     */

  }, {
    key: "physicsTick",
    value: function physicsTick() {
      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.


      if (this.stabilized === true) return; // adaptivity means the timestep adapts to the situation, only applicable for stabilization

      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
        // timestep remains stable for "interval" iterations.
        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;

        if (doAdaptive) {
          // first the big step and revert.
          this.timestep = 2 * this.timestep;
          this.physicsStep();
          this.revert(); // saves the reference state
          // now the normal step. Since this is the last step, it is the more stable one and we will take this.

          this.timestep = 0.5 * this.timestep; // since it's half the step, we do it twice.

          this.physicsStep();
          this.physicsStep();
          this.adjustTimeStep();
        } else {
          this.physicsStep(); // normal step, keeping timestep constant
        }

        this.adaptiveCounter += 1;
      } else {
        // case for the static timestep, we reset it to the one in options and take a normal step.
        this.timestep = this.options.timestep;
        this.physicsStep();
      }

      if (this.stabilized === true) this.revert();
      this.stabilizationIterations++;
    }
    /**
     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
     *
     * @private
     */

  }, {
    key: "updatePhysicsData",
    value: function updatePhysicsData() {
      this.physicsBody.forces = {};
      this.physicsBody.physicsNodeIndices = [];
      this.physicsBody.physicsEdgeIndices = [];
      var nodes = this.body.nodes;
      var edges = this.body.edges; // get node indices for physics

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (nodes[nodeId].options.physics === true) {
            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
          }
        }
      } // get edge indices for physics


      for (var edgeId in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
          if (edges[edgeId].options.physics === true) {
            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
          }
        }
      } // get the velocity and the forces vector


      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var _nodeId = this.physicsBody.physicsNodeIndices[i];
        this.physicsBody.forces[_nodeId] = {
          x: 0,
          y: 0
        }; // forces can be reset because they are recalculated. Velocities have to persist.

        if (this.physicsBody.velocities[_nodeId] === undefined) {
          this.physicsBody.velocities[_nodeId] = {
            x: 0,
            y: 0
          };
        }
      } // clean deleted nodes from the velocity vector


      for (var _nodeId2 in this.physicsBody.velocities) {
        if (nodes[_nodeId2] === undefined) {
          delete this.physicsBody.velocities[_nodeId2];
        }
      }
    }
    /**
     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
     */

  }, {
    key: "revert",
    value: function revert() {
      var nodeIds = keys$4(this.previousStates);

      var nodes = this.body.nodes;
      var velocities = this.physicsBody.velocities;
      this.referenceState = {};

      for (var i = 0; i < nodeIds.length; i++) {
        var nodeId = nodeIds[i];

        if (nodes[nodeId] !== undefined) {
          if (nodes[nodeId].options.physics === true) {
            this.referenceState[nodeId] = {
              positions: {
                x: nodes[nodeId].x,
                y: nodes[nodeId].y
              }
            };
            velocities[nodeId].x = this.previousStates[nodeId].vx;
            velocities[nodeId].y = this.previousStates[nodeId].vy;
            nodes[nodeId].x = this.previousStates[nodeId].x;
            nodes[nodeId].y = this.previousStates[nodeId].y;
          }
        } else {
          delete this.previousStates[nodeId];
        }
      }
    }
    /**
     * This compares the reference state to the current state
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_evaluateStepQuality",
    value: function _evaluateStepQuality() {
      var dx, dy, dpos;
      var nodes = this.body.nodes;
      var reference = this.referenceState;
      var posThreshold = 0.3;

      for (var nodeId in this.referenceState) {
        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== undefined) {
          dx = nodes[nodeId].x - reference[nodeId].positions.x;
          dy = nodes[nodeId].y - reference[nodeId].positions.y;
          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

          if (dpos > posThreshold) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * move the nodes one timestep and check if they are stabilized
     */

  }, {
    key: "moveNodes",
    value: function moveNodes() {
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var maxNodeVelocity = 0;
      var averageNodeVelocity = 0; // the velocity threshold (energy in the system) for the adaptivity toggle

      var velocityAdaptiveThreshold = 5;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];

        var nodeVelocity = this._performStep(nodeId); // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized


        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
        averageNodeVelocity += nodeVelocity;
      } // evaluating the stabilized and adaptiveTimestepEnabled conditions


      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
      this.stabilized = maxNodeVelocity < this.options.minVelocity;
    }
    /**
     * Calculate new velocity for a coordinate direction
     *
     * @param {number} v  velocity for current coordinate
     * @param {number} f  regular force for current coordinate
     * @param {number} m  mass of current node
     * @returns {number} new velocity for current coordinate
     * @private
     */

  }, {
    key: "calculateComponentVelocity",
    value: function calculateComponentVelocity(v, f, m) {
      var df = this.modelOptions.damping * v; // damping force

      var a = (f - df) / m; // acceleration

      v += a * this.timestep; // Put a limit on the velocities if it is really high

      var maxV = this.options.maxVelocity || 1e9;

      if (Math.abs(v) > maxV) {
        v = v > 0 ? maxV : -maxV;
      }

      return v;
    }
    /**
     * Perform the actual step
     *
     * @param {Node.id} nodeId
     * @returns {number} the new velocity of given node
     * @private
     */

  }, {
    key: "_performStep",
    value: function _performStep(nodeId) {
      var node = this.body.nodes[nodeId];
      var force = this.physicsBody.forces[nodeId];

      if (this.options.wind) {
        force.x += this.options.wind.x;
        force.y += this.options.wind.y;
      }

      var velocity = this.physicsBody.velocities[nodeId]; // store the state so we can revert

      this.previousStates[nodeId] = {
        x: node.x,
        y: node.y,
        vx: velocity.x,
        vy: velocity.y
      };

      if (node.options.fixed.x === false) {
        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
        node.x += velocity.x * this.timestep;
      } else {
        force.x = 0;
        velocity.x = 0;
      }

      if (node.options.fixed.y === false) {
        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
        node.y += velocity.y * this.timestep;
      } else {
        force.y = 0;
        velocity.y = 0;
      }

      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
      return totalVelocity;
    }
    /**
     * When initializing and stabilizing, we can freeze nodes with a predefined position.
     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
     *
     * @private
     */

  }, {
    key: "_freezeNodes",
    value: function _freezeNodes() {
      var nodes = this.body.nodes;

      for (var id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          if (nodes[id].x && nodes[id].y) {
            var fixed = nodes[id].options.fixed;
            this.freezeCache[id] = {
              x: fixed.x,
              y: fixed.y
            };
            fixed.x = true;
            fixed.y = true;
          }
        }
      }
    }
    /**
     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
     *
     * @private
     */

  }, {
    key: "_restoreFrozenNodes",
    value: function _restoreFrozenNodes() {
      var nodes = this.body.nodes;

      for (var id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          if (this.freezeCache[id] !== undefined) {
            nodes[id].options.fixed.x = this.freezeCache[id].x;
            nodes[id].options.fixed.y = this.freezeCache[id].y;
          }
        }
      }

      this.freezeCache = {};
    }
    /**
     * Find a stable position for all nodes
     *
     * @param {number} [iterations=this.options.stabilization.iterations]
     */

  }, {
    key: "stabilize",
    value: function stabilize() {
      var _this3 = this;

      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;

      if (typeof iterations !== "number") {
        iterations = this.options.stabilization.iterations;
        console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
      }

      if (this.physicsBody.physicsNodeIndices.length === 0) {
        this.ready = true;
        return;
      } // enable adaptive timesteps


      this.adaptiveTimestep = this.options.adaptiveTimestep; // this sets the width of all nodes initially which could be required for the avoidOverlap

      this.body.emitter.emit("_resizeNodes");
      this.stopSimulation(); // stop the render loop

      this.stabilized = false; // block redraw requests

      this.body.emitter.emit("_blockRedraw");
      this.targetIterations = iterations; // start the stabilization

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._freezeNodes();
      }

      this.stabilizationIterations = 0;

      setTimeout$1(function () {
        return _this3._stabilizationBatch();
      }, 0);
    }
    /**
     * If not already stabilizing, start it and emit a start event.
     *
     * @returns {boolean} true if stabilization started with this call
     * @private
     */

  }, {
    key: "_startStabilizing",
    value: function _startStabilizing() {
      if (this.startedStabilization === true) return false;
      this.body.emitter.emit("startStabilizing");
      this.startedStabilization = true;
      return true;
    }
    /**
     * One batch of stabilization
     *
     * @private
     */

  }, {
    key: "_stabilizationBatch",
    value: function _stabilizationBatch() {
      var _this4 = this;

      var running = function running() {
        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
      };

      var sendProgress = function sendProgress() {
        _this4.body.emitter.emit("stabilizationProgress", {
          iterations: _this4.stabilizationIterations,
          total: _this4.targetIterations
        });
      };

      if (this._startStabilizing()) {
        sendProgress(); // Ensure that there is at least one start event.
      }

      var count = 0;

      while (running() && count < this.options.stabilization.updateInterval) {
        this.physicsTick();
        count++;
      }

      sendProgress();

      if (running()) {
        var _context2;

        setTimeout$1(bind$6(_context2 = this._stabilizationBatch).call(_context2, this), 0);
      } else {
        this._finalizeStabilization();
      }
    }
    /**
     * Wrap up the stabilization, fit and emit the events.
     *
     * @private
     */

  }, {
    key: "_finalizeStabilization",
    value: function _finalizeStabilization() {
      this.body.emitter.emit("_allowRedraw");

      if (this.options.stabilization.fit === true) {
        this.body.emitter.emit("fit");
      }

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._restoreFrozenNodes();
      }

      this.body.emitter.emit("stabilizationIterationsDone");
      this.body.emitter.emit("_requestRedraw");

      if (this.stabilized === true) {
        this._emitStabilized();
      } else {
        this.startSimulation();
      }

      this.ready = true;
    } //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * Debug function that display arrows for the forces currently active in the network.
     *
     * Use this when debugging only.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: "_drawForces",
    value: function _drawForces(ctx) {
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var index = this.physicsBody.physicsNodeIndices[i];
        var node = this.body.nodes[index];
        var force = this.physicsBody.forces[index];
        var factor = 20;
        var colorFactor = 0.03;
        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
        var size = Math.min(Math.max(5, forceSize), 15);
        var arrowSize = 3 * size;
        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
        var point = {
          x: node.x + factor * force.x,
          y: node.y + factor * force.y
        };
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
        var angle = Math.atan2(force.y, force.x);
        ctx.fillStyle = color;
        EndPoints.draw(ctx, {
          type: "arrow",
          point: point,
          angle: angle,
          length: arrowSize
        });

        fill(ctx).call(ctx);
      }
    }
  }]);

  return PhysicsEngine;
}();

/**
 * Utility Class
 */

var NetworkUtil = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function NetworkUtil() {
    _classCallCheck(this, NetworkUtil);
  }
  /**
   * Find the center position of the network considering the bounding boxes
   *
   * @param {Array.<Node>} allNodes
   * @param {Array.<Node>} [specificNodes=[]]
   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
   * @static
   */


  _createClass(NetworkUtil, null, [{
    key: "getRange",
    value: function getRange(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;

      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];

          if (minX > node.shape.boundingBox.left) {
            minX = node.shape.boundingBox.left;
          }

          if (maxX < node.shape.boundingBox.right) {
            maxX = node.shape.boundingBox.right;
          }

          if (minY > node.shape.boundingBox.top) {
            minY = node.shape.boundingBox.top;
          } // top is negative, bottom is positive


          if (maxY < node.shape.boundingBox.bottom) {
            maxY = node.shape.boundingBox.bottom;
          } // top is negative, bottom is positive

        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }

      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    }
    /**
     * Find the center position of the network
     *
     * @param {Array.<Node>} allNodes
     * @param {Array.<Node>} [specificNodes=[]]
     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
     * @static
     */

  }, {
    key: "getRangeCore",
    value: function getRangeCore(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;

      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];

          if (minX > node.x) {
            minX = node.x;
          }

          if (maxX < node.x) {
            maxX = node.x;
          }

          if (minY > node.y) {
            minY = node.y;
          } // top is negative, bottom is positive


          if (maxY < node.y) {
            maxY = node.y;
          } // top is negative, bottom is positive

        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }

      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    }
    /**
     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
     * @returns {{x: number, y: number}}
     * @static
     */

  }, {
    key: "findCenter",
    value: function findCenter(range) {
      return {
        x: 0.5 * (range.maxX + range.minX),
        y: 0.5 * (range.maxY + range.minY)
      };
    }
    /**
     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
     *
     * @param {vis.Item} item
     * @param {'node'|undefined} type
     * @returns {{}}
     * @static
     */

  }, {
    key: "cloneOptions",
    value: function cloneOptions(item, type) {
      var clonedOptions = {};

      if (type === undefined || type === "node") {
        deepExtend(clonedOptions, item.options, true);
        clonedOptions.x = item.x;
        clonedOptions.y = item.y;
        clonedOptions.amountOfConnections = item.edges.length;
      } else {
        deepExtend(clonedOptions, item.options, true);
      }

      return clonedOptions;
    }
  }]);

  return NetworkUtil;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Cluster is a special Node that allows a group of Nodes positioned closely together
 * to be represented by a single Cluster Node.
 *
 * @augments Node
 */

var Cluster = /*#__PURE__*/function (_Node) {
  _inherits(Cluster, _Node);

  var _super = _createSuper$1(Cluster);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Array.<HTMLImageElement>}imagelist
   * @param {Array} grouplist
   * @param {object} globalOptions
   * @param {object} defaultOptions     Global default options for nodes
   */
  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    var _this;

    _classCallCheck(this, Cluster);

    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions);
    _this.isCluster = true;
    _this.containedNodes = {};
    _this.containedEdges = {};
    return _this;
  }
  /**
   * Transfer child cluster data to current and disconnect the child cluster.
   *
   * Please consult the header comment in 'Clustering.js' for the fields set here.
   *
   * @param {string|number} childClusterId  id of child cluster to open
   */


  _createClass(Cluster, [{
    key: "_openChildCluster",
    value: function _openChildCluster(childClusterId) {
      var _this2 = this;

      var childCluster = this.body.nodes[childClusterId];

      if (this.containedNodes[childClusterId] === undefined) {
        throw new Error("node with id: " + childClusterId + " not in current cluster");
      }

      if (!childCluster.isCluster) {
        throw new Error("node with id: " + childClusterId + " is not a cluster");
      } // Disconnect child cluster from current cluster


      delete this.containedNodes[childClusterId];
      forEach$1(childCluster.edges, function (edge) {
        delete _this2.containedEdges[edge.id];
      }); // Transfer nodes and edges

      forEach$1(childCluster.containedNodes, function (node, nodeId) {
        _this2.containedNodes[nodeId] = node;
      });
      childCluster.containedNodes = {};
      forEach$1(childCluster.containedEdges, function (edge, edgeId) {
        _this2.containedEdges[edgeId] = edge;
      });
      childCluster.containedEdges = {}; // Transfer edges within cluster edges which are clustered

      forEach$1(childCluster.edges, function (clusterEdge) {
        forEach$1(_this2.edges, function (parentClusterEdge) {
          var _context, _context2;

          // Assumption: a clustered edge can only be present in a single clustering edge
          // Not tested here
          var index = indexOf(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);

          if (index === -1) return;
          forEach$1(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {
            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId); // Maintain correct bookkeeping for transferred edge

            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
          }); // Remove cluster edge from parent cluster edge

          splice$1(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index, 1);
        });
      });
      childCluster.edges = [];
    }
  }]);

  return Cluster;
}(Node);

/**
 * The clustering engine
 */

var ClusterEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function ClusterEngine(body) {
    var _this = this;

    _classCallCheck(this, ClusterEngine);

    this.body = body;
    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}

    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge

    this.options = {};
    this.defaultOptions = {};

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("_resetData", function () {
      _this.clusteredNodes = {};
      _this.clusteredEdges = {};
    });
  }
  /**
   *
   * @param {number} hubsize
   * @param {object} options
   */


  _createClass(ClusterEngine, [{
    key: "clusterByHubsize",
    value: function clusterByHubsize(hubsize, options) {
      if (hubsize === undefined) {
        hubsize = this._getHubSize();
      } else if (_typeof(hubsize) === "object") {
        options = this._checkOptions(hubsize);
        hubsize = this._getHubSize();
      }

      var nodesToCluster = [];

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];

        if (node.edges.length >= hubsize) {
          nodesToCluster.push(node.id);
        }
      }

      for (var _i = 0; _i < nodesToCluster.length; _i++) {
        this.clusterByConnection(nodesToCluster[_i], options, true);
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * loop over all nodes, check if they adhere to the condition and cluster if needed.
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "cluster",
    value: function cluster() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (options.joinCondition === undefined) {
        throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
      } // check if the options object is fine, append if needed


      options = this._checkOptions(options);
      var childNodesObj = {};
      var childEdgesObj = {}; // collect the nodes that will be in the cluster

      forEach$1(this.body.nodes, function (node, nodeId) {
        if (node.options && options.joinCondition(node.options) === true) {
          childNodesObj[nodeId] = node; // collect the edges that will be in the cluster

          forEach$1(node.edges, function (edge) {
            if (_this2.clusteredEdges[edge.id] === undefined) {
              childEdgesObj[edge.id] = edge;
            }
          });
        }
      });

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only X edges
     *
     * @param {number} edgeCount
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterByEdgeCount",
    value: function clusterByEdgeCount(edgeCount, options) {
      var _this3 = this;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      options = this._checkOptions(options);
      var clusters = [];
      var usedNodes = {};
      var edge, edges, relevantEdgeCount; // collect the nodes that will be in the cluster

      var _loop = function _loop(i) {
        var childNodesObj = {};
        var childEdgesObj = {};
        var nodeId = _this3.body.nodeIndices[i];
        var node = _this3.body.nodes[nodeId]; // if this node is already used in another cluster this session, we do not have to re-evaluate it.

        if (usedNodes[nodeId] === undefined) {
          relevantEdgeCount = 0;
          edges = [];

          for (var j = 0; j < node.edges.length; j++) {
            edge = node.edges[j];

            if (_this3.clusteredEdges[edge.id] === undefined) {
              if (edge.toId !== edge.fromId) {
                relevantEdgeCount++;
              }

              edges.push(edge);
            }
          } // this node qualifies, we collect its neighbours to start the clustering process.


          if (relevantEdgeCount === edgeCount) {
            var checkJoinCondition = function checkJoinCondition(node) {
              if (options.joinCondition === undefined || options.joinCondition === null) {
                return true;
              }

              var clonedOptions = NetworkUtil.cloneOptions(node);
              return options.joinCondition(clonedOptions);
            };

            var gatheringSuccessful = true;

            for (var _j = 0; _j < edges.length; _j++) {
              edge = edges[_j];

              var childNodeId = _this3._getConnectedId(edge, nodeId); // add the nodes to the list by the join condition.


              if (checkJoinCondition(node)) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[nodeId] = node;
                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                usedNodes[nodeId] = true;
              } else {
                // this node does not qualify after all.
                gatheringSuccessful = false;
                break;
              }
            } // add to the cluster queue


            if (keys$4(childNodesObj).length > 0 && keys$4(childEdgesObj).length > 0 && gatheringSuccessful === true) {
              /**
               * Search for cluster data that contains any of the node id's
               *
               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition
               */
              var findClusterData = function findClusterData() {
                for (var n = 0; n < clusters.length; ++n) {
                  // Search for a cluster containing any of the node id's
                  for (var m in childNodesObj) {
                    if (clusters[n].nodes[m] !== undefined) {
                      return clusters[n];
                    }
                  }
                }

                return undefined;
              }; // If any of the found nodes is part of a cluster found in this method,
              // add the current values to that cluster


              var foundCluster = findClusterData();

              if (foundCluster !== undefined) {
                // Add nodes to found cluster if not present
                for (var m in childNodesObj) {
                  if (foundCluster.nodes[m] === undefined) {
                    foundCluster.nodes[m] = childNodesObj[m];
                  }
                } // Add edges to found cluster, if not present


                for (var _m in childEdgesObj) {
                  if (foundCluster.edges[_m] === undefined) {
                    foundCluster.edges[_m] = childEdgesObj[_m];
                  }
                }
              } else {
                // Create a new cluster group
                clusters.push({
                  nodes: childNodesObj,
                  edges: childEdgesObj
                });
              }
            }
          }
        }
      };

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        _loop(i);
      }

      for (var _i2 = 0; _i2 < clusters.length; _i2++) {
        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);
      }

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Cluster all nodes in the network that have only 1 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterOutliers",
    value: function clusterOutliers(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.clusterByEdgeCount(1, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only 2 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterBridges",
    value: function clusterBridges(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.clusterByEdgeCount(2, options, refreshData);
    }
    /**
     * suck all connected nodes of a node into the node.
     *
     * @param {Node.id} nodeId
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterByConnection",
    value: function clusterByConnection(nodeId, options) {
      var _context;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (nodeId === undefined) {
        throw new Error("No nodeId supplied to clusterByConnection!");
      }

      if (this.body.nodes[nodeId] === undefined) {
        throw new Error("The nodeId given to clusterByConnection does not exist!");
      }

      var node = this.body.nodes[nodeId];
      options = this._checkOptions(options, node);

      if (options.clusterNodeProperties.x === undefined) {
        options.clusterNodeProperties.x = node.x;
      }

      if (options.clusterNodeProperties.y === undefined) {
        options.clusterNodeProperties.y = node.y;
      }

      if (options.clusterNodeProperties.fixed === undefined) {
        options.clusterNodeProperties.fixed = {};
        options.clusterNodeProperties.fixed.x = node.options.fixed.x;
        options.clusterNodeProperties.fixed.y = node.options.fixed.y;
      }

      var childNodesObj = {};
      var childEdgesObj = {};
      var parentNodeId = node.id;
      var parentClonedOptions = NetworkUtil.cloneOptions(node);
      childNodesObj[parentNodeId] = node; // collect the nodes that will be in the cluster

      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];

        if (this.clusteredEdges[edge.id] === undefined) {
          var childNodeId = this._getConnectedId(edge, parentNodeId); // if the child node is not in a cluster


          if (this.clusteredNodes[childNodeId] === undefined) {
            if (childNodeId !== parentNodeId) {
              if (options.joinCondition === undefined) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[childNodeId] = this.body.nodes[childNodeId];
              } else {
                // clone the options and insert some additional parameters that could be interesting.
                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);

                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                }
              }
            } else {
              // swallow the edge if it is self-referencing.
              childEdgesObj[edge.id] = edge;
            }
          }
        }
      }

      var childNodeIDs = map$3(_context = keys$4(childNodesObj)).call(_context, function (childNode) {
        return childNodesObj[childNode].id;
      });

      for (var childNodeKey in childNodesObj) {
        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;
        var childNode = childNodesObj[childNodeKey];

        for (var y = 0; y < childNode.edges.length; y++) {
          var childEdge = childNode.edges[y];

          if (indexOf(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {
            childEdgesObj[childEdge.id] = childEdge;
          }
        }
      }

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * This function creates the edges that will be attached to the cluster
     * It looks for edges that are connected to the nodes from the "outside' of the cluster.
     *
     * @param {{Node.id: vis.Node}} childNodesObj
     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
     * @param {object} clusterNodeProperties
     * @param {object} clusterEdgeProperties
     * @private
     */

  }, {
    key: "_createClusterEdges",
    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
      var edge, childNodeId, childNode, toId, fromId, otherNodeId; // loop over all child nodes and their edges to find edges going out of the cluster
      // these edges will be replaced by clusterEdges.

      var childKeys = keys$4(childNodesObj);

      var createEdges = [];

      for (var i = 0; i < childKeys.length; i++) {
        childNodeId = childKeys[i];
        childNode = childNodesObj[childNodeId]; // construct new edges from the cluster to others

        for (var j = 0; j < childNode.edges.length; j++) {
          edge = childNode.edges[j]; // we only handle edges that are visible to the system, not the disabled ones from the clustering process.

          if (this.clusteredEdges[edge.id] === undefined) {
            // self-referencing edges will be added to the "hidden" list
            if (edge.toId == edge.fromId) {
              childEdgesObj[edge.id] = edge;
            } else {
              // set up the from and to.
              if (edge.toId == childNodeId) {
                // this is a double equals because ints and strings can be interchanged here.
                toId = clusterNodeProperties.id;
                fromId = edge.fromId;
                otherNodeId = fromId;
              } else {
                toId = edge.toId;
                fromId = clusterNodeProperties.id;
                otherNodeId = toId;
              }
            } // Only edges from the cluster outwards are being replaced.


            if (childNodesObj[otherNodeId] === undefined) {
              createEdges.push({
                edge: edge,
                fromId: fromId,
                toId: toId
              });
            }
          }
        }
      } //
      // Here we actually create the replacement edges.
      //
      // We could not do this in the loop above as the creation process
      // would add an edge to the edges array we are iterating over.
      //
      // NOTE: a clustered edge can have multiple base edges!
      //


      var newEdges = [];
      /**
       * Find a cluster edge which matches the given created edge.
       *
       * @param {vis.Edge} createdEdge
       * @returns {vis.Edge}
       */

      var getNewEdge = function getNewEdge(createdEdge) {
        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
          var newEdge = newEdges[_j2]; // We replace both to and from edges with a single cluster edge

          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;
          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;

          if (matchToDirection || matchFromDirection) {
            return newEdge;
          }
        }

        return null;
      };

      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
        var createdEdge = createEdges[_j3];
        var _edge = createdEdge.edge;
        var newEdge = getNewEdge(createdEdge);

        if (newEdge === null) {
          // Create a clustered edge for this connection
          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
          newEdges.push(newEdge);
        } else {
          newEdge.clusteringEdgeReplacingIds.push(_edge.id);
        } // also reference the new edge in the old edge


        this.body.edges[_edge.id].edgeReplacedById = newEdge.id; // hide the replaced edge

        this._backupEdgeOptions(_edge);

        _edge.setOptions({
          physics: false
        });
      }
    }
    /**
     * This function checks the options that can be supplied to the different cluster functions
     * for certain fields and inserts defaults if needed
     *
     * @param {object} options
     * @returns {*}
     * @private
     */

  }, {
    key: "_checkOptions",
    value: function _checkOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.clusterEdgeProperties === undefined) {
        options.clusterEdgeProperties = {};
      }

      if (options.clusterNodeProperties === undefined) {
        options.clusterNodeProperties = {};
      }

      return options;
    }
    /**
     *
     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
     * @param {object}    childEdgesObj         | object with edge objects, id as keys
     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
     * @param {boolean}   refreshData | when true, do not wrap up
     * @private
     */

  }, {
    key: "_cluster",
    value: function _cluster(childNodesObj, childEdgesObj, options) {
      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      // Remove nodes which are already clustered
      var tmpNodesToRemove = [];

      for (var nodeId in childNodesObj) {
        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {
          if (this.clusteredNodes[nodeId] !== undefined) {
            tmpNodesToRemove.push(nodeId);
          }
        }
      }

      for (var n = 0; n < tmpNodesToRemove.length; ++n) {
        delete childNodesObj[tmpNodesToRemove[n]];
      } // kill condition: no nodes don't bother


      if (keys$4(childNodesObj).length == 0) {
        return;
      } // allow clusters of 1 if options allow


      if (keys$4(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
        return;
      }

      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties); // construct the clusterNodeProperties

      if (options.processProperties !== undefined) {
        // get the childNode options
        var childNodesOptions = [];

        for (var _nodeId in childNodesObj) {
          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {
            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);
            childNodesOptions.push(clonedOptions);
          }
        } // get cluster properties based on childNodes


        var childEdgesOptions = [];

        for (var edgeId in childEdgesObj) {
          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {
            // these cluster edges will be removed on creation of the cluster.
            if (edgeId.substr(0, 12) !== "clusterEdge:") {
              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");

              childEdgesOptions.push(_clonedOptions);
            }
          }
        }

        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);

        if (!clusterNodeProperties) {
          throw new Error("The processProperties function does not return properties!");
        }
      } // check if we have an unique id;


      if (clusterNodeProperties.id === undefined) {
        clusterNodeProperties.id = "cluster:" + v4();
      }

      var clusterId = clusterNodeProperties.id;

      if (clusterNodeProperties.label === undefined) {
        clusterNodeProperties.label = "cluster";
      } // give the clusterNode a position if it does not have one.


      var pos = undefined;

      if (clusterNodeProperties.x === undefined) {
        pos = this._getClusterPosition(childNodesObj);
        clusterNodeProperties.x = pos.x;
      }

      if (clusterNodeProperties.y === undefined) {
        if (pos === undefined) {
          pos = this._getClusterPosition(childNodesObj);
        }

        clusterNodeProperties.y = pos.y;
      } // force the ID to remain the same


      clusterNodeProperties.id = clusterId; // create the cluster Node
      // Note that allowSingleNodeCluster, if present, is stored in the options as well

      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
      clusterNode.containedNodes = childNodesObj;
      clusterNode.containedEdges = childEdgesObj; // cache a copy from the cluster edge properties if we have to reconnect others later on

      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties; // finally put the cluster node into global

      this.body.nodes[clusterNodeProperties.id] = clusterNode;

      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties); // set ID to undefined so no duplicates arise


      clusterNodeProperties.id = undefined; // wrap up

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: "_backupEdgeOptions",
    value: function _backupEdgeOptions(edge) {
      if (this.clusteredEdges[edge.id] === undefined) {
        this.clusteredEdges[edge.id] = {
          physics: edge.options.physics
        };
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: "_restoreEdge",
    value: function _restoreEdge(edge) {
      var originalOptions = this.clusteredEdges[edge.id];

      if (originalOptions !== undefined) {
        edge.setOptions({
          physics: originalOptions.physics
        });
        delete this.clusteredEdges[edge.id];
      }
    }
    /**
     * Check if a node is a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: "isCluster",
    value: function isCluster(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].isCluster === true;
      } else {
        console.error("Node does not exist.");
        return false;
      }
    }
    /**
     * get the position of the cluster node based on what's inside
     *
     * @param {object} childNodesObj    | object with node objects, id as keys
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: "_getClusterPosition",
    value: function _getClusterPosition(childNodesObj) {
      var childKeys = keys$4(childNodesObj);

      var minX = childNodesObj[childKeys[0]].x;
      var maxX = childNodesObj[childKeys[0]].x;
      var minY = childNodesObj[childKeys[0]].y;
      var maxY = childNodesObj[childKeys[0]].y;
      var node;

      for (var i = 1; i < childKeys.length; i++) {
        node = childNodesObj[childKeys[i]];
        minX = node.x < minX ? node.x : minX;
        maxX = node.x > maxX ? node.x : maxX;
        minY = node.y < minY ? node.y : minY;
        maxY = node.y > maxY ? node.y : maxY;
      }

      return {
        x: 0.5 * (minX + maxX),
        y: 0.5 * (minY + maxY)
      };
    }
    /**
     * Open a cluster by calling this function.
     *
     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
     * @param {object} options
     * @param {boolean} refreshData | wrap up afterwards if not true
     */

  }, {
    key: "openCluster",
    value: function openCluster(clusterNodeId, options) {
      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (clusterNodeId === undefined) {
        throw new Error("No clusterNodeId supplied to openCluster.");
      }

      var clusterNode = this.body.nodes[clusterNodeId];

      if (clusterNode === undefined) {
        throw new Error("The clusterNodeId supplied to openCluster does not exist.");
      }

      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {
        throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
      } // Check if current cluster is clustered itself


      var stack = this.findNode(clusterNodeId);
      var parentIndex = indexOf(stack).call(stack, clusterNodeId) - 1;

      if (parentIndex >= 0) {
        // Current cluster is clustered; transfer contained nodes and edges to parent
        var parentClusterNodeId = stack[parentIndex];
        var parentClusterNode = this.body.nodes[parentClusterNodeId]; // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged

        parentClusterNode._openChildCluster(clusterNodeId); // All components of child cluster node have been transferred. It can die now.


        delete this.body.nodes[clusterNodeId];

        if (refreshData === true) {
          this.body.emitter.emit("_dataChanged");
        }

        return;
      } // main body


      var containedNodes = clusterNode.containedNodes;
      var containedEdges = clusterNode.containedEdges; // allow the user to position the nodes after release.

      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === "function") {
        var positions = {};
        var clusterPosition = {
          x: clusterNode.x,
          y: clusterNode.y
        };

        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            var containedNode = this.body.nodes[nodeId];
            positions[nodeId] = {
              x: containedNode.x,
              y: containedNode.y
            };
          }
        }

        var newPositions = options.releaseFunction(clusterPosition, positions);

        for (var _nodeId2 in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {
            var _containedNode = this.body.nodes[_nodeId2];

            if (newPositions[_nodeId2] !== undefined) {
              _containedNode.x = newPositions[_nodeId2].x === undefined ? clusterNode.x : newPositions[_nodeId2].x;
              _containedNode.y = newPositions[_nodeId2].y === undefined ? clusterNode.y : newPositions[_nodeId2].y;
            }
          }
        }
      } else {
        // copy the position from the cluster
        forEach$1(containedNodes, function (containedNode) {
          // inherit position
          if (containedNode.options.fixed.x === false) {
            containedNode.x = clusterNode.x;
          }

          if (containedNode.options.fixed.y === false) {
            containedNode.y = clusterNode.y;
          }
        });
      } // release nodes


      for (var _nodeId3 in containedNodes) {
        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {
          var _containedNode2 = this.body.nodes[_nodeId3]; // inherit speed

          _containedNode2.vx = clusterNode.vx;
          _containedNode2.vy = clusterNode.vy;

          _containedNode2.setOptions({
            physics: true
          });

          delete this.clusteredNodes[_nodeId3];
        }
      } // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.


      var edgesToBeDeleted = [];

      for (var i = 0; i < clusterNode.edges.length; i++) {
        edgesToBeDeleted.push(clusterNode.edges[i]);
      } // actually handling the deleting.


      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {
        var edge = edgesToBeDeleted[_i3];

        var otherNodeId = this._getConnectedId(edge, clusterNodeId);

        var otherNode = this.clusteredNodes[otherNodeId];

        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
          var transferId = edge.clusteringEdgeReplacingIds[j];
          var transferEdge = this.body.edges[transferId];
          if (transferEdge === undefined) continue; // if the other node is in another cluster, we transfer ownership of this edge to the other cluster

          if (otherNode !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[otherNode.clusterId];
            otherCluster.containedEdges[transferEdge.id] = transferEdge; // delete local reference

            delete containedEdges[transferEdge.id]; // get to and from

            var fromId = transferEdge.fromId;
            var toId = transferEdge.toId;

            if (transferEdge.toId == otherNodeId) {
              toId = otherNode.clusterId;
            } else {
              fromId = otherNode.clusterId;
            } // create new cluster edge from the otherCluster


            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {
              hidden: false,
              physics: true
            });
          } else {
            this._restoreEdge(transferEdge);
          }
        }

        edge.remove();
      } // handle the releasing of the edges


      for (var edgeId in containedEdges) {
        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {
          this._restoreEdge(containedEdges[edgeId]);
        }
      } // remove clusterNode


      delete this.body.nodes[clusterNodeId];

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Cluster.id} clusterId
     * @returns {Array.<Node.id>}
     */

  }, {
    key: "getNodesInCluster",
    value: function getNodesInCluster(clusterId) {
      var nodesArray = [];

      if (this.isCluster(clusterId) === true) {
        var containedNodes = this.body.nodes[clusterId].containedNodes;

        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            nodesArray.push(this.body.nodes[nodeId].id);
          }
        }
      }

      return nodesArray;
    }
    /**
     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
     *
     * If a node can't be found in the chain, return an empty array.
     *
     * @param {string|number} nodeId
     * @returns {Array}
     */

  }, {
    key: "findNode",
    value: function findNode(nodeId) {
      var stack = [];
      var max = 100;
      var counter = 0;
      var node;

      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
        node = this.body.nodes[nodeId];
        if (node === undefined) return [];
        stack.push(node.id);
        nodeId = this.clusteredNodes[nodeId].clusterId;
        counter++;
      }

      node = this.body.nodes[nodeId];
      if (node === undefined) return [];
      stack.push(node.id);

      reverse(stack).call(stack);

      return stack;
    }
    /**
     * Using a clustered nodeId, update with the new options
     *
     * @param {Node.id} clusteredNodeId
     * @param {object} newOptions
     */

  }, {
    key: "updateClusteredNode",
    value: function updateClusteredNode(clusteredNodeId, newOptions) {
      if (clusteredNodeId === undefined) {
        throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
      }

      if (newOptions === undefined) {
        throw new Error("No newOptions supplied to updateClusteredNode.");
      }

      if (this.body.nodes[clusteredNodeId] === undefined) {
        throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
      }

      this.body.nodes[clusteredNodeId].setOptions(newOptions);
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Using a base edgeId, update all related clustered edges with the new options
     *
     * @param {vis.Edge.id} startEdgeId
     * @param {object} newOptions
     */

  }, {
    key: "updateEdge",
    value: function updateEdge(startEdgeId, newOptions) {
      if (startEdgeId === undefined) {
        throw new Error("No startEdgeId supplied to updateEdge.");
      }

      if (newOptions === undefined) {
        throw new Error("No newOptions supplied to updateEdge.");
      }

      if (this.body.edges[startEdgeId] === undefined) {
        throw new Error("The startEdgeId supplied to updateEdge does not exist.");
      }

      var allEdgeIds = this.getClusteredEdges(startEdgeId);

      for (var i = 0; i < allEdgeIds.length; i++) {
        var edge = this.body.edges[allEdgeIds[i]];
        edge.setOptions(newOptions);
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
     *
     * @param {vis.Edge.id} edgeId
     * @returns {Array.<vis.Edge.id>}
     */

  }, {
    key: "getClusteredEdges",
    value: function getClusteredEdges(edgeId) {
      var stack = [];
      var max = 100;
      var counter = 0;

      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {
        stack.push(this.body.edges[edgeId].id);
        edgeId = this.body.edges[edgeId].edgeReplacedById;
        counter++;
      }

      reverse(stack).call(stack);

      return stack;
    }
    /**
     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {vis.Edge.id} baseEdgeId
     *
     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
     */

  }, {
    key: "getBaseEdge",
    value: function getBaseEdge(clusteredEdgeId) {
      // Just kludge this by returning the first base edge id found
      return this.getBaseEdges(clusteredEdgeId)[0];
    }
    /**
     * Get all regular edges for this clustered edge id.
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
     */

  }, {
    key: "getBaseEdges",
    value: function getBaseEdges(clusteredEdgeId) {
      var IdsToHandle = [clusteredEdgeId];
      var doneIds = [];
      var foundIds = [];
      var max = 100;
      var counter = 0;

      while (IdsToHandle.length > 0 && counter < max) {
        var nextId = IdsToHandle.pop();
        if (nextId === undefined) continue; // Paranoia here and onwards

        var nextEdge = this.body.edges[nextId];
        if (nextEdge === undefined) continue;
        counter++;
        var replacingIds = nextEdge.clusteringEdgeReplacingIds;

        if (replacingIds === undefined) {
          // nextId is a base id
          foundIds.push(nextId);
        } else {
          // Another cluster edge, unravel this one as well
          for (var i = 0; i < replacingIds.length; ++i) {
            var replacingId = replacingIds[i]; // Don't add if already handled
            // TODO: never triggers; find a test-case which does

            if (indexOf(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || indexOf(doneIds).call(doneIds, replacingIds) !== -1) {
              continue;
            }

            IdsToHandle.push(replacingId);
          }
        }

        doneIds.push(nextId);
      }

      return foundIds;
    }
    /**
     * Get the Id the node is connected to
     *
     * @param {vis.Edge} edge
     * @param {Node.id} nodeId
     * @returns {*}
     * @private
     */

  }, {
    key: "_getConnectedId",
    value: function _getConnectedId(edge, nodeId) {
      if (edge.toId != nodeId) {
        return edge.toId;
      } else if (edge.fromId != nodeId) {
        return edge.fromId;
      } else {
        return edge.fromId;
      }
    }
    /**
     * We determine how many connections denote an important hub.
     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_getHubSize",
    value: function _getHubSize() {
      var average = 0;
      var averageSquared = 0;
      var hubCounter = 0;
      var largestHub = 0;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];

        if (node.edges.length > largestHub) {
          largestHub = node.edges.length;
        }

        average += node.edges.length;
        averageSquared += Math.pow(node.edges.length, 2);
        hubCounter += 1;
      }

      average = average / hubCounter;
      averageSquared = averageSquared / hubCounter;
      var variance = averageSquared - Math.pow(average, 2);
      var standardDeviation = Math.sqrt(variance);
      var hubThreshold = Math.floor(average + 2 * standardDeviation); // always have at least one to cluster

      if (hubThreshold > largestHub) {
        hubThreshold = largestHub;
      }

      return hubThreshold;
    }
    /**
     * Create an edge for the cluster representation.
     *
     * @param {Node.id} fromId
     * @param {Node.id} toId
     * @param {vis.Edge} baseEdge
     * @param {object} clusterEdgeProperties
     * @param {object} extraOptions
     * @returns {Edge} newly created clustered edge
     * @private
     */

  }, {
    key: "_createClusteredEdge",
    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
      // copy the options of the edge we will replace
      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge"); // make sure the properties of clusterEdges are superimposed on it

      deepExtend(clonedOptions, clusterEdgeProperties); // set up the edge

      clonedOptions.from = fromId;
      clonedOptions.to = toId;
      clonedOptions.id = "clusterEdge:" + v4(); // apply the edge specific options to it if specified

      if (extraOptions !== undefined) {
        deepExtend(clonedOptions, extraOptions);
      }

      var newEdge = this.body.functions.createEdge(clonedOptions);
      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
      newEdge.connect(); // Register the new edge

      this.body.edges[newEdge.id] = newEdge;
      return newEdge;
    }
    /**
     * Add the passed child nodes and edges to the given cluster node.
     *
     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster
     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering
     * @param {Node} clusterNode  cluster node to add nodes and edges to
     * @param {object} [clusterEdgeProperties]
     * @private
     */

  }, {
    key: "_clusterEdges",
    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
      if (childEdges instanceof Edge) {
        var edge = childEdges;
        var obj = {};
        obj[edge.id] = edge;
        childEdges = obj;
      }

      if (childNodes instanceof Node) {
        var node = childNodes;
        var _obj = {};
        _obj[node.id] = node;
        childNodes = _obj;
      }

      if (clusterNode === undefined || clusterNode === null) {
        throw new Error("_clusterEdges: parameter clusterNode required");
      }

      if (clusterEdgeProperties === undefined) {
        // Take the required properties from the cluster node
        clusterEdgeProperties = clusterNode.clusterEdgeProperties;
      } // create the new edges that will connect to the cluster.
      // All self-referencing edges will be added to childEdges here.


      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties); // disable the childEdges


      for (var edgeId in childEdges) {
        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {
          if (this.body.edges[edgeId] !== undefined) {
            var _edge2 = this.body.edges[edgeId]; // cache the options before changing

            this._backupEdgeOptions(_edge2); // disable physics and hide the edge


            _edge2.setOptions({
              physics: false
            });
          }
        }
      } // disable the childNodes


      for (var nodeId in childNodes) {
        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {
          this.clusteredNodes[nodeId] = {
            clusterId: clusterNode.id,
            node: this.body.nodes[nodeId]
          };
          this.body.nodes[nodeId].setOptions({
            physics: false
          });
        }
      }
    }
    /**
     * Determine in which cluster given nodeId resides.
     *
     * If not in cluster, return undefined.
     *
     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
     *
     * @param {Node.id} nodeId
     * @returns {Node|undefined} Node instance for cluster, if present
     * @private
     */

  }, {
    key: "_getClusterNodeForNode",
    value: function _getClusterNodeForNode(nodeId) {
      if (nodeId === undefined) return undefined;
      var clusteredNode = this.clusteredNodes[nodeId]; // NOTE: If no cluster info found, it should actually be an error

      if (clusteredNode === undefined) return undefined;
      var clusterId = clusteredNode.clusterId;
      if (clusterId === undefined) return undefined;
      return this.body.nodes[clusterId];
    }
    /**
     * Internal helper function for conditionally removing items in array
     *
     * Done like this because Array.filter() is not fully supported by all IE's.
     *
     * @param {Array} arr
     * @param {Function} callback
     * @returns {Array}
     * @private
     */

  }, {
    key: "_filter",
    value: function _filter(arr, callback) {
      var ret = [];
      forEach$1(arr, function (item) {
        if (callback(item)) {
          ret.push(item);
        }
      });
      return ret;
    }
    /**
     * Scan all edges for changes in clustering and adjust this if necessary.
     *
     * Call this (internally) after there has been a change in node or edge data.
     *
     * Pre: States of this.body.nodes and this.body.edges consistent
     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
     *      of cluster nodes.
     */

  }, {
    key: "_updateState",
    value: function _updateState() {
      var _this4 = this;

      var nodeId;
      var deletedNodeIds = [];
      var deletedEdgeIds = {};
      /**
       * Utility function to iterate over clustering nodes only
       *
       * @param {Function} callback  function to call for each cluster node
       */

      var eachClusterNode = function eachClusterNode(callback) {
        forEach$1(_this4.body.nodes, function (node) {
          if (node.isCluster === true) {
            callback(node);
          }
        });
      }; //
      // Remove deleted regular nodes from clustering
      //
      // Determine the deleted nodes


      for (nodeId in this.clusteredNodes) {
        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;
        var node = this.body.nodes[nodeId];

        if (node === undefined) {
          deletedNodeIds.push(nodeId);
        }
      } // Remove nodes from cluster nodes


      eachClusterNode(function (clusterNode) {
        for (var n = 0; n < deletedNodeIds.length; n++) {
          delete clusterNode.containedNodes[deletedNodeIds[n]];
        }
      }); // Remove nodes from cluster list

      for (var n = 0; n < deletedNodeIds.length; n++) {
        delete this.clusteredNodes[deletedNodeIds[n]];
      } //
      // Remove deleted edges from clustering
      //
      // Add the deleted clustered edges to the list


      forEach$1(this.clusteredEdges, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        if (edge === undefined || !edge.endPointsValid()) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      }); // Cluster nodes can also contain edges which are not clustered,
      // i.e. nodes 1-2 within cluster with an edge in between.
      // So the cluster nodes also need to be scanned for invalid edges

      eachClusterNode(function (clusterNode) {
        forEach$1(clusterNode.containedEdges, function (edge, edgeId) {
          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
            deletedEdgeIds[edgeId] = edgeId;
          }
        });
      }); // Also scan for cluster edges which need to be removed in the active list.
      // Regular edges have been removed beforehand, so this only picks up the cluster edges.

      forEach$1(this.body.edges, function (edge, edgeId) {
        // Explicitly scan the contained edges for validity
        var isValid = true;
        var replacedIds = edge.clusteringEdgeReplacingIds;

        if (replacedIds !== undefined) {
          var numValid = 0;
          forEach$1(replacedIds, function (containedEdgeId) {
            var containedEdge = _this4.body.edges[containedEdgeId];

            if (containedEdge !== undefined && containedEdge.endPointsValid()) {
              numValid += 1;
            }
          });
          isValid = numValid > 0;
        }

        if (!edge.endPointsValid() || !isValid) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      }); // Remove edges from cluster nodes

      eachClusterNode(function (clusterNode) {
        forEach$1(deletedEdgeIds, function (deletedEdgeId) {
          delete clusterNode.containedEdges[deletedEdgeId];
          forEach$1(clusterNode.edges, function (edge, m) {
            if (edge.id === deletedEdgeId) {
              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop

              return;
            }

            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {
              return !deletedEdgeIds[id];
            });
          }); // Clean up the nulls

          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {
            return item !== null;
          });
        });
      }); // Remove from cluster list

      forEach$1(deletedEdgeIds, function (edgeId) {
        delete _this4.clusteredEdges[edgeId];
      }); // Remove cluster edges from active list (this.body.edges).
      // deletedEdgeIds still contains id of regular edges, but these should all
      // be gone when you reach here.

      forEach$1(deletedEdgeIds, function (edgeId) {
        delete _this4.body.edges[edgeId];
      }); //
      // Check changed cluster state of edges
      //
      // Iterating over keys here, because edges may be removed in the loop

      var ids = keys$4(this.body.edges);

      forEach$1(ids, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);

        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
          return; // all is well
        }

        if (shouldBeClustered) {
          // add edge to clustering
          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);

          if (clusterFrom !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
          }

          var clusterTo = _this4._getClusterNodeForNode(edge.toId);

          if (clusterTo !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
          } // TODO: check that it works for both edges clustered
          //       (This might be paranoia)

        } else {
          delete _this4._clusterEdges[edgeId];

          _this4._restoreEdge(edge); // This should not be happening, the state should
          // be properly updated at this point.
          //
          // If it *is* reached during normal operation, then we have to implement
          // undo clustering for this edge here.
          // throw new Error('remove edge from clustering not implemented!')

        }
      }); // Clusters may be nested to any level. Keep on opening until nothing to open

      var changed = false;
      var continueLoop = true;

      var _loop2 = function _loop2() {
        var clustersToOpen = []; // Determine the id's of clusters that need opening

        eachClusterNode(function (clusterNode) {
          var numNodes = keys$4(clusterNode.containedNodes).length;

          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;

          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
            clustersToOpen.push(clusterNode.id);
          }
        }); // Open them

        for (var _n = 0; _n < clustersToOpen.length; ++_n) {
          _this4.openCluster(clustersToOpen[_n], {}, false
          /* Don't refresh, we're in an refresh/update already */
          );
        }

        continueLoop = clustersToOpen.length > 0;
        changed = changed || continueLoop;
      };

      while (continueLoop) {
        _loop2();
      }

      if (changed) {
        this._updateState(); // Redo this method (recursion possible! should be safe)

      }
    }
    /**
     * Determine if node with given id is part of a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {boolean} true if part of a cluster.
     */

  }, {
    key: "_isClusteredNode",
    value: function _isClusteredNode(nodeId) {
      return this.clusteredNodes[nodeId] !== undefined;
    }
    /**
     * Determine if edge with given id is not visible due to clustering.
     *
     * An edge is considered clustered if:
     * - it is directly replaced by a clustering edge
     * - any of its connecting nodes is in a cluster
     *
     * @param {vis.Edge.id} edgeId
     * @returns {boolean} true if part of a cluster.
     */

  }, {
    key: "_isClusteredEdge",
    value: function _isClusteredEdge(edgeId) {
      return this.clusteredEdges[edgeId] !== undefined;
    }
  }]);

  return ClusterEngine;
}();

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$5(o, minLen) { var _context4; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = slice(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Initializes window.requestAnimationFrame() to a usable form.
 *
 * Specifically, set up this method for the case of running on node.js with jsdom enabled.
 *
 * NOTES:
 *
 * On node.js, when calling this directly outside of this class, `window` is not defined.
 *   This happens even if jsdom is used.
 * For node.js + jsdom, `window` is available at the moment the constructor is called.
 *   For this reason, the called is placed within the constructor.
 * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.
 * During unit testing, it happens that the window object is reset during execution, causing
 *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,
 *   see `_requestNextFrame()`.
 * Since this is a global object, it may affect other modules besides `Network`. With normal
 *   usage, this does not cause any problems. During unit testing, errors may occur. These have
 *   been compensated for, see comment block in _requestNextFrame().
 *
 * @private
 */

function _initRequestAnimationFrame() {
  var func;

  if (window !== undefined) {
    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  if (func === undefined) {
    // window or method not present, setting mock requestAnimationFrame
    window.requestAnimationFrame = function (callback) {
      //console.log("Called mock requestAnimationFrame");
      callback();
    };
  } else {
    window.requestAnimationFrame = func;
  }
}
/**
 * The canvas renderer
 */


var CanvasRenderer = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function CanvasRenderer(body, canvas) {
    _classCallCheck(this, CanvasRenderer);

    _initRequestAnimationFrame();

    this.body = body;
    this.canvas = canvas;
    this.redrawRequested = false;
    this.renderTimer = undefined;
    this.requiresTimeout = true;
    this.renderingActive = false;
    this.renderRequests = 0;
    this.allowRedraw = true;
    this.dragging = false;
    this.zooming = false;
    this.options = {};
    this.defaultOptions = {
      hideEdgesOnDrag: false,
      hideEdgesOnZoom: false,
      hideNodesOnDrag: false
    };

    assign$2(this.options, this.defaultOptions);

    this._determineBrowserMethod();

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(CanvasRenderer, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this,
          _context2;

      this.body.emitter.on("dragStart", function () {
        _this.dragging = true;
      });
      this.body.emitter.on("dragEnd", function () {
        _this.dragging = false;
      });
      this.body.emitter.on("zoom", function () {
        _this.zooming = true;
        window.clearTimeout(_this.zoomTimeoutId);
        _this.zoomTimeoutId = setTimeout$1(function () {
          var _context;

          _this.zooming = false;

          bind$6(_context = _this._requestRedraw).call(_context, _this)();
        }, 250);
      });
      this.body.emitter.on("_resizeNodes", function () {
        _this._resizeNodes();
      });
      this.body.emitter.on("_redraw", function () {
        if (_this.renderingActive === false) {
          _this._redraw();
        }
      });
      this.body.emitter.on("_blockRedraw", function () {
        _this.allowRedraw = false;
      });
      this.body.emitter.on("_allowRedraw", function () {
        _this.allowRedraw = true;
        _this.redrawRequested = false;
      });
      this.body.emitter.on("_requestRedraw", bind$6(_context2 = this._requestRedraw).call(_context2, this));
      this.body.emitter.on("_startRendering", function () {
        _this.renderRequests += 1;
        _this.renderingActive = true;

        _this._startRendering();
      });
      this.body.emitter.on("_stopRendering", function () {
        _this.renderRequests -= 1;
        _this.renderingActive = _this.renderRequests > 0;
        _this.renderTimer = undefined;
      });
      this.body.emitter.on("destroy", function () {
        _this.renderRequests = 0;
        _this.allowRedraw = false;
        _this.renderingActive = false;

        if (_this.requiresTimeout === true) {
          clearTimeout(_this.renderTimer);
        } else {
          window.cancelAnimationFrame(_this.renderTimer);
        }

        _this.body.emitter.off();
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * Prepare the drawing of the next frame.
     *
     * Calls the callback when the next frame can or will be drawn.
     *
     * @param {Function} callback
     * @param {number} delay - timeout case only, wait this number of milliseconds
     * @returns {Function | undefined}
     * @private
     */

  }, {
    key: "_requestNextFrame",
    value: function _requestNextFrame(callback, delay) {
      // During unit testing, it happens that the mock window object is reset while
      // the next frame is still pending. Then, either 'window' is not present, or
      // 'requestAnimationFrame()' is not present because it is not defined on the
      // mock window object.
      //
      // As a consequence, unrelated unit tests may appear to fail, even if the problem
      // described happens in the current unit test.
      //
      // This is not something that will happen in normal operation, but we still need
      // to take it into account.
      //
      if (typeof window === "undefined") return; // Doing `if (window === undefined)` does not work here!

      var timer;
      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset
      // while running this method.

      if (this.requiresTimeout === true) {
        // wait given number of milliseconds and perform the animation step function
        timer = setTimeout$1(callback, delay);
      } else {
        if (myWindow.requestAnimationFrame) {
          timer = myWindow.requestAnimationFrame(callback);
        }
      }

      return timer;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_startRendering",
    value: function _startRendering() {
      if (this.renderingActive === true) {
        if (this.renderTimer === undefined) {
          var _context3;

          this.renderTimer = this._requestNextFrame(bind$6(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);
        }
      }
    }
    /**
     *
     * @private
     */

  }, {
    key: "_renderStep",
    value: function _renderStep() {
      if (this.renderingActive === true) {
        // reset the renderTimer so a new scheduled animation step can be set
        this.renderTimer = undefined;

        if (this.requiresTimeout === true) {
          // this schedules a new simulation step
          this._startRendering();
        }

        this._redraw();

        if (this.requiresTimeout === false) {
          // this schedules a new simulation step
          this._startRendering();
        }
      }
    }
    /**
     * Redraw the network with the current data
     * chart will be resized too.
     */

  }, {
    key: "redraw",
    value: function redraw() {
      this.body.emitter.emit("setSize");

      this._redraw();
    }
    /**
     * Redraw the network with the current data
     *
     * @private
     */

  }, {
    key: "_requestRedraw",
    value: function _requestRedraw() {
      var _this2 = this;

      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
        this.redrawRequested = true;

        this._requestNextFrame(function () {
          _this2._redraw(false);
        }, 0);
      }
    }
    /**
     * Redraw the network with the current data
     *
     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
     *                                   Only the nodes are drawn after which they are quickly drawn over.
     * @private
     */

  }, {
    key: "_redraw",
    value: function _redraw() {
      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.allowRedraw === true) {
        this.body.emitter.emit("initRedraw");
        this.redrawRequested = false;
        var drawLater = {
          drawExternalLabels: null
        }; // when the container div was hidden, this fixes it back up!

        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
          this.canvas.setSize();
        }

        this.canvas.setTransform();
        var ctx = this.canvas.getContext(); // clear the canvas

        var w = this.canvas.frame.canvas.clientWidth;
        var h = this.canvas.frame.canvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // if the div is hidden, we stop the redraw here for performance.

        if (this.canvas.frame.clientWidth === 0) {
          return;
        } // set scaling and translation


        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);
        ctx.beginPath();
        this.body.emitter.emit("beforeDrawing", ctx);
        ctx.closePath();

        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawEdges(ctx);
          }
        }

        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
          var _this$_drawNodes = this._drawNodes(ctx, hidden),
              drawExternalLabels = _this$_drawNodes.drawExternalLabels;

          drawLater.drawExternalLabels = drawExternalLabels;
        } // draw the arrows last so they will be at the top


        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawArrows(ctx);
          }
        }

        if (drawLater.drawExternalLabels != null) {
          drawLater.drawExternalLabels();
        }

        if (hidden === false) {
          this._drawSelectionBox(ctx);
        }

        ctx.beginPath();
        this.body.emitter.emit("afterDrawing", ctx);
        ctx.closePath(); // restore original scaling and translation

        ctx.restore();

        if (hidden === true) {
          ctx.clearRect(0, 0, w, h);
        }
      }
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {boolean} [alwaysShow]
     * @private
     */

  }, {
    key: "_resizeNodes",
    value: function _resizeNodes() {
      this.canvas.setTransform();
      var ctx = this.canvas.getContext();
      ctx.save();
      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
      ctx.scale(this.body.view.scale, this.body.view.scale);
      var nodes = this.body.nodes;
      var node; // resize all nodes

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          node = nodes[nodeId];
          node.resize(ctx);
          node.updateBoundingBox(ctx, node.selected);
        }
      } // restore original scaling and translation


      ctx.restore();
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @param {boolean} [alwaysShow]
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "_drawNodes",
    value: function _drawNodes(ctx) {
      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var nodes = this.body.nodes;
      var nodeIndices = this.body.nodeIndices;
      var node;
      var selected = [];
      var hovered = [];
      var margin = 20;
      var topLeft = this.canvas.DOMtoCanvas({
        x: -margin,
        y: -margin
      });
      var bottomRight = this.canvas.DOMtoCanvas({
        x: this.canvas.frame.canvas.clientWidth + margin,
        y: this.canvas.frame.canvas.clientHeight + margin
      });
      var viewableArea = {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
      var _drawExternalLabels = []; // draw unselected nodes;

      for (var _i = 0; _i < nodeIndices.length; _i++) {
        node = nodes[nodeIndices[_i]]; // set selected and hovered nodes aside

        if (node.hover) {
          hovered.push(nodeIndices[_i]);
        } else if (node.isSelected()) {
          selected.push(nodeIndices[_i]);
        } else {
          if (alwaysShow === true) {
            var drawLater = node.draw(ctx);

            if (drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(drawLater.drawExternalLabel);
            }
          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
            var _drawLater = node.draw(ctx);

            if (_drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(_drawLater.drawExternalLabel);
            }
          } else {
            node.updateBoundingBox(ctx, node.selected);
          }
        }
      }

      var i;
      var selectedLength = selected.length;
      var hoveredLength = hovered.length; // draw the selected nodes on top

      for (i = 0; i < selectedLength; i++) {
        node = nodes[selected[i]];

        var _drawLater2 = node.draw(ctx);

        if (_drawLater2.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater2.drawExternalLabel);
        }
      } // draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226


      for (i = 0; i < hoveredLength; i++) {
        node = nodes[hovered[i]];

        var _drawLater3 = node.draw(ctx);

        if (_drawLater3.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater3.drawExternalLabel);
        }
      }

      return {
        drawExternalLabels: function drawExternalLabels() {
          var _iterator = _createForOfIteratorHelper$5(_drawExternalLabels),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var draw = _step.value;
              draw();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      };
    }
    /**
     * Redraw all edges
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawEdges",
    value: function _drawEdges(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;

      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];

        if (edge.connected === true) {
          edge.draw(ctx);
        }
      }
    }
    /**
     * Redraw all arrows
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawArrows",
    value: function _drawArrows(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;

      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];

        if (edge.connected === true) {
          edge.drawArrows(ctx);
        }
      }
    }
    /**
     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
     * some implementations (safari and IE9) did not support requestAnimationFrame
     *
     * @private
     */

  }, {
    key: "_determineBrowserMethod",
    value: function _determineBrowserMethod() {
      if (typeof window !== "undefined") {
        var browserType = navigator.userAgent.toLowerCase();
        this.requiresTimeout = false;

        if (indexOf(browserType).call(browserType, "msie 9.0") != -1) {
          // IE 9
          this.requiresTimeout = true;
        } else if (indexOf(browserType).call(browserType, "safari") != -1) {
          // safari
          if (indexOf(browserType).call(browserType, "chrome") <= -1) {
            this.requiresTimeout = true;
          }
        }
      } else {
        this.requiresTimeout = true;
      }
    }
    /**
     * Redraw selection box
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawSelectionBox",
    value: function _drawSelectionBox(ctx) {
      if (this.body.selectionBox.show) {
        ctx.beginPath();
        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;
        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;
        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.fillStyle = "rgba(151, 194, 252, 0.2)";
        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.strokeStyle = "rgba(151, 194, 252, 1)";
        ctx.stroke();
      } else {
        ctx.closePath();
      }
    }
  }]);

  return CanvasRenderer;
}();

var path$1 = path$y;
var setInterval$1 = path$1.setInterval;

var setInterval = setInterval$1;

/**
 * Register a touch event, taking place before a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 */
function onTouch(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst) {
      callback(event);
    }
  };

  hammer.on("hammer.input", callback.inputHandler);
}
/**
 * Register a release event, taking place after a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 * @returns {*}
 */

function onRelease(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal) {
      callback(event);
    }
  };

  return hammer.on("hammer.input", callback.inputHandler);
}

/**
 * Create the main frame for the Network.
 * This function is executed once when a Network object is created. The frame
 * contains a canvas, and this canvas contains all objects like the axis and
 * nodes.
 */

var Canvas = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function Canvas(body) {
    _classCallCheck(this, Canvas);

    this.body = body;
    this.pixelRatio = 1;
    this.cameraState = {};
    this.initialized = false;
    this.canvasViewCenter = {};
    this._cleanupCallbacks = [];
    this.options = {};
    this.defaultOptions = {
      autoResize: true,
      height: "100%",
      width: "100%"
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(Canvas, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this,
          _context;

      // bind the events
      this.body.emitter.once("resize", function (obj) {
        if (obj.width !== 0) {
          _this.body.view.translation.x = obj.width * 0.5;
        }

        if (obj.height !== 0) {
          _this.body.view.translation.y = obj.height * 0.5;
        }
      });
      this.body.emitter.on("setSize", bind$6(_context = this.setSize).call(_context, this));
      this.body.emitter.on("destroy", function () {
        _this.hammerFrame.destroy();

        _this.hammer.destroy();

        _this._cleanUp();
      });
    }
    /**
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this2 = this;

      if (options !== undefined) {
        var fields = ["width", "height", "autoResize"];
        selectiveDeepExtend(fields, this.options, options);
      } // Automatically adapt to changing size of the container element.


      this._cleanUp();

      if (this.options.autoResize === true) {
        var _context2;

        if (window.ResizeObserver) {
          // decent browsers, immediate reactions
          var observer = new ResizeObserver(function () {
            var changed = _this2.setSize();

            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          });
          var frame = this.frame;
          observer.observe(frame);

          this._cleanupCallbacks.push(function () {
            observer.unobserve(frame);
          });
        } else {
          // IE11, continous polling
          var resizeTimer = setInterval(function () {
            var changed = _this2.setSize();

            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1000);

          this._cleanupCallbacks.push(function () {
            clearInterval(resizeTimer);
          });
        } // Automatically adapt to changing size of the browser.


        var resizeFunction = bind$6(_context2 = this._onResize).call(_context2, this);

        addEventListener(window, "resize", resizeFunction);

        this._cleanupCallbacks.push(function () {
          removeEventListener(window, "resize", resizeFunction);
        });
      }
    }
    /**
     * @private
     */

  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      var _context3, _context4, _context5;

      forEach$2(_context3 = reverse(_context4 = splice$1(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function (callback) {
        try {
          callback();
        } catch (error) {
          console.error(error);
        }
      });
    }
    /**
     * @private
     */

  }, {
    key: "_onResize",
    value: function _onResize() {
      this.setSize();
      this.body.emitter.emit("_redraw");
    }
    /**
     * Get and store the cameraState
     *
     * @param {number} [pixelRatio=this.pixelRatio]
     * @private
     */

  }, {
    key: "_getCameraState",
    value: function _getCameraState() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;

      if (this.initialized === true) {
        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
        this.cameraState.scale = this.body.view.scale;
        this.cameraState.position = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.width / pixelRatio,
          y: 0.5 * this.frame.canvas.height / pixelRatio
        });
      }
    }
    /**
     * Set the cameraState
     *
     * @private
     */

  }, {
    key: "_setCameraState",
    value: function _setCameraState() {
      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {
        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
        var newScale = this.cameraState.scale;

        if (widthRatio != 1 && heightRatio != 1) {
          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
        } else if (widthRatio != 1) {
          newScale = this.cameraState.scale * widthRatio;
        } else if (heightRatio != 1) {
          newScale = this.cameraState.scale * heightRatio;
        }

        this.body.view.scale = newScale; // this comes from the view module.

        var currentViewCenter = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.clientWidth,
          y: 0.5 * this.frame.canvas.clientHeight
        });
        var distanceFromCenter = {
          // offset from view, distance view has to change by these x and y to center the node
          x: currentViewCenter.x - this.cameraState.position.x,
          y: currentViewCenter.y - this.cameraState.position.y
        };
        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
      }
    }
    /**
     *
     * @param {number|string} value
     * @returns {string}
     * @private
     */

  }, {
    key: "_prepareValue",
    value: function _prepareValue(value) {
      if (typeof value === "number") {
        return value + "px";
      } else if (typeof value === "string") {
        if (indexOf(value).call(value, "%") !== -1 || indexOf(value).call(value, "px") !== -1) {
          return value;
        } else if (indexOf(value).call(value, "%") === -1) {
          return value + "px";
        }
      }

      throw new Error("Could not use the value supplied for width or height:" + value);
    }
    /**
     * Create the HTML
     */

  }, {
    key: "_create",
    value: function _create() {
      // remove all elements from the container element.
      while (this.body.container.hasChildNodes()) {
        this.body.container.removeChild(this.body.container.firstChild);
      }

      this.frame = document.createElement("div");
      this.frame.className = "vis-network";
      this.frame.style.position = "relative";
      this.frame.style.overflow = "hidden";
      this.frame.tabIndex = 0; // tab index is required for keycharm to bind keystrokes to the div instead of the window
      //////////////////////////////////////////////////////////////////

      this.frame.canvas = document.createElement("canvas");
      this.frame.canvas.style.position = "relative";
      this.frame.appendChild(this.frame.canvas);

      if (!this.frame.canvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.frame.canvas.appendChild(noCanvas);
      } else {
        this._setPixelRatio();

        this.setTransform();
      } // add the frame to the container element


      this.body.container.appendChild(this.frame);
      this.body.view.scale = 1;
      this.body.view.translation = {
        x: 0.5 * this.frame.canvas.clientWidth,
        y: 0.5 * this.frame.canvas.clientHeight
      };

      this._bindHammer();
    }
    /**
     * This function binds hammer, it can be repeated over and over due to the uniqueness check.
     *
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;

      if (this.hammer !== undefined) {
        this.hammer.destroy();
      }

      this.drag = {};
      this.pinch = {}; // init hammer

      this.hammer = new Hammer(this.frame.canvas);
      this.hammer.get("pinch").set({
        enable: true
      }); // enable to get better response, todo: test on mobile.

      this.hammer.get("pan").set({
        threshold: 5,
        direction: Hammer.DIRECTION_ALL
      });
      onTouch(this.hammer, function (event) {
        _this3.body.eventListeners.onTouch(event);
      });
      this.hammer.on("tap", function (event) {
        _this3.body.eventListeners.onTap(event);
      });
      this.hammer.on("doubletap", function (event) {
        _this3.body.eventListeners.onDoubleTap(event);
      });
      this.hammer.on("press", function (event) {
        _this3.body.eventListeners.onHold(event);
      });
      this.hammer.on("panstart", function (event) {
        _this3.body.eventListeners.onDragStart(event);
      });
      this.hammer.on("panmove", function (event) {
        _this3.body.eventListeners.onDrag(event);
      });
      this.hammer.on("panend", function (event) {
        _this3.body.eventListeners.onDragEnd(event);
      });
      this.hammer.on("pinch", function (event) {
        _this3.body.eventListeners.onPinch(event);
      }); // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?

      this.frame.canvas.addEventListener("wheel", function (event) {
        _this3.body.eventListeners.onMouseWheel(event);
      });
      this.frame.canvas.addEventListener("mousemove", function (event) {
        _this3.body.eventListeners.onMouseMove(event);
      });
      this.frame.canvas.addEventListener("contextmenu", function (event) {
        _this3.body.eventListeners.onContext(event);
      });
      this.hammerFrame = new Hammer(this.frame);
      onRelease(this.hammerFrame, function (event) {
        _this3.body.eventListeners.onRelease(event);
      });
    }
    /**
     * Set a new size for the network
     *
     * @param {string} width   Width in pixels or percentage (for example '800px'
     *                         or '50%')
     * @param {string} height  Height in pixels or percentage  (for example '400px'
     *                         or '30%')
     * @returns {boolean}
     */

  }, {
    key: "setSize",
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;
      width = this._prepareValue(width);
      height = this._prepareValue(height);
      var emitEvent = false;
      var oldWidth = this.frame.canvas.width;
      var oldHeight = this.frame.canvas.height; // update the pixel ratio
      //
      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code
      //       where it is assumed that the pixel ratio could change at runtime.
      //       The only way I can think of this happening is a rotating screen or tablet; but then
      //       there should be a mechanism for reloading the data (TODO: check if this is present).
      //
      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage
      //       of pixel ratio must be overhauled for this.
      //
      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is
      //       constant.

      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value

      this._setPixelRatio();

      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
        this._getCameraState(previousRatio);

        this.frame.style.width = width;
        this.frame.style.height = height;
        this.frame.canvas.style.width = "100%";
        this.frame.canvas.style.height = "100%";
        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
        this.options.width = width;
        this.options.height = height;
        this.canvasViewCenter = {
          x: 0.5 * this.frame.clientWidth,
          y: 0.5 * this.frame.clientHeight
        };
        emitEvent = true;
      } else {
        // this would adapt the width of the canvas to the width from 100% if and only if
        // there is a change.
        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio); // store the camera if there is a change in size.

        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
          this._getCameraState(previousRatio);
        }

        if (this.frame.canvas.width !== newWidth) {
          this.frame.canvas.width = newWidth;
          emitEvent = true;
        }

        if (this.frame.canvas.height !== newHeight) {
          this.frame.canvas.height = newHeight;
          emitEvent = true;
        }
      }

      if (emitEvent === true) {
        this.body.emitter.emit("resize", {
          width: Math.round(this.frame.canvas.width / this.pixelRatio),
          height: Math.round(this.frame.canvas.height / this.pixelRatio),
          oldWidth: Math.round(oldWidth / this.pixelRatio),
          oldHeight: Math.round(oldHeight / this.pixelRatio)
        }); // restore the camera on change.

        this._setCameraState();
      } // set initialized so the get and set camera will work from now on.


      this.initialized = true;
      return emitEvent;
    }
    /**
     *
     * @returns {CanvasRenderingContext2D}
     */

  }, {
    key: "getContext",
    value: function getContext() {
      return this.frame.canvas.getContext("2d");
    }
    /**
     * Determine the pixel ratio for various browsers.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_determinePixelRatio",
    value: function _determinePixelRatio() {
      var ctx = this.getContext();

      if (ctx === undefined) {
        throw new Error("Could not get canvax context");
      }

      var numerator = 1;

      if (typeof window !== "undefined") {
        // (window !== undefined) doesn't work here!
        // Protection during unit tests, where 'window' can be missing
        numerator = window.devicePixelRatio || 1;
      }

      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
      return numerator / denominator;
    }
    /**
     * Lazy determination of pixel ratio.
     *
     * @private
     */

  }, {
    key: "_setPixelRatio",
    value: function _setPixelRatio() {
      this.pixelRatio = this._determinePixelRatio();
    }
    /**
     * Set the transform in the contained context, based on its pixelRatio
     */

  }, {
    key: "setTransform",
    value: function setTransform() {
      var ctx = this.getContext();

      if (ctx === undefined) {
        throw new Error("Could not get canvax context");
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
    /**
     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: "_XconvertDOMtoCanvas",
    value: function _XconvertDOMtoCanvas(x) {
      return (x - this.body.view.translation.x) / this.body.view.scale;
    }
    /**
     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: "_XconvertCanvasToDOM",
    value: function _XconvertCanvasToDOM(x) {
      return x * this.body.view.scale + this.body.view.translation.x;
    }
    /**
     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: "_YconvertDOMtoCanvas",
    value: function _YconvertDOMtoCanvas(y) {
      return (y - this.body.view.translation.y) / this.body.view.scale;
    }
    /**
     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: "_YconvertCanvasToDOM",
    value: function _YconvertCanvasToDOM(y) {
      return y * this.body.view.scale + this.body.view.translation.y;
    }
    /**
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: "canvasToDOM",
    value: function canvasToDOM(pos) {
      return {
        x: this._XconvertCanvasToDOM(pos.x),
        y: this._YconvertCanvasToDOM(pos.y)
      };
    }
    /**
     *
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: "DOMtoCanvas",
    value: function DOMtoCanvas(pos) {
      return {
        x: this._XconvertDOMtoCanvas(pos.x),
        y: this._YconvertDOMtoCanvas(pos.y)
      };
    }
  }]);

  return Canvas;
}();

/**
 * Validate the fit options, replace missing optional values by defaults etc.
 *
 * @param rawOptions - The raw options.
 * @param allNodeIds - All node ids that will be used if nodes are omitted in
 * the raw options.
 * @returns Options with everything filled in and validated.
 */
function normalizeFitOptions(rawOptions, allNodeIds) {
  var options = assign$2({
    nodes: allNodeIds,
    minZoomLevel: Number.MIN_VALUE,
    maxZoomLevel: 1
  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});

  if (!isArray$2(options.nodes)) {
    throw new TypeError("Nodes has to be an array of ids.");
  }

  if (options.nodes.length === 0) {
    options.nodes = allNodeIds;
  }

  if (!(typeof options.minZoomLevel === "number" && options.minZoomLevel > 0)) {
    throw new TypeError("Min zoom level has to be a number higher than zero.");
  }

  if (!(typeof options.maxZoomLevel === "number" && options.minZoomLevel <= options.maxZoomLevel)) {
    throw new TypeError("Max zoom level has to be a number higher than min zoom level.");
  }

  return options;
}

/**
 * The view
 */

var View = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function View(body, canvas) {
    var _context,
        _this = this,
        _context2;

    _classCallCheck(this, View);

    this.body = body;
    this.canvas = canvas;
    this.animationSpeed = 1 / this.renderRefreshRate;
    this.animationEasingFunction = "easeInOutQuint";
    this.easingTime = 0;
    this.sourceScale = 0;
    this.targetScale = 0;
    this.sourceTranslation = 0;
    this.targetTranslation = 0;
    this.lockedOnNodeId = undefined;
    this.lockedOnNodeOffset = undefined;
    this.touchTime = 0;
    this.viewFunction = undefined;
    this.body.emitter.on("fit", bind$6(_context = this.fit).call(_context, this));
    this.body.emitter.on("animationFinished", function () {
      _this.body.emitter.emit("_stopRendering");
    });
    this.body.emitter.on("unlockNode", bind$6(_context2 = this.releaseNode).call(_context2, this));
  }
  /**
   *
   * @param {object} [options={}]
   */


  _createClass(View, [{
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = options;
    }
    /**
     * This function zooms out to fit all data on screen based on amount of nodes
     *
     * @param {object} [options={{nodes=Array}}]
     * @param options
     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
     */

  }, {
    key: "fit",
    value: function fit(options) {
      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      options = normalizeFitOptions(options, this.body.nodeIndices);
      var canvasWidth = this.canvas.frame.canvas.clientWidth;
      var canvasHeight = this.canvas.frame.canvas.clientHeight;
      var range;
      var zoomLevel;

      if (canvasWidth === 0 || canvasHeight === 0) {
        // There's no point in trying to fit into zero sized canvas. This could
        // potentially even result in invalid values being computed. For example
        // for network without nodes and zero sized canvas the zoom level would
        // end up being computed as 0/0 which results in NaN. In any other case
        // this would be 0/something which is again pointless to compute.
        zoomLevel = 1;
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
      } else if (initialZoom === true) {
        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
        var positionDefined = 0;

        for (var nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            var node = this.body.nodes[nodeId];

            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }
        }

        if (positionDefined > 0.5 * this.body.nodeIndices.length) {
          this.fit(options, false);
          return;
        }

        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var numberOfNodes = this.body.nodeIndices.length;
        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.
        // correct for larger canvasses.

        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);
        zoomLevel *= factor;
      } else {
        this.body.emitter.emit("_resizeNodes");
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
        var xZoomLevel = canvasWidth / xDistance;
        var yZoomLevel = canvasHeight / yDistance;
        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
      }

      if (zoomLevel > options.maxZoomLevel) {
        zoomLevel = options.maxZoomLevel;
      } else if (zoomLevel < options.minZoomLevel) {
        zoomLevel = options.minZoomLevel;
      }

      var center = NetworkUtil.findCenter(range);
      var animationOptions = {
        position: center,
        scale: zoomLevel,
        animation: options.animation
      };
      this.moveTo(animationOptions);
    } // animation

    /**
     * Center a node in view.
     *
     * @param {number} nodeId
     * @param {number} [options]
     */

  }, {
    key: "focus",
    value: function focus(nodeId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.body.nodes[nodeId] !== undefined) {
        var nodePosition = {
          x: this.body.nodes[nodeId].x,
          y: this.body.nodes[nodeId].y
        };
        options.position = nodePosition;
        options.lockedOnNode = nodeId;
        this.moveTo(options);
      } else {
        console.error("Node: " + nodeId + " cannot be found.");
      }
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.scale    = number                 // scale to move to
     *                          |  options.position = {x:number, y:number}   // position to move to
     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
     */

  }, {
    key: "moveTo",
    value: function moveTo(options) {
      if (options === undefined) {
        options = {};
        return;
      }

      if (options.offset != null) {
        if (options.offset.x != null) {
          // Coerce and verify that x is valid.
          options.offset.x = +options.offset.x;

          if (!_isFinite(options.offset.x)) {
            throw new TypeError('The option "offset.x" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }

        if (options.offset.y != null) {
          // Coerce and verify that y is valid.
          options.offset.y = +options.offset.y;

          if (!_isFinite(options.offset.y)) {
            throw new TypeError('The option "offset.y" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }
      } else {
        options.offset = {
          x: 0,
          y: 0
        };
      }

      if (options.position != null) {
        if (options.position.x != null) {
          // Coerce and verify that x is valid.
          options.position.x = +options.position.x;

          if (!_isFinite(options.position.x)) {
            throw new TypeError('The option "position.x" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }

        if (options.position.y != null) {
          // Coerce and verify that y is valid.
          options.position.y = +options.position.y;

          if (!_isFinite(options.position.y)) {
            throw new TypeError('The option "position.y" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }
      } else {
        options.position = this.getViewPosition();
      }

      if (options.scale != null) {
        // Coerce and verify that the scale is valid.
        options.scale = +options.scale;

        if (!(options.scale > 0)) {
          throw new TypeError('The option "scale" has to be a number greater than zero.');
        }
      } else {
        options.scale = this.body.view.scale;
      }

      if (options.animation === undefined) {
        options.animation = {
          duration: 0
        };
      }

      if (options.animation === false) {
        options.animation = {
          duration: 0
        };
      }

      if (options.animation === true) {
        options.animation = {};
      }

      if (options.animation.duration === undefined) {
        options.animation.duration = 1000;
      } // default duration


      if (options.animation.easingFunction === undefined) {
        options.animation.easingFunction = "easeInOutQuad";
      } // default easing function


      this.animateView(options);
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.time     = number                 // animation time in milliseconds
     *                          |  options.scale    = number                 // scale to animate to
     *                          |  options.position = {x:number, y:number}   // position to animate to
     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
     */

  }, {
    key: "animateView",
    value: function animateView(options) {
      if (options === undefined) {
        return;
      }

      this.animationEasingFunction = options.animation.easingFunction; // release if something focussed on the node

      this.releaseNode();

      if (options.locked === true) {
        this.lockedOnNodeId = options.lockedOnNode;
        this.lockedOnNodeOffset = options.offset;
      } // forcefully complete the old animation if it was still running


      if (this.easingTime != 0) {
        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.

      }

      this.sourceScale = this.body.view.scale;
      this.sourceTranslation = this.body.view.translation;
      this.targetScale = options.scale; // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
      // but at least then we'll have the target transition

      this.body.view.scale = this.targetScale;
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - options.position.x,
        y: viewCenter.y - options.position.y
      };
      this.targetTranslation = {
        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
      }; // if the time is set to 0, don't do an animation

      if (options.animation.duration === 0) {
        if (this.lockedOnNodeId != undefined) {
          var _context3;

          this.viewFunction = bind$6(_context3 = this._lockedRedraw).call(_context3, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        } else {
          this.body.view.scale = this.targetScale;
          this.body.view.translation = this.targetTranslation;
          this.body.emitter.emit("_requestRedraw");
        }
      } else {
        var _context4;

        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's

        this.animationEasingFunction = options.animation.easingFunction;
        this.viewFunction = bind$6(_context4 = this._transitionRedraw).call(_context4, this);
        this.body.emitter.on("initRedraw", this.viewFunction);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     * used to animate smoothly by hijacking the redraw function.
     *
     * @private
     */

  }, {
    key: "_lockedRedraw",
    value: function _lockedRedraw() {
      var nodePosition = {
        x: this.body.nodes[this.lockedOnNodeId].x,
        y: this.body.nodes[this.lockedOnNodeId].y
      };
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - nodePosition.x,
        y: viewCenter.y - nodePosition.y
      };
      var sourceTranslation = this.body.view.translation;
      var targetTranslation = {
        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
      };
      this.body.view.translation = targetTranslation;
    }
    /**
     * Resets state of a locked on Node
     */

  }, {
    key: "releaseNode",
    value: function releaseNode() {
      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.lockedOnNodeId = undefined;
        this.lockedOnNodeOffset = undefined;
      }
    }
    /**
     * @param {boolean} [finished=false]
     * @private
     */

  }, {
    key: "_transitionRedraw",
    value: function _transitionRedraw() {
      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.easingTime += this.animationSpeed;
      this.easingTime = finished === true ? 1.0 : this.easingTime;
      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);
      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
      this.body.view.translation = {
        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
      }; // cleanup

      if (this.easingTime >= 1.0) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.easingTime = 0;

        if (this.lockedOnNodeId != undefined) {
          var _context5;

          this.viewFunction = bind$6(_context5 = this._lockedRedraw).call(_context5, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        }

        this.body.emitter.emit("animationFinished");
      }
    }
    /**
     *
     * @returns {number}
     */

  }, {
    key: "getScale",
    value: function getScale() {
      return this.body.view.scale;
    }
    /**
     *
     * @returns {{x: number, y: number}}
     */

  }, {
    key: "getViewPosition",
    value: function getViewPosition() {
      return this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
    }
  }]);

  return View;
}();

var css_248z$1 = "div.vis-network div.vis-navigation div.vis-button {\n  width: 34px;\n  height: 34px;\n  -moz-border-radius: 17px;\n  border-radius: 17px;\n  position: absolute;\n  display: inline-block;\n  background-position: 2px 2px;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:hover {\n  box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.3);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:active {\n  box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button.vis-up {\n  background-image: url('data:image/png;base64,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');\n  bottom: 50px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-down {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABpdJREFUeNqcV21QlNcVfp5zX9ikoAvLEsAIIgsoHwpqWAQUNKLNaNv8iZ1JMkNG6/Qj/dDUyCSTtCHpmEkwVk3TToZRMjXj5MOG2KidjIkxQYSAQUAtX6IgIN8su8KCoOzbH4sk4q5g77/33uee555z7rnneYmZDB2MKcJKlyYbqOsZVIgGEOgSHQoy4AKbFFjqAo5dWn/rNAh9OpO852oeJHYxtrmEu4WALhMbxG2ZE9uFAlImDRLY/t/y0b3Ig+u+iWOKsAlgIZSb0OIf15kWtKo1NXh1d5xxiSPEN2wUAHrGOg11jirjWVtJyFnb6YgrzoYwocClu0DI5guPDb43Y2LLp/Iaqf9JCGSErGvIifxd7aqQn/TOJCvFvZ8Hf9haEH+m/6sFQgHBv1Sts/15WmJLkeyl6FuFwFPzny1/ZdE7Nfg/xhv1uUmH2w6kggQp+yqze7d5JbZ8Im+KpucSwI6EN7/cYtlxZarBCts3ptfrtq9odjaGKihE+sV0vRC3u8RqWmmbij149W+Wd5p2rnET6bsqsntyb6+pO3KqkE8FvLxo74lNUX9s9uTJb8/9fG2L81KoogJFYfCm3b9usNq0MXxzw1RsUkDqQICPqf/b/q8sQi3j4WdmtV47OFgNAO6r+DEUFAtFAc9YtpXmRP6hxVsI24cvhyoqnFtrK6jM7isgBa3Dl0O94TeGb255MvzXpUIFjVrhxo/dzgoARBuwFQJkBK9reCnurxfvXX8CRW3yW1G749vT2Br7ysW0oNX1pKDTPG+rm1gHRbibAHLm/7522sKnQCZqFgCUaBCqaS/bEw9vqtWoQROf3dBBiT6KTACImZ3YueqhDdOWjDbFQ4IzIl4elNUX5begU1HD6lPRmULKeghhDcpqnUmZuD3+nkgTH6gZEE9ctlZSoGmG9UIynSCsQVndMyX+IZGiBoHMjHh2SreCglClaSBiSEG8cYnD24bv7CWms/3FocO3hnw13plTggAFb196NdlPM44tC0zrSg5ItXmyEz070UEKCMRqQgkkBQ9NvL2eSJ+revoJTORSpoT6do4/7/7UShBFHQexM+HdfyUHWO8iN/uaRzX3/QjUSLlnqM72F4cCRIY5u9Zf+Y+BAv4AvzpkQ7WAIBRujA/7Vg6cia9xlId6InafVEAAGnQMUCSkb6zTMPdBy8hU3JjrphIq+CrD+Mvxeyumrr+4IH9y7o2GF5eDghuuGx4L2zbWZ9Dc0RoQRbkkFNRdP2/0BH7EtLJLKCjr+zqh2l5u8haZ847vTBW24kRFQXKAtcsT5oqz3igQENIoECkjBJUDZSGewBlBj/ammjLrdX1c/t70ero34gMte9IByLLAjPrUwKweT5jawQshdIuGMiF5XEBU2koivBl9NeEfJeYHwuxtI81zPrn2z6ip60c6DkV1jLTOCTaE2HNjd5Z4s9MwWBOhqEHp/I9cWDtUrJNoHm4KO9P7hdnTBoMYXI8Gb6gVCg63FS53jg9O5tA57tSOdHywnCAygrJrfcTgUe5U2cvNHSPtYYoKCWlrTgsIneB2AfFR+4F4b6f9ZdTzF6P8Ytud407/dy/nL7k9X9i8J9l5y+Ef6RfbnjPvWa8N5suez+KFCgqyPY95Lnd3stv2AcBZ2+mFbze+lui1xc3dXCUUlPafXNx4/aKxcajWWNp/MklRw8/mPFntbd+h1oLE847KhQQxejVg36QQqD0MPTzHv42Ux+uGasJNBnPfwllJd71kkX7RQ3WDNf7dox3BLcNNs6vt34bbbvYHJhlTGp6O+JVHb0/2HJtX1PH+aqECqG/5YN1nlXcokGvvO6vCc4x+QskotxVHB/qa+xbOWuzw8NB3nuo+Ht0z2hHsuGU3GrWAoZfi3jrxgHpw3BPpobaCH7vbqOw6mHI836vYW3Eqcq9AtioqbJy7ufQ3lhfu8sR+s9+3vL8klACsQSu7AnxMY1MxH7YXJp7oPpLulrrj+9575Ni2aeVt1teWfEWfHQLCaspseHzOU7VWU+aM5G2NoyL4i+6j8XWDNQsmGsKu/cv+nTtjQb/mm7hfENyvqEAK5v8opjPJaL26KGBpd5TfguuBvuZRgBgY6zO0jlyZXXe9JqR+8MK8ntHOMHfHIkhu2b/0yIH7/oXJ0yFlxYnPUdRbvuILgO7+y+91l6Ka6M+cnCf4fMSypXvymHf/vzBTD3CuNGUFKT8lmK5Rs5ASqKiBlAGBXFaiSuni0fkp1pJ7Ed4e/xsAqLk46EWsG1EAAAAASUVORK5CYII=');\n  bottom: 10px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-left {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-right {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 95px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomIn {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  right: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomOut {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  right: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {\n  background-image: url('data:image/png;base64,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');\n  bottom: 50px;\n  right: 15px;\n}\n";
styleInject(css_248z$1);

/**
 * Created by Alex on 11/6/2014.
 */
function keycharm(options) {
  var preventDefault = options && options.preventDefault || false;
  var container = options && options.container || window;
  var _exportFunctions = {};
  var _bound = {
    keydown: {},
    keyup: {}
  };
  var _keys = {};
  var i; // a - z

  for (i = 97; i <= 122; i++) {
    _keys[String.fromCharCode(i)] = {
      code: 65 + (i - 97),
      shift: false
    };
  } // A - Z


  for (i = 65; i <= 90; i++) {
    _keys[String.fromCharCode(i)] = {
      code: i,
      shift: true
    };
  } // 0 - 9


  for (i = 0; i <= 9; i++) {
    _keys['' + i] = {
      code: 48 + i,
      shift: false
    };
  } // F1 - F12


  for (i = 1; i <= 12; i++) {
    _keys['F' + i] = {
      code: 111 + i,
      shift: false
    };
  } // num0 - num9


  for (i = 0; i <= 9; i++) {
    _keys['num' + i] = {
      code: 96 + i,
      shift: false
    };
  } // numpad misc


  _keys['num*'] = {
    code: 106,
    shift: false
  };
  _keys['num+'] = {
    code: 107,
    shift: false
  };
  _keys['num-'] = {
    code: 109,
    shift: false
  };
  _keys['num/'] = {
    code: 111,
    shift: false
  };
  _keys['num.'] = {
    code: 110,
    shift: false
  }; // arrows

  _keys['left'] = {
    code: 37,
    shift: false
  };
  _keys['up'] = {
    code: 38,
    shift: false
  };
  _keys['right'] = {
    code: 39,
    shift: false
  };
  _keys['down'] = {
    code: 40,
    shift: false
  }; // extra keys

  _keys['space'] = {
    code: 32,
    shift: false
  };
  _keys['enter'] = {
    code: 13,
    shift: false
  };
  _keys['shift'] = {
    code: 16,
    shift: undefined
  };
  _keys['esc'] = {
    code: 27,
    shift: false
  };
  _keys['backspace'] = {
    code: 8,
    shift: false
  };
  _keys['tab'] = {
    code: 9,
    shift: false
  };
  _keys['ctrl'] = {
    code: 17,
    shift: false
  };
  _keys['alt'] = {
    code: 18,
    shift: false
  };
  _keys['delete'] = {
    code: 46,
    shift: false
  };
  _keys['pageup'] = {
    code: 33,
    shift: false
  };
  _keys['pagedown'] = {
    code: 34,
    shift: false
  }; // symbols

  _keys['='] = {
    code: 187,
    shift: false
  };
  _keys['-'] = {
    code: 189,
    shift: false
  };
  _keys[']'] = {
    code: 221,
    shift: false
  };
  _keys['['] = {
    code: 219,
    shift: false
  };

  var down = function (event) {
    handleEvent(event, 'keydown');
  };

  var up = function (event) {
    handleEvent(event, 'keyup');
  }; // handle the actualy bound key with the event


  var handleEvent = function (event, type) {
    if (_bound[type][event.keyCode] !== undefined) {
      var bound = _bound[type][event.keyCode];

      for (var i = 0; i < bound.length; i++) {
        if (bound[i].shift === undefined) {
          bound[i].fn(event);
        } else if (bound[i].shift == true && event.shiftKey == true) {
          bound[i].fn(event);
        } else if (bound[i].shift == false && event.shiftKey == false) {
          bound[i].fn(event);
        }
      }

      if (preventDefault == true) {
        event.preventDefault();
      }
    }
  }; // bind a key to a callback


  _exportFunctions.bind = function (key, callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    if (_keys[key] === undefined) {
      throw new Error("unsupported key: " + key);
    }

    if (_bound[type][_keys[key].code] === undefined) {
      _bound[type][_keys[key].code] = [];
    }

    _bound[type][_keys[key].code].push({
      fn: callback,
      shift: _keys[key].shift
    });
  }; // bind all keys to a call back (demo purposes)


  _exportFunctions.bindAll = function (callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        _exportFunctions.bind(key, callback, type);
      }
    }
  }; // get the key label from an event


  _exportFunctions.getKey = function (event) {
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.keyCode == _keys[key].code && key == 'shift') {
          return key;
        }
      }
    }

    return "unknown key, currently not supported";
  }; // unbind either a specific callback from a key or all of them (by leaving callback undefined)


  _exportFunctions.unbind = function (key, callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    if (_keys[key] === undefined) {
      throw new Error("unsupported key: " + key);
    }

    if (callback !== undefined) {
      var newBindings = [];
      var bound = _bound[type][_keys[key].code];

      if (bound !== undefined) {
        for (var i = 0; i < bound.length; i++) {
          if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
            newBindings.push(_bound[type][_keys[key].code][i]);
          }
        }
      }

      _bound[type][_keys[key].code] = newBindings;
    } else {
      _bound[type][_keys[key].code] = [];
    }
  }; // reset all bound variables.


  _exportFunctions.reset = function () {
    _bound = {
      keydown: {},
      keyup: {}
    };
  }; // unbind all listeners and reset all variables.


  _exportFunctions.destroy = function () {
    _bound = {
      keydown: {},
      keyup: {}
    };
    container.removeEventListener('keydown', down, true);
    container.removeEventListener('keyup', up, true);
  }; // create listeners.


  container.addEventListener('keydown', down, true);
  container.addEventListener('keyup', up, true); // return the public functions.

  return _exportFunctions;
}

/**
 * Navigation Handler
 */

var NavigationHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function NavigationHandler(body, canvas) {
    var _this = this;

    _classCallCheck(this, NavigationHandler);

    this.body = body;
    this.canvas = canvas;
    this.iconsCreated = false;
    this.navigationHammers = [];
    this.boundFunctions = {};
    this.touchTime = 0;
    this.activated = false;
    this.body.emitter.on("activate", function () {
      _this.activated = true;

      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("deactivate", function () {
      _this.activated = false;

      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("destroy", function () {
      if (_this.keycharm !== undefined) {
        _this.keycharm.destroy();
      }
    });
    this.options = {};
  }
  /**
   *
   * @param {object} options
   */


  _createClass(NavigationHandler, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        this.options = options;
        this.create();
      }
    }
    /**
     * Creates or refreshes navigation and sets key bindings
     */

  }, {
    key: "create",
    value: function create() {
      if (this.options.navigationButtons === true) {
        if (this.iconsCreated === false) {
          this.loadNavigationElements();
        }
      } else if (this.iconsCreated === true) {
        this.cleanNavigation();
      }

      this.configureKeyboardBindings();
    }
    /**
     * Cleans up previous navigation items
     */

  }, {
    key: "cleanNavigation",
    value: function cleanNavigation() {
      // clean hammer bindings
      if (this.navigationHammers.length != 0) {
        for (var i = 0; i < this.navigationHammers.length; i++) {
          this.navigationHammers[i].destroy();
        }

        this.navigationHammers = [];
      } // clean up previous navigation items


      if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
        this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
      }

      this.iconsCreated = false;
    }
    /**
     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
     *
     * @private
     */

  }, {
    key: "loadNavigationElements",
    value: function loadNavigationElements() {
      var _this2 = this;

      this.cleanNavigation();
      this.navigationDOM = {};
      var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
      var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
      this.navigationDOM["wrapper"] = document.createElement("div");
      this.navigationDOM["wrapper"].className = "vis-navigation";
      this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);

      for (var i = 0; i < navigationDivs.length; i++) {
        this.navigationDOM[navigationDivs[i]] = document.createElement("div");
        this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
        this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);

        if (navigationDivActions[i] === "_fit") {
          var _context;

          onTouch(hammer, bind$6(_context = this._fit).call(_context, this));
        } else {
          var _context2;

          onTouch(hammer, bind$6(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));
        }

        this.navigationHammers.push(hammer);
      } // use a hammer for the release so we do not require the one used in the rest of the network
      // the one the rest uses can be overloaded by the manipulation system.


      var hammerFrame = new Hammer(this.canvas.frame);
      onRelease(hammerFrame, function () {
        _this2._stopMovement();
      });
      this.navigationHammers.push(hammerFrame);
      this.iconsCreated = true;
    }
    /**
     *
     * @param {string} action
     */

  }, {
    key: "bindToRedraw",
    value: function bindToRedraw(action) {
      if (this.boundFunctions[action] === undefined) {
        var _context3;

        this.boundFunctions[action] = bind$6(_context3 = this[action]).call(_context3, this);
        this.body.emitter.on("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     *
     * @param {string} action
     */

  }, {
    key: "unbindFromRedraw",
    value: function unbindFromRedraw(action) {
      if (this.boundFunctions[action] !== undefined) {
        this.body.emitter.off("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_stopRendering");
        delete this.boundFunctions[action];
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: "_fit",
    value: function _fit() {
      if (new Date().valueOf() - this.touchTime > 700) {
        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
        this.body.emitter.emit("fit", {
          duration: 700
        });
        this.touchTime = new Date().valueOf();
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: "_stopMovement",
    value: function _stopMovement() {
      for (var boundAction in this.boundFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {
          this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
          this.body.emitter.emit("_stopRendering");
        }
      }

      this.boundFunctions = {};
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveUp",
    value: function _moveUp() {
      this.body.view.translation.y += this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveDown",
    value: function _moveDown() {
      this.body.view.translation.y -= this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveLeft",
    value: function _moveLeft() {
      this.body.view.translation.x += this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveRight",
    value: function _moveRight() {
      this.body.view.translation.x -= this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_zoomIn",
    value: function _zoomIn() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "+",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     *
     * @private
     */

  }, {
    key: "_zoomOut",
    value: function _zoomOut() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "-",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     * bind all keys using keycharm.
     */

  }, {
    key: "configureKeyboardBindings",
    value: function configureKeyboardBindings() {
      var _this3 = this;

      if (this.keycharm !== undefined) {
        this.keycharm.destroy();
      }

      if (this.options.keyboard.enabled === true) {
        if (this.options.keyboard.bindToWindow === true) {
          this.keycharm = keycharm({
            container: window,
            preventDefault: true
          });
        } else {
          this.keycharm = keycharm({
            container: this.canvas.frame,
            preventDefault: true
          });
        }

        this.keycharm.reset();

        if (this.activated === true) {
          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;

          bind$6(_context4 = this.keycharm).call(_context4, "up", function () {
            _this3.bindToRedraw("_moveUp");
          }, "keydown");

          bind$6(_context5 = this.keycharm).call(_context5, "down", function () {
            _this3.bindToRedraw("_moveDown");
          }, "keydown");

          bind$6(_context6 = this.keycharm).call(_context6, "left", function () {
            _this3.bindToRedraw("_moveLeft");
          }, "keydown");

          bind$6(_context7 = this.keycharm).call(_context7, "right", function () {
            _this3.bindToRedraw("_moveRight");
          }, "keydown");

          bind$6(_context8 = this.keycharm).call(_context8, "=", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context9 = this.keycharm).call(_context9, "num+", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context10 = this.keycharm).call(_context10, "num-", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context11 = this.keycharm).call(_context11, "-", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context12 = this.keycharm).call(_context12, "[", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context13 = this.keycharm).call(_context13, "]", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context14 = this.keycharm).call(_context14, "pageup", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context15 = this.keycharm).call(_context15, "pagedown", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context16 = this.keycharm).call(_context16, "up", function () {
            _this3.unbindFromRedraw("_moveUp");
          }, "keyup");

          bind$6(_context17 = this.keycharm).call(_context17, "down", function () {
            _this3.unbindFromRedraw("_moveDown");
          }, "keyup");

          bind$6(_context18 = this.keycharm).call(_context18, "left", function () {
            _this3.unbindFromRedraw("_moveLeft");
          }, "keyup");

          bind$6(_context19 = this.keycharm).call(_context19, "right", function () {
            _this3.unbindFromRedraw("_moveRight");
          }, "keyup");

          bind$6(_context20 = this.keycharm).call(_context20, "=", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context21 = this.keycharm).call(_context21, "num+", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context22 = this.keycharm).call(_context22, "num-", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context23 = this.keycharm).call(_context23, "-", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context24 = this.keycharm).call(_context24, "[", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context25 = this.keycharm).call(_context25, "]", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context26 = this.keycharm).call(_context26, "pageup", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context27 = this.keycharm).call(_context27, "pagedown", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
        }
      }
    }
  }]);

  return NavigationHandler;
}();

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$4(o, minLen) { var _context15; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = slice(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Handler for interactions
 */

var InteractionHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   */
  function InteractionHandler(body, canvas, selectionHandler) {
    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;

    _classCallCheck(this, InteractionHandler);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.navigationHandler = new NavigationHandler(body, canvas); // bind the events from hammer to functions in this object

    this.body.eventListeners.onTap = bind$6(_context = this.onTap).call(_context, this);
    this.body.eventListeners.onTouch = bind$6(_context2 = this.onTouch).call(_context2, this);
    this.body.eventListeners.onDoubleTap = bind$6(_context3 = this.onDoubleTap).call(_context3, this);
    this.body.eventListeners.onHold = bind$6(_context4 = this.onHold).call(_context4, this);
    this.body.eventListeners.onDragStart = bind$6(_context5 = this.onDragStart).call(_context5, this);
    this.body.eventListeners.onDrag = bind$6(_context6 = this.onDrag).call(_context6, this);
    this.body.eventListeners.onDragEnd = bind$6(_context7 = this.onDragEnd).call(_context7, this);
    this.body.eventListeners.onMouseWheel = bind$6(_context8 = this.onMouseWheel).call(_context8, this);
    this.body.eventListeners.onPinch = bind$6(_context9 = this.onPinch).call(_context9, this);
    this.body.eventListeners.onMouseMove = bind$6(_context10 = this.onMouseMove).call(_context10, this);
    this.body.eventListeners.onRelease = bind$6(_context11 = this.onRelease).call(_context11, this);
    this.body.eventListeners.onContext = bind$6(_context12 = this.onContext).call(_context12, this);
    this.touchTime = 0;
    this.drag = {};
    this.pinch = {};
    this.popup = undefined;
    this.popupObj = undefined;
    this.popupTimer = undefined;
    this.body.functions.getPointer = bind$6(_context13 = this.getPointer).call(_context13, this);
    this.options = {};
    this.defaultOptions = {
      dragNodes: true,
      dragView: true,
      hover: false,
      keyboard: {
        enabled: false,
        speed: {
          x: 10,
          y: 10,
          zoom: 0.02
        },
        bindToWindow: true,
        autoFocus: true
      },
      navigationButtons: false,
      tooltipDelay: 300,
      zoomView: true,
      zoomSpeed: 1
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(InteractionHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on("destroy", function () {
        clearTimeout(_this.popupTimer);
        delete _this.body.functions.getPointer;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // extend all but the values in fields
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
        selectiveNotDeepExtend(fields, this.options, options); // merge the keyboard options in.

        mergeOptions(this.options, options, "keyboard");

        if (options.tooltip) {
          assign$2(this.options.tooltip, options.tooltip);

          if (options.tooltip.color) {
            this.options.tooltip.color = parseColor(options.tooltip.color);
          }
        }
      }

      this.navigationHandler.setOptions(this.options);
    }
    /**
     * Get the pointer location from a touch location
     *
     * @param {{x: number, y: number}} touch
     * @returns {{x: number, y: number}} pointer
     * @private
     */

  }, {
    key: "getPointer",
    value: function getPointer(touch) {
      return {
        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),
        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)
      };
    }
    /**
     * On start of a touch gesture, store the pointer
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "onTouch",
    value: function onTouch(event) {
      if (new Date().valueOf() - this.touchTime > 50) {
        this.drag.pointer = this.getPointer(event.center);
        this.drag.pinched = false;
        this.pinch.scale = this.body.view.scale; // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     * handle tap/click event: select/unselect a node
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onTap",
    value: function onTap(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
      this.checkSelectionChanges(pointer, multiselect);
      this.selectionHandler.commitAndEmit(pointer, event);
      this.selectionHandler.generateClickEvent("click", event, pointer);
    }
    /**
     * handle doubletap event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDoubleTap",
    value: function onDoubleTap(event) {
      var pointer = this.getPointer(event.center);
      this.selectionHandler.generateClickEvent("doubleClick", event, pointer);
    }
    /**
     * handle long tap event: multi select nodes
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onHold",
    value: function onHold(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect;
      this.checkSelectionChanges(pointer, multiselect);
      this.selectionHandler.commitAndEmit(pointer, event);
      this.selectionHandler.generateClickEvent("click", event, pointer);
      this.selectionHandler.generateClickEvent("hold", event, pointer);
    }
    /**
     * handle the release of the screen
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onRelease",
    value: function onRelease(event) {
      if (new Date().valueOf() - this.touchTime > 10) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler.generateClickEvent("release", event, pointer); // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     */

  }, {
    key: "onContext",
    value: function onContext(event) {
      var pointer = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      this.selectionHandler.generateClickEvent("oncontext", event, pointer);
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [add=false]
     */

  }, {
    key: "checkSelectionChanges",
    value: function checkSelectionChanges(pointer) {
      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (add === true) {
        this.selectionHandler.selectAdditionalOnPoint(pointer);
      } else {
        this.selectionHandler.selectOnPoint(pointer);
      }
    }
    /**
     * Remove all node and edge id's from the first set that are present in the second one.
     *
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
     * @private
     */

  }, {
    key: "_determineDifference",
    value: function _determineDifference(firstSet, secondSet) {
      var arrayDiff = function arrayDiff(firstArr, secondArr) {
        var result = [];

        for (var i = 0; i < firstArr.length; i++) {
          var value = firstArr[i];

          if (indexOf(secondArr).call(secondArr, value) === -1) {
            result.push(value);
          }
        }

        return result;
      };

      return {
        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
        edges: arrayDiff(firstSet.edges, secondSet.edges)
      };
    }
    /**
     * This function is called by onDragStart.
     * It is separated out because we can then overload it for the datamanipulation system.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      // if already dragging, do not start
      // this can happen on touch screens with multiple fingers
      if (this.drag.dragging) {
        return;
      } //in case the touch event was triggered on an external div, do the initial touch now.


      if (this.drag.pointer === undefined) {
        this.onTouch(event);
      } // note: drag.pointer is set in onTouch to get the initial touch location


      var node = this.selectionHandler.getNodeAt(this.drag.pointer);
      this.drag.dragging = true;
      this.drag.selection = [];
      this.drag.translation = assign$2({}, this.body.view.translation); // copy the object

      this.drag.nodeId = undefined;

      if (event.srcEvent.shiftKey) {
        this.body.selectionBox.show = true;
        var pointer = this.getPointer(event.center);
        this.body.selectionBox.position.start = {
          x: this.canvas._XconvertDOMtoCanvas(pointer.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer.y)
        };
        this.body.selectionBox.position.end = {
          x: this.canvas._XconvertDOMtoCanvas(pointer.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer.y)
        };
      }

      if (node !== undefined && this.options.dragNodes === true) {
        this.drag.nodeId = node.id; // select the clicked node if not yet selected

        if (node.isSelected() === false) {
          this.selectionHandler.setSelection({
            nodes: [node.id]
          });
        } // after select to contain the node


        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer); // create an array with the selected nodes and their original location and status

        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _node = _step.value;
            var s = {
              id: _node.id,
              node: _node,
              // store original x, y, xFixed and yFixed, make the node temporarily Fixed
              x: _node.x,
              y: _node.y,
              xFixed: _node.options.fixed.x,
              yFixed: _node.options.fixed.y
            };
            _node.options.fixed.x = true;
            _node.options.fixed.y = true;
            this.drag.selection.push(s);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        // fallback if no node is selected and thus the view is dragged.
        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer, undefined, true);
      }
    }
    /**
     * handle drag event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDrag",
    value: function onDrag(event) {
      var _this2 = this;

      if (this.drag.pinched === true) {
        return;
      } // remove the focus on node if it is focussed on by the focusOnNode


      this.body.emitter.emit("unlockNode");
      var pointer = this.getPointer(event.center);
      var selection = this.drag.selection;

      if (selection && selection.length && this.options.dragNodes === true) {
        this.selectionHandler.generateClickEvent("dragging", event, pointer); // calculate delta's and new location

        var deltaX = pointer.x - this.drag.pointer.x;
        var deltaY = pointer.y - this.drag.pointer.y; // update position of all selected nodes

        forEach$2(selection).call(selection, function (selection) {
          var node = selection.node; // only move the node if it was not fixed initially

          if (selection.xFixed === false) {
            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
          } // only move the node if it was not fixed initially


          if (selection.yFixed === false) {
            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
          }
        }); // start the simulation of the physics


        this.body.emitter.emit("startSimulation");
      } else {
        // create selection box
        if (event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.

          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }

          this.body.selectionBox.position.end = {
            x: this.canvas._XconvertDOMtoCanvas(pointer.x),
            y: this.canvas._YconvertDOMtoCanvas(pointer.y)
          };
          this.body.emitter.emit("_requestRedraw");
        } // move the network


        if (this.options.dragView === true && !event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.

          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }

          var diffX = pointer.x - this.drag.pointer.x;
          var diffY = pointer.y - this.drag.pointer.y;
          this.body.view.translation = {
            x: this.drag.translation.x + diffX,
            y: this.drag.translation.y + diffY
          };
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * handle drag start event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      var _this3 = this;

      this.drag.dragging = false;

      if (this.body.selectionBox.show) {
        var _context14;

        this.body.selectionBox.show = false;
        var selectionBoxPosition = this.body.selectionBox.position;
        var selectionBoxPositionMinMax = {
          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),
          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)
        };

        var toBeSelectedNodes = filter(_context14 = this.body.nodeIndices).call(_context14, function (nodeId) {
          var node = _this3.body.nodes[nodeId];
          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;
        });

        forEach$2(toBeSelectedNodes).call(toBeSelectedNodes, function (nodeId) {
          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);
        });

        var pointer = this.getPointer(event.center);
        this.selectionHandler.commitAndEmit(pointer, event);
        this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), undefined, true);
        this.body.emitter.emit("_requestRedraw");
      } else {
        var selection = this.drag.selection;

        if (selection && selection.length) {
          forEach$2(selection).call(selection, function (s) {
            // restore original xFixed and yFixed
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });

          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center));
          this.body.emitter.emit("startSimulation");
        } else {
          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), undefined, true);
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * Handle pinch event
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "onPinch",
    value: function onPinch(event) {
      var pointer = this.getPointer(event.center);
      this.drag.pinched = true;

      if (this.pinch["scale"] === undefined) {
        this.pinch.scale = 1;
      } // TODO: enabled moving while pinching?


      var scale = this.pinch.scale * event.scale;
      this.zoom(scale, pointer);
    }
    /**
     * Zoom the network in or out
     *
     * @param {number} scale a number around 1, and between 0.01 and 10
     * @param {{x: number, y: number}} pointer    Position on screen
     * @private
     */

  }, {
    key: "zoom",
    value: function zoom(scale, pointer) {
      if (this.options.zoomView === true) {
        var scaleOld = this.body.view.scale;

        if (scale < 0.00001) {
          scale = 0.00001;
        }

        if (scale > 10) {
          scale = 10;
        }

        var preScaleDragPointer = undefined;

        if (this.drag !== undefined) {
          if (this.drag.dragging === true) {
            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
          }
        } // + this.canvas.frame.canvas.clientHeight / 2


        var translation = this.body.view.translation;
        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;
        this.body.view.scale = scale;
        this.body.view.translation = {
          x: tx,
          y: ty
        };

        if (preScaleDragPointer != undefined) {
          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
          this.drag.pointer.x = postScaleDragPointer.x;
          this.drag.pointer.y = postScaleDragPointer.y;
        }

        this.body.emitter.emit("_requestRedraw");

        if (scaleOld < scale) {
          this.body.emitter.emit("zoom", {
            direction: "+",
            scale: this.body.view.scale,
            pointer: pointer
          });
        } else {
          this.body.emitter.emit("zoom", {
            direction: "-",
            scale: this.body.view.scale,
            pointer: pointer
          });
        }
      }
    }
    /**
     * Event handler for mouse wheel event, used to zoom the timeline
     * See http://adomas.org/javascript-mouse-wheel/
     *     https://github.com/EightMedia/hammer.js/issues/256
     *
     * @param {MouseEvent}  event
     * @private
     */

  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(event) {
      if (this.options.zoomView === true) {
        // If delta is nonzero, handle it.
        // Basically, delta is now positive if wheel was scrolled up,
        // and negative, if wheel was scrolled down.
        if (event.deltaY !== 0) {
          // calculate the new scale
          var scale = this.body.view.scale;
          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1); // calculate the pointer location

          var pointer = this.getPointer({
            x: event.clientX,
            y: event.clientY
          }); // apply the new scale

          this.zoom(scale, pointer);
        } // Prevent default actions caused by mouse wheel.


        event.preventDefault();
      }
    }
    /**
     * Mouse move handler for checking whether the title moves over a node with a title.
     *
     * @param  {Event} event
     * @private
     */

  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _this4 = this;

      var pointer = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      var popupVisible = false; // check if the previously selected node is still selected

      if (this.popup !== undefined) {
        if (this.popup.hidden === false) {
          this._checkHidePopup(pointer);
        } // if the popup was not hidden above


        if (this.popup.hidden === false) {
          popupVisible = true;
          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.show();
        }
      } // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.


      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
        this.canvas.frame.focus();
      } // start a timeout that will check if the mouse is positioned above an element


      if (popupVisible === false) {
        if (this.popupTimer !== undefined) {
          clearInterval(this.popupTimer); // stop any running calculationTimer

          this.popupTimer = undefined;
        }

        if (!this.drag.dragging) {
          this.popupTimer = setTimeout$1(function () {
            return _this4._checkShowPopup(pointer);
          }, this.options.tooltipDelay);
        }
      } // adding hover highlights


      if (this.options.hover === true) {
        this.selectionHandler.hoverObject(event, pointer);
      }
    }
    /**
     * Check if there is an element on the given position in the network
     * (a node or edge). If so, and if this element has a title,
     * show a popup window with its title.
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: "_checkShowPopup",
    value: function _checkShowPopup(pointer) {
      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);

      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);

      var pointerObj = {
        left: x,
        top: y,
        right: x,
        bottom: y
      };
      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
      var nodeUnderCursor = false;
      var popupType = "node"; // check if a node is under the cursor.

      if (this.popupObj === undefined) {
        // search the nodes for overlap, select the top one in case of multiple nodes
        var nodeIndices = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var node;
        var overlappingNodes = [];

        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];

          if (node.isOverlappingWith(pointerObj) === true) {
            nodeUnderCursor = true;

            if (node.getTitle() !== undefined) {
              overlappingNodes.push(nodeIndices[i]);
            }
          }
        }

        if (overlappingNodes.length > 0) {
          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]]; // if you hover over a node, the title of the edge is not supposed to be shown.

          nodeUnderCursor = true;
        }
      }

      if (this.popupObj === undefined && nodeUnderCursor === false) {
        // search the edges for overlap
        var edgeIndices = this.body.edgeIndices;
        var edges = this.body.edges;
        var edge;
        var overlappingEdges = [];

        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];

          if (edge.isOverlappingWith(pointerObj) === true) {
            if (edge.connected === true && edge.getTitle() !== undefined) {
              overlappingEdges.push(edgeIndices[_i]);
            }
          }
        }

        if (overlappingEdges.length > 0) {
          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
          popupType = "edge";
        }
      }

      if (this.popupObj !== undefined) {
        // show popup message window
        if (this.popupObj.id !== previousPopupObjId) {
          if (this.popup === undefined) {
            this.popup = new Popup(this.canvas.frame);
          }

          this.popup.popupTargetType = popupType;
          this.popup.popupTargetId = this.popupObj.id; // adjust a small offset such that the mouse cursor is located in the
          // bottom left location of the popup, and you can easily move over the
          // popup area

          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.setText(this.popupObj.getTitle());
          this.popup.show();
          this.body.emitter.emit("showPopup", this.popupObj.id);
        }
      } else {
        if (this.popup !== undefined) {
          this.popup.hide();
          this.body.emitter.emit("hidePopup");
        }
      }
    }
    /**
     * Check if the popup must be hidden, which is the case when the mouse is no
     * longer hovering on the object
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: "_checkHidePopup",
    value: function _checkHidePopup(pointer) {
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var stillOnObj = false;

      if (this.popup.popupTargetType === "node") {
        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj); // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
          // we initially only check stillOnObj because this is much faster.

          if (stillOnObj === true) {
            var overNode = this.selectionHandler.getNodeAt(pointer);
            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;
          }
        }
      } else {
        if (this.selectionHandler.getNodeAt(pointer) === undefined) {
          if (this.body.edges[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
          }
        }
      }

      if (stillOnObj === false) {
        this.popupObj = undefined;
        this.popup.hide();
        this.body.emitter.emit("hidePopup");
      }
    }
  }]);

  return InteractionHandler;
}();

var uncurryThis$1 = functionUncurryThis;
var redefineAll$1 = redefineAll$3;
var getWeakData = internalMetadata.exports.getWeakData;
var anObject = anObject$d;
var isObject$1 = isObject$j;
var anInstance = anInstance$3;
var iterate = iterate$3;
var ArrayIterationModule = arrayIteration;
var hasOwn = hasOwnProperty_1;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis$1([].splice);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$1 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
      return that;
    };

    redefineAll$1(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject$1(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject$1(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });
    redefineAll$1(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);

        if (isObject$1(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return Constructor;
  }
};

var global$1 = global$P;
var uncurryThis = functionUncurryThis;
var redefineAll = redefineAll$3;
var InternalMetadataModule = internalMetadata.exports;
var collection = collection$3;
var collectionWeak = collectionWeak$1;
var isObject = isObject$j;
var isExtensible = objectIsExtensible;
var enforceInternalState = internalState.enforce;
var NATIVE_WEAK_MAP = nativeWeakMap;
var IS_IE11 = !global$1.ActiveXObject && 'ActiveXObject' in global$1;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}; // `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor


var $WeakMap = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485

if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  var nativeSet = uncurryThis(WeakMapPrototype.set);
  redefineAll(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      }

      return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      }

      return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      }

      return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);

      return this;
    }
  });
}

var path = path$y;
var weakMap$2 = path.WeakMap;

var parent$1 = weakMap$2;
var weakMap$1 = parent$1;

var weakMap = weakMap$1;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { var _context2; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = slice(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _SingleTypeSelectionAccumulator_previousSelection, _SingleTypeSelectionAccumulator_selection, _SelectionAccumulator_nodes, _SelectionAccumulator_edges, _SelectionAccumulator_commitHandler;
/**
 * @param prev
 * @param next
 */

function diffSets(prev, next) {
  var diff = new set();

  var _iterator = _createForOfIteratorHelper$3(next),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      if (!prev.has(item)) {
        diff.add(item);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return diff;
}

var SingleTypeSelectionAccumulator = /*#__PURE__*/function () {
  function SingleTypeSelectionAccumulator() {
    _classCallCheck(this, SingleTypeSelectionAccumulator);

    _SingleTypeSelectionAccumulator_previousSelection.set(this, new set());

    _SingleTypeSelectionAccumulator_selection.set(this, new set());
  }

  _createClass(SingleTypeSelectionAccumulator, [{
    key: "size",
    get: function get() {
      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").size;
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      for (var _i = 0, _items = items; _i < _items.length; _i++) {
        var item = _items[_i];

        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").add(item);
      }
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {
        var item = _items2[_i2];

        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").delete(item);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").clear();
    }
  }, {
    key: "getSelection",
    value: function getSelection() {
      return _toConsumableArray(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"));
    }
  }, {
    key: "getChanges",
    value: function getChanges() {
      return {
        added: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"))),
        deleted: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        previous: _toConsumableArray(new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        current: _toConsumableArray(new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f")))
      };
    }
  }, {
    key: "commit",
    value: function commit() {
      var changes = this.getChanges();

      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), "f");

      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f")), "f");

      var _iterator2 = _createForOfIteratorHelper$3(changes.added),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;
          item.select();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper$3(changes.deleted),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _item = _step3.value;

          _item.unselect();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return changes;
    }
  }]);

  return SingleTypeSelectionAccumulator;
}();

_SingleTypeSelectionAccumulator_previousSelection = new weakMap(), _SingleTypeSelectionAccumulator_selection = new weakMap();
var SelectionAccumulator = /*#__PURE__*/function () {
  function SelectionAccumulator() {
    var commitHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

    _classCallCheck(this, SelectionAccumulator);

    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());

    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());

    _SelectionAccumulator_commitHandler.set(this, void 0);

    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, "f");
  }

  _createClass(SelectionAccumulator, [{
    key: "sizeNodes",
    get: function get() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").size;
    }
  }, {
    key: "sizeEdges",
    get: function get() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").size;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").getSelection();
    }
  }, {
    key: "getEdges",
    value: function getEdges() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").getSelection();
    }
  }, {
    key: "addNodes",
    value: function addNodes() {
      var _classPrivateFieldGe;

      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f")).add.apply(_classPrivateFieldGe, arguments);
    }
  }, {
    key: "addEdges",
    value: function addEdges() {
      var _classPrivateFieldGe2;

      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f")).add.apply(_classPrivateFieldGe2, arguments);
    }
  }, {
    key: "deleteNodes",
    value: function deleteNodes(node) {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").delete(node);
    }
  }, {
    key: "deleteEdges",
    value: function deleteEdges(edge) {
      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").delete(edge);
    }
  }, {
    key: "clear",
    value: function clear() {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").clear();

      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").clear();
    }
  }, {
    key: "commit",
    value: function commit() {
      var _classPrivateFieldGe3, _context;

      var summary = {
        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").commit(),
        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").commit()
      };

      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        rest[_key3] = arguments[_key3];
      }

      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, "f")).call.apply(_classPrivateFieldGe3, concat(_context = [this, summary]).call(_context, rest));

      return summary;
    }
  }]);

  return SelectionAccumulator;
}();
_SelectionAccumulator_nodes = new weakMap(), _SelectionAccumulator_edges = new weakMap(), _SelectionAccumulator_commitHandler = new weakMap();

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { var _context3; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = slice(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * The handler for selections
 */

var SelectionHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function SelectionHandler(body, canvas) {
    var _this = this;

    _classCallCheck(this, SelectionHandler);

    this.body = body;
    this.canvas = canvas; // TODO: Consider firing an event on any change to the selection, not
    // only those caused by clicks and taps. It would be easy to implement
    // now and (at least to me) it seems like something that could be
    // quite useful.

    this._selectionAccumulator = new SelectionAccumulator();
    this.hoverObj = {
      nodes: {},
      edges: {}
    };
    this.options = {};
    this.defaultOptions = {
      multiselect: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true
    };

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("_dataChanged", function () {
      _this.updateSelection();
    });
  }
  /**
   *
   * @param {object} [options]
   */


  _createClass(SelectionHandler, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * handles the selection part of the tap;
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: "selectOnPoint",
    value: function selectOnPoint(pointer) {
      var selected = false;

      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer); // unselect after getting the objects in order to restore width and height.

        this.unselectAll();

        if (obj !== undefined) {
          selected = this.selectObject(obj);
        }

        this.body.emitter.emit("_requestRedraw");
      }

      return selected;
    }
    /**
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: "selectAdditionalOnPoint",
    value: function selectAdditionalOnPoint(pointer) {
      var selectionChanged = false;

      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

        if (obj !== undefined) {
          selectionChanged = true;

          if (obj.isSelected() === true) {
            this.deselectObject(obj);
          } else {
            this.selectObject(obj);
          }

          this.body.emitter.emit("_requestRedraw");
        }
      }

      return selectionChanged;
    }
    /**
     * Create an object containing the standard fields for an event.
     *
     * @param {Event} event
     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
     * @returns {{}}
     * @private
     */

  }, {
    key: "_initBaseEvent",
    value: function _initBaseEvent(event, pointer) {
      var properties = {};
      properties["pointer"] = {
        DOM: {
          x: pointer.x,
          y: pointer.y
        },
        canvas: this.canvas.DOMtoCanvas(pointer)
      };
      properties["event"] = event;
      return properties;
    }
    /**
     * Generate an event which the user can catch.
     *
     * This adds some extra data to the event with respect to cursor position and
     * selected nodes and edges.
     *
     * @param {string} eventType                          Name of event to send
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
     * @param {object | undefined} oldSelection             If present, selection state before event occured
     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
     */

  }, {
    key: "generateClickEvent",
    value: function generateClickEvent(eventType, event, pointer, oldSelection) {
      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      var properties = this._initBaseEvent(event, pointer);

      if (emptySelection === true) {
        properties.nodes = [];
        properties.edges = [];
      } else {
        var tmp = this.getSelection();
        properties.nodes = tmp.nodes;
        properties.edges = tmp.edges;
      }

      if (oldSelection !== undefined) {
        properties["previousSelection"] = oldSelection;
      }

      if (eventType == "click") {
        // For the time being, restrict this functionality to
        // just the click event.
        properties.items = this.getClickedItems(pointer);
      }

      if (event.controlEdge !== undefined) {
        properties.controlEdge = event.controlEdge;
      }

      this.body.emitter.emit(eventType, properties);
    }
    /**
     *
     * @param {object} obj
     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
     * @returns {boolean}
     */

  }, {
    key: "selectObject",
    value: function selectObject(obj) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;

      if (obj !== undefined) {
        if (obj instanceof Node) {
          if (highlightEdges === true) {
            var _this$_selectionAccum;

            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray(obj.edges));
          }

          this._selectionAccumulator.addNodes(obj);
        } else {
          this._selectionAccumulator.addEdges(obj);
        }

        return true;
      }

      return false;
    }
    /**
     *
     * @param {object} obj
     */

  }, {
    key: "deselectObject",
    value: function deselectObject(obj) {
      if (obj.isSelected() === true) {
        obj.selected = false;

        this._removeFromSelection(obj);
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getAllNodesOverlappingWith",
    value: function _getAllNodesOverlappingWith(object) {
      var overlappingNodes = [];
      var nodes = this.body.nodes;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var nodeId = this.body.nodeIndices[i];

        if (nodes[nodeId].isOverlappingWith(object)) {
          overlappingNodes.push(nodeId);
        }
      }

      return overlappingNodes;
    }
    /**
     * Return a position object in canvasspace from a single point in screenspace
     *
     * @param {{x: number, y: number}} pointer
     * @returns {{left: number, top: number, right: number, bottom: number}}
     * @private
     */

  }, {
    key: "_pointerToPositionObject",
    value: function _pointerToPositionObject(pointer) {
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      return {
        left: canvasPos.x - 1,
        top: canvasPos.y + 1,
        right: canvasPos.x + 1,
        bottom: canvasPos.y - 1
      };
    }
    /**
     * Get the top node at the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnNode=true]
     * @returns {Node | undefined} node
     */

  }, {
    key: "getNodeAt",
    value: function getNodeAt(pointer) {
      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // we first check if this is an navigation controls element
      var positionObject = this._pointerToPositionObject(pointer);

      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject); // if there are overlapping nodes, select the last one, this is the
      // one which is drawn on top of the others


      if (overlappingNodes.length > 0) {
        if (returnNode === true) {
          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
        } else {
          return overlappingNodes[overlappingNodes.length - 1];
        }
      } else {
        return undefined;
      }
    }
    /**
     * retrieve all edges overlapping with given object, selector is around center
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getEdgesOverlappingWith",
    value: function _getEdgesOverlappingWith(object, overlappingEdges) {
      var edges = this.body.edges;

      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];

        if (edges[edgeId].isOverlappingWith(object)) {
          overlappingEdges.push(edgeId);
        }
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getAllEdgesOverlappingWith",
    value: function _getAllEdgesOverlappingWith(object) {
      var overlappingEdges = [];

      this._getEdgesOverlappingWith(object, overlappingEdges);

      return overlappingEdges;
    }
    /**
     * Get the edges nearest to the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnEdge=true]
     * @returns {Edge | undefined} node
     */

  }, {
    key: "getEdgeAt",
    value: function getEdgeAt(pointer) {
      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Iterate over edges, pick closest within 10
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      var mindist = 10;
      var overlappingEdge = null;
      var edges = this.body.edges;

      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        var edge = edges[edgeId];

        if (edge.connected) {
          var xFrom = edge.from.x;
          var yFrom = edge.from.y;
          var xTo = edge.to.x;
          var yTo = edge.to.y;
          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);

          if (dist < mindist) {
            overlappingEdge = edgeId;
            mindist = dist;
          }
        }
      }

      if (overlappingEdge !== null) {
        if (returnEdge === true) {
          return this.body.edges[overlappingEdge];
        } else {
          return overlappingEdge;
        }
      } else {
        return undefined;
      }
    }
    /**
     * Add object to the selection array.
     *
     * @param {object} obj
     * @private
     */

  }, {
    key: "_addToHover",
    value: function _addToHover(obj) {
      if (obj instanceof Node) {
        this.hoverObj.nodes[obj.id] = obj;
      } else {
        this.hoverObj.edges[obj.id] = obj;
      }
    }
    /**
     * Remove a single option from selection.
     *
     * @param {object} obj
     * @private
     */

  }, {
    key: "_removeFromSelection",
    value: function _removeFromSelection(obj) {
      if (obj instanceof Node) {
        var _this$_selectionAccum2;

        this._selectionAccumulator.deleteNodes(obj);

        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray(obj.edges));
      } else {
        this._selectionAccumulator.deleteEdges(obj);
      }
    }
    /**
     * Unselect all nodes and edges.
     */

  }, {
    key: "unselectAll",
    value: function unselectAll() {
      this._selectionAccumulator.clear();
    }
    /**
     * return the number of selected nodes
     *
     * @returns {number}
     */

  }, {
    key: "getSelectedNodeCount",
    value: function getSelectedNodeCount() {
      return this._selectionAccumulator.sizeNodes;
    }
    /**
     * return the number of selected edges
     *
     * @returns {number}
     */

  }, {
    key: "getSelectedEdgeCount",
    value: function getSelectedEdgeCount() {
      return this._selectionAccumulator.sizeEdges;
    }
    /**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: "_hoverConnectedEdges",
    value: function _hoverConnectedEdges(node) {
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        edge.hover = true;

        this._addToHover(edge);
      }
    }
    /**
     * Remove the highlight from a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @private
     */

  }, {
    key: "emitBlurEvent",
    value: function emitBlurEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      if (object.hover === true) {
        object.hover = false;

        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit("blurNode", properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit("blurEdge", properties);
        }
      }
    }
    /**
     * Create the highlight for a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @returns {boolean} hoverChanged
     * @private
     */

  }, {
    key: "emitHoverEvent",
    value: function emitHoverEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      var hoverChanged = false;

      if (object.hover === false) {
        object.hover = true;

        this._addToHover(object);

        hoverChanged = true;

        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit("hoverNode", properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit("hoverEdge", properties);
        }
      }

      return hoverChanged;
    }
    /**
     * Perform actions in response to a mouse movement.
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
     */

  }, {
    key: "hoverObject",
    value: function hoverObject(event, pointer) {
      var object = this.getNodeAt(pointer);

      if (object === undefined) {
        object = this.getEdgeAt(pointer);
      }

      var hoverChanged = false; // remove all node hover highlights

      for (var nodeId in this.hoverObj.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {
          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {
            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
            delete this.hoverObj.nodes[nodeId];
            hoverChanged = true;
          }
        }
      } // removing all edge hover highlights


      for (var edgeId in this.hoverObj.edges) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {
          // if the hover has been changed here it means that the node has been hovered over or off
          // we then do not use the emitBlurEvent method here.
          if (hoverChanged === true) {
            this.hoverObj.edges[edgeId].hover = false;
            delete this.hoverObj.edges[edgeId];
          } // if the blur remains the same and the object is undefined (mouse off) or another
          // edge has been hovered, or another node has been hovered we blur the edge.
          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {
            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
            delete this.hoverObj.edges[edgeId];
            hoverChanged = true;
          }
        }
      }

      if (object !== undefined) {
        var hoveredEdgesCount = keys$4(this.hoverObj.edges).length;

        var hoveredNodesCount = keys$4(this.hoverObj.nodes).length;

        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
        var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;

        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {
          hoverChanged = this.emitHoverEvent(event, pointer, object);
        }

        if (object instanceof Node && this.options.hoverConnectedEdges === true) {
          this._hoverConnectedEdges(object);
        }
      }

      if (hoverChanged === true) {
        this.body.emitter.emit("_requestRedraw");
      }
    }
    /**
     * Commit the selection changes but don't emit any events.
     */

  }, {
    key: "commitWithoutEmitting",
    value: function commitWithoutEmitting() {
      this._selectionAccumulator.commit();
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * For changing nodes, select/deselect events are fired.
     *
     * NOTE: For a given edge, if one connecting node is deselected and with the
     * same click the other node is selected, no events for the edge will fire. It
     * was selected and it will remain selected.
     *
     * @param {{x: number, y: number}} pointer - The x and y coordinates of the
     * click, tap, dragendâ¦ that triggered this.
     * @param {UIEvent} event - The event that triggered this.
     */

  }, {
    key: "commitAndEmit",
    value: function commitAndEmit(pointer, event) {
      var selected = false;

      var selectionChanges = this._selectionAccumulator.commit();

      var previousSelection = {
        nodes: selectionChanges.nodes.previous,
        edges: selectionChanges.edges.previous
      };

      if (selectionChanges.edges.deleted.length > 0) {
        this.generateClickEvent("deselectEdge", event, pointer, previousSelection);
        selected = true;
      }

      if (selectionChanges.nodes.deleted.length > 0) {
        this.generateClickEvent("deselectNode", event, pointer, previousSelection);
        selected = true;
      }

      if (selectionChanges.nodes.added.length > 0) {
        this.generateClickEvent("selectNode", event, pointer);
        selected = true;
      }

      if (selectionChanges.edges.added.length > 0) {
        this.generateClickEvent("selectEdge", event, pointer);
        selected = true;
      } // fire the select event if anything has been selected or deselected


      if (selected === true) {
        // select or unselect
        this.generateClickEvent("select", event, pointer);
      }
    }
    /**
     * Retrieve the currently selected node and edge ids.
     *
     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the
     * ids of the selected nodes and edges.
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return {
        nodes: this.getSelectedNodeIds(),
        edges: this.getSelectedEdgeIds()
      };
    }
    /**
     * Retrieve the currently selected nodes.
     *
     * @returns {Array} An array with selected nodes.
     */

  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      return this._selectionAccumulator.getNodes();
    }
    /**
     * Retrieve the currently selected edges.
     *
     * @returns {Array} An array with selected edges.
     */

  }, {
    key: "getSelectedEdges",
    value: function getSelectedEdges() {
      return this._selectionAccumulator.getEdges();
    }
    /**
     * Retrieve the currently selected node ids.
     *
     * @returns {Array} An array with the ids of the selected nodes.
     */

  }, {
    key: "getSelectedNodeIds",
    value: function getSelectedNodeIds() {
      var _context;

      return map$3(_context = this._selectionAccumulator.getNodes()).call(_context, function (node) {
        return node.id;
      });
    }
    /**
     * Retrieve the currently selected edge ids.
     *
     * @returns {Array} An array with the ids of the selected edges.
     */

  }, {
    key: "getSelectedEdgeIds",
    value: function getSelectedEdgeIds() {
      var _context2;

      return map$3(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function (edge) {
        return edge.id;
      });
    }
    /**
     * Updates the current selection
     *
     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
     * @param {object} options                                 Options
     */

  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!selection || !selection.nodes && !selection.edges) {
        throw new TypeError("Selection must be an object with nodes and/or edges properties");
      } // first unselect any selected node, if option is true or undefined


      if (options.unselectAll || options.unselectAll === undefined) {
        this.unselectAll();
      }

      if (selection.nodes) {
        var _iterator = _createForOfIteratorHelper$2(selection.nodes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var id = _step.value;
            var node = this.body.nodes[id];

            if (!node) {
              throw new RangeError('Node with id "' + id + '" not found');
            } // don't select edges with it


            this.selectObject(node, options.highlightEdges);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (selection.edges) {
        var _iterator2 = _createForOfIteratorHelper$2(selection.edges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _id = _step2.value;
            var edge = this.body.edges[_id];

            if (!edge) {
              throw new RangeError('Edge with id "' + _id + '" not found');
            }

            this.selectObject(edge);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      this.body.emitter.emit("_requestRedraw");

      this._selectionAccumulator.commit();
    }
    /**
     * select zero or more nodes with the option to highlight edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     * @param {boolean} [highlightEdges]
     */

  }, {
    key: "selectNodes",
    value: function selectNodes(selection) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!selection || selection.length === undefined) throw "Selection must be an array with ids";
      this.setSelection({
        nodes: selection
      }, {
        highlightEdges: highlightEdges
      });
    }
    /**
     * select zero or more edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     */

  }, {
    key: "selectEdges",
    value: function selectEdges(selection) {
      if (!selection || selection.length === undefined) throw "Selection must be an array with ids";
      this.setSelection({
        edges: selection
      });
    }
    /**
     * Validate the selection: remove ids of nodes which no longer exist
     *
     * @private
     */

  }, {
    key: "updateSelection",
    value: function updateSelection() {
      for (var node in this._selectionAccumulator.getNodes()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {
          this._selectionAccumulator.deleteNodes(node);
        }
      }

      for (var edge in this._selectionAccumulator.getEdges()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {
          this._selectionAccumulator.deleteEdges(edge);
        }
      }
    }
    /**
     * Determine all the visual elements clicked which are on the given point.
     *
     * All elements are returned; this includes nodes, edges and their labels.
     * The order returned is from highest to lowest, i.e. element 0 of the return
     * value is the topmost item clicked on.
     *
     * The return value consists of an array of the following possible elements:
     *
     * - `{nodeId:number}`             - node with given id clicked on
     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
     * - `{edgeId:number}`             - edge with given id clicked on
     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
     *
     * ## NOTES
     *
     * - Currently, there is only one label associated with a node or an edge,
     *   but this is expected to change somewhere in the future.
     * - Since there is no z-indexing yet, it is not really possible to set the nodes and
     *   edges in the correct order. For the time being, nodes come first.
     *
     * @param {point} pointer  mouse position in screen coordinates
     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
     * @private
     */

  }, {
    key: "getClickedItems",
    value: function getClickedItems(pointer) {
      var point = this.canvas.DOMtoCanvas(pointer);
      var items = []; // Note reverse order; we want the topmost clicked items to be first in the array
      // Also note that selected nodes are disregarded here; these normally display on top

      var nodeIndices = this.body.nodeIndices;
      var nodes = this.body.nodes;

      for (var i = nodeIndices.length - 1; i >= 0; i--) {
        var node = nodes[nodeIndices[i]];
        var ret = node.getItemsOnPoint(point);
        items.push.apply(items, ret); // Append the return value to the running list.
      }

      var edgeIndices = this.body.edgeIndices;
      var edges = this.body.edges;

      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
        var edge = edges[edgeIndices[_i]];

        var _ret = edge.getItemsOnPoint(point);

        items.push.apply(items, _ret); // Append the return value to the running list.
      }

      return items;
    }
  }]);

  return SelectionHandler;
}();

var timsort$1 = {};

/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/

(function (exports) {
  (function (global, factory) {
    {
      factory(exports);
    }
  })(commonjsGlobal, function (exports) {

    exports.__esModule = true;
    exports.sort = sort;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

    function log10(x) {
      if (x < 1e5) {
        if (x < 1e2) {
          return x < 1e1 ? 0 : 1;
        }

        if (x < 1e4) {
          return x < 1e3 ? 2 : 3;
        }

        return 4;
      }

      if (x < 1e7) {
        return x < 1e6 ? 5 : 6;
      }

      if (x < 1e9) {
        return x < 1e8 ? 7 : 8;
      }

      return 9;
    }

    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }

      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }

        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }

          if (a >= 0) {
            return 1;
          }

          a = -a;
          b = -b;
        }

        var al = log10(a);
        var bl = log10(b);
        var t = 0;

        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }

        if (a === b) {
          return t;
        }

        return a < b ? -1 : 1;
      }

      var aStr = String(a);
      var bStr = String(b);

      if (aStr === bStr) {
        return 0;
      }

      return aStr < bStr ? -1 : 1;
    }

    function minRunLength(n) {
      var r = 0;

      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }

      return n + r;
    }

    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;

      if (runHi === hi) {
        return 1;
      }

      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }

        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }

      return runHi - lo;
    }

    function reverseRun(array, lo, hi) {
      hi--;

      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }

    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }

      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;

        while (left < right) {
          var mid = left + right >>> 1;

          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }

        var n = start - left;

        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];

          case 2:
            array[left + 2] = array[left + 1];

          case 1:
            array[left + 1] = array[left];
            break;

          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }

        }

        array[left] = pivot;
      }
    }

    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }

      return offset;
    }

    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }

      return offset;
    }

    var TimSort = function () {
      function TimSort(array, compare) {
        _classCallCheck(this, TimSort);

        this.array = null;
        this.compare = null;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.length = 0;
        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
        this.stackLength = 0;
        this.runStart = null;
        this.runLength = null;
        this.stackSize = 0;
        this.array = array;
        this.compare = compare;
        this.length = array.length;

        if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
          this.tmpStorageLength = this.length >>> 1;
        }

        this.tmp = new Array(this.tmpStorageLength);
        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
      }

      TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      };

      TimSort.prototype.mergeRuns = function mergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;

          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }

          this.mergeAt(n);
        }
      };

      TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;

          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }

          this.mergeAt(n);
        }
      };

      TimSort.prototype.mergeAt = function mergeAt(i) {
        var compare = this.compare;
        var array = this.array;
        var start1 = this.runStart[i];
        var length1 = this.runLength[i];
        var start2 = this.runStart[i + 1];
        var length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;

        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }

        this.stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
          return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
          return;
        }

        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      };

      TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;

        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          return;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
          return;
        }

        var minGallop = this.minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;

              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;

              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }

              dest += count1;
              cursor1 += count1;
              length1 -= count1;

              if (length1 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest++] = array[cursor2++];

            if (--length2 === 0) {
              exit = true;
              break;
            }

            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }

              dest += count2;
              cursor2 += count2;
              length2 -= count2;

              if (length2 === 0) {
                exit = true;
                break;
              }
            }

            array[dest++] = tmp[cursor1++];

            if (--length1 === 1) {
              exit = true;
              break;
            }

            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (minGallop < 0) {
            minGallop = 0;
          }

          minGallop += 2;
        }

        this.minGallop = minGallop;

        if (minGallop < 1) {
          this.minGallop = 1;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error('mergeLow preconditions were not respected');
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      };

      TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;

        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }

          return;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
          return;
        }

        var minGallop = this.minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;

              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;

              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;

              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }

              if (length1 === 0) {
                exit = true;
                break;
              }
            }

            array[dest--] = tmp[cursor2--];

            if (--length2 === 1) {
              exit = true;
              break;
            }

            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;

              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }

              if (length2 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest--] = array[cursor1--];

            if (--length1 === 0) {
              exit = true;
              break;
            }

            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (minGallop < 0) {
            minGallop = 0;
          }

          minGallop += 2;
        }

        this.minGallop = minGallop;

        if (minGallop < 1) {
          this.minGallop = 1;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error('mergeHigh preconditions were not respected');
        } else {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      };

      return TimSort;
    }();

    function sort(array, compare, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError('Can only sort arrays');
      }

      if (!compare) {
        compare = alphabeticalCompare;
      } else if (typeof compare !== 'function') {
        hi = lo;
        lo = compare;
        compare = alphabeticalCompare;
      }

      if (!lo) {
        lo = 0;
      }

      if (!hi) {
        hi = array.length;
      }

      var remaining = hi - lo;

      if (remaining < 2) {
        return;
      }

      var runLength = 0;

      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }

      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);

      do {
        runLength = makeAscendingRun(array, lo, hi, compare);

        if (runLength < minRun) {
          var force = remaining;

          if (force > minRun) {
            force = minRun;
          }

          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);

      ts.forceMergeRuns();
    }
  });
})(timsort$1);

var timsort = timsort$1;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Interface definition for direction strategy classes.
 *
 * This class describes the interface for the Strategy
 * pattern classes used to differentiate horizontal and vertical
 * direction of hierarchical results.
 *
 * For a given direction, one coordinate will be 'fixed', meaning that it is
 * determined by level.
 * The other coordinate is 'unfixed', meaning that the nodes on a given level
 * can still move along that coordinate. So:
 *
 * - `vertical` layout: `x` unfixed, `y` fixed per level
 * - `horizontal` layout: `x` fixed per level, `y` unfixed
 *
 * The local methods are stubs and should be regarded as abstract.
 * Derived classes **must** implement all the methods themselves.
 *
 * @private
 */

var DirectionInterface = /*#__PURE__*/function () {
  function DirectionInterface() {
    _classCallCheck(this, DirectionInterface);
  }

  _createClass(DirectionInterface, [{
    key: "abstract",
    value:
    /**
     * @ignore
     */
    function abstract() {
      throw new Error("Can't instantiate abstract class!");
    }
    /**
     * This is a dummy call which is used to suppress the jsdoc errors of type:
     *
     *   "'param' is assigned a value but never used"
     *
     * @ignore
     */

  }, {
    key: "fake_use",
    value: function fake_use() {// Do nothing special
    }
    /**
     * Type to use to translate dynamic curves to, in the case of hierarchical layout.
     * Dynamic curves do not work for these.
     *
     * The value should be perpendicular to the actual direction of the layout.
     *
     * @returns {string} Direction, either 'vertical' or 'horizontal'
     */

  }, {
    key: "curveType",
    value: function curveType() {
      return this.abstract();
    }
    /**
     * Return the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to read
     * @returns {number} Value of the unfixed coordinate
     */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      this.fake_use(node);
      return this.abstract();
    }
    /**
     * Set the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to adjust
     * @param {number} position
     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
     */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      this.fake_use(node, position, level);
      this.abstract();
    }
    /**
     * Get the width of a tree.
     *
     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
     * only among themselves. In essence, it is a sub-network.
     *
     * @param {number} index The index number of a tree
     * @returns {number} the width of a tree in the view coordinates
     */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      this.fake_use(index);
      return this.abstract();
    }
    /**
     * Sort array of nodes on the unfixed coordinates.
     *
     * Note:** chrome has non-stable sorting implementation, which
     * has a tendency to change the order of the array items,
     * even if the custom sort function returns 0.
     *
     * For this reason, an external sort implementation is used,
     * which has the added benefit of being faster than the standard
     * platforms implementation. This has been verified on `node.js`,
     * `firefox` and `chrome` (all linux).
     *
     * @param {Array.<Node>} nodeArray array of nodes to sort
     */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      this.fake_use(nodeArray);
      this.abstract();
    }
    /**
     * Assign the fixed coordinate of the node to the given level
     *
     * @param {Node} node The node to adjust
     * @param {number} level The level to fix to
     */

  }, {
    key: "fix",
    value: function fix(node, level) {
      this.fake_use(node, level);
      this.abstract();
    }
    /**
     * Add an offset to the unfixed coordinate of the given node.
     *
     * @param {NodeId} nodeId Id of the node to adjust
     * @param {number} diff Offset to add to the unfixed coordinate
     */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.fake_use(nodeId, diff);
      this.abstract();
    }
  }]);

  return DirectionInterface;
}();
/**
 * Vertical Strategy
 *
 * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */


var VerticalStrategy = /*#__PURE__*/function (_DirectionInterface) {
  _inherits(VerticalStrategy, _DirectionInterface);

  var _super = _createSuper(VerticalStrategy);

  /**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */
  function VerticalStrategy(layout) {
    var _this;

    _classCallCheck(this, VerticalStrategy);

    _this = _super.call(this);
    _this.layout = layout;
    return _this;
  }
  /** @inheritDoc */


  _createClass(VerticalStrategy, [{
    key: "curveType",
    value: function curveType() {
      return "horizontal";
    }
    /** @inheritDoc */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      return node.x;
    }
    /** @inheritDoc */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }

      node.x = position;
    }
    /** @inheritDoc */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return {
        min: res.min_x,
        max: res.max_x
      };
    }
    /** @inheritDoc */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      timsort.sort(nodeArray, function (a, b) {
        return a.x - b.x;
      });
    }
    /** @inheritDoc */

  }, {
    key: "fix",
    value: function fix(node, level) {
      node.y = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.y = true;
    }
    /** @inheritDoc */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].x += diff;
    }
  }]);

  return VerticalStrategy;
}(DirectionInterface);
/**
 * Horizontal Strategy
 *
 * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */


var HorizontalStrategy = /*#__PURE__*/function (_DirectionInterface2) {
  _inherits(HorizontalStrategy, _DirectionInterface2);

  var _super2 = _createSuper(HorizontalStrategy);

  /**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */
  function HorizontalStrategy(layout) {
    var _this2;

    _classCallCheck(this, HorizontalStrategy);

    _this2 = _super2.call(this);
    _this2.layout = layout;
    return _this2;
  }
  /** @inheritDoc */


  _createClass(HorizontalStrategy, [{
    key: "curveType",
    value: function curveType() {
      return "vertical";
    }
    /** @inheritDoc */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      return node.y;
    }
    /** @inheritDoc */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }

      node.y = position;
    }
    /** @inheritDoc */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return {
        min: res.min_y,
        max: res.max_y
      };
    }
    /** @inheritDoc */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      timsort.sort(nodeArray, function (a, b) {
        return a.y - b.y;
      });
    }
    /** @inheritDoc */

  }, {
    key: "fix",
    value: function fix(node, level) {
      node.x = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.x = true;
    }
    /** @inheritDoc */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].y += diff;
    }
  }]);

  return HorizontalStrategy;
}(DirectionInterface);

var $ = _export;
var $every = arrayIteration.every;
var arrayMethodIsStrict = arrayMethodIsStrict$6;
var STRICT_METHOD = arrayMethodIsStrict('every'); // `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD
}, {
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual = entryVirtual$l;
var every$3 = entryVirtual('Array').every;

var isPrototypeOf = objectIsPrototypeOf;
var method = every$3;
var ArrayPrototype = Array.prototype;

var every$2 = function (it) {
  var own = it.every;
  return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.every ? method : own;
};

var parent = every$2;
var every$1 = parent;

var every = every$1;

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = slice(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Try to assign levels to nodes according to their positions in the cyclic âhierarchyâ.
 *
 * @param nodes - Visible nodes of the graph.
 * @param levels - If present levels will be added to it, if not a new object will be created.
 * @returns Populated node levels.
 */
function fillLevelsByDirectionCyclic(nodes, levels) {
  var edges = new set();

  forEach$2(nodes).call(nodes, function (node) {
    var _context;

    forEach$2(_context = node.edges).call(_context, function (edge) {
      if (edge.connected) {
        edges.add(edge);
      }
    });
  });

  forEach$2(edges).call(edges, function (edge) {
    var fromId = edge.from.id;
    var toId = edge.to.id;

    if (levels[fromId] == null) {
      levels[fromId] = 0;
    }

    if (levels[toId] == null || levels[fromId] >= levels[toId]) {
      levels[toId] = levels[fromId] + 1;
    }
  });

  return levels;
}
/**
 * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.
 *
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */


function fillLevelsByDirectionLeaves(nodes) {
  return fillLevelsByDirection( // Pick only leaves (nodes without children).
  function (node) {
    var _context2, _context3;

    return every(_context2 = filter(_context3 = node.edges // Take only visible nodes into account.
    ).call(_context3, function (edge) {
      return nodes.has(edge.toId);
    }) // Check that all edges lead to this node (leaf).
    ).call(_context2, function (edge) {
      return edge.to === node;
    });
  }, // Use the lowest level.
  function (newLevel, oldLevel) {
    return oldLevel > newLevel;
  }, // Go against the direction of the edges.
  "from", nodes);
}
/**
 * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.
 *
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */

function fillLevelsByDirectionRoots(nodes) {
  return fillLevelsByDirection( // Pick only roots (nodes without parents).
  function (node) {
    var _context4, _context5;

    return every(_context4 = filter(_context5 = node.edges // Take only visible nodes into account.
    ).call(_context5, function (edge) {
      return nodes.has(edge.toId);
    }) // Check that all edges lead from this node (root).
    ).call(_context4, function (edge) {
      return edge.from === node;
    });
  }, // Use the highest level.
  function (newLevel, oldLevel) {
    return oldLevel < newLevel;
  }, // Go in the direction of the edges.
  "to", nodes);
}
/**
 * Assign levels to nodes according to their positions in the hierarchy.
 *
 * @param isEntryNode - Checks and return true if the graph should be traversed from this node.
 * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.
 * @param direction - Wheter the graph should be traversed in the direction of the edges `"to"` or in the other way `"from"`.
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */

function fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {
  var _context6;

  var levels = create$5(null); // If acyclic, the graph can be walked through with (most likely way) fewer
  // steps than the number bellow. The exact value isn't too important as long
  // as it's quick to compute (doesn't impact acyclic graphs too much), is
  // higher than the number of steps actually needed (doesn't cut off before
  // acyclic graph is walked through) and prevents infinite loops (cuts off for
  // cyclic graphs).


  var limit = reduce(_context6 = _toConsumableArray(values(nodes).call(nodes))).call(_context6, function (acc, node) {
    return acc + 1 + node.edges.length;
  }, 0);

  var edgeIdProp = direction + "Id";
  var newLevelDiff = direction === "to" ? 1 : -1;

  var _iterator = _createForOfIteratorHelper$1(nodes),
      _step;

  try {
    var _loop = function _loop() {
      var _step$value = _slicedToArray(_step.value, 2),
          entryNodeId = _step$value[0],
          entryNode = _step$value[1];

      if ( // Skip if the node is not visible.
      !nodes.has(entryNodeId) || // Skip if the node is not an entry node.
      !isEntryNode(entryNode)) {
        return "continue";
      } // Line up all the entry nodes on level 0.


      levels[entryNodeId] = 0;
      var stack = [entryNode];
      var done = 0;
      var node = void 0;

      var _loop2 = function _loop2() {
        var _context7, _context8;

        if (!nodes.has(entryNodeId)) {
          // Skip if the node is not visible.
          return "continue";
        }

        var newLevel = levels[node.id] + newLevelDiff;

        forEach$2(_context7 = filter(_context8 = node.edges).call(_context8, function (edge) {
          return (// Ignore disconnected edges.
            edge.connected && // Ignore circular edges.
            edge.to !== edge.from && // Ignore edges leading to the node that's currently being processed.
            edge[direction] !== node && // Ignore edges connecting to an invisible node.
            nodes.has(edge.toId) && // Ignore edges connecting from an invisible node.
            nodes.has(edge.fromId)
          );
        })).call(_context7, function (edge) {
          var targetNodeId = edge[edgeIdProp];
          var oldLevel = levels[targetNodeId];

          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {
            levels[targetNodeId] = newLevel;
            stack.push(edge[direction]);
          }
        });

        if (done > limit) {
          // This would run forever on a cyclic graph.
          return {
            v: {
              v: fillLevelsByDirectionCyclic(nodes, levels)
            }
          };
        } else {
          ++done;
        }
      };

      while (node = stack.pop()) {
        var _ret2 = _loop2();

        if (_ret2 === "continue") continue;
        if (_typeof(_ret2) === "object") return _ret2.v;
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return levels;
}

/**
 * There's a mix-up with terms in the code. Following are the formal definitions:
 *
 *   tree   - a strict hierarchical network, i.e. every node has at most one parent
 *   forest - a collection of trees. These distinct trees are thus not connected.
 *
 * So:
 * - in a network that is not a tree, there exist nodes with multiple parents.
 * - a network consisting of unconnected sub-networks, of which at least one
 *   is not a tree, is not a forest.
 *
 * In the code, the definitions are:
 *
 *   tree   - any disconnected sub-network, strict hierarchical or not.
 *   forest - a bunch of these sub-networks
 *
 * The difference between tree and not-tree is important in the code, notably within
 * to the block-shifting algorithm. The algorithm assumes formal trees and fails
 * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).
 *
 * In order to distinguish the definitions in the following code, the adjective 'formal' is
 * used. If 'formal' is absent, you must assume the non-formal definition.
 *
 * ----------------------------------------------------------------------------------
 * NOTES
 * =====
 *
 * A hierarchical layout is a different thing from a hierarchical network.
 * The layout is a way to arrange the nodes in the view; this can be done
 * on non-hierarchical networks as well. The converse is also possible.
 */
/**
 * Container for derived data on current network, relating to hierarchy.
 *
 * @private
 */

var HierarchicalStatus = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function HierarchicalStatus() {
    _classCallCheck(this, HierarchicalStatus);

    this.childrenReference = {}; // child id's per node id

    this.parentReference = {}; // parent id's per node id

    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong

    this.distributionOrdering = {}; // The nodes per level, in the display order

    this.levels = {}; // hierarchy level per node id

    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.

    this.isTree = false; // True if current network is a formal tree

    this.treeIndex = -1; // Highest tree id in current network.
  }
  /**
   * Add the relation between given nodes to the current state.
   *
   * @param {Node.id} parentNodeId
   * @param {Node.id} childNodeId
   */


  _createClass(HierarchicalStatus, [{
    key: "addRelation",
    value: function addRelation(parentNodeId, childNodeId) {
      if (this.childrenReference[parentNodeId] === undefined) {
        this.childrenReference[parentNodeId] = [];
      }

      this.childrenReference[parentNodeId].push(childNodeId);

      if (this.parentReference[childNodeId] === undefined) {
        this.parentReference[childNodeId] = [];
      }

      this.parentReference[childNodeId].push(parentNodeId);
    }
    /**
     * Check if the current state is for a formal tree or formal forest.
     *
     * This is the case if every node has at most one parent.
     *
     * Pre: parentReference init'ed properly for current network
     */

  }, {
    key: "checkIfTree",
    value: function checkIfTree() {
      for (var i in this.parentReference) {
        if (this.parentReference[i].length > 1) {
          this.isTree = false;
          return;
        }
      }

      this.isTree = true;
    }
    /**
     * Return the number of separate trees in the current network.
     *
     * @returns {number}
     */

  }, {
    key: "numTrees",
    value: function numTrees() {
      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively
    }
    /**
     * Assign a tree id to a node
     *
     * @param {Node} node
     * @param {string|number} treeId
     */

  }, {
    key: "setTreeIndex",
    value: function setTreeIndex(node, treeId) {
      if (treeId === undefined) return; // Don't bother

      if (this.trees[node.id] === undefined) {
        this.trees[node.id] = treeId;
        this.treeIndex = Math.max(treeId, this.treeIndex);
      }
    }
    /**
     * Ensure level for given id is defined.
     *
     * Sets level to zero for given node id if not already present
     *
     * @param {Node.id} nodeId
     */

  }, {
    key: "ensureLevel",
    value: function ensureLevel(nodeId) {
      if (this.levels[nodeId] === undefined) {
        this.levels[nodeId] = 0;
      }
    }
    /**
     * get the maximum level of a branch.
     *
     * TODO: Never entered; find a test case to test this!
     *
     * @param {Node.id} nodeId
     * @returns {number}
     */

  }, {
    key: "getMaxLevel",
    value: function getMaxLevel(nodeId) {
      var _this = this;

      var accumulator = {};

      var _getMaxLevel = function _getMaxLevel(nodeId) {
        if (accumulator[nodeId] !== undefined) {
          return accumulator[nodeId];
        }

        var level = _this.levels[nodeId];

        if (_this.childrenReference[nodeId]) {
          var children = _this.childrenReference[nodeId];

          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              level = Math.max(level, _getMaxLevel(children[i]));
            }
          }
        }

        accumulator[nodeId] = level;
        return level;
      };

      return _getMaxLevel(nodeId);
    }
    /**
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */

  }, {
    key: "levelDownstream",
    value: function levelDownstream(nodeA, nodeB) {
      if (this.levels[nodeB.id] === undefined) {
        // set initial level
        if (this.levels[nodeA.id] === undefined) {
          this.levels[nodeA.id] = 0;
        } // set level


        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
      }
    }
    /**
     * Small util method to set the minimum levels of the nodes to zero.
     *
     * @param {Array.<Node>} nodes
     */

  }, {
    key: "setMinLevelToZero",
    value: function setMinLevelToZero(nodes) {
      var minLevel = 1e9; // get the minimum level

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (this.levels[nodeId] !== undefined) {
            minLevel = Math.min(this.levels[nodeId], minLevel);
          }
        }
      } // subtract the minimum from the set so we have a range starting from 0


      for (var _nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {
          if (this.levels[_nodeId] !== undefined) {
            this.levels[_nodeId] -= minLevel;
          }
        }
      }
    }
    /**
     * Get the min and max xy-coordinates of a given tree
     *
     * @param {Array.<Node>} nodes
     * @param {number} index
     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
     */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(nodes, index) {
      var min_x = 1e9;
      var max_x = -1e9;
      var min_y = 1e9;
      var max_y = -1e9;

      for (var nodeId in this.trees) {
        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {
          if (this.trees[nodeId] === index) {
            var node = nodes[nodeId];
            min_x = Math.min(node.x, min_x);
            max_x = Math.max(node.x, max_x);
            min_y = Math.min(node.y, min_y);
            max_y = Math.max(node.y, max_y);
          }
        }
      }

      return {
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y
      };
    }
    /**
     * Check if two nodes have the same parent(s)
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise
     */

  }, {
    key: "hasSameParent",
    value: function hasSameParent(node1, node2) {
      var parents1 = this.parentReference[node1.id];
      var parents2 = this.parentReference[node2.id];

      if (parents1 === undefined || parents2 === undefined) {
        return false;
      }

      for (var i = 0; i < parents1.length; i++) {
        for (var j = 0; j < parents2.length; j++) {
          if (parents1[i] == parents2[j]) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * Check if two nodes are in the same tree.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if this is so, false otherwise
     */

  }, {
    key: "inSameSubNetwork",
    value: function inSameSubNetwork(node1, node2) {
      return this.trees[node1.id] === this.trees[node2.id];
    }
    /**
     * Get a list of the distinct levels in the current network
     *
     * @returns {Array}
     */

  }, {
    key: "getLevels",
    value: function getLevels() {
      return keys$4(this.distributionOrdering);
    }
    /**
     * Add a node to the ordering per level
     *
     * @param {Node} node
     * @param {number} level
     */

  }, {
    key: "addToOrdering",
    value: function addToOrdering(node, level) {
      if (this.distributionOrdering[level] === undefined) {
        this.distributionOrdering[level] = [];
      }

      var isPresent = false;
      var curLevel = this.distributionOrdering[level];

      for (var n in curLevel) {
        //if (curLevel[n].id === node.id) {
        if (curLevel[n] === node) {
          isPresent = true;
          break;
        }
      }

      if (!isPresent) {
        this.distributionOrdering[level].push(node);
        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
      }
    }
  }]);

  return HierarchicalStatus;
}();
/**
 * The Layout Engine
 */


var LayoutEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function LayoutEngine(body) {
    _classCallCheck(this, LayoutEngine);

    this.body = body; // Make sure there always is some RNG because the setOptions method won't
    // set it unless there's a seed for it.

    this._resetRNG(Math.random() + ":" + now$1());

    this.setPhysics = false;
    this.options = {};
    this.optionsBackup = {
      physics: {}
    };
    this.defaultOptions = {
      randomSeed: undefined,
      improvedLayout: true,
      clusterThreshold: 150,
      hierarchical: {
        enabled: false,
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: "UD",
        // UD, DU, LR, RL
        sortMethod: "hubsize" // hubsize, directed

      }
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(LayoutEngine, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this;

      this.body.emitter.on("_dataChanged", function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_dataLoaded", function () {
        _this2.layoutNetwork();
      });
      this.body.emitter.on("_resetHierarchicalLayout", function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function () {
        if (_this2.options.hierarchical.enabled !== true) {
          return;
        } // get the type of static smooth curve in case it is required


        var type = _this2.direction.curveType(); // force all edges into static smooth curves.


        _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
      });
    }
    /**
     *
     * @param {object} options
     * @param {object} allOptions
     * @returns {object}
     */

  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions) {
      if (options !== undefined) {
        var hierarchical = this.options.hierarchical;
        var prevHierarchicalState = hierarchical.enabled;
        selectiveDeepExtend(["randomSeed", "improvedLayout", "clusterThreshold"], this.options, options);
        mergeOptions(this.options, options, "hierarchical");

        if (options.randomSeed !== undefined) {
          this._resetRNG(options.randomSeed);
        }

        if (hierarchical.enabled === true) {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit("refresh", true);
          } // make sure the level separation is the right way up


          if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
            if (hierarchical.levelSeparation > 0) {
              hierarchical.levelSeparation *= -1;
            }
          } else {
            if (hierarchical.levelSeparation < 0) {
              hierarchical.levelSeparation *= -1;
            }
          }

          this.setDirectionStrategy();
          this.body.emitter.emit("_resetHierarchicalLayout"); // because the hierarchical system needs it's own physics and smooth curve settings,
          // we adapt the other options if needed.

          return this.adaptAllOptionsForHierarchicalLayout(allOptions);
        } else {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit("refresh");
            return deepExtend(allOptions, this.optionsBackup);
          }
        }
      }

      return allOptions;
    }
    /**
     * Reset the random number generator with given seed.
     *
     * @param {any} seed - The seed that will be forwarded the the RNG.
     */

  }, {
    key: "_resetRNG",
    value: function _resetRNG(seed) {
      this.initialRandomSeed = seed;
      this._rng = Alea(this.initialRandomSeed);
    }
    /**
     *
     * @param {object} allOptions
     * @returns {object}
     */

  }, {
    key: "adaptAllOptionsForHierarchicalLayout",
    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
      if (this.options.hierarchical.enabled === true) {
        var backupPhysics = this.optionsBackup.physics; // set the physics

        if (allOptions.physics === undefined || allOptions.physics === true) {
          allOptions.physics = {
            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,
            solver: "hierarchicalRepulsion"
          };
          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;
          backupPhysics.solver = backupPhysics.solver || "barnesHut";
        } else if (_typeof(allOptions.physics) === "object") {
          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
          backupPhysics.solver = allOptions.physics.solver || "barnesHut";
          allOptions.physics.solver = "hierarchicalRepulsion";
        } else if (allOptions.physics !== false) {
          backupPhysics.solver = "barnesHut";
          allOptions.physics = {
            solver: "hierarchicalRepulsion"
          };
        } // get the type of static smooth curve in case it is required


        var type = this.direction.curveType(); // disable smooth curves if nothing is defined. If smooth curves have been turned on,
        // turn them into static smooth curves.

        if (allOptions.edges === undefined) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions.edges = {
            smooth: false
          };
        } else if (allOptions.edges.smooth === undefined) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions.edges.smooth = false;
        } else {
          if (typeof allOptions.edges.smooth === "boolean") {
            this.optionsBackup.edges = {
              smooth: allOptions.edges.smooth
            };
            allOptions.edges.smooth = {
              enabled: allOptions.edges.smooth,
              type: type
            };
          } else {
            var smooth = allOptions.edges.smooth; // allow custom types except for dynamic

            if (smooth.type !== undefined && smooth.type !== "dynamic") {
              type = smooth.type;
            } // TODO: this is options merging; see if the standard routines can be used here.


            this.optionsBackup.edges = {
              smooth: {
                enabled: smooth.enabled === undefined ? true : smooth.enabled,
                type: smooth.type === undefined ? "dynamic" : smooth.type,
                roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
                forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
              }
            }; // NOTE: Copying an object to self; this is basically setting defaults for undefined variables

            allOptions.edges.smooth = {
              enabled: smooth.enabled === undefined ? true : smooth.enabled,
              type: type,
              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
            };
          }
        } // Force all edges into static smooth curves.
        // Only applies to edges that do not use the global options for smooth.


        this.body.emitter.emit("_forceDisableDynamicCurves", type);
      }

      return allOptions;
    }
    /**
     *
     * @param {Array.<Node>} nodesArray
     */

  }, {
    key: "positionInitially",
    value: function positionInitially(nodesArray) {
      if (this.options.hierarchical.enabled !== true) {
        this._resetRNG(this.initialRandomSeed);

        var radius = nodesArray.length + 50;

        for (var i = 0; i < nodesArray.length; i++) {
          var node = nodesArray[i];

          var angle = 2 * Math.PI * this._rng();

          if (node.x === undefined) {
            node.x = radius * Math.cos(angle);
          }

          if (node.y === undefined) {
            node.y = radius * Math.sin(angle);
          }
        }
      }
    }
    /**
     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
     * cluster them first to reduce the amount.
     */

  }, {
    key: "layoutNetwork",
    value: function layoutNetwork() {
      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
        var indices = this.body.nodeIndices; // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
        // nodes have predefined positions we use this.

        var positionDefined = 0;

        for (var i = 0; i < indices.length; i++) {
          var node = this.body.nodes[indices[i]];

          if (node.predefinedPosition === true) {
            positionDefined += 1;
          }
        } // if less than half of the nodes have a predefined position we continue


        if (positionDefined < 0.5 * indices.length) {
          var MAX_LEVELS = 10;
          var level = 0;
          var clusterThreshold = this.options.clusterThreshold; //
          // Define the options for the hidden cluster nodes
          // These options don't propagate outside the clustering phase.
          //
          // Some options are explicitly disabled, because they may be set in group or default node options.
          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.
          //
          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden
          // cluster nodes, leading to an exception on creation.
          //
          // All settings here are performance related, except when noted otherwise.
          //

          var clusterOptions = {
            clusterNodeProperties: {
              shape: "ellipse",
              // Bugfix: avoid type 'image', no images supplied
              label: "",
              // avoid label handling
              group: "",
              // avoid group handling
              font: {
                multi: false
              } // avoid font propagation

            },
            clusterEdgeProperties: {
              label: "",
              // avoid label handling
              font: {
                multi: false
              },
              // avoid font propagation
              smooth: {
                enabled: false // avoid drawing penalty for complex edges

              }
            }
          }; // if there are a lot of nodes, we cluster before we run the algorithm.
          // NOTE: this part fails to find clusters for large scale-free networks, which should
          //       be easily clusterable.
          // TODO: examine why this is so

          if (indices.length > clusterThreshold) {
            var startLength = indices.length;

            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
              //console.time("clustering")
              level += 1;
              var before = indices.length; // if there are many nodes we do a hubsize cluster

              if (level % 3 === 0) {
                this.body.modules.clustering.clusterBridges(clusterOptions);
              } else {
                this.body.modules.clustering.clusterOutliers(clusterOptions);
              }

              var after = indices.length;

              if (before == after && level % 3 !== 0) {
                this._declusterAll();

                this.body.emitter.emit("_layoutFailed");
                console.info("This network could not be positioned by this version of the improved layout algorithm." + " Please disable improvedLayout for better performance.");
                return;
              } //console.timeEnd("clustering")
              //console.log(before,level,after);

            } // increase the size of the edges


            this.body.modules.kamadaKawai.setOptions({
              springLength: Math.max(150, 2 * startLength)
            });
          }

          if (level > MAX_LEVELS) {
            console.info("The clustering didn't succeed within the amount of interations allowed," + " progressing with partial result.");
          } // position the system for these nodes and edges


          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true); // shift to center point

          this._shiftToCenter(); // perturb the nodes a little bit to force the physics to kick in


          var offset = 70;

          for (var _i = 0; _i < indices.length; _i++) {
            // Only perturb the nodes that aren't fixed
            var _node = this.body.nodes[indices[_i]];

            if (_node.predefinedPosition === false) {
              _node.x += (0.5 - this._rng()) * offset;
              _node.y += (0.5 - this._rng()) * offset;
            }
          } // uncluster all clusters


          this._declusterAll(); // reposition all bezier nodes.


          this.body.emitter.emit("_repositionBezierNodes");
        }
      }
    }
    /**
     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
     *
     * @private
     */

  }, {
    key: "_shiftToCenter",
    value: function _shiftToCenter() {
      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
      var center = NetworkUtil.findCenter(range);

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];
        node.x -= center.x;
        node.y -= center.y;
      }
    }
    /**
     * Expands all clusters
     *
     * @private
     */

  }, {
    key: "_declusterAll",
    value: function _declusterAll() {
      var clustersPresent = true;

      while (clustersPresent === true) {
        clustersPresent = false;

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
            clustersPresent = true;
            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
          }
        }

        if (clustersPresent === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     *
     * @returns {number|*}
     */

  }, {
    key: "getSeed",
    value: function getSeed() {
      return this.initialRandomSeed;
    }
    /**
     * This is the main function to layout the nodes in a hierarchical way.
     * It checks if the node details are supplied correctly
     *
     * @private
     */

  }, {
    key: "setupHierarchicalLayout",
    value: function setupHierarchicalLayout() {
      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
        // get the size of the largest hubs and check if the user has defined a level for a node.
        var node, nodeId;
        var definedLevel = false;
        var undefinedLevel = false;
        this.lastNodeOnLevel = {};
        this.hierarchical = new HierarchicalStatus();

        for (nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            node = this.body.nodes[nodeId];

            if (node.options.level !== undefined) {
              definedLevel = true;
              this.hierarchical.levels[nodeId] = node.options.level;
            } else {
              undefinedLevel = true;
            }
          }
        } // if the user defined some levels but not all, alert and run without hierarchical layout


        if (undefinedLevel === true && definedLevel === true) {
          throw new Error("To use the hierarchical layout, nodes require either no predefined levels" + " or levels have to be defined for all nodes.");
        } else {
          // define levels if undefined by the users. Based on hubsize.
          if (undefinedLevel === true) {
            var sortMethod = this.options.hierarchical.sortMethod;

            if (sortMethod === "hubsize") {
              this._determineLevelsByHubsize();
            } else if (sortMethod === "directed") {
              this._determineLevelsDirected();
            } else if (sortMethod === "custom") {
              this._determineLevelsCustomCallback();
            }
          } // fallback for cases where there are nodes but no edges


          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.hierarchical.ensureLevel(_nodeId2);
            }
          } // check the distribution of the nodes per level.


          var distribution = this._getDistribution(); // get the parent children relations.


          this._generateMap(); // place the nodes on the canvas.


          this._placeNodesByHierarchy(distribution); // condense the whitespace.


          this._condenseHierarchy(); // shift to center so gravity does not have to do much


          this._shiftToCenter();
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_condenseHierarchy",
    value: function _condenseHierarchy() {
      var _this3 = this;

      // Global var in this scope to define when the movement has stopped.
      var stillShifting = false;
      var branches = {}; // first we have some methods to help shifting trees around.
      // the main method to shift the trees

      var shiftTrees = function shiftTrees() {
        var treeSizes = getTreeSizes();
        var shiftBy = 0;

        for (var i = 0; i < treeSizes.length - 1; i++) {
          var diff = treeSizes[i].max - treeSizes[i + 1].min;
          shiftBy += diff + _this3.options.hierarchical.treeSpacing;
          shiftTree(i + 1, shiftBy);
        }
      }; // shift a single tree by an offset


      var shiftTree = function shiftTree(index, offset) {
        var trees = _this3.hierarchical.trees;

        for (var nodeId in trees) {
          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {
            if (trees[nodeId] === index) {
              _this3.direction.shift(nodeId, offset);
            }
          }
        }
      }; // get the width of all trees


      var getTreeSizes = function getTreeSizes() {
        var treeWidths = [];

        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
          treeWidths.push(_this3.direction.getTreeSize(i));
        }

        return treeWidths;
      }; // get a map of all nodes in this branch


      var getBranchNodes = function getBranchNodes(source, map) {
        if (map[source.id]) {
          return;
        }

        map[source.id] = true;

        if (_this3.hierarchical.childrenReference[source.id]) {
          var children = _this3.hierarchical.childrenReference[source.id];

          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              getBranchNodes(_this3.body.nodes[children[i]], map);
            }
          }
        }
      }; // get a min max width as well as the maximum movement space it has on either sides
      // we use min max terminology because width and height can interchange depending on the direction of the layout


      var getBranchBoundary = function getBranchBoundary(branchMap) {
        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;
        var minSpace = 1e9;
        var maxSpace = 1e9;
        var min = 1e9;
        var max = -1e9;

        for (var branchNode in branchMap) {
          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {
            var node = _this3.body.nodes[branchNode];
            var level = _this3.hierarchical.levels[node.id];

            var position = _this3.direction.getPosition(node); // get the space around the node.


            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap),
                _this3$_getSpaceAroun2 = _slicedToArray(_this3$_getSpaceAroun, 2),
                minSpaceNode = _this3$_getSpaceAroun2[0],
                maxSpaceNode = _this3$_getSpaceAroun2[1];

            minSpace = Math.min(minSpaceNode, minSpace);
            maxSpace = Math.min(maxSpaceNode, maxSpace); // the width is only relevant for the levels two nodes have in common. This is why we filter on this.

            if (level <= maxLevel) {
              min = Math.min(position, min);
              max = Math.max(position, max);
            }
          }
        }

        return [min, max, minSpace, maxSpace];
      }; // check what the maximum level is these nodes have in common.


      var getCollisionLevel = function getCollisionLevel(node1, node2) {
        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);

        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);

        return Math.min(maxLevel1, maxLevel2);
      };
      /**
       * Condense elements. These can be nodes or branches depending on the callback.
       *
       * @param {Function} callback
       * @param {Array.<number>} levels
       * @param {*} centerParents
       */


      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
        var hier = _this3.hierarchical;

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = hier.distributionOrdering[level];

          if (levelNodes.length > 1) {
            for (var j = 0; j < levelNodes.length - 1; j++) {
              var node1 = levelNodes[j];
              var node2 = levelNodes[j + 1]; // NOTE: logic maintained as it was; if nodes have same ancestor,
              //       then of course they are in the same sub-network.

              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                callback(node1, node2, centerParents);
              }
            }
          }
        }
      }; // callback for shifting branches


      var branchShiftCallback = function branchShiftCallback(node1, node2) {
        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        //window.CALLBACKS.push(() => {
        var pos1 = _this3.direction.getPosition(node1);

        var pos2 = _this3.direction.getPosition(node2);

        var diffAbs = Math.abs(pos2 - pos1);
        var nodeSpacing = _this3.options.hierarchical.nodeSpacing; //console.log("NOW CHECKING:", node1.id, node2.id, diffAbs);

        if (diffAbs > nodeSpacing) {
          var branchNodes1 = {};
          var branchNodes2 = {};
          getBranchNodes(node1, branchNodes1);
          getBranchNodes(node2, branchNodes2); // check the largest distance between the branches

          var maxLevel = getCollisionLevel(node1, node2);
          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
          var max1 = branchNodeBoundary1[1];
          var min2 = branchNodeBoundary2[0];
          var minSpace2 = branchNodeBoundary2[2]; //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,
          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);

          var diffBranch = Math.abs(max1 - min2);

          if (diffBranch > nodeSpacing) {
            var offset = max1 - min2 + nodeSpacing;

            if (offset < -minSpace2 + nodeSpacing) {
              offset = -minSpace2 + nodeSpacing; //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
            }

            if (offset < 0) {
              //console.log("SHIFTING", node2.id, offset);
              _this3._shiftBlock(node2.id, offset);

              stillShifting = true;
              if (centerParent === true) _this3._centerParent(node2);
            }
          }
        } //this.body.emitter.emit("_redraw");})

      };

      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
        //window.CALLBACKS.push(() => {
        //  console.log("ts",node.id);
        var nodeId = node.id;
        var allEdges = node.edges;
        var nodeLevel = _this3.hierarchical.levels[node.id]; // gather constants

        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
        var referenceNodes = {};
        var aboveEdges = [];

        for (var i = 0; i < allEdges.length; i++) {
          var edge = allEdges[i];

          if (edge.toId != edge.fromId) {
            var otherNode = edge.toId == nodeId ? edge.from : edge.to;
            referenceNodes[allEdges[i].id] = otherNode;

            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
              aboveEdges.push(edge);
            }
          }
        } // differentiated sum of lengths based on only moving one node over one axis


        var getFx = function getFx(point, edges) {
          var sum = 0;

          for (var _i2 = 0; _i2 < edges.length; _i2++) {
            if (referenceNodes[edges[_i2].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
              sum += a / Math.sqrt(a * a + C2);
            }
          }

          return sum;
        }; // doubly differentiated sum of lengths based on only moving one node over one axis


        var getDFx = function getDFx(point, edges) {
          var sum = 0;

          for (var _i3 = 0; _i3 < edges.length; _i3++) {
            if (referenceNodes[edges[_i3].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
              sum -= C2 * Math.pow(a * a + C2, -1.5);
            }
          }

          return sum;
        };

        var getGuess = function getGuess(iterations, edges) {
          var guess = _this3.direction.getPosition(node); // Newton's method for optimization


          var guessMap = {};

          for (var _i4 = 0; _i4 < iterations; _i4++) {
            var fx = getFx(guess, edges);
            var dfx = getDFx(guess, edges); // we limit the movement to avoid instability.

            var limit = 40;
            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
            guess = guess - ratio; // reduce duplicates

            if (guessMap[guess] !== undefined) {
              break;
            }

            guessMap[guess] = _i4;
          }

          return guess;
        };

        var moveBranch = function moveBranch(guess) {
          // position node if there is space
          var nodePosition = _this3.direction.getPosition(node); // check movable area of the branch


          if (branches[node.id] === undefined) {
            var branchNodes = {};
            getBranchNodes(node, branchNodes);
            branches[node.id] = branchNodes;
          }

          var branchBoundary = getBranchBoundary(branches[node.id]);
          var minSpaceBranch = branchBoundary[2];
          var maxSpaceBranch = branchBoundary[3];
          var diff = guess - nodePosition; // check if we are allowed to move the node:

          var branchOffset = 0;

          if (diff > 0) {
            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          } else if (diff < 0) {
            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          }

          if (branchOffset != 0) {
            //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
            _this3._shiftBlock(node.id, branchOffset); //this.body.emitter.emit("_redraw");


            stillShifting = true;
          }
        };

        var moveNode = function moveNode(guess) {
          var nodePosition = _this3.direction.getPosition(node); // position node if there is space


          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node),
              _this3$_getSpaceAroun4 = _slicedToArray(_this3$_getSpaceAroun3, 2),
              minSpace = _this3$_getSpaceAroun4[0],
              maxSpace = _this3$_getSpaceAroun4[1];

          var diff = guess - nodePosition; // check if we are allowed to move the node:

          var newPosition = nodePosition;

          if (diff > 0) {
            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);
          } else if (diff < 0) {
            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);
          }

          if (newPosition !== nodePosition) {
            //console.log("moving Node:",diff, minSpace, maxSpace);
            _this3.direction.setPosition(node, newPosition); //this.body.emitter.emit("_redraw");


            stillShifting = true;
          }
        };

        var guess = getGuess(iterations, aboveEdges);
        moveBranch(guess);
        guess = getGuess(iterations, allEdges);
        moveNode(guess); //})
      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.


      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < iterations; i++) {
          stillShifting = false;

          for (var j = 0; j < levels.length; j++) {
            var level = levels[j];
            var levelNodes = _this3.hierarchical.distributionOrdering[level];

            for (var k = 0; k < levelNodes.length; k++) {
              minimizeEdgeLength(1000, levelNodes[k]);
            }
          }

          if (stillShifting !== true) {
            //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
            break;
          }
        }
      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.


      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          shiftElementsCloser(branchShiftCallback, levels, true);

          if (stillShifting !== true) {
            //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
            break;
          }
        }
      }; // center all parents


      var centerAllParents = function centerAllParents() {
        for (var nodeId in _this3.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);
        }
      }; // center all parents


      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = _this3.hierarchical.distributionOrdering[level];

          for (var j = 0; j < levelNodes.length; j++) {
            _this3._centerParent(levelNodes[j]);
          }
        }
      }; // the actual work is done here.


      if (this.options.hierarchical.blockShifting === true) {
        shiftBranchesCloserBottomUp(5);
        centerAllParents();
      } // minimize edge length


      if (this.options.hierarchical.edgeMinimization === true) {
        minimizeEdgeLengthBottomUp(20);
      }

      if (this.options.hierarchical.parentCentralization === true) {
        centerAllParentsBottomUp();
      }

      shiftTrees();
    }
    /**
     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
     * This is used to only get the distances to nodes outside of a branch.
     *
     * @param {Node} node
     * @param {{Node.id: vis.Node}} map
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getSpaceAroundNode",
    value: function _getSpaceAroundNode(node, map) {
      var useMap = true;

      if (map === undefined) {
        useMap = false;
      }

      var level = this.hierarchical.levels[node.id];

      if (level !== undefined) {
        var index = this.hierarchical.distributionIndex[node.id];
        var position = this.direction.getPosition(node);
        var ordering = this.hierarchical.distributionOrdering[level];
        var minSpace = 1e9;
        var maxSpace = 1e9;

        if (index !== 0) {
          var prevNode = ordering[index - 1];

          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
            var prevPos = this.direction.getPosition(prevNode);
            minSpace = position - prevPos;
          }
        }

        if (index != ordering.length - 1) {
          var nextNode = ordering[index + 1];

          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
            var nextPos = this.direction.getPosition(nextNode);
            maxSpace = Math.min(maxSpace, nextPos - position);
          }
        }

        return [minSpace, maxSpace];
      } else {
        return [0, 0];
      }
    }
    /**
     * We use this method to center a parent node and check if it does not cross other nodes when it does.
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: "_centerParent",
    value: function _centerParent(node) {
      if (this.hierarchical.parentReference[node.id]) {
        var parents = this.hierarchical.parentReference[node.id];

        for (var i = 0; i < parents.length; i++) {
          var parentId = parents[i];
          var parentNode = this.body.nodes[parentId];
          var children = this.hierarchical.childrenReference[parentId];

          if (children !== undefined) {
            // get the range of the children
            var newPosition = this._getCenterPosition(children);

            var position = this.direction.getPosition(parentNode);

            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode),
                _this$_getSpaceAround2 = _slicedToArray(_this$_getSpaceAround, 2),
                minSpace = _this$_getSpaceAround2[0],
                maxSpace = _this$_getSpaceAround2[1];

            var diff = position - newPosition;

            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
              this.direction.setPosition(parentNode, newPosition);
            }
          }
        }
      }
    }
    /**
     * This function places the nodes on the canvas based on the hierarchial distribution.
     *
     * @param {object} distribution | obtained by the function this._getDistribution()
     * @private
     */

  }, {
    key: "_placeNodesByHierarchy",
    value: function _placeNodesByHierarchy(distribution) {
      this.positionedNodes = {}; // start placing all the level 0 nodes first. Then recursively position their branches.

      for (var level in distribution) {
        if (Object.prototype.hasOwnProperty.call(distribution, level)) {
          var _context;

          // sort nodes in level by position:
          var nodeArray = keys$4(distribution[level]);

          nodeArray = this._indexArrayToNodes(nodeArray);

          sort(_context = this.direction).call(_context, nodeArray);

          var handledNodeCount = 0;

          for (var i = 0; i < nodeArray.length; i++) {
            var node = nodeArray[i];

            if (this.positionedNodes[node.id] === undefined) {
              var spacing = this.options.hierarchical.nodeSpacing;
              var pos = spacing * handledNodeCount; // We get the X or Y values we need and store them in pos and previousPos.
              // The get and set make sure we get X or Y

              if (handledNodeCount > 0) {
                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
              }

              this.direction.setPosition(node, pos, level);

              this._validatePositionAndContinue(node, level, pos);

              handledNodeCount++;
            }
          }
        }
      }
    }
    /**
     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
     * on a X position that ensures there will be no overlap.
     *
     * @param {Node.id} parentId
     * @param {number} parentLevel
     * @private
     */

  }, {
    key: "_placeBranchNodes",
    value: function _placeBranchNodes(parentId, parentLevel) {
      var _context2;

      var childRef = this.hierarchical.childrenReference[parentId]; // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.

      if (childRef === undefined) {
        return;
      } // get a list of childNodes


      var childNodes = [];

      for (var i = 0; i < childRef.length; i++) {
        childNodes.push(this.body.nodes[childRef[i]]);
      } // use the positions to order the nodes.


      sort(_context2 = this.direction).call(_context2, childNodes); // position the childNodes


      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
        var childNode = childNodes[_i5];
        var childNodeLevel = this.hierarchical.levels[childNode.id]; // check if the child node is below the parent node and if it has already been positioned.

        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
          // get the amount of space required for this node. If parent the width is based on the amount of children.
          var spacing = this.options.hierarchical.nodeSpacing;
          var pos = void 0; // we get the X or Y values we need and store them in pos and previousPos.
          // The get and set make sure we get X or Y

          if (_i5 === 0) {
            pos = this.direction.getPosition(this.body.nodes[parentId]);
          } else {
            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
          }

          this.direction.setPosition(childNode, pos, childNodeLevel);

          this._validatePositionAndContinue(childNode, childNodeLevel, pos);
        } else {
          return;
        }
      } // center the parent nodes.


      var center = this._getCenterPosition(childNodes);

      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
    }
    /**
     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
     * Finally it will call _placeBranchNodes to place the branch nodes.
     *
     * @param {Node} node
     * @param {number} level
     * @param {number} pos
     * @private
     */

  }, {
    key: "_validatePositionAndContinue",
    value: function _validatePositionAndContinue(node, level, pos) {
      // This method only works for formal trees and formal forests
      // Early exit if this is not the case
      if (!this.hierarchical.isTree) return; // if overlap has been detected, we shift the branch

      if (this.lastNodeOnLevel[level] !== undefined) {
        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);

        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;

          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);

          this._shiftBlock(sharedParent.withChild, diff);
        }
      }

      this.lastNodeOnLevel[level] = node.id; // store change in position.

      this.positionedNodes[node.id] = true;

      this._placeBranchNodes(node.id, level);
    }
    /**
     * Receives an array with node indices and returns an array with the actual node references.
     * Used for sorting based on node properties.
     *
     * @param {Array.<Node.id>} idArray
     * @returns {Array.<Node>}
     */

  }, {
    key: "_indexArrayToNodes",
    value: function _indexArrayToNodes(idArray) {
      var array = [];

      for (var i = 0; i < idArray.length; i++) {
        array.push(this.body.nodes[idArray[i]]);
      }

      return array;
    }
    /**
     * This function get the distribution of levels based on hubsize
     *
     * @returns {object}
     * @private
     */

  }, {
    key: "_getDistribution",
    value: function _getDistribution() {
      var distribution = {};
      var nodeId, node; // we fix Y because the hierarchy is vertical,
      // we fix X so we do not give a node an x position for a second time.
      // the fix of X is removed after the x value has been set.

      for (nodeId in this.body.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
          node = this.body.nodes[nodeId];
          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];
          this.direction.fix(node, level);

          if (distribution[level] === undefined) {
            distribution[level] = {};
          }

          distribution[level][nodeId] = node;
        }
      }

      return distribution;
    }
    /**
     * Return the active (i.e. visible) edges for this node
     *
     * @param {Node} node
     * @returns {Array.<vis.Edge>} Array of edge instances
     * @private
     */

  }, {
    key: "_getActiveEdges",
    value: function _getActiveEdges(node) {
      var _this4 = this;

      var result = [];
      forEach$1(node.edges, function (edge) {
        var _context3;

        if (indexOf(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {
          result.push(edge);
        }
      });
      return result;
    }
    /**
     * Get the hubsizes for all active nodes.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_getHubSizes",
    value: function _getHubSizes() {
      var _this5 = this;

      var hubSizes = {};
      var nodeIds = this.body.nodeIndices;
      forEach$1(nodeIds, function (nodeId) {
        var node = _this5.body.nodes[nodeId];

        var hubSize = _this5._getActiveEdges(node).length;

        hubSizes[hubSize] = true;
      }); // Make an array of the size sorted descending

      var result = [];
      forEach$1(hubSizes, function (size) {
        result.push(Number(size));
      });

      sort(timsort).call(timsort, result, function (a, b) {
        return b - a;
      });

      return result;
    }
    /**
     * this function allocates nodes in levels based on the recursive branching from the largest hubs.
     *
     * @private
     */

  }, {
    key: "_determineLevelsByHubsize",
    value: function _determineLevelsByHubsize() {
      var _this6 = this;

      var levelDownstream = function levelDownstream(nodeA, nodeB) {
        _this6.hierarchical.levelDownstream(nodeA, nodeB);
      };

      var hubSizes = this._getHubSizes();

      var _loop = function _loop(i) {
        var hubSize = hubSizes[i];
        if (hubSize === 0) return "break";
        forEach$1(_this6.body.nodeIndices, function (nodeId) {
          var node = _this6.body.nodes[nodeId];

          if (hubSize === _this6._getActiveEdges(node).length) {
            _this6._crawlNetwork(levelDownstream, nodeId);
          }
        });
      };

      for (var i = 0; i < hubSizes.length; ++i) {
        var _ret = _loop(i);

        if (_ret === "break") break;
      }
    }
    /**
     * TODO: release feature
     * TODO: Determine if this feature is needed at all
     *
     * @private
     */

  }, {
    key: "_determineLevelsCustomCallback",
    value: function _determineLevelsCustomCallback() {
      var _this7 = this;

      var minLevel = 100000; // TODO: this should come from options.
      // eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.

      var customCallback = function customCallback(nodeA, nodeB, edge) {}; // TODO: perhaps move to HierarchicalStatus.
      //       But I currently don't see the point, this method is not used.


      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
        var levelA = _this7.hierarchical.levels[nodeA.id]; // set initial level

        if (levelA === undefined) {
          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
        }

        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
        _this7.hierarchical.levels[nodeB.id] = levelA + diff;
      };

      this._crawlNetwork(levelByDirection);

      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Allocate nodes in levels based on the direction of the edges.
     *
     * @private
     */

  }, {
    key: "_determineLevelsDirected",
    value: function _determineLevelsDirected() {
      var _context4,
          _this8 = this;

      var nodes = reduce(_context4 = this.body.nodeIndices).call(_context4, function (acc, id) {
        acc.set(id, _this8.body.nodes[id]);
        return acc;
      }, new map());

      if (this.options.hierarchical.shakeTowards === "roots") {
        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);
      } else {
        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);
      }

      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Update the bookkeeping of parent and child.
     *
     * @private
     */

  }, {
    key: "_generateMap",
    value: function _generateMap() {
      var _this9 = this;

      var fillInRelations = function fillInRelations(parentNode, childNode) {
        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
          _this9.hierarchical.addRelation(parentNode.id, childNode.id);
        }
      };

      this._crawlNetwork(fillInRelations);

      this.hierarchical.checkIfTree();
    }
    /**
     * Crawl over the entire network and use a callback on each node couple that is connected to each other.
     *
     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
     * @param {Node.id} startingNodeId
     * @private
     */

  }, {
    key: "_crawlNetwork",
    value: function _crawlNetwork() {
      var _this10 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var startingNodeId = arguments.length > 1 ? arguments[1] : undefined;
      var progress = {};

      var crawler = function crawler(node, tree) {
        if (progress[node.id] === undefined) {
          _this10.hierarchical.setTreeIndex(node, tree);

          progress[node.id] = true;
          var childNode;

          var edges = _this10._getActiveEdges(node);

          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];

            if (edge.connected === true) {
              if (edge.toId == node.id) {
                // Not '===' because id's can be string and numeric
                childNode = edge.from;
              } else {
                childNode = edge.to;
              }

              if (node.id != childNode.id) {
                // Not '!==' because id's can be string and numeric
                callback(node, childNode, edge);
                crawler(childNode, tree);
              }
            }
          }
        }
      };

      if (startingNodeId === undefined) {
        // Crawl over all nodes
        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];

          if (progress[nodeId] === undefined) {
            var node = this.body.nodes[nodeId];
            crawler(node, treeIndex);
            treeIndex += 1;
          }
        }
      } else {
        // Crawl from the given starting node
        var _node2 = this.body.nodes[startingNodeId];

        if (_node2 === undefined) {
          console.error("Node not found:", startingNodeId);
          return;
        }

        crawler(_node2);
      }
    }
    /**
     * Shift a branch a certain distance
     *
     * @param {Node.id} parentId
     * @param {number} diff
     * @private
     */

  }, {
    key: "_shiftBlock",
    value: function _shiftBlock(parentId, diff) {
      var _this11 = this;

      var progress = {};

      var shifter = function shifter(parentId) {
        if (progress[parentId]) {
          return;
        }

        progress[parentId] = true;

        _this11.direction.shift(parentId, diff);

        var childRef = _this11.hierarchical.childrenReference[parentId];

        if (childRef !== undefined) {
          for (var i = 0; i < childRef.length; i++) {
            shifter(childRef[i]);
          }
        }
      };

      shifter(parentId);
    }
    /**
     * Find a common parent between branches.
     *
     * @param {Node.id} childA
     * @param {Node.id} childB
     * @returns {{foundParent, withChild}}
     * @private
     */

  }, {
    key: "_findCommonParent",
    value: function _findCommonParent(childA, childB) {
      var _this12 = this;

      var parents = {};

      var iterateParents = function iterateParents(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];

        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];
            parents[parent] = true;
            iterateParents(parents, parent);
          }
        }
      };

      var findParent = function findParent(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];

        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];

            if (parents[parent] !== undefined) {
              return {
                foundParent: parent,
                withChild: child
              };
            }

            var branch = findParent(parents, parent);

            if (branch.foundParent !== null) {
              return branch;
            }
          }
        }

        return {
          foundParent: null,
          withChild: child
        };
      };

      iterateParents(parents, childA);
      return findParent(parents, childB);
    }
    /**
     * Set the strategy pattern for handling the coordinates given the current direction.
     *
     * The individual instances contain all the operations and data specific to a layout direction.
     *
     * @param {Node} node
     * @param {{x: number, y: number}} position
     * @param {number} level
     * @param {boolean} [doNotUpdate=false]
     * @private
     */

  }, {
    key: "setDirectionStrategy",
    value: function setDirectionStrategy() {
      var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";

      if (isVertical) {
        this.direction = new VerticalStrategy(this);
      } else {
        this.direction = new HorizontalStrategy(this);
      }
    }
    /**
     * Determine the center position of a branch from the passed list of child nodes
     *
     * This takes into account the positions of all the child nodes.
     *
     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
     * @returns {number}
     * @private
     */

  }, {
    key: "_getCenterPosition",
    value: function _getCenterPosition(childNodes) {
      var minPos = 1e9;
      var maxPos = -1e9;

      for (var i = 0; i < childNodes.length; i++) {
        var childNode = void 0;

        if (childNodes[i].id !== undefined) {
          childNode = childNodes[i];
        } else {
          var childNodeId = childNodes[i];
          childNode = this.body.nodes[childNodeId];
        }

        var position = this.direction.getPosition(childNode);
        minPos = Math.min(minPos, position);
        maxPos = Math.max(maxPos, position);
      }

      return 0.5 * (minPos + maxPos);
    }
  }]);

  return LayoutEngine;
}();

var css_248z = "div.vis-network div.vis-manipulation {\n  box-sizing: content-box;\n\n  border-width: 0;\n  border-bottom: 1px;\n  border-style: solid;\n  border-color: #d6d9d8;\n  background: #ffffff; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #ffffff),\n    color-stop(48%, #fcfcfc),\n    color-stop(50%, #fafafa),\n    color-stop(100%, #fcfcfc)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#fcfcfc',GradientType=0 ); /* IE6-9 */\n\n  padding-top: 4px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 28px;\n}\n\ndiv.vis-network div.vis-edit-mode,\ndiv.vis-network button.vis-edit-mode {\n  position: absolute;\n  left: 0;\n  top: 5px;\n  height: 30px;\n}\n\n/* FIXME: shouldn't the vis-close button be a child of the vis-manipulation div? */\n\ndiv.vis-network button.vis-close {\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 30px;\n  height: 30px;\n\n  background-color: transparent;\n  background-position: 20px 3px;\n  background-repeat: no-repeat;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC');\n  border: none;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network button.vis-close:hover {\n  opacity: 0.6;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button,\ndiv.vis-network div.vis-edit-mode button.vis-button {\n  float: left;\n  font-family: verdana;\n  font-size: 12px;\n  border: none;\n  box-sizing: content-box;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  background-color: transparent;\n  background-position: 0px 0px;\n  background-repeat: no-repeat;\n  height: 24px;\n  margin-left: 10px;\n  cursor: pointer;\n  padding: 0px 8px 0px 8px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.2);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.5);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-back {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-none:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n  cursor: default;\n}\ndiv.vis-network div.vis-manipulation div.vis-none:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n}\ndiv.vis-network div.vis-manipulation div.vis-none {\n  padding: 0px;\n  line-height: 23px;\n}\ndiv.vis-network div.vis-manipulation div.notification {\n  margin: 2px;\n  font-weight: bold;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-add {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-edit,\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode {\n  background-color: #fcfcfc;\n  border: 1px solid #cccccc;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-connect {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-delete {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=');\n}\n/* top right bottom left */\ndiv.vis-network div.vis-manipulation div.vis-label,\ndiv.vis-network div.vis-edit-mode div.vis-label {\n  margin: 0 0 0 23px;\n  line-height: 25px;\n}\ndiv.vis-network div.vis-manipulation div.vis-separator-line {\n  float: left;\n  display: inline-block;\n  width: 1px;\n  height: 21px;\n  background-color: #bdbdbd;\n  margin: 0px 7px 0 15px; /*top right bottom left*/\n}\n\n/* TODO: is this redundant?\ndiv.network-navigation_wrapper {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n*/\n";
styleInject(css_248z);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { var _context32; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = slice(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Clears the toolbar div element of children
 *
 * @private
 */

var ManipulationSystem = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   * @param {InteractionHandler} interactionHandler
   */
  function ManipulationSystem(body, canvas, selectionHandler, interactionHandler) {
    var _this = this,
        _context,
        _context2;

    _classCallCheck(this, ManipulationSystem);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.interactionHandler = interactionHandler;
    this.editMode = false;
    this.manipulationDiv = undefined;
    this.editModeDiv = undefined;
    this.closeDiv = undefined;
    this._domEventListenerCleanupQueue = [];
    this.temporaryUIFunctions = {};
    this.temporaryEventFunctions = [];
    this.touchTime = 0;
    this.temporaryIds = {
      nodes: [],
      edges: []
    };
    this.guiEnabled = false;
    this.inMode = false;
    this.selectedControlNode = undefined;
    this.options = {};
    this.defaultOptions = {
      enabled: false,
      initiallyActive: false,
      addNode: true,
      addEdge: true,
      editNode: undefined,
      editEdge: true,
      deleteNode: true,
      deleteEdge: true,
      controlNodeStyle: {
        shape: "dot",
        size: 6,
        color: {
          background: "#ff0000",
          border: "#3c3c3c",
          highlight: {
            background: "#07f968",
            border: "#3c3c3c"
          }
        },
        borderWidth: 2,
        borderWidthSelected: 2
      }
    };

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("destroy", function () {
      _this._clean();
    });
    this.body.emitter.on("_dataChanged", bind$6(_context = this._restore).call(_context, this));
    this.body.emitter.on("_resetData", bind$6(_context2 = this._restore).call(_context2, this));
  }
  /**
   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
   *
   * @private
   */


  _createClass(ManipulationSystem, [{
    key: "_restore",
    value: function _restore() {
      if (this.inMode !== false) {
        if (this.options.initiallyActive === true) {
          this.enableEditMode();
        } else {
          this.disableEditMode();
        }
      }
    }
    /**
     * Set the Options
     *
     * @param {object} options
     * @param {object} allOptions
     * @param {object} globalOptions
     */

  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions, globalOptions) {
      if (allOptions !== undefined) {
        if (allOptions.locale !== undefined) {
          this.options.locale = allOptions.locale;
        } else {
          this.options.locale = globalOptions.locale;
        }

        if (allOptions.locales !== undefined) {
          this.options.locales = allOptions.locales;
        } else {
          this.options.locales = globalOptions.locales;
        }
      }

      if (options !== undefined) {
        if (typeof options === "boolean") {
          this.options.enabled = options;
        } else {
          this.options.enabled = true;
          deepExtend(this.options, options);
        }

        if (this.options.initiallyActive === true) {
          this.editMode = true;
        }

        this._setup();
      }
    }
    /**
     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
     *
     * @private
     */

  }, {
    key: "toggleEditMode",
    value: function toggleEditMode() {
      if (this.editMode === true) {
        this.disableEditMode();
      } else {
        this.enableEditMode();
      }
    }
    /**
     * Enables Edit Mode
     */

  }, {
    key: "enableEditMode",
    value: function enableEditMode() {
      this.editMode = true;

      this._clean();

      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        this.editModeDiv.style.display = "none";
        this.showManipulatorToolbar();
      }
    }
    /**
     * Disables Edit Mode
     */

  }, {
    key: "disableEditMode",
    value: function disableEditMode() {
      this.editMode = false;

      this._clean();

      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "none";
        this.closeDiv.style.display = "none";
        this.editModeDiv.style.display = "block";

        this._createEditButton();
      }
    }
    /**
     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
     *
     * @private
     */

  }, {
    key: "showManipulatorToolbar",
    value: function showManipulatorToolbar() {
      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean(); // reset global variables


      this.manipulationDOM = {}; // if the gui is enabled, draw all elements.

      if (this.guiEnabled === true) {
        var _context3, _context4;

        // a _restore will hide these menus
        this.editMode = true;
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();
        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();
        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
        var locale = this.options.locales[this.options.locale];
        var needSeperator = false;

        if (this.options.addNode !== false) {
          this._createAddNodeButton(locale);

          needSeperator = true;
        }

        if (this.options.addEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(1);
          } else {
            needSeperator = true;
          }

          this._createAddEdgeButton(locale);
        }

        if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
          if (needSeperator === true) {
            this._createSeperator(2);
          } else {
            needSeperator = true;
          }

          this._createEditNodeButton(locale);
        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(3);
          } else {
            needSeperator = true;
          }

          this._createEditEdgeButton(locale);
        } // remove buttons


        if (selectedTotalCount !== 0) {
          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }

            this._createDeleteButton(locale);
          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }

            this._createDeleteButton(locale);
          }
        } // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context3 = this.toggleEditMode).call(_context3, this)); // refresh this bar based on what has been selected


        this._temporaryBindEvent("select", bind$6(_context4 = this.showManipulatorToolbar).call(_context4, this));
      } // redraw to show any possible changes


      this.body.emitter.emit("_redraw");
    }
    /**
     * Create the toolbar for adding Nodes
     */

  }, {
    key: "addNodeMode",
    value: function addNodeMode() {
      var _context6;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "addNode";

      if (this.guiEnabled === true) {
        var _context5;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context5 = this.toggleEditMode).call(_context5, this));
      }

      this._temporaryBindEvent("click", bind$6(_context6 = this._performAddNode).call(_context6, this));
    }
    /**
     * call the bound function to handle the editing of the node. The node has to be selected.
     */

  }, {
    key: "editNode",
    value: function editNode() {
      var _this2 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      var node = this.selectionHandler.getSelectedNodes()[0];

      if (node !== undefined) {
        this.inMode = "editNode";

        if (typeof this.options.editNode === "function") {
          if (node.isCluster !== true) {
            var data = deepExtend({}, node.options, false);
            data.x = node.x;
            data.y = node.y;

            if (this.options.editNode.length === 2) {
              this.options.editNode(data, function (finalizedData) {
                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === "editNode") {
                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                  _this2.body.data.nodes.getDataSet().update(finalizedData);
                }

                _this2.showManipulatorToolbar();
              });
            } else {
              throw new Error("The function for edit does not support two arguments (data, callback)");
            }
          } else {
            alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
          }
        } else {
          throw new Error("No function has been configured to handle the editing of nodes.");
        }
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * create the toolbar to connect nodes
     */

  }, {
    key: "addEdgeMode",
    value: function addEdgeMode() {
      var _context8, _context9, _context10, _context11, _context12;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "addEdge";

      if (this.guiEnabled === true) {
        var _context7;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context7 = this.toggleEditMode).call(_context7, this));
      } // temporarily overload functions


      this._temporaryBindUI("onTouch", bind$6(_context8 = this._handleConnect).call(_context8, this));

      this._temporaryBindUI("onDragEnd", bind$6(_context9 = this._finishConnect).call(_context9, this));

      this._temporaryBindUI("onDrag", bind$6(_context10 = this._dragControlNode).call(_context10, this));

      this._temporaryBindUI("onRelease", bind$6(_context11 = this._finishConnect).call(_context11, this));

      this._temporaryBindUI("onDragStart", bind$6(_context12 = this._dragStartEdge).call(_context12, this));

      this._temporaryBindUI("onHold", function () {});
    }
    /**
     * create the toolbar to edit edges
     */

  }, {
    key: "editEdgeMode",
    value: function editEdgeMode() {
      // when using the gui, enable edit mode if it wasn't already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "editEdge";

      if (_typeof(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];

        if (this.edgeBeingEditedId !== undefined) {
          var edge = this.body.edges[this.edgeBeingEditedId];

          this._performEditEdge(edge.from.id, edge.to.id);

          return;
        }
      }

      if (this.guiEnabled === true) {
        var _context13;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context13 = this.toggleEditMode).call(_context13, this));
      }

      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];

      if (this.edgeBeingEditedId !== undefined) {
        var _context14, _context15, _context16, _context17;

        var _edge = this.body.edges[this.edgeBeingEditedId]; // create control nodes

        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);

        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);

        this.temporaryIds.nodes.push(controlNodeFrom.id);
        this.temporaryIds.nodes.push(controlNodeTo.id);
        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
        this.body.nodeIndices.push(controlNodeFrom.id);
        this.body.nodes[controlNodeTo.id] = controlNodeTo;
        this.body.nodeIndices.push(controlNodeTo.id); // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI

        this._temporaryBindUI("onTouch", bind$6(_context14 = this._controlNodeTouch).call(_context14, this)); // used to get the position


        this._temporaryBindUI("onTap", function () {}); // disabled


        this._temporaryBindUI("onHold", function () {}); // disabled


        this._temporaryBindUI("onDragStart", bind$6(_context15 = this._controlNodeDragStart).call(_context15, this)); // used to select control node


        this._temporaryBindUI("onDrag", bind$6(_context16 = this._controlNodeDrag).call(_context16, this)); // used to drag control node


        this._temporaryBindUI("onDragEnd", bind$6(_context17 = this._controlNodeDragEnd).call(_context17, this)); // used to connect or revert control nodes


        this._temporaryBindUI("onMouseMove", function () {}); // disabled
        // create function to position control nodes correctly on movement
        // automatically cleaned up because we use the temporary bind


        this._temporaryBindEvent("beforeDrawing", function (ctx) {
          var positions = _edge.edgeType.findBorderPositions(ctx);

          if (controlNodeFrom.selected === false) {
            controlNodeFrom.x = positions.from.x;
            controlNodeFrom.y = positions.from.y;
          }

          if (controlNodeTo.selected === false) {
            controlNodeTo.x = positions.to.x;
            controlNodeTo.y = positions.to.y;
          }
        });

        this.body.emitter.emit("_redraw");
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * delete everything in the selection
     */

  }, {
    key: "deleteSelected",
    value: function deleteSelected() {
      var _this3 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "delete";
      var selectedNodes = this.selectionHandler.getSelectedNodeIds();
      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();
      var deleteFunction = undefined;

      if (selectedNodes.length > 0) {
        for (var i = 0; i < selectedNodes.length; i++) {
          if (this.body.nodes[selectedNodes[i]].isCluster === true) {
            alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
            return;
          }
        }

        if (typeof this.options.deleteNode === "function") {
          deleteFunction = this.options.deleteNode;
        }
      } else if (selectedEdges.length > 0) {
        if (typeof this.options.deleteEdge === "function") {
          deleteFunction = this.options.deleteEdge;
        }
      }

      if (typeof deleteFunction === "function") {
        var data = {
          nodes: selectedNodes,
          edges: selectedEdges
        };

        if (deleteFunction.length === 2) {
          deleteFunction(data, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === "delete") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);

              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);

              _this3.body.emitter.emit("startSimulation");

              _this3.showManipulatorToolbar();
            } else {
              _this3.body.emitter.emit("startSimulation");

              _this3.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for delete does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().remove(selectedEdges);
        this.body.data.nodes.getDataSet().remove(selectedNodes);
        this.body.emitter.emit("startSimulation");
        this.showManipulatorToolbar();
      }
    } //********************************************** PRIVATE ***************************************//

    /**
     * draw or remove the DOM
     *
     * @private
     */

  }, {
    key: "_setup",
    value: function _setup() {
      if (this.options.enabled === true) {
        // Enable the GUI
        this.guiEnabled = true;

        this._createWrappers();

        if (this.editMode === false) {
          this._createEditButton();
        } else {
          this.showManipulatorToolbar();
        }
      } else {
        this._removeManipulationDOM(); // disable the gui


        this.guiEnabled = false;
      }
    }
    /**
     * create the div overlays that contain the DOM
     *
     * @private
     */

  }, {
    key: "_createWrappers",
    value: function _createWrappers() {
      // load the manipulator HTML elements. All styling done in css.
      if (this.manipulationDiv === undefined) {
        this.manipulationDiv = document.createElement("div");
        this.manipulationDiv.className = "vis-manipulation";

        if (this.editMode === true) {
          this.manipulationDiv.style.display = "block";
        } else {
          this.manipulationDiv.style.display = "none";
        }

        this.canvas.frame.appendChild(this.manipulationDiv);
      } // container for the edit button.


      if (this.editModeDiv === undefined) {
        this.editModeDiv = document.createElement("div");
        this.editModeDiv.className = "vis-edit-mode";

        if (this.editMode === true) {
          this.editModeDiv.style.display = "none";
        } else {
          this.editModeDiv.style.display = "block";
        }

        this.canvas.frame.appendChild(this.editModeDiv);
      } // container for the close div button


      if (this.closeDiv === undefined) {
        var _this$options$locales, _this$options$locales2;

        this.closeDiv = document.createElement("button");
        this.closeDiv.className = "vis-close";
        this.closeDiv.setAttribute("aria-label", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2["close"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales["en"]["close"]);
        this.closeDiv.style.display = this.manipulationDiv.style.display;
        this.canvas.frame.appendChild(this.closeDiv);
      }
    }
    /**
     * generate a new target node. Used for creating new edges and editing edges
     *
     * @param {number} x
     * @param {number} y
     * @returns {Node}
     * @private
     */

  }, {
    key: "_getNewTargetNode",
    value: function _getNewTargetNode(x, y) {
      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);
      controlNodeStyle.id = "targetNode" + v4();
      controlNodeStyle.hidden = false;
      controlNodeStyle.physics = false;
      controlNodeStyle.x = x;
      controlNodeStyle.y = y; // we have to define the bounding box in order for the nodes to be drawn immediately

      var node = this.body.functions.createNode(controlNodeStyle);
      node.shape.boundingBox = {
        left: x,
        right: x,
        top: y,
        bottom: y
      };
      return node;
    }
    /**
     * Create the edit button
     */

  }, {
    key: "_createEditButton",
    value: function _createEditButton() {
      var _context18;

      // restore everything to it's original state (if applicable)
      this._clean(); // reset the manipulationDOM


      this.manipulationDOM = {}; // empty the editModeDiv

      recursiveDOMDelete(this.editModeDiv); // create the contents for the editMode button

      var locale = this.options.locales[this.options.locale];

      var button = this._createButton("editMode", "vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);

      this.editModeDiv.appendChild(button); // bind a hammer listener to the button, calling the function toggleEditMode.

      this._bindElementEvents(button, bind$6(_context18 = this.toggleEditMode).call(_context18, this));
    }
    /**
     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
     *
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      // not in mode
      this.inMode = false; // _clean the divs

      if (this.guiEnabled === true) {
        recursiveDOMDelete(this.editModeDiv);
        recursiveDOMDelete(this.manipulationDiv); // removes all the bindings and overloads

        this._cleanupDOMEventListeners();
      } // remove temporary nodes and edges


      this._cleanupTemporaryNodesAndEdges(); // restore overloaded UI functions


      this._unbindTemporaryUIs(); // remove the temporaryEventFunctions


      this._unbindTemporaryEvents(); // restore the physics if required


      this.body.emitter.emit("restorePhysics");
    }
    /**
     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
     *
     * @private
     */

  }, {
    key: "_cleanupDOMEventListeners",
    value: function _cleanupDOMEventListeners() {
      var _context19;

      // _clean DOM event listener bindings
      var _iterator = _createForOfIteratorHelper(splice$1(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var callback = _step.value;
          callback();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Remove all DOM elements created by this module.
     *
     * @private
     */

  }, {
    key: "_removeManipulationDOM",
    value: function _removeManipulationDOM() {
      // removes all the bindings and overloads
      this._clean(); // empty the manipulation divs


      recursiveDOMDelete(this.manipulationDiv);
      recursiveDOMDelete(this.editModeDiv);
      recursiveDOMDelete(this.closeDiv); // remove the manipulation divs

      if (this.manipulationDiv) {
        this.canvas.frame.removeChild(this.manipulationDiv);
      }

      if (this.editModeDiv) {
        this.canvas.frame.removeChild(this.editModeDiv);
      }

      if (this.closeDiv) {
        this.canvas.frame.removeChild(this.closeDiv);
      } // set the references to undefined


      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;
    }
    /**
     * create a seperator line. the index is to differentiate in the manipulation dom
     *
     * @param {number} [index=1]
     * @private
     */

  }, {
    key: "_createSeperator",
    value: function _createSeperator() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.manipulationDOM["seperatorLineDiv" + index] = document.createElement("div");
      this.manipulationDOM["seperatorLineDiv" + index].className = "vis-separator-line";
      this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index]);
    } // ----------------------    DOM functions for buttons    --------------------------//

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createAddNodeButton",
    value: function _createAddNodeButton(locale) {
      var _context20;

      var button = this._createButton("addNode", "vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context20 = this.addNodeMode).call(_context20, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createAddEdgeButton",
    value: function _createAddEdgeButton(locale) {
      var _context21;

      var button = this._createButton("addEdge", "vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context21 = this.addEdgeMode).call(_context21, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createEditNodeButton",
    value: function _createEditNodeButton(locale) {
      var _context22;

      var button = this._createButton("editNode", "vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context22 = this.editNode).call(_context22, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createEditEdgeButton",
    value: function _createEditEdgeButton(locale) {
      var _context23;

      var button = this._createButton("editEdge", "vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context23 = this.editEdgeMode).call(_context23, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createDeleteButton",
    value: function _createDeleteButton(locale) {
      var _context24;

      var deleteBtnClass;

      if (this.options.rtl) {
        deleteBtnClass = "vis-delete-rtl";
      } else {
        deleteBtnClass = "vis-delete";
      }

      var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context24 = this.deleteSelected).call(_context24, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createBackButton",
    value: function _createBackButton(locale) {
      var _context25;

      var button = this._createButton("back", "vis-back", locale["back"] || this.options.locales["en"]["back"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context25 = this.showManipulatorToolbar).call(_context25, this));
    }
    /**
     *
     * @param {number|string} id
     * @param {string} className
     * @param {label} label
     * @param {string} labelClassName
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_createButton",
    value: function _createButton(id, className, label) {
      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "vis-label";
      this.manipulationDOM[id + "Div"] = document.createElement("button");
      this.manipulationDOM[id + "Div"].className = "vis-button " + className;
      this.manipulationDOM[id + "Label"] = document.createElement("div");
      this.manipulationDOM[id + "Label"].className = labelClassName;
      this.manipulationDOM[id + "Label"].innerText = label;
      this.manipulationDOM[id + "Div"].appendChild(this.manipulationDOM[id + "Label"]);
      return this.manipulationDOM[id + "Div"];
    }
    /**
     *
     * @param {Label} label
     * @private
     */

  }, {
    key: "_createDescription",
    value: function _createDescription(label) {
      this.manipulationDOM["descriptionLabel"] = document.createElement("div");
      this.manipulationDOM["descriptionLabel"].className = "vis-none";
      this.manipulationDOM["descriptionLabel"].innerText = label;
      this.manipulationDiv.appendChild(this.manipulationDOM["descriptionLabel"]);
    } // -------------------------- End of DOM functions for buttons ------------------------------//

    /**
     * this binds an event until cleanup by the clean functions.
     *
     * @param {Event}  event   The event
     * @param {Function} newFunction
     * @private
     */

  }, {
    key: "_temporaryBindEvent",
    value: function _temporaryBindEvent(event, newFunction) {
      this.temporaryEventFunctions.push({
        event: event,
        boundFunction: newFunction
      });
      this.body.emitter.on(event, newFunction);
    }
    /**
     * this overrides an UI function until cleanup by the clean function
     *
     * @param {string} UIfunctionName
     * @param {Function} newFunction
     * @private
     */

  }, {
    key: "_temporaryBindUI",
    value: function _temporaryBindUI(UIfunctionName, newFunction) {
      if (this.body.eventListeners[UIfunctionName] !== undefined) {
        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
        this.body.eventListeners[UIfunctionName] = newFunction;
      } else {
        throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + stringify$1(keys$4(this.body.eventListeners)));
      }
    }
    /**
     * Restore the overridden UI functions to their original state.
     *
     * @private
     */

  }, {
    key: "_unbindTemporaryUIs",
    value: function _unbindTemporaryUIs() {
      for (var functionName in this.temporaryUIFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {
          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
          delete this.temporaryUIFunctions[functionName];
        }
      }

      this.temporaryUIFunctions = {};
    }
    /**
     * Unbind the events created by _temporaryBindEvent
     *
     * @private
     */

  }, {
    key: "_unbindTemporaryEvents",
    value: function _unbindTemporaryEvents() {
      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
        var eventName = this.temporaryEventFunctions[i].event;
        var boundFunction = this.temporaryEventFunctions[i].boundFunction;
        this.body.emitter.off(eventName, boundFunction);
      }

      this.temporaryEventFunctions = [];
    }
    /**
     * Bind an hammer instance to a DOM element.
     *
     * @param {Element} domElement
     * @param {Function} boundFunction
     */

  }, {
    key: "_bindElementEvents",
    value: function _bindElementEvents(domElement, boundFunction) {
      // Bind touch events.
      var hammer = new Hammer(domElement, {});
      onTouch(hammer, boundFunction);

      this._domEventListenerCleanupQueue.push(function () {
        hammer.destroy();
      }); // Bind keyboard events.


      var keyupListener = function keyupListener(_ref) {
        var keyCode = _ref.keyCode,
            key = _ref.key;

        if (key === "Enter" || key === " " || keyCode === 13 || keyCode === 32) {
          boundFunction();
        }
      };

      domElement.addEventListener("keyup", keyupListener, false);

      this._domEventListenerCleanupQueue.push(function () {
        domElement.removeEventListener("keyup", keyupListener, false);
      });
    }
    /**
     * Neatly clean up temporary edges and nodes
     *
     * @private
     */

  }, {
    key: "_cleanupTemporaryNodesAndEdges",
    value: function _cleanupTemporaryNodesAndEdges() {
      // _clean temporary edges
      for (var i = 0; i < this.temporaryIds.edges.length; i++) {
        var _context26;

        this.body.edges[this.temporaryIds.edges[i]].disconnect();
        delete this.body.edges[this.temporaryIds.edges[i]];

        var indexTempEdge = indexOf(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);

        if (indexTempEdge !== -1) {
          var _context27;

          splice$1(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);
        }
      } // _clean temporary nodes


      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
        var _context28;

        delete this.body.nodes[this.temporaryIds.nodes[_i]];

        var indexTempNode = indexOf(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);

        if (indexTempNode !== -1) {
          var _context29;

          splice$1(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);
        }
      }

      this.temporaryIds = {
        nodes: [],
        edges: []
      };
    } // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

    /**
     * the touch is used to get the position of the initial click
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeTouch",
    value: function _controlNodeTouch(event) {
      this.selectionHandler.unselectAll();
      this.lastTouch = this.body.functions.getPointer(event.center);
      this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object
    }
    /**
     * the drag start is used to mark one of the control nodes as selected.
     *
     * @private
     */

  }, {
    key: "_controlNodeDragStart",
    value: function _controlNodeDragStart() {
      var pointer = this.lastTouch;

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var from = this.body.nodes[this.temporaryIds.nodes[0]];
      var to = this.body.nodes[this.temporaryIds.nodes[1]];
      var edge = this.body.edges[this.edgeBeingEditedId];
      this.selectedControlNode = undefined;
      var fromSelect = from.isOverlappingWith(pointerObj);
      var toSelect = to.isOverlappingWith(pointerObj);

      if (fromSelect === true) {
        this.selectedControlNode = from;
        edge.edgeType.from = from;
      } else if (toSelect === true) {
        this.selectedControlNode = to;
        edge.edgeType.to = to;
      } // we use the selection to find the node that is being dragged. We explicitly select it here.


      if (this.selectedControlNode !== undefined) {
        this.selectionHandler.selectObject(this.selectedControlNode);
      }

      this.body.emitter.emit("_redraw");
    }
    /**
     * dragging the control nodes or the canvas
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeDrag",
    value: function _controlNodeDrag(event) {
      this.body.emitter.emit("disablePhysics");
      var pointer = this.body.functions.getPointer(event.center);
      var pos = this.canvas.DOMtoCanvas(pointer);

      if (this.selectedControlNode !== undefined) {
        this.selectedControlNode.x = pos.x;
        this.selectedControlNode.y = pos.y;
      } else {
        this.interactionHandler.onDrag(event);
      }

      this.body.emitter.emit("_redraw");
    }
    /**
     * connecting or restoring the control nodes.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeDragEnd",
    value: function _controlNodeDragEnd(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var edge = this.body.edges[this.edgeBeingEditedId]; // if the node that was dragged is not a control node, return

      if (this.selectedControlNode === undefined) {
        return;
      } // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.


      this.selectionHandler.unselectAll();

      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      } // perform the connection


      if (node !== undefined && this.selectedControlNode !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          var from = this.body.nodes[this.temporaryIds.nodes[0]];

          if (this.selectedControlNode.id === from.id) {
            this._performEditEdge(node.id, edge.to.id);
          } else {
            this._performEditEdge(edge.from.id, node.id);
          }
        }
      } else {
        edge.updateEdgeType();
        this.body.emitter.emit("restorePhysics");
      }

      this.body.emitter.emit("_redraw");
    } // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//

    /**
     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
     * to walk the user through the process.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_handleConnect",
    value: function _handleConnect(event) {
      // check to avoid double fireing of this function.
      if (new Date().valueOf() - this.touchTime > 100) {
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object

        this.interactionHandler.drag.pointer = this.lastTouch; // Drag pointer is not updated when adding edges

        this.interactionHandler.drag.translation = this.lastTouch.translation;
        var pointer = this.lastTouch;
        var node = this.selectionHandler.getNodeAt(pointer);

        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
          } else {
            // create a node the temporary line can look at
            var targetNode = this._getNewTargetNode(node.x, node.y);

            this.body.nodes[targetNode.id] = targetNode;
            this.body.nodeIndices.push(targetNode.id); // create a temporary edge

            var connectionEdge = this.body.functions.createEdge({
              id: "connectionEdge" + v4(),
              from: node.id,
              to: targetNode.id,
              physics: false,
              smooth: {
                enabled: true,
                type: "continuous",
                roundness: 0.5
              }
            });
            this.body.edges[connectionEdge.id] = connectionEdge;
            this.body.edgeIndices.push(connectionEdge.id);
            this.temporaryIds.nodes.push(targetNode.id);
            this.temporaryIds.edges.push(connectionEdge.id);
          }
        }

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_dragControlNode",
    value: function _dragControlNode(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id


      var connectFromId = undefined;

      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      } // get the overlapping node but NOT the temporary node;


      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context30;

        // if the node id is NOT a temporary node, accept the node.
        if (indexOf(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }

      event.controlEdge = {
        from: connectFromId,
        to: node ? node.id : undefined
      };
      this.selectionHandler.generateClickEvent("controlNodeDragging", event, pointer);

      if (this.temporaryIds.nodes[0] !== undefined) {
        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.

        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        this.body.emitter.emit("_redraw");
      } else {
        this.interactionHandler.onDrag(event);
      }
    }
    /**
     * Connect the new edge to the target if one exists, otherwise remove temp line
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_finishConnect",
    value: function _finishConnect(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id


      var connectFromId = undefined;

      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      } // get the overlapping node but NOT the temporary node;


      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context31;

        // if the node id is NOT a temporary node, accept the node.
        if (indexOf(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      } // clean temporary nodes and edges.


      this._cleanupTemporaryNodesAndEdges(); // perform the connection


      if (node !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
            this._performAddEdge(connectFromId, node.id);
          }
        }
      }

      event.controlEdge = {
        from: connectFromId,
        to: node ? node.id : undefined
      };
      this.selectionHandler.generateClickEvent("controlNodeDragEnd", event, pointer); // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.

      this.body.emitter.emit("_redraw");
    }
    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_dragStartEdge",
    value: function _dragStartEdge(event) {
      var pointer = this.lastTouch;
      this.selectionHandler.generateClickEvent("dragStart", event, pointer, undefined, true);
    } // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
    // ------------------------------ Performing all the actual data manipulation ------------------------//

    /**
     * Adds a node on the specified location
     *
     * @param {object} clickData
     * @private
     */

  }, {
    key: "_performAddNode",
    value: function _performAddNode(clickData) {
      var _this4 = this;

      var defaultData = {
        id: v4(),
        x: clickData.pointer.canvas.x,
        y: clickData.pointer.canvas.y,
        label: "new"
      };

      if (typeof this.options.addNode === "function") {
        if (this.options.addNode.length === 2) {
          this.options.addNode(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === "addNode") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this4.body.data.nodes.getDataSet().add(finalizedData);
            }

            _this4.showManipulatorToolbar();
          });
        } else {
          this.showManipulatorToolbar();
          throw new Error("The function for add does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.nodes.getDataSet().add(defaultData);
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: "_performAddEdge",
    value: function _performAddEdge(sourceNodeId, targetNodeId) {
      var _this5 = this;

      var defaultData = {
        from: sourceNodeId,
        to: targetNodeId
      };

      if (typeof this.options.addEdge === "function") {
        if (this.options.addEdge.length === 2) {
          this.options.addEdge(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === "addEdge") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this5.body.data.edges.getDataSet().add(finalizedData);

              _this5.selectionHandler.unselectAll();

              _this5.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for connect does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.edges.getDataSet().add(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: "_performEditEdge",
    value: function _performEditEdge(sourceNodeId, targetNodeId) {
      var _this6 = this;

      var defaultData = {
        id: this.edgeBeingEditedId,
        from: sourceNodeId,
        to: targetNodeId,
        label: this.body.data.edges.get(this.edgeBeingEditedId).label
      };
      var eeFunct = this.options.editEdge;

      if (_typeof(eeFunct) === "object") {
        eeFunct = eeFunct.editWithoutDrag;
      }

      if (typeof eeFunct === "function") {
        if (eeFunct.length === 2) {
          eeFunct(defaultData, function (finalizedData) {
            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== "editEdge") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this6.body.edges[defaultData.id].updateEdgeType();

              _this6.body.emitter.emit("_redraw");

              _this6.showManipulatorToolbar();
            } else {
              _this6.body.data.edges.getDataSet().update(finalizedData);

              _this6.selectionHandler.unselectAll();

              _this6.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for edit does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().update(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
  }]);

  return ManipulationSystem;
}();

/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
var string = "string";
var bool = "boolean";
var number = "number";
var array = "array";
var object = "object"; // should only be in a __type__ property

var dom = "dom";
var any = "any"; // List of endpoints

var endPoints = ["arrow", "bar", "box", "circle", "crow", "curve", "diamond", "image", "inv_curve", "inv_triangle", "triangle", "vee"];
/* eslint-disable @typescript-eslint/naming-convention -- The __*__ format is used to prevent collisions with actual option names. */

var nodeOptions = {
  borderWidth: {
    number: number
  },
  borderWidthSelected: {
    number: number,
    undefined: "undefined"
  },
  brokenImage: {
    string: string,
    undefined: "undefined"
  },
  chosen: {
    label: {
      boolean: bool,
      function: "function"
    },
    node: {
      boolean: bool,
      function: "function"
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  color: {
    border: {
      string: string
    },
    background: {
      string: string
    },
    highlight: {
      border: {
        string: string
      },
      background: {
        string: string
      },
      __type__: {
        object: object,
        string: string
      }
    },
    hover: {
      border: {
        string: string
      },
      background: {
        string: string
      },
      __type__: {
        object: object,
        string: string
      }
    },
    __type__: {
      object: object,
      string: string
    }
  },
  opacity: {
    number: number,
    undefined: "undefined"
  },
  fixed: {
    x: {
      boolean: bool
    },
    y: {
      boolean: bool
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  font: {
    align: {
      string: string
    },
    color: {
      string: string
    },
    size: {
      number: number
    },
    face: {
      string: string
    },
    background: {
      string: string
    },
    strokeWidth: {
      number: number
    },
    strokeColor: {
      string: string
    },
    vadjust: {
      number: number
    },
    multi: {
      boolean: bool,
      string: string
    },
    bold: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    boldital: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    ital: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    mono: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    __type__: {
      object: object,
      string: string
    }
  },
  group: {
    string: string,
    number: number,
    undefined: "undefined"
  },
  heightConstraint: {
    minimum: {
      number: number
    },
    valign: {
      string: string
    },
    __type__: {
      object: object,
      boolean: bool,
      number: number
    }
  },
  hidden: {
    boolean: bool
  },
  icon: {
    face: {
      string: string
    },
    code: {
      string: string
    },
    size: {
      number: number
    },
    color: {
      string: string
    },
    weight: {
      string: string,
      number: number
    },
    __type__: {
      object: object
    }
  },
  id: {
    string: string,
    number: number
  },
  image: {
    selected: {
      string: string,
      undefined: "undefined"
    },
    unselected: {
      string: string,
      undefined: "undefined"
    },
    __type__: {
      object: object,
      string: string
    }
  },
  imagePadding: {
    top: {
      number: number
    },
    right: {
      number: number
    },
    bottom: {
      number: number
    },
    left: {
      number: number
    },
    __type__: {
      object: object,
      number: number
    }
  },
  label: {
    string: string,
    undefined: "undefined"
  },
  labelHighlightBold: {
    boolean: bool
  },
  level: {
    number: number,
    undefined: "undefined"
  },
  margin: {
    top: {
      number: number
    },
    right: {
      number: number
    },
    bottom: {
      number: number
    },
    left: {
      number: number
    },
    __type__: {
      object: object,
      number: number
    }
  },
  mass: {
    number: number
  },
  physics: {
    boolean: bool
  },
  scaling: {
    min: {
      number: number
    },
    max: {
      number: number
    },
    label: {
      enabled: {
        boolean: bool
      },
      min: {
        number: number
      },
      max: {
        number: number
      },
      maxVisible: {
        number: number
      },
      drawThreshold: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    customScalingFunction: {
      function: "function"
    },
    __type__: {
      object: object
    }
  },
  shadow: {
    enabled: {
      boolean: bool
    },
    color: {
      string: string
    },
    size: {
      number: number
    },
    x: {
      number: number
    },
    y: {
      number: number
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  shape: {
    string: ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
  },
  ctxRenderer: {
    function: "function"
  },
  shapeProperties: {
    borderDashes: {
      boolean: bool,
      array: array
    },
    borderRadius: {
      number: number
    },
    interpolation: {
      boolean: bool
    },
    useImageSize: {
      boolean: bool
    },
    useBorderWithImage: {
      boolean: bool
    },
    coordinateOrigin: {
      string: ["center", "top-left"]
    },
    __type__: {
      object: object
    }
  },
  size: {
    number: number
  },
  title: {
    string: string,
    dom: dom,
    undefined: "undefined"
  },
  value: {
    number: number,
    undefined: "undefined"
  },
  widthConstraint: {
    minimum: {
      number: number
    },
    maximum: {
      number: number
    },
    __type__: {
      object: object,
      boolean: bool,
      number: number
    }
  },
  x: {
    number: number
  },
  y: {
    number: number
  },
  __type__: {
    object: object
  }
};
var allOptions = {
  configure: {
    enabled: {
      boolean: bool
    },
    filter: {
      boolean: bool,
      string: string,
      array: array,
      function: "function"
    },
    container: {
      dom: dom
    },
    showButton: {
      boolean: bool
    },
    __type__: {
      object: object,
      boolean: bool,
      string: string,
      array: array,
      function: "function"
    }
  },
  edges: {
    arrows: {
      to: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageHeight: {
          number: number
        },
        imageWidth: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      middle: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number: number
        },
        imageHeight: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      from: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number: number
        },
        imageHeight: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      __type__: {
        string: ["from", "to", "middle"],
        object: object
      }
    },
    endPointOffset: {
      from: {
        number: number
      },
      to: {
        number: number
      },
      __type__: {
        object: object,
        number: number
      }
    },
    arrowStrikethrough: {
      boolean: bool
    },
    background: {
      enabled: {
        boolean: bool
      },
      color: {
        string: string
      },
      size: {
        number: number
      },
      dashes: {
        boolean: bool,
        array: array
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    chosen: {
      label: {
        boolean: bool,
        function: "function"
      },
      edge: {
        boolean: bool,
        function: "function"
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    color: {
      color: {
        string: string
      },
      highlight: {
        string: string
      },
      hover: {
        string: string
      },
      inherit: {
        string: ["from", "to", "both"],
        boolean: bool
      },
      opacity: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    dashes: {
      boolean: bool,
      array: array
    },
    font: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      background: {
        string: string
      },
      strokeWidth: {
        number: number
      },
      strokeColor: {
        string: string
      },
      align: {
        string: ["horizontal", "top", "middle", "bottom"]
      },
      vadjust: {
        number: number
      },
      multi: {
        boolean: bool,
        string: string
      },
      bold: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      boldital: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      ital: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      mono: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      __type__: {
        object: object,
        string: string
      }
    },
    hidden: {
      boolean: bool
    },
    hoverWidth: {
      function: "function",
      number: number
    },
    label: {
      string: string,
      undefined: "undefined"
    },
    labelHighlightBold: {
      boolean: bool
    },
    length: {
      number: number,
      undefined: "undefined"
    },
    physics: {
      boolean: bool
    },
    scaling: {
      min: {
        number: number
      },
      max: {
        number: number
      },
      label: {
        enabled: {
          boolean: bool
        },
        min: {
          number: number
        },
        max: {
          number: number
        },
        maxVisible: {
          number: number
        },
        drawThreshold: {
          number: number
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      customScalingFunction: {
        function: "function"
      },
      __type__: {
        object: object
      }
    },
    selectionWidth: {
      function: "function",
      number: number
    },
    selfReferenceSize: {
      number: number
    },
    selfReference: {
      size: {
        number: number
      },
      angle: {
        number: number
      },
      renderBehindTheNode: {
        boolean: bool
      },
      __type__: {
        object: object
      }
    },
    shadow: {
      enabled: {
        boolean: bool
      },
      color: {
        string: string
      },
      size: {
        number: number
      },
      x: {
        number: number
      },
      y: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    smooth: {
      enabled: {
        boolean: bool
      },
      type: {
        string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
      },
      roundness: {
        number: number
      },
      forceDirection: {
        string: ["horizontal", "vertical", "none"],
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    title: {
      string: string,
      undefined: "undefined"
    },
    width: {
      number: number
    },
    widthConstraint: {
      maximum: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool,
        number: number
      }
    },
    value: {
      number: number,
      undefined: "undefined"
    },
    __type__: {
      object: object
    }
  },
  groups: {
    useDefaultGroups: {
      boolean: bool
    },
    __any__: nodeOptions,
    __type__: {
      object: object
    }
  },
  interaction: {
    dragNodes: {
      boolean: bool
    },
    dragView: {
      boolean: bool
    },
    hideEdgesOnDrag: {
      boolean: bool
    },
    hideEdgesOnZoom: {
      boolean: bool
    },
    hideNodesOnDrag: {
      boolean: bool
    },
    hover: {
      boolean: bool
    },
    keyboard: {
      enabled: {
        boolean: bool
      },
      speed: {
        x: {
          number: number
        },
        y: {
          number: number
        },
        zoom: {
          number: number
        },
        __type__: {
          object: object
        }
      },
      bindToWindow: {
        boolean: bool
      },
      autoFocus: {
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    multiselect: {
      boolean: bool
    },
    navigationButtons: {
      boolean: bool
    },
    selectable: {
      boolean: bool
    },
    selectConnectedEdges: {
      boolean: bool
    },
    hoverConnectedEdges: {
      boolean: bool
    },
    tooltipDelay: {
      number: number
    },
    zoomView: {
      boolean: bool
    },
    zoomSpeed: {
      number: number
    },
    __type__: {
      object: object
    }
  },
  layout: {
    randomSeed: {
      undefined: "undefined",
      number: number,
      string: string
    },
    improvedLayout: {
      boolean: bool
    },
    clusterThreshold: {
      number: number
    },
    hierarchical: {
      enabled: {
        boolean: bool
      },
      levelSeparation: {
        number: number
      },
      nodeSpacing: {
        number: number
      },
      treeSpacing: {
        number: number
      },
      blockShifting: {
        boolean: bool
      },
      edgeMinimization: {
        boolean: bool
      },
      parentCentralization: {
        boolean: bool
      },
      direction: {
        string: ["UD", "DU", "LR", "RL"]
      },
      sortMethod: {
        string: ["hubsize", "directed"]
      },
      shakeTowards: {
        string: ["leaves", "roots"]
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    __type__: {
      object: object
    }
  },
  manipulation: {
    enabled: {
      boolean: bool
    },
    initiallyActive: {
      boolean: bool
    },
    addNode: {
      boolean: bool,
      function: "function"
    },
    addEdge: {
      boolean: bool,
      function: "function"
    },
    editNode: {
      function: "function"
    },
    editEdge: {
      editWithoutDrag: {
        function: "function"
      },
      __type__: {
        object: object,
        boolean: bool,
        function: "function"
      }
    },
    deleteNode: {
      boolean: bool,
      function: "function"
    },
    deleteEdge: {
      boolean: bool,
      function: "function"
    },
    controlNodeStyle: nodeOptions,
    __type__: {
      object: object,
      boolean: bool
    }
  },
  nodes: nodeOptions,
  physics: {
    enabled: {
      boolean: bool
    },
    barnesHut: {
      theta: {
        number: number
      },
      gravitationalConstant: {
        number: number
      },
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    forceAtlas2Based: {
      theta: {
        number: number
      },
      gravitationalConstant: {
        number: number
      },
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    repulsion: {
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      nodeDistance: {
        number: number
      },
      damping: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    hierarchicalRepulsion: {
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      nodeDistance: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    maxVelocity: {
      number: number
    },
    minVelocity: {
      number: number
    },
    solver: {
      string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
    },
    stabilization: {
      enabled: {
        boolean: bool
      },
      iterations: {
        number: number
      },
      updateInterval: {
        number: number
      },
      onlyDynamicEdges: {
        boolean: bool
      },
      fit: {
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    timestep: {
      number: number
    },
    adaptiveTimestep: {
      boolean: bool
    },
    wind: {
      x: {
        number: number
      },
      y: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  //globals :
  autoResize: {
    boolean: bool
  },
  clickToUse: {
    boolean: bool
  },
  locale: {
    string: string
  },
  locales: {
    __any__: {
      any: any
    },
    __type__: {
      object: object
    }
  },
  height: {
    string: string
  },
  width: {
    string: string
  },
  __type__: {
    object: object
  }
};
/* eslint-enable @typescript-eslint/naming-convention */

/**
 * This provides ranges, initial values, steps and dropdown menu choices for the
 * configuration.
 *
 * @remarks
 * Checkbox: `boolean`
 *   The value supllied will be used as the initial value.
 *
 * Text field: `string`
 *   The passed text will be used as the initial value. Any text will be
 *   accepted afterwards.
 *
 * Number range: `[number, number, number, number]`
 *   The meanings are `[initial value, min, max, step]`.
 *
 * Dropdown: `[Exclude<string, "color">, ...(string | number | boolean)[]]`
 *   Translations for people with poor understanding of TypeScript: the first
 *   value always has to be a string but never `"color"`, the rest can be any
 *   combination of strings, numbers and booleans.
 *
 * Color picker: `["color", string]`
 *   The first value says this will be a color picker not a dropdown menu. The
 *   next value is the initial color.
 */

var configureOptions = {
  nodes: {
    borderWidth: [1, 0, 10, 1],
    borderWidthSelected: [2, 0, 10, 1],
    color: {
      border: ["color", "#2B7CE9"],
      background: ["color", "#97C2FC"],
      highlight: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      },
      hover: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      }
    },
    opacity: [0, 0, 1, 0.1],
    fixed: {
      x: false,
      y: false
    },
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [0, 0, 50, 1],
      strokeColor: ["color", "#ffffff"]
    },
    //group: 'string',
    hidden: false,
    labelHighlightBold: true,
    //icon: {
    //  face: 'string',  //'FontAwesome',
    //  code: 'string',  //'\uf007',
    //  size: [50, 0, 200, 1],  //50,
    //  color: ['color','#2B7CE9']   //'#aa00ff'
    //},
    //image: 'string', // --> URL
    physics: true,
    scaling: {
      min: [10, 0, 200, 1],
      max: [30, 0, 200, 1],
      label: {
        enabled: false,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
    shapeProperties: {
      borderDashes: false,
      borderRadius: [6, 0, 20, 1],
      interpolation: true,
      useImageSize: false
    },
    size: [25, 0, 200, 1]
  },
  edges: {
    arrows: {
      to: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      middle: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      from: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      }
    },
    endPointOffset: {
      from: [0, -10, 10, 1],
      to: [0, -10, 10, 1]
    },
    arrowStrikethrough: true,
    color: {
      color: ["color", "#848484"],
      highlight: ["color", "#848484"],
      hover: ["color", "#848484"],
      inherit: ["from", "to", "both", true, false],
      opacity: [1, 0, 1, 0.05]
    },
    dashes: false,
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [2, 0, 50, 1],
      strokeColor: ["color", "#ffffff"],
      align: ["horizontal", "top", "middle", "bottom"]
    },
    hidden: false,
    hoverWidth: [1.5, 0, 5, 0.1],
    labelHighlightBold: true,
    physics: true,
    scaling: {
      min: [1, 0, 100, 1],
      max: [15, 0, 100, 1],
      label: {
        enabled: true,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    selectionWidth: [1.5, 0, 5, 0.1],
    selfReferenceSize: [20, 0, 200, 1],
    selfReference: {
      size: [20, 0, 200, 1],
      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],
      renderBehindTheNode: true
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    smooth: {
      enabled: true,
      type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
      forceDirection: ["horizontal", "vertical", "none"],
      roundness: [0.5, 0, 1, 0.05]
    },
    width: [1, 0, 30, 1]
  },
  layout: {
    //randomSeed: [0, 0, 500, 1],
    //improvedLayout: true,
    hierarchical: {
      enabled: false,
      levelSeparation: [150, 20, 500, 5],
      nodeSpacing: [100, 20, 500, 5],
      treeSpacing: [200, 20, 500, 5],
      blockShifting: true,
      edgeMinimization: true,
      parentCentralization: true,
      direction: ["UD", "DU", "LR", "RL"],
      sortMethod: ["hubsize", "directed"],
      shakeTowards: ["leaves", "roots"] // leaves, roots

    }
  },
  interaction: {
    dragNodes: true,
    dragView: true,
    hideEdgesOnDrag: false,
    hideEdgesOnZoom: false,
    hideNodesOnDrag: false,
    hover: false,
    keyboard: {
      enabled: false,
      speed: {
        x: [10, 0, 40, 1],
        y: [10, 0, 40, 1],
        zoom: [0.02, 0, 0.1, 0.005]
      },
      bindToWindow: true,
      autoFocus: true
    },
    multiselect: false,
    navigationButtons: false,
    selectable: true,
    selectConnectedEdges: true,
    hoverConnectedEdges: true,
    tooltipDelay: [300, 0, 1000, 25],
    zoomView: true,
    zoomSpeed: [1, 0.1, 2, 0.1]
  },
  manipulation: {
    enabled: false,
    initiallyActive: false
  },
  physics: {
    enabled: true,
    barnesHut: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-2000, -30000, 0, 50],
      centralGravity: [0.3, 0, 10, 0.05],
      springLength: [95, 0, 500, 5],
      springConstant: [0.04, 0, 1.2, 0.005],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    forceAtlas2Based: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-50, -500, 0, 1],
      centralGravity: [0.01, 0, 1, 0.005],
      springLength: [95, 0, 500, 5],
      springConstant: [0.08, 0, 1.2, 0.005],
      damping: [0.4, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    repulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [200, 0, 500, 5],
      springConstant: [0.05, 0, 1.2, 0.005],
      nodeDistance: [100, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01]
    },
    hierarchicalRepulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [100, 0, 500, 5],
      springConstant: [0.01, 0, 1.2, 0.005],
      nodeDistance: [120, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    maxVelocity: [50, 0, 150, 1],
    minVelocity: [0.1, 0.01, 0.5, 0.01],
    solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
    timestep: [0.5, 0.01, 1, 0.01],
    wind: {
      x: [0, -10, 10, 0.1],
      y: [0, -10, 10, 0.1]
    } //adaptiveTimestep: true

  }
};
var configuratorHideOption = function configuratorHideOption(parentPath, optionName, options) {
  var _context;

  if (includes(parentPath).call(parentPath, "physics") && includes(_context = configureOptions.physics.solver).call(_context, optionName) && options.physics.solver !== optionName && optionName !== "wind") {
    return true;
  }

  return false;
};

var options = /*#__PURE__*/Object.freeze({
	__proto__: null,
	configuratorHideOption: configuratorHideOption,
	allOptions: allOptions,
	configureOptions: configureOptions
});

/**
 *  The FloydâWarshall algorithm is an algorithm for finding shortest paths in
 *  a weighted graph with positive or negative edge weights (but with no negative
 *  cycles). - https://en.wikipedia.org/wiki/FloydâWarshall_algorithm
 */
var FloydWarshall = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function FloydWarshall() {
    _classCallCheck(this, FloydWarshall);
  }
  /**
   *
   * @param {object} body
   * @param {Array.<Node>} nodesArray
   * @param {Array.<Edge>} edgesArray
   * @returns {{}}
   */


  _createClass(FloydWarshall, [{
    key: "getDistances",
    value: function getDistances(body, nodesArray, edgesArray) {
      var D_matrix = {};
      var edges = body.edges; // prepare matrix with large numbers

      for (var i = 0; i < nodesArray.length; i++) {
        var node = nodesArray[i];
        var cell = {};
        D_matrix[node] = cell;

        for (var j = 0; j < nodesArray.length; j++) {
          cell[nodesArray[j]] = i == j ? 0 : 1e9;
        }
      } // put the weights for the edges in. This assumes unidirectionality.


      for (var _i = 0; _i < edgesArray.length; _i++) {
        var edge = edges[edgesArray[_i]]; // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix

        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
          D_matrix[edge.fromId][edge.toId] = 1;
          D_matrix[edge.toId][edge.fromId] = 1;
        }
      }

      var nodeCount = nodesArray.length; // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.

      for (var k = 0; k < nodeCount; k++) {
        var knode = nodesArray[k];
        var kcolm = D_matrix[knode];

        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
          var inode = nodesArray[_i2];
          var icolm = D_matrix[inode];

          for (var _j = _i2 + 1; _j < nodeCount; _j++) {
            var jnode = nodesArray[_j];
            var jcolm = D_matrix[jnode];
            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
            icolm[jnode] = val;
            jcolm[inode] = val;
          }
        }
      }

      return D_matrix;
    }
  }]);

  return FloydWarshall;
}();

/**
 * KamadaKawai positions the nodes initially based on
 *
 * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
 * -- Tomihisa KAMADA and Satoru KAWAI in 1989
 *
 * Possible optimizations in the distance calculation can be implemented.
 */

var KamadaKawai = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {number} edgeLength
   * @param {number} edgeStrength
   */
  function KamadaKawai(body, edgeLength, edgeStrength) {
    _classCallCheck(this, KamadaKawai);

    this.body = body;
    this.springLength = edgeLength;
    this.springConstant = edgeStrength;
    this.distanceSolver = new FloydWarshall();
  }
  /**
   * Not sure if needed but can be used to update the spring length and spring constant
   *
   * @param {object} options
   */


  _createClass(KamadaKawai, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        if (options.springLength) {
          this.springLength = options.springLength;
        }

        if (options.springConstant) {
          this.springConstant = options.springConstant;
        }
      }
    }
    /**
     * Position the system
     *
     * @param {Array.<Node>} nodesArray
     * @param {Array.<vis.Edge>} edgesArray
     * @param {boolean} [ignoreClusters=false]
     */

  }, {
    key: "solve",
    value: function solve(nodesArray, edgesArray) {
      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // get distance matrix
      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix
      // get the L Matrix

      this._createL_matrix(D_matrix); // get the K Matrix


      this._createK_matrix(D_matrix); // initial E Matrix


      this._createE_matrix(); // calculate positions


      var threshold = 0.01;
      var innerThreshold = 1;
      var iterations = 0;
      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
      var maxInnerIterations = 5;
      var maxEnergy = 1e9;
      var highE_nodeId = 0,
          dE_dx = 0,
          dE_dy = 0,
          delta_m = 0,
          subIterations = 0;

      while (maxEnergy > threshold && iterations < maxIterations) {
        iterations += 1;

        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);

        var _this$_getHighestEner2 = _slicedToArray(_this$_getHighestEner, 4);

        highE_nodeId = _this$_getHighestEner2[0];
        maxEnergy = _this$_getHighestEner2[1];
        dE_dx = _this$_getHighestEner2[2];
        dE_dy = _this$_getHighestEner2[3];
        delta_m = maxEnergy;
        subIterations = 0;

        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
          subIterations += 1;

          this._moveNode(highE_nodeId, dE_dx, dE_dy);

          var _this$_getEnergy = this._getEnergy(highE_nodeId);

          var _this$_getEnergy2 = _slicedToArray(_this$_getEnergy, 3);

          delta_m = _this$_getEnergy2[0];
          dE_dx = _this$_getEnergy2[1];
          dE_dy = _this$_getEnergy2[2];
        }
      }
    }
    /**
     * get the node with the highest energy
     *
     * @param {boolean} ignoreClusters
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getHighestEnergyNode",
    value: function _getHighestEnergyNode(ignoreClusters) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var maxEnergy = 0;
      var maxEnergyNodeId = nodesArray[0];
      var dE_dx_max = 0,
          dE_dy_max = 0;

      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
        var m = nodesArray[nodeIdx]; // by not evaluating nodes with predefined positions we should only move nodes that have no positions.

        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {
          var _this$_getEnergy3 = this._getEnergy(m),
              _this$_getEnergy4 = _slicedToArray(_this$_getEnergy3, 3),
              delta_m = _this$_getEnergy4[0],
              dE_dx = _this$_getEnergy4[1],
              dE_dy = _this$_getEnergy4[2];

          if (maxEnergy < delta_m) {
            maxEnergy = delta_m;
            maxEnergyNodeId = m;
            dE_dx_max = dE_dx;
            dE_dy_max = dE_dy;
          }
        }
      }

      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
    }
    /**
     * calculate the energy of a single node
     *
     * @param {Node.id} m
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getEnergy",
    value: function _getEnergy(m) {
      var _this$E_sums$m = _slicedToArray(this.E_sums[m], 2),
          dE_dx = _this$E_sums$m[0],
          dE_dy = _this$E_sums$m[1];

      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
      return [delta_m, dE_dx, dE_dy];
    }
    /**
     * move the node based on it's energy
     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
     *
     * @param {number} m
     * @param {number} dE_dx
     * @param {number} dE_dy
     * @private
     */

  }, {
    key: "_moveNode",
    value: function _moveNode(m, dE_dx, dE_dy) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var d2E_dx2 = 0;
      var d2E_dxdy = 0;
      var d2E_dy2 = 0;
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var km = this.K_matrix[m];
      var lm = this.L_matrix[m];

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];

        if (i !== m) {
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var kmat = km[i];
          var lmat = lm[i];
          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
        }
      } // make the variable names easier to make the solving of the linear system easier to read


      var A = d2E_dx2,
          B = d2E_dxdy,
          C = dE_dx,
          D = d2E_dy2,
          E = dE_dy; // solve the linear system for dx and dy

      var dy = (C / A + E / B) / (B / A - D / B);
      var dx = -(B * dy + C) / A; // move the node

      nodes[m].x += dx;
      nodes[m].y += dy; // Recalculate E_matrix (should be incremental)

      this._updateE_matrix(m);
    }
    /**
     * Create the L matrix: edge length times shortest path
     *
     * @param {object} D_matrix
     * @private
     */

  }, {
    key: "_createL_matrix",
    value: function _createL_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeLength = this.springLength;
      this.L_matrix = [];

      for (var i = 0; i < nodesArray.length; i++) {
        this.L_matrix[nodesArray[i]] = {};

        for (var j = 0; j < nodesArray.length; j++) {
          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
        }
      }
    }
    /**
     * Create the K matrix: spring constants times shortest path
     *
     * @param {object} D_matrix
     * @private
     */

  }, {
    key: "_createK_matrix",
    value: function _createK_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeStrength = this.springConstant;
      this.K_matrix = [];

      for (var i = 0; i < nodesArray.length; i++) {
        this.K_matrix[nodesArray[i]] = {};

        for (var j = 0; j < nodesArray.length; j++) {
          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
        }
      }
    }
    /**
     *  Create matrix with all energies between nodes
     *
     *  @private
     */

  }, {
    key: "_createE_matrix",
    value: function _createE_matrix() {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      this.E_matrix = {};
      this.E_sums = {};

      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
        this.E_matrix[nodesArray[mIdx]] = [];
      }

      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
        var m = nodesArray[_mIdx];
        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;

        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];

          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
            dE_dx += this.E_matrix[m][iIdx][0];
            dE_dy += this.E_matrix[m][iIdx][1];
          }
        } //Store sum


        this.E_sums[m] = [dE_dx, dE_dy];
      }
    }
    /**
     * Update method, just doing single column (rows are auto-updated) (update all sums)
     *
     * @param {number} m
     * @private
     */

  }, {
    key: "_updateE_matrix",
    value: function _updateE_matrix(m) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var colm = this.E_matrix[m];
      var kcolm = this.K_matrix[m];
      var lcolm = this.L_matrix[m];
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var dE_dx = 0;
      var dE_dy = 0;

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];

        if (i !== m) {
          //Keep old energy value for sum modification below
          var cell = colm[iIdx];
          var oldDx = cell[0];
          var oldDy = cell[1]; //Calc new energy:

          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
          colm[iIdx] = [dx, dy];
          dE_dx += dx;
          dE_dy += dy; //add new energy to sum of each column

          var sum = this.E_sums[i];
          sum[0] += dx - oldDx;
          sum[1] += dy - oldDy;
        }
      } //Store sum at -1 index


      this.E_sums[m] = [dE_dx, dE_dy];
    }
  }]);

  return KamadaKawai;
}();

/**
 * Create a network visualization, displaying nodes and edges.
 *
 * @param {Element} container   The DOM element in which the Network will
 *                                  be created. Normally a div element.
 * @param {object} data         An object containing parameters
 *                              {Array} nodes
 *                              {Array} edges
 * @param {object} options      Options
 * @class Network
 */

function Network(container, data, options) {
  var _context,
      _context2,
      _context3,
      _context4,
      _this = this;

  if (!(this instanceof Network)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  } // set constant values


  this.options = {};
  this.defaultOptions = {
    locale: "en",
    locales: locales,
    clickToUse: false
  };

  assign$2(this.options, this.defaultOptions);
  /**
   * Containers for nodes and edges.
   *
   * 'edges' and 'nodes' contain the full definitions of all the network elements.
   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.
   *
   * The distinction is important, because a defined node need not be active, i.e.
   * visible on the canvas. This happens in particular when clusters are defined, in
   * that case there will be nodes and edges not displayed.
   * The bottom line is that all code with actions related to visibility, *must* use
   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.
   */


  this.body = {
    container: container,
    // See comment above for following fields
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],
    emitter: {
      on: bind$6(_context = this.on).call(_context, this),
      off: bind$6(_context2 = this.off).call(_context2, this),
      emit: bind$6(_context3 = this.emit).call(_context3, this),
      once: bind$6(_context4 = this.once).call(_context4, this)
    },
    eventListeners: {
      onTap: function onTap() {},
      onTouch: function onTouch() {},
      onDoubleTap: function onDoubleTap() {},
      onHold: function onHold() {},
      onDragStart: function onDragStart() {},
      onDrag: function onDrag() {},
      onDragEnd: function onDragEnd() {},
      onMouseWheel: function onMouseWheel() {},
      onPinch: function onPinch() {},
      onMouseMove: function onMouseMove() {},
      onRelease: function onRelease() {},
      onContext: function onContext() {}
    },
    data: {
      nodes: null,
      // A DataSet or DataView
      edges: null // A DataSet or DataView

    },
    functions: {
      createNode: function createNode() {},
      createEdge: function createEdge() {},
      getPointer: function getPointer() {}
    },
    modules: {},
    view: {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      }
    },
    selectionBox: {
      show: false,
      position: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      }
    }
  }; // bind the event listeners

  this.bindEventListeners(); // setting up all modules

  this.images = new Images(function () {
    return _this.body.emitter.emit("_requestRedraw");
  }); // object with images

  this.groups = new Groups(); // object with groups

  this.canvas = new Canvas(this.body); // DOM handler

  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler

  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key

  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms

  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into

  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations

  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout

  this.clustering = new ClusterEngine(this.body); // clustering api

  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler); // data manipulation system

  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options

  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

  this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.

  this.body.modules["clustering"] = this.clustering; // create the DOM elements

  this.canvas._create(); // apply options


  this.setOptions(options); // load data (the disable start variable will be the same as the enabled clustering)

  this.setData(data);
} // Extend Network with an Emitter mixin

Emitter(Network.prototype);
/**
 * Set options
 *
 * @param {object} options
 */

Network.prototype.setOptions = function (options) {
  var _this2 = this;

  if (options === null) {
    options = undefined; // This ensures that options handling doesn't crash in the handling
  }

  if (options !== undefined) {
    var errorFound = Validator.validate(options, allOptions);

    if (errorFound === true) {
      console.error("%cErrors have been found in the supplied options object.", VALIDATOR_PRINT_STYLE);
    } // copy the global fields over


    var fields = ["locale", "locales", "clickToUse"];
    selectiveDeepExtend(fields, this.options, options); // normalize the locale or use English

    if (options.locale !== undefined) {
      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);
    } // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.


    options = this.layoutEngine.setOptions(options.layout, options);
    this.canvas.setOptions(options); // options for canvas are in globals
    // pass the options to the modules

    this.groups.setOptions(options.groups);
    this.nodesHandler.setOptions(options.nodes);
    this.edgesHandler.setOptions(options.edges);
    this.physics.setOptions(options.physics);
    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

    this.interactionHandler.setOptions(options.interaction);
    this.renderer.setOptions(options.interaction); // options for rendering are in interaction

    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction
    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.

    if (options.groups !== undefined) {
      this.body.emitter.emit("refreshNodes");
    } // these two do not have options at the moment, here for completeness
    //this.view.setOptions(options.view);
    //this.clustering.setOptions(options.clustering);


    if ("configure" in options) {
      if (!this.configurator) {
        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);
      }

      this.configurator.setOptions(options.configure);
    } // if the configuration system is enabled, copy all options and put them into the config system


    if (this.configurator && this.configurator.options.enabled === true) {
      var networkOptions = {
        nodes: {},
        edges: {},
        layout: {},
        interaction: {},
        manipulation: {},
        physics: {},
        global: {}
      };
      deepExtend(networkOptions.nodes, this.nodesHandler.options);
      deepExtend(networkOptions.edges, this.edgesHandler.options);
      deepExtend(networkOptions.layout, this.layoutEngine.options); // load the selectionHandler and render default options in to the interaction group

      deepExtend(networkOptions.interaction, this.selectionHandler.options);
      deepExtend(networkOptions.interaction, this.renderer.options);
      deepExtend(networkOptions.interaction, this.interactionHandler.options);
      deepExtend(networkOptions.manipulation, this.manipulation.options);
      deepExtend(networkOptions.physics, this.physics.options); // load globals into the global object

      deepExtend(networkOptions.global, this.canvas.options);
      deepExtend(networkOptions.global, this.options);
      this.configurator.setModuleOptions(networkOptions);
    } // handle network global options


    if (options.clickToUse !== undefined) {
      if (options.clickToUse === true) {
        if (this.activator === undefined) {
          this.activator = new Activator(this.canvas.frame);
          this.activator.on("change", function () {
            _this2.body.emitter.emit("activate");
          });
        }
      } else {
        if (this.activator !== undefined) {
          this.activator.destroy();
          delete this.activator;
        }

        this.body.emitter.emit("activate");
      }
    } else {
      this.body.emitter.emit("activate");
    }

    this.canvas.setSize(); // start the physics simulation. Can be safely called multiple times.

    this.body.emitter.emit("startSimulation");
  }
};
/**
 * Update the visible nodes and edges list with the most recent node state.
 *
 * Visible nodes are stored in this.body.nodeIndices.
 * Visible edges are stored in this.body.edgeIndices.
 * A node or edges is visible if it is not hidden or clustered.
 *
 * @private
 */


Network.prototype._updateVisibleIndices = function () {
  var nodes = this.body.nodes;
  var edges = this.body.edges;
  this.body.nodeIndices = [];
  this.body.edgeIndices = [];

  for (var nodeId in nodes) {
    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
        this.body.nodeIndices.push(nodes[nodeId].id);
      }
    }
  }

  for (var edgeId in edges) {
    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
      var edge = edges[edgeId]; // It can happen that this is executed *after* a node edge has been removed,
      // but *before* the edge itself has been removed. Taking this into account.

      var fromNode = nodes[edge.fromId];
      var toNode = nodes[edge.toId];
      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;
      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden
      toNode.options.hidden === false; // idem

      if (isVisible) {
        this.body.edgeIndices.push(edge.id);
      }
    }
  }
};
/**
 * Bind all events
 */


Network.prototype.bindEventListeners = function () {
  var _this3 = this;

  // This event will trigger a rebuilding of the cache everything.
  // Used when nodes or edges have been added or removed.
  this.body.emitter.on("_dataChanged", function () {
    _this3.edgesHandler._updateState();

    _this3.body.emitter.emit("_dataUpdated");
  }); // this is called when options of EXISTING nodes or edges have changed.

  this.body.emitter.on("_dataUpdated", function () {
    // Order important in following block
    _this3.clustering._updateState();

    _this3._updateVisibleIndices();

    _this3._updateValueRange(_this3.body.nodes);

    _this3._updateValueRange(_this3.body.edges); // start simulation (can be called safely, even if already running)


    _this3.body.emitter.emit("startSimulation");

    _this3.body.emitter.emit("_requestRedraw");
  });
};
/**
 * Set nodes and edges, and optionally options as well.
 *
 * @param {object} data              Object containing parameters:
 *                                   {Array | DataSet | DataView} [nodes] Array with nodes
 *                                   {Array | DataSet | DataView} [edges] Array with edges
 *                                   {String} [dot] String containing data in DOT format
 *                                   {String} [gephi] String containing data in gephi JSON format
 *                                   {Options} [options] Object with options
 */


Network.prototype.setData = function (data) {
  // reset the physics engine.
  this.body.emitter.emit("resetPhysics");
  this.body.emitter.emit("_resetData"); // unselect all to ensure no selections from old data are carried over.

  this.selectionHandler.unselectAll();

  if (data && data.dot && (data.nodes || data.edges)) {
    throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
  } // set options


  this.setOptions(data && data.options); // set all data

  if (data && data.dot) {
    console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);"); // parse DOT file

    var dotData = DOTToGraph(data.dot);
    this.setData(dotData);
    return;
  } else if (data && data.gephi) {
    // parse DOT file
    console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
    var gephiData = parseGephi(data.gephi);
    this.setData(gephiData);
    return;
  } else {
    this.nodesHandler.setData(data && data.nodes, true);
    this.edgesHandler.setData(data && data.edges, true);
  } // emit change in data


  this.body.emitter.emit("_dataChanged"); // emit data loaded

  this.body.emitter.emit("_dataLoaded"); // find a stable position or start animating to a stable position

  this.body.emitter.emit("initPhysics");
};
/**
 * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
 * var network = new vis.Network(..);
 * network.destroy();
 * network = null;
 */


Network.prototype.destroy = function () {
  this.body.emitter.emit("destroy"); // clear events

  this.body.emitter.off();
  this.off(); // delete modules

  delete this.groups;
  delete this.canvas;
  delete this.selectionHandler;
  delete this.interactionHandler;
  delete this.view;
  delete this.renderer;
  delete this.physics;
  delete this.layoutEngine;
  delete this.clustering;
  delete this.manipulation;
  delete this.nodesHandler;
  delete this.edgesHandler;
  delete this.configurator;
  delete this.images;

  for (var nodeId in this.body.nodes) {
    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;
    delete this.body.nodes[nodeId];
  }

  for (var edgeId in this.body.edges) {
    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;
    delete this.body.edges[edgeId];
  } // remove the container and everything inside it recursively


  recursiveDOMDelete(this.body.container);
};
/**
 * Update the values of all object in the given array according to the current
 * value range of the objects in the array.
 *
 * @param {object} obj    An object containing a set of Edges or Nodes
 *                        The objects must have a method getValue() and
 *                        setValueRange(min, max).
 * @private
 */


Network.prototype._updateValueRange = function (obj) {
  var id; // determine the range of the objects

  var valueMin = undefined;
  var valueMax = undefined;
  var valueTotal = 0;

  for (id in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, id)) {
      var value = obj[id].getValue();

      if (value !== undefined) {
        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
        valueTotal += value;
      }
    }
  } // adjust the range of all objects


  if (valueMin !== undefined && valueMax !== undefined) {
    for (id in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, id)) {
        obj[id].setValueRange(valueMin, valueMax, valueTotal);
      }
    }
  }
};
/**
 * Returns true when the Network is active.
 *
 * @returns {boolean}
 */


Network.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

Network.prototype.setSize = function () {
  return this.canvas.setSize.apply(this.canvas, arguments);
};

Network.prototype.canvasToDOM = function () {
  return this.canvas.canvasToDOM.apply(this.canvas, arguments);
};

Network.prototype.DOMtoCanvas = function () {
  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
};
/**
 * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of
 * nodeIds showing where the node is.
 *
 * If any nodeId in the chain, especially the first passed in as a parameter, is not present in
 * the current nodes list, an empty array is returned.
 *
 * Example:
 * cluster 'A' contains cluster 'B',
 * cluster 'B' contains cluster 'C',
 * cluster 'C' contains node 'fred'.
 * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.
 *
 * @param {string|number} nodeId
 * @returns {Array}
 */


Network.prototype.findNode = function () {
  return this.clustering.findNode.apply(this.clustering, arguments);
};

Network.prototype.isCluster = function () {
  return this.clustering.isCluster.apply(this.clustering, arguments);
};

Network.prototype.openCluster = function () {
  return this.clustering.openCluster.apply(this.clustering, arguments);
};

Network.prototype.cluster = function () {
  return this.clustering.cluster.apply(this.clustering, arguments);
};

Network.prototype.getNodesInCluster = function () {
  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
};

Network.prototype.clusterByConnection = function () {
  return this.clustering.clusterByConnection.apply(this.clustering, arguments);
};

Network.prototype.clusterByHubsize = function () {
  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
};

Network.prototype.updateClusteredNode = function () {
  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);
};

Network.prototype.getClusteredEdges = function () {
  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);
};

Network.prototype.getBaseEdge = function () {
  return this.clustering.getBaseEdge.apply(this.clustering, arguments);
};

Network.prototype.getBaseEdges = function () {
  return this.clustering.getBaseEdges.apply(this.clustering, arguments);
};

Network.prototype.updateEdge = function () {
  return this.clustering.updateEdge.apply(this.clustering, arguments);
};
/**
 * This method will cluster all nodes with 1 edge with their respective connected node.
 * The options object is explained in full <a data-scroll="" data-options="{ &quot;easing&quot;: &quot;easeInCubic&quot; }" href="#optionsObject">below</a>.
 *
 * @param {object} [options]
 * @returns {undefined}
 */


Network.prototype.clusterOutliers = function () {
  return this.clustering.clusterOutliers.apply(this.clustering, arguments);
};

Network.prototype.getSeed = function () {
  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
};

Network.prototype.enableEditMode = function () {
  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
};

Network.prototype.disableEditMode = function () {
  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
};

Network.prototype.addNodeMode = function () {
  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
};

Network.prototype.editNode = function () {
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};

Network.prototype.editNodeMode = function () {
  console.warn("Deprecated: Please use editNode instead of editNodeMode.");
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};

Network.prototype.addEdgeMode = function () {
  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
};

Network.prototype.editEdgeMode = function () {
  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
};

Network.prototype.deleteSelected = function () {
  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
};

Network.prototype.getPositions = function () {
  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
};

Network.prototype.getPosition = function () {
  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);
};

Network.prototype.storePositions = function () {
  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
};

Network.prototype.moveNode = function () {
  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
};

Network.prototype.getBoundingBox = function () {
  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
};

Network.prototype.getConnectedNodes = function (objectId) {
  if (this.body.nodes[objectId] !== undefined) {
    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
  } else {
    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
  }
};

Network.prototype.getConnectedEdges = function () {
  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
};

Network.prototype.startSimulation = function () {
  return this.physics.startSimulation.apply(this.physics, arguments);
};

Network.prototype.stopSimulation = function () {
  return this.physics.stopSimulation.apply(this.physics, arguments);
};

Network.prototype.stabilize = function () {
  return this.physics.stabilize.apply(this.physics, arguments);
};

Network.prototype.getSelection = function () {
  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
};

Network.prototype.setSelection = function () {
  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
};

Network.prototype.getSelectedNodes = function () {
  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);
};

Network.prototype.getSelectedEdges = function () {
  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);
};

Network.prototype.getNodeAt = function () {
  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);

  if (node !== undefined && node.id !== undefined) {
    return node.id;
  }

  return node;
};

Network.prototype.getEdgeAt = function () {
  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);

  if (edge !== undefined && edge.id !== undefined) {
    return edge.id;
  }

  return edge;
};

Network.prototype.selectNodes = function () {
  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
};

Network.prototype.selectEdges = function () {
  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
};

Network.prototype.unselectAll = function () {
  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);
  this.redraw();
};

Network.prototype.redraw = function () {
  return this.renderer.redraw.apply(this.renderer, arguments);
};

Network.prototype.getScale = function () {
  return this.view.getScale.apply(this.view, arguments);
};

Network.prototype.getViewPosition = function () {
  return this.view.getViewPosition.apply(this.view, arguments);
};

Network.prototype.fit = function () {
  return this.view.fit.apply(this.view, arguments);
};

Network.prototype.moveTo = function () {
  return this.view.moveTo.apply(this.view, arguments);
};

Network.prototype.focus = function () {
  return this.view.focus.apply(this.view, arguments);
};

Network.prototype.releaseNode = function () {
  return this.view.releaseNode.apply(this.view, arguments);
};

Network.prototype.getOptionsFromConfigurator = function () {
  var options = {};

  if (this.configurator) {
    options = this.configurator.getOptions.apply(this.configurator);
  }

  return options;
};

var parseDOTNetwork = DOTToGraph;
// overflow in UMD builds. They all export vis namespace therefore reexporting
// leads to loading vis to load vis to load visâ¦


//# sourceMappingURL=vis-network.js.map


/***/ }),

/***/ "./node_modules/vis-network/standalone/index.js":
/*!******************************************************!*\
  !*** ./node_modules/vis-network/standalone/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.DataSet),
/* harmony export */   "DataView": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.DataView),
/* harmony export */   "Network": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.Network),
/* harmony export */   "NetworkImages": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.NetworkImages),
/* harmony export */   "Queue": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.Queue),
/* harmony export */   "data": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.data),
/* harmony export */   "networkDOTParser": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkDOTParser),
/* harmony export */   "networkGephiParser": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkGephiParser),
/* harmony export */   "networkOptions": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkOptions),
/* harmony export */   "parseDOTNetwork": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.parseGephiNetwork)
/* harmony export */ });
/* harmony import */ var _esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esm */ "./node_modules/vis-network/standalone/esm/index.js");



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/vis_suffix_tree.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFD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bkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRyxHQUFHO0FBQ047QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhO0FBQ2Q7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtB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QUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RixFQUFFOztBQUVGO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUEsb0JBQW9CLDJDQUEyQztBQUMvRCxNQUFNO0FBQ04sd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWEsaUJBQWlCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUIsK0NBQStDOztBQUUxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtB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STtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFELFVBQVU7QUFDVixxREFBcUQ7QUFDckQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDBCQUEwQixFQUFFLGVBQWUsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBLHlDQUF5Qzs7O0FBR3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6Qjs7QUFFQSxHQUFHO0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBaUU7OztBQUdqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ1gsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxX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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVB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QUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDUjtBQUNBLFFBQVE7OztBQUdSLG1DQUFtQywyQkFBMkI7OztBQUc5RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7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QTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4RUFBOEUsY0FBYztBQUM1RjtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztB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Q0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELDZDQUE2QywyQkFBMkIsNkJBQTZCLDZDQUE2Qyw0RUFBNEUsNERBQTRELHNDQUFzQzs7QUFFaFUsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTywwQkFBMEIsdURBQXVELDhGQUE4Riw0Q0FBNEMsZ0xBQWdMLHlFQUF5RSxLQUFLO0FBQ3ppQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUiwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7OztBQUc3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELDJD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELG1DQUFtQywrREFBK0QseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELG1EQUFtRCxPQUFPLHlDQUF5Qzs7QUFFaFgseUNBQXlDLGdFQUFnRSxrQ0FBa0MsOENBQThDLE1BQU0sb0VBQW9FLElBQUksZUFBZSxZQUFZO0FBQ2xTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsbUNBQW1DLCtEQUErRCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsbURBQW1ELE9BQU8seUNBQXlDOztBQUVoWCx5Q0FBeUMsZ0VBQWdFLGtDQUFrQyw4Q0FBOEMsTUFBTSxvRUFBb0UsSUFBSSxlQUFlLFlBQVk7QUFDbFM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsbUNBQW1DLCtEQUErRCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsbURBQW1ELE9BQU8seUNBQXlDOztBQUVoWCx5Q0FBeUMsZ0VBQWdFLGtDQUFrQyw4Q0FBOEMsTUFBTSxvRUFBb0UsSUFBSSxlQUFlLFlBQVk7QUFDbFM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGdCQUFnQjtBQUM3QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0IseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG1CQUFtQjtBQUNsQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qzs7QUFFN0MsdUNBQXVDOztBQUV2Qyw4REFBOEQ7O0FBRTlELG9DQUFvQzs7O0FBR3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVEsaUJBQWlCO0FBQ3hDLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Ysd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdB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QUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0VBQWdFOztBQUVuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxXQUFXO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsV0FBVyxhQUFhO0FBQy9DO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0NBQWdDLHNCQUFzQjtBQUM3RTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0Usd0RBQXdELHdDQUF3QztBQUNoRzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0NBQWdDLHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RTs7QUFFdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsdUZBQXVGOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOzs7QUFHckIsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FB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TztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsY0FBYztBQUMzQixhQUFhLGNBQWM7QUFDM0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLFFBQVE7OztBQUdSLHVCQUF1Qix3QkFBd0I7QUFDL0MsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekMsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTs7QUFFQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7O0FBRUEsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGOztBQUVBLHNDQUFzQzs7O0FBR3RDLHNDQUFzQzs7O0FBR3RDLDhCQUE4Qjs7O0FBRzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDZCQUE2QjtBQUN6RCxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3Qzs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3Qzs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTs7QUFFQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDBCQUEwQjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsMEJBQTBCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGlDQUFpQyxPQUFPO0FBQ3hDLGlDQUFpQyxPQUFPO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQyw0Q0FBNEM7QUFDNUMsa0NBQWtDO0FBQ2xDLDRDQUE0QztBQUM1QyxrQ0FBa0M7QUFDbEMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QyxvQ0FBb0M7QUFDcEMsNENBQTRDO0FBQzVDLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0EsS0FBSztBQUNMLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOLDhCQUE4Qjs7QUFFOUIsdUNBQXVDOztBQUV2Qyx3RUFBd0U7O0FBRXhFLG1HQUFtRzs7QUFFbkcsZ0RBQWdEOztBQUVoRCw4REFBOEQ7O0FBRTlELCtDQUErQzs7QUFFL0MsbURBQW1EOztBQUVuRCxrREFBa0Q7O0FBRWxELHNIQUFzSDs7QUFFdEgsZ0dBQWdHOztBQUVoRyw2RUFBNkU7O0FBRTdFLDRFQUE0RTs7QUFFNUUscURBQXFEOztBQUVyRCx5QkFBeUI7OztBQUd6Qiw0QkFBNEI7O0FBRTVCO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0EsbURBQW1EOztBQUVuRCwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQ7OztBQUdqRDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixzQ0FBc0MsNEJBQTRCO0FBQ2xFLHNDQUFzQyw0QkFBNEI7QUFDbEUsc0NBQXNDLFFBQVE7QUFDOUMsc0NBQXNDLFFBQVE7QUFDOUMsc0NBQXNDLFNBQVM7QUFDL0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKLHlDQUF5Qzs7QUFFekM7QUFDQSwyUUFBMlEsSUFBSTs7QUFFL1E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbVJBQW1SO0FBQ25SO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osMENBQTBDOztBQUUxQyx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU0sWUFBWSxRQUFRLG1CQUFtQjtBQUMxSDtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvTztBQUNwTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxcTNDc0I7Ozs7Ozs7VUNBdEI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOztVQUVBO1VBQ0E7Ozs7O1dDNUJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1VFSkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNkcy8uL3NyYy9zdHJsaWIudHMiLCJ3ZWJwYWNrOi8vdmlzZHMvLi9zcmMvc3VmZml4X3RyZWUudHMiLCJ3ZWJwYWNrOi8vdmlzZHMvLi9zcmMvdmlzX3N1ZmZpeF90cmVlLnRzIiwid2VicGFjazovL3Zpc2RzLy4vc3JjL3Zpc2pzX2RlZmF1bHRfb3B0aW9ucy50cyIsIndlYnBhY2s6Ly92aXNkcy8uL25vZGVfbW9kdWxlcy92aXMtbmV0d29yay9zdGFuZGFsb25lL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly92aXNkcy8uL25vZGVfbW9kdWxlcy92aXMtbmV0d29yay9zdGFuZGFsb25lL2VzbS92aXMtbmV0d29yay5qcyIsIndlYnBhY2s6Ly92aXNkcy8uL25vZGVfbW9kdWxlcy92aXMtbmV0d29yay9zdGFuZGFsb25lL2luZGV4LmpzIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly92aXNkcy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly92aXNkcy93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbGNwID0gKHg6IHN0cmluZywgeTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgY29uc3QgbiA9IE1hdGgubWluKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoeFtpXSAhPT0geVtpXSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuIiwiaW1wb3J0IHsgbGNwIH0gZnJvbSBcIi4vc3RybGliXCI7XG5jbGFzcyBOb2RlIHtcbiAgdG9fZWRnZV9sYWJlbDogc3RyaW5nO1xuICBjaGlsZHJlbjogTWFwPHN0cmluZywgTm9kZT47XG4gIGJpcnRoX3RpbWU6IG51bWJlcjtcbiAgdmFsdWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihiaXJ0aF90aW1lOiBudW1iZXIsIHRvX2VkZ2VfbGFiZWw6IHN0cmluZywgdmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudG9fZWRnZV9sYWJlbCA9IHRvX2VkZ2VfbGFiZWw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJpcnRoX3RpbWUgPSBiaXJ0aF90aW1lO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgaXNfbGVhZigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jaGlsZHJlbikubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZ2V0IGRlcHRoKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4uc2l6ZSA9PT0gMCkgcmV0dXJuIDA7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAuLi5BcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4udmFsdWVzKCkpLm1hcCgoY2hpbGQpID0+IGNoaWxkLmRlcHRoKVxuICAgICAgKTtcbiAgfVxufVxuXG5jbGFzcyBTdHJUcmVlIHtcbiAgbm9kZXM6IEFycmF5PE5vZGU+O1xuICByb290OiBOb2RlO1xuICBzbGlua3M6IE1hcDxOb2RlLCBOb2RlPjtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuY3JlYXRlX25vZGUoXCJyb290XCIpO1xuICAgIHRoaXMuc2xpbmtzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgY3JlYXRlX25vZGUodG9fZWRnZV9sYWJlbDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyID0gLTEpOiBOb2RlIHtcbiAgICBjb25zdCBub2RlID0gbmV3IE5vZGUodGhpcy5ub2Rlcy5sZW5ndGgsIHRvX2VkZ2VfbGFiZWwsIHZhbHVlKTtcbiAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogc3BsaXQgdGhlIGVkZ2UgYXQgbWF0Y2hfbGVuLCBhbmQgcmV0dXJuIHRoZSBicmFuY2ggbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudCAtIHBhcmVudCBub2RlIG9mIHRoZSBlZGdlIGJlaW5nIHNwbGl0dGVkLlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkIC0gY2hpbGQgbm9kZSBvZiB0aGUgZWRnZSBiZWluZyBzcGxpdHRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hdGNoX2xlbiAtIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWRnZSBiZWluZyBzcGxpdHRlZCBmcm9tIHBhcmVudC5cbiAgICovXG4gIHNwbGl0KHBhcmVudDogTm9kZSwgY2hpbGQ6IE5vZGUsIG1hdGNoX2xlbjogbnVtYmVyKTogTm9kZSB7XG4gICAgaWYgKG1hdGNoX2xlbiA9PT0gMCkgcmV0dXJuIGNoaWxkO1xuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgbWF0Y2hfbGVuIDwgY2hpbGQudG9fZWRnZV9sYWJlbC5sZW5ndGgsXG4gICAgICBtYXRjaF9sZW4udG9TdHJpbmcoKSxcbiAgICAgIGNoaWxkLnRvX2VkZ2VfbGFiZWwubGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCBicmFuY2hfbm9kZSA9IHRoaXMuY3JlYXRlX25vZGUoXG4gICAgICBjaGlsZC50b19lZGdlX2xhYmVsLnN1YnN0cigwLCBtYXRjaF9sZW4pXG4gICAgKTtcbiAgICBwYXJlbnQuY2hpbGRyZW4uc2V0KGJyYW5jaF9ub2RlLnRvX2VkZ2VfbGFiZWxbMF0sIGJyYW5jaF9ub2RlKTtcbiAgICBjaGlsZC50b19lZGdlX2xhYmVsID0gY2hpbGQudG9fZWRnZV9sYWJlbC5zdWJzdHIobWF0Y2hfbGVuKTtcbiAgICBicmFuY2hfbm9kZS5jaGlsZHJlbi5zZXQoY2hpbGQudG9fZWRnZV9sYWJlbFswXSwgY2hpbGQpO1xuICAgIHJldHVybiBicmFuY2hfbm9kZTtcbiAgfVxuXG4gIGZpbmRfYnJhbmNoKFxuICAgIHBhcmVudDogTm9kZSxcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgbWF0Y2hfbGVuX2FsbDogbnVtYmVyID0gMFxuICApOiBbTm9kZSwgTm9kZSB8IG51bGwsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwIHx8IHBhcmVudC5jaGlsZHJlbi5nZXQodGV4dFswXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFtwYXJlbnQsIG51bGwsIDAsIG1hdGNoX2xlbl9hbGxdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbi5nZXQodGV4dFswXSkgYXMgTm9kZTtcbiAgICBjb25zdCBtYXRjaF9sZW4gPSBsY3AoY2hpbGQudG9fZWRnZV9sYWJlbCwgdGV4dCk7XG4gICAgaWYgKG1hdGNoX2xlbiA8IGNoaWxkLnRvX2VkZ2VfbGFiZWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW3BhcmVudCwgY2hpbGQsIG1hdGNoX2xlbiwgbWF0Y2hfbGVuX2FsbCArIG1hdGNoX2xlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRfYnJhbmNoKFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgdGV4dC5zdWJzdHIobWF0Y2hfbGVuKSxcbiAgICAgICAgbWF0Y2hfbGVuX2FsbCArIG1hdGNoX2xlblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpbnNlcnQodGV4dDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgW3BhcmVudCwgY2hpbGQsIG1hdGNoX2xlbiwgbWF0Y2hfbGVuX2FsbF0gPSB0aGlzLmZpbmRfYnJhbmNoKFxuICAgICAgdGhpcy5yb290LFxuICAgICAgdGV4dFxuICAgICk7XG4gICAgLy8gY29uc29sZS5sb2coJ2luc2VydCcsIHRleHQsIHBhcmVudCwgY2hpbGQsIG1hdGNoX2xlbiwgbWF0Y2hfbGVuX2FsbClcbiAgICBpZiAobWF0Y2hfbGVuX2FsbCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBicmFuY2hfbm9kZSA9XG4gICAgICAgIGNoaWxkID09PSBudWxsID8gcGFyZW50IDogdGhpcy5zcGxpdChwYXJlbnQsIGNoaWxkLCBtYXRjaF9sZW4pO1xuICAgICAgY29uc3QgbGVhZiA9IHRoaXMuY3JlYXRlX25vZGUodGV4dC5zdWJzdHIobWF0Y2hfbGVuX2FsbCksIHZhbHVlKTtcbiAgICAgIGJyYW5jaF9ub2RlLmNoaWxkcmVuLnNldChsZWFmLnRvX2VkZ2VfbGFiZWxbMF0sIGxlYWYpO1xuICAgIH1cbiAgfVxuXG4gIHByaW50X3RyZWUobm9kZTogTm9kZSA9IHRoaXMucm9vdCwgcHJlOiBzdHJpbmcgPSBcIlwiKSB7XG4gICAgY29uc29sZS5sb2cocHJlICsgXCIgXCIgKyBub2RlLnRvX2VkZ2VfbGFiZWwgKyBcIjogXCIgKyBub2RlLmJpcnRoX3RpbWUpO1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMucHJpbnRfdHJlZShjaGlsZCwgcHJlICsgXCItLVwiKSk7XG4gIH1cblxuICBidWlsZF9zdWZmaXhfbGlua3MoXG4gICAgbm9kZT86IE5vZGUsXG4gICAgbm9kZV9sYWJlbD86IHN0cmluZyxcbiAgICByZXZlcnNlOiBib29sZWFuID0gZmFsc2VcbiAgKSB7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCB8fCBub2RlX2xhYmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUgPSB0aGlzLnJvb3Q7XG4gICAgICBub2RlX2xhYmVsID0gXCJcIjtcbiAgICAgIHRoaXMuc2xpbmtzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290KSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBjaGlsZF0gPSB0aGlzLmZpbmRfYnJhbmNoKHRoaXMucm9vdCwgbm9kZV9sYWJlbC5zdWJzdHIoMSkpO1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXZlcnNlKSB0aGlzLnNsaW5rcy5zZXQocGFyZW50LCBub2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLnNsaW5rcy5zZXQobm9kZSwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PlxuICAgICAgdGhpcy5idWlsZF9zdWZmaXhfbGlua3MoY2hpbGQsIG5vZGVfbGFiZWwgKyBjaGlsZC50b19lZGdlX2xhYmVsLCByZXZlcnNlKVxuICAgICk7XG4gIH1cblxuICBqc29uKCkge1xuICAgIGNvbnN0IG5vZGVzOiBhbnkgPSBbXTtcbiAgICBpbnRlcmZhY2UgRWRnZVQge1xuICAgICAgZnJvbTogbnVtYmVyO1xuICAgICAgdG86IG51bWJlcjtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgZm9udDogYW55O1xuICAgIH1cbiAgICBsZXQgZWRnZXM6IGFueSA9IFtdO1xuICAgIGNvbnN0IG5pZCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjcmVhdGVfanNvbl9ub2RlID0gKG5vZGU6IE5vZGUsIGxldmVsOiBudW1iZXIpID0+IHtcbiAgICAgIGlmICghbmlkLmhhcyhub2RlKSkge1xuICAgICAgICBuaWQuc2V0KG5vZGUsIG5vZGUuYmlydGhfdGltZSk7XG4gICAgICAgIGNvbnN0IG5kaWMgPSB7XG4gICAgICAgICAgbGFiZWw6IG5vZGUudmFsdWUgPT09IC0xID8gXCJcIiA6IFwiXCIgKyBub2RlLnZhbHVlLFxuICAgICAgICAgIGlkOiBuaWQuZ2V0KG5vZGUpLFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIHNoYXBlOiBub2RlLmlzX2xlYWYgPyBcImJveFwiIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBub2Rlcy5wdXNoKG5kaWMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVjID0gKHBhcmVudDogTm9kZSwgbGV2ZWw6IG51bWJlcikgPT4ge1xuICAgICAgY3JlYXRlX2pzb25fbm9kZShwYXJlbnQsIGxldmVsKTtcbiAgICAgIHBhcmVudC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBjcmVhdGVfanNvbl9ub2RlKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAgIGZyb206IG5pZC5nZXQocGFyZW50KSxcbiAgICAgICAgICB0bzogbmlkLmdldChjaGlsZCksXG4gICAgICAgICAgaWQ6IG5pZC5nZXQocGFyZW50KSArIFwiLVwiICsgbmlkLmdldChjaGlsZCksXG4gICAgICAgICAgbGFiZWw6IGNoaWxkLnRvX2VkZ2VfbGFiZWwsXG4gICAgICAgICAgZm9udDogeyBhbGlnbjogXCJ0b3BcIiB9LFxuICAgICAgICB9O1xuICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICByZWMoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJlYyh0aGlzLnJvb3QsIDApO1xuXG4gICAgLy8gY29tcHV0ZSBzdWZmaXggbGlua3NcbiAgICBjb25zdCBzbGlua3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtmcm9tX25vZGUsIHRvX25vZGVdIG9mIHRoaXMuc2xpbmtzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgc2xpbmsgPSB7XG4gICAgICAgIGZyb206IG5pZC5nZXQoZnJvbV9ub2RlKSxcbiAgICAgICAgdG86IG5pZC5nZXQodG9fbm9kZSksXG4gICAgICAgIGlkOiBcInNcIiArIG5pZC5nZXQoZnJvbV9ub2RlKSArIFwiLVwiICsgbmlkLmdldCh0b19ub2RlKSxcbiAgICAgICAgZGFzaGVzOiB0cnVlLFxuICAgICAgICBjb2xvcjogeyBjb2xvcjogXCIjZmYwMDAwXCIgfSxcbiAgICAgICAgc21vb3RoOiB7IHR5cGU6IFwiY3VydmVkQ1dcIiwgcm91bmRuZXNzOiAwLjQgfSxcbiAgICAgIH07XG4gICAgICBzbGlua3MucHVzaChzbGluayk7XG4gICAgfVxuICAgIGVkZ2VzID0gZWRnZXMuY29uY2F0KHNsaW5rcyk7XG4gICAgcmV0dXJuIHsgcm9vdDogbmlkLmdldCh0aGlzLnJvb3QpLCBub2RlcywgZWRnZXMgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VmZml4X3RyZWUodGV4dDogc3RyaW5nLCBidWlsZF9zdWZmaXhfbGlua3M6IGJvb2xlYW4pIHtcbiAgY29uc3Qgc3QgPSBuZXcgU3RyVHJlZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICBzdC5pbnNlcnQodGV4dC5zdWJzdHIoaSksIGkpO1xuICB9XG4gIGlmIChidWlsZF9zdWZmaXhfbGlua3MpIHN0LmJ1aWxkX3N1ZmZpeF9saW5rcygpO1xuICByZXR1cm4gc3Q7XG59XG5cbmNvbnN0IG1haW4gPSAodGV4dDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0ID0gbmV3IFN0clRyZWUoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3QuaW5zZXJ0KHRleHQuc3Vic3RyKGkpLCBpKTtcbiAgICBzdC5wcmludF90cmVlKCk7XG4gIH1cbiAgY29uc29sZS5sb2coc3QuanNvbigpKTtcbn07XG5cbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBpZiAocHJvY2Vzcy5hcmd2Lmxlbmd0aCA9PT0gMykge1xuICAgIG1haW4ocHJvY2Vzcy5hcmd2WzJdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB1c2FnZSA9XG4gICAgICBwcm9jZXNzLmFyZ3ZbMV0gK1xuICAgICAgXCIgaW5wdXRfc3RyXFxuXCIgK1xuICAgICAgXCJcXHRidWlsZCBzdWZmaXggdHJlZSBvZiBpbnB1dF9zdHIgYW5kIHNob3cgdGhlIHN0cnVjdHVyZSBpbiBqc29uIGZvcm1hdC5cIjtcbiAgICBjb25zb2xlLmxvZyh1c2FnZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFTZXQsIE5ldHdvcmsgfSBmcm9tIFwidmlzLW5ldHdvcmsvc3RhbmRhbG9uZVwiO1xuaW1wb3J0IHsgc3VmZml4X3RyZWUgfSBmcm9tIFwiLi9zdWZmaXhfdHJlZVwiO1xuaW1wb3J0ICogYXMgdmlzanNfZGVmYXVsdF9vcHRpb25zIGZyb20gXCIuL3Zpc2pzX2RlZmF1bHRfb3B0aW9uc1wiO1xuXG5jb25zdCBvcHRpb25zID0gdmlzanNfZGVmYXVsdF9vcHRpb25zLm9wdGlvbnM7XG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5ldHdvcmtcIikgYXMgSFRNTEVsZW1lbnQ7XG5jb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsoY29udGFpbmVyLCB7fSwgb3B0aW9ucyk7XG5sZXQgbmV0d29ya0RhdGEgPSB7XG4gIG5vZGVzOiBuZXcgRGF0YVNldChbXSksXG4gIGVkZ2VzOiBuZXcgRGF0YVNldChbXSksXG59O1xuXG5sZXQgc3RyZWUgPSBzdWZmaXhfdHJlZShcIlwiLCBmYWxzZSk7XG5cbmludGVyZmFjZSBQYXJhbXMge1xuICBpbnB1dF90ZXh0OiBzdHJpbmc7XG4gIHNob3dfc3VmZml4X2xpbmtzOiBib29sZWFuO1xufVxuXG5jb25zdCBsb2FkX3BhcmFtc19mcm9tX3VybCA9ICgpID0+IHtcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0ge1xuICAgIGlucHV0X3RleHQ6IFwiY29jb2FcIixcbiAgICBzaG93X3N1ZmZpeF9saW5rczogdHJ1ZSxcbiAgfTtcblxuICBjb25zdCB1cmxrZXkgPSB1cmxQYXJhbXMuZ2V0KFwiaW5wdXRfdGV4dFwiKTtcbiAgaWYgKHVybGtleSAhPT0gbnVsbCkgcGFyYW1zLmlucHV0X3RleHQgPSB1cmxrZXk7XG4gIHBhcmFtcy5zaG93X3N1ZmZpeF9saW5rcyA9IHVybFBhcmFtcy5nZXQoXCJzaG93X3N1ZmZpeF9saW5rc1wiKSA9PT0gXCJ0cnVlXCI7XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG5jb25zdCBsb2FkX3BhcmFtc19mcm9tX2h0bWwgPSAoKSA9PiB7XG4gIGNvbnN0IGlucHV0X3RleHQgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dF90ZXh0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQpXG4gICAgLnZhbHVlO1xuICBjb25zdCBzaG93X3N1ZmZpeF9saW5rcyA9IChcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dfc3VmZml4X2xpbmtzXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgKS5jaGVja2VkO1xuICBjb25zdCBwYXJhbXM6IFBhcmFtcyA9IHtcbiAgICBpbnB1dF90ZXh0OiBpbnB1dF90ZXh0LFxuICAgIHNob3dfc3VmZml4X2xpbmtzOiBzaG93X3N1ZmZpeF9saW5rcyxcbiAgfTtcbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbmNvbnN0IHNldF9wYXJhbXNfdG9fdXJsID0gKHBhcmFtczogUGFyYW1zKSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1zKSkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1zW2tleSBhcyBrZXlvZiBQYXJhbXNdLnRvU3RyaW5nKCkpO1xuICB9XG4gIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBcIlwiLCB1cmwudG9TdHJpbmcoKSk7XG59O1xuXG5jb25zdCBzZXRfcGFyYW1zX3RvX2h0bWwgPSAocGFyYW1zOiBQYXJhbXMpID0+IHtcbiAgY29uc3QgaW5wdXRfdGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRfdGV4dFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBzaG93X3N1ZmZpeF9saW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgIFwic2hvd19zdWZmaXhfbGlua3NcIlxuICApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIGNvbnN0IGltcGxpY2l0X2NkYXdnID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgXCJpbXBsaWNpdF9jZGF3Z1wiXG4gICkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgaW5wdXRfdGV4dC52YWx1ZSA9IHBhcmFtcy5pbnB1dF90ZXh0O1xuICBzaG93X3N1ZmZpeF9saW5rcy5jaGVja2VkID0gcGFyYW1zLnNob3dfc3VmZml4X2xpbmtzO1xufTtcblxuY29uc3QgcmVkcmF3ID0gKCkgPT4ge1xuICAvLyBzZXQgcGFyYW1zIHRvIHVybFxuICBjb25zdCBwYXJhbXMgPSBsb2FkX3BhcmFtc19mcm9tX2h0bWwoKTtcbiAgc2V0X3BhcmFtc190b191cmwocGFyYW1zKTtcblxuICBjb25zb2xlLmxvZyhcImlucHV0X3RleHRcIiwgcGFyYW1zLmlucHV0X3RleHQpO1xuICBjb25zb2xlLmxvZyhcInNob3dfc3VmZml4X2xpbmtzXCIsIHBhcmFtcy5zaG93X3N1ZmZpeF9saW5rcyk7XG4gIHN0cmVlID0gc3VmZml4X3RyZWUocGFyYW1zLmlucHV0X3RleHQsIHBhcmFtcy5zaG93X3N1ZmZpeF9saW5rcyk7XG4gIGNvbnNvbGUubG9nKFwic3RcIiwgc3RyZWUpO1xuICBjb25zdCBqc29uID0gc3RyZWUuanNvbigpO1xuICBjb25zb2xlLmxvZyhcImpzb25cIiwganNvbik7XG4gIG5ldHdvcmtEYXRhID0ge1xuICAgIG5vZGVzOiBuZXcgRGF0YVNldChqc29uLm5vZGVzKSxcbiAgICBlZGdlczogbmV3IERhdGFTZXQoanNvbi5lZGdlcyksXG4gIH07XG4gIG5ldHdvcmsuc2V0RGF0YShuZXR3b3JrRGF0YSk7XG59O1xuXG5jb25zdCBzaG93X25vZGVfc3RyID0gKG5pZDogbnVtYmVyIHwgbnVsbCkgPT4ge1xuICBjb25zdCBlbG0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vZGVfc3RyXCIpIGFzIEhUTUxFbGVtZW50O1xuICBjb25zdCBuc3RyID0gbmlkID8gbm9kZV9zdHIobmlkKSA6IFwiXCI7XG4gIGVsbS5pbm5lclRleHQgPSBuc3RyO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgbWFwIGZyb20gbm9kZSBpZCB0byB0aGUgc3RyaW5nIGZyb20gcm9vdCB0byB0aGUgbm9kZS5cbiAqL1xuY29uc3QgbWFrZV9uc3RyID0gKCk6IE1hcDxudW1iZXIsIHN0cmluZz4gPT4ge1xuICBjb25zdCBqc29uID0gc3RyZWUuanNvbigpO1xuICBjb25zdCBtYXAgPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPigpO1xuICBjb25zdCByZWMgPSAobmlkOiBudW1iZXIsIHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgbWFwLnNldChuaWQsIHByZWZpeCk7XG4gICAgZm9yIChsZXQgZWRnZSBvZiBqc29uLmVkZ2VzKSB7XG4gICAgICBpZiAoZWRnZS5mcm9tICE9PSBuaWQpIGNvbnRpbnVlO1xuICAgICAgcmVjKGVkZ2UudG8sIHByZWZpeCArIGVkZ2UubGFiZWwpO1xuICAgIH1cbiAgfTtcbiAgcmVjKGpzb24ucm9vdCwgXCJcIik7XG4gIHJldHVybiBtYXA7XG59O1xuXG5jb25zdCBub2RlX3N0ciA9IChuaWQ6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IG5zdHIgPSBtYWtlX25zdHIoKTtcbiAgcmV0dXJuIG5zdHIuZ2V0KG5pZCkgYXMgc3RyaW5nO1xufTtcblxuY29uc3QgbWFpbiA9ICgpID0+IHtcbiAgLy8gc2V0IGV2ZW50IGxpc3RlbmVyXG4gIGNvbnN0IGlucHV0X3RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0X3RleHRcIikgYXMgSFRNTEVsZW1lbnQ7XG4gIGlucHV0X3RleHQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlZHJhdyk7XG4gIGlucHV0X3RleHQuYWRkRXZlbnRMaXN0ZW5lcihcInByb3BlcnR5Y2hhbmdlXCIsIHJlZHJhdyk7XG4gIGNvbnN0IHNob3dfc2xfYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgXCJzaG93X3N1ZmZpeF9saW5rc1wiXG4gICkgYXMgSFRNTEVsZW1lbnQ7XG4gIHNob3dfc2xfYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcmVkcmF3KTtcbiAgbmV0d29yay5vbihcImhvdmVyRWRnZVwiLCAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiaG92ZXJFZGdlXCIsIGUpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBuZXR3b3JrRGF0YS5lZGdlcy51cGRhdGUoeyBpZDogZS5lZGdlLCBmb250OiB7IHNpemU6IDM0IH0gfSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG5pZCA9IG5ldHdvcmtEYXRhLmVkZ2VzLmdldChlLmVkZ2UpLnRvO1xuICAgIHNob3dfbm9kZV9zdHIobmlkKTtcbiAgfSk7XG4gIG5ldHdvcmsub24oXCJibHVyRWRnZVwiLCAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiYmx1ckVkZ2VcIik7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5ldHdvcmtEYXRhLmVkZ2VzLnVwZGF0ZSh7IGlkOiBlLmVkZ2UsIGZvbnQ6IHsgc2l6ZTogMTQgfSB9KTtcbiAgICBzaG93X25vZGVfc3RyKG51bGwpO1xuICB9KTtcbiAgbmV0d29yay5vbihcImhvdmVyTm9kZVwiLCAobikgPT4ge1xuICAgIHNob3dfbm9kZV9zdHIobi5ub2RlKTtcbiAgfSk7XG4gIG5ldHdvcmsub24oXCJibHVyTm9kZVwiLCAobikgPT4ge1xuICAgIHNob3dfbm9kZV9zdHIobnVsbCk7XG4gIH0pO1xuXG4gIC8vIGxvYWQgYW5kIHNldCBwYXJhbWV0ZXJzXG4gIGNvbnN0IHBhcmFtcyA9IGxvYWRfcGFyYW1zX2Zyb21fdXJsKCk7XG4gIHNldF9wYXJhbXNfdG9faHRtbChwYXJhbXMpO1xuXG4gIHJlZHJhdygpO1xufTtcblxubWFpbigpO1xuIiwiZXhwb3J0IGNvbnN0IG9wdGlvbnMgPSB7XG4gIGhlaWdodDogXCIxMDAlXCIsXG4gIGxheW91dDoge1xuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgLy8gZW5hYmxlZDogdHJ1ZVxuICAgICAgLy8gZGlyZWN0aW9uOiAnVUQnLFxuICAgICAgZGlyZWN0aW9uOiBcIkxSXCIsXG4gICAgICAvLyBzb3J0TWV0aG9kOiAnZGlyZWN0ZWQnLFxuICAgICAgdHJlZVNwYWNpbmc6IDE4NSxcbiAgICAgIGxldmVsU2VwYXJhdGlvbjogOTUsXG4gICAgICBub2RlU3BhY2luZzogNDAsXG4gICAgfSxcbiAgfSxcbiAgbm9kZXM6IHtcbiAgICBzaXplOiAxMCxcbiAgfSxcbiAgZWRnZXM6IHtcbiAgICBhcnJvd3M6IHtcbiAgICAgIHRvOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNjYWxlRmFjdG9yOiAwLjUsXG4gICAgICB9LFxuICAgIH0sXG4gICAgLy8gZWRnZSBsYWJlbCBpcyBub3QgZGlzcGxheWVkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGVkZ2VcbiAgICAvLyBpZiBgc21vb3RoYCBpcyBzcGVjaWZpZWRcbiAgICBzbW9vdGg6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAvLyB0eXBlOiAnZHluYW1pYycsXG4gICAgICB0eXBlOiBcInZlcnRpY2FsXCIsIC8vIFRoaXMgaXMgYmV0dGVyIGZvciBMUlxuICAgICAgLy8gdHlwZTogJ2hvcml6b250YWwnLCAvLyBUaGlzIGlzIGJldHRlciBmb3IgVURcbiAgICAgIC8vIHR5cGU6ICdjb250aW51b3VzJyxcbiAgICAgIC8vIHR5cGU6ICdjdXJ2ZWRDQ1cnLFxuICAgICAgLy8gdHlwZTogJ3N0cmFpZ2h0Q3Jvc3MnLFxuICAgICAgcm91bmRuZXNzOiAxLjAsXG4gICAgfSxcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBob3ZlcjogdHJ1ZSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczogdHJ1ZSxcbiAgfSxcbiAgcGh5c2ljczogZmFsc2UsXG59O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vdmlzLW5ldHdvcmtcIjtcbiIsIi8qKlxuICogdmlzLW5ldHdvcmtcbiAqIGh0dHBzOi8vdmlzanMuZ2l0aHViLmlvL3Zpcy1uZXR3b3JrL1xuICpcbiAqIEEgZHluYW1pYywgYnJvd3Nlci1iYXNlZCB2aXN1YWxpemF0aW9uIGxpYnJhcnkuXG4gKlxuICogQHZlcnNpb24gOS4xLjJcbiAqIEBkYXRlICAgIDIwMjItMDMtMjhUMjA6MTM6NTEuMDQ2WlxuICpcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTEtMjAxNyBBbG1lbmRlIEIuViwgaHR0cDovL2FsbWVuZGUuY29tXG4gKiBAY29weXJpZ2h0IChjKSAyMDE3LTIwMTkgdmlzanMgY29udHJpYnV0b3JzLCBodHRwczovL2dpdGh1Yi5jb20vdmlzanNcbiAqXG4gKiBAbGljZW5zZVxuICogdmlzLmpzIGlzIGR1YWwgbGljZW5zZWQgdW5kZXIgYm90aFxuICpcbiAqICAgMS4gVGhlIEFwYWNoZSAyLjAgTGljZW5zZVxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgIGFuZFxuICpcbiAqICAgMi4gVGhlIE1JVCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiB2aXMuanMgbWF5IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGVpdGhlciBsaWNlbnNlLlxuICovXG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5cblxudmFyIGdsb2JhbCRQID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbmNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8IGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbmNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8IGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG5mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBmYWlscyR0ID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyRzID0gZmFpbHMkdDtcbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkcyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0uYmluZCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcblxuXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQ0ID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDMgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkkNiA9IEZ1bmN0aW9uUHJvdG90eXBlJDMuYXBwbHk7XG52YXIgY2FsbCRkID0gRnVuY3Rpb25Qcm90b3R5cGUkMy5jYWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tcmVmbGVjdCAtLSBzYWZlXG5cbnZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQkNCA/IGNhbGwkZC5iaW5kKGFwcGx5JDYpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRkLmFwcGx5KGFwcGx5JDYsIGFyZ3VtZW50cyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kJGQgPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG52YXIgY2FsbCRjID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzJHcgPSBOQVRJVkVfQklORCQzICYmIGJpbmQkZC5iaW5kKGNhbGwkYywgY2FsbCRjKTtcbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMyA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkdyhmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkYy5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxuXG52YXIgaXNDYWxsYWJsZSRoID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIGZhaWxzJHIgPSBmYWlscyR0OyAvLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxuXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkcihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIGNhbGwkYiA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDIgPyBjYWxsJGIuYmluZChjYWxsJGIpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRiLmFwcGx5KGNhbGwkYiwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlJDIgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDggPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyAvLyBOYXNob3JuIH4gSkRLOCBidWdcblxudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDggJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZSQyLmNhbGwoe1xuICAxOiAyXG59LCAxKTsgLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5cbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkOCh0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlJDI7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNSA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkdiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9TdHJpbmckYSA9IHVuY3VycnlUaGlzJHYoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDEgPSB1bmN1cnJ5VGhpcyR2KCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkMSh0b1N0cmluZyRhKGl0KSwgOCwgLTEpO1xufTtcblxudmFyIGdsb2JhbCRPID0gZ2xvYmFsJFA7XG52YXIgdW5jdXJyeVRoaXMkdSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkcSA9IGZhaWxzJHQ7XG52YXIgY2xhc3NvZiRmID0gY2xhc3NvZlJhdyQxO1xudmFyIE9iamVjdCRhID0gZ2xvYmFsJE8uT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMkdSgnJy5zcGxpdCk7IC8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5cbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkcShmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhT2JqZWN0JGEoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJGYoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6IE9iamVjdCRhKGl0KTtcbn0gOiBPYmplY3QkYTtcblxudmFyIGdsb2JhbCROID0gZ2xvYmFsJFA7XG52YXIgVHlwZUVycm9yJGogPSBnbG9iYWwkTi5UeXBlRXJyb3I7IC8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvciRqKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBJbmRleGVkT2JqZWN0JDMgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNCA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCRiID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0JDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0KGl0KSk7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRoO1xuXG52YXIgaXNPYmplY3QkaiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGcoaXQpO1xufTtcblxudmFyIHBhdGgkeSA9IHt9O1xuXG52YXIgcGF0aCR4ID0gcGF0aCR5O1xudmFyIGdsb2JhbCRNID0gZ2xvYmFsJFA7XG52YXIgaXNDYWxsYWJsZSRmID0gaXNDYWxsYWJsZSRoO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGYodmFyaWFibGUpID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ5ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoJHhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbCRNW25hbWVzcGFjZV0pIDogcGF0aCR4W25hbWVzcGFjZV0gJiYgcGF0aCR4W25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWwkTVtuYW1lc3BhY2VdICYmIGdsb2JhbCRNW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyR0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkdCh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kOCA9IGdldEJ1aWx0SW4kOTtcbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDgoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxudmFyIGdsb2JhbCRMID0gZ2xvYmFsJFA7XG52YXIgdXNlckFnZW50JDMgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCRMLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbCRMLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTsgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59IC8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5cblxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQzKSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcblxuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQkMy5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OJDIgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkcCA9IGZhaWxzJHQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJHAoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7IC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcblxuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8IC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OJDIgJiYgVjhfVkVSU0lPTiQyIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCQyID0gbmF0aXZlU3ltYm9sO1xudmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQyICYmICFTeW1ib2wuc2hhbSAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG52YXIgZ2xvYmFsJEsgPSBnbG9iYWwkUDtcbnZhciBnZXRCdWlsdEluJDcgPSBnZXRCdWlsdEluJDk7XG52YXIgaXNDYWxsYWJsZSRlID0gaXNDYWxsYWJsZSRoO1xudmFyIGlzUHJvdG90eXBlT2YkbSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xudmFyIE9iamVjdCQ5ID0gZ2xvYmFsJEsuT2JqZWN0O1xudmFyIGlzU3ltYm9sJDMgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ3KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkZSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJG0oJFN5bWJvbC5wcm90b3R5cGUsIE9iamVjdCQ5KGl0KSk7XG59O1xuXG52YXIgZ2xvYmFsJEogPSBnbG9iYWwkUDtcbnZhciBTdHJpbmckNCA9IGdsb2JhbCRKLlN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gU3RyaW5nJDQoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGdsb2JhbCRJID0gZ2xvYmFsJFA7XG52YXIgaXNDYWxsYWJsZSRkID0gaXNDYWxsYWJsZSRoO1xudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ0O1xudmFyIFR5cGVFcnJvciRpID0gZ2xvYmFsJEkuVHlwZUVycm9yOyAvLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxuXG52YXIgYUNhbGxhYmxlJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkZChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yJGkodHJ5VG9TdHJpbmckMyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkNzsgLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxuXG52YXIgZ2V0TWV0aG9kJDMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUkNihmdW5jKTtcbn07XG5cbnZhciBnbG9iYWwkSCA9IGdsb2JhbCRQO1xudmFyIGNhbGwkYSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGMgPSBpc0NhbGxhYmxlJGg7XG52YXIgaXNPYmplY3QkaSA9IGlzT2JqZWN0JGo7XG52YXIgVHlwZUVycm9yJGggPSBnbG9iYWwkSC5UeXBlRXJyb3I7IC8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxuXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRjKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRpKHZhbCA9IGNhbGwkYShmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkYyhmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRpKHZhbCA9IGNhbGwkYShmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkYyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkaSh2YWwgPSBjYWxsJGEoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvciRoKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIHNoYXJlZCQ0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGdsb2JhbCRHID0gZ2xvYmFsJFA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXG52YXIgZGVmaW5lUHJvcGVydHkkZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIHNldEdsb2JhbCQxID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSRlKGdsb2JhbCRHLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJEdba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdsb2JhbCRGID0gZ2xvYmFsJFA7XG52YXIgc2V0R2xvYmFsID0gc2V0R2xvYmFsJDE7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUkMyA9IGdsb2JhbCRGW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xudmFyIHNoYXJlZFN0b3JlID0gc3RvcmUkMztcblxudmFyIHN0b3JlJDIgPSBzaGFyZWRTdG9yZTtcbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMS4xJyxcbiAgbW9kZTogJ3B1cmUnICxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjEuMS9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcblxudmFyIGdsb2JhbCRFID0gZ2xvYmFsJFA7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xudmFyIE9iamVjdCQ4ID0gZ2xvYmFsJEUuT2JqZWN0OyAvLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxuXG52YXIgdG9PYmplY3QkZSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0JDgocmVxdWlyZU9iamVjdENvZXJjaWJsZSQzKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkZCA9IHRvT2JqZWN0JGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRzKHt9Lmhhc093blByb3BlcnR5KTsgLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcblxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCRkKGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpZCQyID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQ5ID0gdW5jdXJyeVRoaXMkcigxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckOSgrK2lkJDIgKyBwb3N0Zml4LCAzNik7XG59O1xuXG52YXIgZ2xvYmFsJEQgPSBnbG9iYWwkUDtcbnZhciBzaGFyZWQkMyA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgaGFzT3duJGggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQzID0gdWlkJDQ7XG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlJDEgPSBzaGFyZWQkMygnd2tzJyk7XG52YXIgU3ltYm9sJDMgPSBnbG9iYWwkRC5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDMgJiYgU3ltYm9sJDNbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDMgOiBTeW1ib2wkMyAmJiBTeW1ib2wkMy53aXRob3V0U2V0dGVyIHx8IHVpZCQzO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGogPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRoKFdlbGxLbm93blN5bWJvbHNTdG9yZSQxLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wkMSB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gJ1N5bWJvbC4nICsgbmFtZTtcblxuICAgIGlmIChOQVRJVkVfU1lNQk9MJDEgJiYgaGFzT3duJGgoU3ltYm9sJDMsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXSA9IFN5bWJvbCQzW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV07XG59O1xuXG52YXIgZ2xvYmFsJEMgPSBnbG9iYWwkUDtcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkaCA9IGlzT2JqZWN0JGo7XG52YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sJDM7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkMztcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRpID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVHlwZUVycm9yJGcgPSBnbG9iYWwkQy5UeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFJDEgPSB3ZWxsS25vd25TeW1ib2wkaSgndG9QcmltaXRpdmUnKTsgLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcblxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCRoKGlucHV0KSB8fCBpc1N5bWJvbCQyKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDIoaW5wdXQsIFRPX1BSSU1JVElWRSQxKTtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJDkoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCRoKHJlc3VsdCkgfHwgaXNTeW1ib2wkMihyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IFR5cGVFcnJvciRnKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG5cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQxO1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQzOyAvLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcblxudmFyIHRvUHJvcGVydHlLZXkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sJDEoa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIGdsb2JhbCRCID0gZ2xvYmFsJFA7XG52YXIgaXNPYmplY3QkZyA9IGlzT2JqZWN0JGo7XG52YXIgZG9jdW1lbnQkMSA9IGdsb2JhbCRCLmRvY3VtZW50OyAvLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcblxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkZyhkb2N1bWVudCQxKSAmJiBpc09iamVjdCRnKGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkaCA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJG8gPSBmYWlscyR0O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTsgLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5cbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkaCAmJiAhZmFpbHMkbyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkZyA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkOCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQyID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciB0b0luZGV4ZWRPYmplY3QkYSA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIHRvUHJvcGVydHlLZXkkMyA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBoYXNPd24kZyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5cbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkZyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkYShPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMyhQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FJDEpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG4gIGlmIChoYXNPd24kZyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0KCFjYWxsJDgocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMi5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgZmFpbHMkbiA9IGZhaWxzJHQ7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRoO1xudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDEgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZSA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlIDogaXNDYWxsYWJsZSRiKGRldGVjdGlvbikgPyBmYWlscyRuKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQxLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMS5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMS5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQxLlBPTFlGSUxMID0gJ1AnO1xudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQxO1xuXG52YXIgdW5jdXJyeVRoaXMkcSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDUgPSBhQ2FsbGFibGUkNztcbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIGJpbmQkYyA9IHVuY3VycnlUaGlzJHEodW5jdXJyeVRoaXMkcS5iaW5kKTsgLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQkMSA/IGJpbmQkYyhmbiwgdGhhdCkgOiBmdW5jdGlvblxuICAgIC8qIC4uLmFyZ3MgKi9cbiAgKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbnZhciBERVNDUklQVE9SUyRmID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkbSA9IGZhaWxzJHQ7IC8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxuXG52YXIgdjhQcm90b3R5cGVEZWZpbmVCdWcgPSBERVNDUklQVE9SUyRmICYmIGZhaWxzJG0oZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcblxudmFyIGdsb2JhbCRBID0gZ2xvYmFsJFA7XG52YXIgaXNPYmplY3QkZiA9IGlzT2JqZWN0JGo7XG52YXIgU3RyaW5nJDMgPSBnbG9iYWwkQS5TdHJpbmc7XG52YXIgVHlwZUVycm9yJGYgPSBnbG9iYWwkQS5UeXBlRXJyb3I7IC8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcblxudmFyIGFuT2JqZWN0JGQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JGYoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IFR5cGVFcnJvciRmKFN0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIGdsb2JhbCR6ID0gZ2xvYmFsJFA7XG52YXIgREVTQ1JJUFRPUlMkZSA9IGRlc2NyaXB0b3JzO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRjID0gYW5PYmplY3QkZDtcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgVHlwZUVycm9yJGUgPSBnbG9iYWwkei5UeXBlRXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXG52YXIgJGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJzsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuXG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkZSA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGMoQXR0cmlidXRlcyk7XG5cbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJGRlZmluZVByb3BlcnR5JDEoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5JDEgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGMoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5JDEoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IkZSgnQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIERFU0NSSVBUT1JTJGQgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNiA9IERFU0NSSVBUT1JTJGQgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0LmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIGdsb2JhbCR5ID0gZ2xvYmFsJFA7XG52YXIgYXBwbHkkNSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgdW5jdXJyeVRoaXMkcCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRoO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ3ID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xudmFyIHBhdGgkdyA9IHBhdGgkeTtcbnZhciBiaW5kJGIgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgaGFzT3duJGYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgd3JhcENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKE5hdGl2ZUNvbnN0cnVjdG9yKSB7XG4gIHZhciBXcmFwcGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyYXBwZXIpIHtcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIsIGMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcHBseSQ1KE5hdGl2ZUNvbnN0cnVjdG9yLCB0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICByZXR1cm4gV3JhcHBlcjtcbn07XG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xuXG5cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIFBST1RPID0gb3B0aW9ucy5wcm90bztcbiAgdmFyIG5hdGl2ZVNvdXJjZSA9IEdMT0JBTCA/IGdsb2JhbCR5IDogU1RBVElDID8gZ2xvYmFsJHlbVEFSR0VUXSA6IChnbG9iYWwkeVtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIHZhciB0YXJnZXQgPSBHTE9CQUwgPyBwYXRoJHcgOiBwYXRoJHdbVEFSR0VUXSB8fCBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJHcsIFRBUkdFVCwge30pW1RBUkdFVF07XG4gIHZhciB0YXJnZXRQcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICB2YXIgRk9SQ0VELCBVU0VfTkFUSVZFLCBWSVJUVUFMX1BST1RPVFlQRTtcbiAgdmFyIGtleSwgc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5LCBuYXRpdmVQcm9wZXJ0eSwgcmVzdWx0UHJvcGVydHksIGRlc2NyaXB0b3I7XG5cbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTsgLy8gY29udGFpbnMgaW4gbmF0aXZlXG5cbiAgICBVU0VfTkFUSVZFID0gIUZPUkNFRCAmJiBuYXRpdmVTb3VyY2UgJiYgaGFzT3duJGYobmF0aXZlU291cmNlLCBrZXkpO1xuICAgIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKFVTRV9OQVRJVkUpIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDcobmF0aXZlU291cmNlLCBrZXkpO1xuICAgICAgbmF0aXZlUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIG5hdGl2ZVByb3BlcnR5ID0gbmF0aXZlU291cmNlW2tleV07IC8vIGV4cG9ydCBuYXRpdmUgb3IgaW1wbGVtZW50YXRpb25cblxuICAgIHNvdXJjZVByb3BlcnR5ID0gVVNFX05BVElWRSAmJiBuYXRpdmVQcm9wZXJ0eSA/IG5hdGl2ZVByb3BlcnR5IDogc291cmNlW2tleV07XG4gICAgaWYgKFVTRV9OQVRJVkUgJiYgdHlwZW9mIHRhcmdldFByb3BlcnR5ID09IHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSkgY29udGludWU7IC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG5cbiAgICBpZiAob3B0aW9ucy5iaW5kICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gYmluZCRiKHNvdXJjZVByb3BlcnR5LCBnbG9iYWwkeSk7IC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ3MgaW4gdGhpcyB2ZXJzaW9uXG4gICAgZWxzZSBpZiAob3B0aW9ucy53cmFwICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gd3JhcENvbnN0cnVjdG9yKHNvdXJjZVByb3BlcnR5KTsgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgZWxzZSBpZiAoUFJPVE8gJiYgaXNDYWxsYWJsZSRhKHNvdXJjZVByb3BlcnR5KSkgcmVzdWx0UHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRwKHNvdXJjZVByb3BlcnR5KTsgLy8gZGVmYXVsdCBjYXNlXG4gICAgZWxzZSByZXN1bHRQcm9wZXJ0eSA9IHNvdXJjZVByb3BlcnR5OyAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG5cbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8IHNvdXJjZVByb3BlcnR5ICYmIHNvdXJjZVByb3BlcnR5LnNoYW0gfHwgdGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocmVzdWx0UHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUodGFyZ2V0LCBrZXksIHJlc3VsdFByb3BlcnR5KTtcblxuICAgIGlmIChQUk9UTykge1xuICAgICAgVklSVFVBTF9QUk9UT1RZUEUgPSBUQVJHRVQgKyAnUHJvdG90eXBlJztcblxuICAgICAgaWYgKCFoYXNPd24kZihwYXRoJHcsIFZJUlRVQUxfUFJPVE9UWVBFKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJHcsIFZJUlRVQUxfUFJPVE9UWVBFLCB7fSk7XG4gICAgICB9IC8vIGV4cG9ydCB2aXJ0dWFsIHByb3RvdHlwZSBtZXRob2RzXG5cblxuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocGF0aCR3W1ZJUlRVQUxfUFJPVE9UWVBFXSwga2V5LCBzb3VyY2VQcm9wZXJ0eSk7IC8vIGV4cG9ydCByZWFsIHByb3RvdHlwZSBtZXRob2RzXG5cbiAgICAgIGlmIChvcHRpb25zLnJlYWwgJiYgdGFyZ2V0UHJvdG90eXBlICYmICF0YXJnZXRQcm90b3R5cGVba2V5XSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSh0YXJnZXRQcm90b3R5cGUsIGtleSwgc291cmNlUHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7IC8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gc2FmZVxuXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogKG51bWJlciA+IDAgPyBmbG9vciQxIDogY2VpbCkobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG52YXIgbWF4JDMgPSBNYXRoLm1heDtcbnZhciBtaW4kMiA9IE1hdGgubWluOyAvLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG5cbnZhciB0b0Fic29sdXRlSW5kZXgkNSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQzKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDMoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciBtaW4kMSA9IE1hdGgubWluOyAvLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxuXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQxOyAvLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxuXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ5ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDQgPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSRjID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDsgLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxudmFyIGNyZWF0ZU1ldGhvZCQ1ID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ5KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkYyhPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkNChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlOyAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcblxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG5cbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7IC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfVxuICAgIHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJbmNsdWRlcyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QkNSh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QkNShmYWxzZSlcbn07XG5cbnZhciBoaWRkZW5LZXlzJDYgPSB7fTtcblxudmFyIHVuY3VycnlUaGlzJG8gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhhc093biRlID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB0b0luZGV4ZWRPYmplY3QkOCA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIGluZGV4T2YkNCA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDUgPSBoaWRkZW5LZXlzJDY7XG52YXIgcHVzaCQ1ID0gdW5jdXJyeVRoaXMkbyhbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDgob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gTykgIWhhc093biRlKGhpZGRlbktleXMkNSwga2V5KSAmJiBoYXNPd24kZShPLCBrZXkpICYmIHB1c2gkNShyZXN1bHQsIGtleSk7IC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcblxuXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duJGUoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZiQ0KHJlc3VsdCwga2V5KSB8fCBwdXNoJDUocmVzdWx0LCBrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBlbnVtQnVnS2V5cyQzID0gWydjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzOyAvLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcblxudmFyIG9iamVjdEtleXMkNCA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgZW51bUJ1Z0tleXMkMik7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIERFU0NSSVBUT1JTJGMgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyRuID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkbCA9IGZhaWxzJHQ7XG52YXIgb2JqZWN0S2V5cyQzID0gb2JqZWN0S2V5cyQ0O1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciB0b09iamVjdCRjID0gdG9PYmplY3QkZTtcbnZhciBJbmRleGVkT2JqZWN0JDIgPSBpbmRleGVkT2JqZWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG5cbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG52YXIgZGVmaW5lUHJvcGVydHkkZCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjb25jYXQkNiA9IHVuY3VycnlUaGlzJG4oW10uY29uY2F0KTsgLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG5cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyRsKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTJGMgJiYgJGFzc2lnbih7XG4gICAgYjogMVxuICB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JGQoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSRkKHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHtcbiAgICBiOiAyXG4gIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTsgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5cbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN5bWJvbCAtLSBzYWZlXG5cbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7XG4gICAgQltjaHJdID0gY2hyO1xuICB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzJDMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QkYyh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQyLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZjtcblxuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QkMihhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0JDYob2JqZWN0S2V5cyQzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyQzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJGMgfHwgY2FsbCQ3KHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkSiA9IF9leHBvcnQ7XG52YXIgYXNzaWduJDUgPSBvYmplY3RBc3NpZ247IC8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuJCRKKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24kNVxufSwge1xuICBhc3NpZ246IGFzc2lnbiQ1XG59KTtcblxudmFyIHBhdGgkdiA9IHBhdGgkeTtcbnZhciBhc3NpZ24kNCA9IHBhdGgkdi5PYmplY3QuYXNzaWduO1xuXG52YXIgcGFyZW50JDFhID0gYXNzaWduJDQ7XG52YXIgYXNzaWduJDMgPSBwYXJlbnQkMWE7XG5cbnZhciBhc3NpZ24kMiA9IGFzc2lnbiQzO1xuXG52YXIgdW5jdXJyeVRoaXMkbSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYXJyYXlTbGljZSQ1ID0gdW5jdXJyeVRoaXMkbShbXS5zbGljZSk7XG5cbnZhciBnbG9iYWwkeCA9IGdsb2JhbCRQO1xudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ0ID0gYUNhbGxhYmxlJDc7XG52YXIgaXNPYmplY3QkZSA9IGlzT2JqZWN0JGo7XG52YXIgaGFzT3duJGQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGFycmF5U2xpY2UkNCA9IGFycmF5U2xpY2UkNTtcbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbnZhciBGdW5jdGlvbiQyID0gZ2xvYmFsJHguRnVuY3Rpb247XG52YXIgY29uY2F0JDUgPSB1bmN1cnJ5VGhpcyRsKFtdLmNvbmNhdCk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzJGwoW10uam9pbik7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QkNCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghaGFzT3duJGQoZmFjdG9yaWVzLCBhcmdzTGVuZ3RoKSkge1xuICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcblxuICAgIGZhY3Rvcmllc1thcmdzTGVuZ3RoXSA9IEZ1bmN0aW9uJDIoJ0MsYScsICdyZXR1cm4gbmV3IEMoJyArIGpvaW4obGlzdCwgJywnKSArICcpJyk7XG4gIH1cblxuICByZXR1cm4gZmFjdG9yaWVzW2FyZ3NMZW5ndGhdKEMsIGFyZ3MpO1xufTsgLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblxuXG52YXIgZnVuY3Rpb25CaW5kID0gTkFUSVZFX0JJTkQgPyBGdW5jdGlvbiQyLmJpbmQgOiBmdW5jdGlvbiBiaW5kKHRoYXRcbi8qICwgLi4uYXJncyAqL1xuKSB7XG4gIHZhciBGID0gYUNhbGxhYmxlJDQodGhpcyk7XG4gIHZhciBQcm90b3R5cGUgPSBGLnByb3RvdHlwZTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZSQ0KGFyZ3VtZW50cywgMSk7XG5cbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBmdW5jdGlvblxuICAgIC8qIGFyZ3MuLi4gKi9cbiAgYm91bmQoKSB7XG4gICAgdmFyIGFyZ3MgPSBjb25jYXQkNShwYXJ0QXJncywgYXJyYXlTbGljZSQ0KGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmRGdW5jdGlvbiA/IGNvbnN0cnVjdCQ0KEYsIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IEYuYXBwbHkodGhhdCwgYXJncyk7XG4gIH07XG5cbiAgaWYgKGlzT2JqZWN0JGUoUHJvdG90eXBlKSkgYm91bmRGdW5jdGlvbi5wcm90b3R5cGUgPSBQcm90b3R5cGU7XG4gIHJldHVybiBib3VuZEZ1bmN0aW9uO1xufTtcblxudmFyICQkSSA9IF9leHBvcnQ7XG52YXIgYmluZCRhID0gZnVuY3Rpb25CaW5kOyAvLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXG4kJEkoe1xuICB0YXJnZXQ6ICdGdW5jdGlvbicsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IEZ1bmN0aW9uLmJpbmQgIT09IGJpbmQkYVxufSwge1xuICBiaW5kOiBiaW5kJGFcbn0pO1xuXG52YXIgcGF0aCR1ID0gcGF0aCR5O1xuXG52YXIgZW50cnlWaXJ0dWFsJGwgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1IpIHtcbiAgcmV0dXJuIHBhdGgkdVtDT05TVFJVQ1RPUiArICdQcm90b3R5cGUnXTtcbn07XG5cbnZhciBlbnRyeVZpcnR1YWwkayA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGJpbmQkOSA9IGVudHJ5VmlydHVhbCRrKCdGdW5jdGlvbicpLmJpbmQ7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGwgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRoID0gYmluZCQ5O1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbnZhciBiaW5kJDggPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmJpbmQ7XG4gIHJldHVybiBpdCA9PT0gRnVuY3Rpb25Qcm90b3R5cGUkMSB8fCBpc1Byb3RvdHlwZU9mJGwoRnVuY3Rpb25Qcm90b3R5cGUkMSwgaXQpICYmIG93biA9PT0gRnVuY3Rpb25Qcm90b3R5cGUkMS5iaW5kID8gbWV0aG9kJGggOiBvd247XG59O1xuXG52YXIgcGFyZW50JDE5ID0gYmluZCQ4O1xudmFyIGJpbmQkNyA9IHBhcmVudCQxOTtcblxudmFyIGJpbmQkNiA9IGJpbmQkNztcblxuLyoqXHJcbiAqIERyYXcgYSBjaXJjbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICovXG5mdW5jdGlvbiBkcmF3Q2lyY2xlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBzcXVhcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNxdWFyZS5cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdTcXVhcmUoY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoeCAtIHIsIHkgLSByLCByICogMiwgciAqIDIpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZSBzdGFuZGluZyBvbiBhIHNpZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIGxlbmd0aCBvZiB0aGUgc2lkZXMuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpOyAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcblxuICByICo9IDEuMTU7XG4gIHkgKz0gMC4yNzUgKiByO1xuICB2YXIgcyA9IHIgKiAyO1xuICB2YXIgczIgPSBzIC8gMjtcbiAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcblxuICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICBjdHgubW92ZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gIGN0eC5saW5lVG8oeCArIHMyLCB5ICsgaXIpO1xuICBjdHgubGluZVRvKHggLSBzMiwgeSArIGlyKTtcbiAgY3R4LmxpbmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZSBzdGFuZGluZyBvbiBhIHZlcnRleC5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcy5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlRG93bihjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpOyAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcblxuICByICo9IDEuMTU7XG4gIHkgLT0gMC4yNzUgKiByO1xuICB2YXIgcyA9IHIgKiAyO1xuICB2YXIgczIgPSBzIC8gMjtcbiAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcblxuICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICBjdHgubW92ZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gIGN0eC5saW5lVG8oeCArIHMyLCB5IC0gaXIpO1xuICBjdHgubGluZVRvKHggLSBzMiwgeSAtIGlyKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgKGggLSBpcikpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHN0YXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3U3RhcihjdHgsIHgsIHksIHIpIHtcbiAgLy8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xuICBjdHguYmVnaW5QYXRoKCk7IC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuXG4gIHIgKj0gMC44MjtcbiAgeSArPSAwLjEgKiByO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMTA7IG4rKykge1xuICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IHIgKiAxLjMgOiByICogMC41O1xuICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cyAqIE1hdGguc2luKG4gKiAyICogTWF0aC5QSSAvIDEwKSwgeSAtIHJhZGl1cyAqIE1hdGguY29zKG4gKiAyICogTWF0aC5QSSAvIDEwKSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIGRpYW1vbmQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGRpYW1vbmQuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2xhYnMvaHRtbDUtY2FudmFzLXN0YXItc3Bpbm5lci9cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdEaWFtb25kKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICBjdHgubGluZVRvKHggKyByLCB5KTtcbiAgY3R4LmxpbmVUbyh4LCB5IC0gcik7XG4gIGN0eC5saW5lVG8oeCAtIHIsIHkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycy5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGNvcm5lcnMuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLW9uLWh0bWwtY2FudmFzXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3Um91bmRSZWN0KGN0eCwgeCwgeSwgdywgaCwgcikge1xuICB2YXIgcjJkID0gTWF0aC5QSSAvIDE4MDtcblxuICBpZiAodyAtIDIgKiByIDwgMCkge1xuICAgIHIgPSB3IC8gMjtcbiAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB4XG5cblxuICBpZiAoaCAtIDIgKiByIDwgMCkge1xuICAgIHIgPSBoIC8gMjtcbiAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB5XG5cblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuICBjdHgubGluZVRvKHggKyB3IC0gciwgeSk7XG4gIGN0eC5hcmMoeCArIHcgLSByLCB5ICsgciwgciwgcjJkICogMjcwLCByMmQgKiAzNjAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHIsIHkgKyBoIC0gciwgciwgMCwgcjJkICogOTAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4ICsgciwgeSArIGgpO1xuICBjdHguYXJjKHggKyByLCB5ICsgaCAtIHIsIHIsIHIyZCAqIDkwLCByMmQgKiAxODAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcik7XG4gIGN0eC5hcmMoeCArIHIsIHkgKyByLCByLCByMmQgKiAxODAsIHIyZCAqIDI3MCwgZmFsc2UpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlbGxpcHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2UuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZS5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXHJcbiAqXHJcbiAqIFBvc3RmaXggJ192aXMnIGFkZGVkIHRvIGRpc2Nlcm4gaXQgZnJvbSBzdGFuZGFyZCBtZXRob2QgZWxsaXBzZSgpLlxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0VsbGlwc2UoY3R4LCB4LCB5LCB3LCBoKSB7XG4gIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgIG94ID0gdyAvIDIgKiBrYXBwYSxcbiAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgb3kgPSBoIC8gMiAqIGthcHBhLFxuICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgeGUgPSB4ICsgdyxcbiAgICAgIC8vIHgtZW5kXG4gIHllID0geSArIGgsXG4gICAgICAvLyB5LWVuZFxuICB4bSA9IHggKyB3IC8gMixcbiAgICAgIC8vIHgtbWlkZGxlXG4gIHltID0geSArIGggLyAyOyAvLyB5LW1pZGRsZVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4LCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gaXNvbWV0cmljIGN5bGluZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIGRhdGFiYXNlLlxyXG4gKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIGRhdGFiYXNlLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdEYXRhYmFzZShjdHgsIHgsIHksIHcsIGgpIHtcbiAgdmFyIGYgPSAxIC8gMztcbiAgdmFyIHdFbGxpcHNlID0gdztcbiAgdmFyIGhFbGxpcHNlID0gaCAqIGY7XG4gIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgIG94ID0gd0VsbGlwc2UgLyAyICoga2FwcGEsXG4gICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gIG95ID0gaEVsbGlwc2UgLyAyICoga2FwcGEsXG4gICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICB4ZSA9IHggKyB3RWxsaXBzZSxcbiAgICAgIC8vIHgtZW5kXG4gIHllID0geSArIGhFbGxpcHNlLFxuICAgICAgLy8geS1lbmRcbiAgeG0gPSB4ICsgd0VsbGlwc2UgLyAyLFxuICAgICAgLy8geC1taWRkbGVcbiAgeW0gPSB5ICsgaEVsbGlwc2UgLyAyLFxuICAgICAgLy8geS1taWRkbGVcbiAgeW1iID0geSArIChoIC0gaEVsbGlwc2UgLyAyKSxcbiAgICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICB5ZWIgPSB5ICsgaDsgLy8geS1lbmQsIGJvdHRvbSBlbGxpcHNlXG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHhlLCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgY3R4LmxpbmVUbyh4ZSwgeW1iKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltYiArIG95LCB4bSArIG94LCB5ZWIsIHhtLCB5ZWIpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZWIsIHgsIHltYiArIG95LCB4LCB5bWIpO1xuICBjdHgubGluZVRvKHgsIHltKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgZGFzaGVkIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB4MiAtIFRoZSBlbmQgcG9zaXRpb24gb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkyIC0gVGhlIGVuZCBwb3NpdGlvbiBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gcGF0dGVybiAtIExpc3Qgb2YgbGVuZ3RocyBzdGFydGluZyB3aXRoIGxpbmUgYW5kIHRoZW4gYWx0ZXJuYXRpbmcgYmV0d2VlbiBzcGFjZSBhbmQgbGluZS5cclxuICogQGF1dGhvciBEYXZpZCBKb3JkYW5cclxuICogQHJlbWFya3NcclxuICogZGF0ZSAyMDEyLTA4LTA4XHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1xyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4MiwgeTIsIHBhdHRlcm4pIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHgsIHkpO1xuICB2YXIgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICB2YXIgZHggPSB4MiAtIHg7XG4gIHZhciBkeSA9IHkyIC0geTtcbiAgdmFyIHNsb3BlID0gZHkgLyBkeDtcbiAgdmFyIGRpc3RSZW1haW5pbmcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB2YXIgcGF0dGVybkluZGV4ID0gMDtcbiAgdmFyIGRyYXcgPSB0cnVlO1xuICB2YXIgeFN0ZXAgPSAwO1xuICB2YXIgZGFzaExlbmd0aCA9ICtwYXR0ZXJuWzBdO1xuXG4gIHdoaWxlIChkaXN0UmVtYWluaW5nID49IDAuMSkge1xuICAgIGRhc2hMZW5ndGggPSArcGF0dGVybltwYXR0ZXJuSW5kZXgrKyAlIHBhdHRlcm5MZW5ndGhdO1xuXG4gICAgaWYgKGRhc2hMZW5ndGggPiBkaXN0UmVtYWluaW5nKSB7XG4gICAgICBkYXNoTGVuZ3RoID0gZGlzdFJlbWFpbmluZztcbiAgICB9XG5cbiAgICB4U3RlcCA9IE1hdGguc3FydChkYXNoTGVuZ3RoICogZGFzaExlbmd0aCAvICgxICsgc2xvcGUgKiBzbG9wZSkpO1xuICAgIHhTdGVwID0gZHggPCAwID8gLXhTdGVwIDogeFN0ZXA7XG4gICAgeCArPSB4U3RlcDtcbiAgICB5ICs9IHNsb3BlICogeFN0ZXA7XG5cbiAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBkaXN0UmVtYWluaW5nIC09IGRhc2hMZW5ndGg7XG4gICAgZHJhdyA9ICFkcmF3O1xuICB9XG59XG4vKipcclxuICogRHJhdyBhIGhleGFnb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGhleGFnb24uXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3SGV4YWdvbihjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICB2YXIgc2lkZXMgPSA2O1xuICB2YXIgYSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIGN0eC5saW5lVG8oeCArIHIgKiBNYXRoLmNvcyhhICogaSksIHkgKyByICogTWF0aC5zaW4oYSAqIGkpKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbnZhciBzaGFwZU1hcCA9IHtcbiAgY2lyY2xlOiBkcmF3Q2lyY2xlLFxuICBkYXNoZWRMaW5lOiBkcmF3RGFzaGVkTGluZSxcbiAgZGF0YWJhc2U6IGRyYXdEYXRhYmFzZSxcbiAgZGlhbW9uZDogZHJhd0RpYW1vbmQsXG4gIGVsbGlwc2U6IGRyYXdFbGxpcHNlLFxuICBlbGxpcHNlX3ZpczogZHJhd0VsbGlwc2UsXG4gIGhleGFnb246IGRyYXdIZXhhZ29uLFxuICByb3VuZFJlY3Q6IGRyYXdSb3VuZFJlY3QsXG4gIHNxdWFyZTogZHJhd1NxdWFyZSxcbiAgc3RhcjogZHJhd1N0YXIsXG4gIHRyaWFuZ2xlOiBkcmF3VHJpYW5nbGUsXG4gIHRyaWFuZ2xlRG93bjogZHJhd1RyaWFuZ2xlRG93blxufTtcbi8qKlxyXG4gKiBSZXR1cm5zIGVpdGhlciBjdXN0b20gb3IgbmF0aXZlIGRyYXdpbmcgZnVuY3Rpb24gYmFzZSBvbiBzdXBwbGllZCBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi4gRWl0aGVyIHRoZSBuYW1lIG9mIGFcclxuICogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHByb3BlcnR5IG9yIGFuIGV4cG9ydCBmcm9tIHNoYXBlcy50cyB3aXRob3V0IHRoZVxyXG4gKiBkcmF3IHByZWZpeC5cclxuICogQHJldHVybnMgVGhlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHJlbmRlcmluZy4gSW4gY2FzZSBvZiBuYXRpdmVcclxuICogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGZ1bmN0aW9uIHRoZSBBUEkgaXMgbm9ybWFsaXplZCB0b1xyXG4gKiBgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCAuLi5vcmlnaW5hbEFyZ3MpID0+IHZvaWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2hhcGUobmFtZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNoYXBlTWFwLCBuYW1lKSkge1xuICAgIHJldHVybiBzaGFwZU1hcFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtuYW1lXS5jYWxsKGN0eCwgYXJncyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAocmVmID09PSB2b2lkIDApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBjc3NfMjQ4eiQ2ID0gXCIudmlzLW92ZXJsYXkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwcHg7XFxuICByaWdodDogMHB4O1xcbiAgYm90dG9tOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxuXFxuICAvKiBNdXN0IGJlIGRpc3BsYXllZCBhYm92ZSBmb3IgZXhhbXBsZSBzZWxlY3RlZCBUaW1lbGluZSBpdGVtcyAqL1xcbiAgei1pbmRleDogMTA7XFxufVxcblxcbi52aXMtYWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IDAgMCAxMHB4ICM4NmQ1Zjg7XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokNik7XG5cbnZhciBjc3NfMjQ4eiQ1ID0gXCIvKiBvdmVycmlkZSBzb21lIGJvb3RzdHJhcCBzdHlsZXMgc2NyZXdpbmcgdXAgdGhlIHRpbWVsaW5lcyBjc3MgKi9cXG5cXG4udmlzIFtjbGFzcyo9XFxcInNwYW5cXFwiXSB7XFxuICBtaW4taGVpZ2h0OiAwO1xcbiAgd2lkdGg6IGF1dG87XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokNSk7XG5cbnZhciBjc3NfMjQ4eiQ0ID0gXCJkaXYudmlzLWNvbG9yLXBpY2tlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDMwcHg7XFxuICBtYXJnaW4tdG9wOiAtMTQwcHg7XFxuICBtYXJnaW4tbGVmdDogMzBweDtcXG4gIHdpZHRoOiAzMTBweDtcXG4gIGhlaWdodDogNDQ0cHg7XFxuICB6LWluZGV4OiAxO1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC41KSAwcHggMHB4IDEwcHggMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWFycm93IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTQ3cHg7XFxuICBsZWZ0OiA1cHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYXJyb3c6OmFmdGVyLFxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYXJyb3c6OmJlZm9yZSB7XFxuICByaWdodDogMTAwJTtcXG4gIHRvcDogNTAlO1xcbiAgYm9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG4gIGhlaWdodDogMDtcXG4gIHdpZHRoOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYXJyb3c6YWZ0ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDApO1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjZmZmZmZmO1xcbiAgYm9yZGVyLXdpZHRoOiAzMHB4O1xcbiAgbWFyZ2luLXRvcDogLTMwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtY29sb3Ige1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDI4OXB4O1xcbiAgaGVpZ2h0OiAyODlweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1icmlnaHRuZXNzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMzEzcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtb3BhY2l0eSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDM1MHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLXNlbGVjdG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTM3cHg7XFxuICBsZWZ0OiAxMzdweDtcXG4gIHdpZHRoOiAxNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmZmZmY7XFxuICBiYWNrZ3JvdW5kOiAjNGM0YzRjOyAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICM0YzRjNGMgMCUsXFxuICAgICM1OTU5NTkgMTIlLFxcbiAgICAjNjY2NjY2IDI1JSxcXG4gICAgIzQ3NDc0NyAzOSUsXFxuICAgICMyYzJjMmMgNTAlLFxcbiAgICAjMDAwMDAwIDUxJSxcXG4gICAgIzExMTExMSA2MCUsXFxuICAgICMyYjJiMmIgNzYlLFxcbiAgICAjMWMxYzFjIDkxJSxcXG4gICAgIzEzMTMxMyAxMDAlXFxuICApOyAvKiBGRjMuNisgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxuICAgIGxpbmVhcixcXG4gICAgbGVmdCB0b3AsXFxuICAgIGxlZnQgYm90dG9tLFxcbiAgICBjb2xvci1zdG9wKDAlLCAjNGM0YzRjKSxcXG4gICAgY29sb3Itc3RvcCgxMiUsICM1OTU5NTkpLFxcbiAgICBjb2xvci1zdG9wKDI1JSwgIzY2NjY2NiksXFxuICAgIGNvbG9yLXN0b3AoMzklLCAjNDc0NzQ3KSxcXG4gICAgY29sb3Itc3RvcCg1MCUsICMyYzJjMmMpLFxcbiAgICBjb2xvci1zdG9wKDUxJSwgIzAwMDAwMCksXFxuICAgIGNvbG9yLXN0b3AoNjAlLCAjMTExMTExKSxcXG4gICAgY29sb3Itc3RvcCg3NiUsICMyYjJiMmIpLFxcbiAgICBjb2xvci1zdG9wKDkxJSwgIzFjMWMxYyksXFxuICAgIGNvbG9yLXN0b3AoMTAwJSwgIzEzMTMxMylcXG4gICk7IC8qIENocm9tZSxTYWZhcmk0KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzRjNGM0YyAwJSxcXG4gICAgIzU5NTk1OSAxMiUsXFxuICAgICM2NjY2NjYgMjUlLFxcbiAgICAjNDc0NzQ3IDM5JSxcXG4gICAgIzJjMmMyYyA1MCUsXFxuICAgICMwMDAwMDAgNTElLFxcbiAgICAjMTExMTExIDYwJSxcXG4gICAgIzJiMmIyYiA3NiUsXFxuICAgICMxYzFjMWMgOTElLFxcbiAgICAjMTMxMzEzIDEwMCVcXG4gICk7IC8qIENocm9tZTEwKyxTYWZhcmk1LjErICovXFxuICBiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzRjNGM0YyAwJSxcXG4gICAgIzU5NTk1OSAxMiUsXFxuICAgICM2NjY2NjYgMjUlLFxcbiAgICAjNDc0NzQ3IDM5JSxcXG4gICAgIzJjMmMyYyA1MCUsXFxuICAgICMwMDAwMDAgNTElLFxcbiAgICAjMTExMTExIDYwJSxcXG4gICAgIzJiMmIyYiA3NiUsXFxuICAgICMxYzFjMWMgOTElLFxcbiAgICAjMTMxMzEzIDEwMCVcXG4gICk7IC8qIE9wZXJhIDExLjEwKyAqL1xcbiAgYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjNGM0YzRjIDAlLFxcbiAgICAjNTk1OTU5IDEyJSxcXG4gICAgIzY2NjY2NiAyNSUsXFxuICAgICM0NzQ3NDcgMzklLFxcbiAgICAjMmMyYzJjIDUwJSxcXG4gICAgIzAwMDAwMCA1MSUsXFxuICAgICMxMTExMTEgNjAlLFxcbiAgICAjMmIyYjJiIDc2JSxcXG4gICAgIzFjMWMxYyA5MSUsXFxuICAgICMxMzEzMTMgMTAwJVxcbiAgKTsgLyogSUUxMCsgKi9cXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXG4gICAgdG8gYm90dG9tLFxcbiAgICAjNGM0YzRjIDAlLFxcbiAgICAjNTk1OTU5IDEyJSxcXG4gICAgIzY2NjY2NiAyNSUsXFxuICAgICM0NzQ3NDcgMzklLFxcbiAgICAjMmMyYzJjIDUwJSxcXG4gICAgIzAwMDAwMCA1MSUsXFxuICAgICMxMTExMTEgNjAlLFxcbiAgICAjMmIyYjJiIDc2JSxcXG4gICAgIzFjMWMxYyA5MSUsXFxuICAgICMxMzEzMTMgMTAwJVxcbiAgKTsgLyogVzNDICovXFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj0nIzRjNGM0YycsIGVuZENvbG9yc3RyPScjMTMxMzEzJyxHcmFkaWVudFR5cGU9MCApOyAvKiBJRTYtOSAqL1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLW5ldy1jb2xvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMTQwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICB0b3A6IDM4MHB4O1xcbiAgbGVmdDogMTU5cHg7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIHBhZGRpbmctcmlnaHQ6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtaW5pdGlhbC1jb2xvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMTQwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICB0b3A6IDM4MHB4O1xcbiAgbGVmdDogMTBweDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBwYWRkaW5nLWxlZnQ6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtbGFiZWwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgbGVmdDogMTBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1sYWJlbC52aXMtYnJpZ2h0bmVzcyB7XFxuICB0b3A6IDMwMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWxhYmVsLnZpcy1vcGFjaXR5IHtcXG4gIHRvcDogMzM4cHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiA2OHB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG4gIHRvcDogNDEwcHg7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjZDlkOWQ5O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1idXR0b24udmlzLWNhbmNlbCB7XFxuICAvKmJvcmRlcjoycHggc29saWQgI2ZmNGUzMzsqL1xcbiAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjZmY3NzYxOyovXFxuICBsZWZ0OiA1cHg7XFxufVxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYnV0dG9uLnZpcy1sb2FkIHtcXG4gIC8qYm9yZGVyOjJweCBzb2xpZCAjYTE1M2U2OyovXFxuICAvKmJhY2tncm91bmQtY29sb3I6ICNjYjhkZmY7Ki9cXG4gIGxlZnQ6IDgycHg7XFxufVxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYnV0dG9uLnZpcy1hcHBseSB7XFxuICAvKmJvcmRlcjoycHggc29saWQgIzQ1ODhlNjsqL1xcbiAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjODJiNmZmOyovXFxuICBsZWZ0OiAxNTlweDtcXG59XFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1idXR0b24udmlzLXNhdmUge1xcbiAgLypib3JkZXI6MnB4IHNvbGlkICM0NWU2NTU7Ki9cXG4gIC8qYmFja2dyb3VuZC1jb2xvcjogIzZkZmY3YzsqL1xcbiAgbGVmdDogMjM2cHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGlucHV0LnZpcy1yYW5nZSB7XFxuICB3aWR0aDogMjkwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxufVxcblxcbi8qIFRPRE86IGlzIHRoaXMgcmVkdW5kYW50P1xcbmRpdi52aXMtY29sb3ItcGlja2VyIGlucHV0LnZpcy1yYW5nZS1icmlnaHRuZXNzIHtcXG4gIHdpZHRoOiAyODlweCAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBpbnB1dC52aXMtc2F0dXJhdGlvbi1yYW5nZSB7XFxuICB3aWR0aDogMjg5cHggIWltcG9ydGFudDtcXG59Ki9cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDQpO1xuXG52YXIgY3NzXzI0OHokMyA9IFwiZGl2LnZpcy1jb25maWd1cmF0aW9uIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDcwMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlcjo6YWZ0ZXIge1xcbiAgY2xlYXI6IGJvdGg7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1vcHRpb24tY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDQ5NXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICNmN2Y4ZmE7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcbiAgbGVmdDogMTBweDtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1idXR0b24ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogNDk1cHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmOGZhO1xcbiAgYm9yZGVyOiAycHggc29saWQgI2NlY2VkMDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxuICBsZWZ0OiAxMHB4O1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiAzMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1idXR0b24uaG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzQ1ODhlNjtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMyMTQzNzM7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctaXRlbSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDQ5NXB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1pdGVtLnZpcy1jb25maWctczIge1xcbiAgbGVmdDogMTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmN2Y4ZmE7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctaXRlbS52aXMtY29uZmlnLXMzIHtcXG4gIGxlZnQ6IDIwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTRlOWYwO1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWl0ZW0udmlzLWNvbmZpZy1zNCB7XFxuICBsZWZ0OiAzMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NmZDhlNjtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1oZWFkZXIge1xcbiAgZm9udC1zaXplOiAxOHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWxhYmVsIHtcXG4gIHdpZHRoOiAxMjBweDtcXG4gIGhlaWdodDogMjVweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1sYWJlbC52aXMtY29uZmlnLXMzIHtcXG4gIHdpZHRoOiAxMTBweDtcXG59XFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctbGFiZWwudmlzLWNvbmZpZy1zNCB7XFxuICB3aWR0aDogMTAwcHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWNvbG9yQmxvY2sge1xcbiAgdG9wOiAxcHg7XFxuICB3aWR0aDogMzBweDtcXG4gIGhlaWdodDogMTlweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM0NDQ0NDQ7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBwYWRkaW5nOiAwcHg7XFxuICBtYXJnaW46IDBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1jaGVja2JveCB7XFxuICBsZWZ0OiAtNXB4O1xcbn1cXG5cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlaW5wdXQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAtNXB4O1xcbiAgd2lkdGg6IDYwcHg7XFxuICAvKmhlaWdodDoxM3B4OyovXFxuICBwYWRkaW5nOiAxcHg7XFxuICBtYXJnaW46IDA7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZSB7XFxuICAvKnJlbW92ZXMgZGVmYXVsdCB3ZWJraXQgc3R5bGVzKi9cXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG5cXG4gIC8qZml4IGZvciBGRiB1bmFibGUgdG8gYXBwbHkgZm9jdXMgc3R5bGUgYnVnICovXFxuICBib3JkZXI6IDBweCBzb2xpZCB3aGl0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxuXFxuICAvKnJlcXVpcmVkIGZvciBwcm9wZXIgdHJhY2sgc2l6aW5nIGluIEZGKi9cXG4gIHdpZHRoOiAzMDBweDtcXG4gIGhlaWdodDogMjBweDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LXdlYmtpdC1zbGlkZXItcnVubmFibGUtdHJhY2sge1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuICBiYWNrZ3JvdW5kOiAjZGVkZWRlOyAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgI2RlZGVkZSAwJSwgI2M4YzhjOCA5OSUpOyAvKiBGRjMuNisgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxuICAgIGxpbmVhcixcXG4gICAgbGVmdCB0b3AsXFxuICAgIGxlZnQgYm90dG9tLFxcbiAgICBjb2xvci1zdG9wKDAlLCAjZGVkZWRlKSxcXG4gICAgY29sb3Itc3RvcCg5OSUsICNjOGM4YzgpXFxuICApOyAvKiBDaHJvbWUsU2FmYXJpNCsgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNkZWRlZGUgMCUsXFxuICAgICNjOGM4YzggOTklXFxuICApOyAvKiBDaHJvbWUxMCssU2FmYXJpNS4xKyAqL1xcbiAgYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNkZWRlZGUgMCUsXFxuICAgICNjOGM4YzggOTklXFxuICApOyAvKiBPcGVyYSAxMS4xMCsgKi9cXG4gIGJhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjZGVkZWRlIDAlLCAjYzhjOGM4IDk5JSk7IC8qIElFMTArICovXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjZGVkZWRlIDAlLCAjYzhjOGM4IDk5JSk7IC8qIFczQyAqL1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoIHN0YXJ0Q29sb3JzdHI9JyNkZWRlZGUnLCBlbmRDb2xvcnN0cj0nI2M4YzhjOCcsR3JhZGllbnRUeXBlPTAgKTsgLyogSUU2LTkgKi9cXG5cXG4gIGJvcmRlcjogMXB4IHNvbGlkICM5OTk5OTk7XFxuICBib3gtc2hhZG93OiAjYWFhYWFhIDBweCAwcHggM3B4IDBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LXdlYmtpdC1zbGlkZXItdGh1bWIge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzE0MzM0YjtcXG4gIGhlaWdodDogMTdweDtcXG4gIHdpZHRoOiAxN3B4O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZDogIzM4NzZjMjsgLyogT2xkIGJyb3dzZXJzICovXFxuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICMzODc2YzIgMCUsICMzODUzODAgMTAwJSk7IC8qIEZGMy42KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXG4gICAgbGluZWFyLFxcbiAgICBsZWZ0IHRvcCxcXG4gICAgbGVmdCBib3R0b20sXFxuICAgIGNvbG9yLXN0b3AoMCUsICMzODc2YzIpLFxcbiAgICBjb2xvci1zdG9wKDEwMCUsICMzODUzODApXFxuICApOyAvKiBDaHJvbWUsU2FmYXJpNCsgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICMzODc2YzIgMCUsXFxuICAgICMzODUzODAgMTAwJVxcbiAgKTsgLyogQ2hyb21lMTArLFNhZmFyaTUuMSsgKi9cXG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjMzg3NmMyIDAlLFxcbiAgICAjMzg1MzgwIDEwMCVcXG4gICk7IC8qIE9wZXJhIDExLjEwKyAqL1xcbiAgYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICMzODc2YzIgMCUsICMzODUzODAgMTAwJSk7IC8qIElFMTArICovXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjMzg3NmMyIDAlLCAjMzg1MzgwIDEwMCUpOyAvKiBXM0MgKi9cXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KCBzdGFydENvbG9yc3RyPScjMzg3NmMyJywgZW5kQ29sb3JzdHI9JyMzODUzODAnLEdyYWRpZW50VHlwZT0wICk7IC8qIElFNi05ICovXFxuICBib3gtc2hhZG93OiAjMTExOTI3IDBweCAwcHggMXB4IDBweDtcXG4gIG1hcmdpbi10b3A6IC03cHg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTpmb2N1czo6LXdlYmtpdC1zbGlkZXItcnVubmFibGUtdHJhY2sge1xcbiAgYmFja2dyb3VuZDogIzlkOWQ5ZDsgLyogT2xkIGJyb3dzZXJzICovXFxuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICM5ZDlkOWQgMCUsICNjOGM4YzggOTklKTsgLyogRkYzLjYrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcbiAgICBsaW5lYXIsXFxuICAgIGxlZnQgdG9wLFxcbiAgICBsZWZ0IGJvdHRvbSxcXG4gICAgY29sb3Itc3RvcCgwJSwgIzlkOWQ5ZCksXFxuICAgIGNvbG9yLXN0b3AoOTklLCAjYzhjOGM4KVxcbiAgKTsgLyogQ2hyb21lLFNhZmFyaTQrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjOWQ5ZDlkIDAlLFxcbiAgICAjYzhjOGM4IDk5JVxcbiAgKTsgLyogQ2hyb21lMTArLFNhZmFyaTUuMSsgKi9cXG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjOWQ5ZDlkIDAlLFxcbiAgICAjYzhjOGM4IDk5JVxcbiAgKTsgLyogT3BlcmEgMTEuMTArICovXFxuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgIzlkOWQ5ZCAwJSwgI2M4YzhjOCA5OSUpOyAvKiBJRTEwKyAqL1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgIzlkOWQ5ZCAwJSwgI2M4YzhjOCA5OSUpOyAvKiBXM0MgKi9cXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KCBzdGFydENvbG9yc3RyPScjOWQ5ZDlkJywgZW5kQ29sb3JzdHI9JyNjOGM4YzgnLEdyYWRpZW50VHlwZT0wICk7IC8qIElFNi05ICovXFxufVxcblxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi1tb3otcmFuZ2UtdHJhY2sge1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgYmFja2dyb3VuZDogI2RlZGVkZTsgLyogT2xkIGJyb3dzZXJzICovXFxuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICNkZWRlZGUgMCUsICNjOGM4YzggOTklKTsgLyogRkYzLjYrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcbiAgICBsaW5lYXIsXFxuICAgIGxlZnQgdG9wLFxcbiAgICBsZWZ0IGJvdHRvbSxcXG4gICAgY29sb3Itc3RvcCgwJSwgI2RlZGVkZSksXFxuICAgIGNvbG9yLXN0b3AoOTklLCAjYzhjOGM4KVxcbiAgKTsgLyogQ2hyb21lLFNhZmFyaTQrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZGVkZWRlIDAlLFxcbiAgICAjYzhjOGM4IDk5JVxcbiAgKTsgLyogQ2hyb21lMTArLFNhZmFyaTUuMSsgKi9cXG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZGVkZWRlIDAlLFxcbiAgICAjYzhjOGM4IDk5JVxcbiAgKTsgLyogT3BlcmEgMTEuMTArICovXFxuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgI2RlZGVkZSAwJSwgI2M4YzhjOCA5OSUpOyAvKiBJRTEwKyAqL1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgI2RlZGVkZSAwJSwgI2M4YzhjOCA5OSUpOyAvKiBXM0MgKi9cXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KCBzdGFydENvbG9yc3RyPScjZGVkZWRlJywgZW5kQ29sb3JzdHI9JyNjOGM4YzgnLEdyYWRpZW50VHlwZT0wICk7IC8qIElFNi05ICovXFxuXFxuICBib3JkZXI6IDFweCBzb2xpZCAjOTk5OTk5O1xcbiAgYm94LXNoYWRvdzogI2FhYWFhYSAwcHggMHB4IDNweCAwcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi1tb3otcmFuZ2UtdGh1bWIge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgd2lkdGg6IDE2cHg7XFxuXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kOiAjMzg1MzgwO1xcbn1cXG5cXG4vKmhpZGUgdGhlIG91dGxpbmUgYmVoaW5kIHRoZSBib3JkZXIqL1xcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IHNvbGlkIHdoaXRlO1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0xcHg7XFxufVxcblxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi1tcy10cmFjayB7XFxuICB3aWR0aDogMzAwcHg7XFxuICBoZWlnaHQ6IDVweDtcXG5cXG4gIC8qcmVtb3ZlIGJnIGNvbG91ciBmcm9tIHRoZSB0cmFjaywgd2UnbGwgdXNlIG1zLWZpbGwtbG93ZXIgYW5kIG1zLWZpbGwtdXBwZXIgaW5zdGVhZCAqL1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuXFxuICAvKmxlYXZlIHJvb20gZm9yIHRoZSBsYXJnZXIgdGh1bWIgdG8gb3ZlcmZsb3cgd2l0aCBhIHRyYW5zcGFyZW50IGJvcmRlciAqL1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci13aWR0aDogNnB4IDA7XFxuXFxuICAvKnJlbW92ZSBkZWZhdWx0IHRpY2sgbWFya3MqL1xcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotbXMtZmlsbC1sb3dlciB7XFxuICBiYWNrZ3JvdW5kOiAjNzc3O1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LW1zLWZpbGwtdXBwZXIge1xcbiAgYmFja2dyb3VuZDogI2RkZDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi1tcy10aHVtYiB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICB3aWR0aDogMTZweDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGJhY2tncm91bmQ6ICMzODUzODA7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Zm9jdXM6Oi1tcy1maWxsLWxvd2VyIHtcXG4gIGJhY2tncm91bmQ6ICM4ODg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Zm9jdXM6Oi1tcy1maWxsLXVwcGVyIHtcXG4gIGJhY2tncm91bmQ6ICNjY2M7XFxufVxcblxcbi52aXMtY29uZmlndXJhdGlvbi1wb3B1cCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDU3LCA3NiwgODksIDAuODUpO1xcbiAgYm9yZGVyOiAycHggc29saWQgI2YyZmFmZjtcXG4gIGxpbmUtaGVpZ2h0OiAzMHB4O1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgd2lkdGg6IDE1MHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICNmZmZmZmY7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlLWluLW91dDtcXG4gIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2UtaW4tb3V0O1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2UtaW4tb3V0O1xcbn1cXG4udmlzLWNvbmZpZ3VyYXRpb24tcG9wdXA6YWZ0ZXIsXFxuLnZpcy1jb25maWd1cmF0aW9uLXBvcHVwOmJlZm9yZSB7XFxuICBsZWZ0OiAxMDAlO1xcbiAgdG9wOiA1MCU7XFxuICBib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgaGVpZ2h0OiAwO1xcbiAgd2lkdGg6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLnZpcy1jb25maWd1cmF0aW9uLXBvcHVwOmFmdGVyIHtcXG4gIGJvcmRlci1jb2xvcjogcmdiYSgxMzYsIDE4MywgMjEzLCAwKTtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiByZ2JhKDU3LCA3NiwgODksIDAuODUpO1xcbiAgYm9yZGVyLXdpZHRoOiA4cHg7XFxuICBtYXJnaW4tdG9wOiAtOHB4O1xcbn1cXG4udmlzLWNvbmZpZ3VyYXRpb24tcG9wdXA6YmVmb3JlIHtcXG4gIGJvcmRlci1jb2xvcjogcmdiYSgxOTQsIDIyNSwgMjQ1LCAwKTtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiAjZjJmYWZmO1xcbiAgYm9yZGVyLXdpZHRoOiAxMnB4O1xcbiAgbWFyZ2luLXRvcDogLTEycHg7XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokMyk7XG5cbnZhciBjc3NfMjQ4eiQyID0gXCJkaXYudmlzLXRvb2x0aXAge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG5cXG4gIGZvbnQtZmFtaWx5OiB2ZXJkYW5hO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgY29sb3I6ICMwMDAwMDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNGVkO1xcblxcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwNzQ7XFxuXFxuICBib3gtc2hhZG93OiAzcHggM3B4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuXFxuICB6LWluZGV4OiA1O1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDIpO1xuXG52YXIgY29tcG9uZW50RW1pdHRlciA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4gIC8qKlxyXG4gICAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAgICovXG4gIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAgICpcclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbiAgfVxuICAvKipcclxuICAgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cblxuICBmdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIC8qKlxyXG4gICAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIG9uLmZuID0gZm47XG4gICAgdGhpcy5vbihldmVudCwgb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9OyAvLyBhbGxcblxuICAgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBzcGVjaWZpYyBldmVudFxuXG5cbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7IC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcblxuICAgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuXG5cbiAgICB2YXIgY2I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2IgPSBjYWxsYmFja3NbaV07XG5cbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xuICAgIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cblxuXG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcbiAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICEhdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbiAgfTtcbn0pKGNvbXBvbmVudEVtaXR0ZXIpO1xuXG52YXIgRW1pdHRlciA9IGNvbXBvbmVudEVtaXR0ZXIuZXhwb3J0cztcblxudmFyIHdlbGxLbm93blN5bWJvbCRoID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sJGgoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCQyID0ge307XG50ZXN0JDJbVE9fU1RSSU5HX1RBRyQzXSA9ICd6JztcbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCQyKSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgZ2xvYmFsJHcgPSBnbG9iYWwkUDtcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMiA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJGg7XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCRnKCd0b1N0cmluZ1RhZycpO1xudmFyIE9iamVjdCQ3ID0gZ2xvYmFsJHcuT2JqZWN0OyAvLyBFUzMgd3JvbmcgaGVyZVxuXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cztcbn0oKSkgPT0gJ0FyZ3VtZW50cyc7IC8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG5cbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbn07IC8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcblxuXG52YXIgY2xhc3NvZiRlID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUJDIgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QkNyhpdCksIFRPX1NUUklOR19UQUckMikpID09ICdzdHJpbmcnID8gdGFnIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKSAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkOShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBnbG9iYWwkdiA9IGdsb2JhbCRQO1xudmFyIGNsYXNzb2YkZCA9IGNsYXNzb2YkZTtcbnZhciBTdHJpbmckMiA9IGdsb2JhbCR2LlN0cmluZztcblxudmFyIHRvU3RyaW5nJDggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YkZChhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiBTdHJpbmckMihhcmd1bWVudCk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkayA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIHRvU3RyaW5nJDcgPSB0b1N0cmluZyQ4O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciBjaGFyQXQkMyA9IHVuY3VycnlUaGlzJGsoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0JDEgPSB1bmN1cnJ5VGhpcyRrKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMkaygnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QkNCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nJDcocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGID8gQ09OVkVSVF9UT19TVFJJTkcgPyBjaGFyQXQkMyhTLCBwb3NpdGlvbikgOiBmaXJzdCA6IENPTlZFUlRfVE9fU1RSSU5HID8gc3RyaW5nU2xpY2UoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QkNChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCQ0KHRydWUpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRoO1xudmFyIHN0b3JlJDEgPSBzaGFyZWRTdG9yZTtcbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkaihGdW5jdGlvbi50b1N0cmluZyk7IC8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcblxuaWYgKCFpc0NhbGxhYmxlJDgoc3RvcmUkMS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZSQxLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbnZhciBpbnNwZWN0U291cmNlJDIgPSBzdG9yZSQxLmluc3BlY3RTb3VyY2U7XG5cbnZhciBnbG9iYWwkdSA9IGdsb2JhbCRQO1xudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkaDtcbnZhciBpbnNwZWN0U291cmNlJDEgPSBpbnNwZWN0U291cmNlJDI7XG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJHUuV2Vha01hcDtcbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSQ3KFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMShXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQyID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciB1aWQkMiA9IHVpZCQ0O1xudmFyIGtleXMkNyA9IHNoYXJlZCQyKCdrZXlzJyk7XG5cbnZhciBzaGFyZWRLZXkkNCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXMkN1trZXldIHx8IChrZXlzJDdba2V5XSA9IHVpZCQyKGtleSkpO1xufTtcblxudmFyIE5BVElWRV9XRUFLX01BUCQxID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkdCA9IGdsb2JhbCRQO1xudmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0JGQgPSBpc09iamVjdCRqO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgaGFzT3duJGMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCQxID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5JDMgPSBzaGFyZWRLZXkkNDtcbnZhciBoaWRkZW5LZXlzJDQgPSBoaWRkZW5LZXlzJDY7XG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciRkID0gZ2xvYmFsJHQuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkdC5XZWFrTWFwO1xudmFyIHNldCQzLCBnZXQkNiwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldCQ2KGl0KSA6IHNldCQzKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcblxuICAgIGlmICghaXNPYmplY3QkZChpdCkgfHwgKHN0YXRlID0gZ2V0JDYoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IkZCgnSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQJDEgfHwgc2hhcmVkJDEuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkJDEuc3RhdGUgfHwgKHNoYXJlZCQxLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHVuY3VycnlUaGlzJGkoc3RvcmUuZ2V0KTtcbiAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMkaShzdG9yZS5oYXMpO1xuICB2YXIgd21zZXQgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLnNldCk7XG5cbiAgc2V0JDMgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkZChPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuXG4gIGdldCQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0KHN0b3JlLCBpdCkgfHwge307XG4gIH07XG5cbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkkMygnc3RhdGUnKTtcbiAgaGlkZGVuS2V5cyQ0W1NUQVRFXSA9IHRydWU7XG5cbiAgc2V0JDMgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biRjKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkZChPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuXG4gIGdldCQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biRjKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcblxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJGMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDMsXG4gIGdldDogZ2V0JDYsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxudmFyIERFU0NSSVBUT1JTJGIgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kYiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyRiICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRVhJU1RTID0gaGFzT3duJGIoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJyk7IC8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcblxudmFyIFBST1BFUiA9IEVYSVNUUyAmJiBmdW5jdGlvbiBzb21ldGhpbmcoKSB7XG4gIC8qIGVtcHR5ICovXG59Lm5hbWUgPT09ICdzb21ldGhpbmcnO1xuXG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkYiB8fCBERVNDUklQVE9SUyRiICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKTtcbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0ge307XG5cbnZhciBERVNDUklQVE9SUyRhID0gZGVzY3JpcHRvcnM7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGQ7XG52YXIgdG9JbmRleGVkT2JqZWN0JDcgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciBvYmplY3RLZXlzJDIgPSBvYmplY3RLZXlzJDQ7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxuXG5vYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyRhICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JGIoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdCQ3KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMkMihQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuXG4gIHJldHVybiBPO1xufTtcblxudmFyIGdldEJ1aWx0SW4kNiA9IGdldEJ1aWx0SW4kOTtcbnZhciBodG1sJDEgPSBnZXRCdWlsdEluJDYoJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRkO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG52YXIgZW51bUJ1Z0tleXMkMSA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ2O1xudmFyIGh0bWwgPSBodG1sJDE7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkNDtcbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUkMSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMignSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGVtcHR5ICovXG59O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07IC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cblxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG5cbiAgcmV0dXJuIHRlbXA7XG59OyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cblxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG5cbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59OyAvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcblxuXG52YXIgYWN0aXZlWERvY3VtZW50O1xuXG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGlnbm9yZSAqL1xuICB9XG5cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKSA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG5cbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzJDEubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEUkMV1bZW51bUJ1Z0tleXMkMVtsZW5ndGhdXTtcblxuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzJDNbSUVfUFJPVE8kMV0gPSB0cnVlOyAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gYW5PYmplY3QkYShPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gbnVsbDsgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlJDEuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIGZhaWxzJGsgPSBmYWlscyR0O1xudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkayhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cbnZhciBnbG9iYWwkcyA9IGdsb2JhbCRQO1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDYgPSBpc0NhbGxhYmxlJGg7XG52YXIgdG9PYmplY3QkYiA9IHRvT2JqZWN0JGU7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkNDtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIkMSA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkkMSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3QkNiA9IGdsb2JhbCRzLk9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUkMiA9IE9iamVjdCQ2LnByb3RvdHlwZTsgLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIkMSA/IE9iamVjdCQ2LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JGIoTyk7XG4gIGlmIChoYXNPd24kYShvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcblxuICBpZiAoaXNDYWxsYWJsZSQ2KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0JDYgPyBPYmplY3RQcm90b3R5cGUkMiA6IG51bGw7XG59O1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcblxudmFyIHJlZGVmaW5lJDQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW51bWVyYWJsZSkgdGFyZ2V0W2tleV0gPSB2YWx1ZTtlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzKHRhcmdldCwga2V5LCB2YWx1ZSk7XG59O1xuXG52YXIgZmFpbHMkaiA9IGZhaWxzJHQ7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRoO1xudmFyIGNyZWF0ZSRhID0gb2JqZWN0Q3JlYXRlO1xudmFyIGdldFByb3RvdHlwZU9mJDggPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciByZWRlZmluZSQzID0gcmVkZWZpbmUkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkZiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIElURVJBVE9SJDYgPSB3ZWxsS25vd25TeW1ib2wkZignaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTsgLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpOyAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcblxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IHRydWU7ZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkOChnZXRQcm90b3R5cGVPZiQ4KGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSQxID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUkMSA9PSB1bmRlZmluZWQgfHwgZmFpbHMkaihmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307IC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDZdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSQxID0ge307ZWxzZSBJdGVyYXRvclByb3RvdHlwZSQxID0gY3JlYXRlJGEoSXRlcmF0b3JQcm90b3R5cGUkMSk7IC8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcblxuaWYgKCFpc0NhbGxhYmxlJDUoSXRlcmF0b3JQcm90b3R5cGUkMVtJVEVSQVRPUiQ2XSkpIHtcbiAgcmVkZWZpbmUkMyhJdGVyYXRvclByb3RvdHlwZSQxLCBJVEVSQVRPUiQ2LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDEsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMVxufTtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCQxID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGNsYXNzb2YkYyA9IGNsYXNzb2YkZTsgLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCQxID8ge30udG9TdHJpbmcgOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mJGModGhpcykgKyAnXSc7XG59O1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGRlZmluZVByb3BlcnR5JGMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvU3RyaW5nJDYgPSBvYmplY3RUb1N0cmluZztcbnZhciB3ZWxsS25vd25TeW1ib2wkZSA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCRlKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNSA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMsIFNFVF9NRVRIT0QpIHtcbiAgaWYgKGl0KSB7XG4gICAgdmFyIHRhcmdldCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlO1xuXG4gICAgaWYgKCFoYXNPd24kOSh0YXJnZXQsIFRPX1NUUklOR19UQUckMSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5JGModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogVEFHXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoU0VUX01FVEhPRCAmJiAhVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMih0YXJnZXQsICd0b1N0cmluZycsIHRvU3RyaW5nJDYpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSQ5ID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgc2V0VG9TdHJpbmdUYWckNCA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgSXRlcmF0b3JzJDUgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlJDkoSXRlcmF0b3JQcm90b3R5cGUsIHtcbiAgICBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dClcbiAgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDQoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnMkNVtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgZ2xvYmFsJHIgPSBnbG9iYWwkUDtcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJGg7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkci5TdHJpbmc7XG52YXIgVHlwZUVycm9yJGMgPSBnbG9iYWwkci5UeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkNChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yJGMoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmckMShhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG52YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYW5PYmplY3QkOSA9IGFuT2JqZWN0JGQ7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gYVBvc3NpYmxlUHJvdG90eXBlJDE7IC8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5cbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuXG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzJGgoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdCQ5KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO2Vsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciAkJEggPSBfZXhwb3J0O1xudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWU7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMTtcbnZhciBnZXRQcm90b3R5cGVPZiQ3ID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgcmVkZWZpbmUkMiA9IHJlZGVmaW5lJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJGQgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJdGVyYXRvcnMkNCA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQxID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkZCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBkZWZpbmVJdGVyYXRvciQzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuXG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBWQUxVRVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlIEVOVFJJRVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ1XSB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZOyAvLyBmaXggbmF0aXZlXG5cbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkNyhhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG5cbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG5cblxuICAgICAgc2V0VG9TdHJpbmdUYWckMyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgSXRlcmF0b3JzJDRbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfSAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG5cblxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuXG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBjYWxsJDYobmF0aXZlSXRlcmF0b3IsIHRoaXMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuXG5cbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZSQyKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQkSCh7XG4gICAgICB0YXJnZXQ6IE5BTUUsXG4gICAgICBwcm90bzogdHJ1ZSxcbiAgICAgIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUVcbiAgICB9LCBtZXRob2RzKTtcbiAgfSAvLyBkZWZpbmUgaXRlcmF0b3JcblxuXG4gIGlmICgoRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ1XSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgcmVkZWZpbmUkMihJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkNSwgZGVmYXVsdEl0ZXJhdG9yLCB7XG4gICAgICBuYW1lOiBERUZBVUxUXG4gICAgfSk7XG4gIH1cblxuICBJdGVyYXRvcnMkNFtOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgY2hhckF0JDIgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xudmFyIHRvU3RyaW5nJDUgPSB0b1N0cmluZyQ4O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNSA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lSXRlcmF0b3IkMiA9IGRlZmluZUl0ZXJhdG9yJDM7XG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQ1ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7IC8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cbmRlZmluZUl0ZXJhdG9yJDIoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUkNSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmckNShpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7IC8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMpO1xuICB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRvbmU6IHRydWVcbiAgfTtcbiAgcG9pbnQgPSBjaGFyQXQkMihzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBwb2ludCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufSk7XG5cbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGQ7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkMztcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMiA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ4KGl0ZXJhdG9yKTtcblxuICB0cnkge1xuICAgIGlubmVyUmVzdWx0ID0gZ2V0TWV0aG9kJDEoaXRlcmF0b3IsICdyZXR1cm4nKTtcblxuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkNShpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cblxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QkOChpbm5lclJlc3VsdCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkZDtcbnZhciBpdGVyYXRvckNsb3NlJDEgPSBpdGVyYXRvckNsb3NlJDI7IC8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcblxudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmckMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCQ3KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGl0ZXJhdG9yQ2xvc2UkMShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICB9XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJGMoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkaSA9IEFycmF5LnByb3RvdHlwZTsgLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxuXG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycyQzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZSRpW0lURVJBVE9SJDRdID09PSBpdCk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkaSA9IGZhaWxzJHQ7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRoO1xudmFyIGNsYXNzb2YkYiA9IGNsYXNzb2YkZTtcbnZhciBnZXRCdWlsdEluJDUgPSBnZXRCdWlsdEluJDk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkMjtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGVtcHR5ICovXG59O1xuXG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QkMyA9IGdldEJ1aWx0SW4kNSgnUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyQyID0gdW5jdXJyeVRoaXMkZyhjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkMyhhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIGNvbnN0cnVjdCQzKG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDMoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChjbGFzc29mJGIoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjJDIoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTsgLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG5cbnZhciBpc0NvbnN0cnVjdG9yJDQgPSAhY29uc3RydWN0JDMgfHwgZmFpbHMkaShmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KSB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgfSkgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDYgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkMShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoMCwgdmFsdWUpKTtlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciBjbGFzc29mJGEgPSBjbGFzc29mJGU7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDM7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJGIoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ4ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SJDMpIHx8IGdldE1ldGhvZChpdCwgJ0BAaXRlcmF0b3InKSB8fCBJdGVyYXRvcnMkMltjbGFzc29mJGEoaXQpXTtcbn07XG5cbnZhciBnbG9iYWwkcSA9IGdsb2JhbCRQO1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ3O1xudmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRkO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDcgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xudmFyIFR5cGVFcnJvciRiID0gZ2xvYmFsJHEuVHlwZUVycm9yO1xuXG52YXIgZ2V0SXRlcmF0b3IkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kJDcoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZSQzKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0JDYoY2FsbCQ0KGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyBUeXBlRXJyb3IkYih0cnlUb1N0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuXG52YXIgZ2xvYmFsJHAgPSBnbG9iYWwkUDtcbnZhciBiaW5kJDUgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB0b09iamVjdCRhID0gdG9PYmplY3QkZTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgaXNDb25zdHJ1Y3RvciQzID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJGIgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGNyZWF0ZVByb3BlcnR5JDUgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xudmFyIGdldEl0ZXJhdG9yJDYgPSBnZXRJdGVyYXRvciQ3O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDYgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xudmFyIEFycmF5JDUgPSBnbG9iYWwkcC5BcnJheTsgLy8gYEFycmF5LmZyb21gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5cbnZhciBhcnJheUZyb20gPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZVxuLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqL1xuKSB7XG4gIHZhciBPID0gdG9PYmplY3QkYShhcnJheUxpa2UpO1xuICB2YXIgSVNfQ09OU1RSVUNUT1IgPSBpc0NvbnN0cnVjdG9yJDModGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQkNShtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDYoTyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlOyAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuXG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhKHRoaXMgPT0gQXJyYXkkNSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QkMShpdGVyYXRvck1ldGhvZCkpKSB7XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvciQ2KE8sIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKCkgOiBbXTtcblxuICAgIGZvciAoOyAhKHN0ZXAgPSBjYWxsJDMobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgY3JlYXRlUHJvcGVydHkkNShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJGIoTyk7XG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcyhsZW5ndGgpIDogQXJyYXkkNShsZW5ndGgpO1xuXG4gICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICBjcmVhdGVQcm9wZXJ0eSQ1KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGEgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJGEoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6ICEhY2FsbGVkKytcbiAgICAgIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG5cbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyAyO1xuICB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIC8qIGVtcHR5ICovXG59XG5cbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcblxuICAgIG9iamVjdFtJVEVSQVRPUiQyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgJCRHID0gX2V4cG9ydDtcbnZhciBmcm9tJDYgPSBhcnJheUZyb207XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7IC8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuXG4kJEcoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTlxufSwge1xuICBmcm9tOiBmcm9tJDZcbn0pO1xuXG52YXIgcGF0aCR0ID0gcGF0aCR5O1xudmFyIGZyb20kNSA9IHBhdGgkdC5BcnJheS5mcm9tO1xuXG52YXIgcGFyZW50JDE4ID0gZnJvbSQ1O1xudmFyIGZyb20kNCA9IHBhcmVudCQxODtcblxudmFyIGZyb20kMyA9IGZyb20kNDtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ2ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbm9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGRlZmluZUl0ZXJhdG9yJDM7XG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkNCA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7IC8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxuXG5kZWZpbmVJdGVyYXRvciQxKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdCQ2KGl0ZXJhdGVkKSxcbiAgICAvLyB0YXJnZXRcbiAgICBpbmRleDogMCxcbiAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAvLyBraW5kXG5cbiAgfSk7IC8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG5cbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4ge1xuICAgIHZhbHVlOiBpbmRleCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHtcbiAgICB2YWx1ZTogdGFyZ2V0W2luZGV4XSxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG59LCAndmFsdWVzJyk7IC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3RcblxuSXRlcmF0b3JzJDEuQXJndW1lbnRzID0gSXRlcmF0b3JzJDEuQXJyYXk7IC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDUgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kXzEgPSBnZXRJdGVyYXRvck1ldGhvZCQ1O1xuXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5cbnZhciBkb21JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG52YXIgRE9NSXRlcmFibGVzJDQgPSBkb21JdGVyYWJsZXM7XG52YXIgZ2xvYmFsJG8gPSBnbG9iYWwkUDtcbnZhciBjbGFzc29mJDkgPSBjbGFzc29mJGU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBJdGVyYXRvcnMgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJDkgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDkoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMkNCkge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbCRvW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBjbGFzc29mJDkoQ29sbGVjdGlvblByb3RvdHlwZSkgIT09IFRPX1NUUklOR19UQUcpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICB9XG5cbiAgSXRlcmF0b3JzW0NPTExFQ1RJT05fTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cbnZhciBwYXJlbnQkMTcgPSBnZXRJdGVyYXRvck1ldGhvZF8xO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDQgPSBwYXJlbnQkMTc7XG5cbnZhciBwYXJlbnQkMTYgPSBnZXRJdGVyYXRvck1ldGhvZCQ0O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDMgPSBwYXJlbnQkMTY7XG5cbnZhciBwYXJlbnQkMTUgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDIgPSBwYXJlbnQkMTU7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQxID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcblxudmFyIGNsYXNzb2YkOCA9IGNsYXNzb2ZSYXckMTsgLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5cbnZhciBpc0FycmF5JGQgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkOChhcmd1bWVudCkgPT0gJ0FycmF5Jztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xudmFyIGhpZGRlbktleXMkMiA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcblxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyQyKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSB7fTtcblxudmFyIGdsb2JhbCRuID0gZ2xvYmFsJFA7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDMgPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSRhID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBjcmVhdGVQcm9wZXJ0eSQ0ID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBBcnJheSQ0ID0gZ2xvYmFsJG4uQXJyYXk7XG52YXIgbWF4JDIgPSBNYXRoLm1heDtcblxudmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkYShPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgkMyhzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQzKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkkNChtYXgkMihmaW4gLSBrLCAwKSk7XG5cbiAgZm9yICh2YXIgbiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eSQ0KHJlc3VsdCwgbiwgT1trXSk7XG5cbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXG52YXIgY2xhc3NvZiQ3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciBhcnJheVNsaWNlJDMgPSBhcnJheVNsaWNlU2ltcGxlO1xudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyQxKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXJyYXlTbGljZSQzKHdpbmRvd05hbWVzKTtcbiAgfVxufTsgLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xuXG5cbm9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgY2xhc3NvZiQ3KGl0KSA9PSAnV2luZG93JyA/IGdldFdpbmRvd05hbWVzKGl0KSA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEodG9JbmRleGVkT2JqZWN0JDUoaXQpKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2xXcmFwcGVkID0ge307XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbCRqO1xud2VsbEtub3duU3ltYm9sV3JhcHBlZC5mID0gd2VsbEtub3duU3ltYm9sJDg7XG5cbnZhciBwYXRoJHMgPSBwYXRoJHk7XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUkMSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG52YXIgZGVmaW5lUHJvcGVydHkkYiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkbCA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoJHMuU3ltYm9sIHx8IChwYXRoJHMuU3ltYm9sID0ge30pO1xuICBpZiAoIWhhc093biQ4KFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5JGIoU3ltYm9sLCBOQU1FLCB7XG4gICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUkMS5mKE5BTUUpXG4gIH0pO1xufTtcblxudmFyIGdsb2JhbCRtID0gZ2xvYmFsJFA7XG52YXIgaXNBcnJheSRjID0gaXNBcnJheSRkO1xudmFyIGlzQ29uc3RydWN0b3IkMiA9IGlzQ29uc3RydWN0b3IkNDtcbnZhciBpc09iamVjdCRjID0gaXNPYmplY3QkajtcbnZhciB3ZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCQ3KCdzcGVjaWVzJyk7XG52YXIgQXJyYXkkMyA9IGdsb2JhbCRtLkFycmF5OyAvLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxuXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gIHZhciBDO1xuXG4gIGlmIChpc0FycmF5JGMob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjsgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblxuICAgIGlmIChpc0NvbnN0cnVjdG9yJDIoQykgJiYgKEMgPT09IEFycmF5JDMgfHwgaXNBcnJheSRjKEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7ZWxzZSBpZiAoaXNPYmplY3QkYyhDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFUyQzXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSQzIDogQztcbn07XG5cbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDE7IC8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcblxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQ0ID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuXG52YXIgYmluZCQ0ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIHRvT2JqZWN0JDkgPSB0b09iamVjdCRlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDkgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQzID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7XG52YXIgcHVzaCQ0ID0gdW5jdXJyeVRoaXMkZihbXS5wdXNoKTsgLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QkOSgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0JDEoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kJDQoY2FsbGJhY2tmbiwgdGhhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDkoc2VsZik7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlJDM7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcblxuICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG5cbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIC8vIHNvbWVcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAvLyBmaW5kXG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgLy8gZmluZEluZGV4XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwdXNoJDQodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgLy8gZXZlcnlcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHB1c2gkNCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kJDMoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kJDMoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kJDMoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kJDMoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kJDMoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kJDMoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kJDMoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kJDMoNylcbn07XG5cbnZhciAkJEYgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRsID0gZ2xvYmFsJFA7XG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGFwcGx5JDQgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBERVNDUklQVE9SUyQ5ID0gZGVzY3JpcHRvcnM7XG52YXIgTkFUSVZFX1NZTUJPTCA9IG5hdGl2ZVN5bWJvbDtcbnZhciBmYWlscyRoID0gZmFpbHMkdDtcbnZhciBoYXNPd24kNyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNBcnJheSRiID0gaXNBcnJheSRkO1xudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkaDtcbnZhciBpc09iamVjdCRiID0gaXNPYmplY3QkajtcbnZhciBpc1Byb3RvdHlwZU9mJGsgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMztcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkZDtcbnZhciB0b09iamVjdCQ4ID0gdG9PYmplY3QkZTtcbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgJHRvU3RyaW5nID0gdG9TdHJpbmckODtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSBvYmplY3RDcmVhdGU7XG52YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQ0O1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2UkNTtcbnZhciByZWRlZmluZSQxID0gcmVkZWZpbmUkNDtcbnZhciBzaGFyZWQgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQ0O1xudmFyIGhpZGRlbktleXMkMSA9IGhpZGRlbktleXMkNjtcbnZhciB1aWQkMSA9IHVpZCQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGsgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDtcbnZhciBzZXRUb1N0cmluZ1RhZyQyID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xudmFyICRmb3JFYWNoJDEgPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJDYoJ3RvUHJpbWl0aXZlJyk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLmdldHRlckZvcihTWU1CT0wpO1xudmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgJFN5bWJvbCA9IGdsb2JhbCRsLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sICYmICRTeW1ib2xbUFJPVE9UWVBFXTtcbnZhciBUeXBlRXJyb3IkYSA9IGdsb2JhbCRsLlR5cGVFcnJvcjtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsJGwuUU9iamVjdDtcbnZhciAkc3RyaW5naWZ5JDEgPSBnZXRCdWlsdEluJDQoJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMi5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgcHVzaCQzID0gdW5jdXJyeVRoaXMkZShbXS5wdXNoKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTsgLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG5cbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDsgLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG5cbnZhciBzZXRTeW1ib2xEZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkOSAmJiBmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7XG4gICAgICAgIHZhbHVlOiA3XG4gICAgICB9KS5hO1xuICAgIH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPYmplY3RQcm90b3R5cGUkMSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlJDFbUF07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuXG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSQxKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlJDEsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwJDEgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKFN5bWJvbFByb3RvdHlwZSk7XG4gIHNldEludGVybmFsU3RhdGUkMyhzeW1ib2wsIHtcbiAgICB0eXBlOiBTWU1CT0wsXG4gICAgdGFnOiB0YWcsXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gIH0pO1xuICBpZiAoIURFU0NSSVBUT1JTJDkpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSQxKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0JDUoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdCQ1KEF0dHJpYnV0ZXMpO1xuXG4gIGlmIChoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFBdHRyaWJ1dGVzLmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzT3duJDcoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc093biQ3KE8sIEhJRERFTikgJiYgT1tISURERU5dW2tleV0pIE9bSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBBdHRyaWJ1dGVzID0gbmF0aXZlT2JqZWN0Q3JlYXRlKEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGZhbHNlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldFN5bWJvbERlc2NyaXB0b3IoTywga2V5LCBBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JDUoTyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gdG9JbmRleGVkT2JqZWN0JDQoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyQxKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2gkMShrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFERVNDUklQVE9SUyQ5IHx8IGNhbGwkMigkcHJvcGVydHlJc0VudW1lcmFibGUkMSwgcHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUkMSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIFAgPSB0b1Byb3BlcnR5S2V5KFYpO1xuICB2YXIgZW51bWVyYWJsZSA9IGNhbGwkMihuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSwgdGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUkMSAmJiBoYXNPd24kNyhBbGxTeW1ib2xzLCBQKSAmJiAhaGFzT3duJDcoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093biQ3KHRoaXMsIFApIHx8ICFoYXNPd24kNyhBbGxTeW1ib2xzLCBQKSB8fCBoYXNPd24kNyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXSA/IGVudW1lcmFibGUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QkNChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlJDEgJiYgaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duJDcoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKGl0LCBrZXkpO1xuXG4gIGlmIChkZXNjcmlwdG9yICYmIGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXNPd24kNyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0JDQoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoJDEobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhc093biQ3KGhpZGRlbktleXMkMSwga2V5KSkgcHVzaCQzKHJlc3VsdCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhPKSB7XG4gIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlJDE7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QkNChPKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgJGZvckVhY2gkMShuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXNPd24kNyhPYmplY3RQcm90b3R5cGUkMSwga2V5KSkpIHtcbiAgICAgIHB1c2gkMyhyZXN1bHQsIEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07IC8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuXG5cbmlmICghTkFUSVZFX1NZTUJPTCkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmIChpc1Byb3RvdHlwZU9mJGsoU3ltYm9sUHJvdG90eXBlLCB0aGlzKSkgdGhyb3cgVHlwZUVycm9yJGEoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogJHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZCQxKGRlc2NyaXB0aW9uKTtcblxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUkMSkgY2FsbCQyKHNldHRlciwgT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhc093biQ3KHRoaXMsIEhJRERFTikgJiYgaGFzT3duJDcodGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzY3JpcHRvcih0aGlzLCB0YWcsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBpZiAoREVTQ1JJUFRPUlMkOSAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSQxLCB0YWcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXAkMSh0YWcsIGRlc2NyaXB0aW9uKTtcbiAgfTtcblxuICBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sW1BST1RPVFlQRV07XG4gIHJlZGVmaW5lJDEoU3ltYm9sUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuICByZWRlZmluZSQxKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAkMSh1aWQkMShkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG4gIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGUkMTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUkMS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDIuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMi5mID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCQxKHdlbGxLbm93blN5bWJvbCQ2KG5hbWUpLCBuYW1lKTtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMkOSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KFN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuJCRGKHtcbiAgZ2xvYmFsOiB0cnVlLFxuICB3cmFwOiB0cnVlLFxuICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLFxuICBzaGFtOiAhTkFUSVZFX1NZTUJPTFxufSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuJGZvckVhY2gkMShvYmplY3RLZXlzJDEoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sJGsobmFtZSk7XG59KTtcbiQkRih7XG4gIHRhcmdldDogU1lNQk9MLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MXG59LCB7XG4gIC8vIGBTeW1ib2wuZm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9ICR0b1N0cmluZyhrZXkpO1xuICAgIGlmIChoYXNPd24kNyhTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKHN0cmluZyk7XG4gICAgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddID0gc3ltYm9sO1xuICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltYm9sXSA9IHN0cmluZztcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9LFxuICAvLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvciRhKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhc093biQ3KFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkge1xuICAgIFVTRV9TRVRURVIgPSB0cnVlO1xuICB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHtcbiAgICBVU0VfU0VUVEVSID0gZmFsc2U7XG4gIH1cbn0pO1xuJCRGKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCxcbiAgc2hhbTogIURFU0NSSVBUT1JTJDlcbn0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG4kJEYoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MXG59LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlzeW1ib2xzXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7IC8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcblxuJCRGKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mKDEpO1xuICB9KVxufSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mKHRvT2JqZWN0JDgoaXQpKTtcbiAgfVxufSk7IC8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kIGJlaGF2aW9yIHdpdGggc3ltYm9sc1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuXG5pZiAoJHN0cmluZ2lmeSQxKSB7XG4gIHZhciBGT1JDRURfSlNPTl9TVFJJTkdJRlkgPSAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbCgpOyAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuXG4gICAgcmV0dXJuICRzdHJpbmdpZnkkMShbc3ltYm9sXSkgIT0gJ1tudWxsXScgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gICAgfHwgJHN0cmluZ2lmeSQxKHtcbiAgICAgIGE6IHN5bWJvbFxuICAgIH0pICE9ICd7fScgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICB8fCAkc3RyaW5naWZ5JDEoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG4gIH0pO1xuICAkJEYoe1xuICAgIHRhcmdldDogJ0pTT04nLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBGT1JDRURfSlNPTl9TVFJJTkdJRllcbiAgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlJDIoYXJndW1lbnRzKTtcbiAgICAgIHZhciAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgIGlmICghaXNPYmplY3QkYihyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuXG4gICAgICBpZiAoIWlzQXJyYXkkYihyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGUkMigkcmVwbGFjZXIpKSB2YWx1ZSA9IGNhbGwkMigkcmVwbGFjZXIsIHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICAgIHJldHVybiBhcHBseSQ0KCRzdHJpbmdpZnkkMSwgbnVsbCwgYXJncyk7XG4gICAgfVxuICB9KTtcbn0gLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcblxuXG5pZiAoIVN5bWJvbFByb3RvdHlwZVtUT19QUklNSVRJVkVdKSB7XG4gIHZhciB2YWx1ZU9mID0gU3ltYm9sUHJvdG90eXBlLnZhbHVlT2Y7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgLmxlbmd0aFxuXG4gIHJlZGVmaW5lJDEoU3ltYm9sUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGZ1bmN0aW9uIChoaW50KSB7XG4gICAgLy8gVE9ETzogaW1wcm92ZSBoaW50IGxvZ2ljXG4gICAgcmV0dXJuIGNhbGwkMih2YWx1ZU9mLCB0aGlzKTtcbiAgfSk7XG59IC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcblxuXG5zZXRUb1N0cmluZ1RhZyQyKCRTeW1ib2wsIFNZTUJPTCk7XG5oaWRkZW5LZXlzJDFbSElEREVOXSA9IHRydWU7XG5cbnZhciBwYXRoJHIgPSBwYXRoJHk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIgPSBwYXRoJHIuT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIHBhcmVudCQxNCA9IGdldE93blByb3BlcnR5U3ltYm9scyQyO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyQxID0gcGFyZW50JDE0O1xuXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDE7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciAkJEUgPSBfZXhwb3J0O1xudmFyIGZhaWxzJGcgPSBmYWlscyR0O1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgREVTQ1JJUFRPUlMkOCA9IGRlc2NyaXB0b3JzO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkNCA9IGZhaWxzJGcoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7XG59KTtcbnZhciBGT1JDRUQkNiA9ICFERVNDUklQVE9SUyQ4IHx8IEZBSUxTX09OX1BSSU1JVElWRVMkNDsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5cbiQkRSh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRk9SQ0VEJDYsXG4gIHNoYW06ICFERVNDUklQVE9SUyQ4XG59LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdCQzKGl0KSwga2V5KTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJHEgPSBwYXRoJHk7XG52YXIgT2JqZWN0JDUgPSBwYXRoJHEuT2JqZWN0O1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDUgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNi5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdCQ1LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG5cbmlmIChPYmplY3QkNS5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSkgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDUuc2hhbSA9IHRydWU7XG5cbnZhciBwYXJlbnQkMTMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNi5leHBvcnRzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0ID0gcGFyZW50JDEzO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNDtcblxudmFyIGdldEJ1aWx0SW4kMyA9IGdldEJ1aWx0SW4kOTtcbnZhciB1bmN1cnJ5VGhpcyRkID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkZDtcbnZhciBjb25jYXQkNCA9IHVuY3VycnlUaGlzJGQoW10uY29uY2F0KTsgLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xuXG52YXIgb3duS2V5cyRhID0gZ2V0QnVpbHRJbiQzKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQxLmYoYW5PYmplY3QkNChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkNChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgJCREID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgb3duS2V5cyQ5ID0gb3duS2V5cyRhO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgY3JlYXRlUHJvcGVydHkkMyA9IGNyZWF0ZVByb3BlcnR5JDY7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG5cbiQkRCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIHNoYW06ICFERVNDUklQVE9SUyQ3XG59LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMihvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMS5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyQ5KE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBrZXksIGRlc2NyaXB0b3I7XG5cbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5JDMocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRwID0gcGF0aCR5O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMiA9IHBhdGgkcC5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblxudmFyIHBhcmVudCQxMiA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDEgPSBwYXJlbnQkMTI7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQxO1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyQ0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyICQkQyA9IF9leHBvcnQ7XG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnRpZXMkMyA9IG9iamVjdERlZmluZVByb3BlcnRpZXMuZjsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5cbiQkQyh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgIT09IGRlZmluZVByb3BlcnRpZXMkMyxcbiAgc2hhbTogIURFU0NSSVBUT1JTJDZcbn0sIHtcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllcyQzXG59KTtcblxudmFyIHBhdGgkbyA9IHBhdGgkeTtcbnZhciBPYmplY3QkNCA9IHBhdGgkby5PYmplY3Q7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDIgPSBkZWZpbmVQcm9wZXJ0aWVzJDQuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoVCwgRCkge1xuICByZXR1cm4gT2JqZWN0JDQuZGVmaW5lUHJvcGVydGllcyhULCBEKTtcbn07XG5cbmlmIChPYmplY3QkNC5kZWZpbmVQcm9wZXJ0aWVzLnNoYW0pIGRlZmluZVByb3BlcnRpZXMkMi5zaGFtID0gdHJ1ZTtcblxudmFyIHBhcmVudCQxMSA9IGRlZmluZVByb3BlcnRpZXMkNC5leHBvcnRzO1xudmFyIGRlZmluZVByb3BlcnRpZXMkMSA9IHBhcmVudCQxMTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBkZWZpbmVQcm9wZXJ0aWVzJDE7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSRhID0ge2V4cG9ydHM6IHt9fTtcblxudmFyICQkQiA9IF9leHBvcnQ7XG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5JDkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mOyAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxuJCRCKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IGRlZmluZVByb3BlcnR5JDksXG4gIHNoYW06ICFERVNDUklQVE9SUyQ1XG59LCB7XG4gIGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eSQ5XG59KTtcblxudmFyIHBhdGgkbiA9IHBhdGgkeTtcbnZhciBPYmplY3QkMyA9IHBhdGgkbi5PYmplY3Q7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ4ID0gZGVmaW5lUHJvcGVydHkkYS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gT2JqZWN0JDMuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG5pZiAoT2JqZWN0JDMuZGVmaW5lUHJvcGVydHkuc2hhbSkgZGVmaW5lUHJvcGVydHkkOC5zaGFtID0gdHJ1ZTtcblxudmFyIHBhcmVudCQxMCA9IGRlZmluZVByb3BlcnR5JGEuZXhwb3J0cztcbnZhciBkZWZpbmVQcm9wZXJ0eSQ3ID0gcGFyZW50JDEwO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkNiA9IGRlZmluZVByb3BlcnR5JDc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbnZhciBwYXJlbnQkJCA9IGRlZmluZVByb3BlcnR5JDc7XG52YXIgZGVmaW5lUHJvcGVydHkkNSA9IHBhcmVudCQkO1xuXG52YXIgcGFyZW50JF8gPSBkZWZpbmVQcm9wZXJ0eSQ1O1xudmFyIGRlZmluZVByb3BlcnR5JDQgPSBwYXJlbnQkXztcblxudmFyIGRlZmluZVByb3BlcnR5JDMgPSBkZWZpbmVQcm9wZXJ0eSQ0O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIGRlZmluZVByb3BlcnR5JDModGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuXG4gIGRlZmluZVByb3BlcnR5JDMoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG5cbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMyhvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciAkJEEgPSBfZXhwb3J0O1xudmFyIGlzQXJyYXkkYSA9IGlzQXJyYXkkZDsgLy8gYEFycmF5LmlzQXJyYXlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5pc2FycmF5XG5cbiQkQSh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBpc0FycmF5OiBpc0FycmF5JGFcbn0pO1xuXG52YXIgcGF0aCRtID0gcGF0aCR5O1xudmFyIGlzQXJyYXkkOSA9IHBhdGgkbS5BcnJheS5pc0FycmF5O1xuXG52YXIgcGFyZW50JFogPSBpc0FycmF5JDk7XG52YXIgaXNBcnJheSQ4ID0gcGFyZW50JFo7XG5cbnZhciBwYXJlbnQkWSA9IGlzQXJyYXkkODtcbnZhciBpc0FycmF5JDcgPSBwYXJlbnQkWTtcblxudmFyIHBhcmVudCRYID0gaXNBcnJheSQ3O1xudmFyIGlzQXJyYXkkNiA9IHBhcmVudCRYO1xuXG52YXIgaXNBcnJheSQ1ID0gaXNBcnJheSQ2O1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChpc0FycmF5JDUoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxudmFyIGZhaWxzJGYgPSBmYWlscyR0O1xudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVjhfVkVSU0lPTiQxID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCQ1KCdzcGVjaWVzJyk7XG5cbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDUgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcbiAgcmV0dXJuIFY4X1ZFUlNJT04kMSA+PSA1MSB8fCAhZmFpbHMkZihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yW1NQRUNJRVMkMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb286IDFcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG5cbnZhciAkJHogPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRrID0gZ2xvYmFsJFA7XG52YXIgZmFpbHMkZSA9IGZhaWxzJHQ7XG52YXIgaXNBcnJheSQ0ID0gaXNBcnJheSRkO1xudmFyIGlzT2JqZWN0JGEgPSBpc09iamVjdCRqO1xudmFyIHRvT2JqZWN0JDcgPSB0b09iamVjdCRlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDggPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGNyZWF0ZVByb3BlcnR5JDIgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQyID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ0ID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCQ0KCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xudmFyIFR5cGVFcnJvciQ5ID0gZ2xvYmFsJGsuVHlwZUVycm9yOyAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNCgnY29uY2F0Jyk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0JGEoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkkNChPKTtcbn07XG5cbnZhciBGT1JDRUQkNSA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7IC8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG5cbiQkeih7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogRk9SQ0VEJDVcbn0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ3KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDIoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcblxuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG5cbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkOChFKTtcbiAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSJDEpIHRocm93IFR5cGVFcnJvciQ5KE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5JDIoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSJDEpIHRocm93IFR5cGVFcnJvciQ5KE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5JDIoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGogPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuYXN5bmNpdGVyYXRvclxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkaignYXN5bmNJdGVyYXRvcicpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGkgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5oYXNJbnN0YW5jZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmhhc2luc3RhbmNlXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRpKCdoYXNJbnN0YW5jZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGggPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pc2NvbmNhdHNwcmVhZGFibGVcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGgoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGcgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRnKCdpdGVyYXRvcicpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGYgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRmKCdtYXRjaCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGUgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tYXRjaEFsbGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoYWxsXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRlKCdtYXRjaEFsbCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGQgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5yZXBsYWNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucmVwbGFjZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkZCgncmVwbGFjZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGMgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5zZWFyY2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zZWFyY2hcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGMoJ3NlYXJjaCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGIgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5zcGVjaWVzYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuc3BlY2llc1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkYignc3BlY2llcycpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGEgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5zcGxpdGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNwbGl0XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRhKCdzcGxpdCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDkgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC50b1ByaW1pdGl2ZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnRvcHJpbWl0aXZlXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQ5KCd0b1ByaW1pdGl2ZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDggPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC50b1N0cmluZ1RhZ2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnRvc3RyaW5ndGFnXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQ4KCd0b1N0cmluZ1RhZycpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDcgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC51bnNjb3BhYmxlc2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnVuc2NvcGFibGVzXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQ3KCd1bnNjb3BhYmxlcycpO1xuXG52YXIgZ2xvYmFsJGogPSBnbG9iYWwkUDtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckNTsgLy8gSlNPTltAQHRvU3RyaW5nVGFnXSBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLUBAdG9zdHJpbmd0YWdcblxuc2V0VG9TdHJpbmdUYWckMShnbG9iYWwkai5KU09OLCAnSlNPTicsIHRydWUpO1xuXG52YXIgcGF0aCRsID0gcGF0aCR5O1xudmFyIHN5bWJvbCQ1ID0gcGF0aCRsLlN5bWJvbDtcblxudmFyIHBhcmVudCRXID0gc3ltYm9sJDU7XG52YXIgc3ltYm9sJDQgPSBwYXJlbnQkVztcblxudmFyIHBhcmVudCRWID0gc3ltYm9sJDQ7XG52YXIgc3ltYm9sJDMgPSBwYXJlbnQkVjtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ2ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuYXN5bmNEaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdXNpbmctc3RhdGVtZW50XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQ2KCdhc3luY0Rpc3Bvc2UnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ1ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuZGlzcG9zZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXVzaW5nLXN0YXRlbWVudFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNSgnZGlzcG9zZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDQgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tYXRjaGVyYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcGF0dGVybi1tYXRjaGluZ1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNCgnbWF0Y2hlcicpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDMgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5tZXRhZGF0YWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWRlY29yYXRvcnNcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDMoJ21ldGFkYXRhJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMiA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm9ic2VydmFibGVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQyKCdvYnNlcnZhYmxlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnBhdHRlcm5NYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDEoJ3BhdHRlcm5NYXRjaCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3JlcGxhY2VBbGwnKTtcblxudmFyIHBhcmVudCRVID0gc3ltYm9sJDM7IC8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuXG52YXIgc3ltYm9sJDIgPSBwYXJlbnQkVTtcblxudmFyIHN5bWJvbCQxID0gc3ltYm9sJDI7XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIHN5bWJvbCQxICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEoYXJyKSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxudmFyICQkeSA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGkgPSBnbG9iYWwkUDtcbnZhciBpc0FycmF5JDMgPSBpc0FycmF5JGQ7XG52YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIGlzT2JqZWN0JDkgPSBpc09iamVjdCRqO1xudmFyIHRvQWJzb2x1dGVJbmRleCQyID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNyA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciBjcmVhdGVQcm9wZXJ0eSQxID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMyA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciB1biRTbGljZSA9IGFycmF5U2xpY2UkNTtcbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDMgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDMoJ3NsaWNlJyk7XG52YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sJDMoJ3NwZWNpZXMnKTtcbnZhciBBcnJheSQyID0gZ2xvYmFsJGkuQXJyYXk7XG52YXIgbWF4JDEgPSBNYXRoLm1heDsgLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zbGljZVxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuXG4kJHkoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUJDNcbn0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQxKHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ3KE8pO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDIoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQyKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpOyAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcblxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuXG4gICAgaWYgKGlzQXJyYXkkMyhPKSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yOyAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuXG4gICAgICBpZiAoaXNDb25zdHJ1Y3RvciQxKENvbnN0cnVjdG9yKSAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5JDIgfHwgaXNBcnJheSQzKENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdCQ5KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVMkMV07XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkkMiB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1biRTbGljZShPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/IEFycmF5JDIgOiBDb25zdHJ1Y3RvcikobWF4JDEoZmluIC0gaywgMCkpO1xuXG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5JDEocmVzdWx0LCBuLCBPW2tdKTtcblxuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGogPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBzbGljZSQ2ID0gZW50cnlWaXJ0dWFsJGooJ0FycmF5Jykuc2xpY2U7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGogPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRnID0gc2xpY2UkNjtcbnZhciBBcnJheVByb3RvdHlwZSRoID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc2xpY2UkNSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc2xpY2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkaCB8fCBpc1Byb3RvdHlwZU9mJGooQXJyYXlQcm90b3R5cGUkaCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkaC5zbGljZSA/IG1ldGhvZCRnIDogb3duO1xufTtcblxudmFyIHBhcmVudCRUID0gc2xpY2UkNTtcbnZhciBzbGljZSQ0ID0gcGFyZW50JFQ7XG5cbnZhciBwYXJlbnQkUyA9IHNsaWNlJDQ7XG52YXIgc2xpY2UkMyA9IHBhcmVudCRTO1xuXG52YXIgcGFyZW50JFIgPSBzbGljZSQzO1xudmFyIHNsaWNlJDIgPSBwYXJlbnQkUjtcblxudmFyIHNsaWNlJDEgPSBzbGljZSQyO1xuXG52YXIgcGFyZW50JFEgPSBmcm9tJDQ7XG52YXIgZnJvbSQyID0gcGFyZW50JFE7XG5cbnZhciBwYXJlbnQkUCA9IGZyb20kMjtcbnZhciBmcm9tJDEgPSBwYXJlbnQkUDtcblxudmFyIGZyb20gPSBmcm9tJDE7XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOShvLCBtaW5MZW4pIHtcbiAgdmFyIF9jb250ZXh0O1xuXG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ5KG8sIG1pbkxlbik7XG5cbiAgdmFyIG4gPSBzbGljZSQxKF9jb250ZXh0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0LCA4LCAtMSk7XG5cbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG52YXIgaXRlcmF0b3IkNSA9IFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZignaXRlcmF0b3InKTtcblxudmFyIHBhcmVudCRPID0gaXRlcmF0b3IkNTtcbnZhciBpdGVyYXRvciQ0ID0gcGFyZW50JE87XG5cbnZhciBwYXJlbnQkTiA9IGl0ZXJhdG9yJDQ7XG52YXIgaXRlcmF0b3IkMyA9IHBhcmVudCROO1xuXG52YXIgcGFyZW50JE0gPSBpdGVyYXRvciQzO1xudmFyIGl0ZXJhdG9yJDIgPSBwYXJlbnQkTTtcblxudmFyIGl0ZXJhdG9yJDEgPSBpdGVyYXRvciQyO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHN5bWJvbCQxICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIGl0ZXJhdG9yJDEgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHN5bWJvbCQxICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gc3ltYm9sJDEgJiYgb2JqICE9PSBzeW1ib2wkMS5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChpc0FycmF5JDUoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2Ygc3ltYm9sJDEgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShpdGVyKSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBmcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxudmFyIHN5bWJvbCA9IHN5bWJvbCQ0O1xuXG52YXIgZW50cnlWaXJ0dWFsJGkgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBjb25jYXQkMyA9IGVudHJ5VmlydHVhbCRpKCdBcnJheScpLmNvbmNhdDtcblxudmFyIGlzUHJvdG90eXBlT2YkaSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGYgPSBjb25jYXQkMztcbnZhciBBcnJheVByb3RvdHlwZSRnID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgY29uY2F0JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmNvbmNhdDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRnIHx8IGlzUHJvdG90eXBlT2YkaShBcnJheVByb3RvdHlwZSRnLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRnLmNvbmNhdCA/IG1ldGhvZCRmIDogb3duO1xufTtcblxudmFyIHBhcmVudCRMID0gY29uY2F0JDI7XG52YXIgY29uY2F0JDEgPSBwYXJlbnQkTDtcblxudmFyIGNvbmNhdCA9IGNvbmNhdCQxO1xuXG52YXIgc2xpY2UgPSBzbGljZSQ0O1xuXG52YXIgJCR4ID0gX2V4cG9ydDtcbnZhciBvd25LZXlzJDggPSBvd25LZXlzJGE7IC8vIGBSZWZsZWN0Lm93bktleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0Lm93bmtleXNcblxuJCR4KHtcbiAgdGFyZ2V0OiAnUmVmbGVjdCcsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgb3duS2V5czogb3duS2V5cyQ4XG59KTtcblxudmFyIHBhdGgkayA9IHBhdGgkeTtcbnZhciBvd25LZXlzJDcgPSBwYXRoJGsuUmVmbGVjdC5vd25LZXlzO1xuXG52YXIgcGFyZW50JEsgPSBvd25LZXlzJDc7XG52YXIgb3duS2V5cyQ2ID0gcGFyZW50JEs7XG5cbnZhciBvd25LZXlzJDUgPSBvd25LZXlzJDY7XG5cbnZhciBpc0FycmF5JDIgPSBpc0FycmF5JDg7XG5cbnZhciAkJHcgPSBfZXhwb3J0O1xudmFyICRtYXAgPSBhcnJheUl0ZXJhdGlvbi5tYXA7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQyID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMignbWFwJyk7IC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblxuJCR3KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQyXG59LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkaCA9IGVudHJ5VmlydHVhbCRsO1xudmFyIG1hcCQ2ID0gZW50cnlWaXJ0dWFsJGgoJ0FycmF5JykubWFwO1xuXG52YXIgaXNQcm90b3R5cGVPZiRoID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkZSA9IG1hcCQ2O1xudmFyIEFycmF5UHJvdG90eXBlJGYgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBtYXAkNSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQubWFwO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGYgfHwgaXNQcm90b3R5cGVPZiRoKEFycmF5UHJvdG90eXBlJGYsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGYubWFwID8gbWV0aG9kJGUgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEogPSBtYXAkNTtcbnZhciBtYXAkNCA9IHBhcmVudCRKO1xuXG52YXIgbWFwJDMgPSBtYXAkNDtcblxudmFyICQkdiA9IF9leHBvcnQ7XG52YXIgdG9PYmplY3QkNiA9IHRvT2JqZWN0JGU7XG52YXIgbmF0aXZlS2V5cyA9IG9iamVjdEtleXMkNDtcbnZhciBmYWlscyRkID0gZmFpbHMkdDtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDMgPSBmYWlscyRkKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlS2V5cygxKTtcbn0pOyAvLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuXG4kJHYoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkM1xufSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QkNihpdCkpO1xuICB9XG59KTtcblxudmFyIHBhdGgkaiA9IHBhdGgkeTtcbnZhciBrZXlzJDYgPSBwYXRoJGouT2JqZWN0LmtleXM7XG5cbnZhciBwYXJlbnQkSSA9IGtleXMkNjtcbnZhciBrZXlzJDUgPSBwYXJlbnQkSTtcblxudmFyIGtleXMkNCA9IGtleXMkNTtcblxudmFyICQkdSA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkUDtcbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBEYXRlJDEgPSBnbG9iYWwkaC5EYXRlO1xudmFyIGdldFRpbWUgPSB1bmN1cnJ5VGhpcyRjKERhdGUkMS5wcm90b3R5cGUuZ2V0VGltZSk7IC8vIGBEYXRlLm5vd2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUubm93XG5cbiQkdSh7XG4gIHRhcmdldDogJ0RhdGUnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBnZXRUaW1lKG5ldyBEYXRlJDEoKSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRpID0gcGF0aCR5O1xudmFyIG5vdyQzID0gcGF0aCRpLkRhdGUubm93O1xuXG52YXIgcGFyZW50JEggPSBub3ckMztcbnZhciBub3ckMiA9IHBhcmVudCRIO1xuXG52YXIgbm93JDEgPSBub3ckMjtcblxudmFyIGZhaWxzJGMgPSBmYWlscyR0O1xuXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQ2ID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMkYyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG5cbnZhciAkZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQ1ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIFNUUklDVF9NRVRIT0QkNSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNSgnZm9yRWFjaCcpOyAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuXG52YXIgYXJyYXlGb3JFYWNoID0gIVNUUklDVF9NRVRIT0QkNSA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuLyogLCB0aGlzQXJnICovXG4pIHtcbiAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1mb3JlYWNoIC0tIHNhZmVcbn0gOiBbXS5mb3JFYWNoO1xuXG52YXIgJCR0ID0gX2V4cG9ydDtcbnZhciBmb3JFYWNoJDYgPSBhcnJheUZvckVhY2g7IC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuXG4kJHQoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gZm9yRWFjaCQ2XG59LCB7XG4gIGZvckVhY2g6IGZvckVhY2gkNlxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkZyA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGZvckVhY2gkNSA9IGVudHJ5VmlydHVhbCRnKCdBcnJheScpLmZvckVhY2g7XG5cbnZhciBwYXJlbnQkRyA9IGZvckVhY2gkNTtcbnZhciBmb3JFYWNoJDQgPSBwYXJlbnQkRztcblxudmFyIGNsYXNzb2YkNiA9IGNsYXNzb2YkZTtcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiRnID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkZCA9IGZvckVhY2gkNDtcbnZhciBBcnJheVByb3RvdHlwZSRlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIERPTUl0ZXJhYmxlcyQzID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIgZm9yRWFjaCQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5mb3JFYWNoO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGUgfHwgaXNQcm90b3R5cGVPZiRnKEFycmF5UHJvdG90eXBlJGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGUuZm9yRWFjaCB8fCBoYXNPd24kNihET01JdGVyYWJsZXMkMywgY2xhc3NvZiQ2KGl0KSkgPyBtZXRob2QkZCA6IG93bjtcbn07XG5cbnZhciBmb3JFYWNoJDIgPSBmb3JFYWNoJDM7XG5cbnZhciAkJHMgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJGIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQXJyYXkkMSA9IGlzQXJyYXkkZDtcbnZhciB1biRSZXZlcnNlID0gdW5jdXJyeVRoaXMkYihbXS5yZXZlcnNlKTtcbnZhciB0ZXN0JDEgPSBbMSwgMl07IC8vIGBBcnJheS5wcm90b3R5cGUucmV2ZXJzZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4vLyBmaXggZm9yIFNhZmFyaSAxMi4wIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4ODc5NFxuXG4kJHMoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IFN0cmluZyh0ZXN0JDEpID09PSBTdHJpbmcodGVzdCQxLnJldmVyc2UoKSlcbn0sIHtcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ24gLS0gZGlydHkgaGFja1xuICAgIGlmIChpc0FycmF5JDEodGhpcykpIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHVuJFJldmVyc2UodGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGYgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciByZXZlcnNlJDMgPSBlbnRyeVZpcnR1YWwkZignQXJyYXknKS5yZXZlcnNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiRmID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkYyA9IHJldmVyc2UkMztcbnZhciBBcnJheVByb3RvdHlwZSRkID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgcmV2ZXJzZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5yZXZlcnNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGQgfHwgaXNQcm90b3R5cGVPZiRmKEFycmF5UHJvdG90eXBlJGQsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGQucmV2ZXJzZSA/IG1ldGhvZCRjIDogb3duO1xufTtcblxudmFyIHBhcmVudCRGID0gcmV2ZXJzZSQyO1xudmFyIHJldmVyc2UkMSA9IHBhcmVudCRGO1xuXG52YXIgcmV2ZXJzZSA9IHJldmVyc2UkMTtcblxudmFyICQkciA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkUDtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNiA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgdG9PYmplY3QkNSA9IHRvT2JqZWN0JGU7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDEgPSBhcnJheVNwZWNpZXNDcmVhdGUkNDtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQxID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMSA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMSgnc3BsaWNlJyk7XG52YXIgVHlwZUVycm9yJDggPSBnbG9iYWwkZy5UeXBlRXJyb3I7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGV4Y2VlZGVkJzsgLy8gYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuXG4kJHIoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUJDFcbn0sIHtcbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50XG4gIC8qICwgLi4uaXRlbXMgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ1KHRoaXMpO1xuICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQ2KE8pO1xuICAgIHZhciBhY3R1YWxTdGFydCA9IHRvQWJzb2x1dGVJbmRleCQxKHN0YXJ0LCBsZW4pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuXG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGluc2VydENvdW50ID0gMDtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heCh0b0ludGVnZXJPckluZmluaXR5KGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAobGVuICsgaW5zZXJ0Q291bnQgLSBhY3R1YWxEZWxldGVDb3VudCA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQ4KE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQpO1xuICAgIH1cblxuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUkMShPLCBhY3R1YWxEZWxldGVDb3VudCk7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcbiAgICAgIGlmIChmcm9tIGluIE8pIGNyZWF0ZVByb3BlcnR5KEEsIGssIE9bZnJvbV0pO1xuICAgIH1cblxuICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG5cbiAgICBpZiAoaW5zZXJ0Q291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gYWN0dWFsU3RhcnQ7IGsgPCBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50O1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07ZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG5cbiAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlIE9bayAtIDFdO1xuICAgIH0gZWxzZSBpZiAoaW5zZXJ0Q291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsgPiBhY3R1YWxTdGFydDsgay0tKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudCAtIDE7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgaW5zZXJ0Q291bnQ7IGsrKykge1xuICAgICAgT1trICsgYWN0dWFsU3RhcnRdID0gYXJndW1lbnRzW2sgKyAyXTtcbiAgICB9XG5cbiAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGUgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBzcGxpY2UkNCA9IGVudHJ5VmlydHVhbCRlKCdBcnJheScpLnNwbGljZTtcblxudmFyIGlzUHJvdG90eXBlT2YkZSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGIgPSBzcGxpY2UkNDtcbnZhciBBcnJheVByb3RvdHlwZSRjID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc3BsaWNlJDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNwbGljZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRjIHx8IGlzUHJvdG90eXBlT2YkZShBcnJheVByb3RvdHlwZSRjLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRjLnNwbGljZSA/IG1ldGhvZCRiIDogb3duO1xufTtcblxudmFyIHBhcmVudCRFID0gc3BsaWNlJDM7XG52YXIgc3BsaWNlJDIgPSBwYXJlbnQkRTtcblxudmFyIHNwbGljZSQxID0gc3BsaWNlJDI7XG5cbnZhciAkJHEgPSBfZXhwb3J0O1xudmFyICRpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMuaW5jbHVkZXM7XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXG4kJHEoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlXG59LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbFxuICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTsgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXG52YXIgZW50cnlWaXJ0dWFsJGQgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBpbmNsdWRlcyQ0ID0gZW50cnlWaXJ0dWFsJGQoJ0FycmF5JykuaW5jbHVkZXM7XG5cbnZhciBpc09iamVjdCQ4ID0gaXNPYmplY3QkajtcbnZhciBjbGFzc29mJDUgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDIoJ21hdGNoJyk7IC8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG5cbnZhciBpc1JlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdCQ4KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0gkMV0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZiQ1KGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG52YXIgZ2xvYmFsJGYgPSBnbG9iYWwkUDtcbnZhciBpc1JlZ0V4cCA9IGlzUmVnZXhwO1xudmFyIFR5cGVFcnJvciQ3ID0gZ2xvYmFsJGYuVHlwZUVycm9yO1xuXG52YXIgbm90QVJlZ2V4cCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNSZWdFeHAoaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yJDcoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH1cblxuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQxKCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcblxuICB0cnkge1xuICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICB0cnkge1xuICAgICAgcmVnZXhwW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgJCRwID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBub3RBUmVnRXhwID0gbm90QVJlZ2V4cDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG52YXIgdG9TdHJpbmckNCA9IHRvU3RyaW5nJDg7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSBjb3JyZWN0SXNSZWdleHBMb2dpYztcbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMkYSgnJy5pbmRleE9mKTsgLy8gYFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG5cbiQkcCh7XG4gIHRhcmdldDogJ1N0cmluZycsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKVxufSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nXG4gIC8qICwgcG9zaXRpb24gPSAwICovXG4gICkge1xuICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKHRvU3RyaW5nJDQocmVxdWlyZU9iamVjdENvZXJjaWJsZSQxKHRoaXMpKSwgdG9TdHJpbmckNChub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGMgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBpbmNsdWRlcyQzID0gZW50cnlWaXJ0dWFsJGMoJ1N0cmluZycpLmluY2x1ZGVzO1xuXG52YXIgaXNQcm90b3R5cGVPZiRkID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBhcnJheU1ldGhvZCA9IGluY2x1ZGVzJDQ7XG52YXIgc3RyaW5nTWV0aG9kID0gaW5jbHVkZXMkMztcbnZhciBBcnJheVByb3RvdHlwZSRiID0gQXJyYXkucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG5cbnZhciBpbmNsdWRlcyQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5pbmNsdWRlcztcbiAgaWYgKGl0ID09PSBBcnJheVByb3RvdHlwZSRiIHx8IGlzUHJvdG90eXBlT2YkZChBcnJheVByb3RvdHlwZSRiLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRiLmluY2x1ZGVzKSByZXR1cm4gYXJyYXlNZXRob2Q7XG5cbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyB8fCBpdCA9PT0gU3RyaW5nUHJvdG90eXBlIHx8IGlzUHJvdG90eXBlT2YkZChTdHJpbmdQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IFN0cmluZ1Byb3RvdHlwZS5pbmNsdWRlcykge1xuICAgIHJldHVybiBzdHJpbmdNZXRob2Q7XG4gIH1cblxuICByZXR1cm4gb3duO1xufTtcblxudmFyIHBhcmVudCREID0gaW5jbHVkZXMkMjtcbnZhciBpbmNsdWRlcyQxID0gcGFyZW50JEQ7XG5cbnZhciBpbmNsdWRlcyA9IGluY2x1ZGVzJDE7XG5cbnZhciAkJG8gPSBfZXhwb3J0O1xudmFyIGZhaWxzJGIgPSBmYWlscyR0O1xudmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCRlO1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDIgPSBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlR2V0UHJvdG90eXBlT2YoMSk7XG59KTsgLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuXG4kJG8oe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkMixcbiAgc2hhbTogIUNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUlxufSwge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QkNChpdCkpO1xuICB9XG59KTtcblxudmFyIHBhdGgkaCA9IHBhdGgkeTtcbnZhciBnZXRQcm90b3R5cGVPZiQ2ID0gcGF0aCRoLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHBhcmVudCRDID0gZ2V0UHJvdG90eXBlT2YkNjtcbnZhciBnZXRQcm90b3R5cGVPZiQ1ID0gcGFyZW50JEM7XG5cbnZhciBnZXRQcm90b3R5cGVPZiQ0ID0gZ2V0UHJvdG90eXBlT2YkNTtcblxudmFyICQkbiA9IF9leHBvcnQ7XG52YXIgJGZpbHRlciA9IGFycmF5SXRlcmF0aW9uLmZpbHRlcjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdmaWx0ZXInKTsgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuXG4kJG4oe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUXG59LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkYiA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGZpbHRlciQzID0gZW50cnlWaXJ0dWFsJGIoJ0FycmF5JykuZmlsdGVyO1xuXG52YXIgaXNQcm90b3R5cGVPZiRjID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkYSA9IGZpbHRlciQzO1xudmFyIEFycmF5UHJvdG90eXBlJGEgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBmaWx0ZXIkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZmlsdGVyO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGEgfHwgaXNQcm90b3R5cGVPZiRjKEFycmF5UHJvdG90eXBlJGEsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGEuZmlsdGVyID8gbWV0aG9kJGEgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEIgPSBmaWx0ZXIkMjtcbnZhciBmaWx0ZXIkMSA9IHBhcmVudCRCO1xuXG52YXIgZmlsdGVyID0gZmlsdGVyJDE7XG5cbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkNDtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMkOSgkcHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIHB1c2gkMiA9IHVuY3VycnlUaGlzJDkoW10ucHVzaCk7IC8vIGBPYmplY3QueyBlbnRyaWVzLCB2YWx1ZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoVE9fRU5UUklFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGtleSA9IGtleXNbaSsrXTtcblxuICAgICAgaWYgKCFERVNDUklQVE9SUyQ0IHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlKE8sIGtleSkpIHtcbiAgICAgICAgcHVzaCQyKHJlc3VsdCwgVE9fRU5UUklFUyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG52YXIgb2JqZWN0VG9BcnJheSA9IHtcbiAgLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuICBlbnRyaWVzOiBjcmVhdGVNZXRob2QkMih0cnVlKSxcbiAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiAgdmFsdWVzOiBjcmVhdGVNZXRob2QkMihmYWxzZSlcbn07XG5cbnZhciAkJG0gPSBfZXhwb3J0O1xudmFyICR2YWx1ZXMgPSBvYmplY3RUb0FycmF5LnZhbHVlczsgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG5cbiQkbSh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoTykge1xuICAgIHJldHVybiAkdmFsdWVzKE8pO1xuICB9XG59KTtcblxudmFyIHBhdGgkZyA9IHBhdGgkeTtcbnBhdGgkZy5PYmplY3QudmFsdWVzO1xuXG52YXIgd2hpdGVzcGFjZXMkNCA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMicgKyAnXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciB0b1N0cmluZyQzID0gdG9TdHJpbmckODtcbnZhciB3aGl0ZXNwYWNlcyQzID0gd2hpdGVzcGFjZXMkNDtcbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyQ4KCcnLnJlcGxhY2UpO1xudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyQzICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpOyAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbnZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmckMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZSQxKHN0cmluZywgcnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxudmFyIHN0cmluZ1RyaW0gPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCQxKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kJDEoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QkMSgzKVxufTtcblxudmFyIGdsb2JhbCRlID0gZ2xvYmFsJFA7XG52YXIgZmFpbHMkYSA9IGZhaWxzJHQ7XG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9TdHJpbmckMiA9IHRvU3RyaW5nJDg7XG52YXIgdHJpbSQxID0gc3RyaW5nVHJpbS50cmltO1xudmFyIHdoaXRlc3BhY2VzJDIgPSB3aGl0ZXNwYWNlcyQ0O1xudmFyICRwYXJzZUludCQxID0gZ2xvYmFsJGUucGFyc2VJbnQ7XG52YXIgU3ltYm9sJDIgPSBnbG9iYWwkZS5TeW1ib2w7XG52YXIgSVRFUkFUT1IkMSA9IFN5bWJvbCQyICYmIFN5bWJvbCQyLml0ZXJhdG9yO1xudmFyIGhleCA9IC9eWystXT8weC9pO1xudmFyIGV4ZWMkMSA9IHVuY3VycnlUaGlzJDcoaGV4LmV4ZWMpO1xudmFyIEZPUkNFRCQ0ID0gJHBhcnNlSW50JDEod2hpdGVzcGFjZXMkMiArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCQxKHdoaXRlc3BhY2VzJDIgKyAnMHgxNicpICE9PSAyMiAvLyBNUyBFZGdlIDE4LSBicm9rZW4gd2l0aCBib3hlZCBzeW1ib2xzXG58fCBJVEVSQVRPUiQxICYmICFmYWlscyRhKGZ1bmN0aW9uICgpIHtcbiAgJHBhcnNlSW50JDEoT2JqZWN0KElURVJBVE9SJDEpKTtcbn0pOyAvLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblxudmFyIG51bWJlclBhcnNlSW50ID0gRk9SQ0VEJDQgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBTID0gdHJpbSQxKHRvU3RyaW5nJDIoc3RyaW5nKSk7XG4gIHJldHVybiAkcGFyc2VJbnQkMShTLCByYWRpeCA+Pj4gMCB8fCAoZXhlYyQxKGhleCwgUykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50JDE7XG5cbnZhciAkJGwgPSBfZXhwb3J0O1xudmFyICRwYXJzZUludCA9IG51bWJlclBhcnNlSW50OyAvLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblxuJCRsKHtcbiAgZ2xvYmFsOiB0cnVlLFxuICBmb3JjZWQ6IHBhcnNlSW50ICE9ICRwYXJzZUludFxufSwge1xuICBwYXJzZUludDogJHBhcnNlSW50XG59KTtcblxudmFyIHBhdGgkZiA9IHBhdGgkeTtcbnZhciBfcGFyc2VJbnQkMiA9IHBhdGgkZi5wYXJzZUludDtcblxudmFyIHBhcmVudCRBID0gX3BhcnNlSW50JDI7XG52YXIgX3BhcnNlSW50JDEgPSBwYXJlbnQkQTtcblxudmFyIF9wYXJzZUludCA9IF9wYXJzZUludCQxO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5kZXhvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG5cbnZhciAkJGsgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyICRJbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkNCA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciB1biRJbmRleE9mID0gdW5jdXJyeVRoaXMkNihbXS5pbmRleE9mKTtcbnZhciBORUdBVElWRV9aRVJPID0gISF1biRJbmRleE9mICYmIDEgLyB1biRJbmRleE9mKFsxXSwgMSwgLTApIDwgMDtcbnZhciBTVFJJQ1RfTUVUSE9EJDQgPSBhcnJheU1ldGhvZElzU3RyaWN0JDQoJ2luZGV4T2YnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcblxuJCRrKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBORUdBVElWRV9aRVJPIHx8ICFTVFJJQ1RfTUVUSE9EJDRcbn0sIHtcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50XG4gIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICApIHtcbiAgICB2YXIgZnJvbUluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk8gLy8gY29udmVydCAtMCB0byArMFxuICAgID8gdW4kSW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHx8IDAgOiAkSW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRhID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgaW5kZXhPZiQzID0gZW50cnlWaXJ0dWFsJGEoJ0FycmF5JykuaW5kZXhPZjtcblxudmFyIGlzUHJvdG90eXBlT2YkYiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDkgPSBpbmRleE9mJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkOSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGluZGV4T2YkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuaW5kZXhPZjtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ5IHx8IGlzUHJvdG90eXBlT2YkYihBcnJheVByb3RvdHlwZSQ5LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ5LmluZGV4T2YgPyBtZXRob2QkOSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkeiA9IGluZGV4T2YkMjtcbnZhciBpbmRleE9mJDEgPSBwYXJlbnQkejtcblxudmFyIGluZGV4T2YgPSBpbmRleE9mJDE7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgZmFpbHMkOSA9IGZhaWxzJHQ7XG52YXIgd2hpdGVzcGFjZXMkMSA9IHdoaXRlc3BhY2VzJDQ7XG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7IC8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG5cbnZhciBzdHJpbmdUcmltRm9yY2VkID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiBmYWlscyQ5KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF3aGl0ZXNwYWNlcyQxW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPT0gbm9uIHx8IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIHdoaXRlc3BhY2VzJDFbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICB9KTtcbn07XG5cbnZhciAkJGogPSBfZXhwb3J0O1xudmFyICR0cmltID0gc3RyaW5nVHJpbS50cmltO1xudmFyIGZvcmNlZFN0cmluZ1RyaW1NZXRob2QgPSBzdHJpbmdUcmltRm9yY2VkOyAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG5cbiQkaih7XG4gIHRhcmdldDogJ1N0cmluZycsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IGZvcmNlZFN0cmluZ1RyaW1NZXRob2QoJ3RyaW0nKVxufSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkOSA9IGVudHJ5VmlydHVhbCRsO1xuZW50cnlWaXJ0dWFsJDkoJ1N0cmluZycpLnRyaW07XG5cbnZhciAkJGkgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciBjcmVhdGUkOCA9IG9iamVjdENyZWF0ZTsgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5cbiQkaSh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIHNoYW06ICFERVNDUklQVE9SUyQzXG59LCB7XG4gIGNyZWF0ZTogY3JlYXRlJDhcbn0pO1xuXG52YXIgcGF0aCRlID0gcGF0aCR5O1xudmFyIE9iamVjdCQyID0gcGF0aCRlLk9iamVjdDtcblxudmFyIGNyZWF0ZSQ3ID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuIE9iamVjdCQyLmNyZWF0ZShQLCBEKTtcbn07XG5cbnZhciBwYXJlbnQkeSA9IGNyZWF0ZSQ3O1xudmFyIGNyZWF0ZSQ2ID0gcGFyZW50JHk7XG5cbnZhciBjcmVhdGUkNSA9IGNyZWF0ZSQ2O1xuXG52YXIgJCRoID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkZCA9IGdsb2JhbCRQO1xudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kOTtcbnZhciBhcHBseSQzID0gZnVuY3Rpb25BcHBseTtcbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ4ID0gZmFpbHMkdDtcbnZhciBBcnJheSQxID0gZ2xvYmFsJGQuQXJyYXk7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4kMignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMkNSgvLi8uZXhlYyk7XG52YXIgY2hhckF0JDEgPSB1bmN1cnJ5VGhpcyQ1KCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzJDUoJycuY2hhckNvZGVBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzJDUoJycucmVwbGFjZSk7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyQ1KDEuMC50b1N0cmluZyk7XG52YXIgdGVzdGVyID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgbG93ID0gL15bXFx1RDgwMC1cXHVEQkZGXSQvO1xudmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG52YXIgZml4ID0gZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICB2YXIgcHJldiA9IGNoYXJBdCQxKHN0cmluZywgb2Zmc2V0IC0gMSk7XG4gIHZhciBuZXh0ID0gY2hhckF0JDEoc3RyaW5nLCBvZmZzZXQgKyAxKTtcblxuICBpZiAoZXhlYyhsb3csIG1hdGNoKSAmJiAhZXhlYyhoaSwgbmV4dCkgfHwgZXhlYyhoaSwgbWF0Y2gpICYmICFleGVjKGxvdywgcHJldikpIHtcbiAgICByZXR1cm4gJ1xcXFx1JyArIG51bWJlclRvU3RyaW5nKGNoYXJDb2RlQXQobWF0Y2gsIDApLCAxNik7XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59O1xuXG52YXIgRk9SQ0VEJDMgPSBmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRzdHJpbmdpZnkoJ1xcdURGMDZcXHVEODM0JykgIT09ICdcIlxcXFx1ZGYwNlxcXFx1ZDgzNFwiJyB8fCAkc3RyaW5naWZ5KCdcXHVERUFEJykgIT09ICdcIlxcXFx1ZGVhZFwiJztcbn0pO1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXdlbGwtZm9ybWVkLXN0cmluZ2lmeVxuICAkJGgoe1xuICAgIHRhcmdldDogJ0pTT04nLFxuICAgIHN0YXQ6IHRydWUsXG4gICAgZm9yY2VkOiBGT1JDRUQkM1xuICB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheSQxKGwpOyBpIDwgbDsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXBwbHkkMygkc3RyaW5naWZ5LCBudWxsLCBhcmdzKTtcbiAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09ICdzdHJpbmcnID8gcmVwbGFjZShyZXN1bHQsIHRlc3RlciwgZml4KSA6IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgcGF0aCRkID0gcGF0aCR5O1xudmFyIGFwcGx5JDIgPSBmdW5jdGlvbkFwcGx5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tanNvbiAtLSBzYWZlXG5cbmlmICghcGF0aCRkLkpTT04pIHBhdGgkZC5KU09OID0ge1xuICBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuXG52YXIgc3RyaW5naWZ5JDMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICByZXR1cm4gYXBwbHkkMihwYXRoJGQuSlNPTi5zdHJpbmdpZnksIG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgcGFyZW50JHggPSBzdHJpbmdpZnkkMztcbnZhciBzdHJpbmdpZnkkMiA9IHBhcmVudCR4O1xuXG52YXIgc3RyaW5naWZ5JDEgPSBzdHJpbmdpZnkkMjtcblxudmFyIGdsb2JhbCRjID0gZ2xvYmFsJFA7XG52YXIgVHlwZUVycm9yJDYgPSBnbG9iYWwkYy5UeXBlRXJyb3I7XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyBUeXBlRXJyb3IkNignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciAkJGcgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRiID0gZ2xvYmFsJFA7XG52YXIgYXBwbHkkMSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRoO1xudmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xudmFyIGFycmF5U2xpY2UkMSA9IGFycmF5U2xpY2UkNTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDE7XG52YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50JDIpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG5cbnZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJGIuRnVuY3Rpb247XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGhhbmRsZXIsIHRpbWVvdXRcbiAgLyogLCAuLi5hcmd1bWVudHMgKi9cbiAgKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpID4gMjtcbiAgICB2YXIgZm4gPSBpc0NhbGxhYmxlJDEoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24kMShoYW5kbGVyKTtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IGFycmF5U2xpY2UkMShhcmd1bWVudHMsIDIpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2hlZHVsZXIoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkkMShmbiwgdGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lb3V0KTtcbiAgfTtcbn07IC8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjdGltZXJzXG5cblxuJCRnKHtcbiAgZ2xvYmFsOiB0cnVlLFxuICBiaW5kOiB0cnVlLFxuICBmb3JjZWQ6IE1TSUVcbn0sIHtcbiAgLy8gYHNldFRpbWVvdXRgIG1ldGhvZFxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1zZXR0aW1lb3V0XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsJGIuc2V0VGltZW91dCksXG4gIC8vIGBzZXRJbnRlcnZhbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldGludGVydmFsXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbCRiLnNldEludGVydmFsKVxufSk7XG5cbnZhciBwYXRoJGMgPSBwYXRoJHk7XG52YXIgc2V0VGltZW91dCQyID0gcGF0aCRjLnNldFRpbWVvdXQ7XG5cbnZhciBzZXRUaW1lb3V0JDEgPSBzZXRUaW1lb3V0JDI7XG5cbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkZTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ1ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDsgLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcblxudmFyIGFycmF5RmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWVcbi8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovXG4pIHtcbiAgdmFyIE8gPSB0b09iamVjdCQzKHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNShPKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcblxuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcblxuICByZXR1cm4gTztcbn07XG5cbnZhciAkJGYgPSBfZXhwb3J0O1xudmFyIGZpbGwkNCA9IGFycmF5RmlsbDtcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcblxuJCRmKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZVxufSwge1xuICBmaWxsOiBmaWxsJDRcbn0pOyAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbnZhciBlbnRyeVZpcnR1YWwkOCA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGZpbGwkMyA9IGVudHJ5VmlydHVhbCQ4KCdBcnJheScpLmZpbGw7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ4ID0gZmlsbCQzO1xudmFyIEFycmF5UHJvdG90eXBlJDggPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBmaWxsJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZpbGw7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkOCB8fCBpc1Byb3RvdHlwZU9mJGEoQXJyYXlQcm90b3R5cGUkOCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOC5maWxsID8gbWV0aG9kJDggOiBvd247XG59O1xuXG52YXIgcGFyZW50JHcgPSBmaWxsJDI7XG52YXIgZmlsbCQxID0gcGFyZW50JHc7XG5cbnZhciBmaWxsID0gZmlsbCQxO1xuXG4vKiEgSGFtbWVyLkpTIC0gdjIuMC4xNy1yYyAtIDIwMTktMTItMTZcbiAqIGh0dHA6Ly9uYXZlci5naXRodWIuaW8vZWdqc1xuICpcbiAqIEZvcmtlZCBCeSBOYXZlciBlZ2pzXG4gKiBDb3B5cmlnaHQgKGMpIGhhbW1lcmpzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xuXG5cbnZhciBhc3NpZ247XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59IGVsc2Uge1xuICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG52YXIgYXNzaWduJDEgPSBhc3NpZ247XG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8ge1xuICBzdHlsZToge31cbn0gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbnZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgYWJzJDEgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4O1xuICB2YXIgcHJvcDtcbiAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICBwcm9wID0gcHJlZml4ID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cblxuXG52YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAvLyB3aW5kb3cgaXMgdW5kZWZpbmVkIGluIG5vZGUuanNcbiAgd2luID0ge307XG59IGVsc2Uge1xuICB3aW4gPSB3aW5kb3c7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRvdWNoTWFwID0ge307XG4gIHZhciBjc3NTdXBwb3J0cyA9IHdpbi5DU1MgJiYgd2luLkNTUy5zdXBwb3J0cztcbiAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgIHJldHVybiB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW4uQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB0b3VjaE1hcDtcbn1cblxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG5cbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW4pO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW4sICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbnZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG4vKipcbiAqIEBwcml2YXRlXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gIHZhciBpO1xuXG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cblxuXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgLy8gbm9uZVxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9XG5cbiAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gIH1cblxuICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVG91Y2hBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRvdWNoQWN0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAodmFsdWUgPT09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICovXG5cblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cblxuXG4gIF9wcm90by5jb21wdXRlID0gZnVuY3Rpb24gY29tcHV0ZSgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8ucHJldmVudERlZmF1bHRzID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjsgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG5cbiAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcbiAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbmUgfHwgaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8fCBoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgKi9cblxuXG4gIF9wcm90by5wcmV2ZW50U3JjID0gZnVuY3Rpb24gcHJldmVudFNyYyhzcmNFdmVudCkge1xuICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hBY3Rpb247XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5cblxuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcblxuICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgIH07XG4gIH1cblxuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5cblxuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgfTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cblxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuXG4gIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICB2YXIgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgfVxuXG4gIGlmIChhYnMkMSh4KSA+PSBhYnMkMSh5KSkge1xuICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICB9XG5cbiAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7IC8vIGxldCB7IG9mZnNldERlbHRhOm9mZnNldCA9IHt9LCBwcmV2RGVsdGEgPSB7fSwgcHJldklucHV0ID0ge30gfSA9IHNlc3Npb247XG4gIC8vIGpzY3MgdGhyb3dpbmcgZXJyb3Igb24gZGVmYWx1dCBkZXN0cnVjdHVyZWQgdmFsdWVzIGFuZCB3aXRob3V0IGRlZmF1bHRzIHRlc3RzIGZhaWxcblxuICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICB9O1xuICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55XG4gICAgfTtcbiAgfVxuXG4gIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5cblxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dDtcbiAgdmFyIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wO1xuICB2YXIgdmVsb2NpdHk7XG4gIHZhciB2ZWxvY2l0eVg7XG4gIHZhciB2ZWxvY2l0eVk7XG4gIHZhciBkaXJlY3Rpb247XG5cbiAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgdmVsb2NpdHlYID0gdi54O1xuICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICB2ZWxvY2l0eSA9IGFicyQxKHYueCkgPiBhYnMkMSh2LnkpID8gdi54IDogdi55O1xuICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICB9XG5cbiAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cbi8qKlxuKiBAcHJpdmF0ZVxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuXG4gIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9IC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcblxuXG4gIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQsXG4gICAgICBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG4gIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG4gIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSBhYnMkMShvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMkMShvdmVyYWxsVmVsb2NpdHkueSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnM7XG4gIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7IC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG5cbiAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gIHZhciBzcmNFdmVudFRhcmdldDtcblxuICBpZiAoc3JjRXZlbnQuY29tcG9zZWRQYXRoKSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfSBlbHNlIGlmIChzcmNFdmVudC5wYXRoKSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC5wYXRoWzBdO1xuICB9IGVsc2Uge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQudGFyZ2V0O1xuICB9XG5cbiAgaWYgKGhhc1BhcmVudChzcmNFdmVudFRhcmdldCwgdGFyZ2V0KSkge1xuICAgIHRhcmdldCA9IHNyY0V2ZW50VGFyZ2V0O1xuICB9XG5cbiAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gIHZhciBpc0ZpcnN0ID0gZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgcG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDA7XG4gIHZhciBpc0ZpbmFsID0gZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgcG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDA7XG4gIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgaWYgKGlzRmlyc3QpIHtcbiAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgfSAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcblxuXG4gIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTsgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG5cbiAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7IC8vIGVtaXQgc2VjcmV0IGV2ZW50XG5cbiAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG4gIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7IC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cblxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICogQHZpcnR1YWxcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICovXG5cblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gIH07XG5cbiAgcmV0dXJuIElucHV0O1xufSgpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5cblxuZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgIGlmIChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCB8fCAhZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAvLyBkbyBub3QgdXNlID09PSBoZXJlLCB0ZXN0IGZhaWxzXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59OyAvLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxuXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgMzogSU5QVVRfVFlQRV9QRU4sXG4gIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxuXG59O1xudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7IC8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuXG5pZiAod2luLk1TUG9pbnRlckV2ZW50ICYmICF3aW4uUG9pbnRlckV2ZW50KSB7XG4gIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cblxudmFyIFBvaW50ZXJFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9pbnRlckV2ZW50SW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdG9yZSA9IF90aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcbiAgICB2YXIgaXNUb3VjaCA9IHBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX1RPVUNIOyAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuXG4gICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTsgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgfSAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcblxuXG4gICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuXG5cbiAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuXG4gICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9pbnRlckV2ZW50SW5wdXQ7XG59KElucHV0KTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cblxuXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG5cbiAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICB9XG5cbiAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcbi8qKlxuICogQHByaXZhdGVcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFRvdWNoSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgVG91Y2hJbnB1dC5wcm90b3R5cGUuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50YXJnZXRJZHMgPSB7fTsgLy8gdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVG91Y2hJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hJbnB1dDtcbn0oSW5wdXQpO1xuXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzOyAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuXG4gIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgdGFyZ2V0VG91Y2hlcztcbiAgdmFyIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG4gIHZhciBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdO1xuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7IC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcblxuICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gIH0pOyAvLyBjb2xsZWN0IHRvdWNoZXNcblxuICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuXG5cbiAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICB9IC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG5cblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gWy8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksIGNoYW5nZWRUYXJnZXRUb3VjaGVzXTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcbi8qKlxuICogQHByaXZhdGVcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBNb3VzZUlucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTW91c2VJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07IC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH0gLy8gbW91c2UgbXVzdCBiZSBkb3duXG5cblxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNb3VzZUlucHV0O1xufShJbnB1dCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICB2YXIgX2V2ZW50RGF0YSRjaGFuZ2VkUG9pID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVycyxcbiAgICAgIHRvdWNoID0gX2V2ZW50RGF0YSRjaGFuZ2VkUG9pWzBdO1xuXG4gIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgIHZhciBsYXN0VG91Y2ggPSB7XG4gICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgeTogdG91Y2guY2xpZW50WVxuICAgIH07XG4gICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG5cbiAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24gcmVtb3ZlTGFzdFRvdWNoKCkge1xuICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuXG4gICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFg7XG4gIHZhciB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpO1xuICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuXG4gICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBUb3VjaE1vdXNlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgVG91Y2hNb3VzZUlucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShUb3VjaE1vdXNlSW5wdXQsIF9JbnB1dCk7XG5cbiAgICBmdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoX21hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0lucHV0LmNhbGwodGhpcywgX21hbmFnZXIsIGNhbGxiYWNrKSB8fCB0aGlzO1xuXG4gICAgICBfdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDtcbiAgICAgICAgdmFyIGlzTW91c2UgPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfTU9VU0U7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcblxuXG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX3RoaXMpKSwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF90aGlzKSksIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dChfdGhpcy5tYW5hZ2VyLCBfdGhpcy5oYW5kbGVyKTtcbiAgICAgIF90aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQoX3RoaXMubWFuYWdlciwgX3RoaXMuaGFuZGxlcik7XG4gICAgICBfdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgICAgX3RoaXMubGFzdFRvdWNoZXMgPSBbXTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBUb3VjaE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cblxuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb3VjaE1vdXNlSW5wdXQ7XG4gIH0oSW5wdXQpO1xuXG4gIHJldHVybiBUb3VjaE1vdXNlSW5wdXQ7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gIHZhciBUeXBlOyAvLyBsZXQgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHlwZShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cblxudmFyIF91bmlxdWVJZCA9IDE7XG5cbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcblxuICBpZiAobWFuYWdlcikge1xuICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICB9XG5cbiAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtjb25zdGFudH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICByZXR1cm4gJ2NhbmNlbCc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgIHJldHVybiAnZW5kJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICByZXR1cm4gJ21vdmUnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cblxudmFyIFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgZW5hYmxlOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDsgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24kMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuXG4gICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gcmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5kcm9wUmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIGRyb3BSZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ucmVxdWlyZUZhaWx1cmUgPSBmdW5jdGlvbiByZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG5cbiAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8uZHJvcFJlcXVpcmVGYWlsdXJlID0gZnVuY3Rpb24gZHJvcFJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcblxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIF9wcm90by5oYXNSZXF1aXJlRmFpbHVyZXMgPSBmdW5jdGlvbiBoYXNSZXF1aXJlRmFpbHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uY2FuUmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIGNhblJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgfSAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcblxuXG4gICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICB9XG5cbiAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHtcbiAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgIH0gLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcblxuXG4gICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgX3Byb3RvLnRyeUVtaXQgPSBmdW5jdGlvbiB0cnlFbWl0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICB9IC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcblxuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbiB3ZSBlbWl0P1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uY2FuRW1pdCA9IGZ1bmN0aW9uIGNhbkVtaXQoKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24kMSh7fSwgaW5wdXREYXRhKTsgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG5cbiAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcblxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTsgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAqIEB2aXJ0dWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICogQHJldHVybnMge2NvbnN0YW50fSBTVEFURVxuICAgKi9cblxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXREYXRhKSB7fTtcbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAqIEB2aXJ0dWFsXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgKiBAdmlydHVhbFxuICAgKi9cblxuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge307XG5cbiAgcmV0dXJuIFJlY29nbml6ZXI7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIHRhcCBpcyByZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBUYXBSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShUYXBSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gVGFwUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3RhcCcsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRhcHM6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwLFxuICAgICAgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgIHRpbWU6IDI1MCxcbiAgICAgIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICB0aHJlc2hvbGQ6IDksXG4gICAgICAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgcG9zVGhyZXNob2xkOiAxMFxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzOyAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG5cbiAgICBfdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIF90aGlzLnBDZW50ZXIgPSBmYWxzZTtcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgX3RoaXMuY291bnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUYXBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgdGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICB9IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuXG5cbiAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwgOiB0cnVlO1xuICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuXG4gICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuXG4gICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgICAgIF90aGlzMi50cnlFbWl0KCk7XG4gICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8uZmFpbFRpbWVvdXQgPSBmdW5jdGlvbiBmYWlsVGltZW91dCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsKTtcbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRhcFJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgQXR0clJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEF0dHJSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBwb2ludGVyczogMVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQXR0clJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7IC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcblxuICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIHJldHVybiBBdHRyUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICByZXR1cm4gJ2Rvd24nO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1VQKSB7XG4gICAgcmV0dXJuICd1cCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICByZXR1cm4gJ3JpZ2h0JztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBQYW5SZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFuUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3BhbicsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICBfdGhpcy5wWCA9IG51bGw7XG4gICAgX3RoaXMucFkgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYW5SZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfTtcblxuICBfcHJvdG8uZGlyZWN0aW9uVGVzdCA9IGZ1bmN0aW9uIGRpcmVjdGlvblRlc3QoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7IC8vIGxvY2sgdG8gYXhpcz9cblxuICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgZGlyZWN0aW9uID0geCA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgaGFzTW92ZWQgPSB4ICE9PSB0aGlzLnBYO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSB5ID09PSAwID8gRElSRUNUSU9OX05PTkUgOiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICBoYXNNb3ZlZCA9IHkgIT09IHRoaXMucFk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmICggLy8gcmVwbGFjZSB3aXRoIGEgc3VwZXIgY2FsbFxuICAgIHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFBhblJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cblxudmFyIFN3aXBlUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN3aXBlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICBwb2ludGVyczogMVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN3aXBlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJiBpbnB1dC5tYXhQb2ludGVycyA9PT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmIGFicyQxKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuXG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXBlUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBQaW5jaFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQaW5jaFJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQaW5jaFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICB9XG5cbiAgICBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFBpbmNoUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cblxudmFyIFJvdGF0ZVJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShSb3RhdGVSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb3RhdGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gIH07XG5cbiAgcmV0dXJuIFJvdGF0ZVJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5cblxudmFyIFByZXNzUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUHJlc3NSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0aW1lOiAyNTEsXG4gICAgICAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgdGhyZXNob2xkOiA5XG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQcmVzc1JlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cbiAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgX3RoaXMyLnRyeUVtaXQoKTtcbiAgICAgIH0sIG9wdGlvbnMudGltZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgIH1cblxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnB1dCAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIFwidXBcIiwgaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUHJlc3NSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkb21FdmVudHM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICovXG4gIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZTogdHJ1ZSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRDbGFzczogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICBjc3NQcm9wczoge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdG91Y2hTZWxlY3Q6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB0b3VjaENhbGxvdXQ6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIGNvbnRlbnRab29taW5nOiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlckRyYWc6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAqL1xuICAgIHRhcEhpZ2hsaWdodENvbG9yOiBcInJnYmEoMCwwLDAsMClcIlxuICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICogVGhpcyBpcyBzZXBhcmF0ZWQgd2l0aCBvdGhlciBkZWZhdWx0cyBiZWNhdXNlIG9mIHRyZWUtc2hha2luZy5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG52YXIgcHJlc2V0ID0gW1tSb3RhdGVSZWNvZ25pemVyLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbUGluY2hSZWNvZ25pemVyLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbn1dLCBbUGFuUmVjb2duaXplciwge1xuICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG59LCBbJ3N3aXBlJ11dLCBbVGFwUmVjb2duaXplcl0sIFtUYXBSZWNvZ25pemVyLCB7XG4gIGV2ZW50OiAnZG91YmxldGFwJyxcbiAgdGFwczogMlxufSwgWyd0YXAnXV0sIFtQcmVzc1JlY29nbml6ZXJdXTtcbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcblxuICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJvcDtcbiAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcblxuICAgIGlmIChhZGQpIHtcbiAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCBcIlwiO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFhZGQpIHtcbiAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cbi8qKlxuKiBAcHJpdmF0ZVxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24kMSh7fSwgZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHJlY29nbml6ZXIgPSBfdGhpcy5hZGQobmV3IGl0ZW1bMF0oaXRlbVsxXSkpO1xuXG4gICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcblxuICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgKi9cblxuXG4gIF9wcm90by5zdG9wID0gZnVuY3Rpb24gc3RvcChmb3JjZSkge1xuICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcblxuICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG5cblxuICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG4gICAgdmFyIHJlY29nbml6ZXI7XG4gICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVyczsgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcblxuICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyOyAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuXG4gICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICBjdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldOyAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuXG4gICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkge1xuICAgICAgICAvLyAzXG4gICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICB9IC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcblxuXG4gICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChyZWNvZ25pemVyKSB7XG4gICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9XG5cbiAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgKi9cblxuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQocmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcImFkZFwiLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyByZW1vdmUgZXhpc3RpbmdcblxuXG4gICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcblxuICAgIGlmIChleGlzdGluZykge1xuICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgIH1cblxuICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICovXG5cblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJyZW1vdmVcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRSZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7IC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG5cbiAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHRhcmdldFJlY29nbml6ZXIpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBiaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLm9uID0gZnVuY3Rpb24gb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG5cblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgfSAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcblxuXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcblxuICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuXG4gICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgKi9cblxuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBNYW5hZ2VyO1xufSgpO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgU2luZ2xlVG91Y2hJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFNpbmdsZVRvdWNoSW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvdG8gPSBTaW5nbGVUb3VjaElucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG5cbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7IC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU2luZ2xlVG91Y2hJbnB1dDtcbn0oSW5wdXQpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSBcIkRFUFJFQ0FURUQgTUVUSE9EOiBcIiArIG5hbWUgKyBcIlxcblwiICsgbWVzc2FnZSArIFwiIEFUIFxcblwiO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJykucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuXG4gICAgaWYgKGxvZykge1xuICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuXG5cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgIGlmICghbWVyZ2UgfHwgbWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cblxudmFyIG1lcmdlJDIgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGU7XG4gIHZhciBjaGlsZFA7XG4gIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgYXNzaWduJDEoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIEhhbW1lciQyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIEhhbW1lciA9XG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEBjb25zdCB7c3RyaW5nfVxuICAgICovXG4gIGZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBfZXh0ZW5kcyh7XG4gICAgICByZWNvZ25pemVyczogcHJlc2V0LmNvbmNhdCgpXG4gICAgfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIEhhbW1lci5WRVJTSU9OID0gXCIyLjAuMTctcmNcIjtcbiAgSGFtbWVyLkRJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fQUxMO1xuICBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgSGFtbWVyLkRJUkVDVElPTl9MRUZUID0gRElSRUNUSU9OX0xFRlQ7XG4gIEhhbW1lci5ESVJFQ1RJT05fUklHSFQgPSBESVJFQ1RJT05fUklHSFQ7XG4gIEhhbW1lci5ESVJFQ1RJT05fVVAgPSBESVJFQ1RJT05fVVA7XG4gIEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMO1xuICBIYW1tZXIuRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICBIYW1tZXIuRElSRUNUSU9OX05PTkUgPSBESVJFQ1RJT05fTk9ORTtcbiAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIEhhbW1lci5JTlBVVF9TVEFSVCA9IElOUFVUX1NUQVJUO1xuICBIYW1tZXIuSU5QVVRfTU9WRSA9IElOUFVUX01PVkU7XG4gIEhhbW1lci5JTlBVVF9FTkQgPSBJTlBVVF9FTkQ7XG4gIEhhbW1lci5JTlBVVF9DQU5DRUwgPSBJTlBVVF9DQU5DRUw7XG4gIEhhbW1lci5TVEFURV9QT1NTSUJMRSA9IFNUQVRFX1BPU1NJQkxFO1xuICBIYW1tZXIuU1RBVEVfQkVHQU4gPSBTVEFURV9CRUdBTjtcbiAgSGFtbWVyLlNUQVRFX0NIQU5HRUQgPSBTVEFURV9DSEFOR0VEO1xuICBIYW1tZXIuU1RBVEVfRU5ERUQgPSBTVEFURV9FTkRFRDtcbiAgSGFtbWVyLlNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9SRUNPR05JWkVEO1xuICBIYW1tZXIuU1RBVEVfQ0FOQ0VMTEVEID0gU1RBVEVfQ0FOQ0VMTEVEO1xuICBIYW1tZXIuU1RBVEVfRkFJTEVEID0gU1RBVEVfRkFJTEVEO1xuICBIYW1tZXIuTWFuYWdlciA9IE1hbmFnZXI7XG4gIEhhbW1lci5JbnB1dCA9IElucHV0O1xuICBIYW1tZXIuVG91Y2hBY3Rpb24gPSBUb3VjaEFjdGlvbjtcbiAgSGFtbWVyLlRvdWNoSW5wdXQgPSBUb3VjaElucHV0O1xuICBIYW1tZXIuTW91c2VJbnB1dCA9IE1vdXNlSW5wdXQ7XG4gIEhhbW1lci5Qb2ludGVyRXZlbnRJbnB1dCA9IFBvaW50ZXJFdmVudElucHV0O1xuICBIYW1tZXIuVG91Y2hNb3VzZUlucHV0ID0gVG91Y2hNb3VzZUlucHV0O1xuICBIYW1tZXIuU2luZ2xlVG91Y2hJbnB1dCA9IFNpbmdsZVRvdWNoSW5wdXQ7XG4gIEhhbW1lci5SZWNvZ25pemVyID0gUmVjb2duaXplcjtcbiAgSGFtbWVyLkF0dHJSZWNvZ25pemVyID0gQXR0clJlY29nbml6ZXI7XG4gIEhhbW1lci5UYXAgPSBUYXBSZWNvZ25pemVyO1xuICBIYW1tZXIuUGFuID0gUGFuUmVjb2duaXplcjtcbiAgSGFtbWVyLlN3aXBlID0gU3dpcGVSZWNvZ25pemVyO1xuICBIYW1tZXIuUGluY2ggPSBQaW5jaFJlY29nbml6ZXI7XG4gIEhhbW1lci5Sb3RhdGUgPSBSb3RhdGVSZWNvZ25pemVyO1xuICBIYW1tZXIuUHJlc3MgPSBQcmVzc1JlY29nbml6ZXI7XG4gIEhhbW1lci5vbiA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIub2ZmID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5lYWNoID0gZWFjaDtcbiAgSGFtbWVyLm1lcmdlID0gbWVyZ2UkMjtcbiAgSGFtbWVyLmV4dGVuZCA9IGV4dGVuZDtcbiAgSGFtbWVyLmJpbmRGbiA9IGJpbmRGbjtcbiAgSGFtbWVyLmFzc2lnbiA9IGFzc2lnbiQxO1xuICBIYW1tZXIuaW5oZXJpdCA9IGluaGVyaXQ7XG4gIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gIEhhbW1lci5wcmVmaXhlZCA9IHByZWZpeGVkO1xuICBIYW1tZXIudG9BcnJheSA9IHRvQXJyYXk7XG4gIEhhbW1lci5pbkFycmF5ID0gaW5BcnJheTtcbiAgSGFtbWVyLnVuaXF1ZUFycmF5ID0gdW5pcXVlQXJyYXk7XG4gIEhhbW1lci5zcGxpdFN0ciA9IHNwbGl0U3RyO1xuICBIYW1tZXIuYm9vbE9yRm4gPSBib29sT3JGbjtcbiAgSGFtbWVyLmhhc1BhcmVudCA9IGhhc1BhcmVudDtcbiAgSGFtbWVyLmFkZEV2ZW50TGlzdGVuZXJzID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5yZW1vdmVFdmVudExpc3RlbmVycyA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIuZGVmYXVsdHMgPSBhc3NpZ24kMSh7fSwgZGVmYXVsdHMsIHtcbiAgICBwcmVzZXQ6IHByZXNldFxuICB9KTtcbiAgcmV0dXJuIEhhbW1lcjtcbn0oKTsgLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgUmVhbEhhbW1lciA9IEhhbW1lciQyO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ4KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDgobywgbWluTGVuKSB7IHZhciBfY29udGV4dDIxOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOChvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MjEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQyMSwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDgobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ4KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXHJcbiAqIFVzZSB0aGlzIHN5bWJvbCB0byBkZWxldGUgcHJvcGVyaWVzIGluIGRlZXBPYmplY3RBc3NpZ24uXHJcbiAqL1xuXG52YXIgREVMRVRFID0gc3ltYm9sKFwiREVMRVRFXCIpO1xuLyoqXHJcbiAqIFB1cmUgdmVyc2lvbiBvZiBkZWVwT2JqZWN0QXNzaWduLCBpdCBkb2Vzbid0IG1vZGlmeSBhbnkgb2YgaXQncyBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYXNlIC0gVGhlIGJhc2Ugb2JqZWN0IHRoYXQgZnVsbGZpbHMgdGhlIHdob2xlIGludGVyZmFjZSBULlxyXG4gKiBAcGFyYW0gdXBkYXRlcyAtIFVwZGF0ZXMgdGhhdCBtYXkgY2hhbmdlIG9yIGRlbGV0ZSBwcm9wcy5cclxuICogQHJldHVybnMgQSBicmFuZCBuZXcgaW5zdGFuY2Ugd2l0aCBhbGwgdGhlIHN1cHBsaWVkIG9iamVjdHMgZGVlcGx5IG1lcmdlZC5cclxuICovXG5cblxuZnVuY3Rpb24gcHVyZURlZXBPYmplY3RBc3NpZ24oYmFzZSkge1xuICB2YXIgX2NvbnRleHQ7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHVwZGF0ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHVwZGF0ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRlZXBPYmplY3RBc3NpZ24uYXBwbHkodm9pZCAwLCBjb25jYXQoX2NvbnRleHQgPSBbe30sIGJhc2VdKS5jYWxsKF9jb250ZXh0LCB1cGRhdGVzKSk7XG59XG4vKipcclxuICogRGVlcCB2ZXJzaW9uIG9mIG9iamVjdCBhc3NpZ24gd2l0aCBhZGRpdGlvbmFsIGRlbGV0aW5nIGJ5IHRoZSBERUxFVEUgc3ltYm9sLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0cyB0byBiZSBkZWVwbHkgbWVyZ2VkLlxyXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgb2JqZWN0IGZyb20gdmFsdWVzLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwT2JqZWN0QXNzaWduKCkge1xuICB2YXIgbWVyZ2VkID0gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgc3RyaXBEZWxldGUobWVyZ2VkKTtcbiAgcmV0dXJuIG1lcmdlZDtcbn1cbi8qKlxyXG4gKiBEZWVwIHZlcnNpb24gb2Ygb2JqZWN0IGFzc2lnbiB3aXRoIGFkZGl0aW9uYWwgZGVsZXRpbmcgYnkgdGhlIERFTEVURSBzeW1ib2wuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgZG9lc24ndCBzdHJpcCB0aGUgREVMRVRFIHN5bWJvbHMgc28gdGhleSBtYXkgZW5kIHVwIGluIHRoZSBmaW5hbCBvYmplY3QuXHJcbiAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3RzIHRvIGJlIGRlZXBseSBtZXJnZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBvYmplY3QgZnJvbSB2YWx1ZXMuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeSgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICB2YWx1ZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGlmICh2YWx1ZXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH0gZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgcmV0dXJuIGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeS5hcHBseSh2b2lkIDAsIGNvbmNhdChfY29udGV4dDIgPSBbZGVlcE9iamVjdEFzc2lnbih2YWx1ZXNbMF0sIHZhbHVlc1sxXSldKS5jYWxsKF9jb250ZXh0MiwgX3RvQ29uc3VtYWJsZUFycmF5KHNsaWNlKHZhbHVlcykuY2FsbCh2YWx1ZXMsIDIpKSkpO1xuICB9XG5cbiAgdmFyIGEgPSB2YWx1ZXNbMF07XG4gIHZhciBiID0gdmFsdWVzWzFdO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KG93bktleXMkNShiKSksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcHJvcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoYiwgcHJvcCkpIDtlbHNlIGlmIChiW3Byb3BdID09PSBERUxFVEUpIHtcbiAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICB9IGVsc2UgaWYgKGFbcHJvcF0gIT09IG51bGwgJiYgYltwcm9wXSAhPT0gbnVsbCAmJiBfdHlwZW9mKGFbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIF90eXBlb2YoYltwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgIWlzQXJyYXkkMihhW3Byb3BdKSAmJiAhaXNBcnJheSQyKGJbcHJvcF0pKSB7XG4gICAgICAgIGFbcHJvcF0gPSBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkoYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhW3Byb3BdID0gY2xvbmUoYltwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxyXG4gKiBEZWVwIGNsb25lIGdpdmVuIG9iamVjdCBvciBhcnJheS4gSW4gY2FzZSBvZiBwcmltaXRpdmUgc2ltcGx5IHJldHVybi5cclxuICpcclxuICogQHBhcmFtIGEgLSBBbnl0aGluZy5cclxuICogQHJldHVybnMgRGVlcCBjbG9uZWQgb2JqZWN0L2FycmF5IG9yIHVuY2hhbmdlZCBhLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIGlmIChpc0FycmF5JDIoYSkpIHtcbiAgICByZXR1cm4gbWFwJDMoYSkuY2FsbChhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBjbG9uZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoX3R5cGVvZihhKSA9PT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeSh7fSwgYSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbi8qKlxyXG4gKiBTdHJpcCBERUxFVEUgZnJvbSBnaXZlbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gT2JqZWN0IHdoaWNoIG1heSBjb250YWluIERFTEVURSBidXQgd29uJ3QgYWZ0ZXIgdGhpcyBpcyBleGVjdXRlZC5cclxuICovXG5cblxuZnVuY3Rpb24gc3RyaXBEZWxldGUoYSkge1xuICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IGtleXMkNChhKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHByb3AgPSBfT2JqZWN0JGtleXNbX2ldO1xuXG4gICAgaWYgKGFbcHJvcF0gPT09IERFTEVURSkge1xuICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGFbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIGFbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgIHN0cmlwRGVsZXRlKGFbcHJvcF0pO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIFNlZWRhYmxlLCBmYXN0IGFuZCByZWFzb25hYmx5IGdvb2QgKG5vdCBjcnlwdG8gYnV0IG1vcmUgdGhhbiBva2F5IGZvciBvdXJcclxuICogbmVlZHMpIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBZGFwdGVkIGZyb20ge0BsaW5rIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDExMDQyOTEwMDczNi9odHRwOi8vYmFhZ29lLmNvbTo4MC9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHR9LlxyXG4gKiBPcmlnaW5hbCBhbGdvcml0aG0gY3JlYXRlZCBieSBKb2hhbm5lcyBCYWFnw7hlIFxcPGJhYWdvZVxcQGJhYWdvZS5jb21cXD4gaW4gMjAxMC5cclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGUgYSBzZWVkZWQgcHNldWRvIHJhbmRvbSBnZW5lcmF0b3IgYmFzZWQgb24gQWxlYSBieSBKb2hhbm5lcyBCYWFnw7hlLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIEFsbCBzdXBwbGllZCBhcmd1bWVudHMgd2lsbCBiZSB1c2VkIGFzIGEgc2VlZC4gSW4gY2FzZSBub3RoaW5nXHJcbiAqIGlzIHN1cHBsaWVkIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkIHRvIHNlZWQgdGhlIGdlbmVyYXRvci5cclxuICogQHJldHVybnMgQSByZWFkeSB0byB1c2Ugc2VlZGVkIGdlbmVyYXRvci5cclxuICovXG5cblxuZnVuY3Rpb24gQWxlYSgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzZWVkID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc2VlZFtfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIEFsZWFJbXBsZW1lbnRhdGlvbihzZWVkLmxlbmd0aCA/IHNlZWQgOiBbbm93JDEoKV0pO1xufVxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFtbQWxlYV1dIHdpdGhvdXQgdXNlciBpbnB1dCB2YWxpZGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNlZWQgdGhlIGdlbmVyYXRvci5cclxuICogQHJldHVybnMgQSByZWFkeSB0byB1c2Ugc2VlZGVkIGdlbmVyYXRvci5cclxuICovXG5cblxuZnVuY3Rpb24gQWxlYUltcGxlbWVudGF0aW9uKHNlZWQpIHtcbiAgdmFyIF9tYXNoU2VlZCA9IG1hc2hTZWVkKHNlZWQpLFxuICAgICAgX21hc2hTZWVkMiA9IF9zbGljZWRUb0FycmF5KF9tYXNoU2VlZCwgMyksXG4gICAgICBzMCA9IF9tYXNoU2VlZDJbMF0sXG4gICAgICBzMSA9IF9tYXNoU2VlZDJbMV0sXG4gICAgICBzMiA9IF9tYXNoU2VlZDJbMl07XG5cbiAgdmFyIGMgPSAxO1xuXG4gIHZhciByYW5kb20gPSBmdW5jdGlvbiByYW5kb20oKSB7XG4gICAgdmFyIHQgPSAyMDkxNjM5ICogczAgKyBjICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcblxuICAgIHMwID0gczE7XG4gICAgczEgPSBzMjtcbiAgICByZXR1cm4gczIgPSB0IC0gKGMgPSB0IHwgMCk7XG4gIH07XG5cbiAgcmFuZG9tLnVpbnQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgfTsgLy8gMl4zMlxuXG5cbiAgcmFuZG9tLmZyYWN0NTMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhbmRvbSgpICsgKHJhbmRvbSgpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7XG4gIH07IC8vIDJeLTUzXG5cblxuICByYW5kb20uYWxnb3JpdGhtID0gXCJBbGVhXCI7XG4gIHJhbmRvbS5zZWVkID0gc2VlZDtcbiAgcmFuZG9tLnZlcnNpb24gPSBcIjAuOVwiO1xuICByZXR1cm4gcmFuZG9tO1xufVxuLyoqXHJcbiAqIFR1cm4gYXJiaXRyYXJ5IGRhdGEgaW50byB2YWx1ZXMgW1tBbGVhSW1wbGVtZW50YXRpb25dXSBjYW4gdXNlIHRvIGdlbmVyYXRlXHJcbiAqIHJhbmRvbSBudW1iZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBzZWVkLlxyXG4gKiBAcmV0dXJucyBUaHJlZSBudW1iZXJzIHRvIHVzZSBhcyBpbml0aWFsIHZhbHVlcyBmb3IgW1tBbGVhSW1wbGVtZW50YXRpb25dXS5cclxuICovXG5cblxuZnVuY3Rpb24gbWFzaFNlZWQoKSB7XG4gIHZhciBtYXNoID0gTWFzaCgpO1xuICB2YXIgczAgPSBtYXNoKFwiIFwiKTtcbiAgdmFyIHMxID0gbWFzaChcIiBcIik7XG4gIHZhciBzMiA9IG1hc2goXCIgXCIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgczAgLT0gbWFzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pO1xuXG4gICAgaWYgKHMwIDwgMCkge1xuICAgICAgczAgKz0gMTtcbiAgICB9XG5cbiAgICBzMSAtPSBtYXNoKGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG5cbiAgICBpZiAoczEgPCAwKSB7XG4gICAgICBzMSArPSAxO1xuICAgIH1cblxuICAgIHMyIC09IG1hc2goaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldKTtcblxuICAgIGlmIChzMiA8IDApIHtcbiAgICAgIHMyICs9IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtzMCwgczEsIHMyXTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWFzaCBmdW5jdGlvbi5cclxuICpcclxuICogQHJldHVybnMgQSBub25wdXJlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXJiaXRyYXJ5IFtbTWFzaGFibGVdXSBkYXRhIGFuZCB0dXJuc1xyXG4gKiB0aGVtIGludG8gbnVtYmVycy5cclxuICovXG5cblxuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc3RyaW5nID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuXG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH07XG59XG4vKipcbiAqIFNldHVwIGEgbW9jayBoYW1tZXIuanMgb2JqZWN0LCBmb3IgdW5pdCB0ZXN0aW5nLlxuICpcbiAqIEluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL3B1bGwvNjU4XG4gKlxuICogQHJldHVybnMge3tvbjogbm9vcCwgb2ZmOiBub29wLCBkZXN0cm95OiBub29wLCBlbWl0OiBub29wLCBnZXQ6IGdldH19XG4gKi9cblxuXG5mdW5jdGlvbiBoYW1tZXJNb2NrKCkge1xuICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuICByZXR1cm4ge1xuICAgIG9uOiBub29wLFxuICAgIG9mZjogbm9vcCxcbiAgICBkZXN0cm95OiBub29wLFxuICAgIGVtaXQ6IG5vb3AsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXQ6IG5vb3BcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG52YXIgSGFtbWVyJDEgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LkhhbW1lciB8fCBSZWFsSGFtbWVyIDogZnVuY3Rpb24gKCkge1xuICAvLyBoYW1tZXIuanMgaXMgb25seSBhdmFpbGFibGUgaW4gYSBicm93c2VyLCBub3QgaW4gbm9kZS5qcy4gUmVwbGFjaW5nIGl0IHdpdGggYSBtb2NrIG9iamVjdC5cbiAgcmV0dXJuIGhhbW1lck1vY2soKTtcbn07XG4vKipcbiAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqIEBjbGFzcyBBY3RpdmF0b3JcbiAqL1xuXG5mdW5jdGlvbiBBY3RpdmF0b3IkMShjb250YWluZXIpIHtcbiAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgIF9jb250ZXh0MztcblxuICB0aGlzLl9jbGVhbnVwUXVldWUgPSBbXTtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5fZG9tID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIG92ZXJsYXk6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgfTtcblxuICB0aGlzLl9kb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwidmlzLW92ZXJsYXlcIik7XG5cbiAgdGhpcy5fZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20ub3ZlcmxheSk7XG5cbiAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF90aGlzLl9kb20ub3ZlcmxheSk7XG4gIH0pO1xuXG4gIHZhciBoYW1tZXIgPSBIYW1tZXIkMSh0aGlzLl9kb20ub3ZlcmxheSk7XG4gIGhhbW1lci5vbihcInRhcFwiLCBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5fb25UYXBPdmVybGF5KS5jYWxsKF9jb250ZXh0MywgdGhpcykpO1xuXG4gIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBoYW1tZXIuZGVzdHJveSgpOyAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkXG4gICAgLy8gZnJvbSBtZW1vcnkpXG4gIH0pOyAvLyBibG9jayBhbGwgdG91Y2ggZXZlbnRzIChleGNlcHQgdGFwKVxuXG5cbiAgdmFyIGV2ZW50cyA9IFtcInRhcFwiLCBcImRvdWJsZXRhcFwiLCBcInByZXNzXCIsIFwicGluY2hcIiwgXCJwYW5cIiwgXCJwYW5zdGFydFwiLCBcInBhbm1vdmVcIiwgXCJwYW5lbmRcIl07XG5cbiAgZm9yRWFjaCQyKGV2ZW50cykuY2FsbChldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGhhbW1lci5vbihldmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSk7IC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuXG5cbiAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB0aGlzLl9vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV9oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCBjb250YWluZXIpKSB7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb25DbGljayk7XG5cbiAgICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfdGhpcy5fb25DbGljayk7XG4gICAgfSk7XG4gIH0gLy8gcHJlcGFyZSBlc2NhcGUga2V5IGxpc3RlbmVyIGZvciBkZWFjdGl2YXRpbmcgd2hlbiBhY3RpdmVcblxuXG4gIHRoaXMuX2VzY0xpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKFwia2V5XCIgaW4gZXZlbnQgPyBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgOiBldmVudC5rZXlDb2RlID09PSAyN1xuICAgIC8qIHRoZSBrZXlDb2RlIGlzIGZvciBJRTExICovXG4gICAgKSB7XG4gICAgICBfdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9O1xufSAvLyB0dXJuIGludG8gYW4gZXZlbnQgZW1pdHRlclxuXG5cbkVtaXR0ZXIoQWN0aXZhdG9yJDEucHJvdG90eXBlKTsgLy8gVGhlIGN1cnJlbnRseSBhY3RpdmUgYWN0aXZhdG9yXG5cbkFjdGl2YXRvciQxLmN1cnJlbnQgPSBudWxsO1xuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDU7XG5cbiAgdGhpcy5kZWFjdGl2YXRlKCk7XG5cbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KHJldmVyc2UoX2NvbnRleHQ0ID0gc3BsaWNlJDEoX2NvbnRleHQ1ID0gdGhpcy5fY2xlYW51cFF1ZXVlKS5jYWxsKF9jb250ZXh0NSwgMCkpLmNhbGwoX2NvbnRleHQ0KSksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG59O1xuLyoqXG4gKiBBY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBoaWRkZW4sIGVsZW1lbnQgaXMgZGVjb3JhdGVkIHdpdGggYSBibHVlIHNoYWRvdyBib3JkZXJcbiAqL1xuXG5cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gd2UgYWxsb3cgb25seSBvbmUgYWN0aXZlIGFjdGl2YXRvciBhdCBhIHRpbWVcbiAgaWYgKEFjdGl2YXRvciQxLmN1cnJlbnQpIHtcbiAgICBBY3RpdmF0b3IkMS5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIEFjdGl2YXRvciQxLmN1cnJlbnQgPSB0aGlzO1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICB0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ2aXMtYWN0aXZlXCIpO1xuXG4gIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgdGhpcy5lbWl0KFwiYWN0aXZhdGVcIik7IC8vIHVnbHkgaGFjazogYmluZCBFU0MgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50cywgYXMgdGhlIE5ldHdvcmsgcmViaW5kcyBhbGxcbiAgLy8ga2V5Ym9hcmQgZXZlbnRzIG9uIGEgJ2NoYW5nZScgZXZlbnRcblxuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2VzY0xpc3RlbmVyKTtcbn07XG4vKipcbiAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgZWxlbWVudFxuICovXG5cblxuQWN0aXZhdG9yJDEucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwidmlzLWFjdGl2ZVwiKTtcblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2VzY0xpc3RlbmVyKTtcbiAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB0aGlzLmVtaXQoXCJkZWFjdGl2YXRlXCIpO1xufTtcbi8qKlxuICogSGFuZGxlIGEgdGFwIGV2ZW50OiBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gKlxuICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQWN0aXZhdG9yJDEucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICB0aGlzLmFjdGl2YXRlKCk7XG4gIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICogaXRzIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFyZW50IGlzIGZvdW5kIHNvbWV3aGVyZSBpbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gX2hhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG52YXIgZnVsbEhleFJFID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaTtcbnZhciBzaG9ydEhleFJFID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbnZhciByZ2JSRSA9IC9ecmdiXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICpcXCkkL2k7XG52YXIgcmdiYVJFID0gL15yZ2JhXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooWzAxXXwwP1xcLlxcZCspICpcXCkkL2k7XG4vKipcclxuICogUmVtb3ZlIGV2ZXJ5dGhpbmcgaW4gdGhlIERPTSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBET01vYmplY3QgLSBOb2RlIHdob3NlIGNoaWxkIG5vZGVzIHdpbGwgYmUgcmVjdXJzaXZlbHkgZGVsZXRlZC5cclxuICovXG5cblxuZnVuY3Rpb24gcmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdCkge1xuICBpZiAoRE9Nb2JqZWN0KSB7XG4gICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcbiAgICAgIHZhciBjaGlsZCA9IERPTW9iamVjdC5maXJzdENoaWxkO1xuXG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKGNoaWxkKTtcbiAgICAgICAgRE9Nb2JqZWN0LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG9iamVjdCAobm90IHByaW1pdGl2ZSBvciBudWxsKS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIG5vdCBudWxsIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCQ3KHZhbHVlKSB7XG4gIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxyXG4gKiBDb3B5IHByb3BlcnR5IGZyb20gYiB0byBhIGlmIHByb3BlcnR5IHByZXNlbnQgaW4gYS5cclxuICogSWYgcHJvcGVydHkgaW4gYiBleHBsaWNpdGx5IHNldCB0byBudWxsLCBkZWxldGUgaXQgaWYgYGFsbG93RGVsZXRpb25gIHNldC5cclxuICpcclxuICogSW50ZXJuYWwgaGVscGVyIHJvdXRpbmUsIHNob3VsZCBub3QgYmUgZXhwb3J0ZWQuIE5vdCBhZGRlZCB0byBgZXhwb3J0c2AgZm9yIHRoYXQgcmVhc29uLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRhcmdldCBvYmplY3QuXHJcbiAqIEBwYXJhbSBiIC0gU291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIHByb3AgLSBOYW1lIG9mIHByb3BlcnR5IHRvIGNvcHkgZnJvbSBiIHRvIGEuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbikge1xuICB2YXIgZG9EZWxldGlvbiA9IGZhbHNlO1xuXG4gIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgZG9EZWxldGlvbiA9IGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRvRGVsZXRpb24pIHtcbiAgICBkZWxldGUgYVtwcm9wXTtcbiAgfSBlbHNlIHtcbiAgICBhW3Byb3BdID0gYltwcm9wXTsgLy8gUmVtZW1iZXIsIHRoaXMgaXMgYSByZWZlcmVuY2UgY29weSFcbiAgfVxufVxuLyoqXHJcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuXHJcbiAqXHJcbiAqIE9ubHkgY29waWVzIHZhbHVlcyBmb3IgdGhlIHByb3BlcnRpZXMgYWxyZWFkeSBwcmVzZW50IGluIGEuXHJcbiAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXQncyBwcm9wZXJ0aWVzIHVwZGF0ZWQuXHJcbiAqIEBwYXJhbSBiIC0gVGhlIG9iamVjdCB3aXRoIHByb3BlcnR5IHVwZGF0ZXMuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnRpZXMgaW4gYSB0aGF0IGFyZSBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbGxJZkRlZmluZWQoYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogaXRlcmF0aW9uIG9mIHByb3BlcnRpZXMgb2YgYVxuICAvLyBOT1RFOiBwcm90b3R5cGUgcHJvcGVydGllcyBpdGVyYXRlZCBvdmVyIGFzIHdlbGxcbiAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgaWYgKGJbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgfHwgX3R5cGVvZihiW3Byb3BdKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBOb3RlOiB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFQcm9wID0gYVtwcm9wXTtcbiAgICAgICAgdmFyIGJQcm9wID0gYltwcm9wXTtcblxuICAgICAgICBpZiAoaXNPYmplY3QkNyhhUHJvcCkgJiYgaXNPYmplY3QkNyhiUHJvcCkpIHtcbiAgICAgICAgICBmaWxsSWZEZWZpbmVkKGFQcm9wLCBiUHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxyXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBQcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgcm91dGluZSBpbXBsaWVkIHRoYXQgbXVsdGlwbGUgc291cmNlIG9iamVjdHMgY291bGRcclxuICogYmUgdXNlZDsgaG93ZXZlciwgdGhlIGltcGxlbWVudGF0aW9uIHdhcyAqKndyb25nKiouIFNpbmNlIG11bHRpcGxlIChcXD4xKVxyXG4gKiBzb3VyY2VzIHdlcmVuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgYHZpcy5qc2AgY29kZSwgdGhpcyBoYXMgYmVlbiByZW1vdmVkXHJcbiAqIEBwYXJhbSBwcm9wcyAtIE5hbWVzIG9mIGZpcnN0LWxldmVsIHByb3BlcnRpZXMgdG8gY29weSBvdmVyLlxyXG4gKiBAcGFyYW0gYSAtIFRhcmdldCBvYmplY3QuXHJcbiAqIEBwYXJhbSBiIC0gU291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydHkgaW4gYSBpZiBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqIEByZXR1cm5zIEFyZ3VtZW50IGEuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNlbGVjdGl2ZURlZXBFeHRlbmQocHJvcHMsIGEsIGIpIHtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoaXNBcnJheSQyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICB9XG5cbiAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbcF07XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApKSB7XG4gICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKGJbcHJvcF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxyXG4gKiBFeHRlbmQgb2JqZWN0IGBhYCB3aXRoIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGBiYCwgaWdub3JpbmcgcHJvcGVydGllcyB3aGljaFxyXG4gKiBhcmUgZXhwbGljaXRseSBzcGVjaWZpZWQgdG8gYmUgZXhjbHVkZWQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIG9mIGBiYCBhcmUgY29uc2lkZXJlZCBmb3IgY29weWluZy4gUHJvcGVydGllcyB3aGljaCBhcmVcclxuICogdGhlbXNlbHZlcyBvYmplY3RzIGFyZSBhcmUgYWxzbyBleHRlbmRlZC4gT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZFxyXG4gKiB2YWx1ZXMgYXJlIGNvcGllZC5cclxuICogQHBhcmFtIHByb3BzVG9FeGNsdWRlIC0gTmFtZXMgb2YgcHJvcGVydGllcyB3aGljaCBzaG91bGQgKm5vdCogYmUgY29waWVkLlxyXG4gKiBAcGFyYW0gYSAtIE9iamVjdCB0byBleHRlbmQuXHJcbiAqIEBwYXJhbSBiIC0gT2JqZWN0IHRvIHRha2UgcHJvcGVydGllcyBmcm9tIGZvciBleHRlbnNpb24uXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnRpZXMgaW4gYSB0aGF0IGFyZSBleHBsaWNpdGx5XHJcbiAqIHNldCB0byBudWxsIGluIGIuXHJcbiAqIEByZXR1cm5zIEFyZ3VtZW50IGEuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQocHJvcHNUb0V4Y2x1ZGUsIGEsIGIpIHtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICAvLyBOT1RFOiBhcnJheSBwcm9wZXJ0aWVzIGhhdmUgYW4gZWxzZS1iZWxvdzsgYXBwYXJlbnRseSwgdGhlcmUgaXMgYSBwcm9ibGVtIGhlcmUuXG4gIGlmIChpc0FycmF5JDIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XG4gIH1cblxuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBIYW5kbGUgbG9jYWwgcHJvcGVydGllcyBvbmx5XG5cblxuICAgIGlmIChpbmNsdWRlcyhwcm9wc1RvRXhjbHVkZSkuY2FsbChwcm9wc1RvRXhjbHVkZSwgcHJvcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSW4gZXhjbHVzaW9uIGxpc3QsIHNraXBcblxuXG4gICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0pOyAvLyBOT1RFOiBhbGxvd0RlbGV0aW9uIG5vdCBwcm9wYWdhdGVkIVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKGJbcHJvcF0pKSB7XG4gICAgICBhW3Byb3BdID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxyXG4gKiBEZWVwIGV4dGVuZCBhbiBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRhcmdldCBvYmplY3QuXHJcbiAqIEBwYXJhbSBiIC0gU291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIHByb3RvRXh0ZW5kIC0gSWYgdHJ1ZSwgdGhlIHByb3RvdHlwZSB2YWx1ZXMgd2lsbCBhbHNvIGJlIGV4dGVuZGVkLlxyXG4gKiAoVGhhdCBpcyB0aGUgb3B0aW9ucyBvYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIG90aGVycyB3aWxsIGFsc28gZ2V0IHRoZVxyXG4gKiBpbmhlcml0ZWQgb3B0aW9ucykuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgdGhlIHZhbHVlcyBvZiBmaWVsZHMgdGhhdCBhcmUgbnVsbCB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAqIEByZXR1cm5zIEFyZ3VtZW50IGEuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBFeHRlbmQoYSwgYikge1xuICB2YXIgcHJvdG9FeHRlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSB8fCBwcm90b0V4dGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKF90eXBlb2YoYltwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgYltwcm9wXSAhPT0gbnVsbCAmJiBnZXRQcm90b3R5cGVPZiQ0KGJbcHJvcF0pID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0gZGVlcEV4dGVuZCh7fSwgYltwcm9wXSwgcHJvdG9FeHRlbmQpOyAvLyBOT1RFOiBhbGxvd0RlbGV0aW9uIG5vdCBwcm9wYWdhdGVkIVxuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoYVtwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgYVtwcm9wXSAhPT0gbnVsbCAmJiBnZXRQcm90b3R5cGVPZiQ0KGFbcHJvcF0pID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihiW3Byb3BdKSkge1xuICAgICAgICB2YXIgX2NvbnRleHQ2O1xuXG4gICAgICAgIGFbcHJvcF0gPSBzbGljZShfY29udGV4dDYgPSBiW3Byb3BdKS5jYWxsKF9jb250ZXh0Nik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnIgLSBGaXJzdCBwYXJ0LlxyXG4gKiBAcGFyYW0gbmV3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgYWFkZGVkIGludG8gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSB3aXRoIGFsbCBpdGVtcyBmcm9tIGFyciBhbmQgbmV3VmFsdWUgKHdoaWNoIGlzIGxhc3QpLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5QW5kRXh0ZW5kQXJyYXkoYXJyLCBuZXdWYWx1ZSkge1xuICB2YXIgX2NvbnRleHQ3O1xuXG4gIHJldHVybiBjb25jYXQoX2NvbnRleHQ3ID0gW10pLmNhbGwoX2NvbnRleHQ3LCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSwgW25ld1ZhbHVlXSk7XG59XG4vKipcclxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnIgLSBUaGUgYXJyYXkgdG8gYmUgY29waWVkLlxyXG4gKiBAcmV0dXJucyBTaGFsbG93IGNvcHkgb2YgYXJyLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gIHJldHVybiBzbGljZShhcnIpLmNhbGwoYXJyKTtcbn1cbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgbGVmdCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgaW4gdGhlIGJyb3dzZXIgcGFnZS5cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVMZWZ0KGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbn1cbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgdG9wIHZhbHVlIG9mIGEgRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtIC0gQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXYuXHJcbiAqIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSB0b3AgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IGluIHRoZSBicm93c2VyIHBhZ2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEFic29sdXRlVG9wKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xufVxuLyoqXHJcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXHJcbiAqIEluIGNhc2Ugb2YgYW4gYXJyYXksIHRoZSBidWlsdC1pbiBBcnJheS5mb3JFYWNoKCkgaXMgYXBwbGllZCAoKipObywgaXQncyBub3QhKiopLlxyXG4gKiBJbiBjYXNlIG9mIGFuIE9iamVjdCwgdGhlIG1ldGhvZCBsb29wcyBvdmVyIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3QgLSBBbiBPYmplY3Qgb3IgQXJyYXkgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gQXJyYXkuZm9yRWFjaC1saWtlIGNhbGxiYWNrLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoJDEob2JqZWN0LCBjYWxsYmFjaykge1xuICBpZiAoaXNBcnJheSQyKG9iamVjdCkpIHtcbiAgICAvLyBhcnJheVxuICAgIHZhciBsZW4gPSBvYmplY3QubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvYmplY3RcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8uXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBTYW1lIGFzIEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIOKAlCwg4oCUKS5cclxuICogQHBhcmFtIGxpc3RlbmVyIC0gU2FtZSBhcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIo4oCULCBsaXN0ZW5lciwg4oCUKS5cclxuICogQHBhcmFtIHVzZUNhcHR1cmUgLSBTYW1lIGFzIEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcijigJQsIOKAlCwgdXNlQ2FwdHVyZSkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIF9jb250ZXh0ODtcblxuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBpbmNsdWRlcyhfY29udGV4dDggPSBuYXZpZ2F0b3IudXNlckFnZW50KS5jYWxsKF9jb250ZXh0OCwgXCJGaXJlZm94XCIpKSB7XG4gICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7IC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEBUT0RPOiBJRSB0eXBlcz8gRG9lcyBhbnlvbmUgY2FyZT9cbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpOyAvLyBJRSBicm93c2Vyc1xuICB9XG59XG4vKipcclxuICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBiaW5kIHRoZSBldmVudCBsaXN0ZW5lciB0by5cclxuICogQHBhcmFtIGFjdGlvbiAtIFNhbWUgYXMgRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwg4oCULCDigJQpLlxyXG4gKiBAcGFyYW0gbGlzdGVuZXIgLSBTYW1lIGFzIEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcijigJQsIGxpc3RlbmVyLCDigJQpLlxyXG4gKiBAcGFyYW0gdXNlQ2FwdHVyZSAtIFNhbWUgYXMgRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKOKAlCwg4oCULCB1c2VDYXB0dXJlKS5cclxuICovXG5cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgX2NvbnRleHQ5O1xuXG4gICAgLy8gbm9uLUlFIGJyb3dzZXJzXG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIGluY2x1ZGVzKF9jb250ZXh0OSA9IG5hdmlnYXRvci51c2VyQWdlbnQpLmNhbGwoX2NvbnRleHQ5LCBcIkZpcmVmb3hcIikpIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gRm9yIEZpcmVmb3hcbiAgICB9XG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQFRPRE86IElFIHR5cGVzPyBEb2VzIGFueW9uZSBjYXJlP1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7IC8vIElFIGJyb3dzZXJzXG4gIH1cbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGhleCBjb2xvciBzdHJpbmcgaW50byBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiB7QGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2J9XHJcbiAqIEBwYXJhbSBoZXggLSBIZXggY29sb3Igc3RyaW5nICgzIG9yIDYgZGlnaXRzLCB3aXRoIG9yIHdpdGhvdXQgIykuXHJcbiAqIEByZXR1cm5zIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBoZXhUb1JHQihoZXgpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBzd2l0Y2ggKGhleC5sZW5ndGgpIHtcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgICAgcmVzdWx0ID0gc2hvcnRIZXhSRS5leGVjKGhleCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICByOiBfcGFyc2VJbnQocmVzdWx0WzFdICsgcmVzdWx0WzFdLCAxNiksXG4gICAgICAgIGc6IF9wYXJzZUludChyZXN1bHRbMl0gKyByZXN1bHRbMl0sIDE2KSxcbiAgICAgICAgYjogX3BhcnNlSW50KHJlc3VsdFszXSArIHJlc3VsdFszXSwgMTYpXG4gICAgICB9IDogbnVsbDtcblxuICAgIGNhc2UgNjpcbiAgICBjYXNlIDc6XG4gICAgICByZXN1bHQgPSBmdWxsSGV4UkUuZXhlYyhoZXgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgcjogX3BhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgICAgICBnOiBfcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgICAgIGI6IF9wYXJzZUludChyZXN1bHRbM10sIDE2KVxuICAgICAgfSA6IG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHN0cmluZyBjb2xvciBpbiBoZXggb3IgUkdCIGZvcm1hdCBhbmQgYWRkcyB0aGUgb3BhY2l0eSwgUkdCQSBpcyBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciAtIFRoZSBjb2xvciBzdHJpbmcgKGhleCwgUkdCLCBSR0JBKS5cclxuICogQHBhcmFtIG9wYWNpdHkgLSBUaGUgbmV3IG9wYWNpdHkuXHJcbiAqIEByZXR1cm5zIFJHQkEgc3RyaW5nLCBmb3IgZXhhbXBsZSAncmdiYSgyNTUsIDAsIDEyNywgMC4zKScuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG92ZXJyaWRlT3BhY2l0eShjb2xvciwgb3BhY2l0eSkge1xuICBpZiAoaW5jbHVkZXMoY29sb3IpLmNhbGwoY29sb3IsIFwicmdiYVwiKSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfSBlbHNlIGlmIChpbmNsdWRlcyhjb2xvcikuY2FsbChjb2xvciwgXCJyZ2JcIikpIHtcbiAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKGluZGV4T2YoY29sb3IpLmNhbGwoY29sb3IsIFwiKFwiKSArIDEpLnJlcGxhY2UoXCIpXCIsIFwiXCIpLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiWzBdICsgXCIsXCIgKyByZ2JbMV0gKyBcIixcIiArIHJnYlsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmdiID0gaGV4VG9SR0IoY29sb3IpO1xuXG4gICAgaWYgKF9yZ2IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgX3JnYi5yICsgXCIsXCIgKyBfcmdiLmcgKyBcIixcIiArIF9yZ2IuYiArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgUkdCIFxcPDAsIDI1NVxcPiBpbnRvIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWQgLSBSZWQgY2hhbm5lbC5cclxuICogQHBhcmFtIGdyZWVuIC0gR3JlZW4gY2hhbm5lbC5cclxuICogQHBhcmFtIGJsdWUgLSBCbHVlIGNoYW5uZWwuXHJcbiAqIEByZXR1cm5zIEhleCBjb2xvciBzdHJpbmcgKGZvciBleGFtcGxlOiAnIzBhY2RjMCcpLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBSR0JUb0hleChyZWQsIGdyZWVuLCBibHVlKSB7XG4gIHZhciBfY29udGV4dDEwO1xuXG4gIHJldHVybiBcIiNcIiArIHNsaWNlKF9jb250ZXh0MTAgPSAoKDEgPDwgMjQpICsgKHJlZCA8PCAxNikgKyAoZ3JlZW4gPDwgOCkgKyBibHVlKS50b1N0cmluZygxNikpLmNhbGwoX2NvbnRleHQxMCwgMSk7XG59XG4vKipcclxuICogUGFyc2UgYSBjb2xvciBwcm9wZXJ0eSBpbnRvIGFuIG9iamVjdCB3aXRoIGJvcmRlciwgYmFja2dyb3VuZCwgYW5kIGhpZ2hsaWdodCBjb2xvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dENvbG9yIC0gU2hvcnRoYW5kIGNvbG9yIHN0cmluZyBvciBpbnB1dCBjb2xvciBvYmplY3QuXHJcbiAqIEBwYXJhbSBkZWZhdWx0Q29sb3IgLSBGdWxsIGNvbG9yIG9iamVjdCB0byBmaWxsIGluIG1pc3NpbmcgdmFsdWVzIGluIGlucHV0Q29sb3IuXHJcbiAqIEByZXR1cm5zIENvbG9yIG9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VDb2xvcihpbnB1dENvbG9yLCBkZWZhdWx0Q29sb3IpIHtcbiAgaWYgKGlzU3RyaW5nKGlucHV0Q29sb3IpKSB7XG4gICAgdmFyIGNvbG9yU3RyID0gaW5wdXRDb2xvcjtcblxuICAgIGlmIChpc1ZhbGlkUkdCKGNvbG9yU3RyKSkge1xuICAgICAgdmFyIF9jb250ZXh0MTE7XG5cbiAgICAgIHZhciByZ2IgPSBtYXAkMyhfY29udGV4dDExID0gY29sb3JTdHIuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvclN0ci5sZW5ndGggLSA1KS5zcGxpdChcIixcIikpLmNhbGwoX2NvbnRleHQxMSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VJbnQodmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbG9yU3RyID0gUkdCVG9IZXgocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRIZXgoY29sb3JTdHIpID09PSB0cnVlKSB7XG4gICAgICB2YXIgaHN2ID0gaGV4VG9IU1YoY29sb3JTdHIpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IGhzdi5zICogMC44LFxuICAgICAgICB2OiBNYXRoLm1pbigxLCBoc3YudiAqIDEuMDIpXG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySFNWID0ge1xuICAgICAgICBoOiBoc3YuaCxcbiAgICAgICAgczogTWF0aC5taW4oMSwgaHN2LnMgKiAxLjI1KSxcbiAgICAgICAgdjogaHN2LnYgKiAwLjhcbiAgICAgIH07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIZXggPSBIU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBIU1ZUb0hleChsaWdodGVyQ29sb3JIU1YuaCwgbGlnaHRlckNvbG9ySFNWLnMsIGxpZ2h0ZXJDb2xvckhTVi52KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4LFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICBib3JkZXI6IGNvbG9yU3RyLFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yU3RyXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclN0clxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVmYXVsdENvbG9yKSB7XG4gICAgICB2YXIgY29sb3IgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuYmFja2dyb3VuZCB8fCBkZWZhdWx0Q29sb3IuYmFja2dyb3VuZCxcbiAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmJvcmRlciB8fCBkZWZhdWx0Q29sb3IuYm9yZGVyLFxuICAgICAgICBoaWdobGlnaHQ6IGlzU3RyaW5nKGlucHV0Q29sb3IuaGlnaGxpZ2h0KSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCBkZWZhdWx0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQsXG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmhpZ2hsaWdodC5ib3JkZXJcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IGlzU3RyaW5nKGlucHV0Q29sb3IuaG92ZXIpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYm9yZGVyIHx8IGRlZmF1bHRDb2xvci5ob3Zlci5ib3JkZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmhvdmVyLmJhY2tncm91bmRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jb2xvciA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmJvcmRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgIGhpZ2hsaWdodDogaXNTdHJpbmcoaW5wdXRDb2xvci5oaWdobGlnaHQpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IGlzU3RyaW5nKGlucHV0Q29sb3IuaG92ZXIpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYm9yZGVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfY29sb3I7XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29udmVydCBSR0IgXFw8MCwgMjU1XFw+IGludG8gSFNWIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvcmdiMmhzdi5odG19XHJcbiAqIEBwYXJhbSByZWQgLSBSZWQgY2hhbm5lbC5cclxuICogQHBhcmFtIGdyZWVuIC0gR3JlZW4gY2hhbm5lbC5cclxuICogQHBhcmFtIGJsdWUgLSBCbHVlIGNoYW5uZWwuXHJcbiAqIEByZXR1cm5zIEhTViBjb2xvciBvYmplY3QuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIFJHQlRvSFNWKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmVkID0gcmVkIC8gMjU1O1xuICBncmVlbiA9IGdyZWVuIC8gMjU1O1xuICBibHVlID0gYmx1ZSAvIDI1NTtcbiAgdmFyIG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcbiAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTsgLy8gQmxhY2stZ3JheS13aGl0ZVxuXG4gIGlmIChtaW5SR0IgPT09IG1heFJHQikge1xuICAgIHJldHVybiB7XG4gICAgICBoOiAwLFxuICAgICAgczogMCxcbiAgICAgIHY6IG1pblJHQlxuICAgIH07XG4gIH0gLy8gQ29sb3JzIG90aGVyIHRoYW4gYmxhY2stZ3JheS13aGl0ZTpcblxuXG4gIHZhciBkID0gcmVkID09PSBtaW5SR0IgPyBncmVlbiAtIGJsdWUgOiBibHVlID09PSBtaW5SR0IgPyByZWQgLSBncmVlbiA6IGJsdWUgLSByZWQ7XG4gIHZhciBoID0gcmVkID09PSBtaW5SR0IgPyAzIDogYmx1ZSA9PT0gbWluUkdCID8gMSA6IDU7XG4gIHZhciBodWUgPSA2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSAvIDM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICByZXR1cm4ge1xuICAgIGg6IGh1ZSxcbiAgICBzOiBzYXR1cmF0aW9uLFxuICAgIHY6IHZhbHVlXG4gIH07XG59XG4vKipcclxuICogQ29udmVydCBIU1YgXFw8MCwgMVxcPiBpbnRvIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamlqYWNrc29uLzUzMTEyNTZ9XHJcbiAqIEBwYXJhbSBoIC0gSHVlLlxyXG4gKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24uXHJcbiAqIEBwYXJhbSB2IC0gVmFsdWUuXHJcbiAqIEByZXR1cm5zIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIEhTVlRvUkdCKGgsIHMsIHYpIHtcbiAgdmFyIHI7XG4gIHZhciBnO1xuICB2YXIgYjtcbiAgdmFyIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgdmFyIGYgPSBoICogNiAtIGk7XG4gIHZhciBwID0gdiAqICgxIC0gcyk7XG4gIHZhciBxID0gdiAqICgxIC0gZiAqIHMpO1xuICB2YXIgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOlxuICAgICAgciA9IHYsIGcgPSB0LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgciA9IHEsIGcgPSB2LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgciA9IHAsIGcgPSB2LCBiID0gdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAzOlxuICAgICAgciA9IHAsIGcgPSBxLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSA0OlxuICAgICAgciA9IHQsIGcgPSBwLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSA1OlxuICAgICAgciA9IHYsIGcgPSBwLCBiID0gcTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByOiBNYXRoLmZsb29yKHIgKiAyNTUpLFxuICAgIGc6IE1hdGguZmxvb3IoZyAqIDI1NSksXG4gICAgYjogTWF0aC5mbG9vcihiICogMjU1KVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgSFNWIFxcPDAsIDFcXD4gaW50byBoZXggY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gaCAtIEh1ZS5cclxuICogQHBhcmFtIHMgLSBTYXR1cmF0aW9uLlxyXG4gKiBAcGFyYW0gdiAtIFZhbHVlLlxyXG4gKiBAcmV0dXJucyBIZXggY29sb3Igc3RyaW5nLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBIU1ZUb0hleChoLCBzLCB2KSB7XG4gIHZhciByZ2IgPSBIU1ZUb1JHQihoLCBzLCB2KTtcbiAgcmV0dXJuIFJHQlRvSGV4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHN0cmluZyBpbnRvIEhTViBcXDwwLCAxXFw+LlxyXG4gKlxyXG4gKiBAcGFyYW0gaGV4IC0gSGV4IGNvbG9yIHN0cmluZy5cclxuICogQHJldHVybnMgSFNWIGNvbG9yIG9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gaGV4VG9IU1YoaGV4KSB7XG4gIHZhciByZ2IgPSBoZXhUb1JHQihoZXgpO1xuXG4gIGlmICghcmdiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidcIi5jb25jYXQoaGV4LCBcIicgaXMgbm90IGEgdmFsaWQgY29sb3IuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBSR0JUb0hTVihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn1cbi8qKlxyXG4gKiBWYWxpZGF0ZSBoZXggY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gaGV4IC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEhleChoZXgpIHtcbiAgdmFyIGlzT2sgPSAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChoZXgpO1xuICByZXR1cm4gaXNPaztcbn1cbi8qKlxyXG4gKiBWYWxpZGF0ZSBSR0IgY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmdiIC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZFJHQihyZ2IpIHtcbiAgcmV0dXJuIHJnYlJFLnRlc3QocmdiKTtcbn1cbi8qKlxyXG4gKiBWYWxpZGF0ZSBSR0JBIGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJnYmEgLSBVbmtub3duIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0cmluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkUkdCQShyZ2JhKSB7XG4gIHJldHVybiByZ2JhUkUudGVzdChyZ2JhKTtcbn1cbi8qKlxyXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0LlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdCAtIFRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAqIEByZXR1cm5zIFRoZSBFbGVtZW50IGlmIHRoZSByZWZlcmVuY2VPYmplY3QgaXMgYW4gRWxlbWVudCwgb3IgYSBuZXcgb2JqZWN0IGluaGVyaXRpbmcgZnJvbSB0aGUgcmVmZXJlbmNlT2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBicmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0KSB7XG4gIGlmIChyZWZlcmVuY2VPYmplY3QgPT09IG51bGwgfHwgX3R5cGVvZihyZWZlcmVuY2VPYmplY3QpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocmVmZXJlbmNlT2JqZWN0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIC8vIEF2b2lkIGJyaWRnaW5nIERPTSBvYmplY3RzXG4gICAgcmV0dXJuIHJlZmVyZW5jZU9iamVjdDtcbiAgfVxuXG4gIHZhciBvYmplY3RUbyA9IGNyZWF0ZSQ1KHJlZmVyZW5jZU9iamVjdCk7XG5cbiAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZmVyZW5jZU9iamVjdCwgaSkpIHtcbiAgICAgIGlmIChfdHlwZW9mKHJlZmVyZW5jZU9iamVjdFtpXSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBvYmplY3RUb1tpXSA9IGJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3RUbztcbn1cbi8qKlxyXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBvcHRpb25zIG9mIHN1Ym9iamVjdHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gKlxyXG4gKiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHMgaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnRcclxuICogd2hpY2ggaXMgb3B0aW9uYWwgZm9yIHRoZSB1c2VyIGJ1dCBtYW5kYXRvcnkgZm9yIHRoZSBwcm9ncmFtLlxyXG4gKlxyXG4gKiBUaGUgYWRkZWQgdmFsdWUgaGVyZSBvZiB0aGUgbWVyZ2UgaXMgdGhhdCBvcHRpb24gJ2VuYWJsZWQnIGlzIHNldCBhcyByZXF1aXJlZC5cclxuICpcclxuICogQHBhcmFtIG1lcmdlVGFyZ2V0IC0gRWl0aGVyIHRoaXMub3B0aW9ucyBvciB0aGUgb3B0aW9ucyB1c2VkIGZvciB0aGUgZ3JvdXBzLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXHJcbiAqIEBwYXJhbSBvcHRpb24gLSBPcHRpb24ga2V5IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxyXG4gKiBAcGFyYW0gZ2xvYmFsT3B0aW9ucyAtIEdsb2JhbCBvcHRpb25zLCBwYXNzZWQgaW4gdG8gZGV0ZXJtaW5lIHZhbHVlIG9mIG9wdGlvbiAnZW5hYmxlZCcuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKSB7XG4gIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAvLyBMb2NhbCBoZWxwZXJzXG4gIHZhciBpc1ByZXNlbnQgPSBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gXCJvYmplY3RcIjtcbiAgfTsgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0NDkxMjg3LzEyMjM1MzFcblxuXG4gIHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciB4IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsgLy8gR3VhcmRzXG5cblxuICBpZiAoIWlzT2JqZWN0KG1lcmdlVGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBtZXJnZVRhcmdldCBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIGlmICghaXNQcmVzZW50KG9wdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3B0aW9uIG11c3QgaGF2ZSBhIHZhbHVlXCIpO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChnbG9iYWxPcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBnbG9iYWxPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9IC8vXG4gIC8vIEFjdHVhbCBtZXJnZSByb3V0aW5lLCBzZXBhcmF0ZWQgZnJvbSBtYWluIGxvZ2ljXG4gIC8vIE9ubHkgYSBzaW5nbGUgbGV2ZWwgb2Ygb3B0aW9ucyBpcyBtZXJnZWQuIERlZXBlciBsZXZlbHMgYXJlIHJlZidkLiBUaGlzIG1heSBhY3R1YWxseSBiZSBhbiBpc3N1ZS5cbiAgLy9cblxuXG4gIHZhciBkb01lcmdlID0gZnVuY3Rpb24gZG9NZXJnZSh0YXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICB0YXJnZXRbb3B0aW9uXSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBvcHRpb25zW29wdGlvbl07XG4gICAgdmFyIGRzdCA9IHRhcmdldFtvcHRpb25dO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzcmMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBwcm9wKSkge1xuICAgICAgICBkc3RbcHJvcF0gPSBzcmNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBMb2NhbCBpbml0aWFsaXphdGlvblxuXG5cbiAgdmFyIHNyY09wdGlvbiA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgdmFyIGdsb2JhbFBhc3NlZCA9IGlzT2JqZWN0KGdsb2JhbE9wdGlvbnMpICYmICFpc0VtcHR5KGdsb2JhbE9wdGlvbnMpO1xuICB2YXIgZ2xvYmFsT3B0aW9uID0gZ2xvYmFsUGFzc2VkID8gZ2xvYmFsT3B0aW9uc1tvcHRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgZ2xvYmFsRW5hYmxlZCA9IGdsb2JhbE9wdGlvbiA/IGdsb2JhbE9wdGlvbi5lbmFibGVkIDogdW5kZWZpbmVkOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJvdXRpbmVcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBpZiAoc3JjT3B0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3JjT3B0aW9uID09PSBcImJvb2xlYW5cIikge1xuICAgIGlmICghaXNPYmplY3QobWVyZ2VUYXJnZXRbb3B0aW9uXSkpIHtcbiAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSB7fTtcbiAgICB9XG5cbiAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBzcmNPcHRpb247XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNyY09wdGlvbiA9PT0gbnVsbCAmJiAhaXNPYmplY3QobWVyZ2VUYXJnZXRbb3B0aW9uXSkpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgZXhwbGljaXQgY29weSBmcm9tIGdsb2JhbHNcbiAgICBpZiAoaXNQcmVzZW50KGdsb2JhbE9wdGlvbikpIHtcbiAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSBjcmVhdGUkNShnbG9iYWxPcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgICB9XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0KHNyY09wdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH0gLy9cbiAgLy8gRW5zdXJlIHRoYXQgJ2VuYWJsZWQnIGlzIHByb3Blcmx5IHNldC4gSXQgaXMgcmVxdWlyZWQgaW50ZXJuYWxseVxuICAvLyBOb3RlIHRoYXQgdGhlIHZhbHVlIGZyb20gb3B0aW9ucyB3aWxsIGFsd2F5cyBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlXG4gIC8vXG5cblxuICB2YXIgZW5hYmxlZCA9IHRydWU7IC8vIGRlZmF1bHQgdmFsdWVcblxuICBpZiAoc3JjT3B0aW9uLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZWQgPSBzcmNPcHRpb24uZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUYWtlIGZyb20gZ2xvYmFscywgaWYgcHJlc2VudFxuICAgIGlmIChnbG9iYWxFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuYWJsZWQgPSBnbG9iYWxPcHRpb24uZW5hYmxlZDtcbiAgICB9XG4gIH1cblxuICBkb01lcmdlKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pO1xuICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBlbmFibGVkO1xufVxuLypcclxuICogRWFzaW5nIEZ1bmN0aW9ucy5cclxuICogT25seSBjb25zaWRlcmluZyB0aGUgdCB2YWx1ZSBmb3IgdGhlIHJhbmdlIFswLCAxXSA9PiBbMCwgMV0uXHJcbiAqXHJcbiAqIEluc3BpcmF0aW9uOiBmcm9tIGh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1xyXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxyXG4gKi9cblxuXG52YXIgZWFzaW5nRnVuY3Rpb25zID0ge1xuICAvKipcclxuICAgKiBQcm92aWRlcyBubyBlYXNpbmcgYW5kIG5vIGFjY2VsZXJhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJblF1YWQ6IGZ1bmN0aW9uIGVhc2VJblF1YWQodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gZWFzZU91dFF1YWQodCkge1xuICAgIHJldHVybiB0ICogKDIgLSB0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gZWFzZUluQ3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiBlYXNlT3V0Q3ViaWModCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5RdWFydCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5RdWludDogZnVuY3Rpb24gZWFzZUluUXVpbnQodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWludCh0KSB7XG4gICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICB9XG59O1xuLy8gSXQgd29ya3Mgb25seSBmb3Igc2luZ2xlIHByb3BlcnR5IG9iamVjdHMsXG4vLyBvdGhlcndpc2UgaXQgY29tYmluZXMgYWxsIG9mIHRoZSB0eXBlcyBpbiBhIHVuaW9uLlxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIFYxPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjE+W10sXG4vLyAgIGFjY2Vzc29yczogSzEgfCBbSzFdXG4vLyApOiB1bmRlZmluZWQgfCBWMVxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIEsyIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjI+IChcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMSB8IFJlY29yZDxLMiwgdW5kZWZpbmVkIHwgVjI+PltdLFxuLy8gICBhY2Nlc3NvcnM6IFtLMSwgSzJdXG4vLyApOiB1bmRlZmluZWQgfCBWMSB8IFYyXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgSzIgZXh0ZW5kcyBzdHJpbmcsIEszIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjIsIFYzPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjEgfCBSZWNvcmQ8SzIsIHVuZGVmaW5lZCB8IFYyIHwgUmVjb3JkPEszLCB1bmRlZmluZWQgfCBWMz4+PltdLFxuLy8gICBhY2Nlc3NvcnM6IFtLMSwgSzIsIEszXVxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMiB8IFYzXG5cbi8qKlxyXG4gKiBHZXQgdGhlIHRvcCBtb3N0IHByb3BlcnR5IHZhbHVlIGZyb20gYSBwaWxlIG9mIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwaWxlIC0gQXJyYXkgb2Ygb2JqZWN0cywgbm8gcmVxdWlyZWQgZm9ybWF0LlxyXG4gKiBAcGFyYW0gYWNjZXNzb3JzIC0gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEZvciBleGFtcGxlIGBvYmplY3RbJ2ZvbyddWydiYXInXWAg4oaSIGBbJ2ZvbycsICdiYXInXWAuXHJcbiAqIEByZXR1cm5zIFZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aXRoIGdpdmVuIGFjY2Vzc29ycyBwYXRoIGZyb20gdGhlIGZpcnN0IHBpbGUgaXRlbSB3aGVyZSBpdCdzIG5vdCB1bmRlZmluZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvcE1vc3QocGlsZSwgYWNjZXNzb3JzKSB7XG4gIHZhciBjYW5kaWRhdGU7XG5cbiAgaWYgKCFpc0FycmF5JDIoYWNjZXNzb3JzKSkge1xuICAgIGFjY2Vzc29ycyA9IFthY2Nlc3NvcnNdO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KHBpbGUpLFxuICAgICAgX3N0ZXAzO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBtZW1iZXIgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gbWVtYmVyW2FjY2Vzc29yc1swXV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhY2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVbYWNjZXNzb3JzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IzLmYoKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGU7XG59XG5cbnZhciBodG1sQ29sb3JzID0ge1xuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIG5hdnk6IFwiIzAwMDA4MFwiLFxuICBkYXJrYmx1ZTogXCIjMDAwMDhCXCIsXG4gIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLFxuICBibHVlOiBcIiMwMDAwRkZcIixcbiAgZGFya2dyZWVuOiBcIiMwMDY0MDBcIixcbiAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICB0ZWFsOiBcIiMwMDgwODBcIixcbiAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICBkZWVwc2t5Ymx1ZTogXCIjMDBCRkZGXCIsXG4gIGRhcmt0dXJxdW9pc2U6IFwiIzAwQ0VEMVwiLFxuICBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBGQTlBXCIsXG4gIGxpbWU6IFwiIzAwRkYwMFwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsXG4gIGFxdWE6IFwiIzAwRkZGRlwiLFxuICBjeWFuOiBcIiMwMEZGRkZcIixcbiAgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIixcbiAgZG9kZ2VyYmx1ZTogXCIjMUU5MEZGXCIsXG4gIGxpZ2h0c2VhZ3JlZW46IFwiIzIwQjJBQVwiLFxuICBmb3Jlc3RncmVlbjogXCIjMjI4QjIyXCIsXG4gIHNlYWdyZWVuOiBcIiMyRThCNTdcIixcbiAgZGFya3NsYXRlZ3JheTogXCIjMkY0RjRGXCIsXG4gIGxpbWVncmVlbjogXCIjMzJDRDMyXCIsXG4gIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgdHVycXVvaXNlOiBcIiM0MEUwRDBcIixcbiAgcm95YWxibHVlOiBcIiM0MTY5RTFcIixcbiAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsXG4gIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhEMUNDXCIsXG4gIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gIGRhcmtvbGl2ZWdyZWVuOiBcIiM1NTZCMkZcIixcbiAgY2FkZXRibHVlOiBcIiM1RjlFQTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIiM2NkNEQUFcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsXG4gIG9saXZlZHJhYjogXCIjNkI4RTIzXCIsXG4gIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsXG4gIGxpZ2h0c2xhdGVncmF5OiBcIiM3Nzg4OTlcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIiM3QjY4RUVcIixcbiAgbGF3bmdyZWVuOiBcIiM3Q0ZDMDBcIixcbiAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gIGFxdWFtYXJpbmU6IFwiIzdGRkZENFwiLFxuICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICBwdXJwbGU6IFwiIzgwMDA4MFwiLFxuICBvbGl2ZTogXCIjODA4MDAwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBza3libHVlOiBcIiM4N0NFRUJcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgYmx1ZXZpb2xldDogXCIjOEEyQkUyXCIsXG4gIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLFxuICBkYXJrbWFnZW50YTogXCIjOEIwMDhCXCIsXG4gIHNhZGRsZWJyb3duOiBcIiM4QjQ1MTNcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIixcbiAgbGlnaHRncmVlbjogXCIjOTBFRTkwXCIsXG4gIG1lZGl1bXB1cnBsZTogXCIjOTM3MEQ4XCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLFxuICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICBkYXJrb3JjaGlkOiBcIiM5OTMyQ0NcIixcbiAgeWVsbG93Z3JlZW46IFwiIzlBQ0QzMlwiLFxuICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICBicm93bjogXCIjQTUyQTJBXCIsXG4gIGRhcmtncmF5OiBcIiNBOUE5QTlcIixcbiAgbGlnaHRibHVlOiBcIiNBREQ4RTZcIixcbiAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICBwYWxldHVycXVvaXNlOiBcIiNBRkVFRUVcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiI0IwQzRERVwiLFxuICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIixcbiAgZGFya2dvbGRlbnJvZDogXCIjQjg4NjBCXCIsXG4gIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gIHJvc3licm93bjogXCIjQkM4RjhGXCIsXG4gIGRhcmtraGFraTogXCIjQkRCNzZCXCIsXG4gIHNpbHZlcjogXCIjQzBDMEMwXCIsXG4gIG1lZGl1bXZpb2xldHJlZDogXCIjQzcxNTg1XCIsXG4gIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsXG4gIHBlcnU6IFwiI0NEODUzRlwiLFxuICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICB0YW46IFwiI0QyQjQ4Q1wiLFxuICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICBwYWxldmlvbGV0cmVkOiBcIiNEODcwOTNcIixcbiAgdGhpc3RsZTogXCIjRDhCRkQ4XCIsXG4gIG9yY2hpZDogXCIjREE3MEQ2XCIsXG4gIGdvbGRlbnJvZDogXCIjREFBNTIwXCIsXG4gIGNyaW1zb246IFwiI0RDMTQzQ1wiLFxuICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICBwbHVtOiBcIiNEREEwRERcIixcbiAgYnVybHl3b29kOiBcIiNERUI4ODdcIixcbiAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgbGF2ZW5kZXI6IFwiI0U2RTZGQVwiLFxuICBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIixcbiAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgcGFsZWdvbGRlbnJvZDogXCIjRUVFOEFBXCIsXG4gIGxpZ2h0Y29yYWw6IFwiI0YwODA4MFwiLFxuICBraGFraTogXCIjRjBFNjhDXCIsXG4gIGFsaWNlYmx1ZTogXCIjRjBGOEZGXCIsXG4gIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIixcbiAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICBzYW5keWJyb3duOiBcIiNGNEE0NjBcIixcbiAgd2hlYXQ6IFwiI0Y1REVCM1wiLFxuICBiZWlnZTogXCIjRjVGNURDXCIsXG4gIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLFxuICBtaW50Y3JlYW06IFwiI0Y1RkZGQVwiLFxuICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgc2FsbW9uOiBcIiNGQTgwNzJcIixcbiAgYW50aXF1ZXdoaXRlOiBcIiNGQUVCRDdcIixcbiAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjRkFGQUQyXCIsXG4gIG9sZGxhY2U6IFwiI0ZERjVFNlwiLFxuICByZWQ6IFwiI0ZGMDAwMFwiLFxuICBmdWNoc2lhOiBcIiNGRjAwRkZcIixcbiAgbWFnZW50YTogXCIjRkYwMEZGXCIsXG4gIGRlZXBwaW5rOiBcIiNGRjE0OTNcIixcbiAgb3JhbmdlcmVkOiBcIiNGRjQ1MDBcIixcbiAgdG9tYXRvOiBcIiNGRjYzNDdcIixcbiAgaG90cGluazogXCIjRkY2OUI0XCIsXG4gIGNvcmFsOiBcIiNGRjdGNTBcIixcbiAgZGFya29yYW5nZTogXCIjRkY4QzAwXCIsXG4gIGxpZ2h0c2FsbW9uOiBcIiNGRkEwN0FcIixcbiAgb3JhbmdlOiBcIiNGRkE1MDBcIixcbiAgbGlnaHRwaW5rOiBcIiNGRkI2QzFcIixcbiAgcGluazogXCIjRkZDMENCXCIsXG4gIGdvbGQ6IFwiI0ZGRDcwMFwiLFxuICBwZWFjaHB1ZmY6IFwiI0ZGREFCOVwiLFxuICBuYXZham93aGl0ZTogXCIjRkZERUFEXCIsXG4gIG1vY2Nhc2luOiBcIiNGRkU0QjVcIixcbiAgYmlzcXVlOiBcIiNGRkU0QzRcIixcbiAgbWlzdHlyb3NlOiBcIiNGRkU0RTFcIixcbiAgYmxhbmNoZWRhbG1vbmQ6IFwiI0ZGRUJDRFwiLFxuICBwYXBheWF3aGlwOiBcIiNGRkVGRDVcIixcbiAgbGF2ZW5kZXJibHVzaDogXCIjRkZGMEY1XCIsXG4gIHNlYXNoZWxsOiBcIiNGRkY1RUVcIixcbiAgY29ybnNpbGs6IFwiI0ZGRjhEQ1wiLFxuICBsZW1vbmNoaWZmb246IFwiI0ZGRkFDRFwiLFxuICBmbG9yYWx3aGl0ZTogXCIjRkZGQUYwXCIsXG4gIHNub3c6IFwiI0ZGRkFGQVwiLFxuICB5ZWxsb3c6IFwiI0ZGRkYwMFwiLFxuICBsaWdodHllbGxvdzogXCIjRkZGRkUwXCIsXG4gIGl2b3J5OiBcIiNGRkZGRjBcIixcbiAgd2hpdGU6IFwiI0ZGRkZGRlwiXG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAqL1xuXG52YXIgQ29sb3JQaWNrZXIkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yUGlja2VyJDEoKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JQaWNrZXIkMSk7XG5cbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHtcbiAgICAgIHg6IDI4OSAvIDIsXG4gICAgICB5OiAyODkgLyAyXG4gICAgfTtcbiAgICB0aGlzLnIgPSAyODkgKiAwLjQ5O1xuICAgIHRoaXMuY29sb3IgPSB7XG4gICAgICByOiAyNTUsXG4gICAgICBnOiAyNTUsXG4gICAgICBiOiAyNTUsXG4gICAgICBhOiAxLjBcbiAgICB9O1xuICAgIHRoaXMuaHVlQ2lyY2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yID0ge1xuICAgICAgcjogMjU1LFxuICAgICAgZzogMjU1LFxuICAgICAgYjogMjU1LFxuICAgICAgYTogMS4wXG4gICAgfTtcbiAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7IC8vIGJvdW5kIGJ5XG5cbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTsgLy8gY3JlYXRlIGFsbCBET00gZWxlbWVudHNcblxuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29sb3JQaWNrZXIkMSwgW3tcbiAgICBrZXk6IFwiaW5zZXJ0VG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VG8oY29udGFpbmVyKSB7XG4gICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaGFtbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICAgIHRoaXMuX3NldFNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFVwZGF0ZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciB1cGRhdGUgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2xvc2VDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDbG9zZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIGNsb3NpbmcgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc0NvbG9yU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBodG1sQ29sb3JzW2NvbG9yXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICAgKiBTdXBwb3J0ZWQgZm9ybWF0czpcbiAgICAgKiAncmVkJyAgICAgICAgICAgICAgICAgICAtLT4gSFRNTCBjb2xvciBzdHJpbmdcbiAgICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgICAqICdyZ2IoMjU1LDI1NSwyNTUpJyAgICAgIC0tPiByZ2Igc3RyaW5nXG4gICAgICogJ3JnYmEoMjU1LDI1NSwyNTUsMS4wKScgLS0+IHJnYmEgc3RyaW5nXG4gICAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9IC0tPiByZ2JhIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IGNvbG9yXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0SW5pdGlhbD10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAoY29sb3IgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJnYmE7IC8vIGlmIGEgaHRtbCBjb2xvciBzaG9ydGhhbmQgaXMgdXNlZCwgY29udmVydCB0byBoZXhcblxuICAgICAgdmFyIGh0bWxDb2xvciA9IHRoaXMuX2lzQ29sb3JTdHJpbmcoY29sb3IpO1xuXG4gICAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sb3IgPSBodG1sQ29sb3I7XG4gICAgICB9IC8vIGNoZWNrIGZvcm1hdFxuXG5cbiAgICAgIGlmIChpc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiByZ2JhQXJyYXlbMF0sXG4gICAgICAgICAgICBnOiByZ2JhQXJyYXlbMV0sXG4gICAgICAgICAgICBiOiByZ2JhQXJyYXlbMl0sXG4gICAgICAgICAgICBhOiAxLjBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdChcIixcIik7XG5cbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogX3JnYmFBcnJheVswXSxcbiAgICAgICAgICAgIGc6IF9yZ2JhQXJyYXlbMV0sXG4gICAgICAgICAgICBiOiBfcmdiYUFycmF5WzJdLFxuICAgICAgICAgICAgYTogX3JnYmFBcnJheVszXVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmdiT2JqID0gaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiByZ2JPYmoucixcbiAgICAgICAgICAgIGc6IHJnYk9iai5nLFxuICAgICAgICAgICAgYjogcmdiT2JqLmIsXG4gICAgICAgICAgICBhOiAxLjBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoY29sb3IuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmcgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5iICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNvbG9yLmEgIT09IHVuZGVmaW5lZCA/IGNvbG9yLmEgOiBcIjEuMFwiO1xuICAgICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogYWxwaGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHNldCBjb2xvclxuXG5cbiAgICAgIGlmIChyZ2JhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBwYXNzZWQgdG8gdGhlIGNvbG9yUGlja2VyLiBTdXBwb3J0ZWQgYXJlIHN0cmluZ3M6IHJnYiwgaGV4LCByZ2JhLiBPYmplY3Q6IHJnYiAoe3I6cixnOmcsYjpiLFthOmFdfSkuIFN1cHBsaWVkOiBcIiArIHN0cmluZ2lmeSQxKGNvbG9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRDb2xvcihyZ2JhLCBzZXRJbml0aWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBzaG93cyB0aGUgY29sb3IgcGlja2VyLlxuICAgICAqIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLmNsb3NlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICAgICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQUklWQVRFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBwaWNrZXIuIElzIGNhbGxlZCBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgKiBPcHRpb25hbCBib29sZWFuIHRvIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgZWFzeSBhY2Nlc3MgbGF0ZXIgb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdG9yZVByZXZpb3VzPXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzdG9yZVByZXZpb3VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIG5leHQgdGltZTtcbiAgICAgIGlmIChzdG9yZVByZXZpb3VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IGFzc2lnbiQyKHt9LCB0aGlzLmNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXBwbGllZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuaW5pdGlhbENvbG9yKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IC8vIGNhbGwgdGhlIGNsb3NpbmcgY2FsbGJhY2ssIHJlc3RvcmluZyB0aGUgb25jbGljayBtZXRob2QuXG4gICAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG5cbiAgICAgIHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMyLmNsb3NlQ2FsbGJhY2soKTtcblxuICAgICAgICAgIF90aGlzMi5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gdGhlIHNhdmUgYnV0dG9uLiBTYXZlcyBhbmQgaGlkZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5KCkge1xuICAgICAgdGhpcy5hcHBsaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZExhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRMYXN0KCkge1xuICAgICAgaWYgKHRoaXMucHJldmlvdXNDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChcIlRoZXJlIGlzIG5vIGxhc3QgY29sb3IgdG8gbG9hZC4uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBjb2xvciwgcGxhY2UgdGhlIHBpY2tlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJnYmFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q29sb3IocmdiYSkge1xuICAgICAgdmFyIHNldEluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGNvbG9yXG4gICAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxDb2xvciA9IGFzc2lnbiQyKHt9LCByZ2JhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgICB2YXIgaHN2ID0gUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgICB2YXIgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEk7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5yICogaHN2LnM7XG4gICAgICB2YXIgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcbiAgICAgIHZhciB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSB4IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgXCJweFwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IHkgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJvdW5kIHRvIG9wYWNpdHkgY29udHJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbG9yLmEgPSB2YWx1ZSAvIDEwMDtcblxuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byBicmlnaHRuZXNzIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QnJpZ2h0bmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICAgIHZhciByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICByZ2JhW1wiYVwiXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBjb2xvciBwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmdiYVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlUGlja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQaWNrZXIoKSB7XG4gICAgICB2YXIgcmdiYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5jb2xvcjtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApOyAvLyBjbGVhciB0aGUgY2FudmFzXG5cbiAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YSh0aGlzLmh1ZUNpcmNsZSwgMCwgMCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLFwiICsgKDEgLSBoc3YudikgKyBcIilcIjtcbiAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG5cbiAgICAgIGZpbGwoY3R4KS5jYWxsKGN0eCk7XG5cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gMTAwICogaHN2LnY7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9IDEwMCAqIHJnYmEuYTtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYShcIiArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyBcIilcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5jb2xvci5yICsgXCIsXCIgKyB0aGlzLmNvbG9yLmcgKyBcIixcIiArIHRoaXMuY29sb3IuYiArIFwiLFwiICsgdGhpcy5jb2xvci5hICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVzZWQgYnkgY3JlYXRlIHRvIHNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaXplKCkge1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGggPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmhlaWdodCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIGFsbCBkb20gZWxlbWVudHNcbiAgICAgKiBUT0RPOiBjbGVhbnVwLCBsb3RzIG9mIHNpbWlsYXIgZG9tIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgdmFyIF9jb250ZXh0MTYsIF9jb250ZXh0MTcsIF9jb250ZXh0MTgsIF9jb250ZXh0MTk7XG5cbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy1jb2xvci1waWNrZXJcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGFzc05hbWUgPSBcInZpcy1zZWxlY3RvclwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuXG4gICAgICBpZiAoIXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgICAgICBub0NhbnZhcy5pbm5lclRleHQgPSBcIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbG9yXCI7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5vcGFjaXR5RGl2LmNsYXNzTmFtZSA9IFwidmlzLW9wYWNpdHlcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYuY2xhc3NOYW1lID0gXCJ2aXMtYnJpZ2h0bmVzc1wiO1xuICAgICAgdGhpcy5hcnJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9IFwidmlzLWFycm93XCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcblxuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5taW4gPSBcIjBcIjtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWF4ID0gXCIxMDBcIjtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nLlxuICAgICAgfVxuXG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9IFwiMTAwXCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWUgPSBcInZpcy1yYW5nZVwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG5cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gXCIwXCI7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9IFwiMTAwXCI7XG4gICAgICB9IGNhdGNoIChlcnIpIHsvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICAgIH1cblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSBcIjEwMFwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtcmFuZ2VcIjtcbiAgICAgIHRoaXMub3BhY2l0eURpdi5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlSYW5nZSk7XG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzUmFuZ2UpO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1icmlnaHRuZXNzXCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lclRleHQgPSBcImJyaWdodG5lc3M6XCI7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuaW5uZXJUZXh0ID0gXCJvcGFjaXR5OlwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLW5ldy1jb2xvclwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lclRleHQgPSBcIm5ld1wiO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtaW5pdGlhbC1jb2xvclwiO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJUZXh0ID0gXCJpbml0aWFsXCI7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWNhbmNlbFwiO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uaW5uZXJUZXh0ID0gXCJjYW5jZWxcIjtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSBiaW5kJDYoX2NvbnRleHQxNiA9IHRoaXMuX2hpZGUpLmNhbGwoX2NvbnRleHQxNiwgdGhpcywgZmFsc2UpO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIjtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24uaW5uZXJUZXh0ID0gXCJhcHBseVwiO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbi5vbmNsaWNrID0gYmluZCQ2KF9jb250ZXh0MTcgPSB0aGlzLl9hcHBseSkuY2FsbChfY29udGV4dDE3LCB0aGlzKTtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLnNhdmVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1zYXZlXCI7XG4gICAgICB0aGlzLnNhdmVCdXR0b24uaW5uZXJUZXh0ID0gXCJzYXZlXCI7XG4gICAgICB0aGlzLnNhdmVCdXR0b24ub25jbGljayA9IGJpbmQkNihfY29udGV4dDE4ID0gdGhpcy5fc2F2ZSkuY2FsbChfY29udGV4dDE4LCB0aGlzKTtcbiAgICAgIHRoaXMubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmxvYWRCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1sb2FkXCI7XG4gICAgICB0aGlzLmxvYWRCdXR0b24uaW5uZXJUZXh0ID0gXCJsb2FkIGxhc3RcIjtcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrID0gYmluZCQ2KF9jb250ZXh0MTkgPSB0aGlzLl9sb2FkTGFzdCkuY2FsbChfY29udGV4dDE5LCB0aGlzKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckRpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NMYWJlbCk7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eUxhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5RGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uZXdDb2xvckRpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuaW5pdGlhbENvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFwcGx5QnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zYXZlQnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYmluZCBoYW1tZXIgdG8gdGhlIGNvbG9yIHBpY2tlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kSGFtbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9O1xuICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyJDEodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgICB0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5zZXQoe1xuICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwidGFwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuc3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuZW5kXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVIdWVDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlSHVlQ2lyY2xlKCkge1xuICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApOyAvLyBjbGVhciB0aGUgY2FudmFzXG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpOyAvLyBkcmF3IGh1ZSBjaXJjbGVcblxuICAgICAgICB2YXIgeCwgeSwgaHVlLCBzYXQ7XG4gICAgICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgeDogdyAqIDAuNSxcbiAgICAgICAgICB5OiBoICogMC41XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuciA9IDAuNDkgKiB3O1xuICAgICAgICB2YXIgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEkgLyAzNjA7XG4gICAgICAgIHZhciBoZmFjID0gMSAvIDM2MDtcbiAgICAgICAgdmFyIHNmYWMgPSAxIC8gdGhpcy5yO1xuICAgICAgICB2YXIgcmdiO1xuXG4gICAgICAgIGZvciAoaHVlID0gMDsgaHVlIDwgMzYwOyBodWUrKykge1xuICAgICAgICAgIGZvciAoc2F0ID0gMDsgc2F0IDwgdGhpcy5yOyBzYXQrKykge1xuICAgICAgICAgICAgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHNhdCAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgc2F0ICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgIHJnYiA9IEhTVlRvUkdCKGh1ZSAqIGhmYWMsIHNhdCAqIHNmYWMsIDEpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiKFwiICsgcmdiLnIgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiKVwiO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHggLSAwLjUsIHkgLSAwLjUsIDIsIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgwLDAsMCwxKVwiO1xuICAgICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuaHVlQ2lyY2xlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5nZW5lcmF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBzZWxlY3Rvci4gVGhpcyBpcyBjYWxsZWQgYnkgaGFtbWVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZVNlbGVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlU2VsZWN0b3IoZXZlbnQpIHtcbiAgICAgIHZhciByZWN0ID0gdGhpcy5jb2xvclBpY2tlckRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBsZWZ0ID0gZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQ7XG4gICAgICB2YXIgdG9wID0gZXZlbnQuY2VudGVyLnkgLSByZWN0LnRvcDtcbiAgICAgIHZhciBjZW50ZXJZID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgeCA9IGxlZnQgLSBjZW50ZXJYO1xuICAgICAgdmFyIHkgPSB0b3AgLSBjZW50ZXJZO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih4LCB5KTtcbiAgICAgIHZhciByYWRpdXMgPSAwLjk4ICogTWF0aC5taW4oTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjZW50ZXJYKTtcbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJYO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IG5ld1RvcCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyBcInB4XCI7IC8vIHNldCBjb2xvclxuXG4gICAgICB2YXIgaCA9IGFuZ2xlIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgIGggPSBoIDwgMCA/IGggKyAxIDogaDtcbiAgICAgIHZhciBzID0gcmFkaXVzIC8gdGhpcy5yO1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgICAgaHN2LmggPSBoO1xuICAgICAgaHN2LnMgPSBzO1xuICAgICAgdmFyIHJnYmEgPSBIU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgIHJnYmFbXCJhXCJdID0gdGhpcy5jb2xvci5hO1xuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7IC8vIHVwZGF0ZSBwcmV2aWV3c1xuXG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgXCIsXCIgKyB0aGlzLmluaXRpYWxDb2xvci5nICsgXCIsXCIgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgXCIsXCIgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgXCIpXCI7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYShcIiArIHRoaXMuY29sb3IuciArIFwiLFwiICsgdGhpcy5jb2xvci5nICsgXCIsXCIgKyB0aGlzLmNvbG9yLmIgKyBcIixcIiArIHRoaXMuY29sb3IuYSArIFwiKVwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xvclBpY2tlciQxO1xufSgpO1xuLyoqXG4gKiBXcmFwIGdpdmVuIHRleHQgKGxhc3QgYXJndW1lbnQpIGluIEhUTUwgZWxlbWVudHMgKGFsbCBwcmVjZWRpbmcgYXJndW1lbnRzKS5cbiAqXG4gKiBAcGFyYW0gey4uLmFueX0gcmVzdCAtIExpc3Qgb2YgdGFnIG5hbWVzIGZvbGxvd2VkIGJ5IGlubmVyIHRleHQuXG4gKiBAcmV0dXJucyBBbiBlbGVtZW50IG9yIGEgdGV4dCBub2RlLlxuICovXG5cblxuZnVuY3Rpb24gd3JhcEluVGFnKCkge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICByZXN0W19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cblxuICBpZiAocmVzdC5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRzLlwiKTtcbiAgfSBlbHNlIGlmIChyZXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyZXN0WzBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocmVzdFswXSk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwSW5UYWcuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoc2xpY2UocmVzdCkuY2FsbChyZXN0LCAxKSkpKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuLyoqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIHRoaXMucG9zc2libGUgb3B0aW9ucywgeW91IGNhbiBzdXBwbHkgdGhlIHByb3BlcnR5IG5hbWUgaW4gYW55IGZvcm0gdG8gbGlzdCB0aGUgb3B0aW9ucy5cbiAqIEJvb2xlYW4gb3B0aW9ucyBhcmUgcmVjb2duaXNlZCBhcyBCb29sZWFuXG4gKiBOdW1iZXIgb3B0aW9ucyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW2RlZmF1bHQgdmFsdWUsIG1pbiB2YWx1ZSwgbWF4IHZhbHVlLCBzdGVwc2l6ZV1cbiAqIENvbG9ycyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogWydjb2xvcicsICcjZmZmZmZmJ11cbiAqIFN0cmluZ3Mgd2l0aCBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW29wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIC4uXVxuICpcbiAqIFRoZSBvcHRpb25zIGFyZSBtYXRjaGVkIHdpdGggdGhlaXIgY291bnRlcnBhcnRzIGluIGVhY2ggb2YgdGhlIG1vZHVsZXMgYW5kIHRoZSB2YWx1ZXMgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBhcmVcbiAqL1xuXG5cbnZhciBDb25maWd1cmF0b3IkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50TW9kdWxlICAgICAgICB8IHRoZSBsb2NhdGlvbiB3aGVyZSBwYXJlbnRNb2R1bGUuc2V0T3B0aW9ucygpIGNhbiBiZSBjYWxsZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRDb250YWluZXIgICAgfCB0aGUgZGVmYXVsdCBjb250YWluZXIgb2YgdGhlIG1vZHVsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gICAgICAgICAgfCBjYW52YXMgcGl4ZWwgcmF0aW9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGlkZU9wdGlvbiAgICAgICAgfCBjdXN0b20gbG9naWMgdG8gZHluYW1pY2FsbHkgaGlkZSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDb25maWd1cmF0b3IkMShwYXJlbnRNb2R1bGUsIGRlZmF1bHRDb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgICB2YXIgaGlkZU9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlndXJhdG9yJDEpO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRNb2R1bGU7XG4gICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcjtcbiAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmhpZGVPcHRpb24gPSBoaWRlT3B0aW9uO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvcHVwQ291bnRlciA9IDA7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICBzaG93QnV0dG9uOiB0cnVlXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgdGhpcy5wb3B1cExpbWl0ID0gNTtcbiAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIkMShwaXhlbFJhdGlvKTtcbiAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIHJlZnJlc2ggYWxsIG9wdGlvbnMuXG4gICAqIEJlY2F1c2UgYWxsIG1vZHVsZXMgcGFyc2UgdGhlaXIgb3B0aW9ucyBieSB0aGVtc2VsdmVzLCB3ZSBqdXN0IHVzZSB0aGVpciBvcHRpb25zLiBXZSBjb3B5IHRoZW0gaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29uZmlndXJhdG9yJDEsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBwb3B1cCBoaXN0b3J5IGJlY2F1c2UgdGhlIGluZGljZXMgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG5cbiAgICAgICAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihvcHRpb25zKSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmlsdGVyKG9wdGlvbnMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBmaWx0ZXIob3B0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0J1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9IG9wdGlvbnMuc2hvd0J1dHRvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSB0cnVlO1xuICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWx0ZXIodGhpcy5vcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZU9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE1vZHVsZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlT3B0aW9ucyhtb2R1bGVPcHRpb25zKSB7XG4gICAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSBtb2R1bGVPcHRpb25zO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgZmlsdGVyJDEgPSBmaWx0ZXIodGhpcy5vcHRpb25zKTtcblxuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgX29wdGlvbiBpbiB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMsIF9vcHRpb24pKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgc2hvdyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIkMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBzaG93ID0gZmlsdGVyJDEoX29wdGlvbiwgW10pO1xuICAgICAgICAgICAgc2hvdyA9IHNob3cgfHwgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tfb3B0aW9uXSwgW19vcHRpb25dLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciQxID09PSB0cnVlIHx8IGluZGV4T2YoZmlsdGVyJDEpLmNhbGwoZmlsdGVyJDEsIF9vcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSB0cnVlOyAvLyBsaW5lYnJlYWsgYmV0d2VlbiBjYXRlZ29yaWVzXG5cbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgICB9IC8vIGEgaGVhZGVyIGZvciB0aGUgY2F0ZWdvcnlcblxuXG4gICAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKF9vcHRpb24pOyAvLyBnZXQgdGhlIHN1YiBvcHRpb25zXG5cblxuICAgICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tfb3B0aW9uXSwgW19vcHRpb25dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWFrZUJ1dHRvbigpO1xuXG4gICAgICB0aGlzLl9wdXNoKCk7IC8vfiB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wdXNoKCkge1xuICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMud3JhcHBlci5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uLXdyYXBwZXJcIjtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nob3dQb3B1cElmTmVlZGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRlbGV0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcblxuICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmFsdWUocGF0aCkge1xuICAgICAgdmFyIGJhc2UgPSB0aGlzLm1vZHVsZU9wdGlvbnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFzZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYmFzZSA9IGJhc2VbcGF0aFtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWxsIG9wdGlvbiBlbGVtZW50cyBhcmUgd3JhcHBlZCBpbiBhbiBpdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50Pn0gZG9tRWxlbWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VJdGVtKHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1pdGVtIHZpcy1jb25maWctc1wiICsgcGF0aC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBkb21FbGVtZW50cyA9IG5ldyBBcnJheShfbGVuNiA+IDEgPyBfbGVuNiAtIDEgOiAwKSwgX2tleTYgPSAxOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgICAgZG9tRWxlbWVudHNbX2tleTYgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoJDIoZG9tRWxlbWVudHMpLmNhbGwoZG9tRWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBoZWFkZXIgZm9yIG1ham9yIHN1YmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUhlYWRlcihuYW1lKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyXCI7XG4gICAgICBkaXYuaW5uZXJUZXh0ID0gbmFtZTtcblxuICAgICAgdGhpcy5fbWFrZUl0ZW0oW10sIGRpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBsYWJlbCwgaWYgaXQgaXMgYW4gb2JqZWN0IGxhYmVsLCBpdCBnZXRzIGRpZmZlcmVudCBzdHlsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TGFiZWxcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VMYWJlbChuYW1lLCBwYXRoKSB7XG4gICAgICB2YXIgb2JqZWN0TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWxhYmVsIHZpcy1jb25maWctc1wiICsgcGF0aC5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgICB3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHdyYXBJblRhZyhcImlcIiwgXCJiXCIsIG5hbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5pbm5lclRleHQgPSBuYW1lICsgXCI6XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlRHJvcGRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICAgIHNlbGVjdC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctc2VsZWN0XCI7XG4gICAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IDA7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpbmRleE9mKGFycikuY2FsbChhcnIsIHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlID0gaW5kZXhPZihhcnIpLmNhbGwoYXJyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9vcHRpb24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcblxuICAgICAgICBfb3B0aW9uMi52YWx1ZSA9IGFycltpXTtcblxuICAgICAgICBpZiAoaSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICAgIF9vcHRpb24yLnNlbGVjdGVkID0gXCJzZWxlY3RlZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgX29wdGlvbjIuaW5uZXJUZXh0ID0gYXJyW2ldO1xuICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQoX29wdGlvbjIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBzZWxlY3Qub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcblxuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSByYW5nZSBvYmplY3QgZm9yIG51bWVyaWMgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJyWzBdO1xuICAgICAgdmFyIG1pbiA9IGFyclsxXTtcbiAgICAgIHZhciBtYXggPSBhcnJbMl07XG4gICAgICB2YXIgc3RlcCA9IGFyclszXTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIHJhbmdlLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZVwiO1xuXG4gICAgICB0cnkge1xuICAgICAgICByYW5nZS50eXBlID0gXCJyYW5nZVwiOyAvLyBub3Qgc3VwcG9ydGVkIG9uIElFOVxuXG4gICAgICAgIHJhbmdlLm1pbiA9IG1pbjtcbiAgICAgICAgcmFuZ2UubWF4ID0gbWF4O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7Ly8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgICB9XG5cbiAgICAgIHJhbmdlLnN0ZXAgPSBzdGVwOyAvLyBzZXQgdXAgdGhlIHBvcHVwIHNldHRpbmdzIGluIGNhc2UgdGhleSBhcmUgbmVlZGVkLlxuXG4gICAgICB2YXIgcG9wdXBTdHJpbmcgPSBcIlwiO1xuICAgICAgdmFyIHBvcHVwVmFsdWUgPSAwO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gMS4yO1xuXG4gICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdmFsdWUgKiBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgcG9wdXBTdHJpbmcgPSBcInJhbmdlIGluY3JlYXNlZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIC8gZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlIC8gZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAqIGZhY3RvciA+IG1heCAmJiBtYXggIT09IDEpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5tYXg7XG4gICAgICAgICAgcG9wdXBTdHJpbmcgPSBcInJhbmdlIGluY3JlYXNlZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBpbnB1dC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dFwiO1xuICAgICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgICAgICAgbWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG5cbiAgICAgIHZhciBpdGVtSW5kZXggPSB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgcmFuZ2UsIGlucHV0KTsgLy8gaWYgYSBwb3B1cCBpcyBuZWVkZWQgQU5EIGl0IGhhcyBub3QgYmVlbiBzaG93biBmb3IgdGhpcyB2YWx1ZSwgc2hvdyBpdC5cblxuXG4gICAgICBpZiAocG9wdXBTdHJpbmcgIT09IFwiXCIgJiYgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSAhPT0gcG9wdXBWYWx1ZSkge1xuICAgICAgICB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdID0gcG9wdXBWYWx1ZTtcblxuICAgICAgICB0aGlzLl9zZXR1cFBvcHVwKHBvcHVwU3RyaW5nLCBpdGVtSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgYnV0dG9uIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQnV0dG9uKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCI7XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLmlubmVyVGV4dCA9IFwiZ2VuZXJhdGUgb3B0aW9uc1wiO1xuXG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0Ll9wcmludE9wdGlvbnMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1vcHRpb24tY29udGFpbmVyXCI7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaCh0aGlzLm9wdGlvbnNDb250YWluZXIpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2goZ2VuZXJhdGVCdXR0b24pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlIHRoZSBwb3B1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBQb3B1cChzdHJpbmcsIGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgJiYgdGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlICYmIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0KSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICAgIGRpdi5pbm5lclRleHQgPSBzdHJpbmc7XG5cbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1Ll9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9wdXBDb3VudGVyICs9IDE7XG4gICAgICAgIHRoaXMucG9wdXBEaXYgPSB7XG4gICAgICAgICAgaHRtbDogZGl2LFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIHBvcHVwIGZyb20gdGhlIGRvbVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlUG9wdXAoKSB7XG4gICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5wb3B1cERpdiA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBwb3B1cCBpZiBpdCBpcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dQb3B1cElmTmVlZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93UG9wdXBJZk5lZWRlZCgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgICAgdmFyIHJlY3QgPSBjb3JyZXNwb25kaW5nRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3AgPSByZWN0LnRvcCAtIDMwICsgXCJweFwiOyAvLyAzMCBpcyB0aGUgaGVpZ2h0O1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2LnBvcHVwRGl2Lmh0bWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH0sIDE1MDApO1xuICAgICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNi5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgfSwgMTgwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBjaGVja2JveCBmb3IgYm9vbGVhbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUNoZWNrYm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ2hlY2tib3goZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgY2hlY2tib3gudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YoZGVmYXVsdFZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUuZW5hYmxlZCkge1xuICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLmNoZWNrZWQsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSB0ZXh0IGlucHV0IGZpZWxkIGZvciBzdHJpbmcgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VUZXh0SW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VUZXh0SW5wdXQoZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgY2hlY2tib3gudHlwZSA9IFwidGV4dFwiO1xuICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXRleHRcIjtcbiAgICAgIGNoZWNrYm94LnZhbHVlID0gdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBjb2xvciBmaWVsZCB3aXRoIGEgY29sb3IgcGlja2VyIGZvciBjb2xvciBmaWVsZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUNvbG9yRmllbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdENvbG9yID0gYXJyWzFdO1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3IgOiB2YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2tcIjtcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrIG5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczcuX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgZGl2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXNlZCBieSB0aGUgY29sb3IgYnV0dG9ucyB0byBjYWxsIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaXZcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dDb2xvclBpY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAvLyBjbGVhciB0aGUgY2FsbGJhY2sgZnJvbSB0aGlzIGRpdlxuICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyhkaXYpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5zaG93KCk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBjb2xvclN0cmluZyA9IFwicmdiYShcIiArIGNvbG9yLnIgKyBcIixcIiArIGNvbG9yLmcgKyBcIixcIiArIGNvbG9yLmIgKyBcIixcIiArIGNvbG9yLmEgKyBcIilcIjtcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyaW5nO1xuXG4gICAgICAgIF90aGlzOC5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICAgIH0pOyAvLyBvbiBjbG9zZSBvZiB0aGUgY29sb3JwaWNrZXIsIHJlc3RvcmUgdGhlIGNhbGxiYWNrLlxuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENsb3NlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczguX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwYXJzZSBhbiBvYmplY3QgYW5kIGRyYXcgdGhlIGNvcnJlY3QgaXRlbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGF0aD1bXV0gICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoZWNrT25seT1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZU9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlT2JqZWN0KG9iaikge1xuICAgICAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIGNoZWNrT25seSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgc2hvdyA9IGZhbHNlO1xuXG4gICAgICB2YXIgZmlsdGVyJDEgPSBmaWx0ZXIodGhpcy5vcHRpb25zKTtcblxuICAgICAgdmFyIHZpc2libGVJblNldCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBzdWJPYmogaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBzdWJPYmopKSB7XG4gICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBvYmpbc3ViT2JqXTtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IGNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBzdWJPYmopO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIkMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBzaG93ID0gZmlsdGVyJDEoc3ViT2JqLCBwYXRoKTsgLy8gaWYgbmVlZGVkIHdlIG11c3QgZ28gZGVlcGVyIGludG8gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSQyKGl0ZW0pICYmIHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpdGVtICE9PSBcImJvb2xlYW5cIiAmJiBpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2hvdyA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBjaGVja09ubHkgPT09IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShuZXdQYXRoKTtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkkMihpdGVtKSkge1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVBcnJheShpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBza2lwIHRoZSBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgIGlmICghdGhpcy5oaWRlT3B0aW9uKHBhdGgsIHN1Yk9iaiwgdGhpcy5tb2R1bGVPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBjb2xsYXBzZSBvcHRpb25zIHdpdGggYW4gZGlzYWJsZWQgZW5hYmxlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFBhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkobmV3UGF0aCwgXCJlbmFibGVkXCIpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoZW5hYmxlZFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcblxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIGVuYWJsZWRWYWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgX2xhYmVsKTtcblxuICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkb250IGtub3cgaG93IHRvIGhhbmRsZVwiLCBpdGVtLCBzdWJPYmosIG5ld1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlzaWJsZUluU2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgdGhlIGFycmF5IHR5cGUgb2Ygb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJzdHJpbmdcIiAmJiBhcnJbMF0gPT09IFwiY29sb3JcIikge1xuICAgICAgICB0aGlzLl9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKTtcblxuICAgICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLl9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCk7XG5cbiAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpO1xuXG4gICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHZhbHVlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSh2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoKTtcblxuICAgICAgaWYgKHRoaXMucGFyZW50LmJvZHkgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KSB7XG4gICAgICAgIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KFwiY29uZmlnQ2hhbmdlXCIsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucGFyZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBib29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAcGFyYW0ge3t9fSBvcHRpb25zT2JqXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29uc3RydWN0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIG9wdGlvbnNPYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHBvaW50ZXIgPSBvcHRpb25zT2JqOyAvLyB3aGVuIGRyb3Bkb3duIGJveGVzIGNhbiBiZSBzdHJpbmcgb3IgYm9vbGVhbiwgd2UgdHlwZWNhc3QgaXQgaW50byBjb3JyZWN0IHR5cGVzXG5cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOiB2YWx1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXRoW2ldICE9PSBcImdsb2JhbFwiKSB7XG4gICAgICAgICAgaWYgKHBvaW50ZXJbcGF0aFtpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW3BhdGhbaV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zT2JqO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ByaW50T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJpbnRPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcblxuICAgICAgd2hpbGUgKHRoaXMub3B0aW9uc0NvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLm9wdGlvbnNDb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3cmFwSW5UYWcoXCJwcmVcIiwgXCJjb25zdCBvcHRpb25zID0gXCIgKyBzdHJpbmdpZnkkMShvcHRpb25zLCBudWxsLCAyKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7fX0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmZpZ3VyYXRvciQxO1xufSgpO1xuLyoqXG4gKiBQb3B1cCBpcyBhIGNsYXNzIHRvIGNyZWF0ZSBhIHBvcHVwIHdpbmRvdyB3aXRoIHNvbWUgdGV4dFxuICovXG5cblxudmFyIFBvcHVwJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICAgICAgVGhlIGNvbnRhaW5lciBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgb3ZlcmZsb3dNZXRob2QgIEhvdyB0aGUgcG9wdXAgc2hvdWxkIGFjdCB0byBvdmVyZmxvd2luZyAoJ2ZsaXAnIG9yICdjYXAnKVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wdXAkMShjb250YWluZXIsIG92ZXJmbG93TWV0aG9kKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHVwJDEpO1xuXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5vdmVyZmxvd01ldGhvZCA9IG92ZXJmbG93TWV0aG9kIHx8IFwiY2FwXCI7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTsgLy8gY3JlYXRlIHRoZSBmcmFtZVxuXG4gICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy10b29sdGlwXCI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQb3B1cCQxLCBbe1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnggPSBfcGFyc2VJbnQoeCk7XG4gICAgICB0aGlzLnkgPSBfcGFyc2VJbnQoeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCBmb3IgdGhlIHBvcHVwIHdpbmRvdy4gVGhpcyBjYW4gYmUgSFRNTCBjb2RlIG9yIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnR9IGNvbnRlbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhbWUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5mcmFtZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdHJpbmcgY29udGFpbmluZyBsaXRlcmFsIHRleHQsIGVsZW1lbnQgaGFzIHRvIGJlIHVzZWQgZm9yIEhUTUwgZHVlIHRvXG4gICAgICAgIC8vIFhTUyByaXNrcyBhc3NvY2lhdGVkIHdpdGggaW5uZXJIVE1MIChpLmUuIHByZXZlbnQgWFNTIGJ5IGFjY2lkZW50KS5cbiAgICAgICAgdGhpcy5mcmFtZS5pbm5lclRleHQgPSBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvU2hvd10gICAgU2hvdyBvciBoaWRlIHRoZSB3aW5kb3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhkb1Nob3cpIHtcbiAgICAgIGlmIChkb1Nob3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkb1Nob3cgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9TaG93ID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmZyYW1lLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IHRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICAgICAgdG9wID0gMDtcblxuICAgICAgICBpZiAodGhpcy5vdmVyZmxvd01ldGhvZCA9PSBcImZsaXBcIikge1xuICAgICAgICAgIHZhciBpc0xlZnQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgaXNUb3AgPSB0cnVlOyAvLyBXaGVyZSBhcm91bmQgdGhlIHBvc2l0aW9uIGl0J3MgbG9jYXRlZFxuXG4gICAgICAgICAgaWYgKHRoaXMueSAtIGhlaWdodCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgaXNUb3AgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy54ICsgd2lkdGggPiBtYXhXaWR0aCAtIHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgaXNMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy54IC0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzVG9wKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnkgLSBoZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKHRvcCArIGhlaWdodCArIHRoaXMucGFkZGluZyA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gbWF4SGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b3AgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZWZ0ID0gdGhpcy54O1xuXG4gICAgICAgICAgaWYgKGxlZnQgKyB3aWR0aCArIHRoaXMucGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWF4V2lkdGggLSB3aWR0aCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVmdCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcG9wdXAgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUpOyAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3B1cCQxO1xufSgpO1xuXG52YXIgZXJyb3JGb3VuZCA9IGZhbHNlO1xudmFyIGFsbE9wdGlvbnMkMTtcbnZhciBWQUxJREFUT1JfUFJJTlRfU1RZTEUkMSA9IFwiYmFja2dyb3VuZDogI0ZGZWVlZTsgY29sb3I6ICNkZDAwMDBcIjtcbi8qKlxuICogIFVzZWQgdG8gdmFsaWRhdGUgb3B0aW9ucy5cbiAqL1xuXG52YXIgVmFsaWRhdG9yJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYWxpZGF0b3IkMSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdG9yJDEpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZhbGlkYXRvciQxLCBudWxsLCBbe1xuICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN1Yk9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBzdWJPYmplY3QpIHtcbiAgICAgIGVycm9yRm91bmQgPSBmYWxzZTtcbiAgICAgIGFsbE9wdGlvbnMkMSA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICB2YXIgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuXG4gICAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zW3N1Yk9iamVjdF07XG4gICAgICB9XG5cbiAgICAgIFZhbGlkYXRvciQxLnBhcnNlKG9wdGlvbnMsIHVzZWRPcHRpb25zLCBbXSk7XG4gICAgICByZXR1cm4gZXJyb3JGb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCB0cmF2ZXJzZSBhbiBvYmplY3QgcmVjdXJzaXZlbHkgYW5kIGNoZWNrIGV2ZXJ5IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgZm9yICh2YXIgX29wdGlvbjMgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIF9vcHRpb24zKSkge1xuICAgICAgICAgIFZhbGlkYXRvciQxLmNoZWNrKF9vcHRpb24zLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBldmVyeSB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgY2FsbCB0aGUgcGFyc2UgZnVuY3Rpb24gb24gdGhhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFZhbGlkYXRvciQxLmdldFN1Z2dlc3Rpb24ob3B0aW9uLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmZXJlbmNlT3B0aW9uID0gb3B0aW9uO1xuICAgICAgdmFyIGlzX29iamVjdCA9IHRydWU7XG5cbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgdHJpZ2dlcnMgaWYgdGhlIF9fYW55X18gaXMgaW4gdGhlIHRvcCBsZXZlbCBvZiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICAgIC8vICAgICAgIFRIQVQnUyBBIFJFQUxMWSBCQUQgUExBQ0UgVE8gQUxMT1cgSVQhISEhXG4gICAgICAgIC8vIFRPRE86IEV4YW1pbmUgaWYgbmVlZGVkLCByZW1vdmUgaWYgcG9zc2libGVcbiAgICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICAgIHJlZmVyZW5jZU9wdGlvbiA9IFwiX19hbnlfX1wiOyAvLyBpZiB0aGUgYW55LXN1Ymdyb3VwIGlzIG5vdCBhIHByZWRlZmluZWQgb2JqZWN0IGluIHRoZSBjb25maWd1cmF0b3IsXG4gICAgICAgIC8vIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG5cbiAgICAgICAgaXNfb2JqZWN0ID0gVmFsaWRhdG9yJDEuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pID09PSBcIm9iamVjdFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmT3B0aW9uT2JqID0gcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dO1xuXG4gICAgICBpZiAoaXNfb2JqZWN0ICYmIHJlZk9wdGlvbk9iai5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZk9wdGlvbk9iaiA9IHJlZk9wdGlvbk9iai5fX3R5cGVfXztcbiAgICAgIH1cblxuICAgICAgVmFsaWRhdG9yJDEuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBvcHRpb24gICAgICAgICAgIHwgdGhlIG9wdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgICAgICB8IFRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgcmVmZXJlbmNlT3B0aW9ucyB8IFRoZSByZWZlcmVuY2Ugb3B0aW9ucyBjb250YWluaW5nIGFsbCBvcHRpb25zIGFuZCB0aGVpciBhbGxvd2VkIGZvcm1hdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHJlZmVyZW5jZU9wdGlvbiAgfCBVc3VhbGx5IHRoaXMgaXMgdGhlIHNhbWUgYXMgb3B0aW9uLCBleGNlcHQgd2hlbiBoYW5kbGluZyBhbiBfX2FueV9fIHRhZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHJlZk9wdGlvbk9iaiAgICAgfCBUaGlzIGlzIHRoZSB0eXBlIG9iamVjdCBmcm9tIHRoZSByZWZlcmVuY2Ugb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgcGF0aCAgICAgICAgICAgICB8IHdoZXJlIGluIHRoZSBvYmplY3QgaXMgdGhlIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcmVmZXJlbmNlT3B0aW9uLCByZWZPcHRpb25PYmosIHBhdGgpIHtcbiAgICAgIHZhciBsb2cgPSBmdW5jdGlvbiBsb2cobWVzc2FnZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiJWNcIiArIG1lc3NhZ2UgKyBWYWxpZGF0b3IkMS5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvcHRpb25UeXBlID0gVmFsaWRhdG9yJDEuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pO1xuICAgICAgdmFyIHJlZk9wdGlvblR5cGUgPSByZWZPcHRpb25PYmpbb3B0aW9uVHlwZV07XG5cbiAgICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgd2UgY2hlY2sgaWYgaXQgaXMgc3VwcG9zZWQgdG8gYmUgb25lIG9mIGEgZmV3IHNlbGVjdCB2YWx1ZXNcbiAgICAgICAgaWYgKFZhbGlkYXRvciQxLmdldFR5cGUocmVmT3B0aW9uVHlwZSkgPT09IFwiYXJyYXlcIiAmJiBpbmRleE9mKHJlZk9wdGlvblR5cGUpLmNhbGwocmVmT3B0aW9uVHlwZSwgb3B0aW9uc1tvcHRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICBsb2coJ0ludmFsaWQgb3B0aW9uIGRldGVjdGVkIGluIFwiJyArIG9wdGlvbiArICdcIi4nICsgXCIgQWxsb3dlZCB2YWx1ZXMgYXJlOlwiICsgVmFsaWRhdG9yJDEucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcpO1xuICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICAgIHBhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3B0aW9uKTtcbiAgICAgICAgICBWYWxpZGF0b3IkMS5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVmT3B0aW9uT2JqW1wiYW55XCJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHlwZSBvZiB0aGUgZmllbGQgaXMgaW5jb3JyZWN0IGFuZCB0aGUgZmllbGQgY2Fubm90IGJlIGFueVxuICAgICAgICBsb2coJ0ludmFsaWQgdHlwZSByZWNlaXZlZCBmb3IgXCInICsgb3B0aW9uICsgJ1wiLiBFeHBlY3RlZDogJyArIFZhbGlkYXRvciQxLnByaW50KGtleXMkNChyZWZPcHRpb25PYmopKSArIFwiLiBSZWNlaXZlZCBbXCIgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyk7XG4gICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IEFycmF5LjxudW1iZXI+IHwgRGF0ZSB8IE5vZGUgfCBNb21lbnQgfCB1bmRlZmluZWQgfCBudWxsfSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gX3R5cGVvZihvYmplY3QpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheSQyKG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gXCJkb21cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QuX2lzQU1vbWVudE9iamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBcIm1vbWVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFN1Z2dlc3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbihvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvciQxLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoLCBmYWxzZSk7XG4gICAgICB2YXIgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yJDEuZmluZEluT3B0aW9ucyhvcHRpb24sIGFsbE9wdGlvbnMkMSwgW10sIHRydWUpO1xuICAgICAgdmFyIGxvY2FsU2VhcmNoVGhyZXNob2xkID0gODtcbiAgICAgIHZhciBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgPSA0O1xuICAgICAgdmFyIG1zZztcblxuICAgICAgaWYgKGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtc2cgPSBcIiBpbiBcIiArIFZhbGlkYXRvciQxLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCBcIlwiKSArICdQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJyArIGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggKyAnXCI/XFxuXFxuJztcbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsU2VhcmNoLmRpc3RhbmNlIDw9IGdsb2JhbFNlYXJjaFRocmVzaG9sZCAmJiBsb2NhbFNlYXJjaC5kaXN0YW5jZSA+IGdsb2JhbFNlYXJjaC5kaXN0YW5jZSkge1xuICAgICAgICBtc2cgPSBcIiBpbiBcIiArIFZhbGlkYXRvciQxLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCBcIlwiKSArIFwiUGVyaGFwcyBpdCB3YXMgbWlzcGxhY2VkPyBNYXRjaGluZyBvcHRpb24gZm91bmQgYXQ6IFwiICsgVmFsaWRhdG9yJDEucHJpbnRMb2NhdGlvbihnbG9iYWxTZWFyY2gucGF0aCwgZ2xvYmFsU2VhcmNoLmNsb3Nlc3RNYXRjaCwgXCJcIik7XG4gICAgICB9IGVsc2UgaWYgKGxvY2FsU2VhcmNoLmRpc3RhbmNlIDw9IGxvY2FsU2VhcmNoVGhyZXNob2xkKSB7XG4gICAgICAgIG1zZyA9ICcuIERpZCB5b3UgbWVhbiBcIicgKyBsb2NhbFNlYXJjaC5jbG9zZXN0TWF0Y2ggKyAnXCI/JyArIFZhbGlkYXRvciQxLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9IFwiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiBcIiArIFZhbGlkYXRvciQxLnByaW50KGtleXMkNChvcHRpb25zKSkgKyBWYWxpZGF0b3IkMS5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIicgKyBtc2csIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxKTtcbiAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdXG4gICAgICogQHJldHVybnMge3tjbG9zZXN0TWF0Y2g6IHN0cmluZywgcGF0aDogQXJyYXksIGRpc3RhbmNlOiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRJbk9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciByZWN1cnNpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgdmFyIG1pbiA9IDFlOTtcbiAgICAgIHZhciBjbG9zZXN0TWF0Y2ggPSBcIlwiO1xuICAgICAgdmFyIGNsb3Nlc3RNYXRjaFBhdGggPSBbXTtcbiAgICAgIHZhciBsb3dlckNhc2VPcHRpb24gPSBvcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBpbmRleE1hdGNoID0gdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKHZhciBvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAob3B0aW9uc1tvcF0uX190eXBlX18gIT09IHVuZGVmaW5lZCAmJiByZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gVmFsaWRhdG9yJDEuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnNbb3BdLCBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3ApKTtcblxuICAgICAgICAgIGlmIChtaW4gPiByZXN1bHQuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaCA9IHJlc3VsdC5jbG9zZXN0TWF0Y2g7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gcmVzdWx0LnBhdGg7XG4gICAgICAgICAgICBtaW4gPSByZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgICBpbmRleE1hdGNoID0gcmVzdWx0LmluZGV4TWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY29udGV4dDIwO1xuXG4gICAgICAgICAgaWYgKGluZGV4T2YoX2NvbnRleHQyMCA9IG9wLnRvTG93ZXJDYXNlKCkpLmNhbGwoX2NvbnRleHQyMCwgbG93ZXJDYXNlT3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4TWF0Y2ggPSBvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvciQxLmxldmVuc2h0ZWluRGlzdGFuY2Uob3B0aW9uLCBvcCk7XG5cbiAgICAgICAgICBpZiAobWluID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaCA9IG9wO1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IGNvcHlBcnJheShwYXRoKTtcbiAgICAgICAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZXN0TWF0Y2g6IGNsb3Nlc3RNYXRjaCxcbiAgICAgICAgcGF0aDogY2xvc2VzdE1hdGNoUGF0aCxcbiAgICAgICAgZGlzdGFuY2U6IG1pbixcbiAgICAgICAgaW5kZXhNYXRjaDogaW5kZXhNYXRjaFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmludExvY2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSB7XG4gICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIlByb2JsZW0gdmFsdWUgZm91bmQgYXQ6IFxcblwiO1xuICAgICAgdmFyIHN0ciA9IFwiXFxuXFxuXCIgKyBwcmVmaXggKyBcIm9wdGlvbnMgPSB7XFxuXCI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKyAxOyBqKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IHBhdGhbaV0gKyBcIjoge1xcblwiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGF0aC5sZW5ndGggKyAxOyBfaisrKSB7XG4gICAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSBvcHRpb24gKyBcIlxcblwiO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBwYXRoLmxlbmd0aCArIDE7IF9pMysrKSB7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHBhdGgubGVuZ3RoIC0gX2kzOyBfajIrKykge1xuICAgICAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gXCJ9XFxuXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHIgKyBcIlxcblxcblwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnQob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeSQxKG9wdGlvbnMpLnJlcGxhY2UoLyhcIil8KFxcWyl8KFxcXSl8KCxcIl9fdHlwZV9fXCIpL2csIFwiXCIpLnJlcGxhY2UoLygsKS9nLCBcIiwgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5nc1xuICAgICAqIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2UjSmF2YVNjcmlwdFxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDExIEFuZHJlaSBNYWNrZW56aWVcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZXZlbnNodGVpbkRpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiBhLmxlbmd0aDtcbiAgICAgIHZhciBtYXRyaXggPSBbXTsgLy8gaW5jcmVtZW50IGFsb25nIHRoZSBmaXJzdCBjb2x1bW4gb2YgZWFjaCByb3dcblxuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXRyaXhbaV0gPSBbaV07XG4gICAgICB9IC8vIGluY3JlbWVudCBlYWNoIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG5cblxuICAgICAgdmFyIGo7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICBtYXRyaXhbMF1bal0gPSBqO1xuICAgICAgfSAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBtYXRyaXhcblxuXG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGIuY2hhckF0KGkgLSAxKSA9PSBhLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaSAtIDFdW2ogLSAxXSArIDEsIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsIC8vIGluc2VydGlvblxuICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeFtiLmxlbmd0aF1bYS5sZW5ndGhdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWYWxpZGF0b3IkMTtcbn0oKTtcblxudmFyIEFjdGl2YXRvciA9IEFjdGl2YXRvciQxO1xudmFyIENvbmZpZ3VyYXRvciA9IENvbmZpZ3VyYXRvciQxO1xudmFyIEhhbW1lciA9IEhhbW1lciQxO1xudmFyIFBvcHVwID0gUG9wdXAkMTtcbnZhciBWQUxJREFUT1JfUFJJTlRfU1RZTEUgPSBWQUxJREFUT1JfUFJJTlRfU1RZTEUkMTtcbnZhciBWYWxpZGF0b3IgPSBWYWxpZGF0b3IkMTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG4vKipcbiAqIFBhcnNlIGEgdGV4dCBzb3VyY2UgY29udGFpbmluZyBkYXRhIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKiBUaGUgb2JqZWN0IGNvbnRhaW5zIHR3byBsaXN0czogb25lIHdpdGggbm9kZXMgYW5kIG9uZSB3aXRoIGVkZ2VzLlxuICpcbiAqIERPVCBsYW5ndWFnZSByZWZlcmVuY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2xhbmcuaHRtbFxuICpcbiAqIERPVCBsYW5ndWFnZSBhdHRyaWJ1dGVzOiBodHRwOi8vZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaCAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IGVkZ2VzXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVE9ET1xuICogPT09PVxuICpcbiAqIEZvciBsYWJlbCBoYW5kbGluZywgdGhpcyBpcyBhbiBpbmNvbXBsZXRlIGltcGxlbWVudGF0aW9uLiBGcm9tIGRvY3MgKHF1b3RlICMzMDE1KTpcbiAqXG4gKiA+IHRoZSBlc2NhcGUgc2VxdWVuY2VzIFwiXFxuXCIsIFwiXFxsXCIgYW5kIFwiXFxyXCIgZGl2aWRlIHRoZSBsYWJlbCBpbnRvIGxpbmVzLCBjZW50ZXJlZCxcbiAqID4gbGVmdC1qdXN0aWZpZWQsIGFuZCByaWdodC1qdXN0aWZpZWQsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBTb3VyY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnMja2VzY1N0cmluZ1xuICpcbiAqID4gQXMgYW5vdGhlciBhaWQgZm9yIHJlYWRhYmlsaXR5LCBkb3QgYWxsb3dzIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB0byBzcGFuIG11bHRpcGxlIHBoeXNpY2FsXG4gKiA+IGxpbmVzIHVzaW5nIHRoZSBzdGFuZGFyZCBDIGNvbnZlbnRpb24gb2YgYSBiYWNrc2xhc2ggaW1tZWRpYXRlbHkgcHJlY2VkaW5nIGEgbmV3bGluZVxuICogPiBjaGFyYWN0ZXJcbiAqID4gSW4gYWRkaXRpb24sIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyBjYW4gYmUgY29uY2F0ZW5hdGVkIHVzaW5nIGEgJysnIG9wZXJhdG9yLlxuICogPiBBcyBIVE1MIHN0cmluZ3MgY2FuIGNvbnRhaW4gbmV3bGluZSBjaGFyYWN0ZXJzLCB3aGljaCBhcmUgdXNlZCBzb2xlbHkgZm9yIGZvcm1hdHRpbmcsXG4gKiA+IHRoZSBsYW5ndWFnZSBkb2VzIG5vdCBhbGxvdyBlc2NhcGVkIG5ld2xpbmVzIG9yIGNvbmNhdGVuYXRpb24gb3BlcmF0b3JzIHRvIGJlIHVzZWRcbiAqID4gd2l0aGluIHRoZW0uXG4gKlxuICogLSBDdXJyZW50bHksIG9ubHkgJ1xcXFxuJyBpcyBoYW5kbGVkXG4gKiAtIE5vdGUgdGhhdCB0ZXh0IGV4cGxpY2l0bHkgc2F5cyAnbGFiZWxzJzsgdGhlIGRvdCBwYXJzZXIgY3VycmVudGx5IGhhbmRsZXMgZXNjYXBlXG4gKiAgIHNlcXVlbmNlcyBpbiAqKmFsbCoqIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRE9UKGRhdGEpIHtcbiAgZG90ID0gZGF0YTtcbiAgcmV0dXJuIHBhcnNlR3JhcGgoKTtcbn0gLy8gbWFwcGluZyBvZiBhdHRyaWJ1dGVzIGZyb20gRE9UICh0aGUga2V5cykgdG8gdmlzLmpzICh0aGUgdmFsdWVzKVxuXG52YXIgTk9ERV9BVFRSX01BUFBJTkcgPSB7XG4gIGZvbnRzaXplOiBcImZvbnQuc2l6ZVwiLFxuICBmb250Y29sb3I6IFwiZm9udC5jb2xvclwiLFxuICBsYWJlbGZvbnRjb2xvcjogXCJmb250LmNvbG9yXCIsXG4gIGZvbnRuYW1lOiBcImZvbnQuZmFjZVwiLFxuICBjb2xvcjogW1wiY29sb3IuYm9yZGVyXCIsIFwiY29sb3IuYmFja2dyb3VuZFwiXSxcbiAgZmlsbGNvbG9yOiBcImNvbG9yLmJhY2tncm91bmRcIixcbiAgdG9vbHRpcDogXCJ0aXRsZVwiLFxuICBsYWJlbHRvb2x0aXA6IFwidGl0bGVcIlxufTtcblxudmFyIEVER0VfQVRUUl9NQVBQSU5HID0gY3JlYXRlJDUoTk9ERV9BVFRSX01BUFBJTkcpO1xuXG5FREdFX0FUVFJfTUFQUElORy5jb2xvciA9IFwiY29sb3IuY29sb3JcIjtcbkVER0VfQVRUUl9NQVBQSU5HLnN0eWxlID0gXCJkYXNoZXNcIjsgLy8gdG9rZW4gdHlwZXMgZW51bWVyYXRpb25cblxudmFyIFRPS0VOVFlQRSA9IHtcbiAgTlVMTDogMCxcbiAgREVMSU1JVEVSOiAxLFxuICBJREVOVElGSUVSOiAyLFxuICBVTktOT1dOOiAzXG59OyAvLyBtYXAgd2l0aCBhbGwgZGVsaW1pdGVyc1xuXG52YXIgREVMSU1JVEVSUyA9IHtcbiAgXCJ7XCI6IHRydWUsXG4gIFwifVwiOiB0cnVlLFxuICBcIltcIjogdHJ1ZSxcbiAgXCJdXCI6IHRydWUsXG4gIFwiO1wiOiB0cnVlLFxuICBcIj1cIjogdHJ1ZSxcbiAgXCIsXCI6IHRydWUsXG4gIFwiLT5cIjogdHJ1ZSxcbiAgXCItLVwiOiB0cnVlXG59O1xudmFyIGRvdCA9IFwiXCI7IC8vIGN1cnJlbnQgZG90IGZpbGVcblxudmFyIGluZGV4JDEgPSAwOyAvLyBjdXJyZW50IGluZGV4IGluIGRvdCBmaWxlXG5cbnZhciBjID0gXCJcIjsgLy8gY3VycmVudCB0b2tlbiBjaGFyYWN0ZXIgaW4gZXhwclxuXG52YXIgdG9rZW4gPSBcIlwiOyAvLyBjdXJyZW50IHRva2VuXG5cbnZhciB0b2tlblR5cGUgPSBUT0tFTlRZUEUuTlVMTDsgLy8gdHlwZSBvZiB0aGUgdG9rZW5cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICovXG5cbmZ1bmN0aW9uIGZpcnN0KCkge1xuICBpbmRleCQxID0gMDtcbiAgYyA9IGRvdC5jaGFyQXQoMCk7XG59XG4vKipcbiAqIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5leHQoKSB7XG4gIGluZGV4JDErKztcbiAgYyA9IGRvdC5jaGFyQXQoaW5kZXgkMSk7XG59XG4vKipcbiAqIFByZXZpZXcgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNOZXh0XG4gKi9cblxuXG5mdW5jdGlvbiBuZXh0UHJldmlldygpIHtcbiAgcmV0dXJuIGRvdC5jaGFyQXQoaW5kZXgkMSArIDEpO1xufVxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gY2hhcmFjdGVyIGlzIGFscGhhYmV0aWMgb3IgbnVtZXJpYyAoIGEtekEtWl8wLTkuOiMgKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNBbHBoYU51bWVyaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQWxwaGFOdW1lcmljKGMpIHtcbiAgdmFyIGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuXG4gIGlmIChjaGFyQ29kZSA8IDQ3KSB7XG4gICAgLy8gIy5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDM1IHx8IGNoYXJDb2RlID09PSA0NjtcbiAgfVxuXG4gIGlmIChjaGFyQ29kZSA8IDU5KSB7XG4gICAgLy8gMC05IGFuZCA6XG4gICAgcmV0dXJuIGNoYXJDb2RlID4gNDc7XG4gIH1cblxuICBpZiAoY2hhckNvZGUgPCA5MSkge1xuICAgIC8vIEEtWlxuICAgIHJldHVybiBjaGFyQ29kZSA+IDY0O1xuICB9XG5cbiAgaWYgKGNoYXJDb2RlIDwgOTYpIHtcbiAgICAvLyBfXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSA5NTtcbiAgfVxuXG4gIGlmIChjaGFyQ29kZSA8IDEyMykge1xuICAgIC8vIGEtelxuICAgIHJldHVybiBjaGFyQ29kZSA+IDk2O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBNZXJnZSBhbGwgb3B0aW9ucyBvZiBvYmplY3QgYiBpbnRvIG9iamVjdCBiXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBhXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZSQxKGEsIGIpIHtcbiAgaWYgKCFhKSB7XG4gICAgYSA9IHt9O1xuICB9XG5cbiAgaWYgKGIpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGIpIHtcbiAgICAgIGlmIChiLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGFbbmFtZV0gPSBiW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXG4gKiBTZXQgYSB2YWx1ZSBpbiBhbiBvYmplY3QsIHdoZXJlIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgbmFtZSBjYW4gYmUgYVxuICogcGF0aCB3aXRoIG5lc3RlZCBwYXJhbWV0ZXJzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIG9iaiA9IHthOiAyfTtcbiAqICAgICBzZXRWYWx1ZShvYmosICdiLmMnLCAzKTsgICAgIC8vIG9iaiA9IHthOiAyLCBiOiB7YzogM319XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggIEEgcGFyYW1ldGVyIG5hbWUgb3IgZG90LXNlcGFyYXRlZCBwYXJhbWV0ZXIgcGF0aCxcbiAqICAgICAgICAgICAgICAgICAgICAgIGxpa2UgXCJjb2xvci5oaWdobGlnaHQuYm9yZGVyXCIuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRWYWx1ZShvYmosIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHZhciBvID0gb2JqO1xuXG4gIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBrZXlzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgdGhlIGVuZCBwb2ludFxuICAgICAgaWYgKCFvW2tleV0pIHtcbiAgICAgICAgb1trZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIG8gPSBvW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBwb2ludFxuICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEFkZCBhIG5vZGUgdG8gYSBncmFwaCBvYmplY3QuIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub2RlIHdpdGhcbiAqIHRoZSBzYW1lIGlkLCB0aGVpciBhdHRyaWJ1dGVzIHdpbGwgYmUgbWVyZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZE5vZGUoZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIGksIGxlbjtcbiAgdmFyIGN1cnJlbnQgPSBudWxsOyAvLyBmaW5kIHJvb3QgZ3JhcGggKGluIGNhc2Ugb2Ygc3ViZ3JhcGgpXG5cbiAgdmFyIGdyYXBocyA9IFtncmFwaF07IC8vIGxpc3Qgd2l0aCBhbGwgZ3JhcGhzIGZyb20gY3VycmVudCBncmFwaCB0byByb290IGdyYXBoXG5cbiAgdmFyIHJvb3QgPSBncmFwaDtcblxuICB3aGlsZSAocm9vdC5wYXJlbnQpIHtcbiAgICBncmFwaHMucHVzaChyb290LnBhcmVudCk7XG4gICAgcm9vdCA9IHJvb3QucGFyZW50O1xuICB9IC8vIGZpbmQgZXhpc3Rpbmcgbm9kZSAoYXQgcm9vdCBsZXZlbCkgYnkgaXRzIGlkXG5cblxuICBpZiAocm9vdC5ub2Rlcykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJvb3Qubm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChub2RlLmlkID09PSByb290Lm5vZGVzW2ldLmlkKSB7XG4gICAgICAgIGN1cnJlbnQgPSByb290Lm5vZGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWN1cnJlbnQpIHtcbiAgICAvLyB0aGlzIGlzIGEgbmV3IG5vZGVcbiAgICBjdXJyZW50ID0ge1xuICAgICAgaWQ6IG5vZGUuaWRcbiAgICB9O1xuXG4gICAgaWYgKGdyYXBoLm5vZGUpIHtcbiAgICAgIC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgICAgY3VycmVudC5hdHRyID0gbWVyZ2UkMShjdXJyZW50LmF0dHIsIGdyYXBoLm5vZGUpO1xuICAgIH1cbiAgfSAvLyBhZGQgbm9kZSB0byB0aGlzIChzdWIpZ3JhcGggYW5kIGFsbCBpdHMgcGFyZW50IGdyYXBoc1xuXG5cbiAgZm9yIChpID0gZ3JhcGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIF9jb250ZXh0O1xuXG4gICAgdmFyIGcgPSBncmFwaHNbaV07XG5cbiAgICBpZiAoIWcubm9kZXMpIHtcbiAgICAgIGcubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXhPZihfY29udGV4dCA9IGcubm9kZXMpLmNhbGwoX2NvbnRleHQsIGN1cnJlbnQpID09PSAtMSkge1xuICAgICAgZy5ub2Rlcy5wdXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfSAvLyBtZXJnZSBhdHRyaWJ1dGVzXG5cblxuICBpZiAobm9kZS5hdHRyKSB7XG4gICAgY3VycmVudC5hdHRyID0gbWVyZ2UkMShjdXJyZW50LmF0dHIsIG5vZGUuYXR0cik7XG4gIH1cbn1cbi8qKlxuICogQWRkIGFuIGVkZ2UgdG8gYSBncmFwaCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBlZGdlXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRFZGdlKGdyYXBoLCBlZGdlKSB7XG4gIGlmICghZ3JhcGguZWRnZXMpIHtcbiAgICBncmFwaC5lZGdlcyA9IFtdO1xuICB9XG5cbiAgZ3JhcGguZWRnZXMucHVzaChlZGdlKTtcblxuICBpZiAoZ3JhcGguZWRnZSkge1xuICAgIHZhciBhdHRyID0gbWVyZ2UkMSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuXG4gICAgZWRnZS5hdHRyID0gbWVyZ2UkMShhdHRyLCBlZGdlLmF0dHIpOyAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGVkZ2UgdG8gYSBncmFwaCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgb2JqZWN0fSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG9iamVjdH0gdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IGF0dHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGVkZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKSB7XG4gIHZhciBlZGdlID0ge1xuICAgIGZyb206IGZyb20sXG4gICAgdG86IHRvLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcblxuICBpZiAoZ3JhcGguZWRnZSkge1xuICAgIGVkZ2UuYXR0ciA9IG1lcmdlJDEoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgfVxuXG4gIGVkZ2UuYXR0ciA9IG1lcmdlJDEoZWRnZS5hdHRyIHx8IHt9LCBhdHRyKTsgLy8gbWVyZ2UgYXR0cmlidXRlc1xuICAvLyBNb3ZlIGFycm93cyBhdHRyaWJ1dGUgZnJvbSBhdHRyIHRvIGVkZ2UgdGVtcG9yYWxseSBjcmVhdGVkIGluXG4gIC8vIHBhcnNlQXR0cmlidXRlTGlzdCgpLlxuXG4gIGlmIChhdHRyICE9IG51bGwpIHtcbiAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShcImFycm93c1wiKSAmJiBhdHRyW1wiYXJyb3dzXCJdICE9IG51bGwpIHtcbiAgICAgIGVkZ2VbXCJhcnJvd3NcIl0gPSB7XG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBhdHRyLmFycm93cy50eXBlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhdHRyW1wiYXJyb3dzXCJdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWRnZTtcbn1cbi8qKlxuICogR2V0IG5leHQgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZG90IGZpbGUuXG4gKiBUaGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgYXJlIGF2YWlsYWJsZSBhcyB0b2tlbiBhbmQgdG9rZW5UeXBlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUb2tlbigpIHtcbiAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7XG4gIHRva2VuID0gXCJcIjsgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG5cbiAgd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcclwiKSB7XG4gICAgLy8gc3BhY2UsIHRhYiwgZW50ZXJcbiAgICBuZXh0KCk7XG4gIH1cblxuICBkbyB7XG4gICAgdmFyIGlzQ29tbWVudCA9IGZhbHNlOyAvLyBza2lwIGNvbW1lbnRcblxuICAgIGlmIChjID09PSBcIiNcIikge1xuICAgICAgLy8gZmluZCB0aGUgcHJldmlvdXMgbm9uLXNwYWNlIGNoYXJhY3RlclxuICAgICAgdmFyIGkgPSBpbmRleCQxIC0gMTtcblxuICAgICAgd2hpbGUgKGRvdC5jaGFyQXQoaSkgPT09IFwiIFwiIHx8IGRvdC5jaGFyQXQoaSkgPT09IFwiXFx0XCIpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG90LmNoYXJBdChpKSA9PT0gXCJcXG5cIiB8fCBkb3QuY2hhckF0KGkpID09PSBcIlwiKSB7XG4gICAgICAgIC8vIHRoZSAjIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUsIHRoaXMgaXMgaW5kZWVkIGEgbGluZSBjb21tZW50XG4gICAgICAgIHdoaWxlIChjICE9IFwiXCIgJiYgYyAhPSBcIlxcblwiKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIvXCIpIHtcbiAgICAgIC8vIHNraXAgbGluZSBjb21tZW50XG4gICAgICB3aGlsZSAoYyAhPSBcIlwiICYmIGMgIT0gXCJcXG5cIikge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGMgPT09IFwiL1wiICYmIG5leHRQcmV2aWV3KCkgPT09IFwiKlwiKSB7XG4gICAgICAvLyBza2lwIGJsb2NrIGNvbW1lbnRcbiAgICAgIHdoaWxlIChjICE9IFwiXCIpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiKlwiICYmIG5leHRQcmV2aWV3KCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgLy8gZW5kIG9mIGJsb2NrIGNvbW1lbnQgZm91bmQuIHNraXAgdGhlc2UgbGFzdCB0d28gY2hhcmFjdGVyc1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgfSAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcblxuXG4gICAgd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcclwiKSB7XG4gICAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfSB3aGlsZSAoaXNDb21tZW50KTsgLy8gY2hlY2sgZm9yIGVuZCBvZiBkb3QgZmlsZVxuXG5cbiAgaWYgKGMgPT09IFwiXCIpIHtcbiAgICAvLyB0b2tlbiBpcyBzdGlsbCBlbXB0eVxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMiBjaGFyYWN0ZXJzXG5cblxuICB2YXIgYzIgPSBjICsgbmV4dFByZXZpZXcoKTtcblxuICBpZiAoREVMSU1JVEVSU1tjMl0pIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHRva2VuID0gYzI7XG4gICAgbmV4dCgpO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGRlbGltaXRlcnMgY29uc2lzdGluZyBvZiAxIGNoYXJhY3RlclxuXG5cbiAgaWYgKERFTElNSVRFUlNbY10pIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHRva2VuID0gYztcbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNoZWNrIGZvciBhbiBpZGVudGlmaWVyIChudW1iZXIgb3Igc3RyaW5nKVxuICAvLyBUT0RPOiBtb3JlIHByZWNpc2UgcGFyc2luZyBvZiBudW1iZXJzL3N0cmluZ3MgKGFuZCB0aGUgcG9ydCBzZXBhcmF0b3IgJzonKVxuXG5cbiAgaWYgKGlzQWxwaGFOdW1lcmljKGMpIHx8IGMgPT09IFwiLVwiKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG5cbiAgICB3aGlsZSAoaXNBbHBoYU51bWVyaWMoYykpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHRva2VuID0gZmFsc2U7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IFwidHJ1ZVwiKSB7XG4gICAgICB0b2tlbiA9IHRydWU7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih0b2tlbikpKSB7XG4gICAgICB0b2tlbiA9IE51bWJlcih0b2tlbik7IC8vIGNvbnZlcnQgdG8gbnVtYmVyXG4gICAgfVxuXG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLklERU5USUZJRVI7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNoZWNrIGZvciBhIHN0cmluZyBlbmNsb3NlZCBieSBkb3VibGUgcXVvdGVzXG5cblxuICBpZiAoYyA9PT0gJ1wiJykge1xuICAgIG5leHQoKTtcblxuICAgIHdoaWxlIChjICE9IFwiXCIgJiYgKGMgIT0gJ1wiJyB8fCBjID09PSAnXCInICYmIG5leHRQcmV2aWV3KCkgPT09ICdcIicpKSB7XG4gICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAvLyBza2lwIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcXFxcXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCJuXCIpIHtcbiAgICAgICAgLy8gSG9ub3IgYSBuZXdsaW5lIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICB0b2tlbiArPSBcIlxcblwiO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgfVxuXG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKGMgIT0gJ1wiJykge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0VuZCBvZiBzdHJpbmcgXCIgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLklERU5USUZJRVI7XG4gICAgcmV0dXJuO1xuICB9IC8vIHNvbWV0aGluZyB1bmtub3duIGlzIGZvdW5kLCB3cm9uZyBjaGFyYWN0ZXJzLCBhIHN5bnRheCBlcnJvclxuXG5cbiAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLlVOS05PV047XG5cbiAgd2hpbGUgKGMgIT0gXCJcIikge1xuICAgIHRva2VuICs9IGM7XG4gICAgbmV4dCgpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTeW50YXggZXJyb3IgaW4gcGFydCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCInKTtcbn1cbi8qKlxuICogUGFyc2UgYSBncmFwaC5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaFxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VHcmFwaCgpIHtcbiAgdmFyIGdyYXBoID0ge307XG4gIGZpcnN0KCk7XG4gIGdldFRva2VuKCk7IC8vIG9wdGlvbmFsIHN0cmljdCBrZXl3b3JkXG5cbiAgaWYgKHRva2VuID09PSBcInN0cmljdFwiKSB7XG4gICAgZ3JhcGguc3RyaWN0ID0gdHJ1ZTtcbiAgICBnZXRUb2tlbigpO1xuICB9IC8vIGdyYXBoIG9yIGRpZ3JhcGgga2V5d29yZFxuXG5cbiAgaWYgKHRva2VuID09PSBcImdyYXBoXCIgfHwgdG9rZW4gPT09IFwiZGlncmFwaFwiKSB7XG4gICAgZ3JhcGgudHlwZSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gIH0gLy8gb3B0aW9uYWwgZ3JhcGggaWRcblxuXG4gIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgZ3JhcGguaWQgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICB9IC8vIG9wZW4gYW5nbGUgYnJhY2tldFxuXG5cbiAgaWYgKHRva2VuICE9IFwie1wiKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IHsgZXhwZWN0ZWRcIik7XG4gIH1cblxuICBnZXRUb2tlbigpOyAvLyBzdGF0ZW1lbnRzXG5cbiAgcGFyc2VTdGF0ZW1lbnRzKGdyYXBoKTsgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuXG4gIGlmICh0b2tlbiAhPSBcIn1cIikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkXCIpO1xuICB9XG5cbiAgZ2V0VG9rZW4oKTsgLy8gZW5kIG9mIGZpbGVcblxuICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkVuZCBvZiBmaWxlIGV4cGVjdGVkXCIpO1xuICB9XG5cbiAgZ2V0VG9rZW4oKTsgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcblxuICBkZWxldGUgZ3JhcGgubm9kZTtcbiAgZGVsZXRlIGdyYXBoLmVkZ2U7XG4gIGRlbGV0ZSBncmFwaC5ncmFwaDtcbiAgcmV0dXJuIGdyYXBoO1xufVxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgd2l0aCBzdGF0ZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRzKGdyYXBoKSB7XG4gIHdoaWxlICh0b2tlbiAhPT0gXCJcIiAmJiB0b2tlbiAhPSBcIn1cIikge1xuICAgIHBhcnNlU3RhdGVtZW50KGdyYXBoKTtcblxuICAgIGlmICh0b2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC4gQ2FuIGJlIGEgYW4gYXR0cmlidXRlIHN0YXRlbWVudCwgbm9kZVxuICogc3RhdGVtZW50LCBhIHNlcmllcyBvZiBub2RlIHN0YXRlbWVudHMgYW5kIGVkZ2Ugc3RhdGVtZW50cywgb3IgYVxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpIHtcbiAgLy8gcGFyc2Ugc3ViZ3JhcGhcbiAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG5cbiAgaWYgKHN1YmdyYXBoKSB7XG4gICAgLy8gZWRnZSBzdGF0ZW1lbnRzXG4gICAgcGFyc2VFZGdlKGdyYXBoLCBzdWJncmFwaCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnRcblxuXG4gIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVTdGF0ZW1lbnQoZ3JhcGgpO1xuXG4gIGlmIChhdHRyKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIHBhcnNlIG5vZGVcblxuXG4gIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIklkZW50aWZpZXIgZXhwZWN0ZWRcIik7XG4gIH1cblxuICB2YXIgaWQgPSB0b2tlbjsgLy8gaWQgY2FuIGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyXG5cbiAgZ2V0VG9rZW4oKTtcblxuICBpZiAodG9rZW4gPT09IFwiPVwiKSB7XG4gICAgLy8gaWQgc3RhdGVtZW50XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBleHBlY3RlZFwiKTtcbiAgICB9XG5cbiAgICBncmFwaFtpZF0gPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpOyAvLyBUT0RPOiBpbXBsZW1lbnQgY29tbWEgc2VwYXJhdGVkIGxpc3Qgd2l0aCBcImFfbGlzdDogSUQ9SUQgWycsJ10gW2FfbGlzdF0gXCJcbiAgfSBlbHNlIHtcbiAgICBwYXJzZU5vZGVTdGF0ZW1lbnQoZ3JhcGgsIGlkKTtcbiAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHN1YmdyYXBoXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoICAgIHBhcmVudCBncmFwaCBvYmplY3RcbiAqIEByZXR1cm5zIHtvYmplY3QgfCBudWxsfSBzdWJncmFwaFxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VTdWJncmFwaChncmFwaCkge1xuICB2YXIgc3ViZ3JhcGggPSBudWxsOyAvLyBvcHRpb25hbCBzdWJncmFwaCBrZXl3b3JkXG5cbiAgaWYgKHRva2VuID09PSBcInN1YmdyYXBoXCIpIHtcbiAgICBzdWJncmFwaCA9IHt9O1xuICAgIHN1YmdyYXBoLnR5cGUgPSBcInN1YmdyYXBoXCI7XG4gICAgZ2V0VG9rZW4oKTsgLy8gb3B0aW9uYWwgZ3JhcGggaWRcblxuICAgIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICBzdWJncmFwaC5pZCA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG4gIH0gLy8gb3BlbiBhbmdsZSBicmFja2V0XG5cblxuICBpZiAodG9rZW4gPT09IFwie1wiKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIGlmICghc3ViZ3JhcGgpIHtcbiAgICAgIHN1YmdyYXBoID0ge307XG4gICAgfVxuXG4gICAgc3ViZ3JhcGgucGFyZW50ID0gZ3JhcGg7XG4gICAgc3ViZ3JhcGgubm9kZSA9IGdyYXBoLm5vZGU7XG4gICAgc3ViZ3JhcGguZWRnZSA9IGdyYXBoLmVkZ2U7XG4gICAgc3ViZ3JhcGguZ3JhcGggPSBncmFwaC5ncmFwaDsgLy8gc3RhdGVtZW50c1xuXG4gICAgcGFyc2VTdGF0ZW1lbnRzKHN1YmdyYXBoKTsgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuXG4gICAgaWYgKHRva2VuICE9IFwifVwiKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkFuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZFwiKTtcbiAgICB9XG5cbiAgICBnZXRUb2tlbigpOyAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuXG4gICAgZGVsZXRlIHN1YmdyYXBoLm5vZGU7XG4gICAgZGVsZXRlIHN1YmdyYXBoLmVkZ2U7XG4gICAgZGVsZXRlIHN1YmdyYXBoLmdyYXBoO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5wYXJlbnQ7IC8vIHJlZ2lzdGVyIGF0IHRoZSBwYXJlbnQgZ3JhcGhcblxuICAgIGlmICghZ3JhcGguc3ViZ3JhcGhzKSB7XG4gICAgICBncmFwaC5zdWJncmFwaHMgPSBbXTtcbiAgICB9XG5cbiAgICBncmFwaC5zdWJncmFwaHMucHVzaChzdWJncmFwaCk7XG4gIH1cblxuICByZXR1cm4gc3ViZ3JhcGg7XG59XG4vKipcbiAqIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQgbGlrZSBcIm5vZGUgW3NoYXBlPWNpcmNsZSBmb250U2l6ZT0xNl1cIi5cbiAqIEF2YWlsYWJsZSBrZXl3b3JkcyBhcmUgJ25vZGUnLCAnZWRnZScsICdncmFwaCcuXG4gKiBUaGUgcHJldmlvdXMgbGlzdCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyB3aWxsIGJlIHJlcGxhY2VkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0ga2V5d29yZCBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBwYXJzZWQgYXR0cmlidXRlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZSwgZWRnZSwgZ3JhcGgpLCBvciBudWxsIGlmIG5vdGhpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHBhcnNlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlU3RhdGVtZW50KGdyYXBoKSB7XG4gIC8vIGF0dHJpYnV0ZSBzdGF0ZW1lbnRzXG4gIGlmICh0b2tlbiA9PT0gXCJub2RlXCIpIHtcbiAgICBnZXRUb2tlbigpOyAvLyBub2RlIGF0dHJpYnV0ZXNcblxuICAgIGdyYXBoLm5vZGUgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICByZXR1cm4gXCJub2RlXCI7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09IFwiZWRnZVwiKSB7XG4gICAgZ2V0VG9rZW4oKTsgLy8gZWRnZSBhdHRyaWJ1dGVzXG5cbiAgICBncmFwaC5lZGdlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwiZWRnZVwiO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSBcImdyYXBoXCIpIHtcbiAgICBnZXRUb2tlbigpOyAvLyBncmFwaCBhdHRyaWJ1dGVzXG5cbiAgICBncmFwaC5ncmFwaCA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcImdyYXBoXCI7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogcGFyc2UgYSBub2RlIHN0YXRlbWVudFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGlkXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZU5vZGVTdGF0ZW1lbnQoZ3JhcGgsIGlkKSB7XG4gIC8vIG5vZGUgc3RhdGVtZW50XG4gIHZhciBub2RlID0ge1xuICAgIGlkOiBpZFxuICB9O1xuICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuXG4gIGlmIChhdHRyKSB7XG4gICAgbm9kZS5hdHRyID0gYXR0cjtcbiAgfVxuXG4gIGFkZE5vZGUoZ3JhcGgsIG5vZGUpOyAvLyBlZGdlIHN0YXRlbWVudHNcblxuICBwYXJzZUVkZ2UoZ3JhcGgsIGlkKTtcbn1cbi8qKlxuICogUGFyc2UgYW4gZWRnZSBvciBhIHNlcmllcyBvZiBlZGdlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGZyb20gICAgICAgIElkIG9mIHRoZSBmcm9tIG5vZGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlRWRnZShncmFwaCwgZnJvbSkge1xuICB3aGlsZSAodG9rZW4gPT09IFwiLT5cIiB8fCB0b2tlbiA9PT0gXCItLVwiKSB7XG4gICAgdmFyIHRvO1xuICAgIHZhciB0eXBlID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgICB2YXIgc3ViZ3JhcGggPSBwYXJzZVN1YmdyYXBoKGdyYXBoKTtcblxuICAgIGlmIChzdWJncmFwaCkge1xuICAgICAgdG8gPSBzdWJncmFwaDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIklkZW50aWZpZXIgb3Igc3ViZ3JhcGggZXhwZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHRvID0gdG9rZW47XG4gICAgICBhZGROb2RlKGdyYXBoLCB7XG4gICAgICAgIGlkOiB0b1xuICAgICAgfSk7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH0gLy8gcGFyc2UgZWRnZSBhdHRyaWJ1dGVzXG5cblxuICAgIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7IC8vIGNyZWF0ZSBlZGdlXG5cbiAgICB2YXIgZWRnZSA9IGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKTtcbiAgICBhZGRFZGdlKGdyYXBoLCBlZGdlKTtcbiAgICBmcm9tID0gdG87XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzZXQgd2l0aCBhdHRyaWJ1dGVzLFxuICogZm9yIGV4YW1wbGUgW2xhYmVsPVwiMS4wMDBcIiwgc2hhcGU9c29saWRdXG4gKlxuICogQHJldHVybnMge29iamVjdCB8IG51bGx9IGF0dHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlTGlzdCgpIHtcbiAgdmFyIGk7XG4gIHZhciBhdHRyID0gbnVsbDsgLy8gZWRnZSBzdHlsZXMgb2YgZG90IGFuZCB2aXNcblxuICB2YXIgZWRnZVN0eWxlcyA9IHtcbiAgICBkYXNoZWQ6IHRydWUsXG4gICAgc29saWQ6IGZhbHNlLFxuICAgIGRvdHRlZDogWzEsIDVdXG4gIH07XG4gIC8qKlxuICAgKiBEZWZpbmUgYXJyb3cgdHlwZXMuXG4gICAqIHZpcyBjdXJyZW50bHkgc3VwcG9ydHMgdHlwZXMgZGVmaW5lZCBpbiAnYXJyb3dUeXBlcycuXG4gICAqIERldGFpbHMgb2YgYXJyb3cgc2hhcGVzIGFyZSBkZXNjcmliZWQgaW5cbiAgICogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvY29udGVudC9hcnJvdy1zaGFwZXNcbiAgICovXG5cbiAgdmFyIGFycm93VHlwZXMgPSB7XG4gICAgZG90OiBcImNpcmNsZVwiLFxuICAgIGJveDogXCJib3hcIixcbiAgICBjcm93OiBcImNyb3dcIixcbiAgICBjdXJ2ZTogXCJjdXJ2ZVwiLFxuICAgIGljdXJ2ZTogXCJpbnZfY3VydmVcIixcbiAgICBub3JtYWw6IFwidHJpYW5nbGVcIixcbiAgICBpbnY6IFwiaW52X3RyaWFuZ2xlXCIsXG4gICAgZGlhbW9uZDogXCJkaWFtb25kXCIsXG4gICAgdGVlOiBcImJhclwiLFxuICAgIHZlZTogXCJ2ZWVcIlxuICB9O1xuICAvKipcbiAgICogJ2F0dHJfbGlzdCcgY29udGFpbnMgYXR0cmlidXRlcyBmb3IgY2hlY2tpbmcgaWYgc29tZSBvZiB0aGVtIGFyZSBhZmZlY3RlZFxuICAgKiBsYXRlci4gRm9yIGluc3RhbmNlLCBib3RoIG9mICdhcnJvd2hlYWQnIGFuZCAnZGlyJyAoZWRnZSBzdHlsZSBkZWZpbmVkXG4gICAqIGluIERPVCkgbWFrZSBjaGFuZ2VzIHRvICdhcnJvd3MnIGF0dHJpYnV0ZSBpbiB2aXMuXG4gICAqL1xuXG4gIHZhciBhdHRyX2xpc3QgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIGF0dHJfbmFtZXMgPSBuZXcgQXJyYXkoKTsgLy8gdXNlZCBmb3IgY2hlY2tpbmcgdGhlIGNhc2UuXG4gIC8vIHBhcnNlIGF0dHJpYnV0ZXNcblxuICB3aGlsZSAodG9rZW4gPT09IFwiW1wiKSB7XG4gICAgZ2V0VG9rZW4oKTtcbiAgICBhdHRyID0ge307XG5cbiAgICB3aGlsZSAodG9rZW4gIT09IFwiXCIgJiYgdG9rZW4gIT0gXCJdXCIpIHtcbiAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBdHRyaWJ1dGUgbmFtZSBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIGlmICh0b2tlbiAhPSBcIj1cIikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkVxdWFsIHNpZ24gPSBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkF0dHJpYnV0ZSB2YWx1ZSBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gdG9rZW47IC8vIGNvbnZlcnQgZnJvbSBkb3Qgc3R5bGUgdG8gdmlzXG5cbiAgICAgIGlmIChuYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgdmFsdWUgPSBlZGdlU3R5bGVzW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycm93VHlwZTtcblxuICAgICAgaWYgKG5hbWUgPT09IFwiYXJyb3doZWFkXCIpIHtcbiAgICAgICAgYXJyb3dUeXBlID0gYXJyb3dUeXBlc1t2YWx1ZV07XG4gICAgICAgIG5hbWUgPSBcImFycm93c1wiO1xuICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGFycm93VHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IFwiYXJyb3d0YWlsXCIpIHtcbiAgICAgICAgYXJyb3dUeXBlID0gYXJyb3dUeXBlc1t2YWx1ZV07XG4gICAgICAgIG5hbWUgPSBcImFycm93c1wiO1xuICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXJyb3dUeXBlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgIGF0dHI6IGF0dHIsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBhdHRyX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW4gPT0gXCIsXCIpIHtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4gIT0gXCJdXCIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQnJhY2tldCBdIGV4cGVjdGVkXCIpO1xuICAgIH1cblxuICAgIGdldFRva2VuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFzIGV4cGxhaW5lZCBpbiBbMV0sIGdyYXBodml6IGhhcyBsaW1pdGF0aW9ucyBmb3IgY29tYmluYXRpb24gb2ZcbiAgICogYXJyb3dbaGVhZHx0YWlsXSBhbmQgZGlyLiBJZiBhdHRyaWJ1dGUgbGlzdCBpbmNsdWRlcyAnZGlyJyxcbiAgICogZm9sbG93aW5nIGNhc2VzIGp1c3QgYmUgc3VwcG9ydGVkLlxuICAgKiAgIDEuIGJvdGggb3Igbm9uZSArIGFycm93aGVhZCwgYXJyb3d0YWlsXG4gICAqICAgMi4gZm9yd2FyZCArIGFycm93aGVhZCAoYXJyb3d0YWlsIGlzIG5vdCBhZmZlZHRlZClcbiAgICogICAzLiBiYWNrICsgYXJyb3d0YWlsIChhcnJvd2hlYWQgaXMgbm90IGFmZmVjdGVkKVxuICAgKiBbMV0gaHR0cHM6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2F0dHJzLmh0bWwjaDp1bmRpcl9ub3RlXG4gICAqL1xuXG5cbiAgaWYgKGluY2x1ZGVzKGF0dHJfbmFtZXMpLmNhbGwoYXR0cl9uYW1lcywgXCJkaXJcIikpIHtcbiAgICB2YXIgaWR4ID0ge307IC8vIGdldCBpbmRleCBvZiAnYXJyb3dzJyBhbmQgJ2RpcidcblxuICAgIGlkeC5hcnJvd3MgPSB7fTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyX2xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gXCJhcnJvd3NcIikge1xuICAgICAgICBpZiAoYXR0cl9saXN0W2ldLnZhbHVlLnRvICE9IG51bGwpIHtcbiAgICAgICAgICBpZHguYXJyb3dzLnRvID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyX2xpc3RbaV0udmFsdWUuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgaWR4LmFycm93cy5mcm9tID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkludmFsaWQgdmFsdWUgb2YgYXJyb3dzXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGF0dHJfbGlzdFtpXS5uYW1lID09PSBcImRpclwiKSB7XG4gICAgICAgIGlkeC5kaXIgPSBpO1xuICAgICAgfVxuICAgIH0gLy8gZmlyc3QsIGFkZCBkZWZhdWx0IGFycm93IHNoYXBlIGlmIGl0IGlzIG5vdCBhc3NpZ25lZCB0byBhdm9pZCBlcnJvclxuXG5cbiAgICB2YXIgZGlyX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmRpcl0udmFsdWU7XG5cbiAgICBpZiAoIWluY2x1ZGVzKGF0dHJfbmFtZXMpLmNhbGwoYXR0cl9uYW1lcywgXCJhcnJvd3NcIikpIHtcbiAgICAgIGlmIChkaXJfdHlwZSA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJbnZhbGlkIGRpciB0eXBlIFwiJyArIGRpcl90eXBlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb21fdHlwZTtcbiAgICB2YXIgdG9fdHlwZTsgLy8gdXBkYXRlICdhcnJvd3MnIGF0dHJpYnV0ZSBmcm9tICdkaXInLlxuXG4gICAgaWYgKGRpcl90eXBlID09PSBcImJvdGhcIikge1xuICAgICAgLy8gYm90aCBvZiBzaGFwZXMgb2YgJ2Zyb20nIGFuZCAndG8nIGFyZSBnaXZlblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzcGxpY2UkMShhdHRyX2xpc3QpLmNhbGwoYXR0cl9saXN0LCBpZHguYXJyb3dzLmZyb20sIDEpOyAvLyBzaGFwZSBvZiAndG8nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCB0byAnZnJvbSdcblxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gb25seSBzaGFwZSBvZiAnZnJvbScgaXMgYXNzaWduZWQgYW5kIHVzZSBkZWZhdWx0IGZvciAndG8nXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiYmFja1wiKSB7XG4gICAgICAvLyBnaXZlbiBib3RoIG9mIHNoYXBlcywgYnV0IHVzZSBvbmx5ICdmcm9tJ1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBnaXZlbiBzaGFwZSBvZiAndG8nLCBidXQgZG9lcyBub3QgdXNlIGl0XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiXCI7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gaWR4LmFycm93cy50bztcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIGFzc2lnbiBnaXZlbiAnZnJvbScgc2hhcGVcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcIm5vbmVcIikge1xuICAgICAgdmFyIGlkeF9hcnJvdztcblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeF9hcnJvdyA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeF9hcnJvd10gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLm5hbWUsXG4gICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAvLyBnaXZlbiBib3RoIG9mIHNoYXBlcywgYnV0IHVzZSBvbmx5ICd0bydcbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiXCI7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBhc3NpZ24gZ2l2ZW4gJ3RvJyBzaGFwZVxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJcIjtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIGdpdmVuIHNoYXBlIG9mICdmcm9tJywgYnV0IGRvZXMgbm90IHVzZSBpdFxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgZnJvbV90eXBlID0gXCJcIjtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJbnZhbGlkIGRpciB0eXBlIFwiJyArIGRpcl90eXBlICsgJ1wiJyk7XG4gICAgfSAvLyByZW1vdmUgJ2RpcicgYXR0cmlidXRlIG5vIG5lZWQgYW55bW9yZVxuXG5cbiAgICBzcGxpY2UkMShhdHRyX2xpc3QpLmNhbGwoYXR0cl9saXN0LCBpZHguZGlyLCAxKTtcbiAgfSAvLyBwYXJzZSAncGVud2lkdGgnXG5cblxuICB2YXIgbm9mX2F0dHJfbGlzdDtcblxuICBpZiAoaW5jbHVkZXMoYXR0cl9uYW1lcykuY2FsbChhdHRyX25hbWVzLCBcInBlbndpZHRoXCIpKSB7XG4gICAgdmFyIHRtcF9hdHRyX2xpc3QgPSBbXTtcbiAgICBub2ZfYXR0cl9saXN0ID0gYXR0cl9saXN0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBub2ZfYXR0cl9saXN0OyBpKyspIHtcbiAgICAgIC8vIGV4Y2x1ZGUgJ3dpZHRoJyBmcm9tIGF0dHJfbGlzdCBpZiAncGVud2lkdGgnIGV4aXN0c1xuICAgICAgaWYgKGF0dHJfbGlzdFtpXS5uYW1lICE9PSBcIndpZHRoXCIpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS5uYW1lID09PSBcInBlbndpZHRoXCIpIHtcbiAgICAgICAgICBhdHRyX2xpc3RbaV0ubmFtZSA9IFwid2lkdGhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcF9hdHRyX2xpc3QucHVzaChhdHRyX2xpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJfbGlzdCA9IHRtcF9hdHRyX2xpc3Q7XG4gIH1cblxuICBub2ZfYXR0cl9saXN0ID0gYXR0cl9saXN0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbm9mX2F0dHJfbGlzdDsgaSsrKSB7XG4gICAgc2V0VmFsdWUoYXR0cl9saXN0W2ldLmF0dHIsIGF0dHJfbGlzdFtpXS5uYW1lLCBhdHRyX2xpc3RbaV0udmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGF0dHI7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN5bnRheCBlcnJvciB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgdG9rZW4gYW5kIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7U3ludGF4RXJyb3J9IGVyclxuICovXG5cblxuZnVuY3Rpb24gbmV3U3ludGF4RXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UgKyAnLCBnb3QgXCInICsgY2hvcCh0b2tlbiwgMzApICsgJ1wiIChjaGFyICcgKyBpbmRleCQxICsgXCIpXCIpO1xufVxuLyoqXG4gKiBDaG9wIG9mZiB0ZXh0IGFmdGVyIGEgbWF4aW11bSBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGNob3AodGV4dCwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGggPyB0ZXh0IDogdGV4dC5zdWJzdHIoMCwgMjcpICsgXCIuLi5cIjtcbn1cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIGZuIGZvciBlYWNoIHBhaXIgb2YgZWxlbWVudHMgaW4gdHdvIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTFcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoMihhcnJheTEsIGFycmF5MiwgZm4pIHtcbiAgaWYgKGlzQXJyYXkkMihhcnJheTEpKSB7XG4gICAgZm9yRWFjaCQyKGFycmF5MSkuY2FsbChhcnJheTEsIGZ1bmN0aW9uIChlbGVtMSkge1xuICAgICAgaWYgKGlzQXJyYXkkMihhcnJheTIpKSB7XG4gICAgICAgIGZvckVhY2gkMihhcnJheTIpLmNhbGwoYXJyYXkyLCBmdW5jdGlvbiAoZWxlbTIpIHtcbiAgICAgICAgICBmbihlbGVtMSwgZWxlbTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKGVsZW0xLCBhcnJheTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0FycmF5JDIoYXJyYXkyKSkge1xuICAgICAgZm9yRWFjaCQyKGFycmF5MikuY2FsbChhcnJheTIsIGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICBmbihhcnJheTEsIGVsZW0yKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbihhcnJheTEsIGFycmF5Mik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFNldCBhIG5lc3RlZCBwcm9wZXJ0eSBvbiBhbiBvYmplY3RcbiAqIFdoZW4gbmVzdGVkIG9iamVjdHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICogRm9yIGV4YW1wbGUgc2V0UHJvcCh7fSwgJ2ZvbnQuY29sb3InLCAncmVkJykgd2lsbCByZXR1cm4ge2ZvbnQ6IHtjb2xvcjogJ3JlZCd9fVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICAgQSBkb3Qgc2VwYXJhdGVkIHN0cmluZyBsaWtlICdmb250LmNvbG9yJ1xuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBSZXR1cm5zIHRoZSBvcmlnaW5hbCBvYmplY3QsIGFsbG93cyBmb3IgY2hhaW5pbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRQcm9wKG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHZhciBwcm9wID0gbmFtZXMucG9wKCk7IC8vIHRyYXZlcnNlIG92ZXIgdGhlIG5lc3RlZCBvYmplY3RzXG5cbiAgdmFyIG9iaiA9IG9iamVjdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcblxuICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgb2JqW25hbWVdID0ge307XG4gICAgfVxuXG4gICAgb2JqID0gb2JqW25hbWVdO1xuICB9IC8vIHNldCB0aGUgcHJvcGVydHkgdmFsdWVcblxuXG4gIG9ialtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzIHRvIHRoZWlyIHZpcy5qcyBlcXVpdmFsZW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0ciAgICAgT2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBwaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdmlzLmpzIGF0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnZlcnRBdHRyKGF0dHIsIG1hcHBpbmcpIHtcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gYXR0cikge1xuICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgdmlzUHJvcCA9IG1hcHBpbmdbcHJvcF07XG5cbiAgICAgIGlmIChpc0FycmF5JDIodmlzUHJvcCkpIHtcbiAgICAgICAgZm9yRWFjaCQyKHZpc1Byb3ApLmNhbGwodmlzUHJvcCwgZnVuY3Rpb24gKHZpc1Byb3BJKSB7XG4gICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3BJLCBhdHRyW3Byb3BdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNQcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFByb3AoY29udmVydGVkLCBwcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIG1hcCBjb250YWluaW5nXG4gKiB3aXRoIG5vZGVzIGFuZCBlZGdlcyBpbiB0aGUgZm9ybWF0IG9mIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaERhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIERPVFRvR3JhcGgoZGF0YSkge1xuICAvLyBwYXJzZSB0aGUgRE9UIGZpbGVcbiAgdmFyIGRvdERhdGEgPSBwYXJzZURPVChkYXRhKTtcbiAgdmFyIGdyYXBoRGF0YSA9IHtcbiAgICBub2RlczogW10sXG4gICAgZWRnZXM6IFtdLFxuICAgIG9wdGlvbnM6IHt9XG4gIH07IC8vIGNvcHkgdGhlIG5vZGVzXG5cbiAgaWYgKGRvdERhdGEubm9kZXMpIHtcbiAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgZm9yRWFjaCQyKF9jb250ZXh0MiA9IGRvdERhdGEubm9kZXMpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZG90Tm9kZSkge1xuICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgaWQ6IGRvdE5vZGUuaWQsXG4gICAgICAgIGxhYmVsOiBTdHJpbmcoZG90Tm9kZS5sYWJlbCB8fCBkb3ROb2RlLmlkKVxuICAgICAgfTtcbiAgICAgIG1lcmdlJDEoZ3JhcGhOb2RlLCBjb252ZXJ0QXR0cihkb3ROb2RlLmF0dHIsIE5PREVfQVRUUl9NQVBQSU5HKSk7XG5cbiAgICAgIGlmIChncmFwaE5vZGUuaW1hZ2UpIHtcbiAgICAgICAgZ3JhcGhOb2RlLnNoYXBlID0gXCJpbWFnZVwiO1xuICAgICAgfVxuXG4gICAgICBncmFwaERhdGEubm9kZXMucHVzaChncmFwaE5vZGUpO1xuICAgIH0pO1xuICB9IC8vIGNvcHkgdGhlIGVkZ2VzXG5cblxuICBpZiAoZG90RGF0YS5lZGdlcykge1xuICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGVkZ2UgaW4gRE9UIGZvcm1hdCB0byBhbiBlZGdlIHdpdGggVmlzR3JhcGggZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG90RWRnZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoRWRnZVxuICAgICAqL1xuICAgIHZhciBjb252ZXJ0RWRnZSA9IGZ1bmN0aW9uIGNvbnZlcnRFZGdlKGRvdEVkZ2UpIHtcbiAgICAgIHZhciBncmFwaEVkZ2UgPSB7XG4gICAgICAgIGZyb206IGRvdEVkZ2UuZnJvbSxcbiAgICAgICAgdG86IGRvdEVkZ2UudG9cbiAgICAgIH07XG4gICAgICBtZXJnZSQxKGdyYXBoRWRnZSwgY29udmVydEF0dHIoZG90RWRnZS5hdHRyLCBFREdFX0FUVFJfTUFQUElORykpOyAvLyBBZGQgYXJyb3dzIGF0dHJpYnV0ZSB0byBkZWZhdWx0IHN0eWxlZCBhcnJvdy5cbiAgICAgIC8vIFRoZSByZWFzb24gd2h5IGRlZmF1bHQgc3R5bGUgaXMgbm90IGFkZGVkIGluIHBhcnNlQXR0cmlidXRlTGlzdCgpIGlzXG4gICAgICAvLyBiZWNhdXNlIG9ubHkgZGVmYXVsdCBpcyBjbGVhcmVkIGJlZm9yZSBoZXJlLlxuXG4gICAgICBpZiAoZ3JhcGhFZGdlLmFycm93cyA9PSBudWxsICYmIGRvdEVkZ2UudHlwZSA9PT0gXCItPlwiKSB7XG4gICAgICAgIGdyYXBoRWRnZS5hcnJvd3MgPSBcInRvXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFwaEVkZ2U7XG4gICAgfTtcblxuICAgIGZvckVhY2gkMihfY29udGV4dDMgPSBkb3REYXRhLmVkZ2VzKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGRvdEVkZ2UpIHtcbiAgICAgIHZhciBmcm9tLCB0bztcblxuICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBmcm9tID0gZG90RWRnZS5mcm9tLm5vZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHtcbiAgICAgICAgICBpZDogZG90RWRnZS5mcm9tXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRvID0gZG90RWRnZS50by5ub2RlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLnRvXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS5mcm9tLmVkZ2VzKSB7XG4gICAgICAgIHZhciBfY29udGV4dDQ7XG5cbiAgICAgICAgZm9yRWFjaCQyKF9jb250ZXh0NCA9IGRvdEVkZ2UuZnJvbS5lZGdlcykuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3JFYWNoMihmcm9tLCB0bywgZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBzdWJFZGdlID0gY3JlYXRlRWRnZShncmFwaERhdGEsIGZyb20uaWQsIHRvLmlkLCBkb3RFZGdlLnR5cGUsIGRvdEVkZ2UuYXR0cik7XG4gICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLnRvLmVkZ2VzKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG5cbiAgICAgICAgZm9yRWFjaCQyKF9jb250ZXh0NSA9IGRvdEVkZ2UudG8uZWRnZXMpLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBjb3B5IHRoZSBvcHRpb25zXG5cblxuICBpZiAoZG90RGF0YS5hdHRyKSB7XG4gICAgZ3JhcGhEYXRhLm9wdGlvbnMgPSBkb3REYXRhLmF0dHI7XG4gIH1cblxuICByZXR1cm4gZ3JhcGhEYXRhO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby12YXIgKi9cblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuXG52YXIgZG90cGFyc2VyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHBhcnNlRE9UOiBwYXJzZURPVCxcblx0RE9UVG9HcmFwaDogRE9UVG9HcmFwaFxufSk7XG5cbi8qKlxyXG4gKiBDb252ZXJ0IEdlcGhpIHRvIFZpcy5cclxuICpcclxuICogQHBhcmFtIGdlcGhpSlNPTiAtIFRoZSBwYXJzZWQgSlNPTiBkYXRhIGluIEdlcGhpIGZvcm1hdC5cclxuICogQHBhcmFtIG9wdGlvbnNPYmogLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgZGF0YSByZWFkeSB0byBiZSB1c2VkIGluIFZpcy5cclxuICovXG5mdW5jdGlvbiBwYXJzZUdlcGhpKGdlcGhpSlNPTiwgb3B0aW9uc09iaikge1xuICB2YXIgX2NvbnRleHQ7XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZWRnZXM6IHtcbiAgICAgIGluaGVyaXRDb2xvcjogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVzOiB7XG4gICAgICBmaXhlZDogZmFsc2UsXG4gICAgICBwYXJzZUNvbG9yOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBpZiAob3B0aW9uc09iaiAhPSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnNPYmouZml4ZWQgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5ub2Rlcy5maXhlZCA9IG9wdGlvbnNPYmouZml4ZWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNPYmoucGFyc2VDb2xvciAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLm5vZGVzLnBhcnNlQ29sb3IgPSBvcHRpb25zT2JqLnBhcnNlQ29sb3I7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNPYmouaW5oZXJpdENvbG9yICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID0gb3B0aW9uc09iai5pbmhlcml0Q29sb3I7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdFZGdlcyA9IGdlcGhpSlNPTi5lZGdlcztcblxuICB2YXIgdkVkZ2VzID0gbWFwJDMoZ0VkZ2VzKS5jYWxsKGdFZGdlcywgZnVuY3Rpb24gKGdFZGdlKSB7XG4gICAgdmFyIHZFZGdlID0ge1xuICAgICAgZnJvbTogZ0VkZ2Uuc291cmNlLFxuICAgICAgaWQ6IGdFZGdlLmlkLFxuICAgICAgdG86IGdFZGdlLnRhcmdldFxuICAgIH07XG5cbiAgICBpZiAoZ0VkZ2UuYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICB2RWRnZS5hdHRyaWJ1dGVzID0gZ0VkZ2UuYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICBpZiAoZ0VkZ2UubGFiZWwgIT0gbnVsbCkge1xuICAgICAgdkVkZ2UubGFiZWwgPSBnRWRnZS5sYWJlbDtcbiAgICB9XG5cbiAgICBpZiAoZ0VkZ2UuYXR0cmlidXRlcyAhPSBudWxsICYmIGdFZGdlLmF0dHJpYnV0ZXMudGl0bGUgIT0gbnVsbCkge1xuICAgICAgdkVkZ2UudGl0bGUgPSBnRWRnZS5hdHRyaWJ1dGVzLnRpdGxlO1xuICAgIH1cblxuICAgIGlmIChnRWRnZS50eXBlID09PSBcIkRpcmVjdGVkXCIpIHtcbiAgICAgIHZFZGdlLmFycm93cyA9IFwidG9cIjtcbiAgICB9IC8vIGVkZ2VbJ3ZhbHVlJ10gPSBnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwgPyBnRWRnZS5hdHRyaWJ1dGVzLldlaWdodCA6IHVuZGVmaW5lZDtcbiAgICAvLyBlZGdlWyd3aWR0aCddID0gZWRnZVsndmFsdWUnXSAhPSBudWxsID8gdW5kZWZpbmVkIDogZWRnZWdFZGdlLnNpemU7XG5cblxuICAgIGlmIChnRWRnZS5jb2xvciAmJiBvcHRpb25zLmVkZ2VzLmluaGVyaXRDb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgIHZFZGdlLmNvbG9yID0gZ0VkZ2UuY29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZFZGdlO1xuICB9KTtcblxuICB2YXIgdk5vZGVzID0gbWFwJDMoX2NvbnRleHQgPSBnZXBoaUpTT04ubm9kZXMpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChnTm9kZSkge1xuICAgIHZhciB2Tm9kZSA9IHtcbiAgICAgIGlkOiBnTm9kZS5pZCxcbiAgICAgIGZpeGVkOiBvcHRpb25zLm5vZGVzLmZpeGVkICYmIGdOb2RlLnggIT0gbnVsbCAmJiBnTm9kZS55ICE9IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGdOb2RlLmF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgdk5vZGUuYXR0cmlidXRlcyA9IGdOb2RlLmF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLmxhYmVsID0gZ05vZGUubGFiZWw7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLnNpemUgIT0gbnVsbCkge1xuICAgICAgdk5vZGUuc2l6ZSA9IGdOb2RlLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLmF0dHJpYnV0ZXMgIT0gbnVsbCAmJiBnTm9kZS5hdHRyaWJ1dGVzLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnRpdGxlID0gZ05vZGUuYXR0cmlidXRlcy50aXRsZTtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUudGl0bGUgIT0gbnVsbCkge1xuICAgICAgdk5vZGUudGl0bGUgPSBnTm9kZS50aXRsZTtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUueCAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS54ID0gZ05vZGUueDtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUueSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS55ID0gZ05vZGUueTtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUuY29sb3IgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9PT0gdHJ1ZSkge1xuICAgICAgICB2Tm9kZS5jb2xvciA9IGdOb2RlLmNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdk5vZGUuY29sb3IgPSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgYm9yZGVyOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgICAgYm9yZGVyOiBnTm9kZS5jb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgICAgYm9yZGVyOiBnTm9kZS5jb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdk5vZGU7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbm9kZXM6IHZOb2RlcyxcbiAgICBlZGdlczogdkVkZ2VzXG4gIH07XG59XG5cbnZhciBnZXBoaVBhcnNlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRwYXJzZUdlcGhpOiBwYXJzZUdlcGhpXG59KTtcblxuLy8gRW5nbGlzaFxudmFyIGVuID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJDbGljayBpbiBhbiBlbXB0eSBzcGFjZSB0byBwbGFjZSBhIG5ldyBub2RlLlwiLFxuICBhZGRFZGdlOiBcIkFkZCBFZGdlXCIsXG4gIGFkZE5vZGU6IFwiQWRkIE5vZGVcIixcbiAgYmFjazogXCJCYWNrXCIsXG4gIGNsb3NlOiBcIkNsb3NlXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJDYW5ub3QgbGluayBlZGdlcyB0byBhIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJEZWxldGUgc2VsZWN0ZWRcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGNhbm5vdCBiZSBkZWxldGVkLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpY2sgb24gYSBub2RlIGFuZCBkcmFnIHRoZSBlZGdlIHRvIGFub3RoZXIgbm9kZSB0byBjb25uZWN0IHRoZW0uXCIsXG4gIGVkaXQ6IFwiRWRpdFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGNhbm5vdCBiZSBlZGl0ZWQuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXQgRWRnZVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaWNrIG9uIHRoZSBjb250cm9sIHBvaW50cyBhbmQgZHJhZyB0aGVtIHRvIGEgbm9kZSB0byBjb25uZWN0IHRvIGl0LlwiLFxuICBlZGl0Tm9kZTogXCJFZGl0IE5vZGVcIlxufTsgLy8gR2VybWFuXG5cbnZhciBkZSA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS2xpY2tlIGF1ZiBlaW5lIGZyZWllIFN0ZWxsZSwgdW0gZWluZW4gbmV1ZW4gS25vdGVuIHp1IHBsYXppZXJlbi5cIixcbiAgYWRkRWRnZTogXCJLYW50ZSBoaW56dWZcXHhGQ2dlblwiLFxuICBhZGROb2RlOiBcIktub3RlbiBoaW56dWZcXHhGQ2dlblwiLFxuICBiYWNrOiBcIlp1clxceEZDY2tcIixcbiAgY2xvc2U6IFwiU2NobGllw59lblwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiRXMgaXN0IG5pY2h0IG1cXHhGNmdsaWNoLCBLYW50ZW4gbWl0IENsdXN0ZXJuIHp1IHZlcmJpbmRlbi5cIixcbiAgZGVsOiBcIkxcXHhGNnNjaGUgQXVzd2FobFwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlciBrXFx4RjZubmVuIG5pY2h0IGdlbFxceEY2c2NodCB3ZXJkZW4uXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGVpbmVuIEtub3RlbiB1bmQgemllaGUgZGllIEthbnRlIHp1IGVpbmVtIGFuZGVyZW4gS25vdGVuLCB1bSBkaWVzZSB6dSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXQ6IFwiRWRpdGllcmVuXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlciBrXFx4RjZubmVuIG5pY2h0IGVkaXRpZXJ0IHdlcmRlbi5cIixcbiAgZWRpdEVkZ2U6IFwiS2FudGUgZWRpdGllcmVuXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiS2xpY2tlIGF1ZiBkaWUgVmVyYmluZHVuZ3NwdW5rdGUgdW5kIHppZWhlIGRpZXNlIGF1ZiBlaW5lbiBLbm90ZW4sIHVtIHNpZSB6dSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXROb2RlOiBcIktub3RlbiBlZGl0aWVyZW5cIlxufTsgLy8gU3BhbmlzaFxuXG52YXIgZXMgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkhhZ2EgY2xpYyBlbiB1biBsdWdhciB2YWNcXHhFRG8gcGFyYSBjb2xvY2FyIHVuIG51ZXZvIG5vZG8uXCIsXG4gIGFkZEVkZ2U6IFwiQVxceEYxYWRpciBhcmlzdGFcIixcbiAgYWRkTm9kZTogXCJBXFx4RjFhZGlyIG5vZG9cIixcbiAgYmFjazogXCJBdHJcXHhFMXNcIixcbiAgY2xvc2U6IFwiQ2VycmFyXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJObyBzZSBwdWVkZSBjb25lY3RhciB1bmEgYXJpc3RhIGEgdW4gZ3J1cG8uXCIsXG4gIGRlbDogXCJFbGltaW5hciBzZWxlY2NpXFx4RjNuXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJObyBlcyBwb3NpYmxlIGVsaW1pbmFyIGdydXBvcy5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkhhZ2EgY2xpYyBlbiB1biBub2RvIHkgYXJyYXN0cmUgbGEgYXJpc3RhIGhhY2lhIG90cm8gbm9kbyBwYXJhIGNvbmVjdGFybG9zLlwiLFxuICBlZGl0OiBcIkVkaXRhclwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIk5vIGVzIHBvc2libGUgZWRpdGFyIGdydXBvcy5cIixcbiAgZWRpdEVkZ2U6IFwiRWRpdGFyIGFyaXN0YVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkhhZ2EgY2xpYyBlbiB1biBwdW50byBkZSBjb250cm9sIHkgYXJyYXN0cmVsbyBhIHVuIG5vZG8gcGFyYSBjb25lY3RhcmxvLlwiLFxuICBlZGl0Tm9kZTogXCJFZGl0YXIgbm9kb1wiXG59OyAvL0l0YWxpYW5vXG5cbnZhciBpdCA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpY2NhIHBlciBhZ2dpdW5nZXJlIHVuIG51b3ZvIG5vZG9cIixcbiAgYWRkRWRnZTogXCJBZ2dpdW5naSB1biB2ZXJ0aWNlXCIsXG4gIGFkZE5vZGU6IFwiQWdnaXVuZ2kgdW4gbm9kb1wiLFxuICBiYWNrOiBcIkluZGlldHJvXCIsXG4gIGNsb3NlOiBcIkNoaXVkZXJlXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOb24gc2kgcG9zc29ubyBjb2xsZWdhcmUgdmVydGljaSBhZCB1biBjbHVzdGVyXCIsXG4gIGRlbDogXCJDYW5jZWxsYSBsYSBzZWxlemlvbmVcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkkgY2x1c3RlciBub24gcG9zc29ubyBlc3NlcmUgY2FuY2VsbGF0aVwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpY2NhIHN1IHVuIG5vZG8gZSB0cmFzY2luYWxvIGFkIHVuIGFsdHJvIG5vZG8gcGVyIGNvbm5ldHRlcmxpLlwiLFxuICBlZGl0OiBcIk1vZGlmaWNhXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiSSBjbHVzdGVycyBub24gcG9zc29ubyBlc3NlcmUgbW9kaWZpY2F0aS5cIixcbiAgZWRpdEVkZ2U6IFwiTW9kaWZpY2EgaWwgdmVydGljZVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaWNjYSBzdWkgUHVudGkgZGkgY29udHJvbGxvIGUgdHJhc2NpbmFsaSBhZCB1biBub2RvIHBlciBjb25uZXR0ZXJsaS5cIixcbiAgZWRpdE5vZGU6IFwiTW9kaWZpY2EgaWwgbm9kb1wiXG59OyAvLyBEdXRjaFxuXG52YXIgbmwgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIktsaWsgb3AgZWVuIGxlZWcgZ2ViaWVkIG9tIGVlbiBuaWV1d2Ugbm9kZSB0ZSBtYWtlbi5cIixcbiAgYWRkRWRnZTogXCJMaW5rIHRvZXZvZWdlblwiLFxuICBhZGROb2RlOiBcIk5vZGUgdG9ldm9lZ2VuXCIsXG4gIGJhY2s6IFwiVGVydWdcIixcbiAgY2xvc2U6IFwiU2x1aXRlblwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiS2FuIGdlZW4gbGluayBtYWtlbiBuYWFyIGVlbiBjbHVzdGVyLlwiLFxuICBkZWw6IFwiU2VsZWN0aWUgdmVyd2lqZGVyZW5cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiB2ZXJ3aWpkZXJkLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiS2xpayBvcCBlZW4gbm9kZSBlbiBzbGVlcCBkZSBsaW5rIG5hYXIgZWVuIGFuZGVyZSBub2RlIG9tIHplIHRlIHZlcmJpbmRlbi5cIixcbiAgZWRpdDogXCJXaWp6aWdlblwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiBhYW5nZXBhc3QuXCIsXG4gIGVkaXRFZGdlOiBcIkxpbmsgd2lqemlnZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJLbGlrIG9wIGRlIHZlcmJpbmRpbmdzcHVudGVuIGVuIHNsZWVwIHplIG5hYXIgZWVuIG5vZGUgb20gZGFhcm1lZSB0ZSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXROb2RlOiBcIk5vZGUgd2lqemlnZW5cIlxufTsgLy8gUG9ydHVndWVzZSBCcmF6aWxcblxudmFyIHB0ID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJDbGlxdWUgZW0gdW0gZXNwYcOnbyBlbSBicmFuY28gcGFyYSBhZGljaW9uYXIgdW0gbm92byBuw7NcIixcbiAgYWRkRWRnZTogXCJBZGljaW9uYXIgYXJlc3RhXCIsXG4gIGFkZE5vZGU6IFwiQWRpY2lvbmFyIG7Ds1wiLFxuICBiYWNrOiBcIlZvbHRhclwiLFxuICBjbG9zZTogXCJGZWNoYXJcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIk7Do28gZm9pIHBvc3PDrXZlbCBsaW5rYXIgYXJlc3RhcyBhIHVtIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJSZW1vdmVyIHNlbGVjaW9uYWRvXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBuw6NvIHB1ZGVyYW0gc2VyIHJlbW92aWRvcy5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZSBlbSB1bSBuw7MgZSBhcnJhc3RlIGEgYXJlc3RhIGF0w6kgb3V0cm8gbsOzIHBhcmEgY29uZWN0w6EtbG9zXCIsXG4gIGVkaXQ6IFwiRWRpdGFyXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciBlZGl0YWRvcy5cIixcbiAgZWRpdEVkZ2U6IFwiRWRpdGFyIGFyZXN0YVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZSBub3MgcG9udG9zIGRlIGNvbnRyb2xlIGUgb3MgYXJyYXN0ZSBwYXJhIHVtIG7DsyBwYXJhIGNvbmVjdMOhLWxvc1wiLFxuICBlZGl0Tm9kZTogXCJFZGl0YXIgbsOzXCJcbn07IC8vIFJ1c3NpYW5cblxudmFyIHJ1ID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCLQmtC70LjQutC90LjRgtC1INCyINGB0LLQvtCx0L7QtNC90L7QtSDQvNC10YHRgtC+LCDRh9GC0L7QsdGLINC00L7QsdCw0LLQuNGC0Ywg0L3QvtCy0YvQuSDRg9C30LXQuy5cIixcbiAgYWRkRWRnZTogXCLQlNC+0LHQsNCy0LjRgtGMINGA0LXQsdGA0L5cIixcbiAgYWRkTm9kZTogXCLQlNC+0LHQsNCy0LjRgtGMINGD0LfQtdC7XCIsXG4gIGJhY2s6IFwi0J3QsNC30LDQtFwiLFxuICBjbG9zZTogXCLQl9Cw0LrRgNGL0LLQsNGC0YxcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LXQstC+0LfQvNC+0LbQvdC+INGB0L7QtdC00LjQvdC40YLRjCDRgNC10LHRgNCwINCyINC60LvQsNGB0YLQtdGALlwiLFxuICBkZWw6IFwi0KPQtNCw0LvQuNGC0Ywg0LLRi9Cx0YDQsNC90L3QvtC1XCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLQmtC70LDRgdGC0LXRgNGLINC90LUg0LzQvtCz0YPRgiDQsdGL0YLRjCDRg9C00LDQu9C10L3Ri1wiLFxuICBlZGdlRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQvdCwINGD0LfQtdC7INC4INC/0YDQvtGC0Y/QvdC40YLQtSDRgNC10LHRgNC+INC6INC00YDRg9Cz0L7QvNGDINGD0LfQu9GDLCDRh9GC0L7QsdGLINGB0L7QtdC00LjQvdC40YLRjCDQuNGFLlwiLFxuICBlZGl0OiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwi0JrQu9Cw0YHRgtC10YDRiyDQvdC10LTQvtGB0YLRg9C/0L3RiyDQtNC70Y8g0YDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjRjy5cIixcbiAgZWRpdEVkZ2U6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YDQtdCx0YDQvlwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcItCa0LvQuNC60L3QuNGC0LUg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3Ri9C1INGC0L7Rh9C60Lgg0Lgg0L/QtdGA0LXRgtCw0YnQuNGC0LUg0LjRhSDQsiDRg9C30LXQuywg0YfRgtC+0LHRiyDQv9C+0LTQutC70Y7Rh9C40YLRjNGB0Y8g0Log0L3QtdC80YMuXCIsXG4gIGVkaXROb2RlOiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGD0LfQtdC7XCJcbn07IC8vIENoaW5lc2VcblxudmFyIGNuID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCLljZXlh7vnqbrnmb3lpITmlL7nva7mlrDoioLngrnjgIJcIixcbiAgYWRkRWRnZTogXCLmt7vliqDov57mjqXnur9cIixcbiAgYWRkTm9kZTogXCLmt7vliqDoioLngrlcIixcbiAgYmFjazogXCLov5Tlm55cIixcbiAgY2xvc2U6IFwi6Zec6ZaJXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCLml6Dms5XlsIbov57mjqXnur/ov57mjqXliLDnvqTpm4bjgIJcIixcbiAgZGVsOiBcIuWIoOmZpOmAieWumlwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwi5peg5rOV5Yig6Zmk576k6ZuG44CCXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCLljZXlh7vmn5DkuKroioLngrnlubblsIbor6Xov57mjqXnur/mi5bliqjliLDlj6bkuIDkuKroioLngrnku6Xov57mjqXlroPku6zjgIJcIixcbiAgZWRpdDogXCLnvJbovpFcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCLml6Dms5XnvJbovpHnvqTpm4bjgIJcIixcbiAgZWRpdEVkZ2U6IFwi57yW6L6R6L+e5o6l57q/XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwi5Y2V5Ye75o6n5Yi26IqC54K55bm25bCG5a6D5Lus5ouW5Yiw6IqC54K55LiK6L+e5o6l44CCXCIsXG4gIGVkaXROb2RlOiBcIue8lui+keiKgueCuVwiXG59OyAvLyBVa3JhaW5pYW5cblxudmFyIHVrID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJL0LvRltC60L3RltGC0Ywg0L3QsCDQstGW0LvRjNC90LUg0LzRltGB0YbQtSwg0YnQvtCxINC00L7QtNCw0YLQuCDQvdC+0LLQuNC5INCy0YPQt9C+0LsuXCIsXG4gIGFkZEVkZ2U6IFwi0JTQvtC00LDRgtC4INC60YDQsNC5XCIsXG4gIGFkZE5vZGU6IFwi0JTQvtC00LDRgtC4INCy0YPQt9C+0LtcIixcbiAgYmFjazogXCLQndCw0LfQsNC0XCIsXG4gIGNsb3NlOiBcItCX0LDQutGA0LjRgtC4XCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCLQndC1INC80L7QttC70LjQstC+INC+0LEn0ZTQtNC90LDRgtC4INC60YDQsNGXINCyINCz0YDRg9C/0YMuXCIsXG4gIGRlbDogXCLQktC40LTQsNC70LjRgtC4INC+0LHRgNCw0L3QtVwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwi0JPRgNGD0L/QuCDQvdC1INC80L7QttGD0YLRjCDQsdGD0YLQuCDQstC40LTQsNC70LXQvdGWLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINCy0YPQt9C+0Lsg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDQutGA0LDQuSDQtNC+INGW0L3RiNC+0LPQviDQstGD0LfQu9CwLCDRidC+0LEg0ZfRhSDQtyfRlNC00L3QsNGC0LguXCIsXG4gIGVkaXQ6IFwi0KDQtdC00LDQs9GD0LLQsNGC0LhcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCLQk9GA0YPQv9C4INC90LXQtNC+0YHRgtGD0L/QvdGWINC00LvRjyDRgNC10LTQsNCz0YPQstCw0L3QvdGPLlwiLFxuICBlZGl0RWRnZTogXCLQoNC10LTQsNCz0YPQstCw0YLQuCDQutGA0LDQuVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcItCa0LvRltC60L3RltGC0Ywg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3RliDRgtC+0YfQutC4INGWINC/0LXRgNC10YLRj9Cz0L3RltGC0Ywg0ZfRhSDRgyDQstGD0LfQvtC7LCDRidC+0LEg0L/RltC00LrQu9GO0YfQuNGC0LjRgdGPINC00L4g0L3RjNC+0LPQvi5cIixcbiAgZWRpdE5vZGU6IFwi0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LLRg9C30L7Qu1wiXG59OyAvLyBGcmVuY2hcblxudmFyIGZyID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJDbGlxdWV6IGRhbnMgdW4gZW5kcm9pdCB2aWRlIHBvdXIgcGxhY2VyIHVuIG7Fk3VkLlwiLFxuICBhZGRFZGdlOiBcIkFqb3V0ZXIgdW4gbGllblwiLFxuICBhZGROb2RlOiBcIkFqb3V0ZXIgdW4gbsWTdWRcIixcbiAgYmFjazogXCJSZXRvdXJcIixcbiAgY2xvc2U6IFwiRmVybWVyXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJJbXBvc3NpYmxlIGRlIGNyw6llciB1biBsaWVuIHZlcnMgdW4gY2x1c3Rlci5cIixcbiAgZGVsOiBcIkVmZmFjZXIgbGEgc8OpbGVjdGlvblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIGVmZmFjw6lzLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVleiBzdXIgdW4gbsWTdWQgZXQgZ2xpc3NleiBsZSBsaWVuIHZlcnMgdW4gYXV0cmUgbsWTdWQgcG91ciBsZXMgY29ubmVjdGVyLlwiLFxuICBlZGl0OiBcIsOJZGl0ZXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJMZXMgY2x1c3RlcnMgbmUgcGV1dmVudCBwYXMgw6p0cmUgw6lkaXTDqXMuXCIsXG4gIGVkaXRFZGdlOiBcIsOJZGl0ZXIgbGUgbGllblwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZXogc3VyIGxlcyBwb2ludHMgZGUgY29udHLDtGxlIGV0IGdsaXNzZXotbGVzIHBvdXIgY29ubmVjdGVyIHVuIG7Fk3VkLlwiLFxuICBlZGl0Tm9kZTogXCLDiWRpdGVyIGxlIG7Fk3VkXCJcbn07IC8vIEN6ZWNoXG5cbnZhciBjcyA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS2x1a251dMOtbSBkbyBwcsOhemRuw6lobyBwcm9zdG9ydSBtxa/FvmV0ZSBwxZlpZGF0IG5vdsO9IHZyY2hvbC5cIixcbiAgYWRkRWRnZTogXCJQxZlpZGF0IGhyYW51XCIsXG4gIGFkZE5vZGU6IFwiUMWZaWRhdCB2cmNob2xcIixcbiAgYmFjazogXCJacMSbdFwiLFxuICBjbG9zZTogXCJaYXbFmcOtdFwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTmVsemUgcMWZaXBvaml0IGhyYW51IGtlIHNobHVrdS5cIixcbiAgZGVsOiBcIlNtYXphdCB2w71ixJtyXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJOZWx6ZSBtYXphdCBzaGx1a3kuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJQxZlldGHFvmVuw61tIHogamVkbm9obyB2cmNob2x1IGRvIGRydWjDqWhvIG3Fr8W+ZXRlIHNwb2ppdCB0eXRvIHZyY2hvbHkgbm92b3UgaHJhbm91LlwiLFxuICBlZGl0OiBcIlVwcmF2aXRcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJOZWx6ZSB1cHJhdm92YXQgc2hsdWt5LlwiLFxuICBlZGl0RWRnZTogXCJVcHJhdml0IGhyYW51XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiUMWZZXRhxb5lbsOtbSBrb250cm9sbsOtaG8gdnJjaG9sdSBocmFueSBqaSBtxa/FvmV0ZSBwxZlpcG9qaXQgayBqaW7DqW11IHZyY2hvbHUuXCIsXG4gIGVkaXROb2RlOiBcIlVwcmF2aXQgdnJjaG9sXCJcbn07XG5cbnZhciBsb2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGVuOiBlbixcblx0ZGU6IGRlLFxuXHRlczogZXMsXG5cdGl0OiBpdCxcblx0bmw6IG5sLFxuXHRwdDogcHQsXG5cdHJ1OiBydSxcblx0Y246IGNuLFxuXHR1azogdWssXG5cdGZyOiBmcixcblx0Y3M6IGNzXG59KTtcblxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgbGFuZ3VhZ2UgY29kZSBpbnRvIHRoZSBmb3JtYXQgdXNlZCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlcyAtIEFsbCB0aGUgYXZhaWxhYmxlIGxvY2FsZXMuXHJcbiAqIEBwYXJhbSByYXdDb2RlIC0gVGhlIG9yaWdpbmFsIGNvZGUgYXMgc3VwcGxpZWQgYnkgdGhlIHVzZXIuXHJcbiAqIEByZXR1cm5zIExhbmd1YWdlIGNvZGUgaW4gdGhlIGZvcm1hdCBsYW5ndWFnZS1DT1VOVFJZIG9yIGxhbmd1YWdlLCBldmVudHVhbGx5XHJcbiAqIGZhbGxiYWNrcyB0byBlbi5cclxuICovXG5mdW5jdGlvbiBub3JtYWxpemVMYW5ndWFnZUNvZGUobG9jYWxlcywgcmF3Q29kZSkge1xuICB0cnkge1xuICAgIHZhciBfcmF3Q29kZSRzcGxpdCA9IHJhd0NvZGUuc3BsaXQoL1stXyAvXS8sIDIpLFxuICAgICAgICBfcmF3Q29kZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfcmF3Q29kZSRzcGxpdCwgMiksXG4gICAgICAgIHJhd0xhbmd1YWdlID0gX3Jhd0NvZGUkc3BsaXQyWzBdLFxuICAgICAgICByYXdDb3VudHJ5ID0gX3Jhd0NvZGUkc3BsaXQyWzFdO1xuXG4gICAgdmFyIGxhbmd1YWdlID0gcmF3TGFuZ3VhZ2UgIT0gbnVsbCA/IHJhd0xhbmd1YWdlLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIHZhciBjb3VudHJ5ID0gcmF3Q291bnRyeSAhPSBudWxsID8gcmF3Q291bnRyeS50b1VwcGVyQ2FzZSgpIDogbnVsbDtcblxuICAgIGlmIChsYW5ndWFnZSAmJiBjb3VudHJ5KSB7XG4gICAgICB2YXIgY29kZSA9IGxhbmd1YWdlICsgXCItXCIgKyBjb3VudHJ5O1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvY2FsZXMsIGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgIGNvbnNvbGUud2Fybihjb25jYXQoX2NvbnRleHQgPSBcIlVua25vd24gdmFyaWFudCBcIi5jb25jYXQoY291bnRyeSwgXCIgb2YgbGFuZ3VhZ2UgXCIpKS5jYWxsKF9jb250ZXh0LCBsYW5ndWFnZSwgXCIuXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIHZhciBfY29kZSA9IGxhbmd1YWdlO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvY2FsZXMsIF9jb2RlKSkge1xuICAgICAgICByZXR1cm4gX2NvZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIGxhbmd1YWdlIFwiLmNvbmNhdChsYW5ndWFnZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbG9jYWxlIFwiLmNvbmNhdChyYXdDb2RlLCBcIiwgZmFsbGluZyBiYWNrIHRvIEVuZ2xpc2guXCIpKTtcbiAgICByZXR1cm4gXCJlblwiO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGNvbnNvbGUud2FybihcIlVuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgbm9ybWFsaXppbmcgbG9jYWxlIFwiLmNvbmNhdChyYXdDb2RlLCBcIiwgZmFsbGluZyBiYWNrIHRvIEVuZ2xpc2guXCIpKTtcbiAgICByZXR1cm4gXCJlblwiO1xuICB9XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhIGNhbnZhcyB0byBhIGdpdmVuIGltYWdlLCBjb250YWluaW5nIGEgbnVtYmVyIG9mIHJlbmRlcmluZ3NcbiAqIG9mIHRoZSBpbWFnZSBhdCB2YXJpb3VzIHNpemVzLlxuICpcbiAqIFRoaXMgdGVjaG5pcXVlIGlzIGtub3duIGFzICdtaXBtYXBwaW5nJy5cbiAqXG4gKiBOT1RFOiBJbWFnZXMgY2FuIGFsc28gYmUgb2YgdHlwZSAnZGF0YTpzdmcreG1sYC4gVGhpcyBjb2RlIGFsc28gd29ya3NcbiAqICAgICAgIGZvciBzdmcsIGJ1dCB0aGUgbWlwbWFwcGluZyBtYXkgbm90IGJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG52YXIgQ2FjaGVkSW1hZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2FjaGVkSW1hZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlZEltYWdlKTtcblxuICAgIHRoaXMuTlVNX0lURVJBVElPTlMgPSA0OyAvLyBOdW1iZXIgb2YgaXRlbXMgaW4gdGhlIGNvb3JkaW5hdGVzIGFycmF5XG5cbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2FjaGVkSW1hZ2UsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKCkpIHJldHVybjtcbiAgICAgIHRoaXMuc3JjID0gdGhpcy5pbWFnZS5zcmM7IC8vIEZvciBzYW1lIGludGVyZmFjZSB3aXRoIEltYWdlXG5cbiAgICAgIHZhciB3ID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5pbWFnZS5oZWlnaHQ7IC8vIEVhc2UgZXh0ZXJuYWwgYWNjZXNzXG5cbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgICAgdmFyIGgyID0gTWF0aC5mbG9vcihoIC8gMik7XG4gICAgICB2YXIgaDQgPSBNYXRoLmZsb29yKGggLyA0KTtcbiAgICAgIHZhciBoOCA9IE1hdGguZmxvb3IoaCAvIDgpO1xuICAgICAgdmFyIGgxNiA9IE1hdGguZmxvb3IoaCAvIDE2KTtcbiAgICAgIHZhciB3MiA9IE1hdGguZmxvb3IodyAvIDIpO1xuICAgICAgdmFyIHc0ID0gTWF0aC5mbG9vcih3IC8gNCk7XG4gICAgICB2YXIgdzggPSBNYXRoLmZsb29yKHcgLyA4KTtcbiAgICAgIHZhciB3MTYgPSBNYXRoLmZsb29yKHcgLyAxNik7IC8vIE1ha2UgY2FudmFzIGFzIHNtYWxsIGFzIHBvc3NpYmxlXG5cbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gMyAqIHc0O1xuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaDI7IC8vIENvb3JkaW5hdGVzIGFuZCBzaXplcyBvZiBpbWFnZXMgY29udGFpbmVkIGluIHRoZSBjYW52YXNcbiAgICAgIC8vIFZhbHVlcyBwZXIgcm93OiAgW3RvcCB4LCBsZWZ0IHksIHdpZHRoLCBoZWlnaHRdXG5cbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBbWzAsIDAsIHcyLCBoMl0sIFt3MiwgMCwgdzQsIGg0XSwgW3cyLCBoNCwgdzgsIGg4XSwgWzUgKiB3OCwgaDQsIHcxNiwgaDE2XV07XG5cbiAgICAgIHRoaXMuX2ZpbGxNaXBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaW5pdCgpIGhhcyBiZWVuIGNhbGxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgbWFpbiBpbWFnZSBpbiB2YXJpb3VzIHNpemVzIHRvIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogVGhlIHJhdGlvbmFsZSBiZWhpbmQgdGhpcyBpcyB0byByZWR1Y2UgYXJ0ZWZhY3RzIGR1ZSB0byBpbnRlcnBvbGF0aW9uXG4gICAgICogYXQgZGlmZmVyaW5nIHpvb20gbGV2ZWxzLlxuICAgICAqXG4gICAgICogU291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODc2MTQwNC8xMjIzNTMxXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZHMgdGFrZXMgdGhlIHJlc2l6aW5nIG91dCBvZiB0aGUgZHJhd2luZyBsb29wLCBpbiBvcmRlciB0b1xuICAgICAqIHJlZHVjZSBwZXJmb3JtYW5jZSBvdmVyaGVhZC5cbiAgICAgKlxuICAgICAqIFRPRE86IFRoZSBjb2RlIGFzc3VtZXMgdGhhdCBhIDJEIGNvbnRleHQgY2FuIGFsd2F5cyBiZSBnb3R0ZW4uIFRoaXMgaXNcbiAgICAgKiAgICAgICBub3QgbmVjZXNzYXJpbHkgdHJ1ZSEgT1RPSCwgaWYgbm90IHRydWUgdGhlbiB1c2FnZSBvZiB0aGlzIGNsYXNzXG4gICAgICogICAgICAgaXMgc2Vuc2VsZXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maWxsTWlwTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWxsTWlwTWFwKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgLy8gRmlyc3Qgem9vbS1sZXZlbCBjb21lcyBmcm9tIHRoZSBpbWFnZVxuXG4gICAgICB2YXIgdG8gPSB0aGlzLmNvb3JkaW5hdGVzWzBdO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCB0b1swXSwgdG9bMV0sIHRvWzJdLCB0b1szXSk7IC8vIFRoZSByZXN0IGFyZSBjb3B5IGFjdGlvbnMgaW50ZXJuYWwgdG8gdGhlIGNhbnZhcy9jb250ZXh0XG5cbiAgICAgIGZvciAodmFyIGl0ZXJhdGlvbnMgPSAxOyBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUzsgaXRlcmF0aW9ucysrKSB7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zIC0gMV07XG4gICAgICAgIHZhciBfdG8gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnNdO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCBmcm9tWzBdLCBmcm9tWzFdLCBmcm9tWzJdLCBmcm9tWzNdLCBfdG9bMF0sIF90b1sxXSwgX3RvWzJdLCBfdG9bM10pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSBpbWFnZSwgdXNpbmcgdGhlIG1pcG1hcCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBNaXBNYXAgaXMgb25seSB1c2VkIGlmIHBhcmFtIGZhY3RvciA+IDI7IG90aGVyd2lzZSwgb3JpZ2luYWwgYml0bWFwXG4gICAgICogaXMgcmVzaXplZC4gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2tpcCBtaXBtYXAgdXNhZ2UsIGUuZy4gYnkgc2V0dGluZyBmYWN0b3IgPSAxXG4gICAgICpcbiAgICAgKiBDcmVkaXRzIHRvICdBbGV4IGRlIE11bGRlcicgZm9yIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgY29udGV4dCBvbiB3aGljaCB0byBkcmF3IHpvb21lZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7RmxvYXR9IGZhY3RvciBzY2FsZSBmYWN0b3IgYXQgd2hpY2ggdG8gZHJhd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdJbWFnZUF0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIGZhY3RvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQoKSkgcmV0dXJuOyAvL2Nhbid0IGRyYXcgaW1hZ2UgeWV0IG5vdCBpbnRpYWxpemVkXG5cbiAgICAgIGlmIChmYWN0b3IgPiAyKSB7XG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCB6b29tZWQgaW1hZ2UgdG8gdXNlXG4gICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblxuICAgICAgICB3aGlsZSAoZmFjdG9yID4gMiAmJiBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPj0gdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLk5VTV9JVEVSQVRJT05TIC0gMTtcbiAgICAgICAgfSAvL2NvbnNvbGUubG9nKFwiaXRlcmF0aW9uczogXCIgKyBpdGVyYXRpb25zKTtcblxuXG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zXTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgZnJvbVswXSwgZnJvbVsxXSwgZnJvbVsyXSwgZnJvbVszXSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgaW1hZ2UgZGlyZWN0bHlcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYWNoZWRJbWFnZTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGEgY2FsbGJhY2sgdGhhdCBhY2NlcHRzIGFuIEltYWdlLlxuICpcbiAqIEBjYWxsYmFjayBJbWFnZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICpcbiAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuXG52YXIgSW1hZ2VzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlcyhjYWxsYmFjaykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZXMpO1xuXG4gICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICB0aGlzLmltYWdlQnJva2VuID0ge307XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgICAgICAgICAgICAgICAgICAgIFRoZSBvcmlnaW5hbCBVcmwgdGhhdCBmYWlsZWQgdG8gbG9hZCwgaWYgdGhlIGJyb2tlbiBpbWFnZSBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNhY2hlIHVzaW5nIHRoaXMgVXJsIGFzIHRoZSBrZXkgc28gdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGZvciB0aGlzIFVybCB3aWxsIHJldHVybiB0aGUgYnJva2VuIGltYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgICAgICAgICAgICAgVXJsIHRoZSBicm9rZW4gaW1hZ2UgdG8gdHJ5IGFuZCBsb2FkXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gICBUaGUgaW1hZ2Ugb2JqZWN0XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEltYWdlcywgW3tcbiAgICBrZXk6IFwiX3RyeWxvYWRCcm9rZW5VcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltYWdlVG9Mb2FkQnJva2VuVXJsT24pIHtcbiAgICAgIC8vSWYgdGhlc2UgcGFyYW1ldGVycyBhcmVuJ3Qgc3BlY2lmaWVkIHRoZW4gZXhpdCB0aGUgZnVuY3Rpb24gYmVjYXVzZSBub3RoaW5nIGNvbnN0cnVjdGl2ZSBjYW4gYmUgZG9uZVxuICAgICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoYnJva2VuVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gYnJva2VuIHVybCBpbWFnZSBkZWZpbmVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vQ2xlYXIgdGhlIG9sZCBzdWJzY3JpcHRpb24gdG8gdGhlIGVycm9yIGV2ZW50IGFuZCBwdXQgYSBuZXcgaW4gcGxhY2UgdGhhdCBvbmx5IGhhbmRsZSBlcnJvcnMgaW4gbG9hZGluZyB0aGUgYnJva2VuSW1hZ2VVcmxcblxuXG4gICAgICBpbWFnZVRvTG9hZEJyb2tlblVybE9uLmltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBicm9rZW5JbWFnZTpcIiwgYnJva2VuVXJsKTsgLy8gY2FjaGUgaXRlbSB3aWxsIGNvbnRhaW4gZW1wdHkgaW1hZ2UsIHRoaXMgc2hvdWxkIGJlIE9LIGZvciBkZWZhdWx0XG4gICAgICB9OyAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgYnJva2VuVXJsLCB0aGlzIGlzIGFjdHVhbGx5IHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBicm9rZW4gaW1hZ2VcblxuXG4gICAgICBpbWFnZVRvTG9hZEJyb2tlblVybE9uLmltYWdlLnNyYyA9IGJyb2tlblVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JbWFnZX0gaW1hZ2VUb1JlZHJhd1dpdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZHJhd1dpdGhJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3V2l0aEltYWdlKGltYWdlVG9SZWRyYXdXaXRoKSB7XG4gICAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGltYWdlVG9SZWRyYXdXaXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICBVcmwgb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJyb2tlblVybCAgICBVcmwgb2YgYW4gaW1hZ2UgdG8gdXNlIGlmIHRoZSB1cmwgaW1hZ2UgaXMgbm90IGZvdW5kXG4gICAgICogQHJldHVybnMge0ltYWdlfSBpbWcgICAgICAgICAgVGhlIGltYWdlIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgYnJva2VuVXJsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvL1RyeSBhbmQgZ2V0IHRoZSBpbWFnZSBmcm9tIHRoZSBjYWNoZSwgaWYgc3VjY2Vzc2Z1bCB0aGVuIHJldHVybiB0aGUgY2FjaGVkIGltYWdlXG4gICAgICB2YXIgY2FjaGVkSW1hZ2UgPSB0aGlzLmltYWdlc1t1cmxdO1xuICAgICAgaWYgKGNhY2hlZEltYWdlKSByZXR1cm4gY2FjaGVkSW1hZ2U7IC8vQ3JlYXRlIGEgbmV3IGltYWdlXG5cbiAgICAgIHZhciBpbWcgPSBuZXcgQ2FjaGVkSW1hZ2UoKTsgLy8gTmVlZCB0byBhZGQgdG8gY2FjaGUgaGVyZSwgb3RoZXJ3aXNlIGZpbmFsIHJldHVybiB3aWxsIHNwYXduIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlIHNhbWUgaW1hZ2UsXG4gICAgICAvLyBBbHNvLCB0aGVyZSB3aWxsIGJlIG11bHRpcGxlIGxvYWRzIG9mIHRoZSBzYW1lIGltYWdlLlxuXG4gICAgICB0aGlzLmltYWdlc1t1cmxdID0gaW1nOyAvL1N1YnNjcmliZSB0byB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgaWYgdGhlIGltYWdlIGxvYWRzIHN1Y2Nlc3NmdWxseVxuXG4gICAgICBpbWcuaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcm9wZXJseSBpbml0IHRoZSBjYWNoZWQgaXRlbSBhbmQgdGhlbiByZXF1ZXN0IGEgcmVkcmF3XG4gICAgICAgIF90aGlzLl9maXhJbWFnZUNvb3JkaW5hdGVzKGltZy5pbWFnZSk7XG5cbiAgICAgICAgaW1nLmluaXQoKTtcblxuICAgICAgICBfdGhpcy5fcmVkcmF3V2l0aEltYWdlKGltZyk7XG4gICAgICB9OyAvL1N1YnNjcmliZSB0byB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgaWYgdGhlIGltYWdlIGZhaWxzIHRvIGxvYWRcblxuXG4gICAgICBpbWcuaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlOlwiLCB1cmwpOyAvL1RyeSBhbmQgbG9hZCB0aGUgaW1hZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBicm9rZW5VcmwgdXNpbmdcblxuICAgICAgICBfdGhpcy5fdHJ5bG9hZEJyb2tlblVybCh1cmwsIGJyb2tlblVybCwgaW1nKTtcbiAgICAgIH07IC8vU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIHRvIHRoZSB1cmwsIHRoaXMgaXMgd2hhdCBhY3R1YWxseSBraWNrcyBvZmYgdGhlIGxvYWRpbmcgb2YgdGhlIGltYWdlXG5cblxuICAgICAgaW1nLmltYWdlLnNyYyA9IHVybDsgLy9SZXR1cm4gdGhlIG5ldyBpbWFnZVxuXG4gICAgICByZXR1cm4gaW1nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJRTExIGZpeCAtLSB0aGFua3MgZHBvbmNoIVxuICAgICAqXG4gICAgICogTG9jYWwgaGVscGVyIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JbWFnZX0gaW1hZ2VUb0NhY2hlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maXhJbWFnZUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXhJbWFnZUNvb3JkaW5hdGVzKGltYWdlVG9DYWNoZSkge1xuICAgICAgaWYgKGltYWdlVG9DYWNoZS53aWR0aCA9PT0gMCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICAgIGltYWdlVG9DYWNoZS53aWR0aCA9IGltYWdlVG9DYWNoZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaW1hZ2VUb0NhY2hlLmhlaWdodCA9IGltYWdlVG9DYWNoZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2VzO1xufSgpO1xuXG52YXIgaW50ZXJuYWxNZXRhZGF0YSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBmYWlscyQ3ID0gZmFpbHMkdDtcbnZhciBhcnJheUJ1ZmZlck5vbkV4dGVuc2libGUgPSBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShidWZmZXIpKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVmZmVyLCAnYScsIHtcbiAgICAgIHZhbHVlOiA4XG4gICAgfSk7XG4gIH1cbn0pO1xuXG52YXIgZmFpbHMkNiA9IGZhaWxzJHQ7XG52YXIgaXNPYmplY3QkNiA9IGlzT2JqZWN0JGo7XG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZlJhdyQxO1xudmFyIEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSA9IGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUgLS0gc2FmZVxuXG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQxID0gZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gICRpc0V4dGVuc2libGUoMSk7XG59KTsgLy8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuaXNleHRlbnNpYmxlXG5cbnZhciBvYmplY3RJc0V4dGVuc2libGUgPSBGQUlMU19PTl9QUklNSVRJVkVTJDEgfHwgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID8gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gIGlmICghaXNPYmplY3QkNihpdCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSAmJiBjbGFzc29mJDQoaXQpID09ICdBcnJheUJ1ZmZlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWU7XG59IDogJGlzRXh0ZW5zaWJsZTtcblxudmFyIGZhaWxzJDUgPSBmYWlscyR0O1xudmFyIGZyZWV6aW5nID0gIWZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LXByZXZlbnRleHRlbnNpb25zIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG5cbnZhciAkJGUgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhpZGRlbktleXMgPSBoaWRkZW5LZXlzJDY7XG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JGo7XG52YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGRlZmluZVByb3BlcnR5JDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbDtcbnZhciBpc0V4dGVuc2libGUkMSA9IG9iamVjdElzRXh0ZW5zaWJsZTtcbnZhciB1aWQgPSB1aWQkNDtcbnZhciBGUkVFWklORyA9IGZyZWV6aW5nO1xudmFyIFJFUVVJUkVEID0gZmFsc2U7XG52YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcbnZhciBpZCQxID0gMDtcblxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIGRlZmluZVByb3BlcnR5JDIoaXQsIE1FVEFEQVRBLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG9iamVjdElEOiAnTycgKyBpZCQxKyssXG4gICAgICAvLyBvYmplY3QgSURcbiAgICAgIHdlYWtEYXRhOiB7fSAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmYXN0S2V5JDEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdCQ1KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblxuICBpZiAoIWhhc093biQ1KGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlJDEoaXQpKSByZXR1cm4gJ0YnOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICBzZXRNZXRhZGF0YShpdCk7IC8vIHJldHVybiBvYmplY3QgSURcbiAgfVxuXG4gIHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XG59O1xuXG52YXIgZ2V0V2Vha0RhdGEkMSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzT3duJDUoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUkMShpdCkpIHJldHVybiB0cnVlOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgIHNldE1ldGFkYXRhKGl0KTsgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9XG5cbiAgcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcbn07IC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXG5cbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpJTkcgJiYgUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlJDEoaXQpICYmICFoYXNPd24kNShpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBlbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIG1ldGEuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH07XG5cbiAgUkVRVUlSRUQgPSB0cnVlO1xuICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZjtcbiAgdmFyIHNwbGljZSA9IHVuY3VycnlUaGlzJDQoW10uc3BsaWNlKTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdGVzdFtNRVRBREFUQV0gPSAxOyAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxuXG4gIGlmIChnZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QpLmxlbmd0aCkge1xuICAgIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGZ1bmN0aW9uIChpdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXN1bHRbaV0gPT09IE1FVEFEQVRBKSB7XG4gICAgICAgICAgc3BsaWNlKHJlc3VsdCwgaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgJCRlKHtcbiAgICAgIHRhcmdldDogJ09iamVjdCcsXG4gICAgICBzdGF0OiB0cnVlLFxuICAgICAgZm9yY2VkOiB0cnVlXG4gICAgfSwge1xuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lczogZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlLmZcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIG1ldGEgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHMgPSB7XG4gIGVuYWJsZTogZW5hYmxlLFxuICBmYXN0S2V5OiBmYXN0S2V5JDEsXG4gIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSQxLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5oaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG5cbnZhciBnbG9iYWwkYSA9IGdsb2JhbCRQO1xudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRkO1xudmFyIHRyeVRvU3RyaW5nJDEgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGlzUHJvdG90eXBlT2YkOSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IkNSA9IGdldEl0ZXJhdG9yJDc7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ4O1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDI7XG52YXIgVHlwZUVycm9yJDUgPSBnbG9iYWwkYS5UeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCQzKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93IFR5cGVFcnJvciQ1KHRyeVRvU3RyaW5nJDEoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTsgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcblxuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDQoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDkoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvciQ1KGl0ZXJhYmxlLCBpdGVyRm4pO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG5cbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkMShuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIGlzUHJvdG90eXBlT2YkOShSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkUDtcbnZhciBpc1Byb3RvdHlwZU9mJDggPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFR5cGVFcnJvciQ0ID0gZ2xvYmFsJDkuVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkOChQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBUeXBlRXJyb3IkNCgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbnZhciAkJGQgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJFA7XG52YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSQxID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzO1xudmFyIGZhaWxzJDQgPSBmYWlscyR0O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGl0ZXJhdGUkMiA9IGl0ZXJhdGUkMztcbnZhciBhbkluc3RhbmNlJDIgPSBhbkluc3RhbmNlJDM7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkaDtcbnZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkajtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0dGVyRm9yO1xuXG52YXIgY29sbGVjdGlvbiQzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xuICB2YXIgSVNfTUFQID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdNYXAnKSAhPT0gLTE7XG4gIHZhciBJU19XRUFLID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdXZWFrJykgIT09IC0xO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkOFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGV4cG9ydGVkID0ge307XG4gIHZhciBDb25zdHJ1Y3RvcjtcblxuICBpZiAoIURFU0NSSVBUT1JTJDIgfHwgIWlzQ2FsbGFibGUoTmF0aXZlQ29uc3RydWN0b3IpIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDb25zdHJ1Y3RvciA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlJDEuZW5hYmxlKCk7XG4gIH0gZWxzZSB7XG4gICAgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlJDIoYW5JbnN0YW5jZSQyKHRhcmdldCwgUHJvdG90eXBlKSwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBjb2xsZWN0aW9uOiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKVxuICAgICAgfSk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlJDIoaXRlcmFibGUsIHRhcmdldFtBRERFUl0sIHtcbiAgICAgICAgdGhhdDogdGFyZ2V0LFxuICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDIoQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgZm9yRWFjaChbJ2FkZCcsICdjbGVhcicsICdkZWxldGUnLCAnZm9yRWFjaCcsICdnZXQnLCAnaGFzJywgJ3NldCcsICdrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJ10sIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG5cbiAgICAgIGlmIChLRVkgaW4gTmF0aXZlUHJvdG90eXBlICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uO1xuICAgICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QkNChhKSkgcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBJU19XRUFLIHx8IGRlZmluZVByb3BlcnR5JDEoUHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgZmFsc2UsIHRydWUpO1xuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuICAkJGQoe1xuICAgIGdsb2JhbDogdHJ1ZSxcbiAgICBmb3JjZWQ6IHRydWVcbiAgfSwgZXhwb3J0ZWQpO1xuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciByZWRlZmluZSA9IHJlZGVmaW5lJDQ7XG5cbnZhciByZWRlZmluZUFsbCQzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtlbHNlIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kOTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTJDEgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBjcmVhdGUkNCA9IG9iamVjdENyZWF0ZTtcbnZhciByZWRlZmluZUFsbCQyID0gcmVkZWZpbmVBbGwkMztcbnZhciBiaW5kJDIgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGFuSW5zdGFuY2UkMSA9IGFuSW5zdGFuY2UkMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDM7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQzO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciBmYXN0S2V5ID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzLmZhc3RLZXk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQxID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3I7XG52YXIgY29sbGVjdGlvblN0cm9uZyQyID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSQxKHRoYXQsIFByb3RvdHlwZSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlJDEodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlJDQobnVsbCksXG4gICAgICAgIGZpcnN0OiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSk7XG4gICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZSQxKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwge1xuICAgICAgICB0aGF0OiB0aGF0LFxuICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDsgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlOyAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZW1vdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICBpZiAocHJldmlvdXMpIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7ZWxzZSB0aGF0LnNpemUrKzsgLy8gYWRkIHRvIGluZGV4XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTsgLy8gZmFzdCBjYXNlXG5cbiAgICAgIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgICAgIHZhciBlbnRyeTtcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gc3RhdGUuaW5kZXhbaW5kZXhdOyAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcblxuICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsJDIoUHJvdG90eXBlLCB7XG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5jbGVhcigpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBkYXRhID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wcmV2aW91cykgZW50cnkucHJldmlvdXMgPSBlbnRyeS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSA9IDA7ZWxzZSB0aGF0LnNpemUgPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wcmV2aW91cyA9IHByZXY7XG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmxhc3QgPT0gZW50cnkpIHN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZS0tO2Vsc2UgdGhhdC5zaXplLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmZvcmVhY2hcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAgICAgLyogLCB0aGF0ID0gdW5kZWZpbmVkICovXG4gICAgICApIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kJDIoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgZW50cnk7XG5cbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpOyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXR9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmhhc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmhhc1xuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwkMihQcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIGBNYXAucHJvdG90eXBlLmdldChrZXkpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5nZXRcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG4gICAgICB9LFxuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5zZXRcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIC8vIGBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmFkZFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eShQcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoSVRFUkFUT1JfTkFNRSk7IC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLnsga2V5cywgdmFsdWVzLCBlbnRyaWVzLCBAQGl0ZXJhdG9yIH0oKWAgbWV0aG9kc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5lbnRyaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUudmFsdWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLUBAaXRlcmF0b3JcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cbiAgICBkZWZpbmVJdGVyYXRvcihDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgICAgICB0eXBlOiBJVEVSQVRPUl9OQU1FLFxuICAgICAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxuICAgICAgICBzdGF0ZTogZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUoaXRlcmF0ZWQpLFxuICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmxhc3Q7IC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuXG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91czsgLy8gZ2V0IG5leHQgZW50cnlcblxuXG4gICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcblxuXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBlbnRyeS5rZXksXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZSxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7IC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlW0BAc3BlY2llc11gIGFjY2Vzc29yc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LW1hcC1AQHNwZWNpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1zZXQtQEBzcGVjaWVzXG5cbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuICB9XG59O1xuXG52YXIgY29sbGVjdGlvbiQyID0gY29sbGVjdGlvbiQzO1xudmFyIGNvbGxlY3Rpb25TdHJvbmckMSA9IGNvbGxlY3Rpb25TdHJvbmckMjsgLy8gYE1hcGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLW9iamVjdHNcblxuY29sbGVjdGlvbiQyKCdNYXAnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufSwgY29sbGVjdGlvblN0cm9uZyQxKTtcblxudmFyIHBhdGgkYiA9IHBhdGgkeTtcbnZhciBtYXAkMiA9IHBhdGgkYi5NYXA7XG5cbnZhciBwYXJlbnQkdiA9IG1hcCQyO1xudmFyIG1hcCQxID0gcGFyZW50JHY7XG5cbnZhciBtYXAgPSBtYXAkMTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBzdG9yZSBncm91cHMgYW5kIG9wdGlvbnMgc3BlY2lmaWMgZm9yIGdyb3Vwcy5cbiAqL1xudmFyIEdyb3VwcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBHcm91cHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyb3Vwcyk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5fZGVmYXVsdEluZGV4ID0gMDtcbiAgICB0aGlzLl9ncm91cEluZGV4ID0gMDtcbiAgICB0aGlzLl9kZWZhdWx0R3JvdXBzID0gW3tcbiAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM5N0MyRkNcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiXG4gICAgICB9XG4gICAgfSwgLy8gMDogYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkZBNTAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkZBNTAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRkZBM1wiXG4gICAgICB9XG4gICAgfSwgLy8gMTogeWVsbG93XG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGQTBBMTBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZCN0U4MVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkEwQTEwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGQTBBMTBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZBRkIxXCJcbiAgICAgIH1cbiAgICB9LCAvLyAyOiByZWRcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzQxQTkwNlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjN0JFMTQxXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQTFFQzc2XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzQxQTkwNlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNBMUVDNzZcIlxuICAgICAgfVxuICAgIH0sIC8vIDM6IGdyZWVuXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNFMTI5RjBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0VCN0RGNFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFMTI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRjBCM0Y1XCJcbiAgICAgIH1cbiAgICB9LCAvLyA0OiBtYWdlbnRhXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM3QzI5RjBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0FEODVFNFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjN0MyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM3QzI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDNCREYwXCJcbiAgICAgIH1cbiAgICB9LCAvLyA1OiBwdXJwbGVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0MzN0YwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkZBODA3XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZDQTY2XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0MzN0YwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkNBNjZcIlxuICAgICAgfVxuICAgIH0sIC8vIDY6IG9yYW5nZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNDIyMEZCXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM2RTZFRkRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDIyMEZCXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzlCOUJGRFwiXG4gICAgICB9XG4gICAgfSwgLy8gNzogZGFya2JsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZENUE3N1wiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkZDMENCXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRDVBNzdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZENUE3N1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkQxRDlcIlxuICAgICAgfVxuICAgIH0sIC8vIDg6IHBpbmtcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzRBRDYzQVwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjQzJGQUJDXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRTZGRkUzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzRBRDYzQVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNFNkZGRTNcIlxuICAgICAgfVxuICAgIH0sIC8vIDk6IG1pbnRcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzk5MDAwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRUUwMDAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCQjAwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYzMzMzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0JCMDAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIlxuICAgICAgfVxuICAgIH0sIC8vIDEwOmJyaWdodCByZWRcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGNjAwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGNjAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjYwMDBcIlxuICAgICAgfVxuICAgIH0sIC8vIDEyOiByZWFsIG9yYW5nZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjOTdDMkZDXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0QyRTVGRlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDJFNUZGXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiXG4gICAgICB9XG4gICAgfSwgLy8gMTM6IGJsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzM5OTYwNVwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjMjU1QzAzXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjU1QzAzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzM5OTYwNVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIlxuICAgICAgfVxuICAgIH0sIC8vIDE0OiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQjcwMDU0XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjQjcwMDU0XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMDA3RVwiXG4gICAgICB9XG4gICAgfSwgLy8gMTU6IG1hZ2VudGFcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0FEODVFNFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjN0MyOUYwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEM0JERjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjN0MyOUYwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0QzQkRGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIlxuICAgICAgfVxuICAgIH0sIC8vIDE2OiBwdXJwbGVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzQ1NTdGQVwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjMDAwRUExXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM2RTZFRkRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMDAwRUExXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzZFNkVGRFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIlxuICAgICAgfVxuICAgIH0sIC8vIDE3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkZDMENCXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGRDFEOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkZEMUQ5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZENUE3N1wiXG4gICAgICB9XG4gICAgfSwgLy8gMTg6IHBpbmtcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0MyRkFCQ1wiLFxuICAgICAgYmFja2dyb3VuZDogXCIjNzRENjZBXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFNkZGRTNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzRENjZBXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0U2RkZFM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIlxuICAgICAgfVxuICAgIH0sIC8vIDE5OiBtaW50XG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNFRTAwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzk5MDAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkYzMzMzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjMzMzNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQkIwMDAwXCJcbiAgICAgIH1cbiAgICB9IC8vIDIwOmJyaWdodCByZWRcbiAgICBdO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB1c2VEZWZhdWx0R3JvdXBzOiB0cnVlXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEdyb3VwcywgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBvcHRpb25GaWVsZHMgPSBbXCJ1c2VEZWZhdWx0R3JvdXBzXCJdO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGdyb3VwTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBncm91cE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZihvcHRpb25GaWVsZHMpLmNhbGwob3B0aW9uRmllbGRzLCBncm91cE5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBvcHRpb25zW2dyb3VwTmFtZV07XG4gICAgICAgICAgICAgIHRoaXMuYWRkKGdyb3VwTmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JvdXBzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX2dyb3VwcyA9IG5ldyBtYXAoKTtcbiAgICAgIHRoaXMuX2dyb3VwTmFtZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGdyb3VwIG9wdGlvbnMgb2YgYSBncm91cG5hbWUuXG4gICAgICogSWYgZ3JvdXBuYW1lIGlzIG5vdCBmb3VuZCwgYSBuZXcgZ3JvdXAgbWF5IGJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgIGdyb3VwbmFtZSAgICAgQ2FuIGJlIGEgbnVtYmVyLCBzdHJpbmcsIERhdGUsIGV0Yy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG91bGRDcmVhdGU9dHJ1ZV0gSWYgdHJ1ZSwgY3JlYXRlIGEgbmV3IGdyb3VwXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGZvdW5kIG9yIGNyZWF0ZWQgZ3JvdXBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZ3JvdXBuYW1lKSB7XG4gICAgICB2YXIgc2hvdWxkQ3JlYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cHMuZ2V0KGdyb3VwbmFtZSk7XG5cbiAgICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkICYmIHNob3VsZENyZWF0ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZURlZmF1bHRHcm91cHMgPT09IGZhbHNlICYmIHRoaXMuX2dyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9ncm91cEluZGV4ICUgdGhpcy5fZ3JvdXBOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgKyt0aGlzLl9ncm91cEluZGV4O1xuICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLl9ncm91cHMuZ2V0KHRoaXMuX2dyb3VwTmFtZXNbaW5kZXhdKTtcblxuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBuYW1lLCBncm91cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgIHZhciBfaW5kZXggPSB0aGlzLl9kZWZhdWx0SW5kZXggJSB0aGlzLl9kZWZhdWx0R3JvdXBzLmxlbmd0aDtcblxuICAgICAgICAgIHRoaXMuX2RlZmF1bHRJbmRleCsrO1xuICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLl9kZWZhdWx0R3JvdXBzW19pbmRleF07XG5cbiAgICAgICAgICB0aGlzLl9ncm91cHMuc2V0KGdyb3VwbmFtZSwgZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBncm91cCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAsIGEgbmV3IGdyb3VwIHdpbGwgYmVcbiAgICAgKiBjcmVhdGVkIGlmIGEgZ3JvdXAgd2l0aCB0aGUgc2FtZSBuYW1lIGRvZXNuJ3QgZXhpc3QsIG90aGVyd2lzZSB0aGUgb2xkXG4gICAgICogZ3JvdXBzIHN0eWxlIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYm9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcixcbiAgICAgKiBldGMuXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGNyZWF0ZWQgZ3JvdXAgb2JqZWN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChncm91cE5hbWUsIHN0eWxlKSB7XG4gICAgICAvLyBPbmx5IHB1c2ggZ3JvdXAgbmFtZSBvbmNlIHRvIHByZXZlbnQgZHVwbGljYXRlcyB3aGljaCB3b3VsZCBjb25zdW1lIG1vcmVcbiAgICAgIC8vIFJBTSBhbmQgYWxzbyBza2V3IHRoZSBkaXN0cmlidXRpb24gdG93YXJkcyBtb3JlIG9mdGVuIHVwZGF0ZWQgZ3JvdXBzLFxuICAgICAgLy8gbmVpdGhlciBvZiB3aGljaCBpcyBkZXNpcmFibGUuXG4gICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5oYXMoZ3JvdXBOYW1lKSkge1xuICAgICAgICB0aGlzLl9ncm91cE5hbWVzLnB1c2goZ3JvdXBOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cE5hbWUsIHN0eWxlKTtcblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcm91cHM7XG59KCk7XG5cbnZhciAkJGMgPSBfZXhwb3J0OyAvLyBgTnVtYmVyLmlzTmFOYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzbmFuXG5cbiQkYyh7XG4gIHRhcmdldDogJ051bWJlcicsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRhID0gcGF0aCR5O1xudmFyIGlzTmFuJDIgPSBwYXRoJGEuTnVtYmVyLmlzTmFOO1xuXG52YXIgcGFyZW50JHUgPSBpc05hbiQyO1xudmFyIGlzTmFuJDEgPSBwYXJlbnQkdTtcblxudmFyIGlzTmFuID0gaXNOYW4kMTtcblxudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJFA7XG52YXIgZ2xvYmFsSXNGaW5pdGUgPSBnbG9iYWwkNy5pc0Zpbml0ZTsgLy8gYE51bWJlci5pc0Zpbml0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW51bWJlci1pc2Zpbml0ZSAtLSBzYWZlXG5cbnZhciBudW1iZXJJc0Zpbml0ZSQxID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgZ2xvYmFsSXNGaW5pdGUoaXQpO1xufTtcblxudmFyICQkYiA9IF9leHBvcnQ7XG52YXIgbnVtYmVySXNGaW5pdGUgPSBudW1iZXJJc0Zpbml0ZSQxOyAvLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzZmluaXRlXG5cbiQkYih7XG4gIHRhcmdldDogJ051bWJlcicsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgaXNGaW5pdGU6IG51bWJlcklzRmluaXRlXG59KTtcblxudmFyIHBhdGgkOSA9IHBhdGgkeTtcbnZhciBfaXNGaW5pdGUkMiA9IHBhdGgkOS5OdW1iZXIuaXNGaW5pdGU7XG5cbnZhciBwYXJlbnQkdCA9IF9pc0Zpbml0ZSQyO1xudmFyIF9pc0Zpbml0ZSQxID0gcGFyZW50JHQ7XG5cbnZhciBfaXNGaW5pdGUgPSBfaXNGaW5pdGUkMTtcblxudmFyICQkYSA9IF9leHBvcnQ7XG52YXIgJHNvbWUgPSBhcnJheUl0ZXJhdGlvbi5zb21lO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMyA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciBTVFJJQ1RfTUVUSE9EJDMgPSBhcnJheU1ldGhvZElzU3RyaWN0JDMoJ3NvbWUnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcblxuJCRhKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCQzXG59LCB7XG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkNyA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHNvbWUkMyA9IGVudHJ5VmlydHVhbCQ3KCdBcnJheScpLnNvbWU7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDcgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ3ID0gc29tZSQzO1xudmFyIEFycmF5UHJvdG90eXBlJDcgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzb21lJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvbWU7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNyB8fCBpc1Byb3RvdHlwZU9mJDcoQXJyYXlQcm90b3R5cGUkNywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNy5zb21lID8gbWV0aG9kJDcgOiBvd247XG59O1xuXG52YXIgcGFyZW50JHMgPSBzb21lJDI7XG52YXIgc29tZSQxID0gcGFyZW50JHM7XG5cbnZhciBzb21lID0gc29tZSQxO1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkUDtcbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckNDtcbnZhciBUeXBlRXJyb3IkMyA9IGdsb2JhbCQ2LlR5cGVFcnJvcjsgLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcblxudmFyIGFDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IkMyh0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDEgPSBmdW5jdGlvbkJpbmQ7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGQ7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JGo7XG52YXIgY3JlYXRlJDMgPSBvYmplY3RDcmVhdGU7XG52YXIgZmFpbHMkMyA9IGZhaWxzJHQ7XG52YXIgbmF0aXZlQ29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIHB1c2gkMSA9IFtdLnB1c2g7IC8vIGBSZWZsZWN0LmNvbnN0cnVjdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcblxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiAhKG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9KTtcbn0pO1xudmFyIEZPUkNFRCQyID0gTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUc7XG4kJDkoe1xuICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBGT1JDRUQkMixcbiAgc2hhbTogRk9SQ0VEJDJcbn0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzXG4gIC8qICwgbmV3VGFyZ2V0ICovXG4gICkge1xuICAgIGFDb25zdHJ1Y3RvcihUYXJnZXQpO1xuICAgIGFuT2JqZWN0JDIoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUNvbnN0cnVjdG9yKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIG5hdGl2ZUNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG5cbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KCk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfSAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuXG5cbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgIGFwcGx5KHB1c2gkMSwgJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYXBwbHkoYmluZCQxLCBUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9IC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuXG5cbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZSQzKGlzT2JqZWN0JDMocHJvdG8pID8gcHJvdG8gOiBPYmplY3RQcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBhcHBseShUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QkMyhyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCQ4ID0gcGF0aCR5O1xudmFyIGNvbnN0cnVjdCQyID0gcGF0aCQ4LlJlZmxlY3QuY29uc3RydWN0O1xuXG52YXIgcGFyZW50JHIgPSBjb25zdHJ1Y3QkMjtcbnZhciBjb25zdHJ1Y3QkMSA9IHBhcmVudCRyO1xuXG52YXIgY29uc3RydWN0ID0gY29uc3RydWN0JDE7XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbnZhciBwYXJlbnQkcSA9IGNyZWF0ZSQ2O1xudmFyIGNyZWF0ZSQyID0gcGFyZW50JHE7XG5cbnZhciBwYXJlbnQkcCA9IGNyZWF0ZSQyO1xudmFyIGNyZWF0ZSQxID0gcGFyZW50JHA7XG5cbnZhciBjcmVhdGUgPSBjcmVhdGUkMTtcblxudmFyICQkOCA9IF9leHBvcnQ7XG52YXIgc2V0UHJvdG90eXBlT2YkNSA9IG9iamVjdFNldFByb3RvdHlwZU9mOyAvLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG5cbiQkOCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgc2V0UHJvdG90eXBlT2Y6IHNldFByb3RvdHlwZU9mJDVcbn0pO1xuXG52YXIgcGF0aCQ3ID0gcGF0aCR5O1xudmFyIHNldFByb3RvdHlwZU9mJDQgPSBwYXRoJDcuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG52YXIgcGFyZW50JG8gPSBzZXRQcm90b3R5cGVPZiQ0O1xudmFyIHNldFByb3RvdHlwZU9mJDMgPSBwYXJlbnQkbztcblxudmFyIHBhcmVudCRuID0gc2V0UHJvdG90eXBlT2YkMztcbnZhciBzZXRQcm90b3R5cGVPZiQyID0gcGFyZW50JG47XG5cbnZhciBwYXJlbnQkbSA9IHNldFByb3RvdHlwZU9mJDI7XG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IHBhcmVudCRtO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiQxO1xuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IGNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBkZWZpbmVQcm9wZXJ0eSQzKHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuXG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbnZhciBwYXJlbnQkbCA9IGdldFByb3RvdHlwZU9mJDU7XG52YXIgZ2V0UHJvdG90eXBlT2YkMyA9IHBhcmVudCRsO1xuXG52YXIgcGFyZW50JGsgPSBnZXRQcm90b3R5cGVPZiQzO1xudmFyIGdldFByb3RvdHlwZU9mJDIgPSBwYXJlbnQkaztcblxudmFyIGdldFByb3RvdHlwZU9mJDEgPSBnZXRQcm90b3R5cGVPZiQyO1xuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiA/IGdldFByb3RvdHlwZU9mJDEgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBnZXRQcm90b3R5cGVPZiQxKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG52YXIgcnVudGltZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdmFyIHJ1bnRpbWUgPSBmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gICAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHVuZGVmaW5lZCQxOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cblxuICAgIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICAgIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICAgIGRlZmluZSh7fSwgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG5cbiAgICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgfVxuXG4gICAgZXhwb3J0cy53cmFwID0gd3JhcDsgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gICAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gICAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gICAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAgIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gICAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gICAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuXG4gICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICAgIGFyZzogZXJyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gICAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiOyAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuXG4gICAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gICAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gICAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuXG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAgIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG5cblxuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICAgIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG5cbiAgICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAgIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG5cbiAgICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gICAgfTtcblxuICAgIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgICAgcmV0dXJuIGdlbkZ1bjtcbiAgICB9OyAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAgIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuXG5cbiAgICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX19hd2FpdDogYXJnXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgICB9IC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cblxuXG4gICAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICAgIH1cblxuICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yOyAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gICAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG5cbiAgICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcbiAgICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfSAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcblxuXG4gICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkOyAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuXG4gICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gICAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gICAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG5cblxuICAgIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCQxKSB7XG4gICAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7IC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cblxuICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jOyAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG5cblxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9IC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gICAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuXG5cbiAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICAgIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpOyAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAgIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gICAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIHRyeUxvYzogbG9jc1swXVxuICAgICAgfTtcblxuICAgICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgICAgfV07XG4gICAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgICB0aGlzLnJlc2V0KHRydWUpO1xuICAgIH1cblxuICAgIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleXMucmV2ZXJzZSgpOyAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG5cblxuICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcblxuICAgICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCQxLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgICByZXNldDogZnVuY3Rpb24gKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gMDsgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cblxuICAgICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWJydXB0OiBmdW5jdGlvbiAodHlwZSwgYXJnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiBmdW5jdGlvbiAoZmluYWxseUxvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cblxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICAgIH0sXG4gICAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH07IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH0oIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgbW9kdWxlLmV4cG9ydHMgKTtcblxuICB0cnkge1xuICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gICAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gICAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAgIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAgIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAgIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gICAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgICB9XG4gIH1cbn0pKHJ1bnRpbWUpO1xuXG52YXIgcmVnZW5lcmF0b3IgPSBydW50aW1lLmV4cG9ydHM7XG5cbnZhciBnbG9iYWwkNSA9IGdsb2JhbCRQO1xudmFyIGFDYWxsYWJsZSQyID0gYUNhbGxhYmxlJDc7XG52YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JGU7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMyA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgVHlwZUVycm9yJDIgPSBnbG9iYWwkNS5UeXBlRXJyb3I7IC8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFDYWxsYWJsZSQyKGNhbGxiYWNrZm4pO1xuICAgIHZhciBPID0gdG9PYmplY3QkMih0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDMoTyk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaW5kZXggKz0gaTtcblxuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvciQyKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IElTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbnZhciBhcnJheVJlZHVjZSA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBjbGFzc29mJDMgPSBjbGFzc29mUmF3JDE7XG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkUDtcbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJDMoZ2xvYmFsJDQucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgJCQ3ID0gX2V4cG9ydDtcbnZhciAkcmVkdWNlID0gYXJyYXlSZWR1Y2UubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDIgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfTk9ERSA9IGVuZ2luZUlzTm9kZTtcbnZhciBTVFJJQ1RfTUVUSE9EJDIgPSBhcnJheU1ldGhvZElzU3RyaWN0JDIoJ3JlZHVjZScpOyAvLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG5cbnZhciBDSFJPTUVfQlVHID0gIUlTX05PREUgJiYgQ0hST01FX1ZFUlNJT04gPiA3OSAmJiBDSFJPTUVfVkVSU0lPTiA8IDgzOyAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcblxuJCQ3KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCQyIHx8IENIUk9NRV9CVUdcbn0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmblxuICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICApIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ2ID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgcmVkdWNlJDMgPSBlbnRyeVZpcnR1YWwkNignQXJyYXknKS5yZWR1Y2U7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDYgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ2ID0gcmVkdWNlJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkNiA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHJlZHVjZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5yZWR1Y2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNiB8fCBpc1Byb3RvdHlwZU9mJDYoQXJyYXlQcm90b3R5cGUkNiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNi5yZWR1Y2UgPyBtZXRob2QkNiA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkaiA9IHJlZHVjZSQyO1xudmFyIHJlZHVjZSQxID0gcGFyZW50JGo7XG5cbnZhciByZWR1Y2UgPSByZWR1Y2UkMTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJFA7XG52YXIgaXNBcnJheSA9IGlzQXJyYXkkZDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQyID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbCQzLlR5cGVFcnJvcjsgLy8gYEZsYXR0ZW5JbnRvQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxuXG52YXIgZmxhdHRlbkludG9BcnJheSQxID0gZnVuY3Rpb24gKHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gYmluZChtYXBwZXIsIHRoaXNBcmcpIDogZmFsc2U7XG4gIHZhciBlbGVtZW50LCBlbGVtZW50TGVuO1xuXG4gIHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuICAgIGlmIChzb3VyY2VJbmRleCBpbiBzb3VyY2UpIHtcbiAgICAgIGVsZW1lbnQgPSBtYXBGbiA/IG1hcEZuKHNvdXJjZVtzb3VyY2VJbmRleF0sIHNvdXJjZUluZGV4LCBvcmlnaW5hbCkgOiBzb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgICBpZiAoZGVwdGggPiAwICYmIGlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudExlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoZWxlbWVudCk7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZmxhdHRlbkludG9BcnJheSQxKHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIGVsZW1lbnRMZW4sIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFGRkZGRkZGRkZGRkZGKSB0aHJvdyBUeXBlRXJyb3IkMSgnRXhjZWVkIHRoZSBhY2NlcHRhYmxlIGFycmF5IGxlbmd0aCcpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG5cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufTtcblxudmFyIGZsYXR0ZW5JbnRvQXJyYXlfMSA9IGZsYXR0ZW5JbnRvQXJyYXkkMTtcblxudmFyICQkNiA9IF9leHBvcnQ7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IGZsYXR0ZW5JbnRvQXJyYXlfMTtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ3O1xudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCRlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IGFycmF5U3BlY2llc0NyZWF0ZSQ0OyAvLyBgQXJyYXkucHJvdG90eXBlLmZsYXRNYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmxhdG1hcFxuXG4kJDYoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlXG59LCB7XG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQxKHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQxKE8pO1xuICAgIHZhciBBO1xuICAgIGFDYWxsYWJsZSQxKGNhbGxiYWNrZm4pO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgQS5sZW5ndGggPSBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ1ID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgZmxhdE1hcCQzID0gZW50cnlWaXJ0dWFsJDUoJ0FycmF5JykuZmxhdE1hcDtcblxudmFyIGlzUHJvdG90eXBlT2YkNSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDUgPSBmbGF0TWFwJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkNSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGZsYXRNYXAkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZmxhdE1hcDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ1IHx8IGlzUHJvdG90eXBlT2YkNShBcnJheVByb3RvdHlwZSQ1LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ1LmZsYXRNYXAgPyBtZXRob2QkNSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkaSA9IGZsYXRNYXAkMjtcbnZhciBmbGF0TWFwJDEgPSBwYXJlbnQkaTtcblxudmFyIGZsYXRNYXAgPSBmbGF0TWFwJDE7XG5cbnZhciBjb2xsZWN0aW9uJDEgPSBjb2xsZWN0aW9uJDM7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IGNvbGxlY3Rpb25TdHJvbmckMjsgLy8gYFNldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcblxuY29sbGVjdGlvbiQxKCdTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG5cbnZhciBwYXRoJDYgPSBwYXRoJHk7XG52YXIgc2V0JDIgPSBwYXRoJDYuU2V0O1xuXG52YXIgcGFyZW50JGggPSBzZXQkMjtcbnZhciBzZXQkMSA9IHBhcmVudCRoO1xuXG52YXIgc2V0ID0gc2V0JDE7XG5cbnZhciBpdGVyYXRvciA9IGl0ZXJhdG9yJDQ7XG5cbnZhciBnZXRJdGVyYXRvciQ0ID0gZ2V0SXRlcmF0b3IkNztcbnZhciBnZXRJdGVyYXRvcl8xID0gZ2V0SXRlcmF0b3IkNDtcblxudmFyIHBhcmVudCRnID0gZ2V0SXRlcmF0b3JfMTtcbnZhciBnZXRJdGVyYXRvciQzID0gcGFyZW50JGc7XG5cbnZhciBwYXJlbnQkZiA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3IkMiA9IHBhcmVudCRmO1xuXG52YXIgcGFyZW50JGUgPSBnZXRJdGVyYXRvciQyO1xudmFyIGdldEl0ZXJhdG9yJDEgPSBwYXJlbnQkZTtcblxudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMTtcblxudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlU2ltcGxlO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoYXJyYXksIG1lcmdlU29ydChhcnJheVNsaWNlKGFycmF5LCAwLCBtaWRkbGUpLCBjb21wYXJlZm4pLCBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSwgY29tcGFyZWZuKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcblxuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cblxuICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gbGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdIDogbGluZGV4IDwgbGxlbmd0aCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5U29ydCA9IG1lcmdlU29ydDtcblxudmFyIHVzZXJBZ2VudCQxID0gZW5naW5lVXNlckFnZW50O1xudmFyIGZpcmVmb3ggPSB1c2VyQWdlbnQkMS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcbnZhciBlbmdpbmVGZlZlcnNpb24gPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cbnZhciBVQSA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBlbmdpbmVJc0llT3JFZGdlID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7XG5cbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgd2Via2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xudmFyIGVuZ2luZVdlYmtpdFZlcnNpb24gPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuXG52YXIgJCQ1ID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkNztcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JGU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIHRvU3RyaW5nJDEgPSB0b1N0cmluZyQ4O1xudmFyIGZhaWxzJDIgPSBmYWlscyR0O1xudmFyIGludGVybmFsU29ydCA9IGFycmF5U29ydDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgRkYgPSBlbmdpbmVGZlZlcnNpb247XG52YXIgSUVfT1JfRURHRSA9IGVuZ2luZUlzSWVPckVkZ2U7XG52YXIgVjggPSBlbmdpbmVWOFZlcnNpb247XG52YXIgV0VCS0lUID0gZW5naW5lV2Via2l0VmVyc2lvbjtcbnZhciB0ZXN0ID0gW107XG52YXIgdW4kU29ydCA9IHVuY3VycnlUaGlzJDModGVzdC5zb3J0KTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMkMyh0ZXN0LnB1c2gpOyAvLyBJRTgtXG5cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KTsgLy8gVjggYnVnXG5cbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydChudWxsKTtcbn0pOyAvLyBPbGQgV2ViS2l0XG5cbnZhciBTVFJJQ1RfTUVUSE9EJDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDEoJ3NvcnQnKTtcbnZhciBTVEFCTEVfU09SVCA9ICFmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzA7XG4gIGlmIChGRiAmJiBGRiA+IDMpIHJldHVybjtcbiAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAzO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjb2RlLCBjaHIsIHZhbHVlLCBpbmRleDsgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG5cbiAgZm9yIChjb2RlID0gNjU7IGNvZGUgPCA3NjsgY29kZSsrKSB7XG4gICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA2NjpcbiAgICAgIGNhc2UgNjk6XG4gICAgICBjYXNlIDcwOlxuICAgICAgY2FzZSA3MjpcbiAgICAgICAgdmFsdWUgPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2ODpcbiAgICAgIGNhc2UgNzE6XG4gICAgICAgIHZhbHVlID0gNDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhbHVlID0gMjtcbiAgICB9XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0NzsgaW5kZXgrKykge1xuICAgICAgdGVzdC5wdXNoKHtcbiAgICAgICAgazogY2hyICsgaW5kZXgsXG4gICAgICAgIHY6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0ZXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi52IC0gYS52O1xuICB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0ZXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IHRlc3RbaW5kZXhdLmsuY2hhckF0KDApO1xuICAgIGlmIChyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSAhPT0gY2hyKSByZXN1bHQgKz0gY2hyO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gJ0RHQkVGSEFDSUpLJztcbn0pO1xudmFyIEZPUkNFRCQxID0gRkFJTFNfT05fVU5ERUZJTkVEIHx8ICFGQUlMU19PTl9OVUxMIHx8ICFTVFJJQ1RfTUVUSE9EJDEgfHwgIVNUQUJMRV9TT1JUO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgcmV0dXJuIHRvU3RyaW5nJDEoeCkgPiB0b1N0cmluZyQxKHkpID8gMSA6IC0xO1xuICB9O1xufTsgLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcblxuXG4kJDUoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IEZPUkNFRCQxXG59LCB7XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSBhQ2FsbGFibGUoY29tcGFyZWZuKTtcbiAgICB2YXIgYXJyYXkgPSB0b09iamVjdCh0aGlzKTtcbiAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IHVuJFNvcnQoYXJyYXkpIDogdW4kU29ydChhcnJheSwgY29tcGFyZWZuKTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgYXJyYXlMZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShhcnJheSk7XG4gICAgdmFyIGl0ZW1zTGVuZ3RoLCBpbmRleDtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoaW5kZXggaW4gYXJyYXkpIHB1c2goaXRlbXMsIGFycmF5W2luZGV4XSk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxTb3J0KGl0ZW1zLCBnZXRTb3J0Q29tcGFyZShjb21wYXJlZm4pKTtcbiAgICBpdGVtc0xlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBpdGVtc0xlbmd0aCkgYXJyYXlbaW5kZXhdID0gaXRlbXNbaW5kZXgrK107XG5cbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheUxlbmd0aCkgZGVsZXRlIGFycmF5W2luZGV4KytdO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ0ID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgc29ydCQzID0gZW50cnlWaXJ0dWFsJDQoJ0FycmF5Jykuc29ydDtcblxudmFyIGlzUHJvdG90eXBlT2YkNCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDQgPSBzb3J0JDM7XG52YXIgQXJyYXlQcm90b3R5cGUkNCA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNvcnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc29ydDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ0IHx8IGlzUHJvdG90eXBlT2YkNChBcnJheVByb3RvdHlwZSQ0LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ0LnNvcnQgPyBtZXRob2QkNCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkZCA9IHNvcnQkMjtcbnZhciBzb3J0JDEgPSBwYXJlbnQkZDtcblxudmFyIHNvcnQgPSBzb3J0JDE7XG5cbnZhciBlbnRyeVZpcnR1YWwkMyA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGtleXMkMyA9IGVudHJ5VmlydHVhbCQzKCdBcnJheScpLmtleXM7XG5cbnZhciBwYXJlbnQkYyA9IGtleXMkMztcbnZhciBrZXlzJDIgPSBwYXJlbnQkYztcblxudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2YkZTtcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkMyA9IGtleXMkMjtcbnZhciBBcnJheVByb3RvdHlwZSQzID0gQXJyYXkucHJvdG90eXBlO1xudmFyIERPTUl0ZXJhYmxlcyQyID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIga2V5cyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5rZXlzO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDMgfHwgaXNQcm90b3R5cGVPZiQzKEFycmF5UHJvdG90eXBlJDMsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDMua2V5cyB8fCBoYXNPd24kNChET01JdGVyYWJsZXMkMiwgY2xhc3NvZiQyKGl0KSkgPyBtZXRob2QkMyA6IG93bjtcbn07XG5cbnZhciBrZXlzID0ga2V5cyQxO1xuXG52YXIgZW50cnlWaXJ0dWFsJDIgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciB2YWx1ZXMkMyA9IGVudHJ5VmlydHVhbCQyKCdBcnJheScpLnZhbHVlcztcblxudmFyIHBhcmVudCRiID0gdmFsdWVzJDM7XG52YXIgdmFsdWVzJDIgPSBwYXJlbnQkYjtcblxudmFyIGNsYXNzb2YkMSA9IGNsYXNzb2YkZTtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkMiA9IHZhbHVlcyQyO1xudmFyIEFycmF5UHJvdG90eXBlJDIgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgRE9NSXRlcmFibGVzJDEgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbnZhciB2YWx1ZXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQudmFsdWVzO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDIgfHwgaXNQcm90b3R5cGVPZiQyKEFycmF5UHJvdG90eXBlJDIsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDIudmFsdWVzIHx8IGhhc093biQzKERPTUl0ZXJhYmxlcyQxLCBjbGFzc29mJDEoaXQpKSA/IG1ldGhvZCQyIDogb3duO1xufTtcblxudmFyIHZhbHVlcyA9IHZhbHVlcyQxO1xuXG52YXIgZW50cnlWaXJ0dWFsJDEgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBlbnRyaWVzJDMgPSBlbnRyeVZpcnR1YWwkMSgnQXJyYXknKS5lbnRyaWVzO1xuXG52YXIgcGFyZW50JGEgPSBlbnRyaWVzJDM7XG52YXIgZW50cmllcyQyID0gcGFyZW50JGE7XG5cbnZhciBjbGFzc29mID0gY2xhc3NvZiRlO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQxID0gZW50cmllcyQyO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIgZW50cmllcyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5lbnRyaWVzO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDEgfHwgaXNQcm90b3R5cGVPZiQxKEFycmF5UHJvdG90eXBlJDEsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDEuZW50cmllcyB8fCBoYXNPd24kMihET01JdGVyYWJsZXMsIGNsYXNzb2YoaXQpKSA/IG1ldGhvZCQxIDogb3duO1xufTtcblxudmFyIGVudHJpZXMgPSBlbnRyaWVzJDE7XG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn1cblxudmFyIFJFR0VYID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwOyAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcblxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkNChvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gZmlsdGVyKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIF9jb250ZXh0MzIsIF9jb250ZXh0MzM7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IGZvckVhY2gkMihfY29udGV4dDMyID0gb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCAhMCkpLmNhbGwoX2NvbnRleHQzMiwgZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBmb3JFYWNoJDIoX2NvbnRleHQzMyA9IG93bktleXMkNChPYmplY3Qoc291cmNlKSkpLmNhbGwoX2NvbnRleHQzMywgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQ2KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciR0KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQzMTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDMxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MzEsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxyXG4gKiBDcmVhdGUgbmV3IGRhdGEgcGlwZS5cclxuICpcclxuICogQHBhcmFtIGZyb20gLSBUaGUgc291cmNlIGRhdGEgc2V0IG9yIGRhdGEgdmlldy5cclxuICogQHJlbWFya3NcclxuICogRXhhbXBsZSB1c2FnZTpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbnRlcmZhY2UgQXBwSXRlbSB7XHJcbiAqICAgd2hvYW1pOiBzdHJpbmc7XHJcbiAqICAgYXBwRGF0YTogdW5rbm93bjtcclxuICogICB2aXNEYXRhOiBWaXNJdGVtO1xyXG4gKiB9XHJcbiAqIGludGVyZmFjZSBWaXNJdGVtIHtcclxuICogICBpZDogbnVtYmVyO1xyXG4gKiAgIGxhYmVsOiBzdHJpbmc7XHJcbiAqICAgY29sb3I6IHN0cmluZztcclxuICogICB4OiBudW1iZXI7XHJcbiAqICAgeTogbnVtYmVyO1xyXG4gKiB9XHJcbiAqXHJcbiAqIGNvbnN0IGRzMSA9IG5ldyBEYXRhU2V0PEFwcEl0ZW0sIFwid2hvYW1pXCI+KFtdLCB7IGZpZWxkSWQ6IFwid2hvYW1pXCIgfSk7XHJcbiAqIGNvbnN0IGRzMiA9IG5ldyBEYXRhU2V0PFZpc0l0ZW0sIFwiaWRcIj4oKTtcclxuICpcclxuICogY29uc3QgcGlwZSA9IGNyZWF0ZU5ld0RhdGFQaXBlRnJvbShkczEpXHJcbiAqICAgLmZpbHRlcigoaXRlbSk6IGJvb2xlYW4gPT4gaXRlbS5lbmFibGVkID09PSB0cnVlKVxyXG4gKiAgIC5tYXA8VmlzSXRlbSwgXCJpZFwiPigoaXRlbSk6IFZpc0l0ZW0gPT4gaXRlbS52aXNEYXRhKVxyXG4gKiAgIC50byhkczIpO1xyXG4gKlxyXG4gKiBwaXBlLnN0YXJ0KCk7XHJcbiAqIGBgYFxyXG4gKiBAcmV0dXJucyBBIGZhY3Rvcnkgd2hvc2UgbWV0aG9kcyBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgdGhlIHBpcGUuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdEYXRhUGlwZUZyb20oZnJvbSkge1xuICByZXR1cm4gbmV3IERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24oZnJvbSk7XG59XG4vKipcclxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHBpcGUuIFRoaXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb25seSB0aHJvdWdoXHJcbiAqIGBjcmVhdGVOZXdEYXRhUGlwZUZyb21gIGZyb20gdGhlIG91dHNpZGUuXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gU0kgLSBTb3VyY2UgaXRlbSB0eXBlLlxyXG4gKiBAdHlwZVBhcmFtIFNQIC0gU291cmNlIGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAqL1xuXG5cbnZhciBTaW1wbGVEYXRhUGlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEJvdW5kIGxpc3RlbmVycyBmb3IgdXNlIHdpdGggYERhdGFJbnRlcmZhY2VbJ29uJyB8ICdvZmYnXWAuXHJcbiAgICovXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGEgcGlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBfc291cmNlIC0gVGhlIGRhdGEgc2V0IG9yIGRhdGEgdmlldyB0aGF0IHdpbGwgYmUgb2JzZXJ2ZWQuXHJcbiAgICogQHBhcmFtIF90cmFuc2Zvcm1lcnMgLSBBbiBhcnJheSBvZiB0cmFuc2Zvcm1pbmcgZnVuY3Rpb25zIHRvIGJlIHVzZWQgdG9cclxuICAgKiBmaWx0ZXIgb3IgdHJhbnNmb3JtIHRoZSBpdGVtcyBpbiB0aGUgcGlwZS5cclxuICAgKiBAcGFyYW0gX3RhcmdldCAtIFRoZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGl0ZW1zLlxyXG4gICAqL1xuICBmdW5jdGlvbiBTaW1wbGVEYXRhUGlwZShfc291cmNlLCBfdHJhbnNmb3JtZXJzLCBfdGFyZ2V0KSB7XG4gICAgdmFyIF9jb250ZXh0LCBfY29udGV4dDIsIF9jb250ZXh0MztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW1wbGVEYXRhUGlwZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc291cmNlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJhbnNmb3JtZXJzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGlzdGVuZXJzXCIsIHtcbiAgICAgIGFkZDogYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5fYWRkKS5jYWxsKF9jb250ZXh0LCB0aGlzKSxcbiAgICAgIHJlbW92ZTogYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuX3JlbW92ZSkuY2FsbChfY29udGV4dDIsIHRoaXMpLFxuICAgICAgdXBkYXRlOiBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5fdXBkYXRlKS5jYWxsKF9jb250ZXh0MywgdGhpcylcbiAgICB9KTtcblxuICAgIHRoaXMuX3NvdXJjZSA9IF9zb3VyY2U7XG4gICAgdGhpcy5fdHJhbnNmb3JtZXJzID0gX3RyYW5zZm9ybWVycztcbiAgICB0aGlzLl90YXJnZXQgPSBfdGFyZ2V0O1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNpbXBsZURhdGFQaXBlLCBbe1xuICAgIGtleTogXCJhbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0LnVwZGF0ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KCkpKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub24oXCJhZGRcIiwgdGhpcy5fbGlzdGVuZXJzLmFkZCk7XG5cbiAgICAgIHRoaXMuX3NvdXJjZS5vbihcInJlbW92ZVwiLCB0aGlzLl9saXN0ZW5lcnMucmVtb3ZlKTtcblxuICAgICAgdGhpcy5fc291cmNlLm9uKFwidXBkYXRlXCIsIHRoaXMuX2xpc3RlbmVycy51cGRhdGUpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwiYWRkXCIsIHRoaXMuX2xpc3RlbmVycy5hZGQpO1xuXG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwicmVtb3ZlXCIsIHRoaXMuX2xpc3RlbmVycy5yZW1vdmUpO1xuXG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwidXBkYXRlXCIsIHRoaXMuX2xpc3RlbmVycy51cGRhdGUpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgdHJhbnNmb3JtZXJzIHRvIHRoZSBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gYmUgdHJhbnNmb3JtZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl90cmFuc2Zvcm1JdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNmb3JtSXRlbXMoaXRlbXMpIHtcbiAgICAgIHZhciBfY29udGV4dDQ7XG5cbiAgICAgIHJldHVybiByZWR1Y2UoX2NvbnRleHQ0ID0gdGhpcy5fdHJhbnNmb3JtZXJzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGl0ZW1zLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShpdGVtcyk7XG4gICAgICB9LCBpdGVtcyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGFuIGFkZCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgLSBJZ25vcmVkLlxyXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgcGF5bG9hZCBjb250YWluaW5nIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQoX25hbWUsIHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90YXJnZXQuYWRkKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQocGF5bG9hZC5pdGVtcykpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgYW4gdXBkYXRlIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIGNvbnRhaW5pbmcgdGhlIGlkcyBvZiB0aGUgdXBkYXRlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKF9uYW1lLCBwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGFyZ2V0LnVwZGF0ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KHBheWxvYWQuaXRlbXMpKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGEgcmVtb3ZlIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgdGhlIHJlbW92ZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZShfbmFtZSwgcGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmUodGhpcy5fdHJhbnNmb3JtSXRlbXMocGF5bG9hZC5vbGREYXRhKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbXBsZURhdGFQaXBlO1xufSgpO1xuLyoqXHJcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwaXBlIGZhY3RvcnkuIFRoaXMgc2hvdWxkIGJlIGFjY2Vzc2libGVcclxuICogb25seSB0aHJvdWdoIGBjcmVhdGVOZXdEYXRhUGlwZUZyb21gIGZyb20gdGhlIG91dHNpZGUuXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAqL1xuXG5cbnZhciBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQXJyYXkgdHJhbnNmb3JtZXJzIHVzZWQgdG8gdHJhbnNmb3JtIGl0ZW1zIHdpdGhpbiB0aGUgcGlwZS4gVGhpcyBpcyB0eXBlZFxyXG4gICAqIGFzIGFueSBmb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eS5cclxuICAgKi9cblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBwaXBlIGZhY3RvcnkuIFRoaXMgaXMgYW4gaW50ZXJuYWwgY29uc3RydWN0b3IgdGhhdFxyXG4gICAqIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIG9mIHRoaXMgZmlsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBfc291cmNlIC0gVGhlIHNvdXJjZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgZm9yIHRoaXMgcGlwZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbihfc291cmNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NvdXJjZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RyYW5zZm9ybWVyc1wiLCBbXSk7XG5cbiAgICB0aGlzLl9zb3VyY2UgPSBfc291cmNlO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbHRlciB0aGUgaXRlbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGZpbHRlcmluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBnaXZlbiBpdGVtXHJcbiAgICogc2hvdWxkIGJlIHBpcGVkIGFuZCBmYWxzZSBpZiBub3QuXHJcbiAgICogQHJldHVybnMgVGhpcyBmYWN0b3J5IGZvciBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbiwgW3tcbiAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlciQxKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihpbnB1dCkuY2FsbChpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIE1hcCBlYWNoIHNvdXJjZSBpdGVtIHRvIGEgbmV3IHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBtYXBwaW5nIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzb3VyY2UgaXRlbSBhbmQgcmV0dXJuc1xyXG4gICAgICogY29ycmVzcG9uZGluZyBtYXBwZWQgaXRlbS5cclxuICAgICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gICAgICogQHR5cGVQYXJhbSBUUCAtIFRhcmdldCBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICogQHJldHVybnMgVGhpcyBmYWN0b3J5IGZvciBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbWFwJDMoaW5wdXQpLmNhbGwoaW5wdXQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBNYXAgZWFjaCBzb3VyY2UgaXRlbSB0byB6ZXJvIG9yIG1vcmUgaXRlbXMgb2YgYSBuZXcgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIG1hcHBpbmcgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNvdXJjZSBpdGVtIGFuZCByZXR1cm5zXHJcbiAgICAgKiBhbiBhcnJheSBvZiBjb3JyZXNwb25kaW5nIG1hcHBlZCBpdGVtcy5cclxuICAgICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxyXG4gICAgICogQHR5cGVQYXJhbSBUUCAtIFRhcmdldCBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICogQHJldHVybnMgVGhpcyBmYWN0b3J5IGZvciBmdXJ0aGVyIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZsYXRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxhdE1hcCQxKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAoaW5wdXQpLmNhbGwoaW5wdXQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IHRoaXMgcGlwZSB0byBnaXZlbiBkYXRhIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGRhdGEgc2V0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBpdGVtcyBmcm9tIHRoaXMgcGlwZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBwaXBlIGNvbm5lY3RlZCBiZXR3ZWVuIGdpdmVuIGRhdGEgc2V0cyBhbmQgcGVyZm9ybWluZ1xyXG4gICAgICogY29uZmlndXJlZCB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgcHJvY2Vzc2VkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBuZXcgU2ltcGxlRGF0YVBpcGUodGhpcy5fc291cmNlLCB0aGlzLl90cmFuc2Zvcm1lcnMsIHRhcmdldCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb247XG59KCk7XG4vKipcclxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpZC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCBpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0lkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuLyoqXHJcbiAqIEEgcXVldWUuXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIG1ldGhvZCBuYW1lcyB0byBiZSByZXBsYWNlZCBieSBxdWV1ZWQgdmVyc2lvbnMuXHJcbiAqL1xuXG5cbnZhciBRdWV1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKiBEZWxheSBpbiBtaWxsaXNlY29uZHMuIElmIGRlZmluZWQgdGhlIHF1ZXVlIHdpbGwgYmUgcGVyaW9kaWNhbGx5IGZsdXNoZWQuICovXG5cbiAgLyoqIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlIGJlZm9yZSBpdCB3aWxsIGJlIGZsdXNoZWQuICovXG5cbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IFF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBRdWV1ZSBjb25maWd1cmF0aW9uLlxyXG4gICAqL1xuICBmdW5jdGlvbiBRdWV1ZShvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1ZXVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlbGF5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9xdWV1ZVwiLCBbXSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGltZW91dFwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9leHRlbmRlZFwiLCBudWxsKTtcblxuICAgIC8vIG9wdGlvbnNcbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICB0aGlzLm1heCA9IEluZmluaXR5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBRdWV1ZSBjb25maWd1cmF0aW9uLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFF1ZXVlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLm1heCA9IG9wdGlvbnMubWF4O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHF1ZXVpbmcgZnVuY3Rpb25hbGl0eS5cclxuICAgICAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZCBpbiBvcHRpb25zLnJlcGxhY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBxdWV1ZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSB0aGUgcXVldWUuIFRoZSBxdWV1ZSB3aWxsIGZpcnN0IGZsdXNoIGFsbCBxdWV1ZWQgYWN0aW9ucywgYW5kIGluIGNhc2UgaXQgaGFzIGV4dGVuZGVkIGFuIG9iamVjdCwgd2lsbCByZXN0b3JlIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuXG4gICAgICBpZiAodGhpcy5fZXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2ldO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cbiAgICAgICAgICAgIG9iamVjdFttZXRob2QubmFtZV0gPSBtZXRob2Qub3JpZ2luYWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBiZXR0ZXIgc29sdXRpb24/XG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0W21ldGhvZC5uYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9leHRlbmRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2QuXHJcbiAgICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCBuYW1lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2Uob2JqZWN0LCBtZXRob2QpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyAtLSBGdW5jdGlvbiB0aGlzIGlzIG5lY2Vzc2FyeSBpbiB0aGUgZnVuY3Rpb24gYmVsbG93LCBzbyBjbGFzcyB0aGlzIGhhcyB0byBiZSBzYXZlZCBpbnRvIGEgdmFyaWFibGUgaGVyZS4gKi9cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBvYmplY3RbbWV0aG9kXTtcblxuICAgICAgaWYgKCFvcmlnaW5hbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiB1bmRlZmluZWRcIik7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoaXMgY2FsbCB0byB0aGUgcXVldWVcbiAgICAgICAgbWUucXVldWUoe1xuICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgZm46IG9yaWdpbmFsLFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFF1ZXVlIGEgY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50cnkgLSBUaGUgZnVuY3Rpb24gb3IgZW50cnkgdG8gYmUgcXVldWVkLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJxdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWV1ZShlbnRyeSkge1xuICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGZuOiBlbnRyeVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goZW50cnkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgcXVldWUgbmVlZHMgdG8gYmUgZmx1c2hlZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZsdXNoSWZOZWVkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZsdXNoSWZOZWVkZWQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBmbHVzaCB3aGVuIHRoZSBtYXhpbXVtIGlzIGV4Y2VlZGVkLlxuICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH0gLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuXG5cbiAgICAgIGlmICh0aGlzLl90aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiB0eXBlb2YgdGhpcy5kZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5mbHVzaCgpO1xuICAgICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGbHVzaCBhbGwgcXVldWVkIGNhbGxzXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgdmFyIF9jb250ZXh0NSwgX2NvbnRleHQ2O1xuXG4gICAgICBmb3JFYWNoJDIoX2NvbnRleHQ1ID0gc3BsaWNlJDEoX2NvbnRleHQ2ID0gdGhpcy5fcXVldWUpLmNhbGwoX2NvbnRleHQ2LCAwKSkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBlbnRyeS5mbi5hcHBseShlbnRyeS5jb250ZXh0IHx8IGVudHJ5LmZuLCBlbnRyeS5hcmdzIHx8IFtdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImV4dGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmQob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgICAgIGlmIChvYmplY3QuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGEgcHJvcGVydHkgZmx1c2hcIik7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcXVldWUuZmx1c2goKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBtZXRob2RzID0gW3tcbiAgICAgICAgbmFtZTogXCJmbHVzaFwiLFxuICAgICAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gICAgICB9XTtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLnJlcGxhY2VbaV07XG4gICAgICAgICAgbWV0aG9kcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgb3JpZ2luYWw6IG9iamVjdFtuYW1lXVxuICAgICAgICAgIH0pOyAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuXG4gICAgICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIG1ldGhvZHM6IG1ldGhvZHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gcXVldWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFF1ZXVlO1xufSgpO1xuLyoqXHJcbiAqIFtbRGF0YVNldF1dIGNvZGUgdGhhdCBjYW4gYmUgcmV1c2VkIGluIFtbRGF0YVZpZXddXSBvciBvdGhlciBzaW1pbGFyIGltcGxlbWVudGF0aW9ucyBvZiBbW0RhdGFJbnRlcmZhY2VdXS5cclxuICpcclxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cclxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICovXG5cblxudmFyIERhdGFTZXRQYXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YVNldFBhcnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFTZXRQYXJ0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdWJzY3JpYmVyc1wiLCB7XG4gICAgICBcIipcIjogW10sXG4gICAgICBhZGQ6IFtdLFxuICAgICAgcmVtb3ZlOiBbXSxcbiAgICAgIHVwZGF0ZTogW11cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1YnNjcmliZVwiLCBEYXRhU2V0UGFydC5wcm90b3R5cGUub24pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5zdWJzY3JpYmVcIiwgRGF0YVNldFBhcnQucHJvdG90eXBlLm9mZik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF0YVNldFBhcnQsIFt7XG4gICAga2V5OiBcIl90cmlnZ2VyXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gRXZlbnQgcGF5bG9hZC5cclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIElkIG9mIHRoZSBzZW5kZXIuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgc2VuZGVySWQpIHtcbiAgICAgIHZhciBfY29udGV4dDcsIF9jb250ZXh0ODtcblxuICAgICAgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJpZ2dlciBldmVudCAqXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3JFYWNoJDIoX2NvbnRleHQ3ID0gY29uY2F0KF9jb250ZXh0OCA9IFtdKS5jYWxsKF9jb250ZXh0OCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdWJzY3JpYmVyc1tcIipcIl0pKSkuY2FsbChfY29udGV4dDcsIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHN1YnNjcmliZXIoZXZlbnQsIHBheWxvYWQsIHNlbmRlcklkICE9IG51bGwgPyBzZW5kZXJJZCA6IG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50LCBhZGQgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3MgTm9uLWZ1bmN0aW9uIGNhbGxiYWNrcyBhcmUgaWdub3JlZC5cclxuICAgICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBtZXRob2QuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gLy8gQFRPRE86IE1heWJlIHRocm93IGZvciBpbnZhbGlkIGNhbGxiYWNrcz9cblxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQsIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrcyBJZiB0aGUgc2FtZSBjYWxsYmFjayB3YXMgc3Vic2NyaWJlZCBtb3JlIHRoYW4gb25jZSAqKmFsbCoqIG9jY3VyZW5jZXMgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIG1ldGhvZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfY29udGV4dDk7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IGZpbHRlcihfY29udGV4dDkgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pLmNhbGwoX2NvbnRleHQ5LCBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlciAhPT0gY2FsbGJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugb24gaW5zdGVhZCAoUFM6IERhdGFWaWV3LnN1YnNjcmliZSA9PT0gRGF0YVZpZXcub24pLlxyXG4gICAgICovXG5cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhU2V0UGFydDtcbn0oKTtcbi8qKlxyXG4gKiBEYXRhIHN0cmVhbVxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBbW0RhdGFTdHJlYW1dXSBvZmZlcnMgYW4gYWx3YXlzIHVwIHRvIGRhdGUgc3RyZWFtIG9mIGl0ZW1zIGZyb20gYSBbW0RhdGFTZXRdXSBvciBbW0RhdGFWaWV3XV0uXHJcbiAqIFRoYXQgbWVhbnMgdGhhdCB0aGUgc3RyZWFtIGlzIGV2YWx1YXRlZCBhdCB0aGUgdGltZSBvZiBpdGVyYXRpb24sIGNvbnZlcnNpb24gdG8gYW5vdGhlciBkYXRhIHR5cGUgb3Igd2hlbiBbW2NhY2hlXV0gaXMgY2FsbGVkLCBub3Qgd2hlbiB0aGUgW1tEYXRhU3RyZWFtXV0gd2FzIGNyZWF0ZWQuXHJcbiAqIE11bHRpcGxlIGludm9jYXRpb25zIG9mIGZvciBleGFtcGxlIFtbdG9JdGVtQXJyYXldXSBtYXkgeWllbGQgZGlmZmVyZW50IHJlc3VsdHMgKGlmIHRoZSBkYXRhIHNvdXJjZSBsaWtlIGZvciBleGFtcGxlIFtbRGF0YVNldF1dIGdldHMgbW9kaWZpZWQpLlxyXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBUaGUgaXRlbSB0eXBlIHRoaXMgc3RyZWFtIGlzIGdvaW5nIHRvIHdvcmsgd2l0aC5cclxuICovXG5cblxuX1N5bWJvbCRpdGVyYXRvciA9IGl0ZXJhdG9yO1xuXG52YXIgRGF0YVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhIHN0cmVhbS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYWlycyAtIFRoZSBpZCwgaXRlbSBwYWlycy5cclxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVN0cmVhbShwYWlycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU3RyZWFtKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYWlyc1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fcGFpcnMgPSBwYWlycztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIHN0cmVhbS5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhU3RyZWFtLCBbe1xuICAgIGtleTogX1N5bWJvbCRpdGVyYXRvcixcbiAgICB2YWx1ZTpcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IsIF9zdGVwLCBfc3RlcCR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIHZhbHVlJChfY29udGV4dDEwKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLnMoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSwgaWQgPSBfc3RlcCR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dDEwLnQwID0gX2NvbnRleHQxMFtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvci5lKF9jb250ZXh0MTAudDApO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHZhbHVlLCB0aGlzLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgfSlcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyojX19QVVJFX18qL1xuICAgIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IyLCBfc3RlcDIsIF9zdGVwMiR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIGVudHJpZXMkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5zKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKChfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLCBpZCA9IF9zdGVwMiR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgaXRlbV07XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS50MCA9IF9jb250ZXh0MTFbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IyLmUoX2NvbnRleHQxMS50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGVudHJpZXMsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICB9KVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGtleXMgaW4gdGhlIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOlxuICAgIC8qI19fUFVSRV9fKi9cbiAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMywgX3N0ZXAzLCBfc3RlcDMkdmFsdWUsIGlkO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBrZXlzJChfY29udGV4dDEyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICBfY29udGV4dDEyLnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMucygpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGlmICgoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAxKSwgaWQgPSBfc3RlcDMkdmFsdWVbMF07XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBpZDtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dDEyLnQwID0gX2NvbnRleHQxMltcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMuZShfY29udGV4dDEyLnQwKTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwga2V5cywgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgIH0pXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2YgdmFsdWVzIGluIHRoZSBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qI19fUFVSRV9fKi9cbiAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHZhciBfaXRlcmF0b3I0LCBfc3RlcDQsIF9zdGVwNCR2YWx1ZSwgaXRlbTtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gdmFsdWVzJChfY29udGV4dDEzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICBfY29udGV4dDEzLnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQucygpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGlmICgoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSwgaXRlbSA9IF9zdGVwNCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dDEzLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy50MCA9IF9jb250ZXh0MTNbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3I0LmUoX2NvbnRleHQxMy50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHZhbHVlcywgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgIH0pXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGlkcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2l0aWVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGlkcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0lkQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JZEFycmF5KCkge1xuICAgICAgdmFyIF9jb250ZXh0MTQ7XG5cbiAgICAgIHJldHVybiBtYXAkMyhfY29udGV4dDE0ID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKSkuY2FsbChfY29udGV4dDE0LCBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICByZXR1cm4gcGFpclswXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgaXRlbXMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIGFsbCBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0l0ZW1BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0l0ZW1BcnJheSgpIHtcbiAgICAgIHZhciBfY29udGV4dDE1O1xuXG4gICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQxNSA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycykpLmNhbGwoX2NvbnRleHQxNSwgZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJbMV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGVudHJpZXMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIGFsbCBlbnRyaWVzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvRW50cnlBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0VudHJ5QXJyYXkoKSB7XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IG1hcCBjb250YWluaW5nIGFsbCB0aGUgaXRlbXMgaW4gdGhpcyBzdHJlYW0gYWNjZXNzaWJsZSBieSBpZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIEluIGNhc2Ugb2YgZHVwbGljYXRlIGlkcyAoY29lcmNlZCB0byBzdHJpbmcgc28gYDcgPT0gJzcnYCkgdGhlIGxhc3QgZW5jb3V0ZXJlZCBhcHBlYXJzIGluIHRoZSByZXR1cm5lZCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IG1hcCBvZiBhbGwgaWQg4oaSIGl0ZW0gcGFpcnMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9PYmplY3RNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3RNYXAoKSB7XG4gICAgICB2YXIgbWFwID0gY3JlYXRlJDUobnVsbCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyksXG4gICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpZCA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwNSR2YWx1ZVsxXTtcblxuICAgICAgICAgIG1hcFtpZF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtIGFjY2Vzc2libGUgYnkgaWRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBtYXAgb2YgYWxsIGlkIOKGkiBpdGVtIHBhaXJzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBtYXAodGhpcy5fcGFpcnMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHNldCBjb250YWluaW5nIGFsbCB0aGUgKHVuaXF1ZSkgaWRzIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIGlkcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0lkU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSWRTZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IHNldCh0aGlzLnRvSWRBcnJheSgpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBzZXQgY29udGFpbmluZyBhbGwgdGhlICh1bmlxdWUpIGl0ZW1zIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIGl0ZW1zIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSXRlbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0l0ZW1TZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IHNldCh0aGlzLnRvSXRlbUFycmF5KCkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENhY2hlIHRoZSBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIGl0ZW1zIHRvIGJlIGZldGNoZWQgaW1tZWRpYXRlbGx5IGFuZCB1c2VkIChwb3NzaWJseSBtdWx0aXBsZSB0aW1lcykgbGF0ZXIuXHJcbiAgICAgKiBJdCBjYW4gYWxzbyBiZSB1c2VkIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGFzIFtbRGF0YVN0cmVhbV1dIHdvdWxkIG90aGVyd2lzZSByZWV2YWx1YXRlIGV2ZXJ5dGhpbmcgdXBvbiBlYWNoIGl0ZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiBjb25zdCBkcyA9IG5ldyBEYXRhU2V0KFvigKZdKVxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGNhY2hlZFN0cmVhbSA9IGRzLnN0cmVhbSgpXHJcbiAgICAgKiAgIC5maWx0ZXIo4oCmKVxyXG4gICAgICogICAuc29ydCjigKYpXHJcbiAgICAgKiAgIC5tYXAo4oCmKVxyXG4gICAgICogICAuY2FjaGVkKOKApikgLy8gRGF0YSBhcmUgZmV0Y2hlZCwgcHJvY2Vzc2VkIGFuZCBjYWNoZWQgaGVyZS5cclxuICAgICAqXHJcbiAgICAgKiBkcy5jbGVhcigpXHJcbiAgICAgKiBjaGFjaGVkU3RyZWFtIC8vIFN0aWxsIGhhcyBhbGwgdGhlIGl0ZW1zLlxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBbW0RhdGFTdHJlYW1dXSB3aXRoIGNhY2hlZCBpdGVtcyAoZGV0YWNoZWQgZnJvbSB0aGUgb3JpZ2luYWwgW1tEYXRhU2V0XV0pLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWNoZSgpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGFpcnMpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpc3RpbmN0IHZhbHVlcyBvZiBnaXZlbiBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBwaWNrcyBhbmQgcG9zc2libHkgY29udmVydHMgdGhlIHByb3BlcnR5LlxyXG4gICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGRpc3RpbmN0IHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgQSBzZXQgb2YgYWxsIGRpc3RpbmN0IHByb3BlcnRpZXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RpbmN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RpbmN0KGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2V0JDEgPSBuZXcgc2V0KCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyksXG4gICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpZCA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwNiR2YWx1ZVsxXTtcblxuICAgICAgICAgIHNldCQxLmFkZChjYWxsYmFjayhpdGVtLCBpZCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldCQxO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbHRlciB0aGUgaXRlbXMgb2YgdGhlIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBkZWNpZGVzIHdoZXRoZXIgYW4gaXRlbSB3aWxsIGJlIGluY2x1ZGVkLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgZGF0YSBzdHJlYW0gd2l0aCB0aGUgZmlsdGVyZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgIHZhciBwYWlycyA9IHRoaXMuX3BhaXJzO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3I3LCBfc3RlcDcsIF9zdGVwNyR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQxNikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTYucHJldiA9IF9jb250ZXh0MTYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcocGFpcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc3RlcDckdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDcudmFsdWUsIDIpLCBpZCA9IF9zdGVwNyR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwNyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2soaXRlbSwgaWQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi50MCA9IF9jb250ZXh0MTZbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcuZShfY29udGV4dDE2LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYucHJldiA9IDE1O1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5maW5pc2goMTUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDEyLCAxNSwgMThdXSk7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBpdGVtIG9mIHRoZSBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGZvciBlYWNoIGl0ZW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICBfc3RlcDg7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX3N0ZXA4JHZhbHVlWzBdLFxuICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA4JHZhbHVlWzFdO1xuXG4gICAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBNYXAgdGhlIGl0ZW1zIGludG8gYSBkaWZmZXJlbnQgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSBjb252ZXJzaW9uLlxyXG4gICAgICogQHR5cGVQYXJhbSBNYXBwZWQgLSBUaGUgdHlwZSBvZiB0aGUgaXRlbSBhZnRlciBtYXBwaW5nLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgZGF0YSBzdHJlYW0gd2l0aCB0aGUgbWFwcGVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcGFpcnMgPSB0aGlzLl9wYWlycztcbiAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjksIF9zdGVwOSwgX3N0ZXA5JHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcocGFpcnMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9zdGVwOSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOS52YWx1ZSwgMiksIGlkID0gX3N0ZXA5JHZhbHVlWzBdLCBpdGVtID0gX3N0ZXA5JHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgY2FsbGJhY2soaXRlbSwgaWQpXTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3LnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3LnQwID0gX2NvbnRleHQxN1tcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5lKF9jb250ZXh0MTcudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LmYoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaXRlbSB3aXRoIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRoIHRoZSBtYXhpbXVtIGlmIGZvdW5kIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaXRlciA9IGdldEl0ZXJhdG9yKHRoaXMuX3BhaXJzKTtcblxuICAgICAgdmFyIGN1cnIgPSBpdGVyLm5leHQoKTtcblxuICAgICAgaWYgKGN1cnIuZG9uZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heEl0ZW0gPSBjdXJyLnZhbHVlWzFdO1xuICAgICAgdmFyIG1heFZhbHVlID0gY2FsbGJhY2soY3Vyci52YWx1ZVsxXSwgY3Vyci52YWx1ZVswXSk7XG5cbiAgICAgIHdoaWxlICghKGN1cnIgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIgX2N1cnIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShjdXJyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGlkID0gX2N1cnIkdmFsdWVbMF0sXG4gICAgICAgICAgICBpdGVtID0gX2N1cnIkdmFsdWVbMV07XG5cbiAgICAgICAgdmFyIF92YWx1ZSA9IGNhbGxiYWNrKGl0ZW0sIGlkKTtcblxuICAgICAgICBpZiAoX3ZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICBtYXhWYWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgICBtYXhJdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4SXRlbTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGl0ZW0gd2l0aCB0aGUgbWluaW11bSB2YWx1ZSBvZiBnaXZlbiBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBwaWNrcyBhbmQgcG9zc2libHkgY29udmVydHMgdGhlIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gd2l0aCB0aGUgbWluaW11bSBpZiBmb3VuZCBvdGhlcndpc2UgbnVsbC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihjYWxsYmFjaykge1xuICAgICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcih0aGlzLl9wYWlycyk7XG5cbiAgICAgIHZhciBjdXJyID0gaXRlci5uZXh0KCk7XG5cbiAgICAgIGlmIChjdXJyLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5JdGVtID0gY3Vyci52YWx1ZVsxXTtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGNhbGxiYWNrKGN1cnIudmFsdWVbMV0sIGN1cnIudmFsdWVbMF0pO1xuXG4gICAgICB3aGlsZSAoIShjdXJyID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgdmFyIF9jdXJyJHZhbHVlMiA9IF9zbGljZWRUb0FycmF5KGN1cnIudmFsdWUsIDIpLFxuICAgICAgICAgICAgaWQgPSBfY3VyciR2YWx1ZTJbMF0sXG4gICAgICAgICAgICBpdGVtID0gX2N1cnIkdmFsdWUyWzFdO1xuXG4gICAgICAgIHZhciBfdmFsdWUyID0gY2FsbGJhY2soaXRlbSwgaWQpO1xuXG4gICAgICAgIGlmIChfdmFsdWUyIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICBtaW5WYWx1ZSA9IF92YWx1ZTI7XG4gICAgICAgICAgbWluSXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbkl0ZW07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVkdWNlIHRoZSBpdGVtcyBpbnRvIGEgc2luZ2xlIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIHJlZHVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBhY2N1bXVsYXRvciAtIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cclxuICAgICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSByZWR1Y2VkIHZhbHVlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWR1Y2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyksXG4gICAgICAgICAgX3N0ZXAxMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxMC5zKCk7ICEoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAxMCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMTAudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpZCA9IF9zdGVwMTAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGl0ZW0gPSBfc3RlcDEwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgaXRlbSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTAuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTAuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU29ydCB0aGUgaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gSXRlbSBjb21wYXJhdG9yLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgc3RyZWFtIHdpdGggc29ydGVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQkMShjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfY29udGV4dDE4O1xuXG4gICAgICAgIHJldHVybiBnZXRJdGVyYXRvcihzb3J0KF9jb250ZXh0MTggPSBfdG9Db25zdW1hYmxlQXJyYXkoX3RoaXMyLl9wYWlycykpLmNhbGwoX2NvbnRleHQxOCwgZnVuY3Rpb24gKF9yZWYsIF9yZWYyKSB7XG4gICAgICAgICAgdmFyIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICAgIGlkQSA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgICBpdGVtQSA9IF9yZWYzWzFdO1xuXG4gICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgICAgICAgICBpZEIgPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgaXRlbUIgPSBfcmVmNFsxXTtcblxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhpdGVtQSwgaXRlbUIsIGlkQSwgaWRCKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhU3RyZWFtO1xufSgpO1xuLyoqXHJcbiAqIEFkZCBhbiBpZCB0byBnaXZlbiBpdGVtIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgYWxyZWFkeS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIGl0ZW0gd2lsbCBiZSBtb2RpZmllZC5cclxuICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSB0aGF0IHdpbGwgaGF2ZSBhbiBpZCBhZnRlciBhIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cclxuICogQHBhcmFtIGlkUHJvcCAtIFRoZSBrZXkgb2YgdGhlIGlkIHByb3BlcnR5LlxyXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxyXG4gKiBAcmV0dXJucyB0cnVlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuc3VyZUZ1bGxJdGVtKGl0ZW0sIGlkUHJvcCkge1xuICBpZiAoaXRlbVtpZFByb3BdID09IG51bGwpIHtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgIGl0ZW1baWRQcm9wXSA9IHY0KCk7XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn1cbi8qKlxyXG4gKiAjIERhdGFTZXRcclxuICpcclxuICogVmlzLmpzIGNvbWVzIHdpdGggYSBmbGV4aWJsZSBEYXRhU2V0LCB3aGljaCBjYW4gYmUgdXNlZCB0byBob2xkIGFuZFxyXG4gKiBtYW5pcHVsYXRlIHVuc3RydWN0dXJlZCBkYXRhIGFuZCBsaXN0ZW4gZm9yIGNoYW5nZXMgaW4gdGhlIGRhdGEuIFRoZSBEYXRhU2V0XHJcbiAqIGlzIGtleS92YWx1ZSBiYXNlZC4gRGF0YSBpdGVtcyBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGVcclxuICogRGF0YVNldCwgYW5kIG9uZSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIERhdGFTZXQuIFRoZSBkYXRhIGluIHRoZVxyXG4gKiBEYXRhU2V0IGNhbiBiZSBmaWx0ZXJlZCBhbmQgb3JkZXJlZC4gRGF0YSBjYW4gYmUgbm9ybWFsaXplZCB3aGVuIGFwcGVuZGluZyBpdFxyXG4gKiB0byB0aGUgRGF0YVNldCBhcyB3ZWxsLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gdXNlIGEgRGF0YVNldC5cclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAqIHZhciBvcHRpb25zID0ge307XHJcbiAqIHZhciBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KG9wdGlvbnMpO1xyXG4gKlxyXG4gKiAvLyBhZGQgaXRlbXNcclxuICogLy8gbm90ZSB0aGF0IHRoZSBkYXRhIGl0ZW1zIGNhbiBjb250YWluIGRpZmZlcmVudCBwcm9wZXJ0aWVzIGFuZCBkYXRhIGZvcm1hdHNcclxuICogZGF0YS5hZGQoW1xyXG4gKiAgIHtpZDogMSwgdGV4dDogJ2l0ZW0gMScsIGRhdGU6IG5ldyBEYXRlKDIwMTMsIDYsIDIwKSwgZ3JvdXA6IDEsIGZpcnN0OiB0cnVlfSxcclxuICogICB7aWQ6IDIsIHRleHQ6ICdpdGVtIDInLCBkYXRlOiAnMjAxMy0wNi0yMycsIGdyb3VwOiAyfSxcclxuICogICB7aWQ6IDMsIHRleHQ6ICdpdGVtIDMnLCBkYXRlOiAnMjAxMy0wNi0yNScsIGdyb3VwOiAyfSxcclxuICogICB7aWQ6IDQsIHRleHQ6ICdpdGVtIDQnfVxyXG4gKiBdKTtcclxuICpcclxuICogLy8gc3Vic2NyaWJlIHRvIGFueSBjaGFuZ2UgaW4gdGhlIERhdGFTZXRcclxuICogZGF0YS5vbignKicsIGZ1bmN0aW9uIChldmVudCwgcHJvcGVydGllcywgc2VuZGVySWQpIHtcclxuICogICBjb25zb2xlLmxvZygnZXZlbnQnLCBldmVudCwgcHJvcGVydGllcyk7XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyB1cGRhdGUgYW4gZXhpc3RpbmcgaXRlbVxyXG4gKiBkYXRhLnVwZGF0ZSh7aWQ6IDIsIGdyb3VwOiAxfSk7XHJcbiAqXHJcbiAqIC8vIHJlbW92ZSBhbiBpdGVtXHJcbiAqIGRhdGEucmVtb3ZlKDQpO1xyXG4gKlxyXG4gKiAvLyBnZXQgYWxsIGlkc1xyXG4gKiB2YXIgaWRzID0gZGF0YS5nZXRJZHMoKTtcclxuICogY29uc29sZS5sb2coJ2lkcycsIGlkcyk7XHJcbiAqXHJcbiAqIC8vIGdldCBhIHNwZWNpZmljIGl0ZW1cclxuICogdmFyIGl0ZW0xID0gZGF0YS5nZXQoMSk7XHJcbiAqIGNvbnNvbGUubG9nKCdpdGVtMScsIGl0ZW0xKTtcclxuICpcclxuICogLy8gcmV0cmlldmUgYSBmaWx0ZXJlZCBzdWJzZXQgb2YgdGhlIGRhdGFcclxuICogdmFyIGl0ZW1zID0gZGF0YS5nZXQoe1xyXG4gKiAgIGZpbHRlcjogZnVuY3Rpb24gKGl0ZW0pIHtcclxuICogICAgIHJldHVybiBpdGVtLmdyb3VwID09IDE7XHJcbiAqICAgfVxyXG4gKiB9KTtcclxuICogY29uc29sZS5sb2coJ2ZpbHRlcmVkIGl0ZW1zJywgaXRlbXMpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cclxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICovXG5cblxudmFyIERhdGFTZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EYXRhU2V0UGFydCkge1xuICBfaW5oZXJpdHMoRGF0YVNldCwgX0RhdGFTZXRQYXJ0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHQoRGF0YVNldCk7XG5cbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IERhdGFTZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIEluaXRpYWwgZGF0YSBvciBvcHRpb25zLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyAodHlwZSBlcnJvciBpZiBkYXRhIGlzIGFsc28gb3B0aW9ucykuXHJcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFTZXQoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVNldCk7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIuY2FsbCh0aGlzKTsgLy8gY29ycmVjdGx5IHJlYWQgb3B0aW9uYWwgYXJndW1lbnRzXG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBcImZsdXNoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBcImxlbmd0aFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgXCJfb3B0aW9uc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgXCJfZGF0YVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgXCJfaWRQcm9wXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBcIl9xdWV1ZVwiLCBudWxsKTtcblxuICAgIGlmIChkYXRhICYmICFpc0FycmF5JDIoZGF0YSkpIHtcbiAgICAgIG9wdGlvbnMgPSBkYXRhO1xuICAgICAgZGF0YSA9IFtdO1xuICAgIH1cblxuICAgIF90aGlzMy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgX3RoaXMzLl9kYXRhID0gbmV3IG1hcCgpOyAvLyBtYXAgd2l0aCBkYXRhIGluZGV4ZWQgYnkgaWRcblxuICAgIF90aGlzMy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFTZXRcblxuICAgIF90aGlzMy5faWRQcm9wID0gX3RoaXMzLl9vcHRpb25zLmZpZWxkSWQgfHwgXCJpZFwiOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gICAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgX3RoaXMzLmFkZChkYXRhKTtcbiAgICB9XG5cbiAgICBfdGhpczMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiBfdGhpczM7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbmV3IG9wdGlvbnMuXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0YVNldCwgW3tcbiAgICBrZXk6IFwiaWRQcm9wXCIsXG4gICAgZ2V0OlxuICAgIC8qKiBGbHVzaCBhbGwgcXVldWVkIGNhbGxzLiAqL1xuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWRQcm9wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWV1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIGRlbGV0ZSBxdWV1ZSBpZiBsb2FkZWRcbiAgICAgICAgICBpZiAodGhpcy5fcXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgdGhpcy5fcXVldWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgcXVldWUgYW5kIHVwZGF0ZSBpdHMgb3B0aW9uc1xuICAgICAgICAgIGlmICghdGhpcy5fcXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gUXVldWUuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgICAgcmVwbGFjZTogW1wiYWRkXCIsIFwidXBkYXRlXCIsIFwicmVtb3ZlXCJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5xdWV1ZSAmJiBfdHlwZW9mKG9wdGlvbnMucXVldWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5zZXRPcHRpb25zKG9wdGlvbnMucXVldWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFkZCBhIGRhdGEgaXRlbSBvciBhbiBhcnJheSB3aXRoIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgYWRkZWQgdG8gdGhlIERhdGFTZXQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgYWRkYC4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldCgpXHJcbiAgICAgKlxyXG4gICAgICogLy8gYWRkIGl0ZW1zXHJcbiAgICAgKiBjb25zdCBpZHMgPSBkYXRhLmFkZChbXHJcbiAgICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDInIH0sXHJcbiAgICAgKiAgIHsgdGV4dDogJ2l0ZW0gd2l0aG91dCBhbiBpZCcgfVxyXG4gICAgICogXSlcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsxLCAyLCAnPFVVSUR2ND4nXVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBJdGVtcyB0byBiZSBhZGRlZCAoaWRzIHdpbGwgYmUgZ2VuZXJhdGVkIGlmIG1pc3NpbmcpLlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICogQHJldHVybnMgYWRkZWRJZHMgLSBBcnJheSB3aXRoIHRoZSBpZHMgKGdlbmVyYXRlZCBpZiBub3QgcHJlc2VudCkgb2YgdGhlIGFkZGVkIGl0ZW1zLlxyXG4gICAgICogQHRocm93cyBXaGVuIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZCBhcyBhbnkgb2YgdGhlIGFkZGVkIGl0ZW1zIGFscmVhZHkgZXhpc3RzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGRhdGEsIHNlbmRlcklkKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgICB2YXIgaWQ7XG5cbiAgICAgIGlmIChpc0FycmF5JDIoZGF0YSkpIHtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgdmFyIGlkc1RvQWRkID0gbWFwJDMoZGF0YSkuY2FsbChkYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkW190aGlzNC5faWRQcm9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNvbWUoaWRzVG9BZGQpLmNhbGwoaWRzVG9BZGQsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuX2RhdGEuaGFzKGlkKTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGR1cGxpY2F0ZSBpZCB3YXMgZm91bmQgaW4gdGhlIHBhcmFtZXRlciBhcnJheS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gdGhpcy5fYWRkSXRlbShkYXRhW2ldKTtcbiAgICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhICYmIF90eXBlb2YoZGF0YSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gU2luZ2xlIGl0ZW1cbiAgICAgICAgaWQgPSB0aGlzLl9hZGRJdGVtKGRhdGEpO1xuICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YVR5cGVcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgaXRlbXM6IGFkZGVkSWRzXG4gICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZGVkSWRzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBleGlzdGluZyBpdGVtcy4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIHdpbGwgYmUgbWVyZ2VkIGluIHRoZSBleGlzdGluZyBpdGVtLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHVwZGF0ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgYWRkYCBmb3IgdGhlIGFkZGVkIGl0ZW1zLCBhbmQgYW4gZXZlbnQgYHVwZGF0ZWAuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgRXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xyXG4gICAgICogICB7IGlkOiAxLCB0ZXh0OiAnaXRlbSAxJyB9LFxyXG4gICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9XHJcbiAgICAgKiBdKVxyXG4gICAgICpcclxuICAgICAqIC8vIHVwZGF0ZSBpdGVtc1xyXG4gICAgICogY29uc3QgaWRzID0gZGF0YS51cGRhdGUoW1xyXG4gICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyICh1cGRhdGVkKScgfSxcclxuICAgICAqICAgeyBpZDogNCwgdGV4dDogJ2l0ZW0gNCAobmV3KScgfVxyXG4gICAgICogXSlcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsyLCA0XVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogIyMgV2FybmluZyBmb3IgVHlwZVNjcmlwdCB1c2Vyc1xyXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGludHJvZHVjZSBwYXJ0aWFsIGl0ZW1zIGludG8gdGhlIGRhdGEgc2V0LiBVc2UgYWRkIG9yIHVwZGF0ZU9ubHkgaW5zdGVhZCBmb3IgYmV0dGVyIHR5cGUgc2FmZXR5LlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBJdGVtcyB0byBiZSB1cGRhdGVkIChpZiB0aGUgaWQgaXMgYWxyZWFkeSBwcmVzZW50KSBvciBhZGRlZCAoaWYgdGhlIGlkIGlzIG1pc3NpbmcpLlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICogQHJldHVybnMgdXBkYXRlZElkcyAtIFRoZSBpZHMgb2YgdGhlIGFkZGVkICh0aGVzZSBtYXkgYmUgbmV3bHkgZ2VuZXJhdGVkIGlmIHRoZXJlIHdhcyBubyBpZCBpbiB0aGUgaXRlbSBmcm9tIHRoZSBkYXRhKSBvciB1cGRhdGVkIGl0ZW1zLlxyXG4gICAgICogQHRocm93cyBXaGVuIHRoZSBzdXBwbGllZCBkYXRhIGlzIG5laXRoZXIgYW4gaXRlbSBub3IgYW4gYXJyYXkgb2YgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoZGF0YSwgc2VuZGVySWQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgIHZhciB1cGRhdGVkSWRzID0gW107XG4gICAgICB2YXIgb2xkRGF0YSA9IFtdO1xuICAgICAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gICAgICB2YXIgaWRQcm9wID0gdGhpcy5faWRQcm9wO1xuXG4gICAgICB2YXIgYWRkT3JVcGRhdGUgPSBmdW5jdGlvbiBhZGRPclVwZGF0ZShpdGVtKSB7XG4gICAgICAgIHZhciBvcmlnSWQgPSBpdGVtW2lkUHJvcF07XG5cbiAgICAgICAgaWYgKG9yaWdJZCAhPSBudWxsICYmIF90aGlzNS5fZGF0YS5oYXMob3JpZ0lkKSkge1xuICAgICAgICAgIHZhciBmdWxsSXRlbSA9IGl0ZW07IC8vIGl0IGhhcyBhbiBpZCwgdGhlcmVmb3JlIGl0IGlzIGEgZnVsbGl0ZW1cblxuICAgICAgICAgIHZhciBvbGRJdGVtID0gYXNzaWduJDIoe30sIF90aGlzNS5fZGF0YS5nZXQob3JpZ0lkKSk7IC8vIHVwZGF0ZSBpdGVtXG5cblxuICAgICAgICAgIHZhciBpZCA9IF90aGlzNS5fdXBkYXRlSXRlbShmdWxsSXRlbSk7XG5cbiAgICAgICAgICB1cGRhdGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgIHVwZGF0ZWREYXRhLnB1c2goZnVsbEl0ZW0pO1xuICAgICAgICAgIG9sZERhdGEucHVzaChvbGRJdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgbmV3IGl0ZW1cbiAgICAgICAgICB2YXIgX2lkID0gX3RoaXM1Ll9hZGRJdGVtKGl0ZW0pO1xuXG4gICAgICAgICAgYWRkZWRJZHMucHVzaChfaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNBcnJheSQyKGRhdGEpKSB7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRhdGFbaV0gJiYgX3R5cGVvZihkYXRhW2ldKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIklnbm9yaW5nIGlucHV0IGl0ZW0sIHdoaWNoIGlzIG5vdCBhbiBvYmplY3QgYXQgaW5kZXggXCIgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBfdHlwZW9mKGRhdGEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICAgIGFkZE9yVXBkYXRlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGl0ZW1zOiB1cGRhdGVkSWRzLFxuICAgICAgICAgIG9sZERhdGE6IG9sZERhdGEsXG4gICAgICAgICAgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgICAgfTsgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydHkgJ2RhdGEnIHNvbWUgZGF5XG4gICAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnZGF0YScsIHtcbiAgICAgICAgLy8gICdnZXQnOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgZGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5nZXQoaWRzKSB0byByZXRyaWV2ZSB0aGUgbmV3IGRhdGEsIHVzZSB0aGUgb2xkRGF0YSBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdCB0byBnZXQgdGhlIG9sZCBkYXRhJyk7XG4gICAgICAgIC8vICAgIHJldHVybiB1cGRhdGVkRGF0YTtcbiAgICAgICAgLy8gIH0pLmJpbmQodGhpcylcbiAgICAgICAgLy99KTtcblxuICAgICAgICB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIHByb3BzLCBzZW5kZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25jYXQoYWRkZWRJZHMpLmNhbGwoYWRkZWRJZHMsIHVwZGF0ZWRJZHMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBleGlzdGluZyBpdGVtcy4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgd2lsbCBiZSBkZWVwbHkgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGl0ZW0uXHJcbiAgICAgKiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QgKGlkIG5vdCBwcmVzZW50IGluIHRoZSBkYXRhIHNldCBvciBhYnNlbnQpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBhbmQgbm90aGluZyB3aWxsIGJlIGNoYW5nZWQuXHJcbiAgICAgKlxyXG4gICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSB1cGRhdGVkLCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYHVwZGF0ZWAuXHJcbiAgICAgKiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICAgKiBjb25zdCBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KFtcclxuICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcclxuICAgICAqICAgeyBpZDogMywgdGV4dDogJ2l0ZW0gMycgfSxcclxuICAgICAqIF0pXHJcbiAgICAgKlxyXG4gICAgICogLy8gdXBkYXRlIGl0ZW1zXHJcbiAgICAgKiBjb25zdCBpZHMgPSBkYXRhLnVwZGF0ZShbXHJcbiAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDIgKHVwZGF0ZWQpJyB9LCAvLyB3b3Jrc1xyXG4gICAgICogICAvLyB7IGlkOiA0LCB0ZXh0OiAnaXRlbSA0IChuZXcpJyB9LCAvLyB3b3VsZCB0aHJvd1xyXG4gICAgICogICAvLyB7IHRleHQ6ICdpdGVtIDQgKG5ldyknIH0sIC8vIHdvdWxkIGFsc28gdGhyb3dcclxuICAgICAqIF0pXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMl1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBVcGRhdGVzICh0aGUgaWQgYW5kIG9wdGlvbmFsbHkgb3RoZXIgcHJvcHMpIHRvIHRoZSBpdGVtcyBpbiB0aGlzIGRhdGEgc2V0LlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICogQHJldHVybnMgdXBkYXRlZElkcyAtIFRoZSBpZHMgb2YgdGhlIHVwZGF0ZWQgaXRlbXMuXHJcbiAgICAgKiBAdGhyb3dzIFdoZW4gdGhlIHN1cHBsaWVkIGRhdGEgaXMgbmVpdGhlciBhbiBpdGVtIG5vciBhbiBhcnJheSBvZiBpdGVtcywgd2hlbiB0aGUgaWRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPbmx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9ubHkoZGF0YSwgc2VuZGVySWQpIHtcbiAgICAgIHZhciBfY29udGV4dDE5LFxuICAgICAgICAgIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICghaXNBcnJheSQyKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVFdmVudERhdGEgPSBtYXAkMyhfY29udGV4dDE5ID0gbWFwJDMoZGF0YSkuY2FsbChkYXRhLCBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIHZhciBvbGREYXRhID0gX3RoaXM2Ll9kYXRhLmdldCh1cGRhdGVbX3RoaXM2Ll9pZFByb3BdKTtcblxuICAgICAgICBpZiAob2xkRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgbm9uLWV4aXN0ZW50IGl0ZW1zIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgICB9O1xuICAgICAgfSkpLmNhbGwoX2NvbnRleHQxOSwgZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBvbGREYXRhID0gX3JlZjUub2xkRGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IF9yZWY1LnVwZGF0ZTtcbiAgICAgICAgdmFyIGlkID0gb2xkRGF0YVtfdGhpczYuX2lkUHJvcF07XG4gICAgICAgIHZhciB1cGRhdGVkRGF0YSA9IHB1cmVEZWVwT2JqZWN0QXNzaWduKG9sZERhdGEsIHVwZGF0ZSk7XG5cbiAgICAgICAgX3RoaXM2Ll9kYXRhLnNldChpZCwgdXBkYXRlZERhdGEpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG9sZERhdGE6IG9sZERhdGEsXG4gICAgICAgICAgdXBkYXRlZERhdGE6IHVwZGF0ZWREYXRhXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgaWYgKHVwZGF0ZUV2ZW50RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGl0ZW1zOiBtYXAkMyh1cGRhdGVFdmVudERhdGEpLmNhbGwodXBkYXRlRXZlbnREYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pZDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBvbGREYXRhOiBtYXAkMyh1cGRhdGVFdmVudERhdGEpLmNhbGwodXBkYXRlRXZlbnREYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vbGREYXRhO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRhdGE6IG1hcCQzKHVwZGF0ZUV2ZW50RGF0YSkuY2FsbCh1cGRhdGVFdmVudERhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZWREYXRhO1xuICAgICAgICAgIH0pXG4gICAgICAgIH07IC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHByb3BlcnR5ICdkYXRhJyBzb21lIGRheVxuICAgICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2RhdGEnLCB7XG4gICAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5IGRhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQuZ2V0KGlkcykgdG8gcmV0cmlldmUgdGhlIG5ldyBkYXRhLCB1c2UgdGhlIG9sZERhdGEgcHJvcGVydHkgb24gdGhpcyBvYmplY3QgdG8gZ2V0IHRoZSBvbGQgZGF0YScpO1xuICAgICAgICAvLyAgICByZXR1cm4gdXBkYXRlZERhdGE7XG4gICAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAgIC8vfSk7XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLCBwcm9wcywgc2VuZGVySWQpO1xuXG4gICAgICAgIHJldHVybiBwcm9wcy5pdGVtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIC8vIEBUT0RPOiBXb3Vkbid0IGl0IGJlIGJldHRlciB0byBzcGxpdCB0aGlzIGludG8gbXVsdGlwbGUgbWV0aG9kcz9cbiAgICAgIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgICAgIHZhciBpZCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpZHMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzSWQoZmlyc3QpKSB7XG4gICAgICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICAgICAgaWQgPSBmaXJzdDtcbiAgICAgICAgb3B0aW9ucyA9IHNlY29uZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKGZpcnN0KSkge1xuICAgICAgICAvLyBnZXQoaWRzIFssIG9wdGlvbnNdKVxuICAgICAgICBpZHMgPSBmaXJzdDtcbiAgICAgICAgb3B0aW9ucyA9IHNlY29uZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldChbLCBvcHRpb25zXSlcbiAgICAgICAgb3B0aW9ucyA9IGZpcnN0O1xuICAgICAgfSAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG5cblxuICAgICAgdmFyIHJldHVyblR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSA9PT0gXCJPYmplY3RcIiA/IFwiT2JqZWN0XCIgOiBcIkFycmF5XCI7IC8vIEBUT0RPOiBXVEYgaXMgdGhpcz8gT3IgYW0gSSBtaXNzaW5nIHNvbWV0aGluZz9cbiAgICAgIC8vIHZhciByZXR1cm5UeXBlXG4gICAgICAvLyBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblR5cGUpIHtcbiAgICAgIC8vICAgdmFyIGFsbG93ZWRWYWx1ZXMgPSBbJ0FycmF5JywgJ09iamVjdCddXG4gICAgICAvLyAgIHJldHVyblR5cGUgPVxuICAgICAgLy8gICAgIGFsbG93ZWRWYWx1ZXMuaW5kZXhPZihvcHRpb25zLnJldHVyblR5cGUpID09IC0xXG4gICAgICAvLyAgICAgICA/ICdBcnJheSdcbiAgICAgIC8vICAgICAgIDogb3B0aW9ucy5yZXR1cm5UeXBlXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICByZXR1cm5UeXBlID0gJ0FycmF5J1xuICAgICAgLy8gfVxuICAgICAgLy8gYnVpbGQgb3B0aW9uc1xuXG4gICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICB2YXIgaXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpdGVtSWRzID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGl0ZW1JZCA9IHVuZGVmaW5lZDsgLy8gY29udmVydCBpdGVtc1xuXG4gICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgaXRlbVxuICAgICAgICBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgIGlmIChpdGVtICYmIGZpbHRlciQxICYmICFmaWx0ZXIkMShpdGVtKSkge1xuICAgICAgICAgIGl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWRzICE9IG51bGwpIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgc3Vic2V0IG9mIGl0ZW1zXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWRzW2ldKTtcblxuICAgICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShpdGVtKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQyMDtcblxuICAgICAgICAvLyByZXR1cm4gYWxsIGl0ZW1zXG4gICAgICAgIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhfY29udGV4dDIwID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDIwKSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbGVuMiA9IGl0ZW1JZHMubGVuZ3RoOyBfaSA8IF9sZW4yOyBfaSsrKSB7XG4gICAgICAgICAgaXRlbUlkID0gaXRlbUlkc1tfaV07XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGl0ZW1JZCk7XG5cbiAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoaXRlbSkpKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBvcmRlciB0aGUgcmVzdWx0c1xuXG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIgJiYgaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICAgICAgfSAvLyBmaWx0ZXIgZmllbGRzIG9mIHRoZSBpdGVtc1xuXG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcblxuICAgICAgICBpZiAoaWQgIT0gdW5kZWZpbmVkICYmIGl0ZW0gIT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfbGVuMyA9IGl0ZW1zLmxlbmd0aDsgX2kyIDwgX2xlbjM7IF9pMisrKSB7XG4gICAgICAgICAgICBpdGVtc1tfaTJdID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW1zW19pMl0sIGZpZWxkcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHJldHVybiB0aGUgcmVzdWx0c1xuXG5cbiAgICAgIGlmIChyZXR1cm5UeXBlID09IFwiT2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9sZW40ID0gaXRlbXMubGVuZ3RoOyBfaTMgPCBfbGVuNDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWx0YW50ID0gaXRlbXNbX2kzXTsgLy8gQFRPRE86IFNob3Vkbid0IHRoaXMgYmUgdGhpcy5fZmllbGRJZD9cbiAgICAgICAgICAvLyByZXN1bHRbcmVzdWx0YW50LmlkXSA9IHJlc3VsdGFudFxuXG4gICAgICAgICAgdmFyIF9pZDIgPSByZXN1bHRhbnRbdGhpcy5faWRQcm9wXTtcbiAgICAgICAgICByZXN1bHRbX2lkMl0gPSByZXN1bHRhbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2l0ZW07XG5cbiAgICAgICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICAgICAgcmV0dXJuIChfaXRlbSA9IGl0ZW0pICE9PSBudWxsICYmIF9pdGVtICE9PSB2b2lkIDAgPyBfaXRlbSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkcyhvcHRpb25zKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgIHZhciBmaWx0ZXIkMSA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICB2YXIgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXI7XG5cbiAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7XG5cbiAgICAgIHZhciBpZHMgPSBbXTtcblxuICAgICAgaWYgKGZpbHRlciQxKSB7XG4gICAgICAgIC8vIGdldCBmaWx0ZXJlZCBpdGVtc1xuICAgICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcblxuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgZmlsdGVyJDEoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfbGVuNSA9IGl0ZW1zLmxlbmd0aDsgX2k0IDwgX2xlbjU7IF9pNCsrKSB7XG4gICAgICAgICAgICBpZHMucHVzaChpdGVtc1tfaTRdW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwLCBfbGVuNiA9IGl0ZW1JZHMubGVuZ3RoOyBfaTUgPCBfbGVuNjsgX2k1KyspIHtcbiAgICAgICAgICAgIHZhciBfaWQzID0gaXRlbUlkc1tfaTVdO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZW0yID0gdGhpcy5fZGF0YS5nZXQoX2lkMyk7XG5cbiAgICAgICAgICAgIGlmIChfaXRlbTIgIT0gbnVsbCAmJiBmaWx0ZXIkMShfaXRlbTIpKSB7XG4gICAgICAgICAgICAgIGlkcy5wdXNoKF9pdGVtMlt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldCBhbGwgaXRlbXNcbiAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICAgIHZhciBfaXRlbXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9sZW43ID0gaXRlbUlkcy5sZW5ndGg7IF9pNiA8IF9sZW43OyBfaTYrKykge1xuICAgICAgICAgICAgdmFyIF9pZDQgPSBpdGVtSWRzW19pNl07XG5cbiAgICAgICAgICAgIF9pdGVtcy5wdXNoKGRhdGEuZ2V0KF9pZDQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zb3J0KF9pdGVtcywgb3JkZXIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k3ID0gMCwgX2xlbjggPSBfaXRlbXMubGVuZ3RoOyBfaTcgPCBfbGVuODsgX2k3KyspIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKF9pdGVtc1tfaTddW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfbGVuOSA9IGl0ZW1JZHMubGVuZ3RoOyBfaTggPCBfbGVuOTsgX2k4KyspIHtcbiAgICAgICAgICAgIHZhciBfaWQ1ID0gaXRlbUlkc1tfaThdO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZW0zID0gZGF0YS5nZXQoX2lkNSk7XG5cbiAgICAgICAgICAgIGlmIChfaXRlbTMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZHMucHVzaChfaXRlbTNbdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICB2YXIgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKGRhdGEpLmNhbGwoZGF0YSkpO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQob3B0aW9ucyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICB2YXIgaWQgPSBpdGVtW3RoaXMuX2lkUHJvcF07XG4gICAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bm9yZGVyZWRcbiAgICAgICAgZm9yICh2YXIgX2k5ID0gMCwgX2xlbjEwID0gaXRlbUlkcy5sZW5ndGg7IF9pOSA8IF9sZW4xMDsgX2k5KyspIHtcbiAgICAgICAgICB2YXIgX2lkNiA9IGl0ZW1JZHNbX2k5XTtcblxuICAgICAgICAgIHZhciBfaXRlbTQgPSB0aGlzLl9kYXRhLmdldChfaWQ2KTtcblxuICAgICAgICAgIGlmIChfaXRlbTQgIT0gbnVsbCAmJiAoIWZpbHRlciQxIHx8IGZpbHRlciQxKF9pdGVtNCkpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfaXRlbTQsIF9pZDYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICB2YXIgbWFwcGVkSXRlbXMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTsgLy8gY29udmVydCBhbmQgZmlsdGVyIGl0ZW1zXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcblxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoaXRlbSkpKSB7XG4gICAgICAgICAgbWFwcGVkSXRlbXMucHVzaChjYWxsYmFjayhpdGVtLCBpZCkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIG9yZGVyIGl0ZW1zXG5cblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgICAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcHBlZEl0ZW1zO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbHRlciB0aGUgZmllbGRzIG9mIGFuIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSB3aG9zZSBmaWVsZHMgc2hvdWxkIGJlIGZpbHRlcmVkLlxyXG4gICAgICogQHBhcmFtIGZpZWxkcyAtIFRoZSBuYW1lcyBvZiB0aGUgZmllbGRzIHRoYXQgd2lsbCBiZSBrZXB0LlxyXG4gICAgICogQHR5cGVQYXJhbSBLIC0gRmllbGQgbmFtZSB0eXBlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gd2l0aG91dCBhbnkgYWRkaXRpb25hbCBmaWVsZHMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maWx0ZXJGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpIHtcbiAgICAgIHZhciBfY29udGV4dDIxO1xuXG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgLy8gaXRlbSBpcyBudWxsXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVkdWNlKF9jb250ZXh0MjEgPSBpc0FycmF5JDIoZmllbGRzKSA/IC8vIFVzZSB0aGUgc3VwcGxpZWQgYXJyYXlcbiAgICAgIGZpZWxkcyA6IC8vIFVzZSB0aGUga2V5cyBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gICAgICBrZXlzJDQoZmllbGRzKSkuY2FsbChfY29udGV4dDIxLCBmdW5jdGlvbiAoZmlsdGVyZWRJdGVtLCBmaWVsZCkge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1bZmllbGRdID0gaXRlbVtmaWVsZF07XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEl0ZW07XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU29ydCB0aGUgcHJvdmlkZWQgYXJyYXkgd2l0aCBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgLSBJdGVtcyB0byBiZSBzb3J0ZWQgaW4gcGxhY2UuXHJcbiAgICAgKiBAcGFyYW0gb3JkZXIgLSBBIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXHJcbiAgICAgKiBAdHlwZVBhcmFtIFQgLSBUaGUgdHlwZSBvZiB0aGUgaXRlbXMgaW4gdGhlIGl0ZW1zIGFycmF5LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc29ydChpdGVtcywgb3JkZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gb3JkZXIgYnkgcHJvdmlkZWQgZmllbGQgbmFtZVxuICAgICAgICB2YXIgbmFtZSA9IG9yZGVyOyAvLyBmaWVsZCBuYW1lXG5cbiAgICAgICAgc29ydChpdGVtcykuY2FsbChpdGVtcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAvLyBAVE9ETzogSG93IHRvIHRyZWF0IG1pc3NpbmcgcHJvcGVydGllcz9cbiAgICAgICAgICB2YXIgYXYgPSBhW25hbWVdO1xuICAgICAgICAgIHZhciBidiA9IGJbbmFtZV07XG4gICAgICAgICAgcmV0dXJuIGF2ID4gYnYgPyAxIDogYXYgPCBidiA/IC0xIDogMDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIG9yZGVyIGJ5IHNvcnQgZnVuY3Rpb25cbiAgICAgICAgc29ydChpdGVtcykuY2FsbChpdGVtcywgb3JkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6c3RyaW5nLCBkaXJlY3Rpb246c3RyaW5nfVxuICAgICAgICAvLyAgICAgICB3aGVyZSBkaXJlY3Rpb24gY2FuIGJlICdhc2MnIG9yICdkZXNjJ1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT3JkZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBpdGVtIG9yIG11bHRpcGxlIGl0ZW1zIGJ5IOKAnHJlZmVyZW5jZeKAnSAob25seSB0aGUgaWQgaXMgdXNlZCkgb3IgYnkgaWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1ldGhvZCBpZ25vcmVzIHJlbW92YWwgb2Ygbm9uLWV4aXN0aW5nIGl0ZW1zLCBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBpZHMgb2YgdGhlIGl0ZW1zIHdoaWNoIGFyZSBhY3R1YWxseSByZW1vdmVkIGZyb20gdGhlIERhdGFTZXQuXHJcbiAgICAgKlxyXG4gICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYHJlbW92ZWAgZm9yIHRoZSByZW1vdmVkIGl0ZW1zLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xyXG4gICAgICogICB7IGlkOiAxLCB0ZXh0OiAnaXRlbSAxJyB9LFxyXG4gICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9XHJcbiAgICAgKiBdKVxyXG4gICAgICpcclxuICAgICAqIC8vIHJlbW92ZSBpdGVtc1xyXG4gICAgICogY29uc3QgaWRzID0gZGF0YS5yZW1vdmUoWzIsIHsgaWQ6IDMgfSwgNF0pXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMiwgM11cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCAtIE9uZSBvciBtb3JlIGl0ZW1zIG9yIGlkcyBvZiBpdGVtcyB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGlkcyBvZiB0aGUgcmVtb3ZlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZCwgc2VuZGVySWQpIHtcbiAgICAgIHZhciByZW1vdmVkSWRzID0gW107XG4gICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107IC8vIGZvcmNlIGV2ZXJ5dGhpbmcgdG8gYmUgYW4gYXJyYXkgZm9yIHNpbXBsaWNpdHlcblxuICAgICAgdmFyIGlkcyA9IGlzQXJyYXkkMihpZCkgPyBpZCA6IFtpZF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9yZW1vdmUoaWRzW2ldKTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtW3RoaXMuX2lkUHJvcF07XG5cbiAgICAgICAgICBpZiAoaXRlbUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChpdGVtSWQpO1xuICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICBpdGVtczogcmVtb3ZlZElkcyxcbiAgICAgICAgICBvbGREYXRhOiByZW1vdmVkSXRlbXNcbiAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlZElkcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWQgb3IgcmVmZXJlbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCAtIElkIG9mIGFuIGl0ZW0gb3IgdGhlIGl0ZW0gaXRzZWxmLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlbW92ZWQgaXRlbSBpZiByZW1vdmVkLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlKGlkKSB7XG4gICAgICAvLyBAVE9ETzogSXQgb3JpZ2lhbmxseSByZXR1cm5lZCB0aGUgaXRlbSBhbHRob3VnaCB0aGUgZG9jcyBzYXkgaWQuXG4gICAgICAvLyBUaGUgY29kZSBleHBlY3RzIHRoZSBpdGVtLCBzbyBwcm9iYWJseSBhbiBlcnJvciBpbiB0aGUgZG9jcy5cbiAgICAgIHZhciBpZGVudDsgLy8gY29uZmlybSB0aGUgaWQgdG8gdXNlIGJhc2VkIG9uIHRoZSBhcmdzIHR5cGVcblxuICAgICAgaWYgKGlzSWQoaWQpKSB7XG4gICAgICAgIGlkZW50ID0gaWQ7XG4gICAgICB9IGVsc2UgaWYgKGlkICYmIF90eXBlb2YoaWQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlkZW50ID0gaWRbdGhpcy5faWRQcm9wXTsgLy8gbG9vayBmb3IgdGhlIGlkZW50aWZpZXIgZmllbGQgdXNpbmcgLl9pZFByb3BcbiAgICAgIH0gLy8gZG8gdGhlIHJlbW92aW5nIGlmIHRoZSBpdGVtIGlzIGZvdW5kXG5cblxuICAgICAgaWYgKGlkZW50ICE9IG51bGwgJiYgdGhpcy5fZGF0YS5oYXMoaWRlbnQpKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWRlbnQpIHx8IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZGF0YS5kZWxldGUoaWRlbnQpO1xuXG4gICAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgZW50aXJlIGRhdGEgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgcmVtb3ZlZCwgdGhlIFtbRGF0YVNldF1dIHdpbGwgdHJpZ2dlciBhbiBldmVudCBgcmVtb3ZlYCBmb3IgYWxsIHJlbW92ZWQgaXRlbXMuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxyXG4gICAgICogQHJldHVybnMgcmVtb3ZlZElkcyAtIFRoZSBpZHMgb2YgYWxsIHJlbW92ZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKHNlbmRlcklkKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMjtcblxuICAgICAgdmFyIGlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKF9jb250ZXh0MjIgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MjIpKTtcblxuICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLl9kYXRhLmdldChpZHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGF0YS5jbGVhcigpO1xuXG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICBpdGVtczogaWRzLFxuICAgICAgICBvbGREYXRhOiBpdGVtc1xuICAgICAgfSwgc2VuZGVySWQpO1xuXG4gICAgICByZXR1cm4gaWRzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWVsZCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBtYXggdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KGZpZWxkKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMztcblxuICAgICAgdmFyIG1heCA9IG51bGw7XG4gICAgICB2YXIgbWF4RmllbGQgPSBudWxsO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHZhbHVlcyhfY29udGV4dDIzID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDIzKSksXG4gICAgICAgICAgX3N0ZXAxMTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxMS5zKCk7ICEoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMTEudmFsdWU7XG4gICAgICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtRmllbGQgPT09IFwibnVtYmVyXCIgJiYgKG1heEZpZWxkID09IG51bGwgfHwgaXRlbUZpZWxkID4gbWF4RmllbGQpKSB7XG4gICAgICAgICAgICBtYXggPSBpdGVtO1xuICAgICAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTEuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTEuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4IHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgZm9yIG1pbiB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEl0ZW0gY29udGFpbmluZyBtaW4gdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4oZmllbGQpIHtcbiAgICAgIHZhciBfY29udGV4dDI0O1xuXG4gICAgICB2YXIgbWluID0gbnVsbDtcbiAgICAgIHZhciBtaW5GaWVsZCA9IG51bGw7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IxMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodmFsdWVzKF9jb250ZXh0MjQgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MjQpKSxcbiAgICAgICAgICBfc3RlcDEyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAxMi52YWx1ZTtcbiAgICAgICAgICB2YXIgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1GaWVsZCA9PT0gXCJudW1iZXJcIiAmJiAobWluRmllbGQgPT0gbnVsbCB8fCBpdGVtRmllbGQgPCBtaW5GaWVsZCkpIHtcbiAgICAgICAgICAgIG1pbiA9IGl0ZW07XG4gICAgICAgICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW4gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcCAtIFRoZSBwcm9wZXJ0eSBuYW1lIHdob3NlIGRpc3RpbmN0IHZhbHVlcyBzaG91bGQgYmUgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyBVbm9yZGVyZWQgYXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJdGVtcyB3aXRob3V0IHNwZWNpZmllZCBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGluY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGluY3QocHJvcCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICB2YXIgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKGRhdGEpLmNhbGwoZGF0YSkpO1xuXG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICB2YXIgaXRlbSA9IGRhdGEuZ2V0KGlkKTtcbiAgICAgICAgdmFyIF92YWx1ZTMgPSBpdGVtW3Byb3BdO1xuICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgaWYgKHZhbHVlc1tqXSA9PSBfdmFsdWUzKSB7XG4gICAgICAgICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGlzdHMgJiYgX3ZhbHVlMyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWVzW2NvdW50XSA9IF92YWx1ZTM7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNpbmdsZSBpdGVtLiBXaWxsIGZhaWwgd2hlbiBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW0gLSBBIG5ldyBpdGVtIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMgQWRkZWQgaXRlbSdzIGlkLiBBbiBpZCBpcyBnZW5lcmF0ZWQgd2hlbiBpdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgaXRlbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEl0ZW0oaXRlbSkge1xuICAgICAgdmFyIGZ1bGxJdGVtID0gZW5zdXJlRnVsbEl0ZW0oaXRlbSwgdGhpcy5faWRQcm9wKTtcbiAgICAgIHZhciBpZCA9IGZ1bGxJdGVtW3RoaXMuX2lkUHJvcF07IC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpZCBpcyBhbHJlYWR5IHRha2VuXG5cbiAgICAgIGlmICh0aGlzLl9kYXRhLmhhcyhpZCkpIHtcbiAgICAgICAgLy8gaXRlbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGl0ZW06IGl0ZW0gd2l0aCBpZCBcIiArIGlkICsgXCIgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RhdGEuc2V0KGlkLCBmdWxsSXRlbSk7XG5cbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGEgc2luZ2xlIGl0ZW06IG1lcmdlIHdpdGggZXhpc3RpbmcgaXRlbS5cclxuICAgICAqIFdpbGwgZmFpbCB3aGVuIHRoZSBpdGVtIGhhcyBubyBpZCwgb3Igd2hlbiB0aGVyZSBkb2VzIG5vdCBleGlzdCBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVwZGF0ZSAtIFRoZSBuZXcgaXRlbVxyXG4gICAgICogQHJldHVybnMgVGhlIGlkIG9mIHRoZSB1cGRhdGVkIGl0ZW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVJdGVtKHVwZGF0ZSkge1xuICAgICAgdmFyIGlkID0gdXBkYXRlW3RoaXMuX2lkUHJvcF07XG5cbiAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06IFwiICsgc3RyaW5naWZ5JDEodXBkYXRlKSArIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAvLyBpdGVtIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBpdGVtOiBubyBpdGVtIHdpdGggaWQgXCIgKyBpZCArIFwiIGZvdW5kXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXRhLnNldChpZCwgX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgaXRlbSksIHVwZGF0ZSkpO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbShpZHMpIHtcbiAgICAgIGlmIChpZHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjEzLCBfc3RlcDEzLCBpZCwgaXRlbTtcblxuICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDI1KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjUucHJldiA9IF9jb250ZXh0MjUubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhpZHMpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMTMucygpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgaWYgKChfc3RlcDEzID0gX2l0ZXJhdG9yMTMubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWQgPSBfc3RlcDEzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgaXRlbSA9IGRhdGEuZ2V0KGlkKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoaXRlbSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbaWQsIGl0ZW1dO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5wcmV2ID0gMTM7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1LnQwID0gX2NvbnRleHQyNVtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxMy5lKF9jb250ZXh0MjUudDApO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUucHJldiA9IDE2O1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxMy5mKCk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI1LmZpbmlzaCgxNik7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI1LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzEsIDEzLCAxNiwgMTldXSk7XG4gICAgICAgIH0pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQyNjtcblxuICAgICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgYmluZCQ2KF9jb250ZXh0MjYgPSBlbnRyaWVzKHRoaXMuX2RhdGEpKS5jYWxsKF9jb250ZXh0MjYsIHRoaXMuX2RhdGEpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFTZXQ7XG59KERhdGFTZXRQYXJ0KTtcbi8qKlxyXG4gKiBEYXRhVmlld1xyXG4gKlxyXG4gKiBBIERhdGFWaWV3IG9mZmVycyBhIGZpbHRlcmVkIGFuZC9vciBmb3JtYXR0ZWQgdmlldyBvbiBhIERhdGFTZXQuIE9uZSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gYSBEYXRhVmlldywgYW5kIGVhc2lseSBnZXQgZmlsdGVyZWQgb3IgZm9ybWF0dGVkIGRhdGEgd2l0aG91dCBoYXZpbmcgdG8gc3BlY2lmeSBmaWx0ZXJzIGFuZCBmaWVsZCB0eXBlcyBhbGwgdGhlIHRpbWUuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAqIHZhciBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KCk7XHJcbiAqIGRhdGEuYWRkKFtcclxuICogICB7aWQ6IDEsIHRleHQ6ICdpdGVtIDEnLCBkYXRlOiBuZXcgRGF0ZSgyMDEzLCA2LCAyMCksIGdyb3VwOiAxLCBmaXJzdDogdHJ1ZX0sXHJcbiAqICAge2lkOiAyLCB0ZXh0OiAnaXRlbSAyJywgZGF0ZTogJzIwMTMtMDYtMjMnLCBncm91cDogMn0sXHJcbiAqICAge2lkOiAzLCB0ZXh0OiAnaXRlbSAzJywgZGF0ZTogJzIwMTMtMDYtMjUnLCBncm91cDogMn0sXHJcbiAqICAge2lkOiA0LCB0ZXh0OiAnaXRlbSA0J31cclxuICogXSk7XHJcbiAqXHJcbiAqIC8vIGNyZWF0ZSBhIERhdGFWaWV3XHJcbiAqIC8vIHRoZSB2aWV3IHdpbGwgb25seSBjb250YWluIGl0ZW1zIGhhdmluZyBhIHByb3BlcnR5IGdyb3VwIHdpdGggdmFsdWUgMSxcclxuICogLy8gYW5kIHdpbGwgb25seSBvdXRwdXQgZmllbGRzIGlkLCB0ZXh0LCBhbmQgZGF0ZS5cclxuICogdmFyIHZpZXcgPSBuZXcgdmlzLkRhdGFWaWV3KGRhdGEsIHtcclxuICogICBmaWx0ZXI6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAqICAgICByZXR1cm4gKGl0ZW0uZ3JvdXAgPT0gMSk7XHJcbiAqICAgfSxcclxuICogICBmaWVsZHM6IFsnaWQnLCAndGV4dCcsICdkYXRlJ11cclxuICogfSk7XHJcbiAqXHJcbiAqIC8vIHN1YnNjcmliZSB0byBhbnkgY2hhbmdlIGluIHRoZSBEYXRhVmlld1xyXG4gKiB2aWV3Lm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50LCBwcm9wZXJ0aWVzLCBzZW5kZXJJZCkge1xyXG4gKiAgIGNvbnNvbGUubG9nKCdldmVudCcsIGV2ZW50LCBwcm9wZXJ0aWVzKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIC8vIHVwZGF0ZSBhbiBpdGVtIGluIHRoZSBkYXRhIHNldFxyXG4gKiBkYXRhLnVwZGF0ZSh7aWQ6IDIsIGdyb3VwOiAxfSk7XHJcbiAqXHJcbiAqIC8vIGdldCBhbGwgaWRzIGluIHRoZSB2aWV3XHJcbiAqIHZhciBpZHMgPSB2aWV3LmdldElkcygpO1xyXG4gKiBjb25zb2xlLmxvZygnaWRzJywgaWRzKTsgLy8gd2lsbCBvdXRwdXQgWzEsIDJdXHJcbiAqXHJcbiAqIC8vIGdldCBhbGwgaXRlbXMgaW4gdGhlIHZpZXdcclxuICogdmFyIGl0ZW1zID0gdmlldy5nZXQoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAqL1xuXG5cbnZhciBEYXRhVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RhdGFTZXRQYXJ0Mikge1xuICBfaW5oZXJpdHMoRGF0YVZpZXcsIF9EYXRhU2V0UGFydDIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyJHQoRGF0YVZpZXcpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIERhdGFWaWV3LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgaW5zdGFuY2UgY29udGFpbmluZyBkYXRhIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KS5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoaXMgZGF0YSB2aWV3LlxyXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhVmlldyhkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIF9jb250ZXh0Mjc7XG5cbiAgICB2YXIgX3RoaXM3O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFWaWV3KTtcblxuICAgIF90aGlzNyA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIFwibGVuZ3RoXCIsIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3KSwgXCJfbGlzdGVuZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIFwiX2RhdGFcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIFwiX2lkc1wiLCBuZXcgc2V0KCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3KSwgXCJfb3B0aW9uc1wiLCB2b2lkIDApO1xuXG4gICAgX3RoaXM3Ll9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfdGhpczcuX2xpc3RlbmVyID0gYmluZCQ2KF9jb250ZXh0MjcgPSBfdGhpczcuX29uRXZlbnQpLmNhbGwoX2NvbnRleHQyNywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcpKTtcblxuICAgIF90aGlzNy5zZXREYXRhKGRhdGEpO1xuXG4gICAgcmV0dXJuIF90aGlzNztcbiAgfSAvLyBUT0RPOiBpbXBsZW1lbnQgYSBmdW5jdGlvbiAuY29uZmlnKCkgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoaW5ncyBsaWtlIGNvbmZpZ3VyZWQgZmlsdGVyXG4gIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuICAvKipcclxuICAgKiBTZXQgYSBkYXRhIHNvdXJjZSBmb3IgdGhlIHZpZXcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBpbnN0YW5jZSBjb250YWluaW5nIGRhdGEgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogTm90ZSB0aGF0IHdoZW4gdGhlIGRhdGEgdmlldyBpcyBib3VuZCB0byBhIGRhdGEgc2V0IGl0IHdvbid0IGJlIGdhcmJhZ2VcclxuICAgKiBjb2xsZWN0ZWQgdW5sZXNzIHRoZSBkYXRhIHNldCBpcyB0b28uIFVzZSBgZGF0YVZpZXcuc2V0RGF0YShudWxsKWAgb3JcclxuICAgKiBgZGF0YVZpZXcuZGlzcG9zZSgpYCB0byBlbmFibGUgZ2FyYmFnZSBjb2xsZWN0aW9uIGJlZm9yZSB5b3UgbG9zZSB0aGUgbGFzdFxyXG4gICAqIHJlZmVyZW5jZS5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhVmlldywgW3tcbiAgICBrZXk6IFwiaWRQcm9wXCIsXG4gICAgZ2V0OlxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVNldCgpLmlkUHJvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgICAgIGlmICh0aGlzLl9kYXRhLm9mZikge1xuICAgICAgICAgIHRoaXMuX2RhdGEub2ZmKFwiKlwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgICAgIH0gLy8gdHJpZ2dlciBhIHJlbW92ZSBvZiBhbGwgaXRlbXMgaW4gbWVtb3J5XG5cblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgIGZpbHRlcjogZmlsdGVyKHRoaXMuX29wdGlvbnMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2RhdGEuZ2V0KGlkcyk7XG5cbiAgICAgICAgdGhpcy5faWRzLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgIGl0ZW1zOiBpZHMsXG4gICAgICAgICAgb2xkRGF0YTogaXRlbXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7IC8vIHRyaWdnZXIgYW4gYWRkIG9mIGFsbCBhZGRlZCBpdGVtc1xuXG4gICAgICAgIHZhciBfaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgIGZpbHRlcjogZmlsdGVyKHRoaXMuX29wdGlvbnMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBfaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gX2lkc1tpXTtcblxuICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sZW5ndGggPSBfaWRzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICBpdGVtczogX2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcblxuXG4gICAgICBpZiAodGhpcy5fZGF0YS5vbikge1xuICAgICAgICB0aGlzLl9kYXRhLm9uKFwiKlwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuXHJcbiAgICAgKiBVc2VmdWwgd2hlbiB0aGUgRGF0YVZpZXcgaGFzIGEgZmlsdGVyIGZ1bmN0aW9uIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgIGZpbHRlcjogZmlsdGVyKHRoaXMuX29wdGlvbnMpXG4gICAgICB9KTtcblxuICAgICAgdmFyIG9sZElkcyA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9pZHMpO1xuXG4gICAgICB2YXIgbmV3SWRzID0ge307XG4gICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkSWRzID0gW107XG4gICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107IC8vIGNoZWNrIGZvciBhZGRpdGlvbnNcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5faWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcblxuICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNoZWNrIGZvciByZW1vdmFsc1xuXG5cbiAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfbGVuMTEgPSBvbGRJZHMubGVuZ3RoOyBfaTEwIDwgX2xlbjExOyBfaTEwKyspIHtcbiAgICAgICAgdmFyIF9pZDcgPSBvbGRJZHNbX2kxMF07XG5cbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChfaWQ3KTtcblxuICAgICAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQFRPRE86IEludmVzdGlnYXRlLlxuICAgICAgICAgIC8vIERvZXNuJ3QgaGFwcGVuIGR1cmluZyB0ZXN0cyBvciBleGFtcGxlcy5cbiAgICAgICAgICAvLyBJcyBpdCByZWFsbHkgaW1wb3NzaWJsZSBvciBjb3VsZCBpdCBldmVudHVhbGx5IGhhcHBlbj9cbiAgICAgICAgICAvLyBIb3cgdG8gaGFuZGxlIGl0IGlmIGl0IGRvZXM/IFRoZSB0eXBlcyBndWFyYW50ZWUgbm9uLW51bGxhYmxlIGl0ZW1zLlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJZiB5b3Ugc2VlIHRoaXMsIHJlcG9ydCBpdCBwbGVhc2UuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdJZHNbX2lkN10pIHtcbiAgICAgICAgICByZW1vdmVkSWRzLnB1c2goX2lkNyk7XG4gICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICB0aGlzLl9pZHMuZGVsZXRlKF9pZDcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IGFkZGVkSWRzLmxlbmd0aCAtIHJlbW92ZWRJZHMubGVuZ3RoOyAvLyB0cmlnZ2VyIGV2ZW50c1xuXG4gICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwge1xuICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgIGl0ZW1zOiByZW1vdmVkSWRzLFxuICAgICAgICAgIG9sZERhdGE6IHJlbW92ZWRJdGVtc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcblxuXG4gICAgICB2YXIgaWRzID0gbnVsbDtcbiAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICBpZiAoaXNJZChmaXJzdCkgfHwgaXNBcnJheSQyKGZpcnN0KSkge1xuICAgICAgICBpZHMgPSBmaXJzdDtcbiAgICAgICAgb3B0aW9ucyA9IHNlY29uZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBmaXJzdDtcbiAgICAgIH0gLy8gZXh0ZW5kIHRoZSBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucyBhbmQgcHJvdmlkZWQgb3B0aW9uc1xuXG5cbiAgICAgIHZhciB2aWV3T3B0aW9ucyA9IGFzc2lnbiQyKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTsgLy8gY3JlYXRlIGEgY29tYmluZWQgZmlsdGVyIG1ldGhvZCB3aGVuIG5lZWRlZFxuXG5cbiAgICAgIHZhciB0aGlzRmlsdGVyID0gZmlsdGVyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICB2YXIgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpc0ZpbHRlciAmJiBvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgIHZpZXdPcHRpb25zLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldCh2aWV3T3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXQoaWRzLCB2aWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkcyhvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICE9IG51bGwgPyBmaWx0ZXIob3B0aW9ucykgOiBudWxsO1xuICAgICAgICB2YXIgZmlsdGVyJDE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBvcHRpb25zRmlsdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIkMSA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI4O1xuXG4gICAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gZmlsdGVyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGZpbHRlciQxO1xuXG4gICAgICAgIGlmIChvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gb3B0aW9uc0ZpbHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyJDEgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaCQyKF9jb250ZXh0MjggPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MjgsIGNhbGxiYWNrLCB7XG4gICAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI5O1xuXG4gICAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gZmlsdGVyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGZpbHRlciQxO1xuXG4gICAgICAgIGlmIChvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gb3B0aW9uc0ZpbHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyJDEgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0MjkgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MjksIGNhbGxiYWNrLCB7XG4gICAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YVNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldERhdGFTZXQoKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtKGlkcykge1xuICAgICAgdmFyIF9jb250ZXh0MzA7XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLnN0cmVhbShpZHMgfHwgX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgYmluZCQ2KF9jb250ZXh0MzAgPSBrZXlzKHRoaXMuX2lkcykpLmNhbGwoX2NvbnRleHQzMCwgdGhpcy5faWRzKSkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgaW5zdGFuY2UgdW51c2FibGUgcHJpb3IgdG8gZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgaW50ZW50aW9uIG9mIHRoaXMgbWV0aG9kIGlzIHRvIGhlbHAgZGlzY292ZXIgc2NlbmFyaW9zIHdoZXJlIHRoZSBkYXRhXHJcbiAgICAgKiB2aWV3IGlzIGJlaW5nIHVzZWQgd2hlbiB0aGUgcHJvZ3JhbW1lciB0aGlua3MgaXQgaGFzIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWRcclxuICAgICAqIGFscmVhZHkuIEl0J3Mgc3RyaWN0ZXIgdmVyc2lvbiBvZiBgZGF0YVZpZXcuc2V0RGF0YShudWxsKWAuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHZhciBfdGhpcyRfZGF0YTtcblxuICAgICAgaWYgKChfdGhpcyRfZGF0YSA9IHRoaXMuX2RhdGEpICE9PSBudWxsICYmIF90aGlzJF9kYXRhICE9PSB2b2lkIDAgJiYgX3RoaXMkX2RhdGEub2ZmKSB7XG4gICAgICAgIHRoaXMuX2RhdGEub2ZmKFwiKlwiLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXNzYWdlID0gXCJUaGlzIGRhdGEgdmlldyBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLlwiO1xuICAgICAgdmFyIHJlcGxhY2VtZW50ID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhvd25LZXlzJDUoRGF0YVZpZXcucHJvdG90eXBlKSksXG4gICAgICAgICAgX3N0ZXAxNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxNC5zKCk7ICEoX3N0ZXAxNCA9IF9pdGVyYXRvcjE0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAxNC52YWx1ZTtcblxuICAgICAgICAgIGRlZmluZVByb3BlcnR5JDYodGhpcywga2V5LCByZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNC5mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgbGlzdGVuZXIuIFdpbGwgcHJvcGFnYXRlIGFsbCBldmVudHMgZnJvbSB0aGUgY29ubmVjdGVkIGRhdGEgc2V0IHRvIHRoZSBzdWJzY3JpYmVycyBvZiB0aGUgRGF0YVZpZXcsIGJ1dCB3aWxsIGZpbHRlciB0aGUgaXRlbXMgYW5kIG9ubHkgdHJpZ2dlciB3aGVuIHRoZXJlIGFyZSBjaGFuZ2VzIGluIHRoZSBmaWx0ZXJlZCBkYXRhIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBJZCBzdXBwbGllZCBieSB0aGUgc2VuZGVyLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25FdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25FdmVudChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgaWYgKCFwYXJhbXMgfHwgIXBhcmFtcy5pdGVtcyB8fCAhdGhpcy5fZGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHMgPSBwYXJhbXMuaXRlbXM7XG4gICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgIHZhciB1cGRhdGVkSWRzID0gW107XG4gICAgICB2YXIgcmVtb3ZlZElkcyA9IFtdO1xuICAgICAgdmFyIG9sZEl0ZW1zID0gW107XG4gICAgICB2YXIgdXBkYXRlZEl0ZW1zID0gW107XG4gICAgICB2YXIgcmVtb3ZlZEl0ZW1zID0gW107XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICB0aGlzLl9pZHMuYWRkKGlkKTtcblxuICAgICAgICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBldmVudCBmcm9tIHRoZSB2aWV3cyB2aWV3cG9pbnQ6IGFuIHVwZGF0ZWRcbiAgICAgICAgICAvLyBpdGVtIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCwgb3IgcmVtb3ZlZCBmcm9tIHRoaXMgdmlldy5cbiAgICAgICAgICBmb3IgKHZhciBfaTExID0gMCwgX2xlbjEyID0gaWRzLmxlbmd0aDsgX2kxMSA8IF9sZW4xMjsgX2kxMSsrKSB7XG4gICAgICAgICAgICB2YXIgX2lkOCA9IGlkc1tfaTExXTtcblxuICAgICAgICAgICAgdmFyIF9pdGVtNSA9IHRoaXMuZ2V0KF9pZDgpO1xuXG4gICAgICAgICAgICBpZiAoX2l0ZW01KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKF9pZDgpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZElkcy5wdXNoKF9pZDgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5wdXNoKHBhcmFtcy5kYXRhW19pMTFdKTtcbiAgICAgICAgICAgICAgICBvbGRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW19pMTFdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZHMuYWRkKF9pZDgpO1xuXG4gICAgICAgICAgICAgICAgYWRkZWRJZHMucHVzaChfaWQ4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkcy5oYXMoX2lkOCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZHMuZGVsZXRlKF9pZDgpO1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKF9pZDgpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW19pMTFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgcmVtb3ZlZCBpdGVtc1xuICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfbGVuMTMgPSBpZHMubGVuZ3RoOyBfaTEyIDwgX2xlbjEzOyBfaTEyKyspIHtcbiAgICAgICAgICAgIHZhciBfaWQ5ID0gaWRzW19pMTJdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faWRzLmhhcyhfaWQ5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9pZHMuZGVsZXRlKF9pZDkpO1xuXG4gICAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChfaWQ5KTtcbiAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2gocGFyYW1zLm9sZERhdGFbX2kxMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBhZGRlZElkcy5sZW5ndGggLSByZW1vdmVkSWRzLmxlbmd0aDtcblxuICAgICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLCB7XG4gICAgICAgICAgaXRlbXM6IHVwZGF0ZWRJZHMsXG4gICAgICAgICAgb2xkRGF0YTogb2xkSXRlbXMsXG4gICAgICAgICAgZGF0YTogdXBkYXRlZEl0ZW1zXG4gICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgIGl0ZW1zOiByZW1vdmVkSWRzLFxuICAgICAgICAgIG9sZERhdGE6IHJlbW92ZWRJdGVtc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFWaWV3O1xufShEYXRhU2V0UGFydCk7XG4vKipcclxuICogQ2hlY2sgdGhhdCBnaXZlbiB2YWx1ZSBpcyBjb21wYXRpYmxlIHdpdGggVmlzIERhdGEgU2V0IGludGVyZmFjZS5cclxuICpcclxuICogQHBhcmFtIGlkUHJvcCAtIFRoZSBleHBlY3RlZCBwcm9wZXJ0eSB0byBjb250YWluIGl0ZW0gaWQuXHJcbiAqIEBwYXJhbSB2IC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZC5cclxuICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgZXhwZWN0ZWQgdmFsdWVzIGFuZCBtZXRob2RzIG1hdGNoLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRGF0YVNldExpa2UoaWRQcm9wLCB2KSB7XG4gIHJldHVybiBfdHlwZW9mKHYpID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgaWRQcm9wID09PSB2LmlkUHJvcCAmJiB0eXBlb2Ygdi5hZGQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5jbGVhciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmRpc3RpbmN0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGZvckVhY2gkMih2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldERhdGFTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXRJZHMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5sZW5ndGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1hcCQzKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubWF4ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubWluID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub2ZmID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub24gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5yZW1vdmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5zZXRPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuc3RyZWFtID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYudXBkYXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYudXBkYXRlT25seSA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXHJcbiAqIENoZWNrIHRoYXQgZ2l2ZW4gdmFsdWUgaXMgY29tcGF0aWJsZSB3aXRoIFZpcyBEYXRhIFZpZXcgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWRQcm9wIC0gVGhlIGV4cGVjdGVkIHByb3BlcnR5IHRvIGNvbnRhaW4gaXRlbSBpZC5cclxuICogQHBhcmFtIHYgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFsbCBleHBlY3RlZCB2YWx1ZXMgYW5kIG1ldGhvZHMgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNEYXRhVmlld0xpa2UoaWRQcm9wLCB2KSB7XG4gIHJldHVybiBfdHlwZW9mKHYpID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgaWRQcm9wID09PSB2LmlkUHJvcCAmJiB0eXBlb2YgZm9yRWFjaCQyKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0RGF0YVNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldElkcyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWFwJDModikgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5vZmYgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5vbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiICYmIGlzRGF0YVNldExpa2UoaWRQcm9wLCB2LmdldERhdGFTZXQoKSk7XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRERUxFVEU6IERFTEVURSxcblx0RGF0YVNldDogRGF0YVNldCxcblx0RGF0YVN0cmVhbTogRGF0YVN0cmVhbSxcblx0RGF0YVZpZXc6IERhdGFWaWV3LFxuXHRRdWV1ZTogUXVldWUsXG5cdGNyZWF0ZU5ld0RhdGFQaXBlRnJvbTogY3JlYXRlTmV3RGF0YVBpcGVGcm9tLFxuXHRpc0RhdGFTZXRMaWtlOiBpc0RhdGFTZXRMaWtlLFxuXHRpc0RhdGFWaWV3TGlrZTogaXNEYXRhVmlld0xpa2Vcbn0pO1xuXG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkUDtcbnZhciBmYWlscyQxID0gZmFpbHMkdDtcbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyA9IHRvU3RyaW5nJDg7XG52YXIgdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHdoaXRlc3BhY2VzJDQ7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMkMignJy5jaGFyQXQpO1xudmFyIG4kUGFyc2VGbG9hdCA9IGdsb2JhbCQyLnBhcnNlRmxvYXQ7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkMi5TeW1ib2w7XG52YXIgSVRFUkFUT1IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMS5pdGVyYXRvcjtcbnZhciBGT1JDRUQgPSAxIC8gbiRQYXJzZUZsb2F0KHdoaXRlc3BhY2VzICsgJy0wJykgIT09IC1JbmZpbml0eSAvLyBNUyBFZGdlIDE4LSBicm9rZW4gd2l0aCBib3hlZCBzeW1ib2xzXG58fCBJVEVSQVRPUiAmJiAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gIG4kUGFyc2VGbG9hdChPYmplY3QoSVRFUkFUT1IpKTtcbn0pOyAvLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5cbnZhciBudW1iZXJQYXJzZUZsb2F0ID0gRk9SQ0VEID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHJpbmcpIHtcbiAgdmFyIHRyaW1tZWRTdHJpbmcgPSB0cmltKHRvU3RyaW5nKHN0cmluZykpO1xuICB2YXIgcmVzdWx0ID0gbiRQYXJzZUZsb2F0KHRyaW1tZWRTdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIGNoYXJBdCh0cmltbWVkU3RyaW5nLCAwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiBuJFBhcnNlRmxvYXQ7XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyICRwYXJzZUZsb2F0ID0gbnVtYmVyUGFyc2VGbG9hdDsgLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xuXG4kJDQoe1xuICBnbG9iYWw6IHRydWUsXG4gIGZvcmNlZDogcGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdFxufSwge1xuICBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdFxufSk7XG5cbnZhciBwYXRoJDUgPSBwYXRoJHk7XG52YXIgX3BhcnNlRmxvYXQkMiA9IHBhdGgkNS5wYXJzZUZsb2F0O1xuXG52YXIgcGFyZW50JDkgPSBfcGFyc2VGbG9hdCQyO1xudmFyIF9wYXJzZUZsb2F0JDEgPSBwYXJlbnQkOTtcblxudmFyIF9wYXJzZUZsb2F0ID0gX3BhcnNlRmxvYXQkMTtcblxudmFyICQkMyA9IF9leHBvcnQ7XG52YXIgZmFpbHMgPSBmYWlscyR0O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMkMyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoMSk7XG59KTsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcblxuJCQzKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTXG59LCB7XG4gIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXMkM1xufSk7XG5cbnZhciBwYXRoJDQgPSBwYXRoJHk7XG52YXIgT2JqZWN0JDEgPSBwYXRoJDQuT2JqZWN0O1xuXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQyID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gT2JqZWN0JDEuZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG59O1xuXG52YXIgcGFyZW50JDggPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDI7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQxID0gcGFyZW50JDg7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lcyQxO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSB2YWx1ZXMgdG8gdXNlIGZvciAoc3ViKW9wdGlvbnMgb2YgJ2Nob3NlbicuXG4gKlxuICogVGhpcyBvcHRpb24gaXMgZWl0aGVyIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSBleGFtaW5lZCBmdXJ0aGVyLlxuICogVGhlIHJlbGV2YW50IHN0cnVjdHVyZXMgYXJlOlxuICpcbiAqIC0gY2hvc2VuOiA8Ym9vbGVhbiB2YWx1ZT5cbiAqIC0gY2hvc2VuOiB7IHN1Yk9wdGlvbjogPGJvb2xlYW4gb3IgZnVuY3Rpb24+IH1cbiAqXG4gKiBXaGVyZSBzdWJPcHRpb24gaXMgJ25vZGUnLCAnZWRnZScgb3IgJ2xhYmVsJy5cbiAqXG4gKiBUaGUgaW50ZW50aW9uIG9mIHRoaXMgbWV0aG9kIGFwcGVhcnMgdG8gYmUgdG8gc2V0IGEgc3BlY2lmaWMgcHJpb3JpdHkgdG8gdGhlIG9wdGlvbnM7XG4gKiBTaW5jZSBtb3N0IHByb3BlcnRpZXMgYXJlIGVpdGhlciBicmlkZ2VkIG9yIG1lcmdlZCBpbnRvIHRoZSBsb2NhbCBvcHRpb25zIG9iamVjdHMsIHRoZXJlXG4gKiBpcyBub3QgbXVjaCBwb2ludCBpbiBoYW5kbGluZyB0aGVtIHNlcGFyYXRlbHkuXG4gKiBUT0RPOiBleGFtaW5lIGlmICdtb3N0JyBpbiBwcmV2aW91cyBzZW50ZW5jZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCAnYWxsJy4gSW4gdGhhdCBjYXNlLCB3ZVxuICogICAgICAgc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHN1Yk9wdGlvbiAgb3B0aW9uIHdpdGhpbiBvYmplY3QgJ2Nob3NlbicgdG8gY29uc2lkZXI7IGVpdGhlciAnbm9kZScsICdlZGdlJyBvciAnbGFiZWwnXG4gKiBAcGFyYW0ge29iamVjdH0gIHBpbGUgICAgICAgYXJyYXkgb2Ygb3B0aW9ucyBvYmplY3RzIHRvIGNvbnNpZGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IEZ1bmN0aW9ufSAgdmFsdWUgZm9yIHBhc3NlZCBzdWJPcHRpb24gb2YgJ2Nob3NlbicgdG8gdXNlXG4gKi9cblxuZnVuY3Rpb24gY2hvb3NpZnkoc3ViT3B0aW9uLCBwaWxlKSB7XG4gIC8vIGFsbG93ZWQgdmFsdWVzIGZvciBzdWJPcHRpb25cbiAgdmFyIGFsbG93ZWQgPSBbXCJub2RlXCIsIFwiZWRnZVwiLCBcImxhYmVsXCJdO1xuICB2YXIgdmFsdWUgPSB0cnVlO1xuICB2YXIgY2hvc2VuID0gdG9wTW9zdChwaWxlLCBcImNob3NlblwiKTtcblxuICBpZiAodHlwZW9mIGNob3NlbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICB2YWx1ZSA9IGNob3NlbjtcbiAgfSBlbHNlIGlmIChfdHlwZW9mKGNob3NlbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoaW5kZXhPZihhbGxvd2VkKS5jYWxsKGFsbG93ZWQsIHN1Yk9wdGlvbikgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaG9vc2lmeTogc3ViT3B0aW9uICdcIiArIHN1Yk9wdGlvbiArIFwiJyBzaG91bGQgYmUgb25lIG9mIFwiICsgXCInXCIgKyBhbGxvd2VkLmpvaW4oXCInLCAnXCIpICsgXCInXCIpO1xuICAgIH1cblxuICAgIHZhciBjaG9zZW5FZGdlID0gdG9wTW9zdChwaWxlLCBbXCJjaG9zZW5cIiwgc3ViT3B0aW9uXSk7XG5cbiAgICBpZiAodHlwZW9mIGNob3NlbkVkZ2UgPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiBjaG9zZW5FZGdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gY2hvc2VuRWRnZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAqXG4gKiBAcGFyYW0ge3JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7cG9pbnR9IHBvaW50XG4gKiBAcGFyYW0ge3JvdGF0aW9uUG9pbnR9IFtyb3RhdGlvblBvaW50XSBpZiBzcGVjaWZpZWQsIHRoZSByb3RhdGlvbiB0aGF0IGFwcGxpZXMgdG8gdGhlIHJlY3RhbmdsZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSAgdHJ1ZSBpZiBwb2ludCB3aXRoaW4gcmVjdGFuZ2xlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuXG5mdW5jdGlvbiBwb2ludEluUmVjdChyZWN0LCBwb2ludCwgcm90YXRpb25Qb2ludCkge1xuICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIGVhcmx5IG91dFxuICB9XG5cbiAgaWYgKHJvdGF0aW9uUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgdGhlIHNhbWUgYW1vdW50IGFzIHRoZSByZWN0YW5nbGVcbiAgICB2YXIgdG1wID0ge1xuICAgICAgeDogcG9pbnQueCAtIHJvdGF0aW9uUG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnkgLSByb3RhdGlvblBvaW50LnlcbiAgICB9O1xuXG4gICAgaWYgKHJvdGF0aW9uUG9pbnQuYW5nbGUgIT09IDApIHtcbiAgICAgIC8vIEluIG9yZGVyIHRvIGdldCB0aGUgY29vcmRpbmF0ZXMgdGhlIHNhbWUsIHlvdSBuZWVkIHRvXG4gICAgICAvLyByb3RhdGUgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICB2YXIgYW5nbGUgPSAtcm90YXRpb25Qb2ludC5hbmdsZTtcbiAgICAgIHZhciB0bXAyID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiB0bXAueCAtIE1hdGguc2luKGFuZ2xlKSAqIHRtcC55LFxuICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiB0bXAueCArIE1hdGguY29zKGFuZ2xlKSAqIHRtcC55XG4gICAgICB9O1xuICAgICAgcG9pbnQgPSB0bXAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludCA9IHRtcDtcbiAgICB9IC8vIE5vdGUgdGhhdCBpZiBhIHJvdGF0aW9uIGlzIHNwZWNpZmllZCwgdGhlIHJlY3RhbmdsZSBjb29yZGluYXRlc1xuICAgIC8vIGFyZSAqKm5vdCogdGhlIGZ1bGwgY2FudmFzIGNvb3JkaW5hdGVzLiBUaGV5IGFyZSByZWxhdGl2ZSB0byB0aGVcbiAgICAvLyByb3RhdGlvblBvaW50LiBIZW5jZSwgdGhlIHBvaW50IGNvb3JkaW5hdGVzIG5lZWQgbm90IGJlIHRyYW5zbGF0ZWRcbiAgICAvLyBiYWNrIGluIHRoaXMgY2FzZS5cblxuICB9XG5cbiAgdmFyIHJpZ2h0ID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgdmFyIGJvdHRvbSA9IHJlY3QueSArIHJlY3Qud2lkdGg7XG4gIHJldHVybiByZWN0LmxlZnQgPCBwb2ludC54ICYmIHJpZ2h0ID4gcG9pbnQueCAmJiByZWN0LnRvcCA8IHBvaW50LnkgJiYgYm90dG9tID4gcG9pbnQueTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gdmFsdWUgaXMgYWNjZXB0YWJsZSBhcyBhIGxhYmVsIHRleHQuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IHZhbHVlIHRvIGNoZWNrOyBjYW4gYmUgYW55dGhpbmcgYXQgdGhpcyBwb2ludFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQgbGFiZWwgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRMYWJlbCh0ZXh0KSB7XG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIHF1aXRlIHN0cmljdDogdHlwZXMgdGhhdCAqbWlnaHQqIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgYXJlIGRpc2FsbG93ZWRcbiAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiICYmIHRleHQgIT09IFwiXCI7XG59XG4vKipcbiAqIFJldHVybnMgeCwgeSBvZiBzZWxmIHJlZmVyZW5jZSBjaXJjbGUgYmFzZWQgb24gcHJvdmlkZWQgYW5nbGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY3R4XG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAqIEBwYXJhbSB7VmlzTm9kZX0gbm9kZVxuICogQHJldHVybnMge29iamVjdH0geCBhbmQgeSBjb29yZGluYXRlc1xuICovXG5cbmZ1bmN0aW9uIGdldFNlbGZSZWZDb29yZGluYXRlcyhjdHgsIGFuZ2xlLCByYWRpdXMsIG5vZGUpIHtcbiAgdmFyIHggPSBub2RlLng7XG4gIHZhciB5ID0gbm9kZS55O1xuXG4gIGlmICh0eXBlb2Ygbm9kZS5kaXN0YW5jZVRvQm9yZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvL2NhbGN1bGF0aW5nIG9wcG9zaXRlIGFuZCBhZGphY2VudFxuICAgIC8vZGlzdGFuZVRvQm9yZGVyIGJlY29tZXMgSHlwb3RlbnVzZS5cbiAgICAvL0Zvcm11bGFzIHNpbihhKSA9IE9wcG9zaXRlIC8gSHlwb3RlbnVzZSBhbmQgY29zKGEpID0gQWRqYWNlbnQgLyBIeXBvdGVudXNlXG4gICAgdmFyIHRvQm9yZGVyRGlzdCA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB2YXIgeUZyb21Ob2RlQ2VudGVyID0gTWF0aC5zaW4oYW5nbGUpICogdG9Cb3JkZXJEaXN0O1xuICAgIHZhciB4RnJvbU5vZGVDZW50ZXIgPSBNYXRoLmNvcyhhbmdsZSkgKiB0b0JvcmRlckRpc3Q7IC8veEZyb21Ob2RlQ2VudGVyIGlzIGJhc2ljYWxseSB4IGFuZCBpZiB4RnJvbU5vZGVDZW50ZXIgZXF1YWxzIHRvIHRoZSBkaXN0YW5jZSB0byBib3JkZXIgdGhlbiBpdCBtZWFuc1xuICAgIC8vdGhhdCB5IGRvZXMgbm90IG5lZWQgY2FsY3VsYXRpb24gYmVjYXVzZSBpdCBpcyBlcXVhbCBub2RlLmhlaWdodCAvIDIgb3Igbm9kZS55XG4gICAgLy9zYW1lIHRoaW5nIHdpdGggeUZyb21Ob2RlQ2VudGVyIGFuZCBpZiB5RnJvbU5vZGVDZW50ZXIgZXF1YWxzIHRvIHRoZSBkaXN0YW5jZSB0byBib3JkZXIgdGhlbiBpdCBtZWFuc1xuICAgIC8vdGhhdCB4IGlzIGVxdWFsIG5vZGUud2lkdGggLyAyIG9yIG5vZGUueFxuXG4gICAgaWYgKHhGcm9tTm9kZUNlbnRlciA9PT0gdG9Cb3JkZXJEaXN0KSB7XG4gICAgICB4ICs9IHRvQm9yZGVyRGlzdDtcbiAgICAgIHkgPSBub2RlLnk7XG4gICAgfSBlbHNlIGlmICh5RnJvbU5vZGVDZW50ZXIgPT09IHRvQm9yZGVyRGlzdCkge1xuICAgICAgeCA9IG5vZGUueDtcbiAgICAgIHkgLT0gdG9Cb3JkZXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHhGcm9tTm9kZUNlbnRlcjtcbiAgICAgIHkgLT0geUZyb21Ob2RlQ2VudGVyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnNoYXBlLndpZHRoID4gbm9kZS5zaGFwZS5oZWlnaHQpIHtcbiAgICB4ID0gbm9kZS54ICsgbm9kZS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICB5ID0gbm9kZS55IC0gcmFkaXVzO1xuICB9IGVsc2Uge1xuICAgIHggPSBub2RlLnggKyByYWRpdXM7XG4gICAgeSA9IG5vZGUueSAtIG5vZGUuc2hhcGUuaGVpZ2h0ICogMC41O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCBkaW1lbnNpb25zLCB1c2luZyB0aGUgcGFyZW50IGxhYmVsIHNldHRpbmdzLlxuICpcbiAqIEBjYWxsYmFjayBNZWFzdXJlVGV4dFxuICogQHBhcmFtIHt0ZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3RleHR9IG1vZFxuICogQHJldHVybnMge29iamVjdH0geyB3aWR0aCwgdmFsdWVzfSB3aWR0aCBpbiBwaXhlbHMgYW5kIGZvbnQgYXR0cmlidXRlc1xuICovXG5cbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBMYWJlbCB3aGljaCBjb2xsZWN0cyByZXN1bHRzIG9mIHNwbGl0dGluZyBsYWJlbHMgaW50byBsaW5lcyBhbmQgYmxvY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBMYWJlbEFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TWVhc3VyZVRleHR9IG1lYXN1cmVUZXh0XG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbEFjY3VtdWxhdG9yKG1lYXN1cmVUZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsQWNjdW11bGF0b3IpO1xuXG4gICAgdGhpcy5tZWFzdXJlVGV4dCA9IG1lYXN1cmVUZXh0O1xuICAgIHRoaXMuY3VycmVudCA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIGdpdmVuIHRleHQgdG8gdGhlIGdpdmVuIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbCAgICBpbmRleCBvZiBsaW5lIHRvIGFkZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgc3RyaW5nIHRvIGFwcGVuZCB0byBsaW5lXG4gICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTGFiZWxBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwiX2FkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkKGwsIHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwibm9ybWFsXCI7XG5cbiAgICAgIGlmICh0aGlzLmxpbmVzW2xdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5saW5lc1tsXSA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgYmxvY2tzOiBbXVxuICAgICAgICB9O1xuICAgICAgfSAvLyBXZSBzdGlsbCBuZWVkIHRvIHNldCBhIGJsb2NrIGZvciB1bmRlZmluZWQgYW5kIGVtcHR5IHRleHRzLCBoZW5jZSByZXR1cm4gYXQgdGhpcyBwb2ludFxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGF0IHRoaXMgcG9pbnQgaWYgd2UncmUgYXQgdGhlXG4gICAgICAvLyBzdGFydCBvZiBhbiBlbXB0eSBsaW5lIG9yIG5vdC5cbiAgICAgIC8vIFRvIGNvbXBlbnNhdGUsIGVtcHR5IGJsb2NrcyBhcmUgcmVtb3ZlZCBpbiBgZmluYWxpemUoKWAuXG4gICAgICAvL1xuICAgICAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgc3RpbGwgaGF2ZSBhIGhlaWdodFxuXG5cbiAgICAgIHZhciB0bXBUZXh0ID0gdGV4dDtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gXCJcIikgdG1wVGV4dCA9IFwiIFwiOyAvLyBEZXRlcm1pbmUgd2lkdGggYW5kIGdldCB0aGUgZm9udCBwcm9wZXJ0aWVzXG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1lYXN1cmVUZXh0KHRtcFRleHQsIG1vZCk7XG5cbiAgICAgIHZhciBibG9jayA9IGFzc2lnbiQyKHt9LCB2YWx1ZXMocmVzdWx0KSk7XG5cbiAgICAgIGJsb2NrLnRleHQgPSB0ZXh0O1xuICAgICAgYmxvY2sud2lkdGggPSByZXN1bHQud2lkdGg7XG4gICAgICBibG9jay5tb2QgPSBtb2Q7XG5cbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gXCJcIikge1xuICAgICAgICBibG9jay53aWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGluZXNbbF0uYmxvY2tzLnB1c2goYmxvY2spOyAvLyBVcGRhdGUgdGhlIGxpbmUgd2lkdGguIFdlIG5lZWQgdGhpcyBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBzdHJpbmcgZ29lcyBvdmVyIG1heCB3aWR0aFxuXG4gICAgICB0aGlzLmxpbmVzW2xdLndpZHRoICs9IGJsb2NrLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJXaWR0aCgpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1t0aGlzLmN1cnJlbnRdO1xuICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gbGluZS53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRleHQgaW4gYmxvY2sgdG8gY3VycmVudCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQodGV4dCkge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJub3JtYWxcIjtcblxuICAgICAgdGhpcy5fYWRkKHRoaXMuY3VycmVudCwgdGV4dCwgbW9kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRleHQgaW4gYmxvY2sgdG8gY3VycmVudCBsaW5lIGFuZCBzdGFydCBhIG5ldyBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3TGluZSh0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIm5vcm1hbFwiO1xuXG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuXG4gICAgICB0aGlzLmN1cnJlbnQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFuZCBzZXQgdGhlIGhlaWdodHMgb2YgYWxsIHRoZSBsaW5lcyBjdXJyZW50bHkgY29udGFpbmVkIGluIHRoaXMgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aWR0aCBoYXMgYWxyZWFkeSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVMaW5lSGVpZ2h0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVMaW5lSGVpZ2h0cygpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5saW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNba107IC8vIExvb2tpbmcgZm9yIG1heCBoZWlnaHQgb2YgYmxvY2tzIGluIGxpbmVcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcblxuICAgICAgICBpZiAobGluZS5ibG9ja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIENhbiBoYXBwZW4gaWYgdGV4dCBjb250YWlucyBlLmcuICdcXG4gJ1xuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgYmxvY2suaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGhlaWdodCA9IGJsb2NrLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBmdWxsIHNpemUgb2YgdGhlIGxhYmVsIHRleHQsIGFzIGRldGVybWluZWQgYnkgY3VycmVudCBsaW5lcyBhbmQgYmxvY2tzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lTGFiZWxTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUxhYmVsU2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1trXTtcblxuICAgICAgICBpZiAobGluZS53aWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBsaW5lLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaGVpZ2h0ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBlbXB0eSBibG9ja3MgYW5kIGVtcHR5IGxpbmVzIHdlIGRvbid0IG5lZWRcbiAgICAgKlxuICAgICAqIFRoaXMgbXVzdCBiZSBkb25lIGFmdGVyIHRoZSB3aWR0aC9oZWlnaHQgZGV0ZXJtaW5hdGlvbixcbiAgICAgKiBzbyB0aGF0IHRoZXNlIGFyZSBzZXQgcHJvcGVybHkgZm9yIHByb2Nlc3NpbmcgaGVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxMaW5lPn0gTGluZXMgd2l0aCBlbXB0eSBibG9ja3MgKGFuZCBzb21lIGVtcHR5IGxpbmVzKSByZW1vdmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUVtcHR5QmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5QmxvY2tzKCkge1xuICAgICAgdmFyIHRtcExpbmVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5saW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNba107IC8vIE5vdGU6IGFuIGVtcHR5IGxpbmUgaW4gYmV0d2VlbiB0ZXh0IGhhcyB3aWR0aCB6ZXJvIGJ1dCBpcyBzdGlsbCByZWxldmFudCB0byBsYXlvdXQuXG4gICAgICAgIC8vIFNvIHdlIGNhbid0IHVzZSB3aWR0aCBmb3IgdGVzdGluZyBlbXB0eSBsaW5lIGhlcmVcblxuICAgICAgICBpZiAobGluZS5ibG9ja3MubGVuZ3RoID09PSAwKSBjb250aW51ZTsgLy8gRGlzY2FyZCBmaW5hbCBlbXB0eSBsaW5lIGFsd2F5c1xuXG4gICAgICAgIGlmIChrID09PSB0aGlzLmxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAobGluZS53aWR0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wTGluZSA9IHt9O1xuXG4gICAgICAgIGFzc2lnbiQyKHRtcExpbmUsIGxpbmUpO1xuXG4gICAgICAgIHRtcExpbmUuYmxvY2tzID0gW107XG4gICAgICAgIHZhciBmaXJzdEVtcHR5QmxvY2sgPSB2b2lkIDA7XG4gICAgICAgIHZhciB0bXBCbG9ja3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gbGluZS5ibG9ja3NbbF07XG5cbiAgICAgICAgICBpZiAoYmxvY2sud2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIHRtcEJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpcnN0RW1wdHlCbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpcnN0RW1wdHlCbG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyAqc29tZSogdGV4dCBwcmVzZW50XG5cblxuICAgICAgICBpZiAodG1wQmxvY2tzLmxlbmd0aCA9PT0gMCAmJiBmaXJzdEVtcHR5QmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRtcEJsb2Nrcy5wdXNoKGZpcnN0RW1wdHlCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IHRtcEJsb2NrcztcbiAgICAgICAgdG1wTGluZXMucHVzaCh0bXBMaW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRtcExpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpemVzIGZvciBhbGwgbGluZXMgYW5kIHRoZSB3aG9sZSB0aGluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IChudW1iZXJ8KiksIGhlaWdodDogKG51bWJlcnwqKSwgbGluZXM6IEFycmF5fX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh0aGlzLmxpbmVzLCBudWxsLCAyKSk7XG4gICAgICB0aGlzLmRldGVybWluZUxpbmVIZWlnaHRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZUxhYmVsU2l6ZSgpO1xuICAgICAgdmFyIHRtcExpbmVzID0gdGhpcy5yZW1vdmVFbXB0eUJsb2NrcygpOyAvLyBSZXR1cm4gYSBzaW1wbGUgaGFzaCBvYmplY3QgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZy5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIGxpbmVzOiB0bXBMaW5lc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGFiZWxBY2N1bXVsYXRvcjtcbn0oKTtcblxudmFyIHRhZ1BhdHRlcm4gPSB7XG4gIC8vIEhUTUxcbiAgXCI8Yj5cIjogLzxiPi8sXG4gIFwiPGk+XCI6IC88aT4vLFxuICBcIjxjb2RlPlwiOiAvPGNvZGU+LyxcbiAgXCI8L2I+XCI6IC88XFwvYj4vLFxuICBcIjwvaT5cIjogLzxcXC9pPi8sXG4gIFwiPC9jb2RlPlwiOiAvPFxcL2NvZGU+LyxcbiAgLy8gTWFya2Rvd25cbiAgXCIqXCI6IC9cXCovLFxuICAvLyBib2xkXG4gIF86IC9fLyxcbiAgLy8gaXRhbFxuICBcImBcIjogL2AvLFxuICAvLyBtb25vXG4gIGFmdGVyQm9sZDogL1teKl0vLFxuICBhZnRlckl0YWw6IC9bXl9dLyxcbiAgYWZ0ZXJNb25vOiAvW15gXS9cbn07XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBjbGFzcyBmb3IgcGFyc2luZyB0aGUgbWFya3VwIHRhZ3MgZm9yIEhUTUwgYW5kIE1hcmtkb3duLlxuICpcbiAqIE5PVEU6IFNlcXVlbmNlcyBvZiB0YWJzIGFuZCBzcGFjZXMgYXJlIHJlZHVjZWQgdG8gc2luZ2xlIHNwYWNlLlxuICogICAgICAgU2NhbiB1c2FnZSBvZiBgdGhpcy5zcGFjaW5nYCB3aXRoaW4gbWV0aG9kXG4gKi9cblxudmFyIE1hcmt1cEFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgdGV4dCB0byBwYXJzZSBmb3IgbWFya3VwXG4gICAqL1xuICBmdW5jdGlvbiBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmt1cEFjY3VtdWxhdG9yKTtcblxuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5ib2xkID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsID0gZmFsc2U7XG4gICAgdGhpcy5tb25vID0gZmFsc2U7XG4gICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgIHRoaXMubW9kU3RhY2sgPSBbXTtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1vZCBsYWJlbCBjdXJyZW50bHkgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIHRvcG1vc3QgbW9kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1hcmt1cEFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJtb2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kU3RhY2subGVuZ3RoID09PSAwID8gXCJub3JtYWxcIiA6IHRoaXMubW9kU3RhY2tbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbW9kIGxhYmVsIGN1cnJlbnRseSBhY3RpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICBsYWJlbCBvZiBhY3RpdmUgbW9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vZE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kTmFtZSgpIHtcbiAgICAgIGlmICh0aGlzLm1vZFN0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwibm9ybWFsXCI7ZWxzZSBpZiAodGhpcy5tb2RTdGFja1swXSA9PT0gXCJtb25vXCIpIHJldHVybiBcIm1vbm9cIjtlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYm9sZCAmJiB0aGlzLml0YWwpIHtcbiAgICAgICAgICByZXR1cm4gXCJib2xkaXRhbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYm9sZCkge1xuICAgICAgICAgIHJldHVybiBcImJvbGRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLml0YWwpIHtcbiAgICAgICAgICByZXR1cm4gXCJpdGFsXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVtaXRCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0QmxvY2soKSB7XG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYWRkKFwiIFwiKTtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYmxvY2tzLnB1c2goe1xuICAgICAgICAgIHRleHQ6IHRoaXMuYnVmZmVyLFxuICAgICAgICAgIG1vZDogdGhpcy5tb2ROYW1lKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRleHQgdG8gYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgdGV4dCB0byBhZGRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3BhY2luZykge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSBcIiBcIjtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0ICE9IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwYXJzaW5nIG9mIHdoaXRlc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaCAgdGhlIGNoYXJhY3RlciB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgd2FzIHByb2Nlc3NlZCBhcyB3aGl0ZXNwYWNlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlV1NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VXUyhjaCkge1xuICAgICAgaWYgKC9bIFxcdF0vLnRlc3QoY2gpKSB7XG4gICAgICAgIGlmICghdGhpcy5tb25vKSB7XG4gICAgICAgICAgdGhpcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZChjaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAgbGFiZWwgZm9yIGJsb2NrIHR5cGUgdG8gc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUYWcodGFnTmFtZSkge1xuICAgICAgdGhpcy5lbWl0QmxvY2soKTtcbiAgICAgIHRoaXNbdGFnTmFtZV0gPSB0cnVlO1xuICAgICAgdGhpcy5tb2RTdGFjay51bnNoaWZ0KHRhZ05hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAgbGFiZWwgZm9yIGJsb2NrIHR5cGUgdG8gdW5zZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zZXRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZXRUYWcodGFnTmFtZSkge1xuICAgICAgdGhpcy5lbWl0QmxvY2soKTtcbiAgICAgIHRoaXNbdGFnTmFtZV0gPSBmYWxzZTtcbiAgICAgIHRoaXMubW9kU3RhY2suc2hpZnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbGFiZWwgZm9yIGJsb2NrIHR5cGUgd2UgYXJlIGN1cnJlbnRseSBwcm9jZXNzaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VTdGFydFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnKHRhZ05hbWUsIHRhZykge1xuICAgICAgLy8gTm90ZTogaWYgJ21vbm8nIHBhc3NlZCBhcyB0YWdOYW1lLCB0aGVyZSBpcyBhIGRvdWJsZSBjaGVjayBoZXJlLiBUaGlzIGlzIE9LXG4gICAgICBpZiAoIXRoaXMubW9ubyAmJiAhdGhpc1t0YWdOYW1lXSAmJiB0aGlzLm1hdGNoKHRhZykpIHtcbiAgICAgICAgdGhpcy5zZXRUYWcodGFnTmFtZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthZHZhbmNlPXRydWVdIGlmIHNldCwgYWR2YW5jZSBjdXJyZW50IHBvc2l0aW9uIGluIHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBtYXRjaCBhdCBnaXZlbiBwb3NpdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKHRhZykge1xuICAgICAgdmFyIGFkdmFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIHZhciBfdGhpcyRwcmVwYXJlUmVnRXhwID0gdGhpcy5wcmVwYXJlUmVnRXhwKHRhZyksXG4gICAgICAgICAgX3RoaXMkcHJlcGFyZVJlZ0V4cDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRwcmVwYXJlUmVnRXhwLCAyKSxcbiAgICAgICAgICByZWdFeHAgPSBfdGhpcyRwcmVwYXJlUmVnRXhwMlswXSxcbiAgICAgICAgICBsZW5ndGggPSBfdGhpcyRwcmVwYXJlUmVnRXhwMlsxXTtcblxuICAgICAgdmFyIG1hdGNoZWQgPSByZWdFeHAudGVzdCh0aGlzLnRleHQuc3Vic3RyKHRoaXMucG9zaXRpb24sIGxlbmd0aCkpO1xuXG4gICAgICBpZiAobWF0Y2hlZCAmJiBhZHZhbmNlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIGxhYmVsIGZvciBibG9jayB0eXBlIHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtuZXh0VGFnXSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggZm9yIGNoYXJhY3RlcnMgKmZvbGxvd2luZyogdGhlIGN1cnJlbnQgdGFnXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRW5kVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZ05hbWUsIHRhZywgbmV4dFRhZykge1xuICAgICAgdmFyIGNoZWNrVGFnID0gdGhpcy5tb2QoKSA9PT0gdGFnTmFtZTtcblxuICAgICAgaWYgKHRhZ05hbWUgPT09IFwibW9ub1wiKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yICdtb25vJ1xuICAgICAgICBjaGVja1RhZyA9IGNoZWNrVGFnICYmIHRoaXMubW9ubztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrVGFnID0gY2hlY2tUYWcgJiYgIXRoaXMubW9ubztcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrVGFnICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICBpZiAobmV4dFRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUHVycG9zZSBvZiB0aGUgZm9sbG93aW5nIG1hdGNoIGlzIHRvIHByZXZlbnQgYSBkaXJlY3QgdW5zZXQvc2V0IG9mIGEgZ2l2ZW4gdGFnXG4gICAgICAgICAgLy8gRS5nLiAnKmJvbGQgKipzdGlsbCBib2xkKicgPT4gJypib2xkIHN0aWxsIGJvbGQqJ1xuICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSB0aGlzLnRleHQubGVuZ3RoIC0gMSB8fCB0aGlzLm1hdGNoKG5leHRUYWcsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy51bnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlICBzdHJpbmcgdG8gcmVwbGFjZSB0YWcgd2l0aCwgaWYgZm91bmQgYXQgY3VycmVudCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0YWcgd2FzIHByb2Nlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodGFnLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciB0aGUgdGFnIGlmIGl0IGlzbid0IGFscmVhZHkgb25lLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBhcnJheSBgW1JlZ0V4cCwgbnVtYmVyXWAsIHdpdGggZXhhY3RseSB0d28gdmFsdWUsIHdoZXJlOlxuICAgICAqICAtIFJlZ0V4cCBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIHRvIHVzZVxuICAgICAqICAtIG51bWJlciBpcyB0aGUgbGVudGggb2YgdGhlIGlucHV0IHN0cmluZyB0byBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge0FycmF5fSAgcmVndWxhciBleHByZXNzaW9uIHRvIHVzZSBhbmQgbGVuZ3RoIG9mIGlucHV0IHN0cmluZyB0byBtYXRjaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJlUmVnRXhwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVSZWdFeHAodGFnKSB7XG4gICAgICB2YXIgbGVuZ3RoO1xuICAgICAgdmFyIHJlZ0V4cDtcblxuICAgICAgaWYgKHRhZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZWdFeHAgPSB0YWc7XG4gICAgICAgIGxlbmd0aCA9IDE7IC8vIEFTU1VNUFRJT046IHJlZ2V4cCBvbmx5IHRlc3RzIG9uZSBjaGFyYWN0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBwcmVwYXJlZCByZWdleHAgaWYgcHJlc2VudFxuICAgICAgICB2YXIgcHJlcGFyZWQgPSB0YWdQYXR0ZXJuW3RhZ107XG5cbiAgICAgICAgaWYgKHByZXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWdFeHAgPSBwcmVwYXJlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKHRhZyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSB0YWcubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3JlZ0V4cCwgbGVuZ3RoXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFya3VwQWNjdW11bGF0b3I7XG59KCk7XG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgTGFiZWwgd2hpY2ggZXhwbG9kZXMgdGhlIGxhYmVsIHRleHQgaW50byBsaW5lcyBhbmQgYmxvY2tzIHdpdGhpbiBsaW5lc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgTGFiZWxTcGxpdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0xhYmVsfSBwYXJlbnQgcmVmZXJlbmNlIHRvIHRoZSBMYWJlbCBpbnN0YW5jZSB1c2luZyBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxTcGxpdHRlcihjdHgsIHBhcmVudCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbFNwbGl0dGVyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB0aGlzLmhvdmVyID0gaG92ZXI7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHRleHQgd2lkdGg7IHBhc3NlZCB0byBMYWJlbEFjY3VtdWxhdG9yIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgc3RyaW5nIHRvIGRldGVybWluZSB3aWR0aCBvZlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbW9kICBmb250IHR5cGUgdG8gdXNlIGZvciB0aGlzIHRleHRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB7IHdpZHRoLCB2YWx1ZXN9IHdpZHRoIGluIHBpeGVscyBhbmQgZm9udCBhdHRyaWJ1dGVzXG4gICAgICovXG5cbiAgICB2YXIgdGV4dFdpZHRoID0gZnVuY3Rpb24gdGV4dFdpZHRoKHRleHQsIG1vZCkge1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7IC8vIFRPRE86IFRoaXMgY2FuIGJlIGRvbmUgbW9yZSBlZmZpY2llbnRseSB3aXRoIGNhY2hpbmdcbiAgICAgIC8vIFRoaXMgd2lsbCBzZXQgdGhlIGN0eC5mb250IGNvcnJlY3RseSwgZGVwZW5kaW5nIG9uIHNlbGVjdGVkL2hvdmVyIGFuZCBtb2QgLSBzbyB0aGF0IGN0eC5tZWFzdXJlVGV4dCgpIHdpbGwgYmUgYWNjdXJhdGUuXG5cbiAgICAgIHZhciB2YWx1ZXMgPSBfdGhpcy5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhjdHgsIHNlbGVjdGVkLCBob3ZlciwgbW9kKTtcblxuICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgaWYgKHRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgdmFyIG1lYXN1cmUgPSBfdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG5cbiAgICAgICAgd2lkdGggPSBtZWFzdXJlLndpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmxpbmVzID0gbmV3IExhYmVsQWNjdW11bGF0b3IodGV4dFdpZHRoKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgcGFzc2VkIHRleHQgb2YgYSBsYWJlbCBpbnRvIGxpbmVzIGFuZCBibG9ja3MuXG4gICAqXG4gICAqICMgTk9URVxuICAgKlxuICAgKiBUaGUgaGFuZGxpbmcgb2Ygc3BhY2luZyBpcyBvcHRpb24gZGVwZW5kZW50OlxuICAgKlxuICAgKiAtIGlmIGBmb250Lm11bHRpIDogZmFsc2VgLCBhbGwgc3BhY2VzIGFyZSByZXRhaW5lZFxuICAgKiAtIGlmIGBmb250Lm11bHRpIDogdHJ1ZWAsIGV2ZXJ5IHNlcXVlbmNlIG9mIHNwYWNlcyBpcyBjb21wcmVzc2VkIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAqXG4gICAqIFRoaXMgbWlnaHQgbm90IGJlIHRoZSBiZXN0IHdheSB0byBkbyBpdCwgYnV0IHRoaXMgaXMgYXMgaXQgaGFzIGJlZW4gd29ya2luZyB0aWxsIG5vdy5cbiAgICogSW4gb3JkZXIgbm90IHRvIGJyZWFrIGV4aXN0aW5nIGZ1bmN0aW9uYWxpdHksIGZvciB0aGUgdGltZSBiZWluZyB0aGlzIGJlaGF2aW91ciB3aWxsXG4gICAqIGJlIHJldGFpbmVkIGluIGFueSBjb2RlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICB0ZXh0IHRvIHNwbGl0XG4gICAqIEByZXR1cm5zIHtBcnJheTxsaW5lPn1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTGFiZWxTcGxpdHRlciwgW3tcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKHRleHQpIHtcbiAgICAgIGlmICghaXNWYWxpZExhYmVsKHRleHQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250ID0gdGhpcy5wYXJlbnQuZm9udE9wdGlvbnM7IC8vIE5vcm1hbGl6ZSB0aGUgZW5kLW9mLWxpbmUncyB0byBhIHNpbmdsZSByZXByZXNlbnRhdGlvbiAtIG9yZGVyIGltcG9ydGFudFxuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIik7IC8vIERvcyBFT0wnc1xuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIik7IC8vIE1hYyBFT0wnc1xuICAgICAgLy8gTm90ZSB0aGF0IGF0IHRoaXMgcG9pbnQsIHRoZXJlIGNhbiBiZSBubyBcXHIncyBpbiB0aGUgdGV4dC5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZCBsYXRlciBvbiBzcGxpdFN0cmluZ0ludG9MaW5lcygpIHRvIHNwbGl0IG11bHRpZm9udCB0ZXh0cy5cblxuICAgICAgdmFyIG5sTGluZXMgPSBTdHJpbmcodGV4dCkuc3BsaXQoXCJcXG5cIik7XG4gICAgICB2YXIgbGluZUNvdW50ID0gbmxMaW5lcy5sZW5ndGg7XG5cbiAgICAgIGlmIChmb250Lm11bHRpKSB7XG4gICAgICAgIC8vIE11bHRpLWZvbnQgY2FzZTogc3R5bGluZyB0YWdzIGFjdGl2ZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuc3BsaXRCbG9ja3MobmxMaW5lc1tpXSwgZm9udC5tdWx0aSk7IC8vIFBvc3Q6IFNlcXVlbmNlcyBvZiB0YWJzIGFuZCBzcGFjZXMgYXJlIHJlZHVjZWQgdG8gc2luZ2xlIHNwYWNlXG5cbiAgICAgICAgICBpZiAoYmxvY2tzID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZShcIlwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmb250Lm1heFdkdCA+IDApIHtcbiAgICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIGRlZmluZWRcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1J1bm5pbmcgd2lkdGhDb25zdHJhaW50IG11bHRpLCBtYXg6ICcgKyB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2Nrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbW9kID0gYmxvY2tzW2pdLm1vZDtcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gYmxvY2tzW2pdLnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMuc3BsaXRTdHJpbmdJbnRvTGluZXMoX3RleHQsIG1vZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIE5PVCBkZWZpbmVkXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgYmxvY2tzLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICB2YXIgX21vZCA9IGJsb2Nrc1tfal0ubW9kO1xuICAgICAgICAgICAgICB2YXIgX3RleHQyID0gYmxvY2tzW19qXS50ZXh0O1xuICAgICAgICAgICAgICB0aGlzLmxpbmVzLmFwcGVuZChfdGV4dDIsIF9tb2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW5nbGUtZm9udCBjYXNlXG4gICAgICAgIGlmIChmb250Lm1heFdkdCA+IDApIHtcbiAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBkZWZpbmVkXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1J1bm5pbmcgd2lkdGhDb25zdHJhaW50IG5vcm1hbCwgbWF4OiAnICsgdGhpcy5mb250T3B0aW9ucy5tYXhXZHQpO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsaW5lQ291bnQ7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRTdHJpbmdJbnRvTGluZXMobmxMaW5lc1tfaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBOT1QgZGVmaW5lZFxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGxpbmVDb3VudDsgX2kyKyspIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZShubExpbmVzW19pMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5saW5lcy5maW5hbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBub3JtYWxpemUgdGhlIG1hcmt1cCBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnwnbWQnfCdtYXJrZG93bid8J2h0bWwnfSBtYXJrdXBTeXN0ZW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlTWFya3VwU3lzdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZU1hcmt1cFN5c3RlbShtYXJrdXBTeXN0ZW0pIHtcbiAgICAgIHZhciBzeXN0ZW0gPSBcIm5vbmVcIjtcblxuICAgICAgaWYgKG1hcmt1cFN5c3RlbSA9PT0gXCJtYXJrZG93blwiIHx8IG1hcmt1cFN5c3RlbSA9PT0gXCJtZFwiKSB7XG4gICAgICAgIHN5c3RlbSA9IFwibWFya2Rvd25cIjtcbiAgICAgIH0gZWxzZSBpZiAobWFya3VwU3lzdGVtID09PSB0cnVlIHx8IG1hcmt1cFN5c3RlbSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgc3lzdGVtID0gXCJodG1sXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzeXN0ZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdEh0bWxCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRIdG1sQmxvY2tzKHRleHQpIHtcbiAgICAgIHZhciBzID0gbmV3IE1hcmt1cEFjY3VtdWxhdG9yKHRleHQpO1xuXG4gICAgICB2YXIgcGFyc2VFbnRpdGllcyA9IGZ1bmN0aW9uIHBhcnNlRW50aXRpZXMoY2gpIHtcbiAgICAgICAgaWYgKC8mLy50ZXN0KGNoKSkge1xuICAgICAgICAgIHZhciBwYXJzZWQgPSBzLnJlcGxhY2Uocy50ZXh0LCBcIiZsdDtcIiwgXCI8XCIpIHx8IHMucmVwbGFjZShzLnRleHQsIFwiJmFtcDtcIiwgXCImXCIpO1xuXG4gICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHMuYWRkKFwiJlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChzLnBvc2l0aW9uIDwgcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBzLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuICAgICAgICB2YXIgcGFyc2VkID0gcy5wYXJzZVdTKGNoKSB8fCAvPC8udGVzdChjaCkgJiYgKHMucGFyc2VTdGFydFRhZyhcImJvbGRcIiwgXCI8Yj5cIikgfHwgcy5wYXJzZVN0YXJ0VGFnKFwiaXRhbFwiLCBcIjxpPlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJtb25vXCIsIFwiPGNvZGU+XCIpIHx8IHMucGFyc2VFbmRUYWcoXCJib2xkXCIsIFwiPC9iPlwiKSB8fCBzLnBhcnNlRW5kVGFnKFwiaXRhbFwiLCBcIjwvaT5cIikgfHwgcy5wYXJzZUVuZFRhZyhcIm1vbm9cIiwgXCI8L2NvZGU+XCIpKSB8fCBwYXJzZUVudGl0aWVzKGNoKTtcblxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgIH1cblxuICAgICAgcy5lbWl0QmxvY2soKTtcbiAgICAgIHJldHVybiBzLmJsb2NrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0TWFya2Rvd25CbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRNYXJrZG93bkJsb2Nrcyh0ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHMgPSBuZXcgTWFya3VwQWNjdW11bGF0b3IodGV4dCk7XG4gICAgICB2YXIgYmVnaW5hYmxlID0gdHJ1ZTtcblxuICAgICAgdmFyIHBhcnNlT3ZlcnJpZGUgPSBmdW5jdGlvbiBwYXJzZU92ZXJyaWRlKGNoKSB7XG4gICAgICAgIGlmICgvXFxcXC8udGVzdChjaCkpIHtcbiAgICAgICAgICBpZiAocy5wb3NpdGlvbiA8IF90aGlzMi50ZXh0Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgICAgICAgIGNoID0gX3RoaXMyLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoLyBcXHQvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgIHMuc3BhY2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzLmFkZChjaCk7XG4gICAgICAgICAgICAgIGJlZ2luYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHMucG9zaXRpb24gPCBzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaCA9IHMudGV4dC5jaGFyQXQocy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBwYXJzZWQgPSBzLnBhcnNlV1MoY2gpIHx8IHBhcnNlT3ZlcnJpZGUoY2gpIHx8IChiZWdpbmFibGUgfHwgcy5zcGFjaW5nKSAmJiAocy5wYXJzZVN0YXJ0VGFnKFwiYm9sZFwiLCBcIipcIikgfHwgcy5wYXJzZVN0YXJ0VGFnKFwiaXRhbFwiLCBcIl9cIikgfHwgcy5wYXJzZVN0YXJ0VGFnKFwibW9ub1wiLCBcImBcIikpIHx8IHMucGFyc2VFbmRUYWcoXCJib2xkXCIsIFwiKlwiLCBcImFmdGVyQm9sZFwiKSB8fCBzLnBhcnNlRW5kVGFnKFwiaXRhbFwiLCBcIl9cIiwgXCJhZnRlckl0YWxcIikgfHwgcy5wYXJzZUVuZFRhZyhcIm1vbm9cIiwgXCJgXCIsIFwiYWZ0ZXJNb25vXCIpO1xuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICAgIGJlZ2luYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5wb3NpdGlvbisrO1xuICAgICAgfVxuXG4gICAgICBzLmVtaXRCbG9jaygpO1xuICAgICAgcmV0dXJuIHMuYmxvY2tzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBsb2RlcyBhIHBpZWNlIG9mIHRleHQgaW50byBzaW5nbGUtZm9udCBibG9ja3MgdXNpbmcgYSBnaXZlbiBtYXJrdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtib29sZWFufCdtZCd8J21hcmtkb3duJ3wnaHRtbCd9IG1hcmt1cFN5c3RlbVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3RleHQ6IHN0cmluZywgbW9kOiBzdHJpbmd9Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRCbG9ja3ModGV4dCwgbWFya3VwU3lzdGVtKSB7XG4gICAgICB2YXIgc3lzdGVtID0gdGhpcy5kZWNvZGVNYXJrdXBTeXN0ZW0obWFya3VwU3lzdGVtKTtcblxuICAgICAgaWYgKHN5c3RlbSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBtb2Q6IFwibm9ybWFsXCJcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2UgaWYgKHN5c3RlbSA9PT0gXCJtYXJrZG93blwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0TWFya2Rvd25CbG9ja3ModGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHN5c3RlbSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRIdG1sQmxvY2tzKHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRleHQgbGVuZ3RoIG92ZXIgdGhlIGN1cnJlbnQgbWF4IHdpdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3Zlck1heFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJNYXhXaWR0aCh0ZXh0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgIHJldHVybiB0aGlzLmxpbmVzLmN1cldpZHRoKCkgKyB3aWR0aCA+IHRoaXMucGFyZW50LmZvbnRPcHRpb25zLm1heFdkdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBsb25nZXN0IHBhcnQgb2YgdGhlIHNlbnRlbmNlIHdoaWNoIHN0aWxsIGZpdHMgaW4gdGhlXG4gICAgICogY3VycmVudCBtYXggd2lkdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAgQXJyYXkgb2Ygc3RyaW5ncyBzaWduaWZ5aW5nIGEgdGV4dCBsaW5lc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9ICAgICAgaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb25nZXN0Rml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvbmdlc3RGaXQod29yZHMpIHtcbiAgICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgIHZhciB3ID0gMDtcblxuICAgICAgd2hpbGUgKHcgPCB3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRleHQgPT09IFwiXCIgPyBcIlwiIDogXCIgXCI7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gdGV4dCArIHByZSArIHdvcmRzW3ddO1xuICAgICAgICBpZiAodGhpcy5vdmVyTWF4V2lkdGgobmV3VGV4dCkpIGJyZWFrO1xuICAgICAgICB0ZXh0ID0gbmV3VGV4dDtcbiAgICAgICAgdysrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBsb25nZXN0IHBhcnQgb2YgdGhlIHN0cmluZyB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgQXJyYXkgb2Ygc3RyaW5ncyBzaWduaWZ5aW5nIGEgdGV4dCBsaW5lc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IG9mIGZpcnN0IGl0ZW0gaW4gc3RyaW5nIG1ha2luZyBzdHJpbmcgZ28gb3ZlciBtYXhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExvbmdlc3RGaXRXb3JkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvbmdlc3RGaXRXb3JkKHdvcmRzKSB7XG4gICAgICB2YXIgdyA9IDA7XG5cbiAgICAgIHdoaWxlICh3IDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJNYXhXaWR0aChzbGljZSh3b3JkcykuY2FsbCh3b3JkcywgMCwgdykpKSBicmVhaztcbiAgICAgICAgdysrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXQgdGhlIHBhc3NlZCB0ZXh0IGludG8gbGluZXMsIGFjY29yZGluZyB0byB3aWR0aCBjb25zdHJhaW50IChpZiBhbnkpLlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCBhc3N1bWVzIHRoYXQgdGhlIGlucHV0IHN0cmluZyBpcyBhIHNpbmdsZSBsaW5lLCBpLmUuIHdpdGhvdXQgbGluZXMgYnJlYWsuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXRhaW5zIHNwYWNlcywgaWYgc3RpbGwgcHJlc2VudCAoY2FzZSBgZm9udC5tdWx0aTogZmFsc2VgKS5cbiAgICAgKiBBIHNwYWNlIHdoaWNoIGZhbGxzIG9uIGFuIGludGVybmFsIGxpbmUgYnJlYWssIHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBuZXdsaW5lLlxuICAgICAqIFRoZXJlIGlzIG5vIHNwZWNpYWwgaGFuZGxpbmcgb2YgdGFiczsgdGhlc2UgZ28gYWxvbmcgd2l0aCB0aGUgZmxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21vZD0nbm9ybWFsJ11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcHBlbmRMYXN0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdFN0cmluZ0ludG9MaW5lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdFN0cmluZ0ludG9MaW5lcyhzdHIpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG4gICAgICB2YXIgYXBwZW5kTGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAvLyBTZXQgdGhlIGNhbnZhcyBjb250ZXh0IGZvbnQsIGJhc2VkIHVwb24gdGhlIGN1cnJlbnQgc2VsZWN0ZWQvaG92ZXIgc3RhdGVcbiAgICAgIC8vIGFuZCB0aGUgcHJvdmlkZWQgbW9kLCBzbyB0aGUgdGV4dCBtZWFzdXJlbWVudCBwZXJmb3JtZWQgYnkgZ2V0TG9uZ2VzdEZpdFxuICAgICAgLy8gd2lsbCBiZSBhY2N1cmF0ZSAtIGFuZCBub3QganVzdCB1c2UgdGhlIGZvbnQgb2Ygd2hvZXZlciBsYXN0IHVzZWQgdGhlIGNhbnZhcy5cbiAgICAgIHRoaXMucGFyZW50LmdldEZvcm1hdHRpbmdWYWx1ZXModGhpcy5jdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIG1vZCk7IC8vIFN0aWxsLXByZXNlbnQgc3BhY2VzIGFyZSByZWxldmFudCwgcmV0YWluIHRoZW1cblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL14oICspL2csIFwiJDFcXHJcIik7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFteXFxyXVteIF0qKSggKykvZywgXCIkMVxcciQyXFxyXCIpO1xuICAgICAgdmFyIHdvcmRzID0gc3RyLnNwbGl0KFwiXFxyXCIpO1xuXG4gICAgICB3aGlsZSAod29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMuZ2V0TG9uZ2VzdEZpdCh3b3Jkcyk7XG5cbiAgICAgICAgaWYgKHcgPT09IDApIHtcbiAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHRoZSBmaXJzdCB3b3JkIGlzIGFscmVhZHkgbGFyZ2VyIHRoYW4gdGhlIG1heCB3aWR0aC5cbiAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzWzBdOyAvLyBCcmVhayB0aGUgd29yZCB0byB0aGUgbGFyZ2VzdCBwYXJ0IHRoYXQgZml0cyB0aGUgbGluZVxuXG4gICAgICAgICAgdmFyIHggPSB0aGlzLmdldExvbmdlc3RGaXRXb3JkKHdvcmQpO1xuICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZShzbGljZSh3b3JkKS5jYWxsKHdvcmQsIDAsIHgpLCBtb2QpOyAvLyBBZGp1c3QgdGhlIHdvcmQsIHNvIHRoYXQgdGhlIHJlc3Qgd2lsbCBiZSBkb25lIG5leHQgaXRlcmF0aW9uXG5cbiAgICAgICAgICB3b3Jkc1swXSA9IHNsaWNlKHdvcmQpLmNhbGwod29yZCwgeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2tpcCBhbnkgc3BhY2UgdGhhdCBpcyByZXBsYWNlZCBieSBhIG5ld2xpbmVcbiAgICAgICAgICB2YXIgbmV3VyA9IHc7XG5cbiAgICAgICAgICBpZiAod29yZHNbdyAtIDFdID09PSBcIiBcIikge1xuICAgICAgICAgICAgdy0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAod29yZHNbbmV3V10gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICBuZXdXKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRleHQgPSBzbGljZSh3b3JkcykuY2FsbCh3b3JkcywgMCwgdykuam9pbihcIlwiKTtcblxuICAgICAgICAgIGlmICh3ID09IHdvcmRzLmxlbmd0aCAmJiBhcHBlbmRMYXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLmFwcGVuZCh0ZXh0LCBtb2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUodGV4dCwgbW9kKTtcbiAgICAgICAgICB9IC8vIEFkanVzdCB0aGUgd29yZCwgc28gdGhhdCB0aGUgcmVzdCB3aWxsIGJlIGRvbmUgbmV4dCBpdGVyYXRpb25cblxuXG4gICAgICAgICAgd29yZHMgPSBzbGljZSh3b3JkcykuY2FsbCh3b3JkcywgbmV3Vyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGFiZWxTcGxpdHRlcjtcbn0oKTtcblxuLyoqXG4gKiBMaXN0IG9mIHNwZWNpYWwgc3R5bGVzIGZvciBtdWx0aS1mb250c1xuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG11bHRpRm9udFN0eWxlID0gW1wiYm9sZFwiLCBcIml0YWxcIiwgXCJib2xkaXRhbFwiLCBcIm1vbm9cIl07XG4vKipcbiAqIEEgTGFiZWwgdG8gYmUgdXNlZCBmb3IgTm9kZXMgb3IgRWRnZXMuXG4gKi9cblxudmFyIExhYmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VkZ2VsYWJlbD1mYWxzZV1cbiAgICovXG4gIGZ1bmN0aW9uIExhYmVsKGJvZHksIG9wdGlvbnMpIHtcbiAgICB2YXIgZWRnZWxhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbCk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucG9pbnRUb1NlbGYgPSBmYWxzZTtcbiAgICB0aGlzLmJhc2VTaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9udE9wdGlvbnMgPSB7fTsgLy8gaW5zdGFuY2UgdmFyaWFibGUgY29udGFpbmluZyB0aGUgKmluc3RhbmNlLWxvY2FsKiBmb250IG9wdGlvbnNcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNpemUgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICB5TGluZTogMFxuICAgIH07XG4gICAgdGhpcy5pc0VkZ2VMYWJlbCA9IGVkZ2VsYWJlbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBOb2RlLWluc3RhbmNlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExhYmVsLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5lbGVtZW50T3B0aW9ucyA9IG9wdGlvbnM7IC8vIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcGFyZW50IE5vZGUtaW5zdGFuY2VcblxuICAgICAgdGhpcy5pbml0Rm9udE9wdGlvbnMob3B0aW9ucy5mb250KTtcblxuICAgICAgaWYgKGlzVmFsaWRMYWJlbChvcHRpb25zLmxhYmVsKSkge1xuICAgICAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQmFkIGxhYmVsISBDaGFuZ2UgdGhlIG9wdGlvbiB2YWx1ZSB0byBwcmV2ZW50IGJhZCBzdHVmZiBoYXBwZW5pbmdcbiAgICAgICAgb3B0aW9ucy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZm9udCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBmb250IG9wdGlvbnMgY2FuIGJlIGRlbGV0ZWQgYXQgdmFyaW91cyBsZXZlbHNcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLmJhc2VTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5mb250KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHZhciBzaXplID0gb3B0aW9ucy5mb250LnNpemU7XG5cbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VTaXplID0gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdCB0aGUgZm9udCBPcHRpb25zIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIE1lbWJlciBmb250T3B0aW9ucyBzZXJ2ZXMgYXMgYW4gYWNjdW11bGF0b3IgZm9yIHRoZSBjdXJyZW50IGZvbnQgb3B0aW9ucy5cbiAgICAgKiBBcyBzdWNoLCBpdCBuZWVkcyB0byBiZSBjb21wbGV0ZWx5IHNlcGFyYXRlZCBmcm9tIHRoZSBub2RlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3Rm9udE9wdGlvbnMgdGhlIG5ldyBmb250IG9wdGlvbnMgdG8gcHJvY2Vzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0Rm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEZvbnRPcHRpb25zKG5ld0ZvbnRPcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSBtdWx0aS1mb250IG9wdGlvbiBvYmplY3RzLlxuICAgICAgLy8gVGhlc2Ugd2lsbCBiZSBmaWxsZWQgaW4gcHJvcGFnYXRlRm9udHMoKSwgaWYgcmVxdWlyZWRcbiAgICAgIGZvckVhY2gkMShtdWx0aUZvbnRTdHlsZSwgZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIF90aGlzLmZvbnRPcHRpb25zW3N0eWxlXSA9IHt9O1xuICAgICAgfSk7IC8vIEhhbmRsZSBzaG9ydGhhbmQgb3B0aW9uLCBpZiBwcmVzZW50XG5cbiAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodGhpcy5mb250T3B0aW9ucywgbmV3Rm9udE9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMudmFkanVzdCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ29weSBvdmVyIHRoZSBub24tbXVsdGlmb250IG9wdGlvbnMsIGlmIHNwZWNpZmllZFxuXG5cbiAgICAgIGZvckVhY2gkMShuZXdGb250T3B0aW9ucywgZnVuY3Rpb24gKHByb3AsIG4pIHtcbiAgICAgICAgaWYgKHByb3AgIT09IHVuZGVmaW5lZCAmJiBwcm9wICE9PSBudWxsICYmIF90eXBlb2YocHJvcCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBfdGhpcy5mb250T3B0aW9uc1tuXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBpbi12YXJpYWJsZSBpcyBhIHN0cmluZywgcGFyc2UgaXQgYXMgYSBmb250IHNwZWNpZmllci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBmb2xsb3dpbmcgaXMgbm90IGRvbmUgaGVyZSBhbmQgaGF2ZSB0byBiZSBkb25lIGFmdGVyIHRoZSBjYWxsOlxuICAgICAqIC0gTm90IGFsbCBmb250IG9wdGlvbnMgYXJlIHNldCAodmFkanVzdCwgbW9kKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG91dE9wdGlvbnMgIG91dC1wYXJhbWV0ZXIsIG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgcGFyc2UgcmVzdWx0cyAoaWYgYW55KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbk9wdGlvbnMgIGZvbnQgb3B0aW9ucyB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGZvbnQgcGFyc2VkIGFzIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3RyYWluXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGNvbnN0cmFpbnRzIGJhc2VkIG9uICduZWFyZXN0JyB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGlsZSBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBhY3R1YWwgY29uc3RyYWludCB2YWx1ZXMgdG8gdXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdHJhaW4ocGlsZSkge1xuICAgICAgLy8gTk9URTogY29uc3RyYWluV2lkdGggYW5kICBjb25zdHJhaW5IZWlnaHQgbmV2ZXIgc2V0IVxuICAgICAgLy8gTk9URTogZm9yIGVkZ2UgbGFiZWxzLCBvbmx5ICdtYXhXZHQnIHNldFxuICAgICAgLy8gTm9kZSBsYWJlbHMgY2FuIHNldCBhbGwgdGhlIGZpZWxkc1xuICAgICAgdmFyIGZvbnRPcHRpb25zID0ge1xuICAgICAgICBjb25zdHJhaW5XaWR0aDogZmFsc2UsXG4gICAgICAgIG1heFdkdDogLTEsXG4gICAgICAgIG1pbldkdDogLTEsXG4gICAgICAgIGNvbnN0cmFpbkhlaWdodDogZmFsc2UsXG4gICAgICAgIG1pbkhndDogLTEsXG4gICAgICAgIHZhbGlnbjogXCJtaWRkbGVcIlxuICAgICAgfTtcbiAgICAgIHZhciB3aWR0aENvbnN0cmFpbnQgPSB0b3BNb3N0KHBpbGUsIFwid2lkdGhDb25zdHJhaW50XCIpO1xuXG4gICAgICBpZiAodHlwZW9mIHdpZHRoQ29uc3RyYWludCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBmb250T3B0aW9ucy5tYXhXZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50KTtcbiAgICAgICAgZm9udE9wdGlvbnMubWluV2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludCk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2Yod2lkdGhDb25zdHJhaW50KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgd2lkdGhDb25zdHJhaW50TWF4aW11bSA9IHRvcE1vc3QocGlsZSwgW1wid2lkdGhDb25zdHJhaW50XCIsIFwibWF4aW11bVwiXSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnRNYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMubWF4V2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludE1heGltdW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPSB0b3BNb3N0KHBpbGUsIFtcIndpZHRoQ29uc3RyYWludFwiLCBcIm1pbmltdW1cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50TWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1pbldkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnRNaW5pbXVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludCA9IHRvcE1vc3QocGlsZSwgXCJoZWlnaHRDb25zdHJhaW50XCIpO1xuXG4gICAgICBpZiAodHlwZW9mIGhlaWdodENvbnN0cmFpbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9udE9wdGlvbnMubWluSGd0ID0gTnVtYmVyKGhlaWdodENvbnN0cmFpbnQpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGhlaWdodENvbnN0cmFpbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9IHRvcE1vc3QocGlsZSwgW1wiaGVpZ2h0Q29uc3RyYWludFwiLCBcIm1pbmltdW1cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludE1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludE1pbmltdW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPSB0b3BNb3N0KHBpbGUsIFtcImhlaWdodENvbnN0cmFpbnRcIiwgXCJ2YWxpZ25cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChoZWlnaHRDb25zdHJhaW50VmFsaWduID09PSBcInRvcFwiIHx8IGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLnZhbGlnbiA9IGhlaWdodENvbnN0cmFpbnRWYWxpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb250T3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9wdGlvbnMgYW5kIHVwZGF0ZSBpbnRlcm5hbCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIG9wdGlvbnMgdG8gc2V0XG4gICAgICogQHBhcmFtIHtBcnJheX0gIHBpbGUgICAgIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyIGZvciBvcHRpb24gJ2Nob3NlbidcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucywgcGlsZSkge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIHRydWUpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVGb250cyhwaWxlKTtcbiAgICAgIGRlZXBFeHRlbmQodGhpcy5mb250T3B0aW9ucywgdGhpcy5jb25zdHJhaW4ocGlsZSkpO1xuICAgICAgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID0gY2hvb3NpZnkoXCJsYWJlbFwiLCBwaWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBtYXJnaW5zIGFyZSBzZXQgaW4gYW4gZWxlbWVudCwgYWRqdXN0IHNpemVzIGlzIGNhbGxlZCB0byByZW1vdmUgdGhlbVxuICAgICAqIGZyb20gdGhlIHdpZHRoL2hlaWdodCBjb25zdHJhaW50cy4gVGhpcyBtdXN0IGJlIGRvbmUgcHJpb3IgdG8gbGFiZWwgc2l6aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBtYXJnaW5zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RTaXplcyhtYXJnaW5zKSB7XG4gICAgICB2YXIgd2lkdGhCaWFzID0gbWFyZ2lucyA/IG1hcmdpbnMucmlnaHQgKyBtYXJnaW5zLmxlZnQgOiAwO1xuXG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCAtPSB3aWR0aEJpYXM7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluV2R0IC09IHdpZHRoQmlhcztcbiAgICAgIH1cblxuICAgICAgdmFyIGhlaWdodEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbSA6IDA7XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmNvbnN0cmFpbkhlaWdodCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1pbkhndCAtPSBoZWlnaHRCaWFzO1xuICAgICAgfVxuICAgIH0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWV0aG9kcyBmb3IgaGFuZGxpbmcgb3B0aW9ucyBwaWxlc1xuICAgIC8vIEV2ZW50dWFsbHksIHRoZXNlIHdpbGwgYmUgbW92ZWQgdG8gYSBzZXBhcmF0ZSBjbGFzc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBmb250IG1lbWJlcnMgb2YgdGhlIHBhc3NlZCBsaXN0IG9mIG9wdGlvbiBvYmplY3RzIHRvIHRoZSBwaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBkc3RQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIGFkZCB0b1xuICAgICAqIEBwYXJhbSB7UGlsZX0gc3JjUGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB0YWtlIGZvbnQgb3B0aW9ucyBmcm9tXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEZvbnRPcHRpb25zVG9QaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvbnRPcHRpb25zVG9QaWxlKGRzdFBpbGUsIHNyY1BpbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjUGlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmFkZEZvbnRUb1BpbGUoZHN0UGlsZSwgc3JjUGlsZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBnaXZlbiBmb250IG9wdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyAodGhlICdwaWxlJykgdG8gY29uc2lkZXIgZm9yIGRldGVybWluaW5nXG4gICAgICogbXVsdGktZm9udCBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBpbnN0YW5jZSB0byBhZGQgdG8gcGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRGb250VG9QaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvbnRUb1BpbGUocGlsZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgaWYgKG9wdGlvbnMuZm9udCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZm9udCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIGl0ZW0gPSBvcHRpb25zLmZvbnQ7XG4gICAgICBwaWxlLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxlY3QgYWxsIG93bi1wcm9wZXJ0eSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBwaWxlIHRoYXQgYXJlbid0IG11bHRpLWZvbnQgb3B0aW9uIG9iamVjdHNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG9iamVjdCB3aXRoIGFsbCBjdXJyZW50IG93biBiYXNpYyBmb250IHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzaWNPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2ljT3B0aW9ucyhwaWxlKSB7XG4gICAgICB2YXIgcmV0ID0ge307IC8vIFNjYW5zIHRoZSB3aG9sZSBwaWxlIHRvIGdldCBhbGwgb3B0aW9ucyBwcmVzZW50XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcGlsZS5sZW5ndGg7ICsrbikge1xuICAgICAgICB2YXIgZm9udE9wdGlvbnMgPSBwaWxlW25dOyAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcblxuICAgICAgICB2YXIgdG1wU2hvcnRoYW5kID0ge307XG5cbiAgICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0bXBTaG9ydGhhbmQsIGZvbnRPcHRpb25zKSkge1xuICAgICAgICAgIGZvbnRPcHRpb25zID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaCQxKGZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICAgICAgaWYgKG9wdCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG11bHRpLWZvbnQgb3B0aW9uIG5lZWQgbm90IGJlIHByZXNlbnRcblxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmV0LCBuYW1lKSkgcmV0dXJuOyAvLyBLZWVwIGZpcnN0IHZhbHVlIHdlIGVuY291bnRlclxuXG4gICAgICAgICAgaWYgKGluZGV4T2YobXVsdGlGb250U3R5bGUpLmNhbGwobXVsdGlGb250U3R5bGUsIG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU2tpcCBtdWx0aS1mb250IHByb3BlcnRpZXMgYnV0IHdlIGRvIG5lZWQgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0W25hbWVdID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IG9wdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIGZvciBnaXZlbiBvcHRpb24gZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250LlxuICAgICAqXG4gICAgICogQWxsIGF2YWlsYWJsZSBvcHRpb24gb2JqZWN0cyBhcmUgdHJhd2xlZCBpbiB0aGUgc2V0IG9yZGVyIHRvIGNvbnN0cnVjdCB0aGUgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICMjIFRyYXZlcnNhbCBvZiBwaWxlIGZvciBtdWx0aS1mb250c1xuICAgICAqXG4gICAgICogVGhlIGRldGVybWluYXRpb24gb2YgbXVsdGktZm9udCBvcHRpb24gdmFsdWVzIGlzIGEgc3BlY2lhbCBjYXNlLCBiZWNhdXNlIGFueSB2YWx1ZXMgbm90XG4gICAgICogcHJlc2VudCBpbiB0aGUgbXVsdGktZm9udCBvcHRpb25zIHNob3VsZCBieSBkZWZpbml0aW9uIGJlIHRha2VuIGZyb20gdGhlIG1haW4gZm9udCBvcHRpb25zLFxuICAgICAqIGkuZS4gZnJvbSB0aGUgY3VycmVudCAncGFyZW50JyBvYmplY3Qgb2YgdGhlIG11bHRpLWZvbnQgb3B0aW9uLlxuICAgICAqXG4gICAgICogIyMjIFNlYXJjaCBvcmRlciBmb3IgbXVsdGktZm9udHNcbiAgICAgKlxuICAgICAqICdib2xkJyB1c2VkIGFzIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgIC0gc2VhcmNoIGluIG9wdGlvbiBncm91cCAnYm9sZCcgaW4gbG9jYWwgcHJvcGVydGllc1xuICAgICAqICAgLSBzZWFyY2ggaW4gbWFpbiBmb250IG9wdGlvbiBncm91cCBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge011bHRpRm9udFN0eWxlfSBtdWx0aU5hbWUgc3ViIHBhdGggZm9yIHRoZSBtdWx0aS1mb250XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbiAgdGhlIG9wdGlvbiB0byBzZWFyY2ggZm9yLCBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcn0gdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvbnRPcHRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbihwaWxlLCBtdWx0aU5hbWUsIG9wdGlvbikge1xuICAgICAgdmFyIG11bHRpRm9udDsgLy8gU2VhcmNoIG11bHRpIGZvbnQgaW4gbG9jYWwgcHJvcGVydGllc1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBpbGUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgdmFyIGZvbnRPcHRpb25zID0gcGlsZVtuXTtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvbnRPcHRpb25zLCBtdWx0aU5hbWUpKSB7XG4gICAgICAgICAgbXVsdGlGb250ID0gZm9udE9wdGlvbnNbbXVsdGlOYW1lXTtcbiAgICAgICAgICBpZiAobXVsdGlGb250ID09PSB1bmRlZmluZWQgfHwgbXVsdGlGb250ID09PSBudWxsKSBjb250aW51ZTsgLy8gQ29udmVydCBzaG9ydGhhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgLy8gVE9ETzogaW5lZmZpY2llbnQgdG8gZG8gdGhpcyBjb252ZXJzaW9uIGV2ZXJ5IHRpbWU7IGZpbmQgYSBiZXR0ZXIgd2F5LlxuXG4gICAgICAgICAgdmFyIHRtcFNob3J0aGFuZCA9IHt9O1xuXG4gICAgICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0bXBTaG9ydGhhbmQsIG11bHRpRm9udCkpIHtcbiAgICAgICAgICAgIG11bHRpRm9udCA9IHRtcFNob3J0aGFuZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG11bHRpRm9udCwgb3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpRm9udFtvcHRpb25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBPcHRpb24gaXMgbm90IG1lbnRpb25lZCBpbiB0aGUgbXVsdGkgZm9udCBvcHRpb25zOyB0YWtlIGl0IGZyb20gdGhlIHBhcmVudCBmb250IG9wdGlvbnMuXG4gICAgICAvLyBUaGVzZSBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgd2l0aCBnZXRCYXNpY09wdGlvbnMoKSwgc28gdXNlIHRoZSBjb252ZXJ0ZWQgdmFsdWVzLlxuXG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5mb250T3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgfSAvLyBBIHZhbHVlICoqbXVzdCoqIGJlIGZvdW5kOyB5b3Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZmluZCB2YWx1ZSBmb3IgbXVsdGktZm9udCBmb3IgcHJvcGVydHk6ICdcIiArIG9wdGlvbiArIFwiJ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCBvcHRpb25zIHZhbHVlcyBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnQuXG4gICAgICpcbiAgICAgKiBBbGwgYXZhaWxhYmxlIG9wdGlvbiBvYmplY3RzIGFyZSB0cmF3bGVkIGluIHRoZSBzZXQgb3JkZXIgdG8gY29uc3RydWN0IHRoZSBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7TXVsdGlGb250U3R5bGV9IG11bHRpTmFtZSBzdWIgcGF0aCBmb3IgdGhlIG1vZC1mb250XG4gICAgICogQHJldHVybnMge011bHRpRm9udE9wdGlvbnN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvbnRPcHRpb25zKHBpbGUsIG11bHRpTmFtZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgdmFyIG9wdGlvbk5hbWVzID0gW1wiY29sb3JcIiwgXCJzaXplXCIsIFwiZmFjZVwiLCBcIm1vZFwiLCBcInZhZGp1c3RcIl07IC8vIExpc3Qgb2YgYWxsb3dlZCBvcHRpb25zIHBlciBtdWx0aS1mb250XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1vZCA9IG9wdGlvbk5hbWVzW2ldO1xuICAgICAgICByZXN1bHRbbW9kXSA9IHRoaXMuZ2V0Rm9udE9wdGlvbihwaWxlLCBtdWx0aU5hbWUsIG1vZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBFbmQgbWV0aG9kcyBmb3IgaGFuZGxpbmcgb3B0aW9ucyBwaWxlc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgdGhlIGZvbnQgb3B0aW9ucyBmb3IgdGhlIG11bHRpLWZvbnQgdG8gc2luZ2xlIG9iamVjdHMsIGZyb21cbiAgICAgKiB0aGUgY2hhaW4gb2Ygb3B0aW9uIG9iamVjdHMgcGFzc2VkICh0aGUgJ3BpbGUnKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgc2VxdWVuY2Ugb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICBGaXJzdCBpdGVtIGluIGxpc3QgYXNzdW1lZCB0byBiZSB0aGUgbmV3bHkgc2V0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9wYWdhdGVGb250c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wYWdhdGVGb250cyhwaWxlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvbnRQaWxlID0gW107IC8vIHNlcXVlbmNlIG9mIGZvbnQgb2JqZWN0cyB0byBjb25zaWRlciwgb3JkZXIgaW1wb3J0YW50XG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcy5lbGVtZW50T3B0aW9ucyBpcyBub3QgdXNlZCBoZXJlLlxuXG4gICAgICB0aGlzLmFkZEZvbnRPcHRpb25zVG9QaWxlKGZvbnRQaWxlLCBwaWxlKTtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMgPSB0aGlzLmdldEJhc2ljT3B0aW9ucyhmb250UGlsZSk7IC8vIFdlIHNldCBtdWx0aWZvbnQgdmFsdWVzIGV2ZW4gaWYgbXVsdGkgPT09IGZhbHNlLCBmb3IgY29uc2lzdGVuY3kgKHRoaW5ncyBicmVhayBvdGhlcndpc2UpXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIG1vZCA9IG11bHRpRm9udFN0eWxlW2ldO1xuICAgICAgICB2YXIgbW9kT3B0aW9ucyA9IF90aGlzMi5mb250T3B0aW9uc1ttb2RdO1xuXG4gICAgICAgIHZhciB0bXBNdWx0aUZvbnRPcHRpb25zID0gX3RoaXMyLmdldEZvbnRPcHRpb25zKGZvbnRQaWxlLCBtb2QpOyAvLyBDb3B5IG92ZXIgZm91bmQgdmFsdWVzXG5cblxuICAgICAgICBmb3JFYWNoJDEodG1wTXVsdGlGb250T3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbiwgbikge1xuICAgICAgICAgIG1vZE9wdGlvbnNbbl0gPSBvcHRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBtb2RPcHRpb25zLnNpemUgPSBOdW1iZXIobW9kT3B0aW9ucy5zaXplKTtcbiAgICAgICAgbW9kT3B0aW9ucy52YWRqdXN0ID0gTnVtYmVyKG1vZE9wdGlvbnMudmFkanVzdCk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpRm9udFN0eWxlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uLiBUaGlzIGlzIGNhbGxlZCBmcm9tIGFueXRoaW5nIHRoYXQgd2FudHMgdG8gZHJhdyBhIGxhYmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFzZWxpbmU9J21pZGRsZSddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogXCJtaWRkbGVcIjtcbiAgICAgIC8vIGlmIG5vIGxhYmVsLCByZXR1cm5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0byByZW5kZXIgdGhlIGxhYmVsXG5cbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsICYmIHZpZXdGb250U2l6ZSA8IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gMSkgcmV0dXJuOyAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGVyZSB3aWxsIG5vdCBiZSBIVUdFIGxldHRlcnMgb24gc2NyZWVuXG4gICAgICAvLyBieSBzZXR0aW5nIGFuIHVwcGVyIGxpbWl0IG9uIHRoZSB2aXNpYmxlIHRleHQgc2l6ZSAocmVnYXJkbGVzcyBvZiB6b29tTGV2ZWwpXG5cbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPj0gdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUpIHtcbiAgICAgICAgdmlld0ZvbnRTaXplID0gTnVtYmVyKHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfSAvLyB1cGRhdGUgdGhlIHNpemUgY2FjaGUgaWYgcmVxdWlyZWRcblxuXG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgeCwgeSwgYmFzZWxpbmUpO1xuXG4gICAgICB0aGlzLl9kcmF3QmFja2dyb3VuZChjdHgpO1xuXG4gICAgICB0aGlzLl9kcmF3VGV4dChjdHgsIHgsIHRoaXMuc2l6ZS55TGluZSwgYmFzZWxpbmUsIHZpZXdGb250U2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBsYWJlbCBiYWNrZ3JvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3QmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JhY2tncm91bmQoY3R4KSB7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgICBjdHguZmlsbFJlY3Qoc2l6ZS5sZWZ0LCBzaXplLnRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1RleHQoY3R4LCB4LCB5KSB7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwibWlkZGxlXCI7XG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBfdGhpcyRfc2V0QWxpZ25tZW50ID0gdGhpcy5fc2V0QWxpZ25tZW50KGN0eCwgeCwgeSwgYmFzZWxpbmUpO1xuXG4gICAgICB2YXIgX3RoaXMkX3NldEFsaWdubWVudDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfc2V0QWxpZ25tZW50LCAyKTtcblxuICAgICAgeCA9IF90aGlzJF9zZXRBbGlnbm1lbnQyWzBdO1xuICAgICAgeSA9IF90aGlzJF9zZXRBbGlnbm1lbnQyWzFdO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgeCA9IHggLSB0aGlzLnNpemUud2lkdGggLyAyOyAvLyBTaGlmdCBsYWJlbCAxLzItZGlzdGFuY2UgdG8gdGhlIGxlZnRcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduICYmIHRoaXMuc2l6ZS5oZWlnaHQgPiB0aGlzLnNpemUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgeSAtPSAodGhpcy5zaXplLmhlaWdodCAtIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgeSArPSAodGhpcy5zaXplLmhlaWdodCAtIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICB9IC8vIGRyYXcgdGhlIHRleHRcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuXG4gICAgICAgIGlmIChsaW5lICYmIGxpbmUuYmxvY2tzKSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsIHx8IHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICAgIHdpZHRoICs9ICh0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoKSAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgIHdpZHRoICs9IHRoaXMuc2l6ZS53aWR0aCAtIGxpbmUud2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gbGluZS5ibG9ja3Nbal07XG4gICAgICAgICAgICBjdHguZm9udCA9IGJsb2NrLmZvbnQ7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRfZ2V0Q29sb3IgPSB0aGlzLl9nZXRDb2xvcihibG9jay5jb2xvciwgdmlld0ZvbnRTaXplLCBibG9jay5zdHJva2VDb2xvciksXG4gICAgICAgICAgICAgICAgX3RoaXMkX2dldENvbG9yMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDb2xvciwgMiksXG4gICAgICAgICAgICAgICAgZm9udENvbG9yID0gX3RoaXMkX2dldENvbG9yMlswXSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IF90aGlzJF9nZXRDb2xvcjJbMV07XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJsb2NrLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZm9udENvbG9yO1xuXG4gICAgICAgICAgICBpZiAoYmxvY2suc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGJsb2NrLnRleHQsIHggKyB3aWR0aCwgeSArIGJsb2NrLnZhZGp1c3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB3aWR0aCArPSBibG9jay53aWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZWxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKSB7XG4gICAgICAvLyBjaGVjayBmb3IgbGFiZWwgYWxpZ25tZW50IChmb3IgZWRnZXMpXG4gICAgICAvLyBUT0RPOiBtYWtlIGFsaWdubWVudCBmb3Igbm9kZXNcbiAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsICYmIHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gIT09IFwiaG9yaXpvbnRhbFwiICYmIHRoaXMucG9pbnRUb1NlbGYgPT09IGZhbHNlKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuXG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgICAgIHkgLT0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgYWxwaGFiZXRpYy4gQWxwaGFiZXRpYyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiaGFuZ2luZ1wiO1xuICAgICAgICAgIHkgKz0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGJhc2VsaW5lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmYWRlIGluIHdoZW4gcmVsYXRpdmUgc2NhbGUgaXMgYmV0d2VlbiB0aHJlc2hvbGQgYW5kIHRocmVzaG9sZCAtIDEuXG4gICAgICogSWYgdGhlIHJlbGF0aXZlIHNjYWxlIHdvdWxkIGJlIHNtYWxsZXIgdGhhbiB0aHJlc2hvbGQgLTEgdGhlIGRyYXcgZnVuY3Rpb24gd291bGQgaGF2ZSByZXR1cm5lZCBiZWZvcmUgY29taW5nIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgIFRoZSBmb250IGNvbG9yIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Rm9udFNpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbFN0cm9rZUNvbG9yXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb250IGNvbG9yIGFuZCBzdHJva2UgY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb2xvcihjb2xvciwgdmlld0ZvbnRTaXplLCBpbml0aWFsU3Ryb2tlQ29sb3IpIHtcbiAgICAgIHZhciBmb250Q29sb3IgPSBjb2xvciB8fCBcIiMwMDAwMDBcIjtcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IGluaXRpYWxTdHJva2VDb2xvciB8fCBcIiNmZmZmZmZcIjtcblxuICAgICAgaWYgKHZpZXdGb250U2l6ZSA8PSB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIDEgLSAodGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSB2aWV3Rm9udFNpemUpKSk7XG4gICAgICAgIGZvbnRDb2xvciA9IG92ZXJyaWRlT3BhY2l0eShmb250Q29sb3IsIG9wYWNpdHkpO1xuICAgICAgICBzdHJva2VDb2xvciA9IG92ZXJyaWRlT3BhY2l0eShzdHJva2VDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZm9udENvbG9yLCBzdHJva2VDb2xvcl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0U2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgIGxpbmVDb3VudDogdGhpcy5saW5lQ291bnRcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICogQHJldHVybnMge3JlY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICB2YXIgbGluZU1hcmdpbiA9IDI7XG4gICAgICB2YXIgeCA9IHRoaXMuc2l6ZS5sZWZ0OyAvLyBkZWZhdWx0IHZhbHVlcyB3aGljaCBtaWdodCBiZSBvdmVycmlkZGVuIGJlbG93XG5cbiAgICAgIHZhciB5ID0gdGhpcy5zaXplLnRvcCAtIDAuNSAqIGxpbmVNYXJnaW47IC8vIGlkZW1cblxuICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwpIHtcbiAgICAgICAgdmFyIHgyID0gLXRoaXMuc2l6ZS53aWR0aCAqIDAuNTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSAtKHRoaXMuc2l6ZS5oZWlnaHQgKyBsaW5lTWFyZ2luKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgeSA9IGxpbmVNYXJnaW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICogQHBhcmFtIHsnbWlkZGxlJ3wnaGFuZ2luZyd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUxhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IFwibWlkZGxlXCI7XG5cbiAgICAgIHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMuc2l6ZS5sZWZ0ID0geCAtIHRoaXMuc2l6ZS53aWR0aCAqIDAuNTtcbiAgICAgIHRoaXMuc2l6ZS50b3AgPSB5IC0gdGhpcy5zaXplLmhlaWdodCAqIDAuNTtcbiAgICAgIHRoaXMuc2l6ZS55TGluZSA9IHkgKyAoMSAtIHRoaXMubGluZUNvdW50KSAqIDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcblxuICAgICAgaWYgKGJhc2VsaW5lID09PSBcImhhbmdpbmdcIikge1xuICAgICAgICB0aGlzLnNpemUudG9wICs9IDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5zaXplLnRvcCArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGUsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGhhbmdpbmcuIEhhbmdpbmcgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG5cbiAgICAgICAgdGhpcy5zaXplLnlMaW5lICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yLCBzaXplLCBmYWNlLCBtb2QsIHZhZGp1c3QsIHN0cm9rZVdpZHRoOiAqLCBzdHJva2VDb2xvcjogKCp8c3RyaW5nfGFsbE9wdGlvbnMuZWRnZXMuZm9udC5zdHJva2VDb2xvcnx7c3RyaW5nfXxhbGxPcHRpb25zLm5vZGVzLmZvbnQuc3Ryb2tlQ29sb3J8QXJyYXkpfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhjdHgsIHNlbGVjdGVkLCBob3ZlciwgbW9kKSB7XG4gICAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZShmb250T3B0aW9ucywgbW9kLCBvcHRpb24pIHtcbiAgICAgICAgaWYgKG1vZCA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIGlmIChvcHRpb24gPT09IFwibW9kXCIpIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvbnRPcHRpb25zW21vZF1bb3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gR3J1bWJsIGxlYXZpbmcgb3V0IHRlc3Qgb24gdW5kZWZpbmVkIGVxdWFscyBmYWxzZSBmb3IgXCJcIlxuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1ttb2RdW29wdGlvbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGFrZSBmcm9tIHBhcmVudCBmb250IG9wdGlvblxuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICBjb2xvcjogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcImNvbG9yXCIpLFxuICAgICAgICBzaXplOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwic2l6ZVwiKSxcbiAgICAgICAgZmFjZTogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcImZhY2VcIiksXG4gICAgICAgIG1vZDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcIm1vZFwiKSxcbiAgICAgICAgdmFkanVzdDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcInZhZGp1c3RcIiksXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmZvbnRPcHRpb25zLnN0cm9rZVdpZHRoLFxuICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5mb250T3B0aW9ucy5zdHJva2VDb2xvclxuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGVjdGVkIHx8IGhvdmVyKSB7XG4gICAgICAgIGlmIChtb2QgPT09IFwibm9ybWFsXCIgJiYgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSB0cnVlICYmIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkKSB7XG4gICAgICAgICAgdmFsdWVzLm1vZCA9IFwiYm9sZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udE9wdGlvbnMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMuZWxlbWVudE9wdGlvbnMuaWQsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250U3RyaW5nID0gXCJcIjtcblxuICAgICAgaWYgKHZhbHVlcy5tb2QgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubW9kICE9PSBcIlwiKSB7XG4gICAgICAgIC8vIHNhZmVndWFyZCBmb3IgdW5kZWZpbmVkIC0gdGhpcyBoYXBwZW5lZFxuICAgICAgICBmb250U3RyaW5nICs9IHZhbHVlcy5tb2QgKyBcIiBcIjtcbiAgICAgIH1cblxuICAgICAgZm9udFN0cmluZyArPSB2YWx1ZXMuc2l6ZSArIFwicHggXCIgKyB2YWx1ZXMuZmFjZTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZy5yZXBsYWNlKC9cIi9nLCBcIlwiKTtcbiAgICAgIHZhbHVlcy5mb250ID0gY3R4LmZvbnQ7XG4gICAgICB2YWx1ZXMuaGVpZ2h0ID0gdmFsdWVzLnNpemU7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaWZmZXJlbnRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCAhPT0gdGhpcy5zZWxlY3RlZFN0YXRlIHx8IGhvdmVyICE9PSB0aGlzLmhvdmVyU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXhwbG9kZXMgdGhlIHBhc3NlZCB0ZXh0IGludG8gbGluZXMgYW5kIGRldGVybWluZXMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpblRleHQgIHRoZSB0ZXh0IHRvIGV4cGxvZGVcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIGxpbmVzfXwqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0xhYmVsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0xhYmVsVGV4dChjdHgsIHNlbGVjdGVkLCBob3ZlciwgaW5UZXh0KSB7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgTGFiZWxTcGxpdHRlcihjdHgsIHRoaXMsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICByZXR1cm4gc3BsaXR0ZXIucHJvY2VzcyhpblRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGV4cGxvZGVzIHRoZSBsYWJlbCBzdHJpbmcgaW50byBsaW5lcyBhbmQgc2V0cyB0aGUgd2lkdGgsIGhlaWdodCBhbmQgbnVtYmVyIG9mIGxpbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubGFiZWxEaXJ0eSA9PT0gZmFsc2UgJiYgIXRoaXMuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsKTtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluV2R0ID4gMCAmJiBzdGF0ZS53aWR0aCA8IHRoaXMuZm9udE9wdGlvbnMubWluV2R0KSB7XG4gICAgICAgIHN0YXRlLndpZHRoID0gdGhpcy5mb250T3B0aW9ucy5taW5XZHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCA9IHN0YXRlLmhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluSGd0ID4gMCAmJiBzdGF0ZS5oZWlnaHQgPCB0aGlzLmZvbnRPcHRpb25zLm1pbkhndCkge1xuICAgICAgICBzdGF0ZS5oZWlnaHQgPSB0aGlzLmZvbnRPcHRpb25zLm1pbkhndDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5saW5lcyA9IHN0YXRlLmxpbmVzO1xuICAgICAgdGhpcy5saW5lQ291bnQgPSBzdGF0ZS5saW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLnNpemUud2lkdGggPSBzdGF0ZS53aWR0aDtcbiAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgICB0aGlzLnNlbGVjdGVkU3RhdGUgPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuaG92ZXJTdGF0ZSA9IGhvdmVyO1xuICAgICAgdGhpcy5sYWJlbERpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbGFiZWwgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBsYWJlbCB3aWxsIGJlIHNob3csIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aXNpYmxlKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZS53aWR0aCA9PT0gMCB8fCB0aGlzLnNpemUuaGVpZ2h0ID09PSAwIHx8IHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdGhpbmcgdG8gZGlzcGxheVxuICAgICAgfVxuXG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG5cbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUb28gc21hbGwgb3IgdG9vIGZhciBhd2F5IHRvIHNob3dcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VGb250U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRm9udFN0cmluZyhvdXRPcHRpb25zLCBpbk9wdGlvbnMpIHtcbiAgICAgIGlmICghaW5PcHRpb25zIHx8IHR5cGVvZiBpbk9wdGlvbnMgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBuZXdPcHRpb25zQXJyYXkgPSBpbk9wdGlvbnMuc3BsaXQoXCIgXCIpO1xuICAgICAgb3V0T3B0aW9ucy5zaXplID0gK25ld09wdGlvbnNBcnJheVswXS5yZXBsYWNlKFwicHhcIiwgXCJcIik7XG4gICAgICBvdXRPcHRpb25zLmZhY2UgPSBuZXdPcHRpb25zQXJyYXlbMV07XG4gICAgICBvdXRPcHRpb25zLmNvbG9yID0gbmV3T3B0aW9uc0FycmF5WzJdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhYmVsO1xufSgpO1xuXG4vKipcbiAqIFRoZSBCYXNlIGNsYXNzIGZvciBhbGwgTm9kZXMuXG4gKi9cbnZhciBOb2RlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUJhc2UpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFyZ2luID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGVCYXNlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0TWFyZ2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSkge1xuICAgICAgdGhpcy5tYXJnaW4gPSB7fTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgaWYgKF90eXBlb2YodGhpcy5vcHRpb25zLm1hcmdpbikgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW4udG9wO1xuICAgICAgICAgIHRoaXMubWFyZ2luLnJpZ2h0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5yaWdodDtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5ib3R0b20gPSB0aGlzLm9wdGlvbnMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ubGVmdCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFiZWxNb2R1bGUuYWRqdXN0U2l6ZXModGhpcy5tYXJnaW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdmFsdWVzLnNoYWRvd0NvbG9yO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHZhbHVlcy5zaGFkb3dTaXplO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHZhbHVlcy5zaGFkb3dYO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHZhbHVlcy5zaGFkb3dZO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVCb3JkZXJEYXNoZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGRhc2hlcyA9IHZhbHVlcy5ib3JkZXJEYXNoZXM7XG5cbiAgICAgICAgICBpZiAoZGFzaGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkYXNoZXMgPSBbNSwgMTVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgICAgdmFsdWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVCb3JkZXJEYXNoZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5ib3JkZXJEYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgICAgdmFsdWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgc2hhcGUgb2YgYSBub2RlIG5lZWRzIHRvIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmVlZHNSZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLnJlZnJlc2hOZWVkZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3QgbG9jYXRpb24gdG8gcmVzZXQgdGhpcyBtZW1iZXIuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHRoZSBjdXJyZW50IGxvZ2ljLCBpdCBpcyB0aGUgbW9zdCBjb252ZW5pZW50IG9uZS5cbiAgICAgICAgdGhpcy5yZWZyZXNoTmVlZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdENvbnRleHRGb3JEcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcykge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdmFsdWVzLmJvcmRlcldpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5jb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGVyZm9ybVN0cm9rZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB2YWx1ZXMuYm9yZGVyV2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTsgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cblxuICAgICAgY3R4LnNhdmUoKTsgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcblxuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcyk7IC8vZHJhdyB0aGUgYm9yZGVyXG5cbiAgICAgICAgY3R4LnN0cm9rZSgpOyAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcblxuICAgICAgICB0aGlzLmRpc2FibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwZXJmb3JtRmlsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJmb3JtRmlsbChjdHgsIHZhbHVlcykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZXMuY29sb3I7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpOyAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG5cbiAgICAgIGZpbGwoY3R4KS5jYWxsKGN0eCk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cblxuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLnBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEJvdW5kaW5nQm94TWFyZ2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb3VuZGluZ0JveE1hcmdpbihtYXJnaW4pIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCAtPSBtYXJnaW47XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCAtPSBtYXJnaW47XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArPSBtYXJnaW47XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ICs9IG1hcmdpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0dWFsIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAgICpcbiAgICAgKiBEb2luZyBpdCBsaWtlIHRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIG92ZXJyaWRlXG4gICAgICogaW4gdGhlIGNoaWxkIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBzdHViIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGltZW5zaW9ucyB0byB1c2UgZm9yIG5vZGVzIHdpdGggYW4gaW50ZXJuYWwgbGFiZWxcbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSwgdGhlc2UgYXJlOiBDaXJjbGUsIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgKiBUaGUgb3RoZXIgbm9kZXMgaGF2ZSBleHRlcm5hbCBsYWJlbHMsIGFuZCB3aWxsIG5vdCBjYWxsIHRoaXMgbWV0aG9kXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBsYWJlbCwgZGVjZW50IGRlZmF1bHQgdmFsdWVzIGFyZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREaW1lbnNpb25zRnJvbUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIC8vIE5PVEU6IHByZXZpb3VzbHkgJ3RleHRTaXplJyB3YXMgbm90IHB1dCBpbiAndGhpcycgZm9yIEVsbGlwc2VcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUgdGhlIGNvbnNlcXVlbmNlcy5cbiAgICAgIHRoaXMudGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMudGV4dFNpemUud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy50ZXh0U2l6ZS5oZWlnaHQ7XG4gICAgICB2YXIgREVGQVVMVF9TSVpFID0gMTQ7XG5cbiAgICAgIGlmICh3aWR0aCA9PT0gMCkge1xuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiB0aGVyZSBpcyBubyBsYWJlbCB0ZXh0IHNldFxuICAgICAgICB3aWR0aCA9IERFRkFVTFRfU0laRTsgLy8gdXNlIGEgZGVjZW50IGRlZmF1bHRcblxuICAgICAgICBoZWlnaHQgPSBERUZBVUxUX1NJWkU7IC8vIGlmIHdpZHRoIHplcm8sIHRoZW4gaGVpZ2h0IGFsc28gYWx3YXlzIHplcm9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZUJhc2U7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRzKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBCb3ggTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBCb3gkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhCb3gsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRzKEJveCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCb3gob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQm94LCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdSb3VuZFJlY3QoY3R4LCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdmFsdWVzLmJvcmRlclJhZGl1cyk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzOyAvLyBvbmx5IGVmZmVjdGl2ZSBmb3IgYm94XG5cbiAgICAgIHRoaXMuX2FkZEJvdW5kaW5nQm94TWFyZ2luKGJvcmRlclJhZGl1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCb3g7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBOT1RFOiBUaGlzIGlzIGEgYmFkIGJhc2UgY2xhc3NcbiAqXG4gKiBDaGlsZCBjbGFzc2VzIGFyZTpcbiAqXG4gKiAgIEltYWdlICAgICAgIC0gdXNlcyAqb25seSogaW1hZ2UgbWV0aG9kc1xuICogICBDaXJjbGUgICAgICAtIHVzZXMgKm9ubHkqIF9kcmF3UmF3Q2lyY2xlXG4gKiAgIENpcmNsZUltYWdlIC0gdXNlcyBhbGxcbiAqXG4gKiBUT0RPOiBSZWZhY3RvciwgbW92ZSBfZHJhd1Jhd0NpcmNsZSB0byBkaWZmZXJlbnQgbW9kdWxlLCBkZXJpdmUgQ2lyY2xlIGZyb20gTm9kZUJhc2VcbiAqICAgICAgIFJlbmFtZSB0aGlzIHRvIEltYWdlQmFzZVxuICogICAgICAgQ29uc29saWRhdGUgY29tbW9uIGNvZGUgaW4gSW1hZ2UgYW5kIENpcmNsZUltYWdlIHRvIGJhc2UgY2xhc3NcbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgQ2lyY2xlSW1hZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKENpcmNsZUltYWdlQmFzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHIoQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIENpcmNsZUltYWdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGVJbWFnZUJhc2UpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgIF90aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2ltYWdlT2JqXVxuICAgKiBAcGFyYW0ge29iamVjdH0gW2ltYWdlT2JqQWx0XVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDaXJjbGVJbWFnZUJhc2UsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghKGltYWdlT2JqID09PSB1bmRlZmluZWQgJiYgaW1hZ2VPYmpBbHQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbWFnZXMgZm9yIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoZSBpbWFnZXMgY2FuIGJlIHVwZGF0ZWQgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0dGluZyBvZiBvcHRpb25zO1xuICAgICAqIHRoZXJlZm9yZSwgdGhpcyBtZXRob2QgbmVlZHMgdG8gYmUgcmVlbnRyYW50LlxuICAgICAqXG4gICAgICogRm9yIGNvcnJlY3Qgd29ya2luZyBpbiBlcnJvciBjYXNlcywgaXQgaXMgbmVjZXNzYXJ5IHRvIHByb3Blcmx5IHNldFxuICAgICAqIGZpZWxkICdub2Rlcy5icm9rZW5JbWFnZScgaW4gdGhlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9iaiAgcmVxdWlyZWQ7IG1haW4gaW1hZ2UgdG8gc2hvdyBmb3IgdGhpcyBub2RlXG4gICAgICogQHBhcmFtIHtJbWFnZXx1bmRlZmluZWR9IGltYWdlT2JqQWx0IG9wdGlvbmFsOyBpbWFnZSB0byBzaG93IHdoZW4gbm9kZSBpcyBzZWxlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICAgIGlmIChpbWFnZU9iakFsdCAmJiB0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSBpbWFnZU9iakFsdDtcbiAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IGltYWdlT2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqO1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmpBbHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3Rpb24gYW5kIHN3aXRjaCBiZXR3ZWVuIHRoZSBiYXNlIGFuZCB0aGUgc2VsZWN0ZWQgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBEbyB0aGUgc3dpdGNoIG9ubHkgaWYgaW1hZ2VPYmpBbHQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCB2YWx1ZSBvZiBuZXcgc2VsZWN0ZWQgc3RhdGUgZm9yIGN1cnJlbnQgbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3dpdGNoSW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN3aXRjaEltYWdlcyhzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdGlvbl9jaGFuZ2VkID0gc2VsZWN0ZWQgJiYgIXRoaXMuc2VsZWN0ZWQgfHwgIXNlbGVjdGVkICYmIHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7IC8vIFJlbWVtYmVyIG5ldyBzZWxlY3Rpb25cblxuICAgICAgaWYgKHRoaXMuaW1hZ2VPYmpBbHQgIT09IHVuZGVmaW5lZCAmJiBzZWxlY3Rpb25fY2hhbmdlZCkge1xuICAgICAgICB2YXIgaW1hZ2VUbXAgPSB0aGlzLmltYWdlT2JqO1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gdGhpcy5pbWFnZU9iakFsdDtcbiAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IGltYWdlVG1wO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEltYWdlIFBhZGRpbmcgZnJvbSBub2RlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsbGVmdDogbnVtYmVyLGJvdHRvbTogbnVtYmVyLHJpZ2h0OiBudW1iZXJ9fSBpbWFnZSBwYWRkaW5nIGluc2lkZSB0aGlzIHNoYXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRJbWFnZVBhZGRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEltYWdlUGFkZGluZygpIHtcbiAgICAgIHZhciBpbWdQYWRkaW5nID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2VQYWRkaW5nKSB7XG4gICAgICAgIHZhciBvcHRJbWdQYWRkaW5nID0gdGhpcy5vcHRpb25zLmltYWdlUGFkZGluZztcblxuICAgICAgICBpZiAoX3R5cGVvZihvcHRJbWdQYWRkaW5nKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaW1nUGFkZGluZy50b3AgPSBvcHRJbWdQYWRkaW5nLnRvcDtcbiAgICAgICAgICBpbWdQYWRkaW5nLnJpZ2h0ID0gb3B0SW1nUGFkZGluZy5yaWdodDtcbiAgICAgICAgICBpbWdQYWRkaW5nLmJvdHRvbSA9IG9wdEltZ1BhZGRpbmcuYm90dG9tO1xuICAgICAgICAgIGltZ1BhZGRpbmcubGVmdCA9IG9wdEltZ1BhZGRpbmcubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWdQYWRkaW5nLnRvcCA9IG9wdEltZ1BhZGRpbmc7XG4gICAgICAgICAgaW1nUGFkZGluZy5yaWdodCA9IG9wdEltZ1BhZGRpbmc7XG4gICAgICAgICAgaW1nUGFkZGluZy5ib3R0b20gPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcubGVmdCA9IG9wdEltZ1BhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGltZ1BhZGRpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgbm9kZSBkaW1lbnNpb25zIGZvciBhIGxvYWRlZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIFByZTogdGhpcy5pbWFnZU9iaiBpcyB2YWxpZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZUltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVJbWFnZSgpIHtcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VJbWFnZVNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2l6ZSBwcm9wZXJ0eVxuICAgICAgICB2YXIgcmF0aW9fd2lkdGggPSAxO1xuICAgICAgICB2YXIgcmF0aW9faGVpZ2h0ID0gMTsgLy8gT25seSBjYWxjdWxhdGUgdGhlIHByb3BlciByYXRpbyBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgbm90IHplcm9cblxuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAmJiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoID4gdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJhdGlvX3dpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXRpb19oZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodCAvIHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgKiByYXRpb193aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW9faGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBpbWFnZSBzaXplIHdpdGggaW1hZ2UgcGFkZGluZ1xuICAgICAgICB2YXIgaW1nUGFkZGluZyA9IHRoaXMuX2dldEltYWdlUGFkZGluZygpO1xuXG4gICAgICAgIHdpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aCArIGltZ1BhZGRpbmcubGVmdCArIGltZ1BhZGRpbmcucmlnaHQ7XG4gICAgICAgIGhlaWdodCA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ICsgaW1nUGFkZGluZy50b3AgKyBpbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1Jhd0NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcykge1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcy5zaXplKTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3SW1hZ2VBdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAhPSAwKSB7XG4gICAgICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHZhbHVlcy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyB2YWx1ZXMub3BhY2l0eSA6IDE7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIHZhciBmYWN0b3IgPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmludGVycG9sYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBmYWN0b3IgPSB0aGlzLmltYWdlT2JqLndpZHRoIC8gdGhpcy53aWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltZ1BhZGRpbmcgPSB0aGlzLl9nZXRJbWFnZVBhZGRpbmcoKTtcblxuICAgICAgICB2YXIgaW1nUG9zTGVmdCA9IHRoaXMubGVmdCArIGltZ1BhZGRpbmcubGVmdDtcbiAgICAgICAgdmFyIGltZ1Bvc1RvcCA9IHRoaXMudG9wICsgaW1nUGFkZGluZy50b3A7XG4gICAgICAgIHZhciBpbWdXaWR0aCA9IHRoaXMud2lkdGggLSBpbWdQYWRkaW5nLmxlZnQgLSBpbWdQYWRkaW5nLnJpZ2h0O1xuICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSBpbWdQYWRkaW5nLnRvcCAtIGltZ1BhZGRpbmcuYm90dG9tO1xuICAgICAgICB0aGlzLmltYWdlT2JqLmRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCBmYWN0b3IsIGltZ1Bvc0xlZnQsIGltZ1Bvc1RvcCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ltYWdlTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUxhYmVsKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgIHZhciBsYWJlbERpbWVuc2lvbnMgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgICBpZiAobGFiZWxEaW1lbnNpb25zLmxpbmVDb3VudCA+PSAxKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGxhYmVsRGltZW5zaW9ucy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB5TGFiZWwgPSB5ICsgb2Zmc2V0O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsKSB7XG4gICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsIGhvdmVyLCBcImhhbmdpbmdcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmNsZUltYWdlQmFzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgQ2lyY2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cblxudmFyIENpcmNsZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhDaXJjbGUsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkcShDaXJjbGUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgZGlhbWV0ZXIgPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0LCBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyOyAvLyBOT1RFOiB0aGlzIHNpemUgZmllbGQgb25seSBzZXQgaGVyZSwgbm90IGluIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcblxuICAgICAgICB0aGlzLndpZHRoID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICB0aGlzLl9kcmF3UmF3Q2lyY2xlKGN0eCwgeCwgeSwgdmFsdWVzKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpZHRoICogMC41O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGU7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRwKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBDaXJjdWxhckltYWdlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cblxudmFyIENpcmN1bGFySW1hZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgX2luaGVyaXRzKENpcmN1bGFySW1hZ2UsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkcChDaXJjdWxhckltYWdlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIENpcmN1bGFySW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjdWxhckltYWdlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDaXJjdWxhckltYWdlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuICAgICAgdmFyIGltYWdlQWJzZW50ID0gdGhpcy5pbWFnZU9iai5zcmMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGltYWdlQWJzZW50KSB7XG4gICAgICAgIHZhciBkaWFtZXRlciA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgYW4gaW1hZ2UgaXMgcHJlc2VudCwgaS5lLiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkLlxuXG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5zd2l0Y2hJbWFnZXMoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHZhciBsYWJlbFggPSB4LFxuICAgICAgICAgIGxhYmVsWSA9IHk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICAgIGxhYmVsWCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgbGFiZWxZICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfSAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kIGNpcmNsZS4gSU1QT1JUQU5UOiB0aGUgc3Ryb2tlIGluIHRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIGNsaXAgbWV0aG9kIGJlbG93LlxuXG5cbiAgICAgIHRoaXMuX2RyYXdSYXdDaXJjbGUoY3R4LCBsYWJlbFgsIGxhYmVsWSwgdmFsdWVzKTsgLy8gbm93IHdlIGRyYXcgaW4gdGhlIGNpcmNsZSwgd2Ugc2F2ZSBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZSBjbGlwIG9wZXJhdGlvbiBhZnRlciBkcmF3aW5nLlxuXG5cbiAgICAgIGN0eC5zYXZlKCk7IC8vIGNsaXAgaXMgdXNlZCB0byB1c2UgdGhlIHN0cm9rZSBpbiBkcmF3UmF3Q2lyY2xlIGFzIGFuIGFyZWEgdGhhdCB3ZSBjYW4gZHJhdyBpbi5cblxuICAgICAgY3R4LmNsaXAoKTsgLy8gZHJhdyB0aGUgaW1hZ2VcblxuICAgICAgdGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcyk7IC8vIHJlc3RvcmUgc28gd2UgY2FuIGFnYWluIGRyYXcgb24gdGhlIGZ1bGwgY2FudmFzXG5cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGhpcy5fZHJhd0ltYWdlTGFiZWwoY3R4LCBsYWJlbFgsIGxhYmVsWSwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICB9IC8vIFRPRE86IGNvbXBhcmUgd2l0aCBDaXJjbGUudXBkYXRlQm91bmRpbmdCb3goKSwgY29uc29saWRhdGU/IE1vcmUgc3R1ZmYgaXMgaGFwcGVuaW5nIGhlcmVcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHg7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIH0gLy8gVE9ETzogY29tcGFyZSB3aXRoIEltYWdlLnVwZGF0ZUJvdW5kaW5nQm94KCksIGNvbnNvbGlkYXRlP1xuXG5cbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpZHRoICogMC41O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjdWxhckltYWdlO1xufShDaXJjbGVJbWFnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cnVjdGluZyBOb2RlL0NsdXN0ZXIgU2hhcGVzLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBTaGFwZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoU2hhcGVCYXNlLCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbyhTaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU2hhcGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlQmFzZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXM9e3NpemU6IHRoaXMub3B0aW9ucy5zaXplfV1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU2hhcGVCYXNlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge1xuICAgICAgICBzaXplOiB0aGlzLm9wdGlvbnMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIF90aGlzJGN1c3RvbVNpemVXaWR0aCwgX3RoaXMkY3VzdG9tU2l6ZUhlaWdoO1xuXG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IDIgKiB2YWx1ZXMuc2l6ZTtcbiAgICAgICAgdGhpcy53aWR0aCA9IChfdGhpcyRjdXN0b21TaXplV2lkdGggPSB0aGlzLmN1c3RvbVNpemVXaWR0aCkgIT09IG51bGwgJiYgX3RoaXMkY3VzdG9tU2l6ZVdpZHRoICE9PSB2b2lkIDAgPyBfdGhpcyRjdXN0b21TaXplV2lkdGggOiBzaXplO1xuICAgICAgICB0aGlzLmhlaWdodCA9IChfdGhpcyRjdXN0b21TaXplSGVpZ2ggPSB0aGlzLmN1c3RvbVNpemVIZWlnaHQpICE9PSBudWxsICYmIF90aGlzJGN1c3RvbVNpemVIZWlnaCAhPT0gdm9pZCAwID8gX3RoaXMkY3VzdG9tU2l6ZUhlaWdoIDogc2l6ZTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZU11bHRpcGxpZXIgLSBVbnVzZWQhIFRPRE86IFJlbW92ZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1NoYXBlKGN0eCwgc2hhcGUsIHNpemVNdWx0aXBsaWVyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBnZXRTaGFwZShzaGFwZSkoY3R4LCB4LCB5LCB2YWx1ZXMuc2l6ZSk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5mb250ID0gKHNlbGVjdGVkID8gXCJib2xkIFwiIDogXCJcIikgKyB0aGlzLmhlaWdodCAvIDIgKyBcInB4IFwiICsgKHRoaXMub3B0aW9ucy5pY29uLmZhY2UgfHwgXCJGb250QXdlc29tZVwiKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmljb24uY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbDogZnVuY3Rpb24gZHJhd0V4dGVybmFsTGFiZWwoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjYWxsIGZvbGxvd2luZyBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB2YWx1ZSBmb3JcbiAgICAgICAgICAgIC8vIGB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0YC5cbiAgICAgICAgICAgIF90aGlzLmxhYmVsTW9kdWxlLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgeCwgeSwgXCJoYW5naW5nXCIpO1xuXG4gICAgICAgICAgICB2YXIgeUxhYmVsID0geSArIDAuNSAqIF90aGlzLmhlaWdodCArIDAuNSAqIF90aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBfdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeUxhYmVsLCBzZWxlY3RlZCwgaG92ZXIsIFwiaGFuZ2luZ1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoYXBlQmFzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkNChvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gZmlsdGVyKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIF9jb250ZXh0LCBfY29udGV4dDI7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IGZvckVhY2gkMihfY29udGV4dCA9IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgITApKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IGZvckVhY2gkMihfY29udGV4dDIgPSBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQ2KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRuKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG4oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBDdXN0b21TaGFwZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBDdXN0b21TaGFwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoQ3VzdG9tU2hhcGUsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbihDdXN0b21TaGFwZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGN0eFJlbmRlcmVyXG4gICAqL1xuICBmdW5jdGlvbiBDdXN0b21TaGFwZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgY3R4UmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tU2hhcGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgY3R4UmVuZGVyZXIpO1xuICAgIF90aGlzLmN0eFJlbmRlcmVyID0gY3R4UmVuZGVyZXI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBkaWZmZXJlbnQgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDdXN0b21TaGFwZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyOyAvLyBHdWFyZCByaWdodCBhd2F5IGJlY2F1c2Ugc29tZW9uZSBtYXkganVzdCBkcmF3IGluIHRoZSBmdW5jdGlvbiBpdHNlbGYuXG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgZHJhd0xhdGVyID0gdGhpcy5jdHhSZW5kZXJlcih7XG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICBob3ZlcjogaG92ZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQkMyh7fSwgdmFsdWVzKSxcbiAgICAgICAgbGFiZWw6IHRoaXMub3B0aW9ucy5sYWJlbFxuICAgICAgfSk7IC8vIFJlbmRlciB0aGUgbm9kZSBzaGFwZSBiZWxsb3cgYXJyb3dzLlxuXG4gICAgICBpZiAoZHJhd0xhdGVyLmRyYXdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgZHJhd0xhdGVyLmRyYXdOb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwpIHtcbiAgICAgICAgLy8gR3VhcmQgdGhlIGV4dGVybmFsIGxhYmVsIChhYm92ZSBhcnJvd3MpIGRyYXdpbmcgZnVuY3Rpb24uXG4gICAgICAgIHZhciBkcmF3RXh0ZXJuYWxMYWJlbCA9IGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbDtcblxuICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbCgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5jdXN0b21TaXplV2lkdGggPSBkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuY3VzdG9tU2l6ZUhlaWdodCA9IGRyYXdMYXRlci5ub2RlRGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcmF3TGF0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1c3RvbVNoYXBlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgRGF0YWJhc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBEYXRhYmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhEYXRhYmFzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG0oRGF0YWJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YWJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YWJhc2UpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFiYXNlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBkcmF3RGF0YWJhc2UoY3R4LCB4IC0gdGhpcy53aWR0aCAvIDIsIHkgLSB0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHRoaXMudG9wICsgdGhpcy50ZXh0U2l6ZS5oZWlnaHQgLyAyICsgdGhpcy5tYXJnaW4udG9wLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhYmFzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgRGlhbW9uZCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBEaWFtb25kJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKERpYW1vbmQsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbChEaWFtb25kKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIERpYW1vbmQob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlhbW9uZCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEaWFtb25kLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwiZGlhbW9uZFwiLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpYW1vbmQ7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRrKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBEb3QgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgRG90ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhEb3QsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkayhEb3QpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRG90KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvdCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEb3QsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJjaXJjbGVcIiwgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERvdDtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGooRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBbSBFbGxpcHNlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgRWxsaXBzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhFbGxpcHNlLCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaihFbGxpcHNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEVsbGlwc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxsaXBzZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRWxsaXBzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKyBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBkcmF3RWxsaXBzZShjdHgsIHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGEgPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgdmFyIGIgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHZhciB3ID0gTWF0aC5zaW4oYW5nbGUpICogYTtcbiAgICAgIHZhciBoID0gTWF0aC5jb3MoYW5nbGUpICogYjtcbiAgICAgIHJldHVybiBhICogYiAvIE1hdGguc3FydCh3ICogdyArIGggKiBoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWxsaXBzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkaShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEFuIGljb24gcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIEljb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoSWNvbiwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGkoSWNvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBJY29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb24pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBVbnVzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSWNvbiwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5pY29uU2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpLFxuICAgICAgICAgIGhlaWdodDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmljb25TaXplLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaWNvblNpemUuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5vcHRpb25zLmljb24uc2l6ZSA9IHRoaXMub3B0aW9ucy5pY29uLnNpemUgfHwgNTA7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIHRoaXMuX2ljb24oY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRyYXdFeHRlcm5hbExhYmVsOiBmdW5jdGlvbiBkcmF3RXh0ZXJuYWxMYWJlbCgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG5cbiAgICAgICAgICAgIF90aGlzMi5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgX3RoaXMyLmxlZnQgKyBfdGhpczIuaWNvblNpemUud2lkdGggLyAyICsgX3RoaXMyLm1hcmdpbi5sZWZ0LCB5ICsgX3RoaXMyLmhlaWdodCAvIDIgKyBpY29uVGV4dFNwYWNpbmcsIHNlbGVjdGVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczIudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQgKyBpY29uVGV4dFNwYWNpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyIC0gVW51c2VkXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ljb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ljb24oY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdmFyIGljb25TaXplID0gTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb24uY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5mb250ID0gW3RoaXMub3B0aW9ucy5pY29uLndlaWdodCAhPSBudWxsID8gdGhpcy5vcHRpb25zLmljb24ud2VpZ2h0IDogc2VsZWN0ZWQgPyBcImJvbGRcIiA6IFwiXCIsIC8vIElmIHRoZSB3ZWlnaHQgaXMgZm9yY2VkIChmb3IgZXhhbXBsZSB0byBtYWtlIEZvbnQgQXdlc29tZSA1IHdvcmtcbiAgICAgICAgLy8gcHJvcGVybHkpIHN1YnN0aXR1dGUgc2xpZ2h0bHkgYmlnZ2VyIHNpemUgZm9yIGJvbGQgZm9udCBmYWNlLlxuICAgICAgICAodGhpcy5vcHRpb25zLmljb24ud2VpZ2h0ICE9IG51bGwgJiYgc2VsZWN0ZWQgPyA1IDogMCkgKyBpY29uU2l6ZSArIFwicHhcIiwgdGhpcy5vcHRpb25zLmljb24uZmFjZV0uam9pbihcIiBcIik7IC8vIGRyYXcgaWNvblxuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiV2hlbiB1c2luZyB0aGUgaWNvbiBzaGFwZSwgeW91IG5lZWQgdG8gZGVmaW5lIHRoZSBjb2RlIGluIHRoZSBpY29uIG9wdGlvbnMgb2JqZWN0LiBUaGlzIGNhbiBiZSBkb25lIHBlciBub2RlIG9yIGdsb2JhbGx5LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSWNvbjtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkaChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEFuIGltYWdlLWJhc2VkIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xuXG52YXIgSW1hZ2UkMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICBfaW5oZXJpdHMoSW1hZ2UsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaChJbWFnZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqQWx0XG4gICAqL1xuICBmdW5jdGlvbiBJbWFnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBVbnVzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgaW1hZ2VBYnNlbnQgPSB0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaW1hZ2VBYnNlbnQpIHtcbiAgICAgICAgdmFyIHNpZGUgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBzaWRlO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5zd2l0Y2hJbWFnZXMoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHZhciBsYWJlbFggPSB4LFxuICAgICAgICAgIGxhYmVsWSA9IHk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICAgIGxhYmVsWCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgbGFiZWxZICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VCb3JkZXJXaXRoSW1hZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgdmFyIGZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIGlmICh2YWx1ZXMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGUgPSBvdmVycmlkZU9wYWNpdHkoc3Ryb2tlU3R5bGUsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICBmaWxsU3R5bGUgPSBvdmVycmlkZU9wYWNpdHkoZmlsbFN0eWxlLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH0gLy8gc2V0dXAgdGhlIGxpbmUgcHJvcGVydGllcy5cblxuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlOyAvLyBzZXQgYSBmaWxsc3R5bGVcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlOyAvLyBkcmF3IGEgcmVjdGFuZ2xlIHRvIGZvcm0gdGhlIGJvcmRlciBhcm91bmQuIFRoaXMgcmVjdGFuZ2xlIGlzIGZpbGxlZCBzbyB0aGUgb3BhY2l0eSBvZiBhIHBpY3R1cmUgKGluIGZ1dHVyZSB2aXMgcmVsZWFzZXM/KSBjYW4gYmUgdXNlZCB0byB0aW50IHRoZSBpbWFnZVxuXG4gICAgICAgIGN0eC5yZWN0KHRoaXMubGVmdCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMudG9wIC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy53aWR0aCArIGN0eC5saW5lV2lkdGgsIHRoaXMuaGVpZ2h0ICsgY3R4LmxpbmVXaWR0aCk7XG5cbiAgICAgICAgZmlsbChjdHgpLmNhbGwoY3R4KTtcblxuICAgICAgICB0aGlzLnBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpO1xuXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIGxhYmVsWCwgbGFiZWxZLCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy50b3AgPSB5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3A7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlO1xufShDaXJjbGVJbWFnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgU3F1YXJlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIFNxdWFyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoU3F1YXJlLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGcoU3F1YXJlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFNxdWFyZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcXVhcmUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3F1YXJlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwic3F1YXJlXCIsIDIsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3F1YXJlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgSGV4YWdvbiBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBIZXhhZ29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhIZXhhZ29uLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGYoSGV4YWdvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBIZXhhZ29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhleGFnb24pO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSGV4YWdvbiwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcImhleGFnb25cIiwgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZXhhZ29uO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgU3RhciBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBTdGFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhTdGFyLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGUoU3Rhcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTdGFyKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3RhciwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInN0YXJcIiwgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGFyO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgdGV4dC1iYXNlZCByZXBsYWNlbWVudCBmb3IgdGhlIGRlZmF1bHQgTm9kZSBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgVGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhUZXh0LCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZChUZXh0KTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRleHQob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy50ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy50ZXh0U2l6ZS53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRleHRTaXplLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHRoaXMudG9wICsgdGhpcy50ZXh0U2l6ZS5oZWlnaHQgLyAyICsgdGhpcy5tYXJnaW4udG9wLCBzZWxlY3RlZCwgaG92ZXIpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHQ7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIFRyaWFuZ2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIFRyaWFuZ2xlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKFRyaWFuZ2xlLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGMoVHJpYW5nbGUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJpYW5nbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJpYW5nbGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhUcmlhbmdsZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInRyaWFuZ2xlXCIsIDMsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJpYW5nbGU7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRiKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBkb3dud2FyZCBmYWNpbmcgVHJpYW5nbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgVHJpYW5nbGVEb3duID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhUcmlhbmdsZURvd24sIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYihUcmlhbmdsZURvd24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJpYW5nbGVEb3duKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlRG93bik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlRG93biwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInRyaWFuZ2xlRG93blwiLCAzLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyaWFuZ2xlRG93bjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDQob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IGZpbHRlcihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBfY29udGV4dDUsIF9jb250ZXh0NjsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gZm9yRWFjaCQyKF9jb250ZXh0NSA9IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgITApKS5jYWxsKF9jb250ZXh0NSwgZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBmb3JFYWNoJDIoX2NvbnRleHQ2ID0gb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDYsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXG4gKiBBIG5vZGUuIEEgbm9kZSBjYW4gYmUgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzIHZpYSBvbmUgb3IgbXVsdGlwbGUgZWRnZXMuXG4gKi9cblxudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgdGhlIG5vZGUuIEFsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFyZSBvcHRpb25hbCwgZXhjZXB0IGZvciB0aGUgaWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gaWQgICAgIElkIG9mIHRoZSBub2RlLiBSZXF1aXJlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxhYmVsICBUZXh0IGxhYmVsIGZvciB0aGUgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IHggICAgICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geSAgICAgIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gc2hhcGUgIE5vZGUgc2hhcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBpbWFnZSAgQW4gaW1hZ2UgdXJsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gdGl0bGUgIEEgdGl0bGUgdGV4dCwgY2FuIGJlIEhUTUxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YW55dHlwZX0gZ3JvdXAgQSBncm91cCBuYW1lIG9yIG51bWJlclxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keSAgICAgICAgICAgICAgIFNoYXJlZCBzdGF0ZSBvZiBjdXJyZW50IG5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkltYWdlc30gaW1hZ2VsaXN0ICBBIGxpc3Qgd2l0aCBpbWFnZXMuIE9ubHkgbmVlZGVkIHdoZW4gdGhlIG5vZGUgaGFzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7R3JvdXBzfSBncm91cGxpc3QgICAgICAgICAgQSBsaXN0IHdpdGggZ3JvdXBzLiBOZWVkZWQgZm9yIHJldHJpZXZpbmcgZ3JvdXAgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9ucyAgICAgIEN1cnJlbnQgZ2xvYmFsIG5vZGUgb3B0aW9uczsgdGhlc2Ugc2VydmUgYXMgZGVmYXVsdHMgZm9yIHRoZSBub2RlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyAgICAgR2xvYmFsIGRlZmF1bHQgb3B0aW9ucyBmb3Igbm9kZXM7IG5vdGUgdGhhdCB0aGlzIGlzIGFsc28gdGhlIHByb3RvdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBwYXJhbWV0ZXIgYGdsb2JhbE9wdGlvbnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZShvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmVkZ2VzID0gW107IC8vIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlXG4gICAgLy8gc2V0IGRlZmF1bHRzIGZvciB0aGUgb3B0aW9uc1xuXG4gICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmltYWdlbGlzdCA9IGltYWdlbGlzdDtcbiAgICB0aGlzLmdyb3VwbGlzdCA9IGdyb3VwbGlzdDsgLy8gc3RhdGUgb3B0aW9uc1xuXG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2VTaXplID0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLm9wdGlvbnMuZm9udC5zaXplO1xuICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7IC8vIHVzZWQgdG8gY2hlY2sgaWYgaW5pdGlhbCBmaXQgc2hvdWxkIGp1c3QgdGFrZSB0aGUgcmFuZ2Ugb3IgYXBwcm94aW1hdGVcblxuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IG5ldyBMYWJlbCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucywgZmFsc2VcbiAgICAvKiBOb3QgZWRnZSBsYWJlbCAqL1xuICAgICk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggYSBlZGdlIHRvIHRoZSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJhdHRhY2hFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEVkZ2UoZWRnZSkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICBpZiAoaW5kZXhPZihfY29udGV4dCA9IHRoaXMuZWRnZXMpLmNhbGwoX2NvbnRleHQsIGVkZ2UpID09PSAtMSkge1xuICAgICAgICB0aGlzLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGFjaCBhIGVkZ2UgZnJvbSB0aGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXRhY2hFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEVkZ2UoZWRnZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihfY29udGV4dDIgPSB0aGlzLmVkZ2VzKS5jYWxsKF9jb250ZXh0MiwgZWRnZSk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgIHNwbGljZSQxKF9jb250ZXh0MyA9IHRoaXMuZWRnZXMpLmNhbGwoX2NvbnRleHQzLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjdXJyZW50U2hhcGUgPSB0aGlzLm9wdGlvbnMuc2hhcGU7XG5cbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm47IC8vIE5vdGUgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgJ3VuZGVmaW5lZCchIFRoaXMgaXMgT0suXG4gICAgICB9IC8vIFNhdmUgdGhlIGNvbG9yIGZvciBsYXRlci5cbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIHByZXZlbnQgbG9jYWwgY29sb3IgZnJvbSBiZWluZyBvdmVyd3JpdHRlbiBieSBncm91cCBjb2xvci5cbiAgICAgIC8vIFRPRE86IFRvIHByZXZlbnQgc3VjaCB3b3JrYXJvdW5kcyB0aGUgd2F5IG9wdGlvbnMgYXJlIGhhbmRsZWQgc2hvdWxkIGJlIHJld3JpdHRlbiBmcm9tIHNjcmF0Y2guXG4gICAgICAvLyBUaGlzIGlzIG5vdCB0aGUgb25seSBwcm9ibGVtIHdpdGggY3VycmVudCBvcHRpb25zIGhhbmRsaW5nLlxuXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLl9sb2NhbENvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICAgIH0gLy8gYmFzaWMgb3B0aW9uc1xuXG5cbiAgICAgIGlmIChvcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBtdXN0IGhhdmUgYW4gaWRcIik7XG4gICAgICB9XG5cbiAgICAgIE5vZGUuY2hlY2tNYXNzKG9wdGlvbnMsIHRoaXMuaWQpOyAvLyBzZXQgdGhlc2Ugb3B0aW9ucyBsb2NhbGx5XG4gICAgICAvLyBjbGVhciB4IGFuZCB5IHBvc2l0aW9uc1xuXG4gICAgICBpZiAob3B0aW9ucy54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueCA9IF9wYXJzZUludChvcHRpb25zLngpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueSA9IF9wYXJzZUludChvcHRpb25zLnkpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnZhbHVlID0gX3BhcnNlRmxvYXQob3B0aW9ucy52YWx1ZSk7XG4gICAgICB9IC8vIHRoaXMgdHJhbnNmb3JtcyBhbGwgc2hvcnRoYW5kcyBpbnRvIGZ1bGx5IGRlZmluZWQgb3B0aW9uc1xuXG5cbiAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zLCB0aGlzLmdyb3VwbGlzdCk7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnNdO1xuICAgICAgdGhpcy5jaG9vc2VyID0gY2hvb3NpZnkoXCJub2RlXCIsIHBpbGUpO1xuXG4gICAgICB0aGlzLl9sb2FkX2ltYWdlcygpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpOyAvLyBOZWVkIHRvIHNldCBsb2NhbCBvcGFjaXR5IGFmdGVyIGB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO2AgYmVjYXVzZSBgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTtgIG92ZXJyaXRlcyBsb2NhbCBvcGFjaXR5IHdpdGggZ3JvdXAgb3BhY2l0eVxuXG4gICAgICBpZiAob3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgTm9kZS5jaGVja09wYWNpdHkob3B0aW9ucy5vcGFjaXR5KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpO1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGltYWdlcyBmcm9tIHRoZSBvcHRpb25zLCBmb3IgdGhlIG5vZGVzIHRoYXQgbmVlZCB0aGVtLlxuICAgICAqXG4gICAgICogSW1hZ2VzIGFyZSBhbHdheXMgbG9hZGVkLCBldmVuIGlmIHRoZXkgYXJlIG5vdCB1c2VkIGluIHRoZSBjdXJyZW50IHNoYXBlLlxuICAgICAqIFRoZSB1c2VyIG1heSBzd2l0Y2ggdG8gYW4gaW1hZ2Ugc2hhcGUgbGF0ZXIgb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRfaW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkX2ltYWdlcygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGUgPT09IFwiY2lyY3VsYXJJbWFnZVwiIHx8IHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbiBpbWFnZSBtdXN0IGJlIGRlZmluZWQgZm9yIG5vZGUgdHlwZSAnXCIgKyB0aGlzLm9wdGlvbnMuc2hhcGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW1hZ2VsaXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgRXJyb3I6IE5vIGltYWdlcyBwcm92aWRlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1bnNlbGVjdGVkIGltYWdlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLnVuc2VsZWN0ZWQsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLnNlbGVjdGVkLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBvcGFjaXR5IGlzIG9ubHkgYmV0d2VlbiAwIGFuZCAxXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tjb2xvcjogKiwgYm9yZGVyV2lkdGg6ICosIGJvcmRlckNvbG9yOiAqLCBzaXplOiAqLCBib3JkZXJEYXNoZXM6IChib29sZWFufEFycmF5fGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlc3x7Ym9vbGVhbiwgYXJyYXl9KSwgYm9yZGVyUmFkaXVzOiAobnVtYmVyfGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1c3x7bnVtYmVyfXxBcnJheSksIHNoYWRvdzogKiwgc2hhZG93Q29sb3I6ICosIHNoYWRvd1NpemU6ICosIHNoYWRvd1g6ICosIHNoYWRvd1k6ICp9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoKSB7XG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICBjb2xvcjogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5vcGFjaXR5LFxuICAgICAgICBib3JkZXJXaWR0aDogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcixcbiAgICAgICAgc2l6ZTogdGhpcy5vcHRpb25zLnNpemUsXG4gICAgICAgIGJvcmRlckRhc2hlczogdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMsXG4gICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXMsXG4gICAgICAgIHNoYWRvdzogdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLFxuICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixcbiAgICAgICAgc2hhZG93U2l6ZTogdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplLFxuICAgICAgICBzaGFkb3dYOiB0aGlzLm9wdGlvbnMuc2hhZG93LngsXG4gICAgICAgIHNoYWRvd1k6IHRoaXMub3B0aW9ucy5zaGFkb3cueVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgfHwgdGhpcy5ob3Zlcikge1xuICAgICAgICBpZiAodGhpcy5jaG9vc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWVzLmJvcmRlcldpZHRoICo9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG92ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMub3B0aW9ucy5pZCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG5cbiAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IgfHwgdmFsdWVzLnNoYWRvd1NpemUgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSB8fCB2YWx1ZXMuc2hhZG93WCAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy54IHx8IHZhbHVlcy5zaGFkb3dZICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnkpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICB2YWx1ZXMuYm9yZGVyQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmJvcmRlckNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgdmFsdWVzLmNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5jb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIHZhbHVlcy5zaGFkb3dDb2xvciA9IG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuc2hhZG93Q29sb3IsIG9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVMYWJlbE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmxhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sYWJlbCA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIE5vZGUudXBkYXRlR3JvdXBPcHRpb25zKHRoaXMub3B0aW9ucywgX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIGNvbG9yOiBvcHRpb25zICYmIG9wdGlvbnMuY29sb3IgfHwgdGhpcy5fbG9jYWxDb2xvciB8fCB1bmRlZmluZWRcbiAgICAgIH0pLCB0aGlzLmdyb3VwbGlzdCk7IC8vXG4gICAgICAvLyBOb3RlOlRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIHRoaXMub3B0aW9ucyBpczpcbiAgICAgIC8vXG4gICAgICAvLyB0aGlzLm9wdGlvbnMgLT4gICAgTm9kZXNIYW5kbGVyLm9wdGlvbnMgICAgLT4gTm9kZXNIYW5kbGVyLmRlZmF1bHRPcHRpb25zXG4gICAgICAvLyAgICAgICAgICAgICAgICAgKGFsc286IHRoaXMuZ2xvYmFsT3B0aW9ucylcbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgdGhlIHByb3RvdHlwZXMgYXJlIG1lbnRpb25lZCBleHBsaWNpdGx5IGluIHRoZSBwaWxlIGxpc3QgYmVsb3c7XG4gICAgICAvLyBXRSBET04nVCBXQU5UIFRIRSBPUkRFUiBPRiBUSEUgUFJPVE9UWVBFUyEhISEgQXQgbGVhc3QsIG5vdCBmb3IgZm9udCBoYW5kbGluZyBvZiBsYWJlbHMuXG4gICAgICAvLyBUaGlzIGlzIGEgZ29vZCBpbmRpY2F0aW9uIHRoYXQgdGhlIHByb3RvdHlwZSB1c2FnZSBvZiBvcHRpb25zIGlzIGRlZmljaWVudC5cbiAgICAgIC8vXG5cbiAgICAgIHZhciBjdXJyZW50R3JvdXAgPSB0aGlzLmdyb3VwbGlzdC5nZXQodGhpcy5vcHRpb25zLmdyb3VwLCBmYWxzZSk7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCAvLyBuZXcgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zLCAvLyBjdXJyZW50IG5vZGUgb3B0aW9ucywgc2VlIGNvbW1lbnQgYWJvdmUgZm9yIHByb3RvdHlwZVxuICAgICAgY3VycmVudEdyb3VwLCAvLyBncm91cCBvcHRpb25zLCBpZiBhbnlcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucywgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgbm9kZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zIC8vIERlZmF1bHQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgXTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucywgcGlsZSk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50U2hhcGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNoYXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSkge1xuICAgICAgaWYgKGN1cnJlbnRTaGFwZSA9PT0gdGhpcy5vcHRpb25zLnNoYXBlICYmIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaG9vc2UgZHJhdyBtZXRob2QgZGVwZW5kaW5nIG9uIHRoZSBzaGFwZVxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgIGNhc2UgXCJib3hcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQm94JDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IENpcmNsZSQxKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNpcmN1bGFySW1hZ2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ2lyY3VsYXJJbWFnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJjdXN0b21cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ3VzdG9tU2hhcGUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMub3B0aW9ucy5jdHhSZW5kZXJlcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJkYXRhYmFzZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEYXRhYmFzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERpYW1vbmQkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJkb3RcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRG90KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRWxsaXBzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJpY29uXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEljb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgSW1hZ2UkMih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgU3F1YXJlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImhleGFnb25cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgSGV4YWdvbih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJzdGFyXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN0YXIodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUZXh0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRyaWFuZ2xlJDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidHJpYW5nbGVEb3duXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRyaWFuZ2xlRG93bih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEVsbGlwc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2VsZWN0IHRoaXMgbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdW5zZWxlY3QgdGhpcyBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmVlZHNSZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBjYWxjdWxhdGVkIHNpemUgb2YgdGhlIG5vZGUsIGZvcmNlcyBpdCB0byByZWNhbGN1bGF0ZSBpdHMgc2l6ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmVlZHNSZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuc2hhcGUucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdGl0bGUgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGl0bGUgICAgVGhlIHRpdGxlIG9mIHRoZSBub2RlLCBvciB1bmRlZmluZWQgd2hlbiBubyB0aXRsZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvIHRoZSBib3JkZXIgb2YgdGhlIE5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAgICAgICAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlICAgRGlzdGFuY2UgdG8gdGhlIGJvcmRlciBpbiBwaXhlbHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG5vZGUgaGFzIGEgZml4ZWQgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgdHJ1ZSBpZiBmaXhlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0ZpeGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRml4ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpeGVkLnggJiYgdGhpcy5vcHRpb25zLmZpeGVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIG5vZGUuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICogQHJldHVybnMge3JlY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxNb2R1bGUuc2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIHZhbHVlIHJhbmdlIG9mIHRoZSBub2RlLiBUaGUgbm9kZSB3aWxsIGFkanVzdCBpdCdzIHNpemVcbiAgICAgKiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIHZhciBzaXplRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBmb250RGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluICsgc2NhbGUgKiBmb250RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiBzaXplRGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5iYXNlU2l6ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBub2RlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5kcmF3KGN0eCwgdGhpcy54LCB0aGlzLnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcykgfHwge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBzaGFwZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgIHRoaXMuc2hhcGUudXBkYXRlQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIGN0eCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoaXMgbm9kZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICB0aGlzLnNoYXBlLnJlc2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbGwgdmlzdWFsIGVsZW1lbnRzIG9mIHRoaXMgbm9kZSBpbnN0YW5jZSwgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgICogcG9pbnQgZmFsbHMgd2l0aGluIHRoZSBib3VuZGluZyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge0FycmF5Ljxub2RlQ2xpY2tJdGVtfG5vZGVMYWJlbENsaWNrSXRlbT59IGxpc3Qgd2l0aCB0aGUgaXRlbXMgd2hpY2ggYXJlIG9uIHRoZSBwb2ludFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SXRlbXNPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1zT25Qb2ludChwb2ludCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICBub2RlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBsYWJlbElkOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50SW5SZWN0KHRoaXMuc2hhcGUuYm91bmRpbmdCb3gsIHBvaW50KSkge1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgbm9kZUlkOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogICBhbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmxlZnQgKyB0aGlzLnNoYXBlLndpZHRoID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUudG9wICsgdGhpcy5zaGFwZS5oZWlnaHQgPiBvYmoudG9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogICBhbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQgPCBvYmoucmlnaHQgJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCA+IG9iai5sZWZ0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gudG9wIDwgb2JqLmJvdHRvbSAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSA+IG9iai50b3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkIHZhbHVlcyBmb3IgbWFzc1xuICAgICAqXG4gICAgICogVGhlIG1hc3MgbWF5IG5vdCBiZSBuZWdhdGl2ZSBvciB6ZXJvLiBJZiBpdCBpcywgcmVzZXQgdG8gMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGlkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogXCJjaGVja09wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgIHJldHVybiAwIDw9IG9wYWNpdHkgJiYgb3BhY2l0eSA8PSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IG9yaWdpbiBpcyAnY2VudGVyJyBvciAndG9wLWxlZnQnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0Nvb3JkaW5hdGVPcmlnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDb29yZGluYXRlT3JpZ2luKG9yaWdpbikge1xuICAgICAgcmV0dXJuIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8IG9yaWdpbiA9PT0gXCJjZW50ZXJcIiB8fCBvcmlnaW4gPT09IFwidG9wLWxlZnRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29weSBncm91cCBvcHRpb24gdmFsdWVzIGludG8gdGhlIG5vZGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBncm91cCBvcHRpb25zIG92ZXJyaWRlIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zLCBzbyB0aGUgY29weSBvZiBncm91cCBvcHRpb25zXG4gICAgICogIG11c3QgaGFwcGVuICphZnRlciogdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG11c3QgYWxzbyBiZSBjYWxsZWQgYWxzbyBpZiB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucyBoYXZlIGNoYW5nZWQgYW5kIHRoZSBncm91cCBvcHRpb25zIGRpZCBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zICBuZXcgdmFsdWVzIGZvciB0aGUgb3B0aW9ucywgY3VycmVudGx5IG9ubHkgcGFzc2VkIGluIGZvciBjaGVja1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBncm91cExpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUdyb3VwT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVHcm91cE9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgZ3JvdXBMaXN0KSB7XG4gICAgICB2YXIgX2NvbnRleHQ0O1xuXG4gICAgICBpZiAoZ3JvdXBMaXN0ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gTm8gZ3JvdXBzLCBub3RoaW5nIHRvIGRvXG5cbiAgICAgIHZhciBncm91cCA9IHBhcmVudE9wdGlvbnMuZ3JvdXA7IC8vIHBhcmFub2lhOiB0aGUgc2VsZWN0ZWQgZ3JvdXAgaXMgYWxyZWFkeSBtZXJnZWQgaW50byBub2RlIG9wdGlvbnMsIGNoZWNrLlxuXG4gICAgICBpZiAobmV3T3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZ3JvdXAgIT09IHVuZGVmaW5lZCAmJiBncm91cCAhPT0gbmV3T3B0aW9ucy5ncm91cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cGRhdGVHcm91cE9wdGlvbnM6IGdyb3VwIHZhbHVlcyBpbiBvcHRpb25zIGRvbid0IG1hdGNoLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0dyb3VwID0gdHlwZW9mIGdyb3VwID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBncm91cCA9PT0gXCJzdHJpbmdcIiAmJiBncm91cCAhPSBcIlwiO1xuICAgICAgaWYgKCFoYXNHcm91cCkgcmV0dXJuOyAvLyBjdXJyZW50IG5vZGUgaGFzIG5vIGdyb3VwLCBubyBuZWVkIHRvIG1lcmdlXG5cbiAgICAgIHZhciBncm91cE9iaiA9IGdyb3VwTGlzdC5nZXQoZ3JvdXApO1xuXG4gICAgICBpZiAoZ3JvdXBPYmoub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTm9kZS5jaGVja09wYWNpdHkoZ3JvdXBPYmoub3BhY2l0eSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIGdyb3VwT2JqLm9wYWNpdHkpO1xuICAgICAgICAgIGdyb3VwT2JqLm9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gU2tpcCBhbnkgbmV3IG9wdGlvbiB0byBhdm9pZCB0aGVtIGJlaW5nIG92ZXJyaWRkZW4gYnkgdGhlIGdyb3VwIG9wdGlvbnMuXG5cblxuICAgICAgdmFyIHNraXBQcm9wZXJ0aWVzID0gZmlsdGVyKF9jb250ZXh0NCA9IGdldE93blByb3BlcnR5TmFtZXMobmV3T3B0aW9ucykpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gbmV3T3B0aW9uc1twXSAhPSBudWxsO1xuICAgICAgfSk7IC8vIEFsd2F5cyBza2lwIG1lcmdpbmcgZ3JvdXAgZm9udCBvcHRpb25zIGludG8gcGFyZW50OyB0aGVzZSBhcmUgcmVxdWlyZWQgdG8gYmUgZGlzdGluY3QgZm9yIGxhYmVsc1xuXG5cbiAgICAgIHNraXBQcm9wZXJ0aWVzLnB1c2goXCJmb250XCIpO1xuICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChza2lwUHJvcGVydGllcywgcGFyZW50T3B0aW9ucywgZ3JvdXBPYmopOyAvLyB0aGUgY29sb3Igb2JqZWN0IG5lZWRzIHRvIGJlIGNvbXBsZXRlbHkgZGVmaW5lZC5cbiAgICAgIC8vIFNpbmNlIGdyb3VwcyBjYW4gcGFydGlhbGx5IG92ZXJ3cml0ZSB0aGUgY29sb3JzLCB3ZSBwYXJzZSBpdCBhZ2FpbiwganVzdCBpbiBjYXNlLlxuXG4gICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gcGFyc2VDb2xvcihwYXJlbnRPcHRpb25zLmNvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9jZXNzIGFsbCBwb3NzaWJsZSBzaG9ydGhhbmRzIGluIHRoZSBuZXcgb3B0aW9ucyBhbmQgbWFrZXMgc3VyZSB0aGF0IHRoZSBwYXJlbnRPcHRpb25zIGFyZSBmdWxseSBkZWZpbmVkLlxuICAgICAqIFN0YXRpYyBzbyBpdCBjYW4gYWxzbyBiZSB1c2VkIGJ5IHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtnbG9iYWxPcHRpb25zPXt9XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZ3JvdXBMaXN0XVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucykge1xuICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIGdyb3VwTGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGZpZWxkcyA9IFtcImNvbG9yXCIsIFwiZml4ZWRcIiwgXCJzaGFkb3dcIl07XG4gICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7XG4gICAgICBOb2RlLmNoZWNrTWFzcyhuZXdPcHRpb25zKTtcblxuICAgICAgaWYgKHBhcmVudE9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTm9kZS5jaGVja09wYWNpdHkocGFyZW50T3B0aW9ucy5vcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiICsgcGFyZW50T3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLm9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTm9kZS5jaGVja09wYWNpdHkobmV3T3B0aW9ucy5vcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiICsgbmV3T3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICBuZXdPcHRpb25zLm9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzICYmICFOb2RlLmNoZWNrQ29vcmRpbmF0ZU9yaWdpbihuZXdPcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgY29vcmRpbmF0ZU9yaWdpbiwgZm91bmQ6IFwiICsgbmV3T3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbik7XG4gICAgICB9IC8vIG1lcmdlIHRoZSBzaGFkb3cgb3B0aW9ucyBpbnRvIHRoZSBwYXJlbnQuXG5cblxuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwic2hhZG93XCIsIGdsb2JhbE9wdGlvbnMpOyAvLyBpbmRpdmlkdWFsIHNoYXBlIG5ld09wdGlvbnNcblxuICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwYXJzZWRDb2xvciA9IHBhcnNlQ29sb3IobmV3T3B0aW9ucy5jb2xvcik7XG4gICAgICAgIGZpbGxJZkRlZmluZWQocGFyZW50T3B0aW9ucy5jb2xvciwgcGFyc2VkQ29sb3IpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmNvbG9yKTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH0gLy8gaGFuZGxlIHRoZSBmaXhlZCBvcHRpb25zXG5cblxuICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmZpeGVkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5maXhlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQueCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkLnggPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQueSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkLnkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnkgPSBuZXdPcHRpb25zLmZpeGVkLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgTm9kZS51cGRhdGVHcm91cE9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgZ3JvdXBMaXN0KTsgLy8gaGFuZGxlIHRoZSBzY2FsaW5nIG9wdGlvbnMsIHNwZWNpZmljYWxseSB0aGUgbGFiZWwgcGFydFxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuc2NhbGluZywgbmV3T3B0aW9ucy5zY2FsaW5nLCBcImxhYmVsXCIsIGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrTWFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja01hc3Mob3B0aW9ucywgaWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLm1hc3MgPD0gMCkge1xuICAgICAgICB2YXIgc3RySWQgPSBcIlwiO1xuXG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RySWQgPSBcIiBpbiBub2RlIGlkOiBcIiArIGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5lcnJvcihcIiVjTmVnYXRpdmUgb3IgemVybyBtYXNzIGRpc2FsbG93ZWRcIiArIHN0cklkICsgXCIsIHNldHRpbmcgbWFzcyB0byAxLlwiLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUpO1xuICAgICAgICBvcHRpb25zLm1hc3MgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobywgbWluTGVuKSB7IHZhciBfY29udGV4dDQ7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQ0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0NCwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ2KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBIYW5kbGVyIGZvciBOb2Rlc1xuICovXG5cbnZhciBOb2Rlc0hhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtJbWFnZXN9IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKiBAcGFyYW0ge0xheW91dEVuZ2luZX0gbGF5b3V0RW5naW5lXG4gICAqL1xuICBmdW5jdGlvbiBOb2Rlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMsIGxheW91dEVuZ2luZSkge1xuICAgIHZhciBfY29udGV4dCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVzSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgIHRoaXMubGF5b3V0RW5naW5lID0gbGF5b3V0RW5naW5lOyAvLyBjcmVhdGUgdGhlIG5vZGUgQVBJIGluIHRoZSBib2R5IGNvbnRhaW5lclxuXG4gICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlID0gYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5jcmVhdGUpLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgIHRoaXMubm9kZXNMaXN0ZW5lcnMgPSB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLmFkZChwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlKHBhcmFtcy5pdGVtcywgcGFyYW1zLmRhdGEsIHBhcmFtcy5vbGREYXRhKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgYnJva2VuSW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzk3QzJGQ1wiLFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICAgIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3BhY2l0eTogdW5kZWZpbmVkLFxuICAgICAgLy8gbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgZml4ZWQ6IHtcbiAgICAgICAgeDogZmFsc2UsXG4gICAgICAgIHk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogXCIjMzQzNDM0XCIsXG4gICAgICAgIHNpemU6IDE0LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiBcImFyaWFsXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgc3Ryb2tlQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgdmFkanVzdDogMCxcbiAgICAgICAgbXVsdGk6IGZhbHNlLFxuICAgICAgICBib2xkOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGRcIlxuICAgICAgICB9LFxuICAgICAgICBib2xkaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJib2xkIGl0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgbW9ubzoge1xuICAgICAgICAgIG1vZDogXCJcIixcbiAgICAgICAgICBzaXplOiAxNSxcbiAgICAgICAgICAvLyBweFxuICAgICAgICAgIGZhY2U6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgICAgdmFkanVzdDogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ3JvdXA6IHVuZGVmaW5lZCxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBpY29uOiB7XG4gICAgICAgIGZhY2U6IFwiRm9udEF3ZXNvbWVcIixcbiAgICAgICAgLy8nRm9udEF3ZXNvbWUnLFxuICAgICAgICBjb2RlOiB1bmRlZmluZWQsXG4gICAgICAgIC8vJ1xcdWYwMDcnLFxuICAgICAgICBzaXplOiA1MCxcbiAgICAgICAgLy81MCxcbiAgICAgICAgY29sb3I6IFwiIzJCN0NFOVwiIC8vJyNhYTAwZmYnXG5cbiAgICAgIH0sXG4gICAgICBpbWFnZTogdW5kZWZpbmVkLFxuICAgICAgLy8gLS0+IFVSTFxuICAgICAgaW1hZ2VQYWRkaW5nOiB7XG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIHNoYXBlXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBsZXZlbDogdW5kZWZpbmVkLFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIHRvcDogNSxcbiAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgIGJvdHRvbTogNSxcbiAgICAgICAgbGVmdDogNVxuICAgICAgfSxcbiAgICAgIG1hc3M6IDEsXG4gICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgc2NhbGluZzoge1xuICAgICAgICBtaW46IDEwLFxuICAgICAgICBtYXg6IDMwLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB4OiA1LFxuICAgICAgICB5OiA1XG4gICAgICB9LFxuICAgICAgc2hhcGU6IFwiZWxsaXBzZVwiLFxuICAgICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICAgIC8vIG9ubHkgZm9yIGJvcmRlcnNcbiAgICAgICAgYm9yZGVyUmFkaXVzOiA2LFxuICAgICAgICAvLyBvbmx5IGZvciBib3ggc2hhcGVcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG4gICAgICAgIHVzZUltYWdlU2l6ZTogZmFsc2UsXG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICB1c2VCb3JkZXJXaXRoSW1hZ2U6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgICBjb29yZGluYXRlT3JpZ2luOiBcImNlbnRlclwiIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuXG4gICAgICB9LFxuICAgICAgc2l6ZTogMjUsXG4gICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgIHk6IHVuZGVmaW5lZFxuICAgIH07IC8vIFByb3RlY3QgZnJvbSBpZGlvY3lcblxuICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLm1hc3MgPD0gMCkge1xuICAgICAgdGhyb3cgXCJJbnRlcm5hbCBlcnJvcjogbWFzcyBpbiBkZWZhdWx0T3B0aW9ucyBvZiBOb2Rlc0hhbmRsZXIgbWF5IG5vdCBiZSB6ZXJvIG9yIG5lZ2F0aXZlXCI7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gYnJpZGdlT2JqZWN0KHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOb2Rlc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQyLFxuICAgICAgICAgIF9jb250ZXh0MyxcbiAgICAgICAgICBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyByZWZyZXNoIHRoZSBub2Rlcy4gVXNlZCB3aGVuIHJldmVydGluZyBmcm9tIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaE5vZGVzXCIsIGJpbmQkNihfY29udGV4dDIgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hcIiwgYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczIubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZGF0YS5ub2RlcykgX3RoaXMyLmJvZHkuZGF0YS5ub2Rlcy5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5hZGQ7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLnJlbW92ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBOZWVkIHRvIHNldCBvcGFjaXR5IGhlcmUgYmVjYXVzZSBOb2RlLnBhcnNlT3B0aW9ucyBpcyBhbHNvIHVzZWQgZm9yIGdyb3VwcyxcbiAgICAgICAgLy8gaWYgeW91IHNldCBvcGFjaXR5IGluIE5vZGUucGFyc2VPcHRpb25zIGl0IG92ZXJ3cml0ZXMgZ3JvdXAgb3BhY2l0eS5cblxuICAgICAgICBpZiAob3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoaXNOYW4ob3B0aW9ucy5vcGFjaXR5KSB8fCAhX2lzRmluaXRlKG9wdGlvbnMub3BhY2l0eSkgfHwgb3B0aW9ucy5vcGFjaXR5IDwgMCB8fCBvcHRpb25zLm9wYWNpdHkgPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIG9wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1cGRhdGUgdGhlIHNoYXBlIGluIGFsbCBub2Rlc1xuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnVwZGF0ZVNoYXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgbGFiZWxzIG9mIG5vZGVzIGlmIGFueSByZWxldmFudCBvcHRpb25zIGNoYW5nZWQuXG5cblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9udCAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygb3B0aW9ucy53aWR0aENvbnN0cmFpbnQgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG9wdGlvbnMuaGVpZ2h0Q29uc3RyYWludCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0ga2V5cyQ0KHRoaXMuYm9keS5ub2Rlcyk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9ub2RlSWQgPSBfT2JqZWN0JGtleXNbX2ldO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcblxuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLm5lZWRzUmVmcmVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1cGRhdGUgdGhlIHNoYXBlIHNpemUgaW4gYWxsIG5vZGVzXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgdmFyaWFibGVzIGlmIG5lZWRlZFxuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIGRhdGEgc2V0IHdpdGggbm9kZXMgZm9yIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBub2RlcyAgICAgICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV0gLSBTdXBwcmVzcyBkYXRhIGNoYW5nZWQgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShub2Rlcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgb2xkTm9kZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEubm9kZXM7XG5cbiAgICAgIGlmIChpc0RhdGFWaWV3TGlrZShcImlkXCIsIG5vZGVzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5vZGVzO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIobm9kZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuYWRkKG5vZGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoIW5vZGVzKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkTm9kZXNEYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBvbGROb2Rlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZW1vdmUgZHJhd24gbm9kZXNcblxuXG4gICAgICB0aGlzLmJvZHkubm9kZXMgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLm5vZGVzKSB7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBmb3JFYWNoJDEodGhpcy5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIG1lLmJvZHkuZGF0YS5ub2Rlcy5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTsgLy8gZHJhdyBhbGwgbmV3IG5vZGVzXG5cbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldElkcygpO1xuICAgICAgICB0aGlzLmFkZChpZHMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGlkcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgaWQ7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0KGlkKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgbmV3Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2lkXSA9IG5vZGU7IC8vIG5vdGU6IHRoaXMgbWF5IHJlcGxhY2UgYW4gZXhpc3Rpbmcgbm9kZVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxheW91dEVuZ2luZS5wb3NpdGlvbkluaXRpYWxseShuZXdOb2Rlcyk7XG5cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBleGlzdGluZyBub2Rlcywgb3IgY3JlYXRlIHRoZW0gd2hlbiBub3QgeWV0IGV4aXN0aW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkcyBpZCdzIG9mIGNoYW5nZWQgbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VkRGF0YSBhcnJheSB3aXRoIGNoYW5nZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl8dW5kZWZpbmVkfSBvbGREYXRhIG9wdGlvbmFsOyBhcnJheSB3aXRoIHByZXZpb3VzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMsIGNoYW5nZWREYXRhLCBvbGREYXRhKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2lkXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjaGFuZ2VkRGF0YVtpXTtcblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIG5vZGVcbiAgICAgICAgICBpZiAobm9kZS5zZXRPcHRpb25zKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTsgLy8gY3JlYXRlIG5vZGVcblxuICAgICAgICAgIG5vZGUgPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgICBub2Rlc1tpZF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YUNoYW5nZWQgJiYgb2xkRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbnkgY2hhbmdlcyB3aGljaCBzaG91bGQgdHJpZ2dlciBhIGxheW91dCByZWNhbGN1bGF0aW9uXG4gICAgICAgIC8vIEZvciBub3csIHRoaXMgaXMganVzdCAnbGV2ZWwnIGZvciBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICAgIC8vIEFzc3VtcHRpb246IG9sZCBhbmQgbmV3IGRhdGEgYXJyYW5nZWQgaW4gc2FtZSBvcmRlcjsgYXQgdGltZSBvZiB3cml0aW5nLCB0aGlzIGhvbGRzLlxuICAgICAgICBkYXRhQ2hhbmdlZCA9IHNvbWUoY2hhbmdlZERhdGEpLmNhbGwoY2hhbmdlZERhdGEsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUgJiYgb2xkVmFsdWUubGV2ZWwgIT09IG5ld1ZhbHVlLmxldmVsO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3Rpbmcgbm9kZXMuIElmIG5vZGVzIGRvIG5vdCBleGlzdCwgdGhlIG1ldGhvZCB3aWxsIGp1c3QgaWdub3JlIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZHMpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICBkZWxldGUgbm9kZXNbaWRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Y2xhc3N9IFtjb25zdHJ1Y3RvckNsYXNzPU5vZGUuZGVmYXVsdF1cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yQ2xhc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE5vZGU7XG4gICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yQ2xhc3MocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xlYXJQb3NpdGlvbnM9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNsZWFyUG9zaXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldChub2RlSWQpO1xuXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY2xlYXJQb3NpdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgIHk6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBmaXhlZDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2RlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZS5pZD4gfCBzdHJpbmd9IFtpZHNdICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhpZHMpIHtcbiAgICAgIHZhciBkYXRhQXJyYXkgPSB7fTtcblxuICAgICAgaWYgKGlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0FycmF5JDIoaWRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dO1xuICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG5vZGUueCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChub2RlLnkpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbaWRzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzXTtcbiAgICAgICAgICAgIGRhdGFBcnJheVtpZHNdID0ge1xuICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKF9ub2RlLngpLFxuICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKF9ub2RlLnkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaTJdXTtcbiAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pMl1dID0ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZChfbm9kZTIueCksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKF9ub2RlMi55KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB4IHkgcG9zaXRpb24gb2YgYSBzcGVjaWZpYyBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgdG8gcmV0cmlldmUuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBubyBpZCBpcyBpbmNsdWRlZC5cbiAgICAgKiBAdGhyb3dzIHtSZWZlcmVuY2VFcnJvcn0gSWYgYW4gaW52YWxpZCBpZCBpcyBwcm92aWRlZC5cbiAgICAgKiBAcmV0dXJucyB7eyB4OiBudW1iZXIsIHk6IG51bWJlciB9fSBSZXR1cm5zIFgsIFkgY2FudmFzIHBvc2l0aW9uIG9mIHRoZSBub2RlIHdpdGggZ2l2ZW4gaWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihpZCkge1xuICAgICAgaWYgKGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gaWQgd2FzIHNwZWNpZmllZCBmb3IgZ2V0UG9zaXRpb24gbWV0aG9kLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRQb3NpdGlvbiBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLmNvbmNhdChpZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKHRoaXMuYm9keS5ub2Rlc1tpZF0ueCksXG4gICAgICAgICAgeTogTWF0aC5yb3VuZCh0aGlzLmJvZHkubm9kZXNbaWRdLnkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIFhZIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgaW50byB0aGUgZGF0YXNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3JlUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3JlUG9zaXRpb25zKCkge1xuICAgICAgLy8gdG9kbzogYWRkIHN1cHBvcnQgZm9yIGNsdXN0ZXJzIGFuZCBoaWVyYXJjaGljYWwuXG4gICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICB2YXIgZGF0YXNldCA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYoZGF0YXNldC5nZXQoKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGRzTm9kZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBpZCA9IGRzTm9kZS5pZDtcbiAgICAgICAgICB2YXIgYm9keU5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRdO1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5yb3VuZChib2R5Tm9kZS54KTtcbiAgICAgICAgICB2YXIgeSA9IE1hdGgucm91bmQoYm9keU5vZGUueSk7XG5cbiAgICAgICAgICBpZiAoZHNOb2RlLnggIT09IHggfHwgZHNOb2RlLnkgIT09IHkpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgZGF0YXNldC51cGRhdGUoZGF0YUFycmF5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7anwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3gobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uc2hhcGUuYm91bmRpbmdCb3g7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSWRzIG9mIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7J3RvJ3wnZnJvbSd8dW5kZWZpbmVkfSBkaXJlY3Rpb24gdmFsdWVzICdmcm9tJyBhbmQgJ3RvJyBzZWxlY3QgcmVzcGVjdGl2ZWx5IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMgb25seS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSBvdGhlciB2YWx1ZSByZXR1cm5zIGJvdGggcGFyZW50IGFuZCBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2Rlcyhub2RlSWQsIGRpcmVjdGlvbikge1xuICAgICAgdmFyIG5vZGVMaXN0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIHZhciBub2RlT2JqID0ge307IC8vIHVzZWQgdG8gcXVpY2tseSBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gXCJ0b1wiICYmIGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLmZyb21JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLmZyb21JZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICE9PSBcImZyb21cIiAmJiBlZGdlLmZyb21JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLnRvSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLnRvSWQpO1xuICAgICAgICAgICAgICBub2RlT2JqW2VkZ2UudG9JZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZUxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbm5lY3RlZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZEVkZ2VzKG5vZGVJZCkge1xuICAgICAgdmFyIGVkZ2VMaXN0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWRnZUxpc3QucHVzaChub2RlLmVkZ2VzW2ldLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0Q29ubmVjdGVkRWRnZXMgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIiwgbm9kZUlkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVkZ2VMaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGUobm9kZUlkLCB4LCB5KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCA9IE51bWJlcih4KTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueSA9IE51bWJlcih5KTtcblxuICAgICAgICBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBpZCBzdXBwbGllZCB0byBtb3ZlTm9kZSBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2Rlc0hhbmRsZXI7XG59KCk7XG5cbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBpc0RhdGFEZXNjcmlwdG9yJDEgPSBmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICByZXR1cm4gZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkICYmIChoYXNPd24kMShkZXNjcmlwdG9yLCAndmFsdWUnKSB8fCBoYXNPd24kMShkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSk7XG59O1xuXG52YXIgJCQyID0gX2V4cG9ydDtcbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCRqO1xudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRkO1xudmFyIGlzRGF0YURlc2NyaXB0b3IgPSBpc0RhdGFEZXNjcmlwdG9yJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7IC8vIGBSZWZsZWN0LmdldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0XG5cbmZ1bmN0aW9uIGdldCQ1KHRhcmdldCwgcHJvcGVydHlLZXlcbi8qICwgcmVjZWl2ZXIgKi9cbikge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2NyaXB0b3IsIHByb3RvdHlwZTtcbiAgaWYgKGFuT2JqZWN0JDEodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gIGlmIChkZXNjcmlwdG9yKSByZXR1cm4gaXNEYXRhRGVzY3JpcHRvcihkZXNjcmlwdG9yKSA/IGRlc2NyaXB0b3IudmFsdWUgOiBkZXNjcmlwdG9yLmdldCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY2FsbChkZXNjcmlwdG9yLmdldCwgcmVjZWl2ZXIpO1xuICBpZiAoaXNPYmplY3QkMihwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldCQ1KHByb3RvdHlwZSwgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJCQyKHtcbiAgdGFyZ2V0OiAnUmVmbGVjdCcsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgZ2V0OiBnZXQkNVxufSk7XG5cbnZhciBwYXRoJDMgPSBwYXRoJHk7XG52YXIgZ2V0JDQgPSBwYXRoJDMuUmVmbGVjdC5nZXQ7XG5cbnZhciBwYXJlbnQkNyA9IGdldCQ0O1xudmFyIGdldCQzID0gcGFyZW50JDc7XG5cbnZhciBwYXJlbnQkNiA9IGdldCQzO1xudmFyIGdldCQyID0gcGFyZW50JDY7XG5cbnZhciBwYXJlbnQkNSA9IGdldCQyO1xudmFyIGdldCQxID0gcGFyZW50JDU7XG5cbnZhciBnZXQgPSBnZXQkMTtcblxudmFyIHBhcmVudCQ0ID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBwYXJlbnQkNDtcblxudmFyIHBhcmVudCQzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDI7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBwYXJlbnQkMztcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0KSB7XG4gICAgX2dldCA9IGdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciAkJDEgPSBfZXhwb3J0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC1oeXBvdCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG52YXIgJGh5cG90ID0gTWF0aC5oeXBvdDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0OyAvLyBDaHJvbWUgNzcgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05NTQ2XG5cbnZhciBCVUdHWSA9ICEhJGh5cG90ICYmICRoeXBvdChJbmZpbml0eSwgTmFOKSAhPT0gSW5maW5pdHk7IC8vIGBNYXRoLmh5cG90YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC5oeXBvdFxuXG4kJDEoe1xuICB0YXJnZXQ6ICdNYXRoJyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBCVUdHWVxufSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG5cbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG5cbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cblxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIHNxcnQoc3VtKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJDIgPSBwYXRoJHk7XG52YXIgaHlwb3QkMiA9IHBhdGgkMi5NYXRoLmh5cG90O1xuXG52YXIgcGFyZW50JDIgPSBoeXBvdCQyO1xudmFyIGh5cG90JDEgPSBwYXJlbnQkMjtcblxudmFyIGh5cG90ID0gaHlwb3QkMTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIENvbW1vbiBtZXRob2RzIGZvciBlbmRwb2ludHNcclxuICpcclxuICogQGNsYXNzXHJcbiAqL1xuXG52YXIgRW5kUG9pbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbmRQb2ludCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kUG9pbnQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVuZFBvaW50LCBudWxsLCBbe1xuICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybWF0aW9uIG9uIHBvaW50cyBmb3IgZGlzcGxheS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGRvbmU6XHJcbiAgICAgKiAtIHJvdGF0ZSBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlXHJcbiAgICAgKiAtIG11bHRpcGx5IHRoZSAobm9ybWFsaXplZCkgY29vcmRpbmF0ZXMgYnkgdGhlIHBhc3NlZCBsZW5ndGhcclxuICAgICAqIC0gb2Zmc2V0IGJ5IHRoZSB0YXJnZXQgY29vcmRpbmF0ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIC0gVGhlIHBvaW50KHMpIHRvIGJlIHRyYW5zZm9ybWVkLlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKSB7XG4gICAgICBpZiAoIWlzQXJyYXkkMihwb2ludHMpKSB7XG4gICAgICAgIHBvaW50cyA9IFtwb2ludHNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IGFycm93RGF0YS5wb2ludC54O1xuICAgICAgdmFyIHkgPSBhcnJvd0RhdGEucG9pbnQueTtcbiAgICAgIHZhciBhbmdsZSA9IGFycm93RGF0YS5hbmdsZTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJvd0RhdGEubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIHh0ID0gcC54ICogTWF0aC5jb3MoYW5nbGUpIC0gcC55ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgeXQgPSBwLnggKiBNYXRoLnNpbihhbmdsZSkgKyBwLnkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHAueCA9IHggKyBsZW5ndGggKiB4dDtcbiAgICAgICAgcC55ID0geSArIGxlbmd0aCAqIHl0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBjbG9zZWQgcGF0aCB1c2luZyB0aGUgZ2l2ZW4gcmVhbCBjb29yZGluYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHBhdGggd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnRzIG9mIHRoZSBwYXRoLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHBvaW50cykge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW5kUG9pbnQ7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYXJyb3cgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBJbWFnZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW5kUG9pbnQpIHtcbiAgX2luaGVyaXRzKEltYWdlLCBfRW5kUG9pbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYShJbWFnZSk7XG5cbiAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBGYWxzZSBhcyB0aGVyZSBpcyBubyB3YXkgdG8gZmlsbCBhbiBpbWFnZS5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIGlmIChhcnJvd0RhdGEuaW1hZ2UpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShhcnJvd0RhdGEucG9pbnQueCwgYXJyb3dEYXRhLnBvaW50LnkpO1xuICAgICAgICBjdHgucm90YXRlKE1hdGguUEkgLyAyICsgYXJyb3dEYXRhLmFuZ2xlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gYXJyb3dEYXRhLmltYWdlV2lkdGggIT0gbnVsbCA/IGFycm93RGF0YS5pbWFnZVdpZHRoIDogYXJyb3dEYXRhLmltYWdlLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYXJyb3dEYXRhLmltYWdlSGVpZ2h0ICE9IG51bGwgPyBhcnJvd0RhdGEuaW1hZ2VIZWlnaHQgOiBhcnJvd0RhdGEuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICBhcnJvd0RhdGEuaW1hZ2UuZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIDEsIC8vIHNjYWxlXG4gICAgICAgIC13aWR0aCAvIDIsIC8vIHhcbiAgICAgICAgMCwgLy8geVxuICAgICAgICB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZTtcbn0oRW5kUG9pbnQpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGFycm93IGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQXJyb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbmRQb2ludDIpIHtcbiAgX2luaGVyaXRzKEFycm93LCBfRW5kUG9pbnQyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlciRhKEFycm93KTtcblxuICBmdW5jdGlvbiBBcnJvdygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyb3cpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBcnJvdywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuOSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFycm93O1xufShFbmRQb2ludCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY3JvdyBlbmRwb2ludC5cclxuICovXG5cblxudmFyIENyb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDcm93KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDcm93KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDcm93LCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC40LFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDcm93O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGN1cnZlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQ3VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXJ2ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VydmUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnZlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC40LFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpOyAvLyBVcGRhdGUgZW5kcG9pbnQgc3R5bGUgZm9yIGRyYXdpbmcgdHJhbnNwYXJlbnQgYXJjLlxuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwKVwiOyAvLyBEZWZpbmUgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cblxuICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlIC0gcGkgLyAyO1xuICAgICAgdmFyIGVuZEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnZlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGludmVydGVkIGN1cnZlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgSW52ZXJ0ZWRDdXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludmVydGVkQ3VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludmVydGVkQ3VydmUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEludmVydGVkQ3VydmUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IC0wLjMsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnQsIGFycm93RGF0YSk7IC8vIFVwZGF0ZSBlbmRwb2ludCBzdHlsZSBmb3IgZHJhd2luZyB0cmFuc3BhcmVudCBhcmMuXG5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7IC8vIERlZmluZSBpbnZlcnRlZCBjdXJ2ZSBlbmRwb2ludCBhcyBzZW1pY2lyY2xlLlxuXG4gICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgKyBwaSAvIDI7XG4gICAgICB2YXIgZW5kQW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgKyAzICogcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludmVydGVkQ3VydmU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdHJpbmFnbGUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBUcmlhbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyaWFuZ2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMC4wMixcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJpYW5nbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgaW52ZXJ0ZWQgdHJpbmFnbGUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBJbnZlcnRlZFRyaWFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW52ZXJ0ZWRUcmlhbmdsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW52ZXJ0ZWRUcmlhbmdsZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW52ZXJ0ZWRUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMFxuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludmVydGVkVHJpYW5nbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY2lyY2xlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQ2lyY2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTtcbiAgICAgIGRyYXdDaXJjbGUoY3R4LCBwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYmFyIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhciwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8qXHJcbiAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAge3g6MCwgeTowLjV9LFxyXG4gICAgICAgIHt4OjAsIHk6LTAuNX1cclxuICAgICAgXTtcclxuICAgICAgICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xyXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcclxuICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICovXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC41XG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjVcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuMTUsXG4gICAgICAgIHk6IC0wLjVcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuMTUsXG4gICAgICAgIHk6IDAuNVxuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhcjtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBib3ggZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBCb3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm94LCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjYsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNixcbiAgICAgICAgeTogMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGRpYW1vbmQgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBEaWFtb25kID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGlhbW9uZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlhbW9uZCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGlhbW9uZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjUsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlhbW9uZDtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSB2ZWUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBWZWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWZWUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmVlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmVlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGVuZHBvaW50cy5cclxuICovXG5cblxudmFyIEVuZFBvaW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kUG9pbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbmRQb2ludHMsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgYW4gZW5kcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHR5cGU7XG5cbiAgICAgIGlmIChhcnJvd0RhdGEudHlwZSkge1xuICAgICAgICB0eXBlID0gYXJyb3dEYXRhLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIHJldHVybiBJbWFnZSQxLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICByZXR1cm4gQ2lyY2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJib3hcIjpcbiAgICAgICAgICByZXR1cm4gQm94LmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJjcm93XCI6XG4gICAgICAgICAgcmV0dXJuIENyb3cuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImN1cnZlXCI6XG4gICAgICAgICAgcmV0dXJuIEN1cnZlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgcmV0dXJuIERpYW1vbmQuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImludl9jdXJ2ZVwiOlxuICAgICAgICAgIHJldHVybiBJbnZlcnRlZEN1cnZlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgICAgIHJldHVybiBUcmlhbmdsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiaW52X3RyaWFuZ2xlXCI6XG4gICAgICAgICAgcmV0dXJuIEludmVydGVkVHJpYW5nbGUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImJhclwiOlxuICAgICAgICAgIHJldHVybiBCYXIuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcInZlZVwiOlxuICAgICAgICAgIHJldHVybiBWZWUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImFycm93XCI6IC8vIGZhbGwtdGhyb3VnaFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIEFycm93LmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbmRQb2ludHM7XG59KCk7XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0ga2V5cyQ0KG9iamVjdCk7IGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBmaWx0ZXIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgX2NvbnRleHQyLCBfY29udGV4dDM7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IGZvckVhY2gkMihfY29udGV4dDIgPSBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksICEwKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogZm9yRWFjaCQyKF9jb250ZXh0MyA9IG93bktleXMkMShPYmplY3Qoc291cmNlKSkpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoa2V5KSB7IGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBUaGUgQmFzZSBDbGFzcyBmb3IgYWxsIGVkZ2VzLlxyXG4gKi9cblxudmFyIEVkZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gX2JvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gX2xhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBFZGdlQmFzZShvcHRpb25zLCBfYm9keSwgX2xhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VCYXNlKTtcblxuICAgIHRoaXMuX2JvZHkgPSBfYm9keTtcbiAgICB0aGlzLl9sYWJlbE1vZHVsZSA9IF9sYWJlbE1vZHVsZTtcbiAgICB0aGlzLmNvbG9yID0ge307XG4gICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmhvdmVyV2lkdGggPSAxLjU7XG4gICAgdGhpcy5zZWxlY3Rpb25XaWR0aCA9IDI7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuZnJvbVBvaW50ID0gdGhpcy5mcm9tO1xuICAgIHRoaXMudG9Qb2ludCA9IHRoaXMudG87XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRWRnZUJhc2UsIFt7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IG5ldyBlZGdlIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbmV3IGVkZ2Ugb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZShjdHgsIHZhbHVlcywgX3NlbGVjdGVkLCBfaG92ZXIpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0aGlzLmdldFZpYU5vZGUoKTtcbiAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHZhbHVlcyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuXG4gICAgICBpZiAodmFsdWVzLmRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fZHJhd0Rhc2hlZExpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBsaW5lIHdpdGggZ2l2ZW4gc3R5bGUgYmV0d2VlbiB0d28gbm9kZXMgdGhyb3VnaCBzdXBwbGllZCBub2RlKHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUgLSBBZGRpdGlvbmFsIGNvbnRyb2wgcG9pbnQocykgZm9yIHRoZSBlZGdlLlxyXG4gICAgICogQHBhcmFtIGZyb21Qb2ludCAtIFRPRE86IFNlZW1zIGlnbm9yZWQsIHJlbW92ZT9cclxuICAgICAqIEBwYXJhbSB0b1BvaW50IC0gVE9ETzogU2VlbXMgaWdub3JlZCwgcmVtb3ZlP1xyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdMaW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgdGhpcy5fbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhLCAzKSxcbiAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzJdO1xuXG4gICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGFzaGVkIGxpbmUgd2l0aCBnaXZlbiBzdHlsZSBiZXR3ZWVuIHR3byBub2RlcyB0aHJvdWdoIHN1cHBsaWVkIG5vZGUocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZSAtIEFkZGl0aW9uYWwgY29udHJvbCBwb2ludChzKSBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcGFyYW0gX2Zyb21Qb2ludCAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqIEBwYXJhbSBfdG9Qb2ludCAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdEYXNoZWRMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgX2Zyb21Qb2ludCwgX3RvUG9pbnQpIHtcbiAgICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgICAgdmFyIHBhdHRlcm4gPSBpc0FycmF5JDIodmFsdWVzLmRhc2hlcykgPyB2YWx1ZXMuZGFzaGVzIDogWzUsIDVdOyAvLyBvbmx5IGZpcmVmb3ggYW5kIGNocm9tZSBzdXBwb3J0IHRoaXMgbWV0aG9kLCBlbHNlIHdlIHVzZSB0aGUgbGVnYWN5IG9uZS5cblxuICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7IC8vIHNldCBkYXNoIHNldHRpbmdzIGZvciBjaHJvbWUgb3IgZmlyZWZveFxuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDsgLy8gZHJhdyB0aGUgbGluZVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTMgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhMywgMyksXG4gICAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMF0sXG4gICAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMV0sXG4gICAgICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNFsyXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgfSAvLyByZXN0b3JlIHRoZSBkYXNoIHNldHRpbmdzLlxuXG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bnN1cHBvcnRpbmcgc21vb3RoIGxpbmVzXG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgIGRyYXdEYXNoZWRMaW5lKGN0eCwgdGhpcy5mcm9tLngsIHRoaXMuZnJvbS55LCB0aGlzLnRvLngsIHRoaXMudG8ueSwgcGF0dGVybik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhNSA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE2ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGE1LCAzKSxcbiAgICAgICAgICAgICAgX3ggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMF0sXG4gICAgICAgICAgICAgIF95ID0gX3RoaXMkX2dldENpcmNsZURhdGE2WzFdLFxuICAgICAgICAgICAgICBfcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGE2WzJdO1xuXG4gICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgdmFsdWVzLCBfeCwgX3ksIF9yYWRpdXMpO1xuICAgICAgICB9IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSAoZWl0aGVyIGZyb20gb3IgdG8gbm9kZSBvZiB0aGUgZWRnZSkuXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3JkZXJQb3NpdGlvbihub2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKG5vZGUsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEJvcmRlclBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb25zKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSwgY3R4KSxcbiAgICAgICAgICB0bzogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMudG8sIGN0eClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEkID0gc2xpY2UoX2NvbnRleHQgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCkpLmNhbGwoX2NvbnRleHQsIDAsIDIpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEkMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhJCwgMiksXG4gICAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGEkMlswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQyWzFdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogMC4yNSxcbiAgICAgICAgICAgIGhpZ2g6IDAuNixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogLTFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0bzogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogMC42LFxuICAgICAgICAgICAgaGlnaDogMC44LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjZW50ZXIgcG9pbnQgYW5kIHJhZGl1cyBvZiBhbiBlZGdlIGNvbm5lY3RlZCB0byB0aGUgc2FtZSBub2RlIGF0IGJvdGggZW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEByZXR1cm5zIGBbeCwgeSwgcmFkaXVzXWBcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENpcmNsZURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENpcmNsZURhdGEoY3R4KSB7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZTtcblxuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20uc2hhcGUud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuZnJvbS5zaGFwZS5yZXNpemUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG5cblxuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZ2V0U2VsZlJlZkNvb3JkaW5hdGVzKGN0eCwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsIHJhZGl1cywgdGhpcy5mcm9tKTtcbiAgICAgIHJldHVybiBbY29vcmRpbmF0ZXMueCwgY29vcmRpbmF0ZXMueSwgcmFkaXVzXTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCAtIENlbnRlciBvZiB0aGUgY2lyY2xlIG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geSAtIENlbnRlciBvZiB0aGUgY2lyY2xlIG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBWYWx1ZSBiZXR3ZWVuIDAgKGxpbmUgc3RhcnQpIGFuZCAxIChsaW5lIGVuZCkuXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgcmVxdWVzdGVkIHBvaW50IG9uIHRoZSBjaXJjbGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wb2ludE9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcG9zaXRpb24pIHtcbiAgICAgIHZhciBhbmdsZSA9IHBvc2l0aW9uICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGNpcmNsZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbmVhck5vZGUgLSBUaGUgbm9kZSAoZWl0aGVyIGZyb20gb3IgdG8gbm9kZSBvZiB0aGUgZWRnZSkuXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB4ID0gb3B0aW9ucy54O1xuICAgICAgdmFyIHkgPSBvcHRpb25zLnk7XG4gICAgICB2YXIgbG93ID0gb3B0aW9ucy5sb3c7XG4gICAgICB2YXIgaGlnaCA9IG9wdGlvbnMuaGlnaDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZTtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjA1O1xuICAgICAgdmFyIHBvcztcbiAgICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG4gICAgICB2YXIgZW5kUG9pbnRPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb207XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuICAgICAgICBwb3MgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgbWlkZGxlKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihuZWFyTm9kZS55IC0gcG9zLnksIG5lYXJOb2RlLnggLSBwb3MueCk7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvQm9yZGVyID0gbmVhck5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSArIGVuZFBvaW50T2Zmc2V0O1xuICAgICAgICB2YXIgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbmVhck5vZGUueCwgMikgKyBNYXRoLnBvdyhwb3MueSAtIG5lYXJOb2RlLnksIDIpKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIGJyZWFrOyAvLyBmb3VuZFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgLy8gZGlzdGFuY2UgdG8gbm9kZXMgaXMgbGFyZ2VyIHRoYW4gZGlzdGFuY2UgdG8gYm9yZGVyIC0tPiB0IG5lZWRzIHRvIGJlIGJpZ2dlciBpZiB3ZSdyZSBsb29raW5nIGF0IHRoZSB0byBub2RlLlxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgKytpdGVyYXRpb247XG4gICAgICB9IHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKTtcblxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHBvcyksIHt9LCB7XG4gICAgICAgIHQ6IG1pZGRsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsaW5lIHdpZHRoIG9mIHRoZSBlZGdlLiBEZXBlbmRzIG9uIHdpZHRoIGFuZCB3aGV0aGVyIG9uZSBvZiB0aGUgY29ubmVjdGVkIG5vZGVzIGlzIHNlbGVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RlZCAtIERldGVybWluZXMgd2hldGVyIHRoZSBsaW5lIGlzIHNlbGVjdGVkLlxyXG4gICAgICogQHBhcmFtIGhvdmVyIC0gRGV0ZXJtaW5lcyB3aGV0ZXIgdGhlIGxpbmUgaXMgYmVpbmcgaG92ZXJlZCwgb25seSBhcHBsaWVzIGlmIHNlbGVjdGVkIGlzIGZhbHNlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHdpZHRoIG9mIHRoZSBsaW5lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMaW5lV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZVdpZHRoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnNlbGVjdGlvbldpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfSBlbHNlIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5ob3ZlcldpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aCwgMC4zIC8gdGhpcy5fYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjb2xvciBvciBncmFkaWVudCBmb3IgZ2l2ZW4gZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSBfc2VsZWN0ZWQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcGFyYW0gX2hvdmVyIC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICogQHJldHVybnMgQ29sb3Igc3RyaW5nIGlmIHNpbmdsZSBjb2xvciBpcyBpbmhlcml0ZWQgb3IgZ3JhZGllbnQgaWYgdHdvLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2xvcihjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5pbmhlcml0c0NvbG9yICE9PSBmYWxzZSkge1xuICAgICAgICAvLyB3aGVuIHRoaXMgaXMgYSBsb29wIGVkZ2UsIGp1c3QgdXNlIHRoZSAnZnJvbScgbWV0aG9kXG4gICAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciA9PT0gXCJib3RoXCIgJiYgdGhpcy5mcm9tLmlkICE9PSB0aGlzLnRvLmlkKSB7XG4gICAgICAgICAgdmFyIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55KTtcbiAgICAgICAgICB2YXIgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICB2YXIgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZyb21Db2xvciA9IG92ZXJyaWRlT3BhY2l0eSh0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICAgIHRvQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSB0cnVlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMCwgZnJvbUNvbG9yKTtcbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsIHRvQ29sb3IpOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSB0aGlzIHJldHVybnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09IFwidG9cIikge1xuICAgICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFwiZnJvbVwiXG4gICAgICAgICAgcmV0dXJuIG92ZXJyaWRlT3BhY2l0eSh0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuY29sb3IsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgbGluZSBmcm9tIGEgbm9kZSB0byBpdHNlbGYsIGEgY2lyY2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIHggLSBDZW50ZXIgb2YgdGhlIGNpcmNsZSBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkgLSBDZW50ZXIgb2YgdGhlIGNpcmNsZSBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaXJjbGUoY3R4LCB2YWx1ZXMsIHgsIHksIHJhZGl1cykge1xuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpOyAvL2Z1bGwgY2lyY2xlXG5cbiAgICAgIHZhciBhbmdsZUZyb20gPSAwO1xuICAgICAgdmFyIGFuZ2xlVG8gPSBNYXRoLlBJICogMjtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5yZW5kZXJCZWhpbmRUaGVOb2RlKSB7XG4gICAgICAgIC8vcmVuZGVyIG9ubHkgcGFydHMgd2hpY2ggYXJlIG5vdCBvdmVybGFwaW5nIHdpdGggcGFyZW50IG5vZGVcbiAgICAgICAgLy9uZWVkIHRvIGZpbmQgeCx5IG9mIGZyb20gcG9pbnQgYW5kIHgseSB0byBwb2ludFxuICAgICAgICAvL2NhbGN1bGF0aW5nIHJhZGlhbnNcbiAgICAgICAgdmFyIGxvdyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlO1xuICAgICAgICB2YXIgaGlnaCA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlICsgTWF0aC5QSTtcblxuICAgICAgICB2YXIgcG9pbnRURnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgIGRpcmVjdGlvbjogLTFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBvaW50VFRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGxvdzogbG93LFxuICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFuZ2xlRnJvbSA9IE1hdGguYXRhbjIocG9pbnRURnJvbS55IC0geSwgcG9pbnRURnJvbS54IC0geCk7XG4gICAgICAgIGFuZ2xlVG8gPSBNYXRoLmF0YW4yKHBvaW50VFRvLnkgLSB5LCBwb2ludFRUby54IC0geCk7XG4gICAgICB9IC8vIGRyYXcgYSBjaXJjbGVcblxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYW5nbGVGcm9tLCBhbmdsZVRvLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXREb2NcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhNyA9IHRoaXMuX2dldENpcmNsZURhdGEodW5kZWZpbmVkKSxcbiAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhOCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhNywgMyksXG4gICAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGE4WzBdLFxuICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhOFsxXSxcbiAgICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhOFsyXTtcblxuICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5MztcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLSByYWRpdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4MywgeTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tICh4MSwgeTEpIHRvICh4MiwgeTIpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGluZSBzZWdtZW50IGFuZCB0aGUgcG9pbnQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHB4ID0geDIgLSB4MTtcbiAgICAgIHZhciBweSA9IHkyIC0geTE7XG4gICAgICB2YXIgc29tZXRoaW5nID0gcHggKiBweCArIHB5ICogcHk7XG4gICAgICB2YXIgdSA9ICgoeDMgLSB4MSkgKiBweCArICh5MyAtIHkxKSAqIHB5KSAvIHNvbWV0aGluZztcblxuICAgICAgaWYgKHUgPiAxKSB7XG4gICAgICAgIHUgPSAxO1xuICAgICAgfSBlbHNlIGlmICh1IDwgMCkge1xuICAgICAgICB1ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSB4MSArIHUgKiBweDtcbiAgICAgIHZhciB5ID0geTEgKyB1ICogcHk7XG4gICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICB2YXIgZHkgPSB5IC0geTM7IC8vIyBOb3RlOiBJZiB0aGUgYWN0dWFsIGRpc3RhbmNlIGRvZXMgbm90IG1hdHRlcixcbiAgICAgIC8vIyBpZiB5b3Ugb25seSB3YW50IHRvIGNvbXBhcmUgd2hhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAvLyMgcmV0dXJucyB0byBvdGhlciByZXN1bHRzIG9mIHRoaXMgZnVuY3Rpb24sIHlvdVxuICAgICAgLy8jIGNhbiBqdXN0IHJldHVybiB0aGUgc3F1YXJlZCBkaXN0YW5jZSBpbnN0ZWFkXG4gICAgICAvLyMgKGkuZS4gcmVtb3ZlIHRoZSBzcXJ0KSB0byBnYWluIGEgbGl0dGxlIHBlcmZvcm1hbmNlXG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEFycm93RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcnJvd0RhdGEoY3R4LCBwb3NpdGlvbiwgdmlhTm9kZSwgX3NlbGVjdGVkLCBfaG92ZXIsIHZhbHVlcykge1xuICAgICAgLy8gc2V0IGxldHNcbiAgICAgIHZhciBhbmdsZTtcbiAgICAgIHZhciBhcnJvd1BvaW50O1xuICAgICAgdmFyIG5vZGUxO1xuICAgICAgdmFyIG5vZGUyO1xuICAgICAgdmFyIHJldmVyc2VkO1xuICAgICAgdmFyIHNjYWxlRmFjdG9yO1xuICAgICAgdmFyIHR5cGU7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuXG4gICAgICBpZiAocG9zaXRpb24gPT09IFwiZnJvbVwiKSB7XG4gICAgICAgIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICBub2RlMiA9IHRoaXMudG87XG4gICAgICAgIHJldmVyc2VkID0gdmFsdWVzLmZyb21BcnJvd1NjYWxlIDwgMDtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSBNYXRoLmFicyh2YWx1ZXMuZnJvbUFycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLmZyb21BcnJvd1R5cGU7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInRvXCIpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMudG9BcnJvd1NjYWxlIDwgMDtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSBNYXRoLmFicyh2YWx1ZXMudG9BcnJvd1NjYWxlKTtcbiAgICAgICAgdHlwZSA9IHZhbHVlcy50b0Fycm93VHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUxID0gdGhpcy50bztcbiAgICAgICAgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICAgIHJldmVyc2VkID0gdmFsdWVzLm1pZGRsZUFycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy5taWRkbGVBcnJvd1NjYWxlKTtcbiAgICAgICAgdHlwZSA9IHZhbHVlcy5taWRkbGVBcnJvd1R5cGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSAxNSAqIHNjYWxlRmFjdG9yICsgMyAqIGxpbmVXaWR0aDsgLy8gMyogbGluZVdpZHRoIGlzIHRoZSB3aWR0aCBvZiB0aGUgZWRnZS5cbiAgICAgIC8vIGlmIG5vdCBjb25uZWN0ZWQgdG8gaXRzZWxmXG5cbiAgICAgIGlmIChub2RlMSAhPSBub2RlMikge1xuICAgICAgICB2YXIgYXBwcm94aW1hdGVFZGdlTGVuZ3RoID0gaHlwb3Qobm9kZTEueCAtIG5vZGUyLngsIG5vZGUxLnkgLSBub2RlMi55KTtcblxuICAgICAgICB2YXIgcmVsYXRpdmVMZW5ndGggPSBsZW5ndGggLyBhcHByb3hpbWF0ZUVkZ2VMZW5ndGg7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSBcIm1pZGRsZVwiKSB7XG4gICAgICAgICAgLy8gZHJhdyBhcnJvdyBoZWFkXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHBvaW50VCA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihub2RlMSwgY3R4LCB7XG4gICAgICAgICAgICAgIHZpYTogdmlhTm9kZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBndWlkZVBvcyA9IHRoaXMuZ2V0UG9pbnQocG9pbnRULnQgKyByZWxhdGl2ZUxlbmd0aCAqIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIgPyAxIDogLTEpLCB2aWFOb2RlKTtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihwb2ludFQueSAtIGd1aWRlUG9zLnksIHBvaW50VC54IC0gZ3VpZGVQb3MueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gcG9pbnRUO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24obm9kZTEsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5lZ2F0aXZlIGhhbGYgbGVuZ3RoIHJldmVyc2VzIGFycm93IGRpcmVjdGlvbi5cbiAgICAgICAgICB2YXIgaGFsZkxlbmd0aCA9IChyZXZlcnNlZCA/IC1yZWxhdGl2ZUxlbmd0aCA6IHJlbGF0aXZlTGVuZ3RoKSAvIDI7XG4gICAgICAgICAgdmFyIGd1aWRlUG9zMSA9IHRoaXMuZ2V0UG9pbnQoMC41ICsgaGFsZkxlbmd0aCwgdmlhTm9kZSk7XG4gICAgICAgICAgdmFyIGd1aWRlUG9zMiA9IHRoaXMuZ2V0UG9pbnQoMC41IC0gaGFsZkxlbmd0aCwgdmlhTm9kZSk7XG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGd1aWRlUG9zMS55IC0gZ3VpZGVQb3MyLnksIGd1aWRlUG9zMS54IC0gZ3VpZGVQb3MyLngpO1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyYXcgY2lyY2xlXG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTkgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGE5LCAzKSxcbiAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzBdLFxuICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMV0sXG4gICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzJdO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgICB2YXIgbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG4gICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG5cbiAgICAgICAgICB2YXIgX3BvaW50VCA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhbmdsZSA9IF9wb2ludFQudCAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICAgIGFycm93UG9pbnQgPSBfcG9pbnRUO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInRvXCIpIHtcbiAgICAgICAgICB2YXIgX2xvdyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlO1xuXG4gICAgICAgICAgdmFyIF9oaWdoID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgKyBNYXRoLlBJO1xuXG4gICAgICAgICAgdmFyIF9wb2ludFQyID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogX2xvdyxcbiAgICAgICAgICAgIGhpZ2g6IF9oaWdoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhbmdsZSA9IF9wb2ludFQyLnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJIC0gMS4xICogTWF0aC5QSTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gX3BvaW50VDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5fcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIHBvcyk7XG4gICAgICAgICAgYW5nbGUgPSBwb3MgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeWkgPSBhcnJvd1BvaW50LnkgLSBsZW5ndGggKiAwLjkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgYXJyb3dDb3JlID0ge1xuICAgICAgICB4OiB4aSxcbiAgICAgICAgeTogeWlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogYXJyb3dQb2ludCxcbiAgICAgICAgY29yZTogYXJyb3dDb3JlLFxuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBcnJvd0hlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgX3NlbGVjdGVkLCBfaG92ZXIsIGFycm93RGF0YSkge1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHgubGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuICAgICAgdmFyIGNhbkZpbGwgPSBFbmRQb2ludHMuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgIGlmIChjYW5GaWxsKSB7XG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuXG4gICAgICAgIGZpbGwoY3R4KS5jYWxsKGN0eCk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cblxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc2hhZG93IGZvcm1hdHRpbmcgdmFsdWVzIGluIHRoZSBjb250ZXh0IGlmIGVuYWJsZWQsIGRvIG5vdGhpbmcgb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgc2hhZG93LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB2YWx1ZXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdmFsdWVzLnNoYWRvd1NpemU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdmFsdWVzLnNoYWRvd1g7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdmFsdWVzLnNoYWRvd1k7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIHNoYWRvdyBmb3JtYXR0aW5nIHZhbHVlcyBpbiB0aGUgY29udGV4dCBpZiBlbmFibGVkLCBkbyBub3RoaW5nIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBmb3IgdGhlIHNoYWRvdy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMCwwLDAsMClcIjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgdGhlIGJhY2tncm91bmQgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXR0aW5nIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBmb3IgdGhlIGJhY2tncm91bmQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJhY2tncm91bmQgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgbGluZSBhdHRyc1xuICAgICAgICB2YXIgb3JpZ0N0eEF0dHIgPSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IGN0eC5zdHJva2VTdHlsZSxcbiAgICAgICAgICBsaW5lV2lkdGg6IGN0eC5saW5lV2lkdGgsXG4gICAgICAgICAgZGFzaGVzOiBjdHguZGFzaGVzXG4gICAgICAgIH07XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMuYmFja2dyb3VuZFNpemU7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmJhY2tncm91bmREYXNoZXMpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7IC8vIHJlc3RvcmUgb3JpZ2luYWwgbGluZSBhdHRyc1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9yaWdDdHhBdHRyLnN0cm9rZVN0eWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3JpZ0N0eEF0dHIubGluZVdpZHRoO1xuICAgICAgICBjdHguZGFzaGVzID0gb3JpZ0N0eEF0dHIuZGFzaGVzO1xuICAgICAgICB0aGlzLnNldFN0cm9rZURhc2hlZChjdHgsIHZhbHVlcy5kYXNoZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbGluZSBkYXNoIHBhdHRlcm4gaWYgc3VwcG9ydGVkLiBMb2dzIGEgd2FybmluZyB0byB0aGUgY29uc29sZSBpZiBpdCBpc24ndCBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gZGFzaGVzIC0gVGhlIHBhdHRlcm4gW2xpbmUsIHNwYWNlLCBsaW5l4oCmXSwgdHJ1ZSBmb3IgZGVmYXVsdCBkYXNoZWQgbGluZSBvciBmYWxzZSBmb3Igbm9ybWFsIGxpbmUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFN0cm9rZURhc2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHJva2VEYXNoZWQoY3R4LCBkYXNoZXMpIHtcbiAgICAgIGlmIChkYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gaXNBcnJheSQyKGRhc2hlcykgPyBkYXNoZXMgOiBbNSwgNV07XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKHBhdHRlcm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgc3Ryb2tlIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGdlQmFzZTtcbn0oKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0ga2V5cyQ0KG9iamVjdCk7IGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBmaWx0ZXIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIF9jb250ZXh0LCBfY29udGV4dDI7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IGZvckVhY2gkMihfY29udGV4dCA9IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBmb3JFYWNoJDIoX2NvbnRleHQyID0gb3duS2V5cyhPYmplY3Qoc291cmNlKSkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoa2V5KSB7IGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIFRoZSBCYXNlIENsYXNzIGZvciBhbGwgQmV6aWVyIGVkZ2VzLlxyXG4gKiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cblxudmFyIEJlemllckVkZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJlemllckVkZ2VCYXNlLCBfRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkOShCZXppZXJFZGdlQmFzZSk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcclxuICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgKlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGJpbmFyeSBzZWFyY2ggdG8gbG9vayBmb3IgdGhlIHBvaW50IHdoZXJlIHRoZSBiZXppZXIgY3VydmUgY3Jvc3NlcyB0aGUgYm9yZGVyIG9mIHRoZSBub2RlLlxyXG4gICAqIEBwYXJhbSBuZWFyTm9kZSAtIFRoZSBub2RlIChlaXRoZXIgZnJvbSBvciB0byBub2RlIG9mIHRoZSBlZGdlKS5cclxuICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgKiBAcGFyYW0gdmlhTm9kZSAtIEFkZGl0aW9uYWwgbm9kZShzKSB0aGUgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VCYXNlLCBbe1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMjtcbiAgICAgIHZhciBmcm9tID0gZmFsc2U7XG4gICAgICB2YXIgaGlnaCA9IDE7XG4gICAgICB2YXIgbG93ID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy50bztcbiAgICAgIHZhciBwb3M7XG4gICAgICB2YXIgbWlkZGxlO1xuICAgICAgdmFyIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0ID8gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvIDogMDtcblxuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuZnJvbTtcbiAgICAgICAgZnJvbSA9IHRydWU7XG4gICAgICAgIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0ID8gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gOiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG4gICAgICAgIHBvcyA9IHRoaXMuZ2V0UG9pbnQobWlkZGxlLCB2aWFOb2RlKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlLnkgLSBwb3MueSwgbm9kZS54IC0gcG9zLngpO1xuICAgICAgICB2YXIgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSArIGVuZFBvaW50T2Zmc2V0O1xuICAgICAgICB2YXIgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gZGlzdGFuY2VUb0JvcmRlciAtIGRpc3RhbmNlVG9Qb2ludDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgKytpdGVyYXRpb247XG4gICAgICB9IHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKTtcblxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcG9zKSwge30sIHtcbiAgICAgICAgdDogbWlkZGxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMseTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tICh4MSx5MSkgdG8gKHgyLHkyKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcclxuICAgICAqIEBwYXJhbSB4MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0gdmlhIC0gVGhlIGNvbnRyb2wgcG9pbnQgZm9yIHRoZSBlZGdlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYSkge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICB2YXIgbWluRGlzdGFuY2UgPSAxZTk7XG4gICAgICB2YXIgZGlzdGFuY2U7XG4gICAgICB2YXIgaSwgdCwgeCwgeTtcbiAgICAgIHZhciBsYXN0WCA9IHgxO1xuICAgICAgdmFyIGxhc3RZID0geTE7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueCArIE1hdGgucG93KHQsIDIpICogeDI7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB5MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS55ICsgTWF0aC5wb3codCwgMikgKiB5MjtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW5EaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgYSBiZXppZXIgY3VydmUgYmV0d2VlbiB0d28gbm9kZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBtZXRob2QgYWNjZXB0cyB6ZXJvLCBvbmUgb3IgdHdvIGNvbnRyb2wgcG9pbnRzLlxyXG4gICAgICogUGFzc2luZyB6ZXJvIGNvbnRyb2wgcG9pbnRzIGp1c3QgZHJhd3MgYSBzdHJhaWdodCBsaW5lLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gU3R5bGUgb3B0aW9ucyBmb3IgZWRnZSBkcmF3aW5nLlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUxIC0gRmlyc3QgY29udHJvbCBwb2ludCBmb3IgY3VydmUgZHJhd2luZy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlMiAtIFNlY29uZCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmV6aWVyQ3VydmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlMSwgdmlhTm9kZTIpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG5cbiAgICAgIGlmICh2aWFOb2RlMSAhPSBudWxsICYmIHZpYU5vZGUxLnggIT0gbnVsbCkge1xuICAgICAgICBpZiAodmlhTm9kZTIgIT0gbnVsbCAmJiB2aWFOb2RlMi54ICE9IG51bGwpIHtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh2aWFOb2RlMS54LCB2aWFOb2RlMS55LCB2aWFOb2RlMi54LCB2aWFOb2RlMi55LCB0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHZpYU5vZGUxLngsIHZpYU5vZGUxLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlXG4gICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH0gLy8gZHJhdyBhIGJhY2tncm91bmRcblxuXG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKGN0eCwgdmFsdWVzKTsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCZXppZXJFZGdlQmFzZTtcbn0oRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkOChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQSBEeW5hbWljIEJlemllciBFZGdlLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsXHJcbiAqIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLiBUaGUgRHluYW1pYyBwaWVjZSByZWZlcnMgdG8gaG93IHRoZSBjdXJ2ZVxyXG4gKiByZWFjdHMgdG8gcGh5c2ljcyBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQmV6aWVyRWRnZUJhc2VcclxuICovXG5cbnZhciBCZXppZXJFZGdlRHluYW1pYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhCZXppZXJFZGdlRHluYW1pYywgX0JlemllckVkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDgoQmV6aWVyRWRnZUR5bmFtaWMpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJlemllckVkZ2VEeW5hbWljKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VEeW5hbWljKTtcblxuICAgIC8vdGhpcy52aWEgPSB1bmRlZmluZWQ7IC8vIEhlcmUgZm9yIGNvbXBsZXRlbmVzcyBidXQgbm90IGFsbG93ZWQgdG8gZGVmaW5lZCBiZWZvcmUgc3VwZXIoKSBpcyBpbnZva2VkLlxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpOyAvLyAtLT4gdGhpcyBjYWxscyB0aGUgc2V0T3B0aW9ucyBiZWxvd1xuXG4gICAgX3RoaXMudmlhID0gX3RoaXMudmlhOyAvLyBjb25zdHJ1Y3RvciDihpIgc3VwZXIg4oaSIHN1cGVyIOKGkiBzZXRPcHRpb25zIOKGkiBzZXR1cFN1cHBvcnROb2RlXG5cbiAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fYm9keS5lbWl0dGVyLm9uKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCBfdGhpcy5fYm91bmRGdW5jdGlvbik7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZUR5bmFtaWMsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihCZXppZXJFZGdlRHluYW1pYy5wcm90b3R5cGUpLCBcInNldE9wdGlvbnNcIiwgdGhpcykuY2FsbCh0aGlzLCBvcHRpb25zKTsgLy8gY2hlY2sgaWYgdGhlIHBoeXNpY3MgaGFzIGNoYW5nZWQuXG5cblxuICAgICAgdmFyIHBoeXNpY3NDaGFuZ2UgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5waHlzaWNzICE9PSBvcHRpb25zLnBoeXNpY3MpIHtcbiAgICAgICAgcGh5c2ljc0NoYW5nZSA9IHRydWU7XG4gICAgICB9IC8vIHNldCB0aGUgb3B0aW9ucyBhbmQgdGhlIHRvIGFuZCBmcm9tIG5vZGVzXG5cblxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgIHRoaXMudG8gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107IC8vIHNldHVwIHRoZSBzdXBwb3J0IG5vZGUgYW5kIGNvbm5lY3RcblxuICAgICAgdGhpcy5zZXR1cFN1cHBvcnROb2RlKCk7XG4gICAgICB0aGlzLmNvbm5lY3QoKTsgLy8gd2hlbiB3ZSBjaGFuZ2UgdGhlIHBoeXNpY3Mgc3RhdGUgb2YgdGhlIGVkZ2UsIHdlIHJlcG9zaXRpb24gdGhlIHN1cHBvcnQgbm9kZS5cblxuICAgICAgaWYgKHBoeXNpY3NDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogdGhpcy5vcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuXG4gICAgICBpZiAodGhpcy5mcm9tID09PSB1bmRlZmluZWQgfHwgdGhpcy50byA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5waHlzaWNzID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpeCB3ZWlyZCBiZWhhdmlvdXIgd2hlcmUgYSBzZWxmIHJlZmVyZW5jaW5nIG5vZGUgaGFzIHBoeXNpY3MgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5mcm9tLmlkID09PSB0aGlzLnRvLmlkKSB7XG4gICAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgdGhpcy5fYm9keS5lbWl0dGVyLm9mZihcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIiwgdGhpcy5fYm91bmRGdW5jdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMudmlhLmlkXTtcbiAgICAgICAgdGhpcy52aWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBzdXBwb3J0IG5vZGUgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogQmV6aWVyIGN1cnZlcyByZXF1aXJlIGFuIGFuY2hvciBwb2ludCB0byBjYWxjdWxhdGUgdGhlIHNtb290aCBmbG93LlxyXG4gICAgICogVGhlc2UgcG9pbnRzIGFyZSBub2Rlcy5cclxuICAgICAqIFRoZXNlIG5vZGVzIGFyZSBpbnZpc2libGUgYnV0IGFyZSB1c2VkIGZvciB0aGUgZm9yY2UgY2FsY3VsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGNoYW5nZWQgZGF0YSBpcyBub3QgY2FsbGVkLCBpZiBuZWVkZWQsIGl0IGlzIHJldHVybmVkIGJ5IHRoZSBtYWluIGVkZ2UgY29uc3RydWN0b3IuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldHVwU3VwcG9ydE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBTdXBwb3J0Tm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBcImVkZ2VJZDpcIiArIHRoaXMuaWQ7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtcbiAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2JvZHkubm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlhID0gbm9kZTtcbiAgICAgICAgdGhpcy52aWEucGFyZW50RWRnZUlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBiZXppZXIgbm9kZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25CZXppZXJOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uQmV6aWVyTm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpYS54ID0gMC41ICogKHRoaXMuZnJvbS54ICsgdGhpcy50by54KTtcbiAgICAgICAgdGhpcy52aWEueSA9IDAuNSAqICh0aGlzLmZyb20ueSArIHRoaXMudG8ueSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52aWEueCA9IDA7XG4gICAgICAgIHRoaXMudmlhLnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKSB7XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpYUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpYTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZpYTtcblxuICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gdGhpcy50bykge1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKCksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgICBjeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlswXSxcbiAgICAgICAgICAgIGN5ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzFdLFxuICAgICAgICAgICAgY3IgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMl07XG5cbiAgICAgICAgdmFyIGEgPSAyICogTWF0aC5QSSAqICgxIC0gcG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGN4ICsgY3IgKiBNYXRoLnNpbihhKSxcbiAgICAgICAgICB5OiBjeSArIGNyIC0gY3IgKiAoMSAtIE1hdGguY29zKGEpKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnBvdygxIC0gcG9zaXRpb24sIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiBwb3NpdGlvbiAqICgxIC0gcG9zaXRpb24pICogdmlhTm9kZS54ICsgTWF0aC5wb3cocG9zaXRpb24sIDIpICogdGhpcy50b1BvaW50LngsXG4gICAgICAgICAgeTogTWF0aC5wb3coMSAtIHBvc2l0aW9uLCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogcG9zaXRpb24gKiAoMSAtIHBvc2l0aW9uKSAqIHZpYU5vZGUueSArIE1hdGgucG93KHBvc2l0aW9uLCAyKSAqIHRoaXMudG9Qb2ludC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgdGhpcy52aWEpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdGhpcy52aWEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCZXppZXJFZGdlRHluYW1pYztcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQSBTdGF0aWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqL1xuXG52YXIgQmV6aWVyRWRnZVN0YXRpYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhCZXppZXJFZGdlU3RhdGljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNyhCZXppZXJFZGdlU3RhdGljKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlU3RhdGljKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VTdGF0aWMpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlU3RhdGljLCBbe1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSkge1xuICAgICAgdGhpcy5fYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB2aWEgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogV2UgZG8gbm90IHVzZSB0aGUgdG8gYW5kIGZyb21Qb2ludHMgaGVyZSB0byBtYWtlIHRoZSB2aWEgbm9kZXMgdGhlIHNhbWUgYXMgZWRnZXMgd2l0aG91dCBhcnJvd3MuXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIHZpYSBub2RlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgLy8gQXNzdW1wdGlvbjogeC95IGNvb3JkaW5hdGVzIGluIGZyb20vdG8gYWx3YXlzIGRlZmluZWRcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcbiAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLnNtb290aC50eXBlO1xuICAgICAgdmFyIGR4ID0gTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpO1xuICAgICAgdmFyIGR5ID0gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJkaXNjcmV0ZVwiIHx8IHR5cGUgPT09IFwiZGlhZ29uYWxDcm9zc1wiKSB7XG4gICAgICAgIHZhciBzdGVwWDtcbiAgICAgICAgdmFyIHN0ZXBZO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIHN0ZXBYID0gc3RlcFkgPSBmYWN0b3IgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGVwWCA9IHN0ZXBZID0gZmFjdG9yICogZHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICBzdGVwWCA9IC1zdGVwWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICBzdGVwWSA9IC1zdGVwWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4VmlhID0gdGhpcy5mcm9tLnggKyBzdGVwWDtcbiAgICAgICAgdmFyIHlWaWEgPSB0aGlzLmZyb20ueSArIHN0ZXBZO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIpIHtcbiAgICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICAgIHhWaWEgPSBkeCA8IGZhY3RvciAqIGR5ID8gdGhpcy5mcm9tLnggOiB4VmlhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5VmlhID0gZHkgPCBmYWN0b3IgKiBkeCA/IHRoaXMuZnJvbS55IDogeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHhWaWEsXG4gICAgICAgICAgeTogeVZpYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmFpZ2h0Q3Jvc3NcIikge1xuICAgICAgICB2YXIgX3N0ZXBYID0gKDEgLSBmYWN0b3IpICogZHg7XG5cbiAgICAgICAgdmFyIF9zdGVwWSA9ICgxIC0gZmFjdG9yKSAqIGR5O1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIC8vIHVwIC0gZG93blxuICAgICAgICAgIF9zdGVwWCA9IDA7XG5cbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgIF9zdGVwWSA9IC1fc3RlcFk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxlZnQgLSByaWdodFxuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgX3N0ZXBYID0gLV9zdGVwWDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc3RlcFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLnRvLnggKyBfc3RlcFgsXG4gICAgICAgICAgeTogdGhpcy50by55ICsgX3N0ZXBZXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIHZhciBfc3RlcFgyID0gKDEgLSBmYWN0b3IpICogZHg7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSB7XG4gICAgICAgICAgX3N0ZXBYMiA9IC1fc3RlcFgyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLnRvLnggKyBfc3RlcFgyLFxuICAgICAgICAgIHk6IHRoaXMuZnJvbS55XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidmVydGljYWxcIikge1xuICAgICAgICB2YXIgX3N0ZXBZMiA9ICgxIC0gZmFjdG9yKSAqIGR5O1xuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgIF9zdGVwWTIgPSAtX3N0ZXBZMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy5mcm9tLngsXG4gICAgICAgICAgeTogdGhpcy50by55ICsgX3N0ZXBZMlxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImN1cnZlZENXXCIpIHtcbiAgICAgICAgZHggPSB0aGlzLnRvLnggLSB0aGlzLmZyb20ueDtcbiAgICAgICAgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICAgIHZhciBvcmlnaW5hbEFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICB2YXIgbXlBbmdsZSA9IChvcmlnaW5hbEFuZ2xlICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBwaSkgJSAoMiAqIHBpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5zaW4obXlBbmdsZSksXG4gICAgICAgICAgeTogdGhpcy5mcm9tLnkgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHJhZGl1cyAqIE1hdGguY29zKG15QW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY3VydmVkQ0NXXCIpIHtcbiAgICAgICAgZHggPSB0aGlzLnRvLnggLSB0aGlzLmZyb20ueDtcbiAgICAgICAgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcblxuICAgICAgICB2YXIgX3JhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgdmFyIF9waSA9IE1hdGguUEk7XG5cbiAgICAgICAgdmFyIF9vcmlnaW5hbEFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuXG4gICAgICAgIHZhciBfbXlBbmdsZSA9IChfb3JpZ2luYWxBbmdsZSArICgtZmFjdG9yICogMC41ICsgMC41KSAqIF9waSkgJSAoMiAqIF9waSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguc2luKF9teUFuZ2xlKSxcbiAgICAgICAgICB5OiB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguY29zKF9teUFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udGludW91c1xuICAgICAgICB2YXIgX3N0ZXBYMztcblxuICAgICAgICB2YXIgX3N0ZXBZMztcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICBfc3RlcFgzID0gX3N0ZXBZMyA9IGZhY3RvciAqIGR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdGVwWDMgPSBfc3RlcFkzID0gZmFjdG9yICogZHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICBfc3RlcFgzID0gLV9zdGVwWDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgX3N0ZXBZMyA9IC1fc3RlcFkzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF94VmlhID0gdGhpcy5mcm9tLnggKyBfc3RlcFgzO1xuXG4gICAgICAgIHZhciBfeVZpYSA9IHRoaXMuZnJvbS55ICsgX3N0ZXBZMztcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICBfeFZpYSA9IHRoaXMudG8ueCA8IF94VmlhID8gdGhpcy50by54IDogX3hWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF94VmlhID0gdGhpcy50by54ID4gX3hWaWEgPyB0aGlzLnRvLnggOiBfeFZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgX3lWaWEgPSB0aGlzLnRvLnkgPiBfeVZpYSA/IHRoaXMudG8ueSA6IF95VmlhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfeVZpYSA9IHRoaXMudG8ueSA8IF95VmlhID8gdGhpcy50by55IDogX3lWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBfeFZpYSxcbiAgICAgICAgICB5OiBfeVZpYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMudmlhKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgdmFyIHQgPSBwb3NpdGlvbjtcbiAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmV6aWVyRWRnZVN0YXRpYztcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQSBCYXNlIENsYXNzIGZvciBhbGwgQ3ViaWMgQmV6aWVyIEVkZ2VzLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsXHJcbiAqIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQmV6aWVyRWRnZUJhc2VcclxuICovXG5cbnZhciBDdWJpY0JlemllckVkZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZUJhc2UsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ2KEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb20gKHgxLHkxKSB0byAoeDIseTIpLlxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXHJcbiAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgKiBAcGFyYW0geTEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB4MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB2aWExIC0gVGhlIGZpcnN0IHBvaW50IHRoaXMgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgKiBAcGFyYW0gdmlhMiAtIFRoZSBzZWNvbmQgcG9pbnQgdGhpcyBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBwb2ludC5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2VCYXNlLCBbe1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZTIoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMikge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICB2YXIgbWluRGlzdGFuY2UgPSAxZTk7XG4gICAgICB2YXIgbGFzdFggPSB4MTtcbiAgICAgIHZhciBsYXN0WSA9IHkxO1xuICAgICAgdmFyIHZlYyA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gMC4xICogaTtcbiAgICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgICB2ZWNbMV0gPSAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKTtcbiAgICAgICAgdmVjWzJdID0gMyAqIE1hdGgucG93KHQsIDIpICogKDEgLSB0KTtcbiAgICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICAgIHZhciB4ID0gdmVjWzBdICogeDEgKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB4MjtcbiAgICAgICAgdmFyIHkgPSB2ZWNbMF0gKiB5MSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHkyO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcblxuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdWJpY0JlemllckVkZ2VCYXNlO1xufShCZXppZXJFZGdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ1KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIEN1YmljIEJlemllciBFZGdlLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cblxudmFyIEN1YmljQmV6aWVyRWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0N1YmljQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZSwgX0N1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNShDdWJpY0JlemllckVkZ2UpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2UsIFt7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2Rlcykge1xuICAgICAgLy8gZ2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgc3VwcG9ydCBwb2ludHMuXG4gICAgICB2YXIgdmlhMSA9IHZpYU5vZGVzWzBdO1xuICAgICAgdmFyIHZpYTIgPSB2aWFOb2Rlc1sxXTtcblxuICAgICAgdGhpcy5fYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYTEsIHZpYTIpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGFkZGl0aW9uYWwgcG9pbnRzIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnRzIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgdmFyIGR4ID0gdGhpcy5mcm9tLnggLSB0aGlzLnRvLng7XG4gICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgIHZhciB4MTtcbiAgICAgIHZhciB5MTtcbiAgICAgIHZhciB4MjtcbiAgICAgIHZhciB5MjtcbiAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzczsgLy8gaG9yaXpvbnRhbCBpZiB4ID4geSBvciBpZiBkaXJlY3Rpb24gaXMgZm9yY2VkIG9yIGlmIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsXG5cbiAgICAgIGlmICgoTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpICYmIHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gIT09IFwidmVydGljYWxcIikge1xuICAgICAgICB5MSA9IHRoaXMuZnJvbS55O1xuICAgICAgICB5MiA9IHRoaXMudG8ueTtcbiAgICAgICAgeDEgPSB0aGlzLmZyb20ueCAtIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgICB4MiA9IHRoaXMudG8ueCArIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB0aGlzLmZyb20ueSAtIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB5MiA9IHRoaXMudG8ueSArIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB4MSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB4MiA9IHRoaXMudG8ueDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHg6IHgxLFxuICAgICAgICB5OiB5MVxuICAgICAgfSwge1xuICAgICAgICB4OiB4MixcbiAgICAgICAgeTogeTJcbiAgICAgIH1dO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCksXG4gICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICB2aWExID0gX3JlZjJbMF0sXG4gICAgICAgICAgdmlhMiA9IF9yZWYyWzFdO1xuXG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZTIoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMik7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxcbiAgICAgICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICB2aWExID0gX3JlZjRbMF0sXG4gICAgICAgICAgdmlhMiA9IF9yZWY0WzFdO1xuXG4gICAgICB2YXIgdCA9IHBvc2l0aW9uO1xuICAgICAgdmFyIHZlYyA9IFtNYXRoLnBvdygxIC0gdCwgMyksIDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpLCAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpLCBNYXRoLnBvdyh0LCAzKV07XG4gICAgICB2YXIgeCA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnggKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHRoaXMudG9Qb2ludC55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3ViaWNCZXppZXJFZGdlO1xufShDdWJpY0JlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgU3RyYWlnaHQgRWRnZS5cclxuICovXG5cbnZhciBTdHJhaWdodEVkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoU3RyYWlnaHRFZGdlLCBfRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNChTdHJhaWdodEVkZ2UpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFN0cmFpZ2h0RWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJhaWdodEVkZ2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTdHJhaWdodEVkZ2UsIFt7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzKSB7XG4gICAgICAvLyBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICgxIC0gcG9zaXRpb24pICogdGhpcy5mcm9tUG9pbnQueCArIHBvc2l0aW9uICogdGhpcy50b1BvaW50LngsXG4gICAgICAgIHk6ICgxIC0gcG9zaXRpb24pICogdGhpcy5mcm9tUG9pbnQueSArIHBvc2l0aW9uICogdGhpcy50b1BvaW50LnlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHZhciBub2RlMSA9IHRoaXMudG87XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLmZyb207XG5cbiAgICAgIGlmIChuZWFyTm9kZS5pZCA9PT0gdGhpcy5mcm9tLmlkKSB7XG4gICAgICAgIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICBub2RlMiA9IHRoaXMudG87XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICB2YXIgZWRnZVNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgdmFyIHRvQm9yZGVyRGlzdCA9IG5lYXJOb2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB2YXIgdG9Cb3JkZXJQb2ludCA9IChlZGdlU2VnbWVudExlbmd0aCAtIHRvQm9yZGVyRGlzdCkgLyBlZGdlU2VnbWVudExlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi54ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLngsXG4gICAgICAgIHk6ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi55ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLnksXG4gICAgICAgIHQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyYWlnaHRFZGdlO1xufShFZGdlQmFzZSk7XG5cbi8qKlxuICogQW4gZWRnZSBjb25uZWN0cyB0d28gbm9kZXMgYW5kIGhhcyBhIHNwZWNpZmljIGRpcmVjdGlvbi5cbiAqL1xuXG52YXIgRWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgdmFsdWVzIHNwZWNpZmljIHRvIHRoaXMgZWRnZSwgbXVzdCBjb250YWluIGF0IGxlYXN0ICdmcm9tJyBhbmQgJ3RvJ1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keSAgICAgICAgICAgc2hhcmVkIHN0YXRlIGZyb20gTmV0d29yayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWQgd2hlbiB0aGUgZWRnZSBoYXMgaW1hZ2UgYXJyb3dzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9ucyAgb3B0aW9ucyBmcm9tIHRoZSBFZGdlc0hhbmRsZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRPcHRpb25zIGRlZmF1bHQgb3B0aW9ucyBmcm9tIHRoZSBFZGdlSGFuZGxlciBpbnN0YW5jZS4gVmFsdWUgYW5kIHJlZmVyZW5jZSBhcmUgY29uc3RhbnRcbiAgICovXG4gIGZ1bmN0aW9uIEVkZ2Uob3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlKTtcblxuICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGJvZHkgcHJvdmlkZWRcIik7XG4gICAgfSAvLyBTaW5jZSBnbG9iYWxPcHRpb25zIGlzIGNvbnN0YW50IGluIHZhbHVlcyBhcyB3ZWxsIGFzIHJlZmVyZW5jZSxcbiAgICAvLyBGb2xsb3dpbmcgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UuXG5cblxuICAgIHRoaXMub3B0aW9ucyA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VsaXN0ID0gaW1hZ2VsaXN0OyAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuXG4gICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYmFzZVdpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgdGhpcy50byA9IHVuZGVmaW5lZDsgLy8gYSBub2RlXG5cbiAgICB0aGlzLmVkZ2VUeXBlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IG5ldyBMYWJlbCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucywgdHJ1ZVxuICAgIC8qIEl0J3MgYW4gZWRnZSBsYWJlbCAqL1xuICAgICk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb3Igb3ZlcndyaXRlIG9wdGlvbnMgZm9yIHRoZSBlZGdlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gdW5kZWZpbmVkIGlmIG5vIG9wdGlvbnMsIHRydWUgaWYgbGF5b3V0IGFmZmVjdGluZyBkYXRhIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRWRnZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEZvbGxvd2luZyBvcHRpb25zIGlmIGNoYW5nZWQgYWZmZWN0IHRoZSBsYXlvdXQuXG5cblxuICAgICAgdmFyIGFmZmVjdHNMYXlvdXQgPSB0eXBlb2Ygb3B0aW9ucy5waHlzaWNzICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMub3B0aW9ucy5waHlzaWNzICE9PSBvcHRpb25zLnBoeXNpY3MgfHwgdHlwZW9mIG9wdGlvbnMuaGlkZGVuICE9PSBcInVuZGVmaW5lZFwiICYmICh0aGlzLm9wdGlvbnMuaGlkZGVuIHx8IGZhbHNlKSAhPT0gKG9wdGlvbnMuaGlkZGVuIHx8IGZhbHNlKSB8fCB0eXBlb2Ygb3B0aW9ucy5mcm9tICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMub3B0aW9ucy5mcm9tICE9PSBvcHRpb25zLmZyb20gfHwgdHlwZW9mIG9wdGlvbnMudG8gIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLnRvICE9PSBvcHRpb25zLnRvO1xuICAgICAgRWRnZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcm9tSWQgPSBvcHRpb25zLmZyb207XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy50b0lkID0gb3B0aW9ucy50bztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnZhbHVlID0gX3BhcnNlRmxvYXQob3B0aW9ucy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBjaG9vc2lmeShcImVkZ2VcIiwgcGlsZSk7IC8vIHVwZGF0ZSBsYWJlbCBNb2R1bGVcblxuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTsgLy8gVXBkYXRlIGVkZ2UgdHlwZSwgdGhpcyBpZiBjaGFuZ2VkIGFmZmVjdHMgdGhlIGxheW91dC5cblxuICAgICAgYWZmZWN0c0xheW91dCA9IHRoaXMudXBkYXRlRWRnZVR5cGUoKSB8fCBhZmZlY3RzTGF5b3V0OyAvLyBpZiBhbnl0aGluZyBoYXMgYmVlbiB1cGRhdGVzLCByZXNldCB0aGUgc2VsZWN0aW9uIHdpZHRoIGFuZCB0aGUgaG92ZXIgd2lkdGhcblxuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25XaWR0aHMoKTsgLy8gQSBub2RlIGlzIGNvbm5lY3RlZCB3aGVuIGl0IGhhcyBhIGZyb20gYW5kIHRvIG5vZGUgdGhhdCBib3RoIGV4aXN0IGluIHRoZSBuZXR3b3JrLmJvZHkubm9kZXMuXG5cblxuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICByZXR1cm4gYWZmZWN0c0xheW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dEZWxldGlvbj1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2dsb2JhbE9wdGlvbnM9e31dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29weUZyb21HbG9iYWxzPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fycm93T3B0aW9uc31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHRvQXJyb3cgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBmcm9tQXJyb3cgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgbWlkZGxlQXJyb3cgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZSA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIGluaGVyaXRzQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaW5oZXJpdDtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIHRvQXJyb3c6IHRvQXJyb3csXG4gICAgICAgIHRvQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy50by5zY2FsZUZhY3RvcixcbiAgICAgICAgdG9BcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8udHlwZSxcbiAgICAgICAgdG9BcnJvd1NyYzogdGhpcy5vcHRpb25zLmFycm93cy50by5zcmMsXG4gICAgICAgIHRvQXJyb3dJbWFnZVdpZHRoOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmltYWdlV2lkdGgsXG4gICAgICAgIHRvQXJyb3dJbWFnZUhlaWdodDogdGhpcy5vcHRpb25zLmFycm93cy50by5pbWFnZUhlaWdodCxcbiAgICAgICAgbWlkZGxlQXJyb3c6IG1pZGRsZUFycm93LFxuICAgICAgICBtaWRkbGVBcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5zY2FsZUZhY3RvcixcbiAgICAgICAgbWlkZGxlQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS50eXBlLFxuICAgICAgICBtaWRkbGVBcnJvd1NyYzogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc3JjLFxuICAgICAgICBtaWRkbGVBcnJvd0ltYWdlV2lkdGg6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmltYWdlV2lkdGgsXG4gICAgICAgIG1pZGRsZUFycm93SW1hZ2VIZWlnaHQ6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmltYWdlSGVpZ2h0LFxuICAgICAgICBmcm9tQXJyb3c6IGZyb21BcnJvdyxcbiAgICAgICAgZnJvbUFycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5zY2FsZUZhY3RvcixcbiAgICAgICAgZnJvbUFycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnR5cGUsXG4gICAgICAgIGZyb21BcnJvd1NyYzogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNyYyxcbiAgICAgICAgZnJvbUFycm93SW1hZ2VXaWR0aDogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmltYWdlV2lkdGgsXG4gICAgICAgIGZyb21BcnJvd0ltYWdlSGVpZ2h0OiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uaW1hZ2VIZWlnaHQsXG4gICAgICAgIGFycm93U3RyaWtldGhyb3VnaDogdGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCxcbiAgICAgICAgY29sb3I6IGluaGVyaXRzQ29sb3IgPyB1bmRlZmluZWQgOiB0aGlzLm9wdGlvbnMuY29sb3IuY29sb3IsXG4gICAgICAgIGluaGVyaXRzQ29sb3I6IGluaGVyaXRzQ29sb3IsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5jb2xvci5vcGFjaXR5LFxuICAgICAgICBoaWRkZW46IHRoaXMub3B0aW9ucy5oaWRkZW4sXG4gICAgICAgIGxlbmd0aDogdGhpcy5vcHRpb25zLmxlbmd0aCxcbiAgICAgICAgc2hhZG93OiB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsXG4gICAgICAgIHNoYWRvd0NvbG9yOiB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yLFxuICAgICAgICBzaGFkb3dTaXplOiB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUsXG4gICAgICAgIHNoYWRvd1g6IHRoaXMub3B0aW9ucy5zaGFkb3cueCxcbiAgICAgICAgc2hhZG93WTogdGhpcy5vcHRpb25zLnNoYWRvdy55LFxuICAgICAgICBkYXNoZXM6IHRoaXMub3B0aW9ucy5kYXNoZXMsXG4gICAgICAgIHdpZHRoOiB0aGlzLm9wdGlvbnMud2lkdGgsXG4gICAgICAgIGJhY2tncm91bmQ6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmVuYWJsZWQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuY29sb3IsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5zaXplLFxuICAgICAgICBiYWNrZ3JvdW5kRGFzaGVzOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5kYXNoZXNcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRXaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RlZFdpZHRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gc2VsZWN0ZWRXaWR0aCh2YWx1ZXMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0ZWRXaWR0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggKz0gc2VsZWN0ZWRXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG92ZXIpIHtcbiAgICAgICAgICAgIHZhciBob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG92ZXJXaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IGhvdmVyV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoICs9IGhvdmVyV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyO1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY2hvb3NlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5jaG9vc2VyKHZhbHVlcywgdGhpcy5vcHRpb25zLmlkLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcblxuICAgICAgICAgIGlmICh2YWx1ZXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWVzLmluaGVyaXRzQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IgfHwgdmFsdWVzLnNoYWRvd1NpemUgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSB8fCB2YWx1ZXMuc2hhZG93WCAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy54IHx8IHZhbHVlcy5zaGFkb3dZICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnkpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBvcHRpb25zIGluIHRoZSBsYWJlbCBtb2R1bGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVMYWJlbE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2xvYmFsT3B0aW9ucywgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgZWRnZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zXTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucywgcGlsZSk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGVkZ2UgdHlwZSwgc2V0IHRoZSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkZ2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2VUeXBlKCkge1xuICAgICAgdmFyIHNtb290aCA9IHRoaXMub3B0aW9ucy5zbW9vdGg7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjaGFuZ2VJblR5cGUgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5lZGdlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQmV6aWVyRWRnZUR5bmFtaWMgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgPT09IFwiZHluYW1pY1wiIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBDdWJpY0JlemllckVkZ2UgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgPT09IFwiY3ViaWNCZXppZXJcIiB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQmV6aWVyRWRnZVN0YXRpYyAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSAhPT0gXCJkeW5hbWljXCIgJiYgc21vb3RoLnR5cGUgIT09IFwiY3ViaWNCZXppZXJcIiB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgU3RyYWlnaHRFZGdlICYmIHNtb290aC50eXBlLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChzbW9vdGgudHlwZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgQmV6aWVyRWRnZUR5bmFtaWModGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc21vb3RoLnR5cGUgPT09IFwiY3ViaWNCZXppZXJcIikge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBDdWJpY0JlemllckVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VTdGF0aWModGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IFN0cmFpZ2h0RWRnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdGhpbmcgY2hhbmdlcywgd2UganVzdCBzZXQgdGhlIG9wdGlvbnMuXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YUNoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYW4gZWRnZSB0byBpdHMgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuZnJvbUlkXSB8fCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50by5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGdlVHlwZS5jb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgYW4gZWRnZSBmcm9tIGl0cyBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICB0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy5mcm9tID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50bykge1xuICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdGl0bGUgb2YgdGhpcyBlZGdlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGl0bGUgICAgVGhlIHRpdGxlIG9mIHRoZSBlZGdlLCBvciB1bmRlZmluZWQgd2hlbiBubyB0aXRsZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgZWRnZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSB2YWx1ZSByYW5nZSBvZiB0aGUgZWRnZS4gVGhlIGVkZ2Ugd2lsbCBhZGp1c3QgaXQncyB3aWR0aFxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBmb250RGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluICsgc2NhbGUgKiBmb250RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbiArIHNjYWxlICogd2lkdGhEaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5iYXNlV2lkdGg7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLmJhc2VGb250U2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25XaWR0aHMoKTtcblxuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0SW50ZXJhY3Rpb25XaWR0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEludGVyYWN0aW9uV2lkdGhzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCArIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYSBlZGdlXG4gICAgICogRHJhdyB0aGlzIGVkZ2UgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG5cbiAgICAgIGlmICh2YWx1ZXMuaGlkZGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZ2V0IHRoZSB2aWEgbm9kZSBmcm9tIHRoZSBlZGdlIHR5cGVcblxuXG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpOyAvLyBkcmF3IGxpbmUgYW5kIGxhYmVsXG5cbiAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZpYU5vZGUpO1xuICAgICAgdGhpcy5kcmF3TGFiZWwoY3R4LCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFycm93c1xuICAgICAqIERyYXcgdGhpcyBhcnJvd3MgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QXJyb3dzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcnJvd3MoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG5cbiAgICAgIGlmICh2YWx1ZXMuaGlkZGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZ2V0IHRoZSB2aWEgbm9kZSBmcm9tIHRoZSBlZGdlIHR5cGVcblxuXG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuICAgICAgdmFyIGFycm93RGF0YSA9IHt9OyAvLyByZXN0b3JlIGVkZ2UgdGFyZ2V0cyB0byBkZWZhdWx0c1xuXG4gICAgICB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IHRoaXMuZWRnZVR5cGUuZnJvbTtcbiAgICAgIHRoaXMuZWRnZVR5cGUudG9Qb2ludCA9IHRoaXMuZWRnZVR5cGUudG87IC8vIGZyb20gYW5kIHRvIGFycm93cyBnaXZlIGEgZGlmZmVyZW50IGVuZCBwb2ludCBmb3IgZWRnZXMuIHdlIHNldCB0aGVtIGhlcmVcblxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLmZyb20gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsIFwiZnJvbVwiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gYXJyb3dEYXRhLmZyb20uY29yZTtcblxuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tLmltYWdlID0gdGhpcy5pbWFnZWxpc3QubG9hZCh2YWx1ZXMuZnJvbUFycm93U3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93SW1hZ2VXaWR0aCkge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tLmltYWdlV2lkdGggPSB2YWx1ZXMuZnJvbUFycm93SW1hZ2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZUhlaWdodCA9IHZhbHVlcy5mcm9tQXJyb3dJbWFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVzLnRvQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLnRvID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCBcInRvXCIsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gYXJyb3dEYXRhLnRvLmNvcmU7XG5cbiAgICAgICAgaWYgKHZhbHVlcy50b0Fycm93U3JjKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLnRvLmltYWdlID0gdGhpcy5pbWFnZWxpc3QubG9hZCh2YWx1ZXMudG9BcnJvd1NyYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLnRvQXJyb3dJbWFnZVdpZHRoKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLnRvLmltYWdlV2lkdGggPSB2YWx1ZXMudG9BcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLnRvQXJyb3dJbWFnZUhlaWdodCkge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZUhlaWdodCA9IHZhbHVlcy50b0Fycm93SW1hZ2VIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdGhlIG1pZGRsZSBhcnJvdyBkZXBlbmRzIG9uIHRoZSBsaW5lLCB3aGljaCBjYW4gZGVwZW5kIG9uIHRoZSB0byBhbmQgZnJvbSBhcnJvd3Mgc28gd2UgZG8gdGhpcyBvbmUgbGFzdGx5LlxuXG5cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLm1pZGRsZSA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJtaWRkbGVcIiwgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcblxuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93U3JjKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZS5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLm1pZGRsZUFycm93U3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZVdpZHRoKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZS5pbWFnZVdpZHRoID0gdmFsdWVzLm1pZGRsZUFycm93SW1hZ2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZUhlaWdodCkge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2VIZWlnaHQgPSB2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVzLmZyb21BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5mcm9tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5taWRkbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVzLnRvQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEudG8pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWwoY3R4LCB2aWFOb2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICAgIHZhciBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgdmFyIG5vZGUyID0gdGhpcy50bztcblxuICAgICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5kaWZmZXJlbnRTdGF0ZSh0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKSkge1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludDtcblxuICAgICAgICBpZiAobm9kZTEuaWQgIT0gbm9kZTIuaWQpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgICAgICAgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgIHZhciByb3RhdGlvblBvaW50ID0gdGhpcy5fZ2V0Um90YXRpb24oY3R4KTtcblxuICAgICAgICAgIGlmIChyb3RhdGlvblBvaW50LmFuZ2xlICE9IDApIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocm90YXRpb25Qb2ludC54LCByb3RhdGlvblBvaW50LnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvblBvaW50LmFuZ2xlKTtcbiAgICAgICAgICB9IC8vIGRyYXcgdGhlIGxhYmVsXG5cblxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHBvaW50LngsIHBvaW50LnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgLy8gVXNlZnVsIGRlYnVnIGNvZGU6IGRyYXcgYSBib3JkZXIgYXJvdW5kIHRoZSBsYWJlbFxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkICoqbm90KiogYmUgZW5hYmxlZCBpbiBwcm9kdWN0aW9uIVxuICAgICAgICAgIHZhciBzaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRTaXplKCk7OyAvLyA7OyBpbnRlbnRpb25hbCBzbyBsaW50IGNhdGNoZXMgaXRcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNmZjAwMDBcIjtcbiAgICAgICAgICBjdHguc3Ryb2tlUmVjdChzaXplLmxlZnQsIHNpemUudG9wLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgLy8gRW5kICBkZWJ1ZyBjb2RlXG4gICAgICAgICAgKi9cblxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWdub3JlIHRoZSBvcmllbnRhdGlvbnMuXG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IHRydWU7IC8vIGdldCBjaXJjbGUgY29vcmRpbmF0ZXNcblxuICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGdldFNlbGZSZWZDb29yZGluYXRlcyhjdHgsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlLCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLCBub2RlMSk7XG4gICAgICAgICAgcG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKGNvb3JkaW5hdGVzLngsIGNvb3JkaW5hdGVzLnksIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlKTtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHZpc3VhbCBlbGVtZW50cyBvZiB0aGlzIGVkZ2UgaW5zdGFuY2UsIGluIHdoaWNoIHRoZSBnaXZlblxuICAgICAqIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgYm91bmRpbmcgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48ZWRnZUNsaWNrSXRlbXxlZGdlTGFiZWxDbGlja0l0ZW0+fSBsaXN0IHdpdGggdGhlIGl0ZW1zIHdoaWNoIGFyZSBvbiB0aGUgcG9pbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEl0ZW1zT25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtc09uUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIHZhciByb3RhdGlvblBvaW50ID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcblxuICAgICAgICBpZiAocG9pbnRJblJlY3QodGhpcy5sYWJlbE1vZHVsZS5nZXRTaXplKCksIHBvaW50LCByb3RhdGlvblBvaW50KSkge1xuICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgIGVkZ2VJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGxhYmVsSWQ6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBsZWZ0OiBwb2ludC54LFxuICAgICAgICB0b3A6IHBvaW50LnlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzT3ZlcmxhcHBpbmdXaXRoKG9iaikpIHtcbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgIGVkZ2VJZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3BcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiB0aGUgZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdmFyIGRpc3RNYXggPSAxMDtcbiAgICAgICAgdmFyIHhGcm9tID0gdGhpcy5mcm9tLng7XG4gICAgICAgIHZhciB5RnJvbSA9IHRoaXMuZnJvbS55O1xuICAgICAgICB2YXIgeFRvID0gdGhpcy50by54O1xuICAgICAgICB2YXIgeVRvID0gdGhpcy50by55O1xuICAgICAgICB2YXIgeE9iaiA9IG9iai5sZWZ0O1xuICAgICAgICB2YXIgeU9iaiA9IG9iai50b3A7XG4gICAgICAgIHZhciBkaXN0ID0gdGhpcy5lZGdlVHlwZS5nZXREaXN0YW5jZVRvRWRnZSh4RnJvbSwgeUZyb20sIHhUbywgeVRvLCB4T2JqLCB5T2JqKTtcbiAgICAgICAgcmV0dXJuIGRpc3QgPCBkaXN0TWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHJvdGF0aW9uIHBvaW50LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2N0eF0gaWYgcGFzc2VkLCBkbyBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIGxhYmVsIHNpemVcbiAgICAgKiBAcmV0dXJucyB7cm90YXRpb25Qb2ludH0gdGhlIHBvaW50IHRvIHJvdGF0ZSBhcm91bmQgYW5kIHRoZSBhbmdsZSBpbiByYWRpYW5zIHRvIHJvdGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Um90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJvdGF0aW9uKGN0eCkge1xuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcblxuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgIHk6IHRoaXMubGFiZWxNb2R1bGUuc2l6ZS55TGluZSxcbiAgICAgICAgYW5nbGU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICghdGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIHJldDsgLy8gRG9uJ3QgZXZlbiBib3RoZXIgZG9pbmcgdGhlIGF0YW4yLCB0aGVyZSdzIG5vdGhpbmcgdG8gZHJhd1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnQuYWxpZ24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIHJldHVybiByZXQ7IC8vIE5vIG5lZWQgdG8gY2FsY3VsYXRlIGFuZ2xlXG4gICAgICB9XG5cbiAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgdmFyIGR4ID0gdGhpcy5mcm9tLnggLSB0aGlzLnRvLng7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7IC8vIHJhZGlhbnNcbiAgICAgIC8vIHJvdGF0ZSBzbyB0aGF0IGxhYmVsIGlzIHJlYWRhYmxlXG5cbiAgICAgIGlmIChhbmdsZSA8IC0xICYmIGR4IDwgMCB8fCBhbmdsZSA+IDAgJiYgZHggPCAwKSB7XG4gICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XG4gICAgICB9XG5cbiAgICAgIHJldC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgcG9pbnQgb24gYSBjaXJjbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge29iamVjdH0gcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvaW50T25DaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogeSAtIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3RlZCBzdGF0ZSB0byB0cnVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgc3RhdGUgdG8gZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbGVhbnMgYWxsIHJlcXVpcmVkIHRoaW5ncyBvbiBkZWxldGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZVR5cGUuY2xlYW51cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZWRnZSBmcm9tIHRoZSBsaXN0IGFuZCBwZXJmb3JtIG5lY2Vzc2FyeSBjbGVhbnVwLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMuaWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBib3RoIGNvbm5lY3Rpbmcgbm9kZXMgZXhpc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kUG9pbnRzVmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kUG9pbnRzVmFsaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgY29weUZyb21HbG9iYWxzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICAgIHZhciBmaWVsZHMgPSBbXCJlbmRQb2ludE9mZnNldFwiLCBcImFycm93U3RyaWtldGhyb3VnaFwiLCBcImlkXCIsIFwiZnJvbVwiLCBcImhpZGRlblwiLCBcImhvdmVyV2lkdGhcIiwgXCJsYWJlbEhpZ2hsaWdodEJvbGRcIiwgXCJsZW5ndGhcIiwgXCJsaW5lXCIsIFwib3BhY2l0eVwiLCBcInBoeXNpY3NcIiwgXCJzY2FsaW5nXCIsIFwic2VsZWN0aW9uV2lkdGhcIiwgXCJzZWxmUmVmZXJlbmNlU2l6ZVwiLCBcInNlbGZSZWZlcmVuY2VcIiwgXCJ0b1wiLCBcInRpdGxlXCIsIFwidmFsdWVcIiwgXCJ3aWR0aFwiLCBcImZvbnRcIiwgXCJjaG9zZW5cIiwgXCJ3aWR0aENvbnN0cmFpbnRcIl07IC8vIG9ubHkgZGVlcCBleHRlbmQgdGhlIGl0ZW1zIGluIHRoZSBmaWVsZCBhcnJheS4gVGhlc2UgZG8gbm90IGhhdmUgc2hvcnRoYW5kLlxuXG4gICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7IC8vIE9ubHkgdXNlIGVuZFBvaW50T2Zmc2V0IHZhbHVlcyAoZnJvbSBhbmQgdG8pIGlmIGl0J3MgdmFsaWQgdmFsdWVzXG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKF9pc0Zpbml0ZShuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20pKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tID0gbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA9IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tIDogMDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZW5kUG9pbnRPZmZzZXQuZnJvbSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKF9pc0Zpbml0ZShuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvKSkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gPSBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gPSBnbG9iYWxPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvICE9PSB1bmRlZmluZWQgPyBnbG9iYWxPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvIDogMDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZW5kUG9pbnRPZmZzZXQudG8gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IC8vIE9ubHkgY29weSBsYWJlbCBpZiBpdCdzIGEgbGVnYWwgdmFsdWUuXG5cblxuICAgICAgaWYgKGlzVmFsaWRMYWJlbChuZXdPcHRpb25zLmxhYmVsKSkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmxhYmVsID0gbmV3T3B0aW9ucy5sYWJlbDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRMYWJlbChwYXJlbnRPcHRpb25zLmxhYmVsKSkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmxhYmVsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgXCJzbW9vdGhcIiwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgXCJzaGFkb3dcIiwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgXCJiYWNrZ3JvdW5kXCIsIGdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5kYXNoZXMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmRhc2hlcyAhPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IG5ld09wdGlvbnMuZGFzaGVzO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZGFzaGVzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gY3JlYXRlJDUoZ2xvYmFsT3B0aW9ucy5kYXNoZXMpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgfSAvLyBzZXQgdGhlIHNjYWxpbmcgbmV3T3B0aW9uc1xuXG5cbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLnNjYWxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5taW4gPSBuZXdPcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5tYXggPSBuZXdPcHRpb25zLnNjYWxpbmcubWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuc2NhbGluZywgbmV3T3B0aW9ucy5zY2FsaW5nLCBcImxhYmVsXCIsIGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5zY2FsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZyA9IGNyZWF0ZSQ1KGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9IC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgYXJyb3dzXG5cblxuICAgICAgaWYgKG5ld09wdGlvbnMuYXJyb3dzICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5hcnJvd3MgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmFycm93cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciBhcnJvd3MgPSBuZXdPcHRpb25zLmFycm93cy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPSBpbmRleE9mKGFycm93cykuY2FsbChhcnJvd3MsIFwidG9cIikgIT0gLTE7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPSBpbmRleE9mKGFycm93cykuY2FsbChhcnJvd3MsIFwibWlkZGxlXCIpICE9IC0xO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9IGluZGV4T2YoYXJyb3dzKS5jYWxsKGFycm93cywgXCJmcm9tXCIpICE9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YobmV3T3B0aW9ucy5hcnJvd3MpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgXCJ0b1wiLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgXCJtaWRkbGVcIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwiZnJvbVwiLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFycm93IG5ld09wdGlvbnMgY2FuIG9ubHkgYmUgYW4gb2JqZWN0IG9yIGEgc3RyaW5nLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbi4gWW91IHVzZWQ6XCIgKyBzdHJpbmdpZnkkMShuZXdPcHRpb25zLmFycm93cykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5hcnJvd3MgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MgPSBjcmVhdGUkNShnbG9iYWxPcHRpb25zLmFycm93cyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9IC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgY29sb3JcblxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGZyb21Db2xvciA9IGlzU3RyaW5nKG5ld09wdGlvbnMuY29sb3IpID8ge1xuICAgICAgICAgIGNvbG9yOiBuZXdPcHRpb25zLmNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDogbmV3T3B0aW9ucy5jb2xvcixcbiAgICAgICAgICBob3ZlcjogbmV3T3B0aW9ucy5jb2xvcixcbiAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0gOiBuZXdPcHRpb25zLmNvbG9yO1xuICAgICAgICB2YXIgdG9Db2xvciA9IHBhcmVudE9wdGlvbnMuY29sb3I7IC8vIElmIHBhc3NlZCwgZmlsbCBpbiB2YWx1ZXMgZnJvbSBkZWZhdWx0IG9wdGlvbnMgLSByZXF1aXJlZCBpbiB0aGUgY2FzZSBvZiBubyBwcm90b3R5cGUgYnJpZGdpbmdcblxuICAgICAgICBpZiAoY29weUZyb21HbG9iYWxzKSB7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0b0NvbG9yLCBnbG9iYWxPcHRpb25zLmNvbG9yLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xlYXIgbG9jYWwgcHJvcGVydGllcyAtIG5lZWQgdG8gZG8gaXQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIHJldGFpbiBwcm90b3R5cGUgYnJpZGdlc1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdG9Db2xvcikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b0NvbG9yLCBpKSkge1xuICAgICAgICAgICAgICBkZWxldGUgdG9Db2xvcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTdHJpbmcodG9Db2xvcikpIHtcbiAgICAgICAgICB0b0NvbG9yLmNvbG9yID0gdG9Db2xvcjtcbiAgICAgICAgICB0b0NvbG9yLmhpZ2hsaWdodCA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5ob3ZlciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLm9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5vcGFjaXR5ID0gMS4wOyAvLyBzZXQgZGVmYXVsdFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29sb3JzRGVmaW5lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmNvbG9yID0gZnJvbUNvbG9yLmNvbG9yO1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5oaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSBmcm9tQ29sb3IuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5ob3ZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmhvdmVyID0gZnJvbUNvbG9yLmhvdmVyO1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5pbmhlcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZyb21Db2xvci5pbmhlcml0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3Iub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLm9wYWNpdHkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmcm9tQ29sb3Iub3BhY2l0eSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2xvcnNEZWZpbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvQ29sb3IuaW5oZXJpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IFwiZnJvbVwiOyAvLyBTZXQgZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmNvbG9yKTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmZvbnQpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5ld09wdGlvbnMsIFwic2VsZlJlZmVyZW5jZVNpemVcIikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIHNlbGZSZWZlcmVuY2VTaXplIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2Ugc2VsZlJlZmVyZW5jZSBwcm9wZXJ0eSBpbnN0ZWFkLiBUaGUgc2VsZlJlZmVyZW5jZSBjYW4gYmUgc2V0IGxpa2UgdGhpc2Ugc2VsZlJlZmVyZW5jZTp7c2l6ZTozMCwgYW5nbGU6TWF0aC5QSSAvIDR9XCIpO1xuICAgICAgICBwYXJlbnRPcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZSA9IG5ld09wdGlvbnMuc2VsZlJlZmVyZW5jZVNpemU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkZ2U7XG59KCk7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgRWRnZXNcbiAqL1xuXG52YXIgRWRnZXNIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkuPEltYWdlPn0gaW1hZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEdyb3VwPn0gZ3JvdXBzXG4gICAqL1xuICBmdW5jdGlvbiBFZGdlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlc0hhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmdyb3VwcyA9IGdyb3VwczsgLy8gY3JlYXRlIHRoZSBlZGdlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcblxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSA9IGJpbmQkNihfY29udGV4dCA9IHRoaXMuY3JlYXRlKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLmVkZ2VzTGlzdGVuZXJzID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgIH0sXG4gICAgICAgIC8vIGJvb2xlYW4gLyB7YXJyb3dTY2FsZUZhY3RvcjoxfSAvIHtlbmFibGVkOiBmYWxzZSwgYXJyb3dTY2FsZUZhY3RvcjoxfVxuICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5kUG9pbnRPZmZzZXQ6IHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IDBcbiAgICAgIH0sXG4gICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRydWUsXG4gICAgICBjb2xvcjoge1xuICAgICAgICBjb2xvcjogXCIjODQ4NDg0XCIsXG4gICAgICAgIGhpZ2hsaWdodDogXCIjODQ4NDg0XCIsXG4gICAgICAgIGhvdmVyOiBcIiM4NDg0ODRcIixcbiAgICAgICAgaW5oZXJpdDogXCJmcm9tXCIsXG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSxcbiAgICAgIGRhc2hlczogZmFsc2UsXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiBcIiMzNDM0MzRcIixcbiAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIGZhY2U6IFwiYXJpYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGFsaWduOiBcImhvcml6b250YWxcIixcbiAgICAgICAgbXVsdGk6IGZhbHNlLFxuICAgICAgICB2YWRqdXN0OiAwLFxuICAgICAgICBib2xkOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGRcIlxuICAgICAgICB9LFxuICAgICAgICBib2xkaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJib2xkIGl0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgbW9ubzoge1xuICAgICAgICAgIG1vZDogXCJcIixcbiAgICAgICAgICBzaXplOiAxNSxcbiAgICAgICAgICAvLyBweFxuICAgICAgICAgIGZhY2U6IFwiY291cmllciBuZXdcIixcbiAgICAgICAgICB2YWRqdXN0OiAyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaG92ZXJXaWR0aDogMS41LFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIGxlbmd0aDogdW5kZWZpbmVkLFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiAxLFxuICAgICAgICBtYXg6IDE1LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uV2lkdGg6IDEuNSxcbiAgICAgIHNlbGZSZWZlcmVuY2U6IHtcbiAgICAgICAgc2l6ZTogMjAsXG4gICAgICAgIGFuZ2xlOiBNYXRoLlBJIC8gNCxcbiAgICAgICAgcmVuZGVyQmVoaW5kVGhlTm9kZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB4OiA1LFxuICAgICAgICB5OiA1XG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IFwicmdiYSgxMTEsMTExLDExMSwxKVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgZGFzaGVzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiBcImR5bmFtaWNcIixcbiAgICAgICAgZm9yY2VEaXJlY3Rpb246IFwibm9uZVwiLFxuICAgICAgICByb3VuZG5lc3M6IDAuNVxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRWRnZXNIYW5kbGVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXMsXG4gICAgICAgICAgX2NvbnRleHQyLFxuICAgICAgICAgIF9jb250ZXh0MztcblxuICAgICAgLy8gdGhpcyBhbGxvd3MgZXh0ZXJuYWwgbW9kdWxlcyB0byBmb3JjZSBhbGwgZHluYW1pYyBjdXJ2ZXMgdG8gdHVybiBzdGF0aWMuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgIHR5cGUgPSBcImNvbnRpbnVvdXNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBfdGhpczIuYm9keS5lZGdlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3RoaXMyLmJvZHkuZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gX3RoaXMyLmJvZHkuZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICAgICAgdmFyIGVkZ2VEYXRhID0gX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5nZXQoZWRnZUlkKTsgLy8gb25seSBmb3JjaWJseSByZW1vdmUgdGhlIHNtb290aCBjdXJ2ZSBpZiB0aGUgZGF0YSBoYXMgYmVlbiBzZXQgb2YgdGhlIGVkZ2UgaGFzIHRoZSBzbW9vdGggY3VydmVzIGRlZmluZWQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgYSBjaGFuZ2UgaW4gdGhlIGdsb2JhbCB3b3VsZCBub3QgYWZmZWN0IHRoZXNlIGN1cnZlcy5cblxuXG4gICAgICAgICAgICBpZiAoZWRnZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgc21vb3RoT3B0aW9ucyA9IGVkZ2VEYXRhLnNtb290aDtcblxuICAgICAgICAgICAgICBpZiAoc21vb3RoT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aE9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGhPcHRpb25zLnR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbWl0ID09PSB0cnVlICYmIGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiBvcHRpb25zIG9mIEVYSVNUSU5HIG5vZGVzIG9yIGVkZ2VzIGhhdmUgY2hhbmdlZC5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBOb3QgdHJ1ZSwgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIE5PVCBjaGFuZ2VkLCBmb3IgYm90aCBleGlzdGluZyBhcyB3ZWxsIGFzIG5ldyBub2Rlcy5cbiAgICAgIC8vICAgICAgIFNlZSB1cGRhdGUoKSBmb3IgbG9naWMuXG4gICAgICAvLyBUT0RPOiBWZXJpZnkgYW5kIGV4YW1pbmUgdGhlIGNvbnNlcXVlbmNlcyBvZiB0aGlzLiBJdCBtaWdodCBzdGlsbCB0cmlnZ2VyIHdoZW5cbiAgICAgIC8vICAgICAgIG5vbi1vcHRpb24gZmllbGRzIGhhdmUgY2hhbmdlZCwgYnV0IHRoZW4gcmVjb25uZWN0aW5nIGVkZ2VzIGlzIHN0aWxsIHVzZWxlc3MuXG4gICAgICAvLyAgICAgICBBbHRlcm5hdGl2ZWx5LCBpdCBtaWdodCBhbHNvIGJlIGNhbGxlZCB3aGVuIGVkZ2VzIGFyZSByZW1vdmVkLlxuICAgICAgLy9cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YVVwZGF0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucmVjb25uZWN0RWRnZXMoKTtcbiAgICAgIH0pOyAvLyByZWZyZXNoIHRoZSBlZGdlcy4gVXNlZCB3aGVuIHJldmVydGluZyBmcm9tIGhpZXJhcmNoaWNhbCBsYXlvdXRcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoRWRnZXNcIiwgYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaFwiLCBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MywgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yRWFjaCQxKF90aGlzMi5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLmVkZ2VzKSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZSB0aGUgcGFyc2VyIGZyb20gdGhlIEVkZ2UgY2xhc3MgdG8gZmlsbCBpbiBhbGwgc2hvcnRoYW5kIG5vdGF0aW9uc1xuICAgICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZGVmYXVsdE9wdGlvbnMsIHRydWUpOyAvLyB1cGRhdGUgc21vb3RoIHNldHRpbmdzIGluIGFsbCBlZGdlc1xuXG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNtb290aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS51cGRhdGVFZGdlVHlwZSgpIHx8IGRhdGFDaGFuZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1cGRhdGUgZm9udHMgaW4gYWxsIGVkZ2VzXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBfZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIF9lZGdlSWQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tfZWRnZUlkXS51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCB8fCBkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBlZGdlcyBieSByZWFkaW5nIHRoZSBkYXRhIHRhYmxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBlZGdlcyAgICBUaGUgZGF0YSBjb250YWluaW5nIHRoZSBlZGdlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdIC0gU3VwcHJlc3MgZGF0YSBjaGFuZ2VkIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZWRnZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBvbGRFZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgaWYgKGlzRGF0YVZpZXdMaWtlKFwiaWRcIiwgZWRnZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gZWRnZXM7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5hZGQoZWRnZXMpO1xuICAgICAgfSBlbHNlIGlmICghZWRnZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5IG9yIERhdGFTZXQgZXhwZWN0ZWRcIik7XG4gICAgICB9IC8vIFRPRE86IGlzIHRoaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2U/XG5cblxuICAgICAgaWYgKG9sZEVkZ2VzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkRWRnZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmVtb3ZlIGRyYXduIGVkZ2VzXG5cblxuICAgICAgdGhpcy5ib2R5LmVkZ2VzID0ge307IC8vIFRPRE86IGlzIHRoaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2U/XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5lZGdlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLmVkZ2VzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pOyAvLyBkcmF3IGFsbCBuZXcgbm9kZXNcblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIik7XG5cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaWRzKSB7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgb2xkRWRnZSA9IGVkZ2VzW2lkXTtcblxuICAgICAgICBpZiAob2xkRWRnZSkge1xuICAgICAgICAgIG9sZEVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSBlZGdlc0RhdGEuZ2V0KGlkLCB7XG4gICAgICAgICAgc2hvd0ludGVybmFsSWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBlZGdlc1tpZF0gPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcblxuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4aXN0aW5nIGVkZ2VzLCBvciBjcmVhdGUgdGhlbSB3aGVuIG5vdCB5ZXQgZXhpc3RpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzKSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQpO1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcblxuICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGVkZ2VcbiAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKSB8fCBkYXRhQ2hhbmdlZDsgLy8gaWYgYSBzdXBwb3J0IG5vZGUgaXMgYWRkZWQsIGRhdGEgY2FuIGJlIGNoYW5nZWQuXG5cbiAgICAgICAgICBlZGdlLmNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgZWRnZVxuICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tpZF0gPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIik7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3RpbmcgZWRnZXMuIE5vbiBleGlzdGluZyBpZHMgd2lsbCBiZSBpZ25vcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtaXQ9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZHMpIHtcbiAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHJldHVybjsgLy8gZWFybHkgb3V0XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIGZvckVhY2gkMShpZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcblxuICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyBFZGdlIEhhbmRsZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5LmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM0LmJvZHkuZGF0YS5lZGdlcy5nZXQoZWRnZUlkKTtcblxuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtFZGdlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IEVkZ2UocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb25uZWN0IGFsbCBlZGdlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlY29ubmVjdEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdEVkZ2VzKCkge1xuICAgICAgdmFyIGlkO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIGlkKSkge1xuICAgICAgICAgIG5vZGVzW2lkXS5lZGdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaWQgaW4gZWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlZGdlcywgaWQpKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgICAgZWRnZS5mcm9tID0gbnVsbDtcbiAgICAgICAgICBlZGdlLnRvID0gbnVsbDtcbiAgICAgICAgICBlZGdlLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZS5pZH0gZWRnZUlkXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkTm9kZXMoZWRnZUlkKSB7XG4gICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICBpZiAoZWRnZS5mcm9tSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS5mcm9tSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UudG9JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLnRvSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlcmUgaXMgbm8gZGlyZWN0IHJlbGF0aW9uIGJldHdlZW4gdGhlIG5vZGVzIGFuZCB0aGUgZWRnZXMgRGF0YVNldCxcbiAgICAgKiBzbyB0aGUgcmlnaHQgcGxhY2UgdG8gZG8gY2FsbCB0aGlzIGlzIGluIHRoZSBoYW5kbGVyIGZvciBldmVudCBgX2RhdGFVcGRhdGVkYC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB0aGlzLl9hZGRNaXNzaW5nRWRnZXMoKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlSW52YWxpZEVkZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYW4gZm9yIG1pc3Npbmcgbm9kZXMgYW5kIHJlbW92ZSBjb3JyZXNwb25kaW5nIGVkZ2VzLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUludmFsaWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW52YWxpZEVkZ2VzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBlZGdlc1RvRGVsZXRlID0gW107XG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5LmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgaWQpIHtcbiAgICAgICAgdmFyIHRvTm9kZSA9IF90aGlzNS5ib2R5Lm5vZGVzW2VkZ2UudG9JZF07XG4gICAgICAgIHZhciBmcm9tTm9kZSA9IF90aGlzNS5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXTsgLy8gU2tpcCBjbHVzdGVyaW5nIGVkZ2VzIGhlcmUsIGxldCB0aGUgQ2x1c3RlcmluZyBtb2R1bGUgaGFuZGxlIHRob3NlXG5cbiAgICAgICAgaWYgKHRvTm9kZSAhPT0gdW5kZWZpbmVkICYmIHRvTm9kZS5pc0NsdXN0ZXIgPT09IHRydWUgfHwgZnJvbU5vZGUgIT09IHVuZGVmaW5lZCAmJiBmcm9tTm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9Ob2RlID09PSB1bmRlZmluZWQgfHwgZnJvbU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVkZ2VzVG9EZWxldGUucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW1vdmUoZWRnZXNUb0RlbGV0ZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGQgYWxsIGVkZ2VzIGZyb20gZGF0YXNldCB0aGF0IGFyZSBub3QgaW4gdGhlIGNhY2hlZCBzdGF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRNaXNzaW5nRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZE1pc3NpbmdFZGdlcygpIHtcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgaWYgKGVkZ2VzRGF0YSA9PT0gdW5kZWZpbmVkIHx8IGVkZ2VzRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47IC8vIE5vIGVkZ2VzIERhdGFTZXQgeWV0OyBjYW4gaGFwcGVuIG9uIHN0YXJ0dXBcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGFkZElkcyA9IFtdO1xuXG4gICAgICBmb3JFYWNoJDIoZWRnZXNEYXRhKS5jYWxsKGVkZ2VzRGF0YSwgZnVuY3Rpb24gKGVkZ2VEYXRhLCBlZGdlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgIGlmIChlZGdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRJZHMucHVzaChlZGdlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hZGQoYWRkSWRzLCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWRnZXNIYW5kbGVyO1xufSgpO1xuXG4vKipcbiAqIEJhcm5lcyBIdXQgU29sdmVyXG4gKi9cblxudmFyIEJhcm5lc0h1dFNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBCYXJuZXNIdXRTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFybmVzSHV0U29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuYmFybmVzSHV0VHJlZTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5fcm5nID0gQWxlYShcIkJBUk5FUyBIVVQgU09MVkVSXCIpOyAvLyBkZWJ1Zzogc2hvdyBncmlkXG4gICAgLy8gdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhZnRlckRyYXdpbmdcIiwgKGN0eCkgPT4ge3RoaXMuX2RlYnVnKGN0eCwnI2ZmMDAwMCcpfSlcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMudGhldGFJbnZlcnNlZCA9IDEgLyB0aGlzLm9wdGlvbnMudGhldGE7IC8vIGlmIDEgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUsIGlmIDAuNSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSArIDAuNSpub2RlLnNoYXBlLnJhZGl1c1xuXG4gICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSAxIC0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5vcHRpb25zLmF2b2lkT3ZlcmxhcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIGdyYXZpdGF0aW9uYWwgbW9kZWwuXG4gICAgICogVGhlIEJhcm5lcyBIdXQgbWV0aG9kIGlzIHVzZWQgdG8gc3BlZWQgdXAgdGhpcyBOLWJvZHkgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7IC8vIGNyZWF0ZSB0aGUgdHJlZVxuXG4gICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTsgLy8gZm9yIGRlYnVnZ2luZ1xuXG5cbiAgICAgICAgdGhpcy5iYXJuZXNIdXRUcmVlID0gYmFybmVzSHV0VHJlZTsgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggcm9vdCBpcyBpcnJlbGV2YW50LCBpdCBuZXZlciBwYXNzZXMgdGhlIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhiYXJuZXNIdXRUcmVlLnJvb3QsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9ucyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVywgbm9kZSk7XG5cbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5ORSwgbm9kZSk7XG5cbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5TVywgbm9kZSk7XG5cbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5TRSwgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBiYXJuZXNIdXRUcmVlLiBJdCBjaGVja3Mgd2hlbiBpdCBjYW4gYXBwcm94aW1hdGUgZGlzdGFudCBub2RlcyB3aXRoIHRoZWlyIGNlbnRlciBvZiBtYXNzLlxuICAgICAqIElmIGEgcmVnaW9uIGNvbnRhaW5zIGEgc2luZ2xlIG5vZGUsIHdlIGNoZWNrIGlmIGl0IGlzIG5vdCBpdHNlbGYsIHRoZW4gd2UgYXBwbHkgdGhlIGZvcmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Rm9yY2VDb250cmlidXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgLy8gd2UgZ2V0IG5vIGZvcmNlIGNvbnRyaWJ1dGlvbiBmcm9tIGFuIGVtcHR5IHJlZ2lvblxuICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID4gMCkge1xuICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBub2RlLlxuICAgICAgICB2YXIgZHggPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggLSBub2RlLng7XG4gICAgICAgIHZhciBkeSA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSAtIG5vZGUueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTsgLy8gQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAvLyBvcmlnaW5hbCBjb25kaXRpb24gOiBzL2QgPCB0aGV0YSA9IHBhc3NlZCAgPT09ICBkL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgIC8vIGNhbGNTaXplID0gMS9zIC0tPiBkICogMS9zID4gMS90aGV0YSA9IHBhc3NlZFxuXG4gICAgICAgIGlmIChkaXN0YW5jZSAqIHBhcmVudEJyYW5jaC5jYWxjU2l6ZSA+IHRoaXMudGhldGFJbnZlcnNlZCkge1xuICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpZCBub3QgcGFzcyB0aGUgY29uZGl0aW9uLCBnbyBpbnRvIGNoaWxkcmVuIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmVudEJyYW5jaCBtdXN0IGhhdmUgb25seSBvbmUgbm9kZSwgaWYgaXQgd2FzIGVtcHR5IHdlIHdvdWxkbnQgYmUgaGVyZVxuICAgICAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhLmlkICE9IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IHNlbGZcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCkge1xuICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGRpc3RhbmNlID0gMC4xO1xuICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSAmJiBub2RlLnNoYXBlLnJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgIH0gLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG5cblxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzIC8gTWF0aC5wb3coZGlzdGFuY2UsIDMpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnN0cnVjdHMgdGhlIGJhcm5lc0h1dCB0cmVlIHJlY3Vyc2l2ZWx5LiBJdCBjcmVhdGVzIHRoZSByb290LCBzcGxpdHMgaXQgYW5kIHN0YXJ0cyBwbGFjaW5nIHRoZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG5vZGVJbmRpY2VzXG4gICAgICogQHJldHVybnMge3tyb290OiB7Y2VudGVyT2ZNYXNzOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LCBtYXNzOiBudW1iZXIsIHJhbmdlOiB7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfSwgc2l6ZTogbnVtYmVyLCBjYWxjU2l6ZTogbnVtYmVyLCBjaGlsZHJlbjoge2RhdGE6IG51bGx9LCBtYXhXaWR0aDogbnVtYmVyLCBsZXZlbDogbnVtYmVyLCBjaGlsZHJlbkNvdW50OiBudW1iZXJ9fX0gQmFybmVzSHV0VHJlZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZm9ybUJhcm5lc0h1dFRyZWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcykge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgdmFyIG1pblggPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueDtcbiAgICAgIHZhciBtaW5ZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG4gICAgICB2YXIgbWF4WCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgdmFyIG1heFkgPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueTsgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgbm9kZXNcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIHZhciB4ID0gX25vZGUueDtcbiAgICAgICAgdmFyIHkgPSBfbm9kZS55O1xuXG4gICAgICAgIGlmIChfbm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgIG1heFggPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWFrZSB0aGUgcmFuZ2UgYSBzcXVhcmVcblxuXG4gICAgICB2YXIgc2l6ZURpZmYgPSBNYXRoLmFicyhtYXhYIC0gbWluWCkgLSBNYXRoLmFicyhtYXhZIC0gbWluWSk7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBYIGFuZCBZXG5cbiAgICAgIGlmIChzaXplRGlmZiA+IDApIHtcbiAgICAgICAgbWluWSAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgbWF4WSArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgIH0gLy8geFNpemUgPiB5U2l6ZVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1pblggKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgIG1heFggLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICB9IC8vIHhTaXplIDwgeVNpemVcblxuXG4gICAgICB2YXIgbWluaW11bVRyZWVTaXplID0gMWUtNTtcbiAgICAgIHZhciByb290U2l6ZSA9IE1hdGgubWF4KG1pbmltdW1UcmVlU2l6ZSwgTWF0aC5hYnMobWF4WCAtIG1pblgpKTtcbiAgICAgIHZhciBoYWxmUm9vdFNpemUgPSAwLjUgKiByb290U2l6ZTtcbiAgICAgIHZhciBjZW50ZXJYID0gMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgICBjZW50ZXJZID0gMC41ICogKG1pblkgKyBtYXhZKTsgLy8gY29uc3RydWN0IHRoZSBiYXJuZXNIdXRUcmVlXG5cbiAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgY2VudGVyT2ZNYXNzOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgbWluWDogY2VudGVyWCAtIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1heFg6IGNlbnRlclggKyBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtaW5ZOiBjZW50ZXJZIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WTogY2VudGVyWSArIGhhbGZSb290U2l6ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2l6ZTogcm9vdFNpemUsXG4gICAgICAgICAgY2FsY1NpemU6IDEgLyByb290U2l6ZSxcbiAgICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgY2hpbGRyZW5Db3VudDogNFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zcGxpdEJyYW5jaChiYXJuZXNIdXRUcmVlLnJvb3QpOyAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlQ291bnQ7IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07XG5cbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWFrZSBnbG9iYWxcblxuXG4gICAgICByZXR1cm4gYmFybmVzSHV0VHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyB1cGRhdGVzIHRoZSBtYXNzIG9mIGEgYnJhbmNoLiB0aGlzIGlzIGluY3JlYXNlZCBieSBhZGRpbmcgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQnJhbmNoTWFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIHZhciBjZW50ZXJPZk1hc3MgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzO1xuICAgICAgdmFyIHRvdGFsTWFzcyA9IHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzSW52ID0gMSAvIHRvdGFsTWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy54ID0gY2VudGVyT2ZNYXNzLnggKiBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUueCAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgY2VudGVyT2ZNYXNzLnggKj0gdG90YWxNYXNzSW52O1xuICAgICAgY2VudGVyT2ZNYXNzLnkgPSBjZW50ZXJPZk1hc3MueSAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS55ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueSAqPSB0b3RhbE1hc3NJbnY7XG4gICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IHRvdGFsTWFzcztcbiAgICAgIHZhciBiaWdnZXN0U2l6ZSA9IE1hdGgubWF4KE1hdGgubWF4KG5vZGUuaGVpZ2h0LCBub2RlLnJhZGl1cyksIG5vZGUud2lkdGgpO1xuICAgICAgcGFyZW50QnJhbmNoLm1heFdpZHRoID0gcGFyZW50QnJhbmNoLm1heFdpZHRoIDwgYmlnZ2VzdFNpemUgPyBiaWdnZXN0U2l6ZSA6IHBhcmVudEJyYW5jaC5tYXhXaWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGluIHdoaWNoIGJyYW5jaCB0aGUgbm9kZSB3aWxsIGJlIHBsYWNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBNYXNzVXBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUluVHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBub2RlLCBza2lwTWFzc1VwZGF0ZSkge1xuICAgICAgaWYgKHNraXBNYXNzVXBkYXRlICE9IHRydWUgfHwgc2tpcE1hc3NVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIG1hc3Mgb2YgdGhlIGJyYW5jaC5cbiAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSBwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcucmFuZ2U7XG4gICAgICB2YXIgcmVnaW9uO1xuXG4gICAgICBpZiAocmFuZ2UubWF4WCA+IG5vZGUueCkge1xuICAgICAgICAvLyBpbiBOVyBvciBTV1xuICAgICAgICBpZiAocmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiTldcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBcIlNXXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluIE5FIG9yIFNFXG4gICAgICAgIGlmIChyYW5nZS5tYXhZID4gbm9kZS55KSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJORVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiU0VcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWN0dWFsbHkgcGxhY2UgdGhlIG5vZGUgaW4gYSByZWdpb24gKG9yIGJyYW5jaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geydOVyd8ICdORScgfCAnU1cnIHwgJ1NFJ30gcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUluUmVnaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXTtcblxuICAgICAgc3dpdGNoIChjaGlsZHJlbi5jaGlsZHJlbkNvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvLyBwbGFjZSBub2RlIGhlcmVcbiAgICAgICAgICBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhID0gbm9kZTtcbiAgICAgICAgICBjaGlsZHJlbi5jaGlsZHJlbkNvdW50ID0gMTtcblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJyYW5jaE1hc3MoY2hpbGRyZW4sIG5vZGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIGNvbnZlcnQgaW50byBjaGlsZHJlblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9kZXMgZXhhY3RseSBvdmVybGFwcGluZyAob24gaW5pdCwgb24gb3BlbmluZyBvZiBjbHVzdGVyIGV0Yy4pXG4gICAgICAgICAgLy8gd2UgbW92ZSBvbmUgbm9kZSBhIGxpdHRsZSBiaXQgYW5kIHdlIGRvIG5vdCBwdXQgaXQgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEueCA9PT0gbm9kZS54ICYmIGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEueSA9PT0gbm9kZS55KSB7XG4gICAgICAgICAgICBub2RlLnggKz0gdGhpcy5fcm5nKCk7XG4gICAgICAgICAgICBub2RlLnkgKz0gdGhpcy5fcm5nKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0QnJhbmNoKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoY2hpbGRyZW4sIG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAvLyBwbGFjZSBpbiBicmFuY2hcbiAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShjaGlsZHJlbiwgbm9kZSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBzcGxpdHMgYSBicmFuY2ggaW50byA0IHN1YiBicmFuY2hlcy4gSWYgdGhlIGJyYW5jaCBjb250YWluZWQgYSBub2RlLCB3ZSBwbGFjZSBpdCBpbiB0aGUgc3ViYnJhbmNoXG4gICAgICogYWZ0ZXIgdGhlIHNwbGl0IGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3BsaXRCcmFuY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QnJhbmNoKHBhcmVudEJyYW5jaCkge1xuICAgICAgLy8gaWYgdGhlIGJyYW5jaCBpcyBzaGFkZWQgd2l0aCBhIG5vZGUsIHJlcGxhY2UgdGhlIG5vZGUgaW4gdGhlIG5ldyBzdWJzZXQuXG4gICAgICB2YXIgY29udGFpbmVkTm9kZSA9IG51bGw7XG5cbiAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gMSkge1xuICAgICAgICBjb250YWluZWROb2RlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGE7XG4gICAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gMDtcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ID0gMDtcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ID0gMDtcbiAgICAgIH1cblxuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPSA0O1xuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEgPSBudWxsO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIk5XXCIpO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIk5FXCIpO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIlNXXCIpO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIlNFXCIpO1xuXG4gICAgICBpZiAoY29udGFpbmVkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaCwgY29udGFpbmVkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyB0aGUgcmVnaW9uIGludG8gZm91ciBuZXcgc2VnbWVudHMuXG4gICAgICogU3BlY2lmaWNhbGx5LCB0aGlzIGluc2VydHMgYSBzaW5nbGUgbmV3IHNlZ21lbnQuXG4gICAgICogSXQgZmlsbHMgdGhlIGNoaWxkcmVuIHNlY3Rpb24gb2YgdGhlIHBhcmVudEJyYW5jaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7J05XJ3wgJ05FJyB8ICdTVycgfCAnU0UnfSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luc2VydFJlZ2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgcmVnaW9uKSB7XG4gICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcbiAgICAgIHZhciBjaGlsZFNpemUgPSAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZTtcblxuICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgY2FzZSBcIk5XXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJORVwiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFg7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiU1dcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblg7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlNFXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSA9IHtcbiAgICAgICAgY2VudGVyT2ZNYXNzOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1hc3M6IDAsXG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICAgIG1pblk6IG1pblksXG4gICAgICAgICAgbWF4WTogbWF4WVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZSxcbiAgICAgICAgY2FsY1NpemU6IDIgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUsXG4gICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgbGV2ZWw6IHBhcmVudEJyYW5jaC5sZXZlbCArIDEsXG4gICAgICAgIGNoaWxkcmVuQ291bnQ6IDBcbiAgICAgIH07XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgREVCVUdHSU5HIEJFTE9XICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VkLCBpdCBkcmF3cyB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlYnVnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJ1ZyhjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAodGhpcy5iYXJuZXNIdXRUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaCh0aGlzLmJhcm5lc0h1dFRyZWUucm9vdCwgY3R4LCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gSXQgZHJhd3MgdGhlIGJyYW5jaGVzIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJyYW5jaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdCcmFuY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCcmFuY2goYnJhbmNoLCBjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvciA9IFwiI0ZGMDAwMFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTlcsIGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTkUsIGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU0UsIGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU1csIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgLypcbiAgICAgICBpZiAoYnJhbmNoLm1hc3MgPiAwKSB7XG4gICAgICAgY3R4LmNpcmNsZShicmFuY2guY2VudGVyT2ZNYXNzLngsIGJyYW5jaC5jZW50ZXJPZk1hc3MueSwgMypicmFuY2gubWFzcyk7XG4gICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgIH1cbiAgICAgICAqL1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXJuZXNIdXRTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogUmVwdWxzaW9uIFNvbHZlclxuICovXG5cbnZhciBSZXB1bHNpb25Tb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcHVsc2lvblNvbHZlcik7XG5cbiAgICB0aGlzLl9ybmcgPSBBbGVhKFwiUkVQVUxTSU9OIFNPTFZFUlwiKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIGZ4LCBmeSwgcmVwdWxzaW5nRm9yY2UsIG5vZGUxLCBub2RlMjtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzOyAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcblxuICAgICAgdmFyIG5vZGVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ub2RlRGlzdGFuY2U7IC8vIGFwcHJveGltYXRpb24gY29uc3RhbnRzXG5cbiAgICAgIHZhciBhID0gLTIgLyAzIC8gbm9kZURpc3RhbmNlO1xuICAgICAgdmFyIGIgPSA0IC8gMzsgLy8gd2UgbG9vcCBmcm9tIGkgb3ZlciBhbGwgYnV0IHRoZSBsYXN0IGVudHJlZSBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIGogbG9vcHMgZnJvbSBpKzEgdG8gdGhlIGxhc3QuIFRoaXMgd2F5IHdlIGRvIG5vdCBkb3VibGUgY291bnQgYW55IG9mIHRoZSBpbmRpY2VzLCBub3IgaSA9PT0galxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBub2RlMSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dO1xuICAgICAgICAgIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7IC8vIHNhbWUgY29uZGl0aW9uIGFzIEJhcm5lc0h1dFNvbHZlciwgbWFraW5nIHN1cmUgbm9kZXMgYXJlIG5ldmVyIDEwMCUgb3ZlcmxhcHBpbmcuXG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gMC4xICogdGhpcy5fcm5nKCk7XG4gICAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDIgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDAuNSAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IDEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gYSAqIGRpc3RhbmNlICsgYjsgLy8gbGluZWFyIGFwcHJveCBvZiAgMSAvICgxICsgTWF0aC5leHAoKGRpc3RhbmNlIC8gbm9kZURpc3RhbmNlIC0gMSkgKiBzdGVlcG5lc3MpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnggLT0gZng7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnkgLT0gZnk7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnggKz0gZng7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnkgKz0gZnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBIaWVyYXJjaGljYWwgUmVwdWxzaW9uIFNvbHZlclxuICovXG52YXIgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5vcHRpb25zLmF2b2lkT3ZlcmxhcCB8fCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7IC8vIHJlcHVsc2luZyBmb3JjZXMgYmV0d2VlbiBub2Rlc1xuXG4gICAgICB2YXIgbm9kZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZTsgLy8gd2UgbG9vcCBmcm9tIGkgb3ZlciBhbGwgYnV0IHRoZSBsYXN0IGVudHJlZSBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIGogbG9vcHMgZnJvbSBpKzEgdG8gdGhlIGxhc3QuIFRoaXMgd2F5IHdlIGRvIG5vdCBkb3VibGUgY291bnQgYW55IG9mIHRoZSBpbmRpY2VzLCBub3IgaSA9PT0galxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbm9kZUluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07IC8vIG5vZGVzIG9ubHkgYWZmZWN0IG5vZGVzIG9uIHRoZWlyIGxldmVsXG5cbiAgICAgICAgICBpZiAobm9kZTEubGV2ZWwgPT09IG5vZGUyLmxldmVsKSB7XG4gICAgICAgICAgICB2YXIgdGhlc2VOb2Rlc0Rpc3RhbmNlID0gbm9kZURpc3RhbmNlICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogKChub2RlMS5zaGFwZS5yYWRpdXMgfHwgMCkgLyAyICsgKG5vZGUyLnNoYXBlLnJhZGl1cyB8fCAwKSAvIDIpO1xuICAgICAgICAgICAgdmFyIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgICB2YXIgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgc3RlZXBuZXNzID0gMC4wNTtcbiAgICAgICAgICAgIHZhciByZXB1bHNpbmdGb3JjZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgdGhlc2VOb2Rlc0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gLU1hdGgucG93KHN0ZWVwbmVzcyAqIGRpc3RhbmNlLCAyKSArIE1hdGgucG93KHN0ZWVwbmVzcyAqIHRoZXNlTm9kZXNEaXN0YW5jZSwgMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IDA7XG4gICAgICAgICAgICB9IC8vIG5vcm1hbGl6ZSBmb3JjZSB3aXRoXG5cblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlICE9PSAwKSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gcmVwdWxzaW5nRm9yY2UgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZ4ID0gZHggKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIHZhciBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnggLT0gZng7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnkgLT0gZnk7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnggKz0gZng7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnkgKz0gZnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBTcHJpbmcgU29sdmVyXG4gKi9cbnZhciBTcHJpbmdTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcmluZ1NvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNwcmluZ1NvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIG5vZGUxLCBub2RlMiwgbm9kZTM7IC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgIC8vIG9ubHkgY2FsY3VsYXRlIGZvcmNlcyBpZiBub2RlcyBhcmUgaW4gdGhlIHNhbWUgc2VjdG9yXG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5lZGdlVHlwZS52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgIG5vZGUxID0gZWRnZS50bztcbiAgICAgICAgICAgICAgbm9kZTIgPSBlZGdlLmVkZ2VUeXBlLnZpYTtcbiAgICAgICAgICAgICAgbm9kZTMgPSBlZGdlLmZyb207XG5cbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCAwLjUgKiBlZGdlTGVuZ3RoKTtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMiwgbm9kZTMsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhlICogMS41IGlzIGhlcmUgc28gdGhlIGVkZ2UgbG9va3MgYXMgbGFyZ2UgYXMgYSBzbW9vdGggZWRnZS4gSXQgZG9lcyBub3QgaW5pdGlhbGx5IGJlY2F1c2UgdGhlIHNtb290aCBlZGdlcyB1c2VcbiAgICAgICAgICAgICAgLy8gdGhlIHN1cHBvcnQgbm9kZXMgd2hpY2ggZXhlcnQgYSByZXB1bHNpdmUgZm9yY2Ugb24gdGhlIHRvIGFuZCBmcm9tIG5vZGVzLCBtYWtpbmcgdGhlIGVkZ2UgYXBwZWFyIGxhcmdlci5cbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggKiAxLjUgOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKGVkZ2UuZnJvbSwgZWRnZS50bywgZWRnZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvZGUgYWN0dWFsbHkgcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIGVkZ2VMZW5ndGgpIHtcbiAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCAwLjAxKTsgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuXG4gICAgICB2YXIgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogc3ByaW5nRm9yY2U7IC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvbmUgbm9kZSBpcyBub3QgcGFydCBvZiB0aGUgcGh5c2Npc1xuXG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdLnggKz0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS55ICs9IGZ5O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdLnggLT0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS55IC09IGZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcHJpbmdTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzcHJpbmdmb3JjZXMgb24gdGhlIG5vZGVzLCBhY2NvdW50aW5nIGZvciB0aGUgc3VwcG9ydCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBlZGdlTGVuZ3RoLCBlZGdlO1xuICAgICAgdmFyIGR4LCBkeSwgZngsIGZ5LCBzcHJpbmdGb3JjZSwgZGlzdGFuY2U7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZmFjdG9yID0gMC41O1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlczsgLy8gaW5pdGlhbGl6ZSB0aGUgc3ByaW5nIGZvcmNlIGNvdW50ZXJzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeCA9IDA7XG4gICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z5ID0gMDtcbiAgICAgIH0gLy8gZm9yY2VzIGNhdXNlZCBieSB0aGUgZWRnZXMsIG1vZGVsbGVkIGFzIHNwcmluZ3NcblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaV1dO1xuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICBkeCA9IGVkZ2UuZnJvbS54IC0gZWRnZS50by54O1xuICAgICAgICAgIGR5ID0gZWRnZS5mcm9tLnkgLSBlZGdlLnRvLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UgPT09IDAgPyAwLjAxIDogZGlzdGFuY2U7IC8vIHRoZSAxL2Rpc3RhbmNlIGlzIHNvIHRoZSBmeCBhbmQgZnkgY2FuIGJlIGNhbGN1bGF0ZWQgd2l0aG91dCBzaW5lIG9yIGNvc2luZS5cblxuICAgICAgICAgIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcbiAgICAgICAgICBmeCA9IGR4ICogc3ByaW5nRm9yY2U7XG4gICAgICAgICAgZnkgPSBkeSAqIHNwcmluZ0ZvcmNlO1xuXG4gICAgICAgICAgaWYgKGVkZ2UudG8ubGV2ZWwgIT0gZWRnZS5mcm9tLmxldmVsKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeCAtPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0uc3ByaW5nRnkgLT0gZnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeCArPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeSArPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueCAtPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueSAtPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnggKz0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0ueSArPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbm9ybWFsaXplIHNwcmluZyBmb3JjZXNcblxuXG4gICAgICBzcHJpbmdGb3JjZSA9IDE7XG4gICAgICB2YXIgc3ByaW5nRngsIHNwcmluZ0Z5O1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkID0gbm9kZUluZGljZXNbX2kyXTtcbiAgICAgICAgc3ByaW5nRnggPSBNYXRoLm1pbihzcHJpbmdGb3JjZSwgTWF0aC5tYXgoLXNwcmluZ0ZvcmNlLCBmb3JjZXNbX25vZGVJZF0uc3ByaW5nRngpKTtcbiAgICAgICAgc3ByaW5nRnkgPSBNYXRoLm1pbihzcHJpbmdGb3JjZSwgTWF0aC5tYXgoLXNwcmluZ0ZvcmNlLCBmb3JjZXNbX25vZGVJZF0uc3ByaW5nRnkpKTtcbiAgICAgICAgZm9yY2VzW19ub2RlSWRdLnggKz0gc3ByaW5nRng7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkXS55ICs9IHNwcmluZ0Z5O1xuICAgICAgfSAvLyByZXRhaW4gZW5lcmd5IGJhbGFuY2VcblxuXG4gICAgICB2YXIgdG90YWxGeCA9IDA7XG4gICAgICB2YXIgdG90YWxGeSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQyID0gbm9kZUluZGljZXNbX2kzXTtcbiAgICAgICAgdG90YWxGeCArPSBmb3JjZXNbX25vZGVJZDJdLng7XG4gICAgICAgIHRvdGFsRnkgKz0gZm9yY2VzW19ub2RlSWQyXS55O1xuICAgICAgfVxuXG4gICAgICB2YXIgY29ycmVjdGlvbkZ4ID0gdG90YWxGeCAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcbiAgICAgIHZhciBjb3JyZWN0aW9uRnkgPSB0b3RhbEZ5IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkMyA9IG5vZGVJbmRpY2VzW19pNF07XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueCAtPSBjb3JyZWN0aW9uRng7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueSAtPSBjb3JyZWN0aW9uRnk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBDZW50cmFsIEdyYXZpdHkgU29sdmVyXG4gKi9cbnZhciBDZW50cmFsR3Jhdml0eVNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBmb3JjZXMgZm9yIGVhY2ggbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZHgsIGR5LCBkaXN0YW5jZSwgbm9kZTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgIGR4ID0gLW5vZGUueDtcbiAgICAgICAgZHkgPSAtbm9kZS55O1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7b2JqZWN0PE5vZGUuaWQsIHZpcy5Ob2RlPn0gZm9yY2VzXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAgOiB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgLyBkaXN0YW5jZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDZW50cmFsR3Jhdml0eVNvbHZlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBAYXVnbWVudHMgQmFybmVzSHV0U29sdmVyXG4gKi9cblxudmFyIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXJuZXNIdXRTb2x2ZXIpIHtcbiAgX2luaGVyaXRzKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIsIF9CYXJuZXNIdXRTb2x2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgIF90aGlzLl9ybmcgPSBBbGVhKFwiRk9SQ0UgQVRMQVMgMiBCQVNFRCBSRVBVTFNJT04gU09MVkVSXCIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiB0aGlzLl9ybmcoKTtcbiAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEgJiYgbm9kZS5zaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7IC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuXG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgKiBkZWdyZWUgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMik7XG4gICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXI7XG59KEJhcm5lc0h1dFNvbHZlcik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQGF1Z21lbnRzIENlbnRyYWxHcmF2aXR5U29sdmVyXG4gKi9cblxudmFyIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NlbnRyYWxHcmF2aXR5U29sdmVyKSB7XG4gIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQyKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgKiBAcGFyYW0ge29iamVjdDxOb2RlLmlkLCBOb2RlPn0gZm9yY2VzXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IG5vZGUuZWRnZXMubGVuZ3RoICsgMTtcbiAgICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eSAqIGRlZ3JlZSAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgICBmb3JjZXNbbm9kZS5pZF0ueCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG59KENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuLyoqXG4gKiBUaGUgcGh5c2ljcyBlbmdpbmVcbiAqL1xuXG52YXIgUGh5c2ljc0VuZ2luZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gUGh5c2ljc0VuZ2luZShib2R5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBoeXNpY3NFbmdpbmUpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0ge1xuICAgICAgcGh5c2ljc05vZGVJbmRpY2VzOiBbXSxcbiAgICAgIHBoeXNpY3NFZGdlSW5kaWNlczogW10sXG4gICAgICBmb3JjZXM6IHt9LFxuICAgICAgdmVsb2NpdGllczoge31cbiAgICB9O1xuICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2ltdWxhdGlvbkludGVydmFsID0gMTAwMCAvIDYwO1xuICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICB0aGlzLnByZXZpb3VzU3RhdGVzID0ge307XG4gICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuICAgIHRoaXMuZnJlZXplQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkOyAvLyBwYXJhbWV0ZXJzIGZvciB0aGUgYWRhcHRpdmUgdGltZXN0ZXBcblxuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IDA7XG4gICAgdGhpcy5hZGFwdGl2ZUludGVydmFsID0gMztcbiAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlOyAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBzdGFiaWxpemVcbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTIwMDAsXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjMsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogOTUsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA0LFxuICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTUwLFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wMSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDgsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICBkYW1waW5nOiAwLjQsXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIHJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4yLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDIwMCxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDUsXG4gICAgICAgIG5vZGVEaXN0YW5jZTogMTAwLFxuICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMCxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjAxLFxuICAgICAgICBub2RlRGlzdGFuY2U6IDEyMCxcbiAgICAgICAgZGFtcGluZzogMC4wOVxuICAgICAgfSxcbiAgICAgIG1heFZlbG9jaXR5OiA1MCxcbiAgICAgIG1pblZlbG9jaXR5OiAwLjc1LFxuICAgICAgLy8gcHgvc1xuICAgICAgc29sdmVyOiBcImJhcm5lc0h1dFwiLFxuICAgICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb24gdG8gc3RhYmlsaXplXG4gICAgICAgIHVwZGF0ZUludGVydmFsOiA1MCxcbiAgICAgICAgb25seUR5bmFtaWNFZGdlczogZmFsc2UsXG4gICAgICAgIGZpdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRpbWVzdGVwOiAwLjUsXG4gICAgICBhZGFwdGl2ZVRpbWVzdGVwOiB0cnVlLFxuICAgICAgd2luZDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLnRpbWVzdGVwID0gMC41O1xuICAgIHRoaXMubGF5b3V0RmFpbGVkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBoeXNpY3NFbmdpbmUsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRQaHlzaWNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuaW5pdFBoeXNpY3MoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfbGF5b3V0RmFpbGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMubGF5b3V0RmFpbGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZXNldFBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuXG4gICAgICAgIF90aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGlzYWJsZVBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVzdG9yZVBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zZXRPcHRpb25zKF90aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChfdGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwic3RhcnRTaW11bGF0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnJlYWR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzdG9wU2ltdWxhdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKGZhbHNlKTtcblxuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm9kZXMgYW5kL29yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLCB1cGRhdGUgc2hvcnRjdXQgbGlzdHMuXG4gICAgICAgIF90aGlzLnVwZGF0ZVBoeXNpY3NEYXRhKCk7XG4gICAgICB9KTsgLy8gZGVidWc6IHNob3cgZm9yY2VzXG4gICAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZHJhd0ZvcmNlcyhjdHgpO30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHBoeXNpY3Mgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChbXCJzdGFiaWxpemF0aW9uXCJdLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwic3RhYmlsaXphdGlvblwiKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2luZCA9IHRoaXMub3B0aW9ucy53aW5kO1xuXG4gICAgICAgICAgaWYgKHdpbmQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZC54ICE9PSBcIm51bWJlclwiIHx8IGlzTmFuKHdpbmQueCkpIHtcbiAgICAgICAgICAgICAgd2luZC54ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kLnkgIT09IFwibnVtYmVyXCIgfHwgaXNOYW4od2luZC55KSkge1xuICAgICAgICAgICAgICB3aW5kLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gc2V0IHRoZSB0aW1lc3RlcFxuXG5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWd1cmUgdGhlIGVuZ2luZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gXCJmb3JjZUF0bGFzMkJhc2VkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5mb3JjZUF0bGFzMkJhc2VkO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSBcInJlcHVsc2lvblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVwdWxzaW9uO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbFJlcHVsc2lvbjtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiYXJuZXNIdXRcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5iYXJuZXNIdXQ7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgQmFybmVzSHV0U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGVsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgdGhlIGVuZ2luZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFBoeXNpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBoeXNpY3MoKSB7XG4gICAgICBpZiAodGhpcy5waHlzaWNzRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLCB7fSwgdGhpcy5sYXlvdXRGYWlsZWQpOyAvLyBpZiB0aGUgbGF5b3V0IGZhaWxlZCwgd2UgdXNlIHRoZSBhcHByb3hpbWF0aW9uIGZvciB0aGUgem9vbVxuXG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBzaW11bGF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFNpbXVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTaW11bGF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7IC8vIHdoZW4gdmlzaWJsZSwgYWRhcHRpdml0eSBpcyBkaXNhYmxlZC5cblxuICAgICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTsgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcblxuICAgICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5zaW11bGF0aW9uU3RlcCkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc2ltdWxhdGlvbiwgZm9yY2Ugc3RhYmlsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtaXQ9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BTaW11bGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BTaW11bGF0aW9uKCkge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZpZXdGdW5jdGlvbiBpbnNlcnRzIHRoaXMgc3RlcCBpbnRvIGVhY2ggcmVuZGVyIGxvb3AuIEl0IGNhbGxzIHRoZSBwaHlzaWNzIHRpY2sgYW5kIGhhbmRsZXMgdGhlIGNsZWFudXAgYXQgc3RhYmlsaXplZC5cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2ltdWxhdGlvblN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2ltdWxhdGlvblN0ZXAoKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgcGh5c2ljcyBoYXZlIHNldHRsZWRcbiAgICAgIHZhciBzdGFydFRpbWUgPSBub3ckMSgpO1xuXG4gICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICB2YXIgcGh5c2ljc1RpbWUgPSBub3ckMSgpIC0gc3RhcnRUaW1lOyAvLyBydW4gZG91YmxlIHNwZWVkIGlmIGl0IGlzIGEgbGl0dGxlIGdyYXBoXG5cbiAgICAgIGlmICgocGh5c2ljc1RpbWUgPCAwLjQgKiB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCB8fCB0aGlzLnJ1bkRvdWJsZVNwZWVkID09PSB0cnVlKSAmJiB0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc1RpY2soKTsgLy8gdGhpcyBtYWtlcyBzdXJlIHRoZXJlIGlzIG5vIGppdHRlci4gVGhlIGRlY2lzaW9uIGlzIHRha2VuIG9uY2UgdG8gcnVuIGl0IGF0IGRvdWJsZSBzcGVlZC5cblxuICAgICAgICB0aGlzLnJ1bkRvdWJsZVNwZWVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRyaWdnZXIgdGhlIHN0YWJpbGl6ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Ftb3VudE9mSXRlcmF0aW9ucz10aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFN0YWJpbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdGFiaWxpemVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBhbW91bnRPZkl0ZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnM7XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID4gMSB8fCB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXplZFwiLCB7XG4gICAgICAgICAgICBpdGVyYXRpb25zOiBhbW91bnRPZkl0ZXJhdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzMi5zdGFydGVkU3RhYmlsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzMi5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBmb3Igb25lIHBoeXNpY3MgaXRlcmF0aW9uIGFuZCBtb3ZlIHRoZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwaHlzaWNzU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzU3RlcCgpIHtcbiAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5ub2Rlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBkeW5hbWljIGFkanVzdG1lbnRzIHRvIHRoZSB0aW1lc3RlcCwgYmFzZWQgb24gY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcGh5c2ljc1RpY2soKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RUaW1lU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RUaW1lU3RlcCgpIHtcbiAgICAgIHZhciBmYWN0b3IgPSAxLjI7IC8vIEZhY3RvciBmb3IgaW5jcmVhc2luZyB0aGUgdGltZXN0ZXAgb24gc3VjY2Vzcy5cbiAgICAgIC8vIHdlIGNvbXBhcmUgdGhlIHR3byBzdGVwcy4gaWYgaXQgaXMgYWNjZXB0YWJsZSB3ZSBkb3VibGUgdGhlIHN0ZXAuXG5cbiAgICAgIGlmICh0aGlzLl9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy50aW1lc3RlcCA9IGZhY3RvciAqIHRoaXMudGltZXN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3QsIHdlIGRlY3JlYXNlIHRoZSBzdGVwIHRvIGEgbWluaW11bSBvZiB0aGUgb3B0aW9ucyB0aW1lc3RlcC5cbiAgICAgICAgLy8gaWYgdGhlIGRlY3JlYXNlZCB0aW1lc3RlcCBpcyBzbWFsbGVyIHRoYW4gdGhlIG9wdGlvbnMgc3RlcCwgd2UgZG8gbm90IHJlc2V0IHRoZSBjb3VudGVyXG4gICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IHRoZSBvcHRpb25zIHRpbWVzdGVwIGlzIHN0YWJsZSBlbm91Z2guXG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGVwIC8gZmFjdG9yIDwgdGhpcy5vcHRpb25zLnRpbWVzdGVwKSB7XG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdGltZXN0ZXAgd2FzIGxhcmdlciB0aGFuIDIgdGltZXMgdGhlIG9wdGlvbiBvbmUgd2UgY2hlY2sgdGhlIGFkYXB0aXZpdHkgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCBsYXJnZSBpbnN0YWJpbGl0aWVzIGRvIG5vdCBmb3JtLlxuICAgICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyID0gLTE7IC8vIGNoZWNrIGFnYWluIG5leHQgaXRlcmF0aW9uXG5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gTWF0aC5tYXgodGhpcy5vcHRpb25zLnRpbWVzdGVwLCB0aGlzLnRpbWVzdGVwIC8gZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpbmdsZSBzaW11bGF0aW9uIHN0ZXAgKG9yICd0aWNrJykgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBoeXNpY3NUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBoeXNpY3NUaWNrKCkge1xuICAgICAgdGhpcy5fc3RhcnRTdGFiaWxpemluZygpOyAvLyB0aGlzIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBubyBzdGFydCBldmVudCB3aGVuIHRoZSBuZXR3b3JrIGlzIGFscmVhZHkgc3RhYmxlLlxuXG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHJldHVybjsgLy8gYWRhcHRpdml0eSBtZWFucyB0aGUgdGltZXN0ZXAgYWRhcHRzIHRvIHRoZSBzaXR1YXRpb24sIG9ubHkgYXBwbGljYWJsZSBmb3Igc3RhYmlsaXphdGlvblxuXG4gICAgICBpZiAodGhpcy5hZGFwdGl2ZVRpbWVzdGVwID09PSB0cnVlICYmIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gdGltZXN0ZXAgcmVtYWlucyBzdGFibGUgZm9yIFwiaW50ZXJ2YWxcIiBpdGVyYXRpb25zLlxuICAgICAgICB2YXIgZG9BZGFwdGl2ZSA9IHRoaXMuYWRhcHRpdmVDb3VudGVyICUgdGhpcy5hZGFwdGl2ZUludGVydmFsID09PSAwO1xuXG4gICAgICAgIGlmIChkb0FkYXB0aXZlKSB7XG4gICAgICAgICAgLy8gZmlyc3QgdGhlIGJpZyBzdGVwIGFuZCByZXZlcnQuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDIgKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLnJldmVydCgpOyAvLyBzYXZlcyB0aGUgcmVmZXJlbmNlIHN0YXRlXG4gICAgICAgICAgLy8gbm93IHRoZSBub3JtYWwgc3RlcC4gU2luY2UgdGhpcyBpcyB0aGUgbGFzdCBzdGVwLCBpdCBpcyB0aGUgbW9yZSBzdGFibGUgb25lIGFuZCB3ZSB3aWxsIHRha2UgdGhpcy5cblxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSAwLjUgKiB0aGlzLnRpbWVzdGVwOyAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuXG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLmFkanVzdFRpbWVTdGVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpOyAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHRoaXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zKys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vZGVzIGFuZCBlZGdlcyBjYW4gaGF2ZSB0aGUgcGh5c2ljcyB0b2dnbGVzIG9uIG9yIG9mZi4gQSBjb2xsZWN0aW9uIG9mIGluZGljZXMgaXMgY3JlYXRlZCBoZXJlIHNvIHdlIGNhbiBza2lwIHRoZSBjaGVjayBhbGwgdGhlIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUGh5c2ljc0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGh5c2ljc0RhdGEoKSB7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcyA9IHt9O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMgPSBbXTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7IC8vIGdldCBub2RlIGluZGljZXMgZm9yIHBoeXNpY3NcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGdldCBlZGdlIGluZGljZXMgZm9yIHBoeXNpY3NcblxuXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMucHVzaChlZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZ2V0IHRoZSB2ZWxvY2l0eSBhbmQgdGhlIGZvcmNlcyB2ZWN0b3JcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV07XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW19ub2RlSWRdID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9OyAvLyBmb3JjZXMgY2FuIGJlIHJlc2V0IGJlY2F1c2UgdGhleSBhcmUgcmVjYWxjdWxhdGVkLiBWZWxvY2l0aWVzIGhhdmUgdG8gcGVyc2lzdC5cblxuICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZF0gPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2xlYW4gZGVsZXRlZCBub2RlcyBmcm9tIHRoZSB2ZWxvY2l0eSB2ZWN0b3JcblxuXG4gICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW19ub2RlSWQyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2ZXJ0IHRoZSBzaW11bGF0aW9uIG9uZSBzdGVwLiBUaGlzIGlzIGRvbmUgc28gYWZ0ZXIgc3RhYmlsaXphdGlvbiwgZXZlcnkgbmV3IHN0YXJ0IG9mIHRoZSBzaW11bGF0aW9uIHdpbGwgYWxzbyBzYXkgc3RhYmlsaXplZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJldmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICB2YXIgbm9kZUlkcyA9IGtleXMkNCh0aGlzLnByZXZpb3VzU3RhdGVzKTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG4gICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUlkc1tpXTtcblxuICAgICAgICBpZiAobm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlW25vZGVJZF0gPSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgIHg6IG5vZGVzW25vZGVJZF0ueCxcbiAgICAgICAgICAgICAgICB5OiBub2Rlc1tub2RlSWRdLnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ4O1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0udnk7XG4gICAgICAgICAgICBub2Rlc1tub2RlSWRdLnggPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueDtcbiAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgY29tcGFyZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsdWF0ZVN0ZXBRdWFsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkge1xuICAgICAgdmFyIGR4LCBkeSwgZHBvcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciByZWZlcmVuY2UgPSB0aGlzLnJlZmVyZW5jZVN0YXRlO1xuICAgICAgdmFyIHBvc1RocmVzaG9sZCA9IDAuMztcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMucmVmZXJlbmNlU3RhdGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJlZmVyZW5jZVN0YXRlLCBub2RlSWQpICYmIG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGR4ID0gbm9kZXNbbm9kZUlkXS54IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLng7XG4gICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcbiAgICAgICAgICBkcG9zID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG5cbiAgICAgICAgICBpZiAoZHBvcyA+IHBvc1RocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgbm9kZXMgb25lIHRpbWVzdGVwIGFuZCBjaGVjayBpZiB0aGV5IGFyZSBzdGFiaWxpemVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgIHZhciBhdmVyYWdlTm9kZVZlbG9jaXR5ID0gMDsgLy8gdGhlIHZlbG9jaXR5IHRocmVzaG9sZCAoZW5lcmd5IGluIHRoZSBzeXN0ZW0pIGZvciB0aGUgYWRhcHRpdml0eSB0b2dnbGVcblxuICAgICAgdmFyIHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQgPSA1O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcblxuICAgICAgICB2YXIgbm9kZVZlbG9jaXR5ID0gdGhpcy5fcGVyZm9ybVN0ZXAobm9kZUlkKTsgLy8gc3RhYmlsaXplZCBpcyB0cnVlIGlmIHN0YWJpbGl6ZWQgaXMgdHJ1ZSBhbmQgdmVsb2NpdHkgaXMgc21hbGxlciB0aGFuIHZtaW4gLS0+IGFsbCBub2RlcyBtdXN0IGJlIHN0YWJpbGl6ZWRcblxuXG4gICAgICAgIG1heE5vZGVWZWxvY2l0eSA9IE1hdGgubWF4KG1heE5vZGVWZWxvY2l0eSwgbm9kZVZlbG9jaXR5KTtcbiAgICAgICAgYXZlcmFnZU5vZGVWZWxvY2l0eSArPSBub2RlVmVsb2NpdHk7XG4gICAgICB9IC8vIGV2YWx1YXRpbmcgdGhlIHN0YWJpbGl6ZWQgYW5kIGFkYXB0aXZlVGltZXN0ZXBFbmFibGVkIGNvbmRpdGlvbnNcblxuXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gYXZlcmFnZU5vZGVWZWxvY2l0eSAvIG5vZGVJbmRpY2VzLmxlbmd0aCA8IHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBuZXcgdmVsb2NpdHkgZm9yIGEgY29vcmRpbmF0ZSBkaXJlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ICB2ZWxvY2l0eSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgIHJlZ3VsYXIgZm9yY2UgZm9yIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtICBtYXNzIG9mIGN1cnJlbnQgbm9kZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5ldyB2ZWxvY2l0eSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHYsIGYsIG0pIHtcbiAgICAgIHZhciBkZiA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2OyAvLyBkYW1waW5nIGZvcmNlXG5cbiAgICAgIHZhciBhID0gKGYgLSBkZikgLyBtOyAvLyBhY2NlbGVyYXRpb25cblxuICAgICAgdiArPSBhICogdGhpcy50aW1lc3RlcDsgLy8gUHV0IGEgbGltaXQgb24gdGhlIHZlbG9jaXRpZXMgaWYgaXQgaXMgcmVhbGx5IGhpZ2hcblxuICAgICAgdmFyIG1heFYgPSB0aGlzLm9wdGlvbnMubWF4VmVsb2NpdHkgfHwgMWU5O1xuXG4gICAgICBpZiAoTWF0aC5hYnModikgPiBtYXhWKSB7XG4gICAgICAgIHYgPSB2ID4gMCA/IG1heFYgOiAtbWF4VjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBzdGVwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBuZXcgdmVsb2NpdHkgb2YgZ2l2ZW4gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybVN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1TdGVwKG5vZGVJZCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGVJZF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2luZCkge1xuICAgICAgICBmb3JjZS54ICs9IHRoaXMub3B0aW9ucy53aW5kLng7XG4gICAgICAgIGZvcmNlLnkgKz0gdGhpcy5vcHRpb25zLndpbmQueTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW25vZGVJZF07IC8vIHN0b3JlIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gcmV2ZXJ0XG5cbiAgICAgIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXSA9IHtcbiAgICAgICAgeDogbm9kZS54LFxuICAgICAgICB5OiBub2RlLnksXG4gICAgICAgIHZ4OiB2ZWxvY2l0eS54LFxuICAgICAgICB2eTogdmVsb2NpdHkueVxuICAgICAgfTtcblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS54ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS54LCBmb3JjZS54LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueCArPSB2ZWxvY2l0eS54ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnggPSAwO1xuICAgICAgICB2ZWxvY2l0eS54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS55ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS55LCBmb3JjZS55LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueSArPSB2ZWxvY2l0eS55ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnkgPSAwO1xuICAgICAgICB2ZWxvY2l0eS55ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHkueCwgMikgKyBNYXRoLnBvdyh2ZWxvY2l0eS55LCAyKSk7XG4gICAgICByZXR1cm4gdG90YWxWZWxvY2l0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBpbml0aWFsaXppbmcgYW5kIHN0YWJpbGl6aW5nLCB3ZSBjYW4gZnJlZXplIG5vZGVzIHdpdGggYSBwcmVkZWZpbmVkIHBvc2l0aW9uLlxuICAgICAqIFRoaXMgZ3JlYXRseSBzcGVlZHMgdXAgc3RhYmlsaXphdGlvbiBiZWNhdXNlIG9ubHkgdGhlIHN1cHBvcnRub2RlcyBmb3IgdGhlIHNtb290aEN1cnZlcyBoYXZlIHRvIHNldHRsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZnJlZXplTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZyZWV6ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBpZCkpIHtcbiAgICAgICAgICBpZiAobm9kZXNbaWRdLnggJiYgbm9kZXNbaWRdLnkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZCA9IG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5mcmVlemVDYWNoZVtpZF0gPSB7XG4gICAgICAgICAgICAgIHg6IGZpeGVkLngsXG4gICAgICAgICAgICAgIHk6IGZpeGVkLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmaXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmZyZWV6ZXMgdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGZyb3plbiBieSBfZnJlZXplRGVmaW5lZE5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN0b3JlRnJvemVuTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVGcm96ZW5Ob2RlcygpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgaWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnggPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS54O1xuICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJlZXplQ2FjaGUgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZXJhdGlvbnM9dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9uc11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YWJpbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFiaWxpemUoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpdGVyYXRpb25zID0gdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBzdGFiaWxpemUgbWV0aG9kIG5lZWRzIGEgbnVtZXJpYyBhbW91bnQgb2YgaXRlcmF0aW9ucy4gU3dpdGNoaW5nIHRvIGRlZmF1bHQ6IFwiLCBpdGVyYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBlbmFibGUgYWRhcHRpdmUgdGltZXN0ZXBzXG5cblxuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlVGltZXN0ZXA7IC8vIHRoaXMgc2V0cyB0aGUgd2lkdGggb2YgYWxsIG5vZGVzIGluaXRpYWxseSB3aGljaCBjb3VsZCBiZSByZXF1aXJlZCBmb3IgdGhlIGF2b2lkT3ZlcmxhcFxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpOyAvLyBzdG9wIHRoZSByZW5kZXIgbG9vcFxuXG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTsgLy8gYmxvY2sgcmVkcmF3IHJlcXVlc3RzXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYmxvY2tSZWRyYXdcIik7XG4gICAgICB0aGlzLnRhcmdldEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zOyAvLyBzdGFydCB0aGUgc3RhYmlsaXphdGlvblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24ub25seUR5bmFtaWNFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9mcmVlemVOb2RlcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcblxuICAgICAgc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc3RhYmlsaXphdGlvbkJhdGNoKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgbm90IGFscmVhZHkgc3RhYmlsaXppbmcsIHN0YXJ0IGl0IGFuZCBlbWl0IGEgc3RhcnQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzdGFiaWxpemF0aW9uIHN0YXJ0ZWQgd2l0aCB0aGlzIGNhbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0U3RhYmlsaXppbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U3RhYmlsaXppbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U3RhYmlsaXppbmdcIik7XG4gICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmUgYmF0Y2ggb2Ygc3RhYmlsaXphdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFiaWxpemF0aW9uQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YWJpbGl6YXRpb25CYXRjaCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcnVubmluZyA9IGZ1bmN0aW9uIHJ1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuc3RhYmlsaXplZCA9PT0gZmFsc2UgJiYgX3RoaXM0LnN0YWJpbGl6YXRpb25JdGVyYXRpb25zIDwgX3RoaXM0LnRhcmdldEl0ZXJhdGlvbnM7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2VuZFByb2dyZXNzID0gZnVuY3Rpb24gc2VuZFByb2dyZXNzKCkge1xuICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemF0aW9uUHJvZ3Jlc3NcIiwge1xuICAgICAgICAgIGl0ZXJhdGlvbnM6IF90aGlzNC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyxcbiAgICAgICAgICB0b3RhbDogX3RoaXM0LnRhcmdldEl0ZXJhdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc3RhcnRTdGFiaWxpemluZygpKSB7XG4gICAgICAgIHNlbmRQcm9ncmVzcygpOyAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgc3RhcnQgZXZlbnQuXG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIHdoaWxlIChydW5uaW5nKCkgJiYgY291bnQgPCB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG5cbiAgICAgIHNlbmRQcm9ncmVzcygpO1xuXG4gICAgICBpZiAocnVubmluZygpKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgICAgc2V0VGltZW91dCQxKGJpbmQkNihfY29udGV4dDIgPSB0aGlzLl9zdGFiaWxpemF0aW9uQmF0Y2gpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcCB1cCB0aGUgc3RhYmlsaXphdGlvbiwgZml0IGFuZCBlbWl0IHRoZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmFsaXplU3RhYmlsaXphdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluYWxpemVTdGFiaWxpemF0aW9uKCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hbGxvd1JlZHJhd1wiKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmZpdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24ub25seUR5bmFtaWNFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZXN0b3JlRnJvemVuTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YWJpbGl6YXRpb25JdGVyYXRpb25zRG9uZVwiKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgREVCVUdHSU5HIEJFTE9XICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogRGVidWcgZnVuY3Rpb24gdGhhdCBkaXNwbGF5IGFycm93cyBmb3IgdGhlIGZvcmNlcyBjdXJyZW50bHkgYWN0aXZlIGluIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgd2hlbiBkZWJ1Z2dpbmcgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdGb3JjZXMoY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRleF07XG4gICAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIGZhY3RvciA9IDIwO1xuICAgICAgICB2YXIgY29sb3JGYWN0b3IgPSAwLjAzO1xuICAgICAgICB2YXIgZm9yY2VTaXplID0gTWF0aC5zcXJ0KE1hdGgucG93KGZvcmNlLngsIDIpICsgTWF0aC5wb3coZm9yY2UueCwgMikpO1xuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KDUsIGZvcmNlU2l6ZSksIDE1KTtcbiAgICAgICAgdmFyIGFycm93U2l6ZSA9IDMgKiBzaXplO1xuICAgICAgICB2YXIgY29sb3IgPSBIU1ZUb0hleCgoMTgwIC0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgY29sb3JGYWN0b3IgKiBmb3JjZVNpemUpKSAqIDE4MCkgLyAzNjAsIDEsIDEpO1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogbm9kZS54ICsgZmFjdG9yICogZm9yY2UueCxcbiAgICAgICAgICB5OiBub2RlLnkgKyBmYWN0b3IgKiBmb3JjZS55XG4gICAgICAgIH07XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzaXplO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKG5vZGUueCwgbm9kZS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGZvcmNlLnksIGZvcmNlLngpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIEVuZFBvaW50cy5kcmF3KGN0eCwge1xuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIixcbiAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgIGxlbmd0aDogYXJyb3dTaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbGwoY3R4KS5jYWxsKGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBoeXNpY3NFbmdpbmU7XG59KCk7XG5cbi8qKlxuICogVXRpbGl0eSBDbGFzc1xuICovXG5cbnZhciBOZXR3b3JrVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBOZXR3b3JrVXRpbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya1V0aWwpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmsgY29uc2lkZXJpbmcgdGhlIGJvdW5kaW5nIGJveGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBhbGxOb2Rlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICogQHN0YXRpY1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOZXR3b3JrVXRpbCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0UmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsTm9kZXMpIHtcbiAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICAgIG1heFkgPSAtMWU5LFxuICAgICAgICAgIG1pblggPSAxZTksXG4gICAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgICAgbm9kZTtcblxuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG5cbiAgICAgICAgICBpZiAobWluWCA+IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gubGVmdCkge1xuICAgICAgICAgICAgbWluWCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gubGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4WCA8IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQpIHtcbiAgICAgICAgICAgIG1heFggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3ApIHtcbiAgICAgICAgICAgIG1pblkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG5cblxuICAgICAgICAgIGlmIChtYXhZIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20pIHtcbiAgICAgICAgICAgIG1heFkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgbWluWSA9IDAsIG1heFkgPSAwLCBtaW5YID0gMCwgbWF4WCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIG1heFk6IG1heFlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IGFsbE5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IFtzcGVjaWZpY05vZGVzPVtdXVxuICAgICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRSYW5nZUNvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VDb3JlKGFsbE5vZGVzKSB7XG4gICAgICB2YXIgc3BlY2lmaWNOb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICAgIG5vZGU7XG5cbiAgICAgIGlmIChzcGVjaWZpY05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IGFsbE5vZGVzW3NwZWNpZmljTm9kZXNbaV1dO1xuXG4gICAgICAgICAgaWYgKG1pblggPiBub2RlLngpIHtcbiAgICAgICAgICAgIG1pblggPSBub2RlLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heFggPCBub2RlLngpIHtcbiAgICAgICAgICAgIG1heFggPSBub2RlLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pblkgPiBub2RlLnkpIHtcbiAgICAgICAgICAgIG1pblkgPSBub2RlLnk7XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuXG5cbiAgICAgICAgICBpZiAobWF4WSA8IG5vZGUueSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUueTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgbWluWSA9IDAsIG1heFkgPSAwLCBtaW5YID0gMCwgbWF4WCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIG1heFk6IG1heFlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYW5nZSA9IHttaW5YOiBtaW5YLCBtYXhYOiBtYXhYLCBtaW5ZOiBtaW5ZLCBtYXhZOiBtYXhZfTtcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDZW50ZXIocmFuZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAuNSAqIChyYW5nZS5tYXhYICsgcmFuZ2UubWluWCksXG4gICAgICAgIHk6IDAuNSAqIChyYW5nZS5tYXhZICsgcmFuZ2UubWluWSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgcmV0dXJucyBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9yIG9wdGlvbnMgb2YgdGhlIGVkZ2Ugb3Igbm9kZSB0byBiZSB1c2VkIGZvciBjb25zdHJ1Y3Rpb24gb2YgbmV3IGVkZ2VzIG9yIGNoZWNrIGZ1bmN0aW9ucyBmb3IgbmV3IG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSXRlbX0gaXRlbVxuICAgICAqIEBwYXJhbSB7J25vZGUnfHVuZGVmaW5lZH0gdHlwZVxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVPcHRpb25zKGl0ZW0sIHR5cGUpIHtcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0ge307XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICAgICAgZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBpdGVtLm9wdGlvbnMsIHRydWUpO1xuICAgICAgICBjbG9uZWRPcHRpb25zLnggPSBpdGVtLng7XG4gICAgICAgIGNsb25lZE9wdGlvbnMueSA9IGl0ZW0ueTtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy5hbW91bnRPZkNvbm5lY3Rpb25zID0gaXRlbS5lZGdlcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZWRPcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOZXR3b3JrVXRpbDtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIENsdXN0ZXIgaXMgYSBzcGVjaWFsIE5vZGUgdGhhdCBhbGxvd3MgYSBncm91cCBvZiBOb2RlcyBwb3NpdGlvbmVkIGNsb3NlbHkgdG9nZXRoZXJcbiAqIHRvIGJlIHJlcHJlc2VudGVkIGJ5IGEgc2luZ2xlIENsdXN0ZXIgTm9kZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZVxuICovXG5cbnZhciBDbHVzdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoQ2x1c3RlciwgX05vZGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMShDbHVzdGVyKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheS48SFRNTEltYWdlRWxlbWVudD59aW1hZ2VsaXN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwbGlzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdE9wdGlvbnMgICAgIEdsb2JhbCBkZWZhdWx0IG9wdGlvbnMgZm9yIG5vZGVzXG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbHVzdGVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICBfdGhpcy5pc0NsdXN0ZXIgPSB0cnVlO1xuICAgIF90aGlzLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgX3RoaXMuY29udGFpbmVkRWRnZXMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZmVyIGNoaWxkIGNsdXN0ZXIgZGF0YSB0byBjdXJyZW50IGFuZCBkaXNjb25uZWN0IHRoZSBjaGlsZCBjbHVzdGVyLlxuICAgKlxuICAgKiBQbGVhc2UgY29uc3VsdCB0aGUgaGVhZGVyIGNvbW1lbnQgaW4gJ0NsdXN0ZXJpbmcuanMnIGZvciB0aGUgZmllbGRzIHNldCBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNoaWxkQ2x1c3RlcklkICBpZCBvZiBjaGlsZCBjbHVzdGVyIHRvIG9wZW5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2x1c3RlciwgW3tcbiAgICBrZXk6IFwiX29wZW5DaGlsZENsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5DaGlsZENsdXN0ZXIoY2hpbGRDbHVzdGVySWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGRDbHVzdGVyID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkQ2x1c3RlcklkXTtcblxuICAgICAgaWYgKHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZSB3aXRoIGlkOiBcIiArIGNoaWxkQ2x1c3RlcklkICsgXCIgbm90IGluIGN1cnJlbnQgY2x1c3RlclwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZENsdXN0ZXIuaXNDbHVzdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGUgd2l0aCBpZDogXCIgKyBjaGlsZENsdXN0ZXJJZCArIFwiIGlzIG5vdCBhIGNsdXN0ZXJcIik7XG4gICAgICB9IC8vIERpc2Nvbm5lY3QgY2hpbGQgY2x1c3RlciBmcm9tIGN1cnJlbnQgY2x1c3RlclxuXG5cbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRhaW5lZE5vZGVzW2NoaWxkQ2x1c3RlcklkXTtcbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuY29udGFpbmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9KTsgLy8gVHJhbnNmZXIgbm9kZXMgYW5kIGVkZ2VzXG5cbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuY29udGFpbmVkTm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRhaW5lZE5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuY29udGFpbmVkTm9kZXMgPSB7fTtcbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuY29udGFpbmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRhaW5lZEVkZ2VzW2VkZ2VJZF0gPSBlZGdlO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuY29udGFpbmVkRWRnZXMgPSB7fTsgLy8gVHJhbnNmZXIgZWRnZXMgd2l0aGluIGNsdXN0ZXIgZWRnZXMgd2hpY2ggYXJlIGNsdXN0ZXJlZFxuXG4gICAgICBmb3JFYWNoJDEoY2hpbGRDbHVzdGVyLmVkZ2VzLCBmdW5jdGlvbiAoY2x1c3RlckVkZ2UpIHtcbiAgICAgICAgZm9yRWFjaCQxKF90aGlzMi5lZGdlcywgZnVuY3Rpb24gKHBhcmVudENsdXN0ZXJFZGdlKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0LCBfY29udGV4dDI7XG5cbiAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBzaW5nbGUgY2x1c3RlcmluZyBlZGdlXG4gICAgICAgICAgLy8gTm90IHRlc3RlZCBoZXJlXG4gICAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihfY29udGV4dCA9IHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzKS5jYWxsKF9jb250ZXh0LCBjbHVzdGVyRWRnZS5pZCk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgICAgZm9yRWFjaCQxKGNsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLCBmdW5jdGlvbiAoc3JjSWQpIHtcbiAgICAgICAgICAgIHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goc3JjSWQpOyAvLyBNYWludGFpbiBjb3JyZWN0IGJvb2trZWVwaW5nIGZvciB0cmFuc2ZlcnJlZCBlZGdlXG5cbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVkZ2VzW3NyY0lkXS5lZGdlUmVwbGFjZWRCeUlkID0gcGFyZW50Q2x1c3RlckVkZ2UuaWQ7XG4gICAgICAgICAgfSk7IC8vIFJlbW92ZSBjbHVzdGVyIGVkZ2UgZnJvbSBwYXJlbnQgY2x1c3RlciBlZGdlXG5cbiAgICAgICAgICBzcGxpY2UkMShfY29udGV4dDIgPSBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcykuY2FsbChfY29udGV4dDIsIGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkQ2x1c3Rlci5lZGdlcyA9IFtdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbHVzdGVyO1xufShOb2RlKTtcblxuLyoqXG4gKiBUaGUgY2x1c3RlcmluZyBlbmdpbmVcbiAqL1xuXG52YXIgQ2x1c3RlckVuZ2luZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gQ2x1c3RlckVuZ2luZShib2R5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbHVzdGVyRW5naW5lKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jbHVzdGVyZWROb2RlcyA9IHt9OyAvLyBrZXk6IG5vZGUgaWQsIHZhbHVlOiB7IGNsdXN0ZXJJZDogPGlkIG9mIGNsdXN0ZXI+LCBub2RlOiA8bm9kZSBpbnN0YW5jZT59XG5cbiAgICB0aGlzLmNsdXN0ZXJlZEVkZ2VzID0ge307IC8vIGtleTogZWRnZSBpZCwgdmFsdWU6IHJlc3RvcmUgaW5mb3JtYXRpb24gZm9yIGdpdmVuIGVkZ2VcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldERhdGFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZEVkZ2VzID0ge307XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBodWJzaXplXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENsdXN0ZXJFbmdpbmUsIFt7XG4gICAga2V5OiBcImNsdXN0ZXJCeUh1YnNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5SHVic2l6ZShodWJzaXplLCBvcHRpb25zKSB7XG4gICAgICBpZiAoaHVic2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YoaHVic2l6ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhodWJzaXplKTtcbiAgICAgICAgaHVic2l6ZSA9IHRoaXMuX2dldEh1YlNpemUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVzVG9DbHVzdGVyID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKG5vZGUuZWRnZXMubGVuZ3RoID49IGh1YnNpemUpIHtcbiAgICAgICAgICBub2Rlc1RvQ2x1c3Rlci5wdXNoKG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlc1RvQ2x1c3Rlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVzVG9DbHVzdGVyW19pXSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGxvb3Agb3ZlciBhbGwgbm9kZXMsIGNoZWNrIGlmIHRoZXkgYWRoZXJlIHRvIHRoZSBjb25kaXRpb24gYW5kIGNsdXN0ZXIgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIGNsdXN0ZXJCeU5vZGVEYXRhIHdpdGhvdXQgYSBqb2luQ29uZGl0aW9uIGZ1bmN0aW9uIGluIHRoZSBvcHRpb25zLlwiKTtcbiAgICAgIH0gLy8gY2hlY2sgaWYgdGhlIG9wdGlvbnMgb2JqZWN0IGlzIGZpbmUsIGFwcGVuZCBpZiBuZWVkZWRcblxuXG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307IC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMgJiYgb3B0aW9ucy5qb2luQ29uZGl0aW9uKG5vZGUub3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSBub2RlOyAvLyBjb2xsZWN0IHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcblxuICAgICAgICAgIGZvckVhY2gkMShub2RlLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IFggZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlQ291bnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnlFZGdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5RWRnZUNvdW50KGVkZ2VDb3VudCwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICAgIHZhciB1c2VkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBlZGdlLCBlZGdlcywgcmVsZXZhbnRFZGdlQ291bnQ7IC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG4gICAgICAgIHZhciBub2RlSWQgPSBfdGhpczMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdOyAvLyBpZiB0aGlzIG5vZGUgaXMgYWxyZWFkeSB1c2VkIGluIGFub3RoZXIgY2x1c3RlciB0aGlzIHNlc3Npb24sIHdlIGRvIG5vdCBoYXZlIHRvIHJlLWV2YWx1YXRlIGl0LlxuXG4gICAgICAgIGlmICh1c2VkTm9kZXNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQgPSAwO1xuICAgICAgICAgIGVkZ2VzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGVkZ2UgPSBub2RlLmVkZ2VzW2pdO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCAhPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHRoaXMgbm9kZSBxdWFsaWZpZXMsIHdlIGNvbGxlY3QgaXRzIG5laWdoYm91cnMgdG8gc3RhcnQgdGhlIGNsdXN0ZXJpbmcgcHJvY2Vzcy5cblxuXG4gICAgICAgICAgaWYgKHJlbGV2YW50RWRnZUNvdW50ID09PSBlZGdlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBjaGVja0pvaW5Db25kaXRpb24gPSBmdW5jdGlvbiBjaGVja0pvaW5Db25kaXRpb24obm9kZSkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuam9pbkNvbmRpdGlvbihjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnYXRoZXJpbmdTdWNjZXNzZnVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGVkZ2VzLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICBlZGdlID0gZWRnZXNbX2pdO1xuXG4gICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IF90aGlzMy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgbm9kZUlkKTsgLy8gYWRkIHRoZSBub2RlcyB0byB0aGUgbGlzdCBieSB0aGUgam9pbiBjb25kaXRpb24uXG5cblxuICAgICAgICAgICAgICBpZiAoY2hlY2tKb2luQ29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IF90aGlzMy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB1c2VkTm9kZXNbbm9kZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBub2RlIGRvZXMgbm90IHF1YWxpZnkgYWZ0ZXIgYWxsLlxuICAgICAgICAgICAgICAgIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBhZGQgdG8gdGhlIGNsdXN0ZXIgcXVldWVcblxuXG4gICAgICAgICAgICBpZiAoa2V5cyQ0KGNoaWxkTm9kZXNPYmopLmxlbmd0aCA+IDAgJiYga2V5cyQ0KGNoaWxkRWRnZXNPYmopLmxlbmd0aCA+IDAgJiYgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2VhcmNoIGZvciBjbHVzdGVyIGRhdGEgdGhhdCBjb250YWlucyBhbnkgb2YgdGhlIG5vZGUgaWQnc1xuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBubyBqb2luQ29uZGl0aW9uLCBvdGhlcndpc2UgcmV0dXJuIHZhbHVlIG9mIGpvaW5Db25kaXRpb25cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIHZhciBmaW5kQ2x1c3RlckRhdGEgPSBmdW5jdGlvbiBmaW5kQ2x1c3RlckRhdGEoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVycy5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNsdXN0ZXIgY29udGFpbmluZyBhbnkgb2YgdGhlIG5vZGUgaWQnc1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyc1tuXS5ub2Rlc1ttXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfTsgLy8gSWYgYW55IG9mIHRoZSBmb3VuZCBub2RlcyBpcyBwYXJ0IG9mIGEgY2x1c3RlciBmb3VuZCBpbiB0aGlzIG1ldGhvZCxcbiAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjdXJyZW50IHZhbHVlcyB0byB0aGF0IGNsdXN0ZXJcblxuXG4gICAgICAgICAgICAgIHZhciBmb3VuZENsdXN0ZXIgPSBmaW5kQ2x1c3RlckRhdGEoKTtcblxuICAgICAgICAgICAgICBpZiAoZm91bmRDbHVzdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbm9kZXMgdG8gZm91bmQgY2x1c3RlciBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3Rlci5ub2Rlc1ttXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2x1c3Rlci5ub2Rlc1ttXSA9IGNoaWxkTm9kZXNPYmpbbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBBZGQgZWRnZXMgdG8gZm91bmQgY2x1c3RlciwgaWYgbm90IHByZXNlbnRcblxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX20gaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3Rlci5lZGdlc1tfbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIuZWRnZXNbX21dID0gY2hpbGRFZGdlc09ialtfbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjbHVzdGVyIGdyb3VwXG4gICAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBub2RlczogY2hpbGROb2Rlc09iaixcbiAgICAgICAgICAgICAgICAgIGVkZ2VzOiBjaGlsZEVkZ2VzT2JqXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjbHVzdGVycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHRoaXMuX2NsdXN0ZXIoY2x1c3RlcnNbX2kyXS5ub2RlcywgY2x1c3RlcnNbX2kyXS5lZGdlcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgMSBlZGdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyT3V0bGllcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3Rlck91dGxpZXJzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDEsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgMiBlZGdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnJpZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnJpZGdlcyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgyLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHN1Y2sgYWxsIGNvbm5lY3RlZCBub2RlcyBvZiBhIG5vZGUgaW50byB0aGUgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3RlckJ5Q29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICAgIC8vIGtpbGwgY29uZGl0aW9uc1xuICAgICAgaWYgKG5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5vZGVJZCBzdXBwbGllZCB0byBjbHVzdGVyQnlDb25uZWN0aW9uIVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGVJZCBnaXZlbiB0byBjbHVzdGVyQnlDb25uZWN0aW9uIGRvZXMgbm90IGV4aXN0IVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucywgbm9kZSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IG5vZGUueDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gbm9kZS55O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZCA9IHt9O1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC54ID0gbm9kZS5vcHRpb25zLmZpeGVkLng7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnkgPSBub2RlLm9wdGlvbnMuZml4ZWQueTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG4gICAgICB2YXIgcGFyZW50Tm9kZUlkID0gbm9kZS5pZDtcbiAgICAgIHZhciBwYXJlbnRDbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgY2hpbGROb2Rlc09ialtwYXJlbnROb2RlSWRdID0gbm9kZTsgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIHBhcmVudE5vZGVJZCk7IC8vIGlmIHRoZSBjaGlsZCBub2RlIGlzIG5vdCBpbiBhIGNsdXN0ZXJcblxuXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVJZCAhPT0gcGFyZW50Tm9kZUlkKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgb3B0aW9ucyBhbmQgaW5zZXJ0IHNvbWUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgY291bGQgYmUgaW50ZXJlc3RpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24ocGFyZW50Q2xvbmVkT3B0aW9ucywgY2hpbGRDbG9uZWRPcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzd2FsbG93IHRoZSBlZGdlIGlmIGl0IGlzIHNlbGYtcmVmZXJlbmNpbmcuXG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGROb2RlSURzID0gbWFwJDMoX2NvbnRleHQgPSBrZXlzJDQoY2hpbGROb2Rlc09iaikpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlXS5pZDtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBjaGlsZE5vZGVLZXkgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBjaGlsZE5vZGVLZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlS2V5XTtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNoaWxkTm9kZS5lZGdlcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgIHZhciBjaGlsZEVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbeV07XG5cbiAgICAgICAgICBpZiAoaW5kZXhPZihjaGlsZE5vZGVJRHMpLmNhbGwoY2hpbGROb2RlSURzLCB0aGlzLl9nZXRDb25uZWN0ZWRJZChjaGlsZEVkZ2UsIGNoaWxkTm9kZS5pZCkpID4gLTEpIHtcbiAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbY2hpbGRFZGdlLmlkXSA9IGNoaWxkRWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgZWRnZXMgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBjbHVzdGVyXG4gICAgICogSXQgbG9va3MgZm9yIGVkZ2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgbm9kZXMgZnJvbSB0aGUgXCJvdXRzaWRlJyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e05vZGUuaWQ6IHZpcy5Ob2RlfX0gY2hpbGROb2Rlc09ialxuICAgICAqIEBwYXJhbSB7e3Zpcy5FZGdlLmlkOiB2aXMuRWRnZX19IGNoaWxkRWRnZXNPYmpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJFZGdlUHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ2x1c3RlckVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDbHVzdGVyRWRnZXMoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBlZGdlLCBjaGlsZE5vZGVJZCwgY2hpbGROb2RlLCB0b0lkLCBmcm9tSWQsIG90aGVyTm9kZUlkOyAvLyBsb29wIG92ZXIgYWxsIGNoaWxkIG5vZGVzIGFuZCB0aGVpciBlZGdlcyB0byBmaW5kIGVkZ2VzIGdvaW5nIG91dCBvZiB0aGUgY2x1c3RlclxuICAgICAgLy8gdGhlc2UgZWRnZXMgd2lsbCBiZSByZXBsYWNlZCBieSBjbHVzdGVyRWRnZXMuXG5cbiAgICAgIHZhciBjaGlsZEtleXMgPSBrZXlzJDQoY2hpbGROb2Rlc09iaik7XG5cbiAgICAgIHZhciBjcmVhdGVFZGdlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVJZCA9IGNoaWxkS2V5c1tpXTtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF07IC8vIGNvbnN0cnVjdCBuZXcgZWRnZXMgZnJvbSB0aGUgY2x1c3RlciB0byBvdGhlcnNcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkTm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbal07IC8vIHdlIG9ubHkgaGFuZGxlIGVkZ2VzIHRoYXQgYXJlIHZpc2libGUgdG8gdGhlIHN5c3RlbSwgbm90IHRoZSBkaXNhYmxlZCBvbmVzIGZyb20gdGhlIGNsdXN0ZXJpbmcgcHJvY2Vzcy5cblxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgXCJoaWRkZW5cIiBsaXN0XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBmcm9tIGFuZCB0by5cbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBjaGlsZE5vZGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkb3VibGUgZXF1YWxzIGJlY2F1c2UgaW50cyBhbmQgc3RyaW5ncyBjYW4gYmUgaW50ZXJjaGFuZ2VkIGhlcmUuXG4gICAgICAgICAgICAgICAgdG9JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSBlZGdlLmZyb21JZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IGZyb21JZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0lkID0gZWRnZS50b0lkO1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IHRvSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gT25seSBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIG91dHdhcmRzIGFyZSBiZWluZyByZXBsYWNlZC5cblxuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2Rlc09ialtvdGhlck5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjcmVhdGVFZGdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgICAgICAgIGZyb21JZDogZnJvbUlkLFxuICAgICAgICAgICAgICAgIHRvSWQ6IHRvSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vXG4gICAgICAvLyBIZXJlIHdlIGFjdHVhbGx5IGNyZWF0ZSB0aGUgcmVwbGFjZW1lbnQgZWRnZXMuXG4gICAgICAvL1xuICAgICAgLy8gV2UgY291bGQgbm90IGRvIHRoaXMgaW4gdGhlIGxvb3AgYWJvdmUgYXMgdGhlIGNyZWF0aW9uIHByb2Nlc3NcbiAgICAgIC8vIHdvdWxkIGFkZCBhbiBlZGdlIHRvIHRoZSBlZGdlcyBhcnJheSB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIuXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogYSBjbHVzdGVyZWQgZWRnZSBjYW4gaGF2ZSBtdWx0aXBsZSBiYXNlIGVkZ2VzIVxuICAgICAgLy9cblxuXG4gICAgICB2YXIgbmV3RWRnZXMgPSBbXTtcbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIGNsdXN0ZXIgZWRnZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBjcmVhdGVkIGVkZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt2aXMuRWRnZX0gY3JlYXRlZEVkZ2VcbiAgICAgICAqIEByZXR1cm5zIHt2aXMuRWRnZX1cbiAgICAgICAqL1xuXG4gICAgICB2YXIgZ2V0TmV3RWRnZSA9IGZ1bmN0aW9uIGdldE5ld0VkZ2UoY3JlYXRlZEVkZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbmV3RWRnZXMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBuZXdFZGdlID0gbmV3RWRnZXNbX2oyXTsgLy8gV2UgcmVwbGFjZSBib3RoIHRvIGFuZCBmcm9tIGVkZ2VzIHdpdGggYSBzaW5nbGUgY2x1c3RlciBlZGdlXG5cbiAgICAgICAgICB2YXIgbWF0Y2hUb0RpcmVjdGlvbiA9IGNyZWF0ZWRFZGdlLmZyb21JZCA9PT0gbmV3RWRnZS5mcm9tSWQgJiYgY3JlYXRlZEVkZ2UudG9JZCA9PT0gbmV3RWRnZS50b0lkO1xuICAgICAgICAgIHZhciBtYXRjaEZyb21EaXJlY3Rpb24gPSBjcmVhdGVkRWRnZS5mcm9tSWQgPT09IG5ld0VkZ2UudG9JZCAmJiBjcmVhdGVkRWRnZS50b0lkID09PSBuZXdFZGdlLmZyb21JZDtcblxuICAgICAgICAgIGlmIChtYXRjaFRvRGlyZWN0aW9uIHx8IG1hdGNoRnJvbURpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBjcmVhdGVFZGdlcy5sZW5ndGg7IF9qMysrKSB7XG4gICAgICAgIHZhciBjcmVhdGVkRWRnZSA9IGNyZWF0ZUVkZ2VzW19qM107XG4gICAgICAgIHZhciBfZWRnZSA9IGNyZWF0ZWRFZGdlLmVkZ2U7XG4gICAgICAgIHZhciBuZXdFZGdlID0gZ2V0TmV3RWRnZShjcmVhdGVkRWRnZSk7XG5cbiAgICAgICAgaWYgKG5ld0VkZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBjbHVzdGVyZWQgZWRnZSBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICAgICAgbmV3RWRnZSA9IHRoaXMuX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UoY3JlYXRlZEVkZ2UuZnJvbUlkLCBjcmVhdGVkRWRnZS50b0lkLCBfZWRnZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBuZXdFZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMucHVzaChfZWRnZS5pZCk7XG4gICAgICAgIH0gLy8gYWxzbyByZWZlcmVuY2UgdGhlIG5ldyBlZGdlIGluIHRoZSBvbGQgZWRnZVxuXG5cbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW19lZGdlLmlkXS5lZGdlUmVwbGFjZWRCeUlkID0gbmV3RWRnZS5pZDsgLy8gaGlkZSB0aGUgcmVwbGFjZWQgZWRnZVxuXG4gICAgICAgIHRoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKF9lZGdlKTtcblxuICAgICAgICBfZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3MgdGhlIG9wdGlvbnMgdGhhdCBjYW4gYmUgc3VwcGxpZWQgdG8gdGhlIGRpZmZlcmVudCBjbHVzdGVyIGZ1bmN0aW9uc1xuICAgICAqIGZvciBjZXJ0YWluIGZpZWxkcyBhbmQgaW5zZXJ0cyBkZWZhdWx0cyBpZiBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja09wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrT3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgIGNoaWxkTm9kZXNPYmogICAgICAgICB8IG9iamVjdCB3aXRoIG5vZGUgb2JqZWN0cywgaWQgYXMga2V5cywgc2FtZSBhcyBjaGlsZE5vZGVzIGV4Y2VwdCBpdCBhbHNvIGNvbnRhaW5zIGEgc291cmNlIG5vZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgY2hpbGRFZGdlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggZWRnZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gICAgIG9wdGlvbnMgICAgICAgICAgICAgICB8IG9iamVjdCB3aXRoIHtjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcywgcHJvY2Vzc1Byb3BlcnRpZXN9XG4gICAgICogQHBhcmFtIHtib29sZWFufSAgIHJlZnJlc2hEYXRhIHwgd2hlbiB0cnVlLCBkbyBub3Qgd3JhcCB1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgICAvLyBSZW1vdmUgbm9kZXMgd2hpY2ggYXJlIGFscmVhZHkgY2x1c3RlcmVkXG4gICAgICB2YXIgdG1wTm9kZXNUb1JlbW92ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXNPYmosIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRtcE5vZGVzVG9SZW1vdmUucHVzaChub2RlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRtcE5vZGVzVG9SZW1vdmUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgZGVsZXRlIGNoaWxkTm9kZXNPYmpbdG1wTm9kZXNUb1JlbW92ZVtuXV07XG4gICAgICB9IC8vIGtpbGwgY29uZGl0aW9uOiBubyBub2RlcyBkb24ndCBib3RoZXJcblxuXG4gICAgICBpZiAoa2V5cyQ0KGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gYWxsb3cgY2x1c3RlcnMgb2YgMSBpZiBvcHRpb25zIGFsbG93XG5cblxuICAgICAgaWYgKGtleXMkNChjaGlsZE5vZGVzT2JqKS5sZW5ndGggPT0gMSAmJiBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyICE9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0gZGVlcEV4dGVuZCh7fSwgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMpOyAvLyBjb25zdHJ1Y3QgdGhlIGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuXG4gICAgICBpZiAob3B0aW9ucy5wcm9jZXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGdldCB0aGUgY2hpbGROb2RlIG9wdGlvbnNcbiAgICAgICAgdmFyIGNoaWxkTm9kZXNPcHRpb25zID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBfbm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoY2hpbGROb2Rlc09ialtfbm9kZUlkXSk7XG4gICAgICAgICAgICBjaGlsZE5vZGVzT3B0aW9ucy5wdXNoKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBnZXQgY2x1c3RlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIGNoaWxkTm9kZXNcblxuXG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZEVkZ2VzT2JqLCBlZGdlSWQpKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBjbHVzdGVyIGVkZ2VzIHdpbGwgYmUgcmVtb3ZlZCBvbiBjcmVhdGlvbiBvZiB0aGUgY2x1c3Rlci5cbiAgICAgICAgICAgIGlmIChlZGdlSWQuc3Vic3RyKDAsIDEyKSAhPT0gXCJjbHVzdGVyRWRnZTpcIikge1xuICAgICAgICAgICAgICB2YXIgX2Nsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoY2hpbGRFZGdlc09ialtlZGdlSWRdLCBcImVkZ2VcIik7XG5cbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09wdGlvbnMucHVzaChfY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9jZXNzUHJvcGVydGllcyhjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNoaWxkTm9kZXNPcHRpb25zLCBjaGlsZEVkZ2VzT3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFjbHVzdGVyTm9kZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvY2Vzc1Byb3BlcnRpZXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIHByb3BlcnRpZXMhXCIpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNoZWNrIGlmIHdlIGhhdmUgYW4gdW5pcXVlIGlkO1xuXG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSBcImNsdXN0ZXI6XCIgKyB2NCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2x1c3RlcklkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuXG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID0gXCJjbHVzdGVyXCI7XG4gICAgICB9IC8vIGdpdmUgdGhlIGNsdXN0ZXJOb2RlIGEgcG9zaXRpb24gaWYgaXQgZG9lcyBub3QgaGF2ZSBvbmUuXG5cblxuICAgICAgdmFyIHBvcyA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IHBvcy54O1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgIH1cblxuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9IHBvcy55O1xuICAgICAgfSAvLyBmb3JjZSB0aGUgSUQgdG8gcmVtYWluIHRoZSBzYW1lXG5cblxuICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gY2x1c3RlcklkOyAvLyBjcmVhdGUgdGhlIGNsdXN0ZXIgTm9kZVxuICAgICAgLy8gTm90ZSB0aGF0IGFsbG93U2luZ2xlTm9kZUNsdXN0ZXIsIGlmIHByZXNlbnQsIGlzIHN0b3JlZCBpbiB0aGUgb3B0aW9ucyBhcyB3ZWxsXG5cbiAgICAgIHZhciBjbHVzdGVyTm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShjbHVzdGVyTm9kZVByb3BlcnRpZXMsIENsdXN0ZXIpO1xuICAgICAgY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXMgPSBjaGlsZE5vZGVzT2JqO1xuICAgICAgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMgPSBjaGlsZEVkZ2VzT2JqOyAvLyBjYWNoZSBhIGNvcHkgZnJvbSB0aGUgY2x1c3RlciBlZGdlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0byByZWNvbm5lY3Qgb3RoZXJzIGxhdGVyIG9uXG5cbiAgICAgIGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzOyAvLyBmaW5hbGx5IHB1dCB0aGUgY2x1c3RlciBub2RlIGludG8gZ2xvYmFsXG5cbiAgICAgIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWRdID0gY2x1c3Rlck5vZGU7XG5cbiAgICAgIHRoaXMuX2NsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTsgLy8gc2V0IElEIHRvIHVuZGVmaW5lZCBzbyBubyBkdXBsaWNhdGVzIGFyaXNlXG5cblxuICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gdW5kZWZpbmVkOyAvLyB3cmFwIHVwXG5cbiAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmFja3VwRWRnZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JhY2t1cEVkZ2VPcHRpb25zKGVkZ2UpIHtcbiAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9IHtcbiAgICAgICAgICBwaHlzaWNzOiBlZGdlLm9wdGlvbnMucGh5c2ljc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdG9yZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBvcmlnaW5hbE9wdGlvbnMgPSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuXG4gICAgICBpZiAob3JpZ2luYWxPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiBvcmlnaW5hbE9wdGlvbnMucGh5c2ljc1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2x1c3Rlcihub2RlSWQpIHtcbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pc0NsdXN0ZXIgPT09IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2x1c3RlciBub2RlIGJhc2VkIG9uIHdoYXQncyBpbnNpZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGlsZE5vZGVzT2JqICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDbHVzdGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENsdXN0ZXJQb3NpdGlvbihjaGlsZE5vZGVzT2JqKSB7XG4gICAgICB2YXIgY2hpbGRLZXlzID0ga2V5cyQ0KGNoaWxkTm9kZXNPYmopO1xuXG4gICAgICB2YXIgbWluWCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgdmFyIG1heFggPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueDtcbiAgICAgIHZhciBtaW5ZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICB2YXIgbWF4WSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hpbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1tpXV07XG4gICAgICAgIG1pblggPSBub2RlLnggPCBtaW5YID8gbm9kZS54IDogbWluWDtcbiAgICAgICAgbWF4WCA9IG5vZGUueCA+IG1heFggPyBub2RlLnggOiBtYXhYO1xuICAgICAgICBtaW5ZID0gbm9kZS55IDwgbWluWSA/IG5vZGUueSA6IG1pblk7XG4gICAgICAgIG1heFkgPSBub2RlLnkgPiBtYXhZID8gbm9kZS55IDogbWF4WTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgeTogMC41ICogKG1pblkgKyBtYXhZKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbiBhIGNsdXN0ZXIgYnkgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gIGNsdXN0ZXJOb2RlSWQgfCB0aGUgSUQgb2YgdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWZyZXNoRGF0YSB8IHdyYXAgdXAgYWZ0ZXJ3YXJkcyBpZiBub3QgdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlbkNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbkNsdXN0ZXIoY2x1c3Rlck5vZGVJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgIGlmIChjbHVzdGVyTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3Rlci5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbHVzdGVyTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXTtcblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUuaXNDbHVzdGVyICE9PSB0cnVlIHx8IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzID09PSB1bmRlZmluZWQgfHwgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZTpcIiArIGNsdXN0ZXJOb2RlSWQgKyBcIiBpcyBub3QgYSB2YWxpZCBjbHVzdGVyLlwiKTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgY3VycmVudCBjbHVzdGVyIGlzIGNsdXN0ZXJlZCBpdHNlbGZcblxuXG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLmZpbmROb2RlKGNsdXN0ZXJOb2RlSWQpO1xuICAgICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXhPZihzdGFjaykuY2FsbChzdGFjaywgY2x1c3Rlck5vZGVJZCkgLSAxO1xuXG4gICAgICBpZiAocGFyZW50SW5kZXggPj0gMCkge1xuICAgICAgICAvLyBDdXJyZW50IGNsdXN0ZXIgaXMgY2x1c3RlcmVkOyB0cmFuc2ZlciBjb250YWluZWQgbm9kZXMgYW5kIGVkZ2VzIHRvIHBhcmVudFxuICAgICAgICB2YXIgcGFyZW50Q2x1c3Rlck5vZGVJZCA9IHN0YWNrW3BhcmVudEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudENsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudENsdXN0ZXJOb2RlSWRdOyAvLyBjbHVzdGVyaW5nLmNsdXN0ZXJlZE5vZGVzIGFuZCBjbHVzdGVyaW5nLmNsdXN0ZXJlZEVkZ2VzIHJlbWFpbiB1bmNoYW5nZWRcblxuICAgICAgICBwYXJlbnRDbHVzdGVyTm9kZS5fb3BlbkNoaWxkQ2x1c3RlcihjbHVzdGVyTm9kZUlkKTsgLy8gQWxsIGNvbXBvbmVudHMgb2YgY2hpbGQgY2x1c3RlciBub2RlIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZC4gSXQgY2FuIGRpZSBub3cuXG5cblxuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1haW4gYm9keVxuXG5cbiAgICAgIHZhciBjb250YWluZWROb2RlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzO1xuICAgICAgdmFyIGNvbnRhaW5lZEVkZ2VzID0gY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXM7IC8vIGFsbG93IHRoZSB1c2VyIHRvIHBvc2l0aW9uIHRoZSBub2RlcyBhZnRlciByZWxlYXNlLlxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGNsdXN0ZXJOb2RlLngsXG4gICAgICAgICAgeTogY2x1c3Rlck5vZGUueVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBwb3NpdGlvbnNbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgeDogY29udGFpbmVkTm9kZS54LFxuICAgICAgICAgICAgICB5OiBjb250YWluZWROb2RlLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcblxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgdmFyIF9jb250YWluZWROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXTtcblxuICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS54ID0gbmV3UG9zaXRpb25zW19ub2RlSWQyXS54ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS54IDogbmV3UG9zaXRpb25zW19ub2RlSWQyXS54O1xuICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS55ID0gbmV3UG9zaXRpb25zW19ub2RlSWQyXS55ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS55IDogbmV3UG9zaXRpb25zW19ub2RlSWQyXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29weSB0aGUgcG9zaXRpb24gZnJvbSB0aGUgY2x1c3RlclxuICAgICAgICBmb3JFYWNoJDEoY29udGFpbmVkTm9kZXMsIGZ1bmN0aW9uIChjb250YWluZWROb2RlKSB7XG4gICAgICAgICAgLy8gaW5oZXJpdCBwb3NpdGlvblxuICAgICAgICAgIGlmIChjb250YWluZWROb2RlLm9wdGlvbnMuZml4ZWQueCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lZE5vZGUueCA9IGNsdXN0ZXJOb2RlLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZWxlYXNlIG5vZGVzXG5cblxuICAgICAgZm9yICh2YXIgX25vZGVJZDMgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2RlcywgX25vZGVJZDMpKSB7XG4gICAgICAgICAgdmFyIF9jb250YWluZWROb2RlMiA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkM107IC8vIGluaGVyaXQgc3BlZWRcblxuICAgICAgICAgIF9jb250YWluZWROb2RlMi52eCA9IGNsdXN0ZXJOb2RlLnZ4O1xuICAgICAgICAgIF9jb250YWluZWROb2RlMi52eSA9IGNsdXN0ZXJOb2RlLnZ5O1xuXG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkTm9kZXNbX25vZGVJZDNdO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNvcHkgdGhlIGNsdXN0ZXJOb2RlIGVkZ2VzIGJlY2F1c2Ugd2UgY2Fubm90IGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QgdGhhdCB3ZSBhZGQgb3IgcmVtb3ZlIGZyb20uXG5cblxuICAgICAgdmFyIGVkZ2VzVG9CZURlbGV0ZWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyTm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlc1RvQmVEZWxldGVkLnB1c2goY2x1c3Rlck5vZGUuZWRnZXNbaV0pO1xuICAgICAgfSAvLyBhY3R1YWxseSBoYW5kbGluZyB0aGUgZGVsZXRpbmcuXG5cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXNUb0JlRGVsZXRlZC5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNUb0JlRGVsZXRlZFtfaTNdO1xuXG4gICAgICAgIHZhciBvdGhlck5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIGNsdXN0ZXJOb2RlSWQpO1xuXG4gICAgICAgIHZhciBvdGhlck5vZGUgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJJZCA9IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNbal07XG4gICAgICAgICAgdmFyIHRyYW5zZmVyRWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0cmFuc2ZlcklkXTtcbiAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBpZiB0aGUgb3RoZXIgbm9kZSBpcyBpbiBhbm90aGVyIGNsdXN0ZXIsIHdlIHRyYW5zZmVyIG93bmVyc2hpcCBvZiB0aGlzIGVkZ2UgdG8gdGhlIG90aGVyIGNsdXN0ZXJcblxuICAgICAgICAgIGlmIChvdGhlck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdHJhbnNmZXIgb3duZXJzaGlwOlxuICAgICAgICAgICAgdmFyIG90aGVyQ2x1c3RlciA9IHRoaXMuYm9keS5ub2Rlc1tvdGhlck5vZGUuY2x1c3RlcklkXTtcbiAgICAgICAgICAgIG90aGVyQ2x1c3Rlci5jb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdID0gdHJhbnNmZXJFZGdlOyAvLyBkZWxldGUgbG9jYWwgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgIGRlbGV0ZSBjb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdOyAvLyBnZXQgdG8gYW5kIGZyb21cblxuICAgICAgICAgICAgdmFyIGZyb21JZCA9IHRyYW5zZmVyRWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRyYW5zZmVyRWRnZS50b0lkO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlLnRvSWQgPT0gb3RoZXJOb2RlSWQpIHtcbiAgICAgICAgICAgICAgdG9JZCA9IG90aGVyTm9kZS5jbHVzdGVySWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tSWQgPSBvdGhlck5vZGUuY2x1c3RlcklkO1xuICAgICAgICAgICAgfSAvLyBjcmVhdGUgbmV3IGNsdXN0ZXIgZWRnZSBmcm9tIHRoZSBvdGhlckNsdXN0ZXJcblxuXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKGZyb21JZCwgdG9JZCwgdHJhbnNmZXJFZGdlLCBvdGhlckNsdXN0ZXIuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZSh0cmFuc2ZlckVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB9IC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuXG5cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjb250YWluZWRFZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZEVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG5cblxuICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXTtcblxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDbHVzdGVyLmlkfSBjbHVzdGVySWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE5vZGUuaWQ+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZXNJbkNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5pc0NsdXN0ZXIoY2x1c3RlcklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXS5jb250YWluZWROb2RlcztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBub2Rlc0FycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFjayBjbHVzdGVySWQncyB0aGF0IGEgY2VydGFpbiBub2RlIHJlc2lkZXMgaW4uIGNsdXN0ZXIgQSAtPiBjbHVzdGVyIEIgLT4gY2x1c3RlciBDIC0+IG5vZGVcbiAgICAgKlxuICAgICAqIElmIGEgbm9kZSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgY2hhaW4sIHJldHVybiBhbiBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbm9kZUlkXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE5vZGUobm9kZUlkKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIG5vZGVJZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXS5jbHVzdGVySWQ7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgICAgc3RhY2sucHVzaChub2RlLmlkKTtcblxuICAgICAgcmV2ZXJzZShzdGFjaykuY2FsbChzdGFjayk7XG5cbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBjbHVzdGVyZWQgbm9kZUlkLCB1cGRhdGUgd2l0aCB0aGUgbmV3IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2x1c3RlcmVkTm9kZUlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUNsdXN0ZXJlZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ2x1c3RlcmVkTm9kZShjbHVzdGVyZWROb2RlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjbHVzdGVyZWROb2RlSWQgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbmV3T3B0aW9ucyBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyZWROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJlZE5vZGVJZF0uc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgYmFzZSBlZGdlSWQsIHVwZGF0ZSBhbGwgcmVsYXRlZCBjbHVzdGVyZWQgZWRnZXMgd2l0aCB0aGUgbmV3IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IHN0YXJ0RWRnZUlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRnZShzdGFydEVkZ2VJZCwgbmV3T3B0aW9ucykge1xuICAgICAgaWYgKHN0YXJ0RWRnZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbmV3T3B0aW9ucyBzdXBwbGllZCB0byB1cGRhdGVFZGdlLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tzdGFydEVkZ2VJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxFZGdlSWRzID0gdGhpcy5nZXRDbHVzdGVyZWRFZGdlcyhzdGFydEVkZ2VJZCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1thbGxFZGdlSWRzW2ldXTtcbiAgICAgICAgZWRnZS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdGFjayBvZiBjbHVzdGVyRWRnZUlkJ3MgKCtiYXNlIGVkZ2VpZCkgdGhhdCBhIGJhc2UgZWRnZSBpcyB0aGUgc2FtZSBhcy4gY2x1c3RlciBlZGdlIEMgLT4gY2x1c3RlciBlZGdlIEIgLT4gY2x1c3RlciBlZGdlIEEgLT4gYmFzZSBlZGdlKGVkZ2VJZClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2x1c3RlcmVkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2x1c3RlcmVkRWRnZXMoZWRnZUlkKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgIHdoaWxlIChlZGdlSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgc3RhY2sucHVzaCh0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5pZCk7XG4gICAgICAgIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLmVkZ2VSZXBsYWNlZEJ5SWQ7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cblxuICAgICAgcmV2ZXJzZShzdGFjaykuY2FsbChzdGFjayk7XG5cbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBiYXNlIGVkZ2UgaWQgb2YgY2x1c3RlckVkZ2VJZC4gY2x1c3RlciBlZGdlIChjbHVzdGVyZWRFZGdlSWQpIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBDIC0+IGJhc2UgZWRnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gY2x1c3RlcmVkRWRnZUlkXG4gICAgICogQHJldHVybnMge3Zpcy5FZGdlLmlkfSBiYXNlRWRnZUlkXG4gICAgICpcbiAgICAgKiBUT0RPOiBkZXByZWNhdGUgaW4gNS4wLjAuIE1ldGhvZCBnZXRCYXNlRWRnZXMoKSBpcyB0aGUgY29ycmVjdCBvbmUgdG8gdXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZUVkZ2UoY2x1c3RlcmVkRWRnZUlkKSB7XG4gICAgICAvLyBKdXN0IGtsdWRnZSB0aGlzIGJ5IHJldHVybmluZyB0aGUgZmlyc3QgYmFzZSBlZGdlIGlkIGZvdW5kXG4gICAgICByZXR1cm4gdGhpcy5nZXRCYXNlRWRnZXMoY2x1c3RlcmVkRWRnZUlkKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWd1bGFyIGVkZ2VzIGZvciB0aGlzIGNsdXN0ZXJlZCBlZGdlIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gY2x1c3RlcmVkRWRnZUlkXG4gICAgICogQHJldHVybnMge0FycmF5Ljx2aXMuRWRnZS5pZD59IGFsbCBiYXNlRWRnZUlkJ3MgdW5kZXIgdGhpcyBjbHVzdGVyZWQgZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VFZGdlcyhjbHVzdGVyZWRFZGdlSWQpIHtcbiAgICAgIHZhciBJZHNUb0hhbmRsZSA9IFtjbHVzdGVyZWRFZGdlSWRdO1xuICAgICAgdmFyIGRvbmVJZHMgPSBbXTtcbiAgICAgIHZhciBmb3VuZElkcyA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgICAgd2hpbGUgKElkc1RvSGFuZGxlLmxlbmd0aCA+IDAgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICB2YXIgbmV4dElkID0gSWRzVG9IYW5kbGUucG9wKCk7XG4gICAgICAgIGlmIChuZXh0SWQgPT09IHVuZGVmaW5lZCkgY29udGludWU7IC8vIFBhcmFub2lhIGhlcmUgYW5kIG9ud2FyZHNcblxuICAgICAgICB2YXIgbmV4dEVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbbmV4dElkXTtcbiAgICAgICAgaWYgKG5leHRFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIHZhciByZXBsYWNpbmdJZHMgPSBuZXh0RWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcztcblxuICAgICAgICBpZiAocmVwbGFjaW5nSWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBuZXh0SWQgaXMgYSBiYXNlIGlkXG4gICAgICAgICAgZm91bmRJZHMucHVzaChuZXh0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFub3RoZXIgY2x1c3RlciBlZGdlLCB1bnJhdmVsIHRoaXMgb25lIGFzIHdlbGxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2luZ0lkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2luZ0lkID0gcmVwbGFjaW5nSWRzW2ldOyAvLyBEb24ndCBhZGQgaWYgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBUT0RPOiBuZXZlciB0cmlnZ2VyczsgZmluZCBhIHRlc3QtY2FzZSB3aGljaCBkb2VzXG5cbiAgICAgICAgICAgIGlmIChpbmRleE9mKElkc1RvSGFuZGxlKS5jYWxsKElkc1RvSGFuZGxlLCByZXBsYWNpbmdJZHMpICE9PSAtMSB8fCBpbmRleE9mKGRvbmVJZHMpLmNhbGwoZG9uZUlkcywgcmVwbGFjaW5nSWRzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIElkc1RvSGFuZGxlLnB1c2gocmVwbGFjaW5nSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmVJZHMucHVzaChuZXh0SWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm91bmRJZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSWQgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBlZGdlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbm5lY3RlZElkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpIHtcbiAgICAgIGlmIChlZGdlLnRvSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRvSWQ7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UuZnJvbUlkICE9IG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gZWRnZS5mcm9tSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWRnZS5mcm9tSWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlIGRldGVybWluZSBob3cgbWFueSBjb25uZWN0aW9ucyBkZW5vdGUgYW4gaW1wb3J0YW50IGh1Yi5cbiAgICAgKiBXZSB0YWtlIHRoZSBtZWFuICsgMipzdGQgYXMgdGhlIGltcG9ydGFudCBodWIgc2l6ZS4gKEFzc3VtaW5nIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBvZiBkYXRhLCB+Mi4yJSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIdWJTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplKCkge1xuICAgICAgdmFyIGF2ZXJhZ2UgPSAwO1xuICAgICAgdmFyIGF2ZXJhZ2VTcXVhcmVkID0gMDtcbiAgICAgIHZhciBodWJDb3VudGVyID0gMDtcbiAgICAgIHZhciBsYXJnZXN0SHViID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPiBsYXJnZXN0SHViKSB7XG4gICAgICAgICAgbGFyZ2VzdEh1YiA9IG5vZGUuZWRnZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYXZlcmFnZSArPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgYXZlcmFnZVNxdWFyZWQgKz0gTWF0aC5wb3cobm9kZS5lZGdlcy5sZW5ndGgsIDIpO1xuICAgICAgICBodWJDb3VudGVyICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlIC8gaHViQ291bnRlcjtcbiAgICAgIGF2ZXJhZ2VTcXVhcmVkID0gYXZlcmFnZVNxdWFyZWQgLyBodWJDb3VudGVyO1xuICAgICAgdmFyIHZhcmlhbmNlID0gYXZlcmFnZVNxdWFyZWQgLSBNYXRoLnBvdyhhdmVyYWdlLCAyKTtcbiAgICAgIHZhciBzdGFuZGFyZERldmlhdGlvbiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG4gICAgICB2YXIgaHViVGhyZXNob2xkID0gTWF0aC5mbG9vcihhdmVyYWdlICsgMiAqIHN0YW5kYXJkRGV2aWF0aW9uKTsgLy8gYWx3YXlzIGhhdmUgYXQgbGVhc3Qgb25lIHRvIGNsdXN0ZXJcblxuICAgICAgaWYgKGh1YlRocmVzaG9sZCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgaHViVGhyZXNob2xkID0gbGFyZ2VzdEh1YjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGh1YlRocmVzaG9sZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGVkZ2UgZm9yIHRoZSBjbHVzdGVyIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBmcm9tSWRcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHRvSWRcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBiYXNlRWRnZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbHVzdGVyRWRnZVByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXh0cmFPcHRpb25zXG4gICAgICogQHJldHVybnMge0VkZ2V9IG5ld2x5IGNyZWF0ZWQgY2x1c3RlcmVkIGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUNsdXN0ZXJlZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UoZnJvbUlkLCB0b0lkLCBiYXNlRWRnZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgdGhlIG9wdGlvbnMgb2YgdGhlIGVkZ2Ugd2Ugd2lsbCByZXBsYWNlXG4gICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhiYXNlRWRnZSwgXCJlZGdlXCIpOyAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnRpZXMgb2YgY2x1c3RlckVkZ2VzIGFyZSBzdXBlcmltcG9zZWQgb24gaXRcblxuICAgICAgZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpOyAvLyBzZXQgdXAgdGhlIGVkZ2VcblxuICAgICAgY2xvbmVkT3B0aW9ucy5mcm9tID0gZnJvbUlkO1xuICAgICAgY2xvbmVkT3B0aW9ucy50byA9IHRvSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLmlkID0gXCJjbHVzdGVyRWRnZTpcIiArIHY0KCk7IC8vIGFwcGx5IHRoZSBlZGdlIHNwZWNpZmljIG9wdGlvbnMgdG8gaXQgaWYgc3BlY2lmaWVkXG5cbiAgICAgIGlmIChleHRyYU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdFZGdlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlKGNsb25lZE9wdGlvbnMpO1xuICAgICAgbmV3RWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcyA9IFtiYXNlRWRnZS5pZF07XG4gICAgICBuZXdFZGdlLmNvbm5lY3QoKTsgLy8gUmVnaXN0ZXIgdGhlIG5ldyBlZGdlXG5cbiAgICAgIHRoaXMuYm9keS5lZGdlc1tuZXdFZGdlLmlkXSA9IG5ld0VkZ2U7XG4gICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwYXNzZWQgY2hpbGQgbm9kZXMgYW5kIGVkZ2VzIHRvIHRoZSBnaXZlbiBjbHVzdGVyIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IE5vZGV9IGNoaWxkTm9kZXMgIGhhc2ggb2Ygbm9kZXMgb3Igc2luZ2xlIG5vZGUgdG8gYWRkIGluIGNsdXN0ZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IEVkZ2V9IGNoaWxkRWRnZXMgIGhhc2ggb2YgZWRnZXMgb3Igc2luZ2xlIGVkZ2UgdG8gdGFrZSBpbnRvIGFjY291bnQgd2hlbiBjbHVzdGVyaW5nXG4gICAgICogQHBhcmFtIHtOb2RlfSBjbHVzdGVyTm9kZSAgY2x1c3RlciBub2RlIHRvIGFkZCBub2RlcyBhbmQgZWRnZXMgdG9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NsdXN0ZXJFZGdlUHJvcGVydGllc11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsdXN0ZXJFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChjaGlsZEVkZ2VzIGluc3RhbmNlb2YgRWRnZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGNoaWxkRWRnZXM7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgY2hpbGRFZGdlcyA9IG9iajtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkTm9kZXMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHZhciBub2RlID0gY2hpbGROb2RlcztcbiAgICAgICAgdmFyIF9vYmogPSB7fTtcbiAgICAgICAgX29ialtub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIGNoaWxkTm9kZXMgPSBfb2JqO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUgPT09IHVuZGVmaW5lZCB8fCBjbHVzdGVyTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfY2x1c3RlckVkZ2VzOiBwYXJhbWV0ZXIgY2x1c3Rlck5vZGUgcmVxdWlyZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUYWtlIHRoZSByZXF1aXJlZCBwcm9wZXJ0aWVzIGZyb20gdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAgICBjbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXM7XG4gICAgICB9IC8vIGNyZWF0ZSB0aGUgbmV3IGVkZ2VzIHRoYXQgd2lsbCBjb25uZWN0IHRvIHRoZSBjbHVzdGVyLlxuICAgICAgLy8gQWxsIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byBjaGlsZEVkZ2VzIGhlcmUuXG5cblxuICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpOyAvLyBkaXNhYmxlIHRoZSBjaGlsZEVkZ2VzXG5cblxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNoaWxkRWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZEVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfZWRnZTIgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTsgLy8gY2FjaGUgdGhlIG9wdGlvbnMgYmVmb3JlIGNoYW5naW5nXG5cbiAgICAgICAgICAgIHRoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKF9lZGdlMik7IC8vIGRpc2FibGUgcGh5c2ljcyBhbmQgaGlkZSB0aGUgZWRnZVxuXG5cbiAgICAgICAgICAgIF9lZGdlMi5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBkaXNhYmxlIHRoZSBjaGlsZE5vZGVzXG5cblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdID0ge1xuICAgICAgICAgICAgY2x1c3RlcklkOiBjbHVzdGVyTm9kZS5pZCxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGluIHdoaWNoIGNsdXN0ZXIgZ2l2ZW4gbm9kZUlkIHJlc2lkZXMuXG4gICAgICpcbiAgICAgKiBJZiBub3QgaW4gY2x1c3RlciwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IElmIHlvdSBrbm93IGEgY2xlYW5lciB3YXkgdG8gZG8gdGhpcywgcGxlYXNlIGVubGlnaHRlbiBtZSAod2ltcmlqbmRlcnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXx1bmRlZmluZWR9IE5vZGUgaW5zdGFuY2UgZm9yIGNsdXN0ZXIsIGlmIHByZXNlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENsdXN0ZXJOb2RlRm9yTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKG5vZGVJZCkge1xuICAgICAgaWYgKG5vZGVJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGNsdXN0ZXJlZE5vZGUgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF07IC8vIE5PVEU6IElmIG5vIGNsdXN0ZXIgaW5mbyBmb3VuZCwgaXQgc2hvdWxkIGFjdHVhbGx5IGJlIGFuIGVycm9yXG5cbiAgICAgIGlmIChjbHVzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcklkID0gY2x1c3RlcmVkTm9kZS5jbHVzdGVySWQ7XG4gICAgICBpZiAoY2x1c3RlcklkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiBmb3IgY29uZGl0aW9uYWxseSByZW1vdmluZyBpdGVtcyBpbiBhcnJheVxuICAgICAqXG4gICAgICogRG9uZSBsaWtlIHRoaXMgYmVjYXVzZSBBcnJheS5maWx0ZXIoKSBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIGJ5IGFsbCBJRSdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlcihhcnIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBmb3JFYWNoJDEoYXJyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSkpIHtcbiAgICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FuIGFsbCBlZGdlcyBmb3IgY2hhbmdlcyBpbiBjbHVzdGVyaW5nIGFuZCBhZGp1c3QgdGhpcyBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBDYWxsIHRoaXMgKGludGVybmFsbHkpIGFmdGVyIHRoZXJlIGhhcyBiZWVuIGEgY2hhbmdlIGluIG5vZGUgb3IgZWRnZSBkYXRhLlxuICAgICAqXG4gICAgICogUHJlOiBTdGF0ZXMgb2YgdGhpcy5ib2R5Lm5vZGVzIGFuZCB0aGlzLmJvZHkuZWRnZXMgY29uc2lzdGVudFxuICAgICAqIFByZTogdGhpcy5jbHVzdGVyZWROb2RlcyBhbmQgdGhpcy5jbHVzdGVyZWRFZGdlIGNvbnNpc3RlbnQgd2l0aCBjb250YWluZWROb2RlcyBhbmQgY29udGFpbmVkRWRnZXNcbiAgICAgKiAgICAgIG9mIGNsdXN0ZXIgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN0YXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBub2RlSWQ7XG4gICAgICB2YXIgZGVsZXRlZE5vZGVJZHMgPSBbXTtcbiAgICAgIHZhciBkZWxldGVkRWRnZUlkcyA9IHt9O1xuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBjbHVzdGVyaW5nIG5vZGVzIG9ubHlcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBjbHVzdGVyIG5vZGVcbiAgICAgICAqL1xuXG4gICAgICB2YXIgZWFjaENsdXN0ZXJOb2RlID0gZnVuY3Rpb24gZWFjaENsdXN0ZXJOb2RlKGNhbGxiYWNrKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczQuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9OyAvL1xuICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgcmVndWxhciBub2RlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGRlbGV0ZWQgbm9kZXNcblxuXG4gICAgICBmb3IgKG5vZGVJZCBpbiB0aGlzLmNsdXN0ZXJlZE5vZGVzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY2x1c3RlcmVkTm9kZXMsIG5vZGVJZCkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGVkTm9kZUlkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIG5vZGVzIGZyb20gY2x1c3RlciBub2Rlc1xuXG5cbiAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkZWxldGVkTm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgIGRlbGV0ZSBjbHVzdGVyTm9kZS5jb250YWluZWROb2Rlc1tkZWxldGVkTm9kZUlkc1tuXV07XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBSZW1vdmUgbm9kZXMgZnJvbSBjbHVzdGVyIGxpc3RcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkZWxldGVkTm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tkZWxldGVkTm9kZUlkc1tuXV07XG4gICAgICB9IC8vXG4gICAgICAvLyBSZW1vdmUgZGVsZXRlZCBlZGdlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG4gICAgICAvLyBBZGQgdGhlIGRlbGV0ZWQgY2x1c3RlcmVkIGVkZ2VzIHRvIHRoZSBsaXN0XG5cblxuICAgICAgZm9yRWFjaCQxKHRoaXMuY2x1c3RlcmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczQuYm9keS5lZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgIGlmIChlZGdlID09PSB1bmRlZmluZWQgfHwgIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSkge1xuICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBDbHVzdGVyIG5vZGVzIGNhbiBhbHNvIGNvbnRhaW4gZWRnZXMgd2hpY2ggYXJlIG5vdCBjbHVzdGVyZWQsXG4gICAgICAvLyBpLmUuIG5vZGVzIDEtMiB3aXRoaW4gY2x1c3RlciB3aXRoIGFuIGVkZ2UgaW4gYmV0d2Vlbi5cbiAgICAgIC8vIFNvIHRoZSBjbHVzdGVyIG5vZGVzIGFsc28gbmVlZCB0byBiZSBzY2FubmVkIGZvciBpbnZhbGlkIGVkZ2VzXG5cbiAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgZm9yRWFjaCQxKGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgICAgaWYgKCFlZGdlLmVuZFBvaW50c1ZhbGlkKCkgJiYgIWRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBBbHNvIHNjYW4gZm9yIGNsdXN0ZXIgZWRnZXMgd2hpY2ggbmVlZCB0byBiZSByZW1vdmVkIGluIHRoZSBhY3RpdmUgbGlzdC5cbiAgICAgIC8vIFJlZ3VsYXIgZWRnZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmVmb3JlaGFuZCwgc28gdGhpcyBvbmx5IHBpY2tzIHVwIHRoZSBjbHVzdGVyIGVkZ2VzLlxuXG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5LmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2NhbiB0aGUgY29udGFpbmVkIGVkZ2VzIGZvciB2YWxpZGl0eVxuICAgICAgICB2YXIgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHZhciByZXBsYWNlZElkcyA9IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHM7XG5cbiAgICAgICAgaWYgKHJlcGxhY2VkSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbnVtVmFsaWQgPSAwO1xuICAgICAgICAgIGZvckVhY2gkMShyZXBsYWNlZElkcywgZnVuY3Rpb24gKGNvbnRhaW5lZEVkZ2VJZCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lZEVkZ2UgPSBfdGhpczQuYm9keS5lZGdlc1tjb250YWluZWRFZGdlSWRdO1xuXG4gICAgICAgICAgICBpZiAoY29udGFpbmVkRWRnZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lZEVkZ2UuZW5kUG9pbnRzVmFsaWQoKSkge1xuICAgICAgICAgICAgICBudW1WYWxpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzVmFsaWQgPSBudW1WYWxpZCA+IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSB8fCAhaXNWYWxpZCkge1xuICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBSZW1vdmUgZWRnZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG5cbiAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgZm9yRWFjaCQxKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZGVsZXRlZEVkZ2VJZCkge1xuICAgICAgICAgIGRlbGV0ZSBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlc1tkZWxldGVkRWRnZUlkXTtcbiAgICAgICAgICBmb3JFYWNoJDEoY2x1c3Rlck5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBtKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5pZCA9PT0gZGVsZXRlZEVkZ2VJZCkge1xuICAgICAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlc1ttXSA9IG51bGw7IC8vIERvbid0IHdhbnQgdG8gZGlyZWN0bHkgZGVsZXRlIGhlcmUsIGJlY2F1c2UgaW4gdGhlIGxvb3BcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMgPSBfdGhpczQuX2ZpbHRlcihlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFkZWxldGVkRWRnZUlkc1tpZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTsgLy8gQ2xlYW4gdXAgdGhlIG51bGxzXG5cbiAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlcyA9IF90aGlzNC5fZmlsdGVyKGNsdXN0ZXJOb2RlLmVkZ2VzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIFJlbW92ZSBmcm9tIGNsdXN0ZXIgbGlzdFxuXG4gICAgICBmb3JFYWNoJDEoZGVsZXRlZEVkZ2VJZHMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzNC5jbHVzdGVyZWRFZGdlc1tlZGdlSWRdO1xuICAgICAgfSk7IC8vIFJlbW92ZSBjbHVzdGVyIGVkZ2VzIGZyb20gYWN0aXZlIGxpc3QgKHRoaXMuYm9keS5lZGdlcykuXG4gICAgICAvLyBkZWxldGVkRWRnZUlkcyBzdGlsbCBjb250YWlucyBpZCBvZiByZWd1bGFyIGVkZ2VzLCBidXQgdGhlc2Ugc2hvdWxkIGFsbFxuICAgICAgLy8gYmUgZ29uZSB3aGVuIHlvdSByZWFjaCBoZXJlLlxuXG4gICAgICBmb3JFYWNoJDEoZGVsZXRlZEVkZ2VJZHMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzNC5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gICAgICB9KTsgLy9cbiAgICAgIC8vIENoZWNrIGNoYW5nZWQgY2x1c3RlciBzdGF0ZSBvZiBlZGdlc1xuICAgICAgLy9cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGtleXMgaGVyZSwgYmVjYXVzZSBlZGdlcyBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgbG9vcFxuXG4gICAgICB2YXIgaWRzID0ga2V5cyQ0KHRoaXMuYm9keS5lZGdlcyk7XG5cbiAgICAgIGZvckVhY2gkMShpZHMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczQuYm9keS5lZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgIHZhciBzaG91bGRCZUNsdXN0ZXJlZCA9IF90aGlzNC5faXNDbHVzdGVyZWROb2RlKGVkZ2UuZnJvbUlkKSB8fCBfdGhpczQuX2lzQ2x1c3RlcmVkTm9kZShlZGdlLnRvSWQpO1xuXG4gICAgICAgIGlmIChzaG91bGRCZUNsdXN0ZXJlZCA9PT0gX3RoaXM0Ll9pc0NsdXN0ZXJlZEVkZ2UoZWRnZS5pZCkpIHtcbiAgICAgICAgICByZXR1cm47IC8vIGFsbCBpcyB3ZWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkQmVDbHVzdGVyZWQpIHtcbiAgICAgICAgICAvLyBhZGQgZWRnZSB0byBjbHVzdGVyaW5nXG4gICAgICAgICAgdmFyIGNsdXN0ZXJGcm9tID0gX3RoaXM0Ll9nZXRDbHVzdGVyTm9kZUZvck5vZGUoZWRnZS5mcm9tSWQpO1xuXG4gICAgICAgICAgaWYgKGNsdXN0ZXJGcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSwgZWRnZSwgY2x1c3RlckZyb20pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjbHVzdGVyVG8gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLnRvSWQpO1xuXG4gICAgICAgICAgaWYgKGNsdXN0ZXJUbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpczQuX2NsdXN0ZXJFZGdlcyhfdGhpczQuYm9keS5ub2Rlc1tlZGdlLnRvSWRdLCBlZGdlLCBjbHVzdGVyVG8pO1xuICAgICAgICAgIH0gLy8gVE9ETzogY2hlY2sgdGhhdCBpdCB3b3JrcyBmb3IgYm90aCBlZGdlcyBjbHVzdGVyZWRcbiAgICAgICAgICAvLyAgICAgICAoVGhpcyBtaWdodCBiZSBwYXJhbm9pYSlcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczQuX2NsdXN0ZXJFZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgICAgX3RoaXM0Ll9yZXN0b3JlRWRnZShlZGdlKTsgLy8gVGhpcyBzaG91bGQgbm90IGJlIGhhcHBlbmluZywgdGhlIHN0YXRlIHNob3VsZFxuICAgICAgICAgIC8vIGJlIHByb3Blcmx5IHVwZGF0ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGl0ICppcyogcmVhY2hlZCBkdXJpbmcgbm9ybWFsIG9wZXJhdGlvbiwgdGhlbiB3ZSBoYXZlIHRvIGltcGxlbWVudFxuICAgICAgICAgIC8vIHVuZG8gY2x1c3RlcmluZyBmb3IgdGhpcyBlZGdlIGhlcmUuXG4gICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdyZW1vdmUgZWRnZSBmcm9tIGNsdXN0ZXJpbmcgbm90IGltcGxlbWVudGVkIScpXG5cbiAgICAgICAgfVxuICAgICAgfSk7IC8vIENsdXN0ZXJzIG1heSBiZSBuZXN0ZWQgdG8gYW55IGxldmVsLiBLZWVwIG9uIG9wZW5pbmcgdW50aWwgbm90aGluZyB0byBvcGVuXG5cbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY29udGludWVMb29wID0gdHJ1ZTtcblxuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgICAgdmFyIGNsdXN0ZXJzVG9PcGVuID0gW107IC8vIERldGVybWluZSB0aGUgaWQncyBvZiBjbHVzdGVycyB0aGF0IG5lZWQgb3BlbmluZ1xuXG4gICAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgICB2YXIgbnVtTm9kZXMgPSBrZXlzJDQoY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXMpLmxlbmd0aDtcblxuICAgICAgICAgIHZhciBhbGxvd1NpbmdsZSA9IGNsdXN0ZXJOb2RlLm9wdGlvbnMuYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciA9PT0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChhbGxvd1NpbmdsZSAmJiBudW1Ob2RlcyA8IDEgfHwgIWFsbG93U2luZ2xlICYmIG51bU5vZGVzIDwgMikge1xuICAgICAgICAgICAgY2x1c3RlcnNUb09wZW4ucHVzaChjbHVzdGVyTm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gT3BlbiB0aGVtXG5cbiAgICAgICAgZm9yICh2YXIgX24gPSAwOyBfbiA8IGNsdXN0ZXJzVG9PcGVuLmxlbmd0aDsgKytfbikge1xuICAgICAgICAgIF90aGlzNC5vcGVuQ2x1c3RlcihjbHVzdGVyc1RvT3Blbltfbl0sIHt9LCBmYWxzZVxuICAgICAgICAgIC8qIERvbid0IHJlZnJlc2gsIHdlJ3JlIGluIGFuIHJlZnJlc2gvdXBkYXRlIGFscmVhZHkgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVMb29wID0gY2x1c3RlcnNUb09wZW4ubGVuZ3RoID4gMDtcbiAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgY29udGludWVMb29wO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKGNvbnRpbnVlTG9vcCkge1xuICAgICAgICBfbG9vcDIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUoKTsgLy8gUmVkbyB0aGlzIG1ldGhvZCAocmVjdXJzaW9uIHBvc3NpYmxlISBzaG91bGQgYmUgc2FmZSlcblxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgbm9kZSB3aXRoIGdpdmVuIGlkIGlzIHBhcnQgb2YgYSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYXJ0IG9mIGEgY2x1c3Rlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc0NsdXN0ZXJlZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ2x1c3RlcmVkTm9kZShub2RlSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGVkZ2Ugd2l0aCBnaXZlbiBpZCBpcyBub3QgdmlzaWJsZSBkdWUgdG8gY2x1c3RlcmluZy5cbiAgICAgKlxuICAgICAqIEFuIGVkZ2UgaXMgY29uc2lkZXJlZCBjbHVzdGVyZWQgaWY6XG4gICAgICogLSBpdCBpcyBkaXJlY3RseSByZXBsYWNlZCBieSBhIGNsdXN0ZXJpbmcgZWRnZVxuICAgICAqIC0gYW55IG9mIGl0cyBjb25uZWN0aW5nIG5vZGVzIGlzIGluIGEgY2x1c3RlclxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gZWRnZUlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNDbHVzdGVyZWRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsdXN0ZXJFbmdpbmU7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0NDsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ0LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDUoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIEluaXRpYWxpemVzIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB0byBhIHVzYWJsZSBmb3JtLlxuICpcbiAqIFNwZWNpZmljYWxseSwgc2V0IHVwIHRoaXMgbWV0aG9kIGZvciB0aGUgY2FzZSBvZiBydW5uaW5nIG9uIG5vZGUuanMgd2l0aCBqc2RvbSBlbmFibGVkLlxuICpcbiAqIE5PVEVTOlxuICpcbiAqIE9uIG5vZGUuanMsIHdoZW4gY2FsbGluZyB0aGlzIGRpcmVjdGx5IG91dHNpZGUgb2YgdGhpcyBjbGFzcywgYHdpbmRvd2AgaXMgbm90IGRlZmluZWQuXG4gKiAgIFRoaXMgaGFwcGVucyBldmVuIGlmIGpzZG9tIGlzIHVzZWQuXG4gKiBGb3Igbm9kZS5qcyArIGpzZG9tLCBgd2luZG93YCBpcyBhdmFpbGFibGUgYXQgdGhlIG1vbWVudCB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkLlxuICogICBGb3IgdGhpcyByZWFzb24sIHRoZSBjYWxsZWQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gKiBFdmVuIHRoZW4sIGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgIGlzIG5vdCBkZWZpbmVkLCBzbyBpdCBzdGlsbCBuZWVkcyB0byBiZSBhZGRlZC5cbiAqIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgd2luZG93IG9iamVjdCBpcyByZXNldCBkdXJpbmcgZXhlY3V0aW9uLCBjYXVzaW5nXG4gKiAgIGEgcnVudGltZSBlcnJvciBkdWUgdG8gbWlzc2luZyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgLiBUaGlzIG5lZWRzIHRvIGJlIGNvbXBlbnNhdGVkIGZvcixcbiAqICAgc2VlIGBfcmVxdWVzdE5leHRGcmFtZSgpYC5cbiAqIFNpbmNlIHRoaXMgaXMgYSBnbG9iYWwgb2JqZWN0LCBpdCBtYXkgYWZmZWN0IG90aGVyIG1vZHVsZXMgYmVzaWRlcyBgTmV0d29ya2AuIFdpdGggbm9ybWFsXG4gKiAgIHVzYWdlLCB0aGlzIGRvZXMgbm90IGNhdXNlIGFueSBwcm9ibGVtcy4gRHVyaW5nIHVuaXQgdGVzdGluZywgZXJyb3JzIG1heSBvY2N1ci4gVGhlc2UgaGF2ZVxuICogICBiZWVuIGNvbXBlbnNhdGVkIGZvciwgc2VlIGNvbW1lbnQgYmxvY2sgaW4gX3JlcXVlc3ROZXh0RnJhbWUoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9pbml0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkge1xuICB2YXIgZnVuYztcblxuICBpZiAod2luZG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmdW5jID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB9XG5cbiAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHdpbmRvdyBvciBtZXRob2Qgbm90IHByZXNlbnQsIHNldHRpbmcgbW9jayByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiQ2FsbGVkIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jO1xuICB9XG59XG4vKipcbiAqIFRoZSBjYW52YXMgcmVuZGVyZXJcbiAqL1xuXG5cbnZhciBDYW52YXNSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXNSZW5kZXJlcihib2R5LCBjYW52YXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzUmVuZGVyZXIpO1xuXG4gICAgX2luaXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgIHRoaXMuYWxsb3dSZWRyYXcgPSB0cnVlO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IGZhbHNlXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2FudmFzUmVuZGVyZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIF9jb250ZXh0MjtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiem9vbVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KF90aGlzLnpvb21UaW1lb3V0SWQpO1xuICAgICAgICBfdGhpcy56b29tVGltZW91dElkID0gc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgICAgICBfdGhpcy56b29taW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQgPSBfdGhpcy5fcmVxdWVzdFJlZHJhdykuY2FsbChfY29udGV4dCwgX3RoaXMpKCk7XG4gICAgICAgIH0sIDI1MCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2l6ZU5vZGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3Jlc2l6ZU5vZGVzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2Jsb2NrUmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYWxsb3dSZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXF1ZXN0UmVkcmF3XCIsIGJpbmQkNihfY29udGV4dDIgPSB0aGlzLl9yZXF1ZXN0UmVkcmF3KS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RhcnRSZW5kZXJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyArPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdG9wUmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgLT0gMTtcbiAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gX3RoaXMucmVuZGVyUmVxdWVzdHMgPiAwO1xuICAgICAgICBfdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX3RoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMucmVuZGVyVGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJoaWRlRWRnZXNPbkRyYWdcIiwgXCJoaWRlRWRnZXNPblpvb21cIiwgXCJoaWRlTm9kZXNPbkRyYWdcIl07XG4gICAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBkcmF3aW5nIG9mIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQ2FsbHMgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIG5leHQgZnJhbWUgY2FuIG9yIHdpbGwgYmUgZHJhd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIHRpbWVvdXQgY2FzZSBvbmx5LCB3YWl0IHRoaXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbiB8IHVuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVlc3ROZXh0RnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3ROZXh0RnJhbWUoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgICAvLyBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBpdCBoYXBwZW5zIHRoYXQgdGhlIG1vY2sgd2luZG93IG9iamVjdCBpcyByZXNldCB3aGlsZVxuICAgICAgLy8gdGhlIG5leHQgZnJhbWUgaXMgc3RpbGwgcGVuZGluZy4gVGhlbiwgZWl0aGVyICd3aW5kb3cnIGlzIG5vdCBwcmVzZW50LCBvclxuICAgICAgLy8gJ3JlcXVlc3RBbmltYXRpb25GcmFtZSgpJyBpcyBub3QgcHJlc2VudCBiZWNhdXNlIGl0IGlzIG5vdCBkZWZpbmVkIG9uIHRoZVxuICAgICAgLy8gbW9jayB3aW5kb3cgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIC8vIEFzIGEgY29uc2VxdWVuY2UsIHVucmVsYXRlZCB1bml0IHRlc3RzIG1heSBhcHBlYXIgdG8gZmFpbCwgZXZlbiBpZiB0aGUgcHJvYmxlbVxuICAgICAgLy8gZGVzY3JpYmVkIGhhcHBlbnMgaW4gdGhlIGN1cnJlbnQgdW5pdCB0ZXN0LlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgbm90IHNvbWV0aGluZyB0aGF0IHdpbGwgaGFwcGVuIGluIG5vcm1hbCBvcGVyYXRpb24sIGJ1dCB3ZSBzdGlsbCBuZWVkXG4gICAgICAvLyB0byB0YWtlIGl0IGludG8gYWNjb3VudC5cbiAgICAgIC8vXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuOyAvLyBEb2luZyBgaWYgKHdpbmRvdyA9PT0gdW5kZWZpbmVkKWAgZG9lcyBub3Qgd29yayBoZXJlIVxuXG4gICAgICB2YXIgdGltZXI7XG4gICAgICB2YXIgbXlXaW5kb3cgPSB3aW5kb3c7IC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gcmVkdWNlIHRoZSBwb3NzaWJpbGl0eSB0aGF0ICd3aW5kb3cnIGlzIHJlc2V0XG4gICAgICAvLyB3aGlsZSBydW5uaW5nIHRoaXMgbWV0aG9kLlxuXG4gICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gd2FpdCBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFuZCBwZXJmb3JtIHRoZSBhbmltYXRpb24gc3RlcCBmdW5jdGlvblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQkMShjYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG15V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHRpbWVyID0gbXlXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFJlbmRlcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gdGhpcy5fcmVxdWVzdE5leHRGcmFtZShiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5fcmVuZGVyU3RlcCkuY2FsbChfY29udGV4dDMsIHRoaXMpLCB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlclN0ZXAoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHJlbmRlclRpbWVyIHNvIGEgbmV3IHNjaGVkdWxlZCBhbmltYXRpb24gc3RlcCBjYW4gYmUgc2V0XG4gICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZHJhdygpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyB0aGlzIHNjaGVkdWxlcyBhIG5ldyBzaW11bGF0aW9uIHN0ZXBcbiAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKiBjaGFydCB3aWxsIGJlIHJlc2l6ZWQgdG9vLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzZXRTaXplXCIpO1xuXG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0UmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0UmVkcmF3KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnJlZHJhd1JlcXVlc3RlZCAhPT0gdHJ1ZSAmJiB0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdE5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLl9yZWRyYXcoZmFsc2UpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGlkZGVuPWZhbHNlXSB8IFVzZWQgdG8gZ2V0IHRoZSBmaXJzdCBlc3RpbWF0ZSBvZiB0aGUgbm9kZSBzaXplcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB0aGUgbm9kZXMgYXJlIGRyYXduIGFmdGVyIHdoaWNoIHRoZXkgYXJlIHF1aWNrbHkgZHJhd24gb3Zlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgdmFyIGhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UmVkcmF3XCIpO1xuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZHJhd0xhdGVyID0ge1xuICAgICAgICAgIGRyYXdFeHRlcm5hbExhYmVsczogbnVsbFxuICAgICAgICB9OyAvLyB3aGVuIHRoZSBjb250YWluZXIgZGl2IHdhcyBoaWRkZW4sIHRoaXMgZml4ZXMgaXQgYmFjayB1cCFcblxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLndpZHRoID09PSAwIHx8IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoKTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7IC8vIGlmIHRoZSBkaXYgaXMgaGlkZGVuLCB3ZSBzdG9wIHRoZSByZWRyYXcgaGVyZSBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLmZyYW1lLmNsaWVudFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHNldCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuXG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJlZm9yZURyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZU5vZGVzT25EcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZHJhd05vZGVzID0gdGhpcy5fZHJhd05vZGVzKGN0eCwgaGlkZGVuKSxcbiAgICAgICAgICAgICAgZHJhd0V4dGVybmFsTGFiZWxzID0gX3RoaXMkX2RyYXdOb2Rlcy5kcmF3RXh0ZXJuYWxMYWJlbHM7XG5cbiAgICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzID0gZHJhd0V4dGVybmFsTGFiZWxzO1xuICAgICAgICB9IC8vIGRyYXcgdGhlIGFycm93cyBsYXN0IHNvIHRoZXkgd2lsbCBiZSBhdCB0aGUgdG9wXG5cblxuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmICgodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnID09PSBmYWxzZSkgJiYgKHRoaXMuem9vbWluZyA9PT0gZmFsc2UgfHwgdGhpcy56b29taW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPblpvb20gPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0Fycm93cyhjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdTZWxlY3Rpb25Cb3goY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFmdGVyRHJhd2luZ1wiLCBjdHgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7IC8vIHJlc3RvcmUgb3JpZ2luYWwgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Fsd2F5c1Nob3ddXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplTm9kZXMoKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGU7IC8vIHJlc2l6ZSBhbGwgbm9kZXNcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBub2RlLnJlc2l6ZShjdHgpO1xuICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG5cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd05vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3Tm9kZXMoY3R4KSB7XG4gICAgICB2YXIgYWx3YXlzU2hvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgdmFyIGhvdmVyZWQgPSBbXTtcbiAgICAgIHZhciBtYXJnaW4gPSAyMDtcbiAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAtbWFyZ2luLFxuICAgICAgICB5OiAtbWFyZ2luXG4gICAgICB9KTtcbiAgICAgIHZhciBib3R0b21SaWdodCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICsgbWFyZ2luLFxuICAgICAgICB5OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICsgbWFyZ2luXG4gICAgICB9KTtcbiAgICAgIHZhciB2aWV3YWJsZUFyZWEgPSB7XG4gICAgICAgIHRvcDogdG9wTGVmdC55LFxuICAgICAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgICAgIGJvdHRvbTogYm90dG9tUmlnaHQueSxcbiAgICAgICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LnhcbiAgICAgIH07XG4gICAgICB2YXIgX2RyYXdFeHRlcm5hbExhYmVscyA9IFtdOyAvLyBkcmF3IHVuc2VsZWN0ZWQgbm9kZXM7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07IC8vIHNldCBzZWxlY3RlZCBhbmQgaG92ZXJlZCBub2RlcyBhc2lkZVxuXG4gICAgICAgIGlmIChub2RlLmhvdmVyKSB7XG4gICAgICAgICAgaG92ZXJlZC5wdXNoKG5vZGVJbmRpY2VzW19pXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKG5vZGVJbmRpY2VzW19pXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFsd2F5c1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkcmF3TGF0ZXIgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICAgICAgaWYgKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKHZpZXdhYmxlQXJlYSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfZHJhd0xhdGVyID0gbm9kZS5kcmF3KGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChfZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKF9kcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWQubGVuZ3RoO1xuICAgICAgdmFyIGhvdmVyZWRMZW5ndGggPSBob3ZlcmVkLmxlbmd0aDsgLy8gZHJhdyB0aGUgc2VsZWN0ZWQgbm9kZXMgb24gdG9wXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RlZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tzZWxlY3RlZFtpXV07XG5cbiAgICAgICAgdmFyIF9kcmF3TGF0ZXIyID0gbm9kZS5kcmF3KGN0eCk7XG5cbiAgICAgICAgaWYgKF9kcmF3TGF0ZXIyLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICBfZHJhd0V4dGVybmFsTGFiZWxzLnB1c2goX2RyYXdMYXRlcjIuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGRyYXcgaG92ZXJlZCBub2RlcyBhYm92ZSBldmVyeXRoaW5nIGVsc2U6IGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqcy92aXMtbmV0d29yay9pc3N1ZXMvMjI2XG5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGhvdmVyZWRMZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gbm9kZXNbaG92ZXJlZFtpXV07XG5cbiAgICAgICAgdmFyIF9kcmF3TGF0ZXIzID0gbm9kZS5kcmF3KGN0eCk7XG5cbiAgICAgICAgaWYgKF9kcmF3TGF0ZXIzLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICBfZHJhd0V4dGVybmFsTGFiZWxzLnB1c2goX2RyYXdMYXRlcjMuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRyYXdFeHRlcm5hbExhYmVsczogZnVuY3Rpb24gZHJhd0V4dGVybmFsTGFiZWxzKCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KF9kcmF3RXh0ZXJuYWxMYWJlbHMpLFxuICAgICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgZHJhdyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdFZGdlcyhjdHgpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIGFycm93c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3QXJyb3dzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QXJyb3dzKGN0eCkge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVkZ2UuZHJhd0Fycm93cyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciByZXF1aXJlcyBhIHNldFRpbWVvdXQgb3IgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFRoaXMgd2FzIHJlcXVpcmVkIGJlY2F1c2VcbiAgICAgKiBzb21lIGltcGxlbWVudGF0aW9ucyAoc2FmYXJpIGFuZCBJRTkpIGRpZCBub3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBicm93c2VyVHlwZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaW5kZXhPZihicm93c2VyVHlwZSkuY2FsbChicm93c2VyVHlwZSwgXCJtc2llIDkuMFwiKSAhPSAtMSkge1xuICAgICAgICAgIC8vIElFIDlcbiAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZihicm93c2VyVHlwZSkuY2FsbChicm93c2VyVHlwZSwgXCJzYWZhcmlcIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBzYWZhcmlcbiAgICAgICAgICBpZiAoaW5kZXhPZihicm93c2VyVHlwZSkuY2FsbChicm93c2VyVHlwZSwgXCJjaHJvbWVcIikgPD0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IHNlbGVjdGlvbiBib3hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIDJEIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1NlbGVjdGlvbkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1NlbGVjdGlvbkJveChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZC54IC0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQueSAtIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueTtcbiAgICAgICAgY3R4LnJlY3QodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LCB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDE1MSwgMTk0LCAyNTIsIDAuMilcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueCwgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDE1MSwgMTk0LCAyNTIsIDEpXCI7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG59KCk7XG5cbnZhciBwYXRoJDEgPSBwYXRoJHk7XG52YXIgc2V0SW50ZXJ2YWwkMSA9IHBhdGgkMS5zZXRJbnRlcnZhbDtcblxudmFyIHNldEludGVydmFsID0gc2V0SW50ZXJ2YWwkMTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICpcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZnVuY3Rpb24gb25Ub3VjaChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xufVxuLyoqXG4gKiBSZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBhZnRlciBhIGdlc3R1cmVcbiAqXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBvblJlbGVhc2UoaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaW5hbCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIGZyYW1lIGZvciB0aGUgTmV0d29yay5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgTmV0d29yayBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gKiBub2Rlcy5cbiAqL1xuXG52YXIgQ2FudmFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXMoYm9keSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXMpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgIHRoaXMuY2FtZXJhU3RhdGUgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNWaWV3Q2VudGVyID0ge307XG4gICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhcywgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgX2NvbnRleHQ7XG5cbiAgICAgIC8vIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub25jZShcInJlc2l6ZVwiLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoud2lkdGggIT09IDApIHtcbiAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCA9IG9iai53aWR0aCAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgPSBvYmouaGVpZ2h0ICogMC41O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwic2V0U2l6ZVwiLCBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLnNldFNpemUpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmhhbW1lckZyYW1lLmRlc3Ryb3koKTtcblxuICAgICAgICBfdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIF90aGlzLl9jbGVhblVwKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmllbGRzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJhdXRvUmVzaXplXCJdO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH0gLy8gQXV0b21hdGljYWxseSBhZGFwdCB0byBjaGFuZ2luZyBzaXplIG9mIHRoZSBjb250YWluZXIgZWxlbWVudC5cblxuXG4gICAgICB0aGlzLl9jbGVhblVwKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Jlc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICAgIGlmICh3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAvLyBkZWNlbnQgYnJvd3NlcnMsIGltbWVkaWF0ZSByZWFjdGlvbnNcbiAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpczIuc2V0U2l6ZSgpO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lO1xuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZnJhbWUpO1xuXG4gICAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShmcmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSUUxMSwgY29udGlub3VzIHBvbGxpbmdcbiAgICAgICAgICB2YXIgcmVzaXplVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzMi5zZXRTaXplKCk7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVzaXplVGltZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIEF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gY2hhbmdpbmcgc2l6ZSBvZiB0aGUgYnJvd3Nlci5cblxuXG4gICAgICAgIHZhciByZXNpemVGdW5jdGlvbiA9IGJpbmQkNihfY29udGV4dDIgPSB0aGlzLl9vblJlc2l6ZSkuY2FsbChfY29udGV4dDIsIHRoaXMpO1xuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcInJlc2l6ZVwiLCByZXNpemVGdW5jdGlvbik7XG5cbiAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgXCJyZXNpemVcIiwgcmVzaXplRnVuY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblVwKCkge1xuICAgICAgdmFyIF9jb250ZXh0MywgX2NvbnRleHQ0LCBfY29udGV4dDU7XG5cbiAgICAgIGZvckVhY2gkMihfY29udGV4dDMgPSByZXZlcnNlKF9jb250ZXh0NCA9IHNwbGljZSQxKF9jb250ZXh0NSA9IHRoaXMuX2NsZWFudXBDYWxsYmFja3MpLmNhbGwoX2NvbnRleHQ1LCAwKSkuY2FsbChfY29udGV4dDQpKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25SZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICAgICAgdGhpcy5zZXRTaXplKCk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuZCBzdG9yZSB0aGUgY2FtZXJhU3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz10aGlzLnBpeGVsUmF0aW9dXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDYW1lcmFTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5waXhlbFJhdGlvO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGggPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQgPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24gPSB0aGlzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8sXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpb1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYW1lcmFTdGF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDYW1lcmFTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICE9PSAwICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAhPT0gMCAmJiB0aGlzLnBpeGVsUmF0aW8gIT09IDAgJiYgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID4gMCAmJiB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0ID4gMCkge1xuICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0O1xuICAgICAgICB2YXIgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlO1xuXG4gICAgICAgIGlmICh3aWR0aFJhdGlvICE9IDEgJiYgaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIDAuNSAqICh3aWR0aFJhdGlvICsgaGVpZ2h0UmF0aW8pO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoUmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIHdpZHRoUmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIGhlaWdodFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBuZXdTY2FsZTsgLy8gdGhpcyBjb21lcyBmcm9tIHRoZSB2aWV3IG1vZHVsZS5cblxuICAgICAgICB2YXIgY3VycmVudFZpZXdDZW50ZXIgPSB0aGlzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgICAgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgeDogY3VycmVudFZpZXdDZW50ZXIueCAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueCxcbiAgICAgICAgICB5OiBjdXJyZW50Vmlld0NlbnRlci55IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHJlcGFyZVZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlVmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgXCJweFwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGluZGV4T2YodmFsdWUpLmNhbGwodmFsdWUsIFwiJVwiKSAhPT0gLTEgfHwgaW5kZXhPZih2YWx1ZSkuY2FsbCh2YWx1ZSwgXCJweFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZih2YWx1ZSkuY2FsbCh2YWx1ZSwgXCIlXCIpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdXNlIHRoZSB2YWx1ZSBzdXBwbGllZCBmb3Igd2lkdGggb3IgaGVpZ2h0OlwiICsgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIEhUTUxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICB3aGlsZSAodGhpcy5ib2R5LmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmJvZHkuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gXCJ2aXMtbmV0d29ya1wiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgdGhpcy5mcmFtZS50YWJJbmRleCA9IDA7IC8vIHRhYiBpbmRleCBpcyByZXF1aXJlZCBmb3Iga2V5Y2hhcm0gdG8gYmluZCBrZXlzdHJva2VzIHRvIHRoZSBkaXYgaW5zdGVhZCBvZiB0aGUgd2luZG93XG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgdGhpcy5mcmFtZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuY2FudmFzKTtcblxuICAgICAgaWYgKCF0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XG4gICAgICAgIG5vQ2FudmFzLmlubmVyVGV4dCA9IFwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCI7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFBpeGVsUmF0aW8oKTtcblxuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgpO1xuICAgICAgfSAvLyBhZGQgdGhlIGZyYW1lIHRvIHRoZSBjb250YWluZXIgZWxlbWVudFxuXG5cbiAgICAgIHRoaXMuYm9keS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IDE7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fYmluZEhhbW1lcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGJpbmRzIGhhbW1lciwgaXQgY2FuIGJlIHJlcGVhdGVkIG92ZXIgYW5kIG92ZXIgZHVlIHRvIHRoZSB1bmlxdWVuZXNzIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kSGFtbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307IC8vIGluaXQgaGFtbWVyXG5cbiAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmZyYW1lLmNhbnZhcyk7XG4gICAgICB0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5zZXQoe1xuICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgIH0pOyAvLyBlbmFibGUgdG8gZ2V0IGJldHRlciByZXNwb25zZSwgdG9kbzogdGVzdCBvbiBtb2JpbGUuXG5cbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBhblwiKS5zZXQoe1xuICAgICAgICB0aHJlc2hvbGQ6IDUsXG4gICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTExcbiAgICAgIH0pO1xuICAgICAgb25Ub3VjaCh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcImRvdWJsZXRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXAoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInByZXNzXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbnN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFubW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5lbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGluY2hcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2goZXZlbnQpO1xuICAgICAgfSk7IC8vIFRPRE86IG5lYXRseSBjbGVhbnVwIHRoZXNlIGhhbmRsZXJzIHdoZW4gcmUtY3JlYXRpbmcgdGhlIENhbnZhcywgSUYgdGhlc2UgYXJlIGRvbmUgd2l0aCBoYW1tZXIsIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB3aWxsIG5vdCB3b3JrP1xuXG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkNvbnRleHQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lckZyYW1lID0gbmV3IEhhbW1lcih0aGlzLmZyYW1lKTtcbiAgICAgIG9uUmVsZWFzZSh0aGlzLmhhbW1lckZyYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgc2l6ZSBmb3IgdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCAgIFdpZHRoIGluIHBpeGVscyBvciBwZXJjZW50YWdlIChmb3IgZXhhbXBsZSAnODAwcHgnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzUwJScpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAgSGVpZ2h0IGluIHBpeGVscyBvciBwZXJjZW50YWdlICAoZm9yIGV4YW1wbGUgJzQwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICczMCUnKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaXplKCkge1xuICAgICAgdmFyIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm9wdGlvbnMuaGVpZ2h0O1xuICAgICAgd2lkdGggPSB0aGlzLl9wcmVwYXJlVmFsdWUod2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fcHJlcGFyZVZhbHVlKGhlaWdodCk7XG4gICAgICB2YXIgZW1pdEV2ZW50ID0gZmFsc2U7XG4gICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQ7IC8vIHVwZGF0ZSB0aGUgcGl4ZWwgcmF0aW9cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBDb21tZW50IGluIGZvbGxvd2luZyBpcyByYXRoZXIgaW5jb25zaXN0ZW50OyB0aGlzIGlzIHRoZSBPTkxZIHBsYWNlIGluIHRoZSBjb2RlXG4gICAgICAvLyAgICAgICB3aGVyZSBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBpeGVsIHJhdGlvIGNvdWxkIGNoYW5nZSBhdCBydW50aW1lLlxuICAgICAgLy8gICAgICAgVGhlIG9ubHkgd2F5IEkgY2FuIHRoaW5rIG9mIHRoaXMgaGFwcGVuaW5nIGlzIGEgcm90YXRpbmcgc2NyZWVuIG9yIHRhYmxldDsgYnV0IHRoZW5cbiAgICAgIC8vICAgICAgIHRoZXJlIHNob3VsZCBiZSBhIG1lY2hhbmlzbSBmb3IgcmVsb2FkaW5nIHRoZSBkYXRhIChUT0RPOiBjaGVjayBpZiB0aGlzIGlzIHByZXNlbnQpLlxuICAgICAgLy9cbiAgICAgIC8vICAgICAgIElmIHRoZSBhc3N1bXB0aW9uIGlzIHRydWUgKGkuZS4gcGl4ZWwgcmF0aW8gY2FuIGNoYW5nZSBhdCBydW50aW1lKSwgdGhlbiAqYWxsKiB1c2FnZVxuICAgICAgLy8gICAgICAgb2YgcGl4ZWwgcmF0aW8gbXVzdCBiZSBvdmVyaGF1bGVkIGZvciB0aGlzLlxuICAgICAgLy9cbiAgICAgIC8vICAgICAgIEZvciB0aGUgdGltZSBiZWluZywgSSB3aWxsIGh1bW9yIHRoZSBhc3N1bXB0aW9uIGhlcmUsIGFuZCBpbiB0aGUgcmVzdCBvZiB0aGUgY29kZSBhc3N1bWUgaXQgaXNcbiAgICAgIC8vICAgICAgIGNvbnN0YW50LlxuXG4gICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbzsgLy8gd2UgY2FjaGUgdGhpcyBiZWNhdXNlIHRoZSBjYW1lcmEgc3RhdGUgc3RvcmFnZSBuZWVkcyB0aGUgb2xkIHZhbHVlXG5cbiAgICAgIHRoaXMuX3NldFBpeGVsUmF0aW8oKTtcblxuICAgICAgaWYgKHdpZHRoICE9IHRoaXMub3B0aW9ucy53aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5vcHRpb25zLmhlaWdodCB8fCB0aGlzLmZyYW1lLnN0eWxlLndpZHRoICE9IHdpZHRoIHx8IHRoaXMuZnJhbWUuc3R5bGUuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcblxuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXNWaWV3Q2VudGVyID0ge1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jbGllbnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgd291bGQgYWRhcHQgdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdG8gdGhlIHdpZHRoIGZyb20gMTAwJSBpZiBhbmQgb25seSBpZlxuICAgICAgICAvLyB0aGVyZSBpcyBhIGNoYW5nZS5cbiAgICAgICAgdmFyIG5ld1dpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7IC8vIHN0b3JlIHRoZSBjYW1lcmEgaWYgdGhlcmUgaXMgYSBjaGFuZ2UgaW4gc2l6ZS5cblxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoIHx8IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVtaXRFdmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzaXplXCIsIHtcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgb2xkV2lkdGg6IE1hdGgucm91bmQob2xkV2lkdGggLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIG9sZEhlaWdodDogTWF0aC5yb3VuZChvbGRIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8pXG4gICAgICAgIH0pOyAvLyByZXN0b3JlIHRoZSBjYW1lcmEgb24gY2hhbmdlLlxuXG4gICAgICAgIHRoaXMuX3NldENhbWVyYVN0YXRlKCk7XG4gICAgICB9IC8vIHNldCBpbml0aWFsaXplZCBzbyB0aGUgZ2V0IGFuZCBzZXQgY2FtZXJhIHdpbGwgd29yayBmcm9tIG5vdyBvbi5cblxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBlbWl0RXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgcGl4ZWwgcmF0aW8gZm9yIHZhcmlvdXMgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lUGl4ZWxSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lUGl4ZWxSYXRpbygpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgY2FudmF4IGNvbnRleHRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBudW1lcmF0b3IgPSAxO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyAod2luZG93ICE9PSB1bmRlZmluZWQpIGRvZXNuJ3Qgd29yayBoZXJlIVxuICAgICAgICAvLyBQcm90ZWN0aW9uIGR1cmluZyB1bml0IHRlc3RzLCB3aGVyZSAnd2luZG93JyBjYW4gYmUgbWlzc2luZ1xuICAgICAgICBudW1lcmF0b3IgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgcmV0dXJuIG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMYXp5IGRldGVybWluYXRpb24gb2YgcGl4ZWwgcmF0aW8uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFBpeGVsUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBpeGVsUmF0aW8oKSB7XG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPSB0aGlzLl9kZXRlcm1pbmVQaXhlbFJhdGlvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdHJhbnNmb3JtIGluIHRoZSBjb250YWluZWQgY29udGV4dCwgYmFzZWQgb24gaXRzIHBpeGVsUmF0aW9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZheCBjb250ZXh0XCIpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9YY29udmVydERPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9YY29udmVydERPTXRvQ2FudmFzKHgpIHtcbiAgICAgIHJldHVybiAoeCAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgKiB0aGUgWCBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfWGNvbnZlcnRDYW52YXNUb0RPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRDYW52YXNUb0RPTSh4KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAqIHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ZY29udmVydERPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydERPTXRvQ2FudmFzKHkpIHtcbiAgICAgIHJldHVybiAoeSAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfWWNvbnZlcnRDYW52YXNUb0RPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRDYW52YXNUb0RPTSh5KSB7XG4gICAgICByZXR1cm4geSAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9zXG4gICAgICogQHJldHVybnMge3BvaW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FudmFzVG9ET00ocG9zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl9YY29udmVydENhbnZhc1RvRE9NKHBvcy54KSxcbiAgICAgICAgeTogdGhpcy5fWWNvbnZlcnRDYW52YXNUb0RPTShwb3MueSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9zXG4gICAgICogQHJldHVybnMge3BvaW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiRE9NdG9DYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gRE9NdG9DYW52YXMocG9zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl9YY29udmVydERPTXRvQ2FudmFzKHBvcy54KSxcbiAgICAgICAgeTogdGhpcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb3MueSlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZhcztcbn0oKTtcblxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoZSBmaXQgb3B0aW9ucywgcmVwbGFjZSBtaXNzaW5nIG9wdGlvbmFsIHZhbHVlcyBieSBkZWZhdWx0cyBldGMuXHJcbiAqXHJcbiAqIEBwYXJhbSByYXdPcHRpb25zIC0gVGhlIHJhdyBvcHRpb25zLlxyXG4gKiBAcGFyYW0gYWxsTm9kZUlkcyAtIEFsbCBub2RlIGlkcyB0aGF0IHdpbGwgYmUgdXNlZCBpZiBub2RlcyBhcmUgb21pdHRlZCBpblxyXG4gKiB0aGUgcmF3IG9wdGlvbnMuXHJcbiAqIEByZXR1cm5zIE9wdGlvbnMgd2l0aCBldmVyeXRoaW5nIGZpbGxlZCBpbiBhbmQgdmFsaWRhdGVkLlxyXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZpdE9wdGlvbnMocmF3T3B0aW9ucywgYWxsTm9kZUlkcykge1xuICB2YXIgb3B0aW9ucyA9IGFzc2lnbiQyKHtcbiAgICBub2RlczogYWxsTm9kZUlkcyxcbiAgICBtaW5ab29tTGV2ZWw6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgbWF4Wm9vbUxldmVsOiAxXG4gIH0sIHJhd09wdGlvbnMgIT09IG51bGwgJiYgcmF3T3B0aW9ucyAhPT0gdm9pZCAwID8gcmF3T3B0aW9ucyA6IHt9KTtcblxuICBpZiAoIWlzQXJyYXkkMihvcHRpb25zLm5vZGVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb2RlcyBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgaWRzLlwiKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIG9wdGlvbnMubm9kZXMgPSBhbGxOb2RlSWRzO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIG9wdGlvbnMubWluWm9vbUxldmVsID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMubWluWm9vbUxldmVsID4gMCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWluIHpvb20gbGV2ZWwgaGFzIHRvIGJlIGEgbnVtYmVyIGhpZ2hlciB0aGFuIHplcm8uXCIpO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIG9wdGlvbnMubWF4Wm9vbUxldmVsID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMubWluWm9vbUxldmVsIDw9IG9wdGlvbnMubWF4Wm9vbUxldmVsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNYXggem9vbSBsZXZlbCBoYXMgdG8gYmUgYSBudW1iZXIgaGlnaGVyIHRoYW4gbWluIHpvb20gbGV2ZWwuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogVGhlIHZpZXdcbiAqL1xuXG52YXIgVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBWaWV3KGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfY29udGV4dCxcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICBfY29udGV4dDI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gdGhpcy5yZW5kZXJSZWZyZXNoUmF0ZTtcbiAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gXCJlYXNlSW5PdXRRdWludFwiO1xuICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VTY2FsZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTY2FsZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy50YXJnZXRUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJmaXRcIiwgYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5maXQpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFuaW1hdGlvbkZpbmlzaGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJ1bmxvY2tOb2RlXCIsIGJpbmQkNihfY29udGV4dDIgPSB0aGlzLnJlbGVhc2VOb2RlKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFZpZXcsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gem9vbXMgb3V0IHRvIGZpdCBhbGwgZGF0YSBvbiBzY3JlZW4gYmFzZWQgb24gYW1vdW50IG9mIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e3tub2Rlcz1BcnJheX19XVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdGlhbFpvb209ZmFsc2VdICB8IHpvb20gYmFzZWQgb24gZml0dGVkIGZvcm11bGEgb3IgcmFuZ2UsIHRydWUgPSBmaXR0ZWQsIGRlZmF1bHQgPSBmYWxzZTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXQob3B0aW9ucykge1xuICAgICAgdmFyIGluaXRpYWxab29tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIG9wdGlvbnMgPSBub3JtYWxpemVGaXRPcHRpb25zKG9wdGlvbnMsIHRoaXMuYm9keS5ub2RlSW5kaWNlcyk7XG4gICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIHZhciByYW5nZTtcbiAgICAgIHZhciB6b29tTGV2ZWw7XG5cbiAgICAgIGlmIChjYW52YXNXaWR0aCA9PT0gMCB8fCBjYW52YXNIZWlnaHQgPT09IDApIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBwb2ludCBpbiB0cnlpbmcgdG8gZml0IGludG8gemVybyBzaXplZCBjYW52YXMuIFRoaXMgY291bGRcbiAgICAgICAgLy8gcG90ZW50aWFsbHkgZXZlbiByZXN1bHQgaW4gaW52YWxpZCB2YWx1ZXMgYmVpbmcgY29tcHV0ZWQuIEZvciBleGFtcGxlXG4gICAgICAgIC8vIGZvciBuZXR3b3JrIHdpdGhvdXQgbm9kZXMgYW5kIHplcm8gc2l6ZWQgY2FudmFzIHRoZSB6b29tIGxldmVsIHdvdWxkXG4gICAgICAgIC8vIGVuZCB1cCBiZWluZyBjb21wdXRlZCBhcyAwLzAgd2hpY2ggcmVzdWx0cyBpbiBOYU4uIEluIGFueSBvdGhlciBjYXNlXG4gICAgICAgIC8vIHRoaXMgd291bGQgYmUgMC9zb21ldGhpbmcgd2hpY2ggaXMgYWdhaW4gcG9pbnRsZXNzIHRvIGNvbXB1dGUuXG4gICAgICAgIHpvb21MZXZlbCA9IDE7XG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFpvb20gPT09IHRydWUpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgbW9yZSB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uLiBJZiBzbywgd2UgdXNlIHRoZSByYW5nZSwgbm90IHRoZSBhcHByb3hpbWF0aW9uLlxuICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb25EZWZpbmVkID4gMC41ICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG4gICAgICAgIHZhciBudW1iZXJPZk5vZGVzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgem9vbUxldmVsID0gMTIuNjYyIC8gKG51bWJlck9mTm9kZXMgKyA3LjQxNDcpICsgMC4wOTY0ODIyOyAvLyB0aGlzIGlzIG9idGFpbmVkIGZyb20gZml0dGluZyBhIGRhdGFzZXQgZnJvbSA1IHBvaW50cyB3aXRoIHNjYWxlIGxldmVscyB0aGF0IGxvb2tlZCBnb29kLlxuICAgICAgICAvLyBjb3JyZWN0IGZvciBsYXJnZXIgY2FudmFzc2VzLlxuXG4gICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLm1pbihjYW52YXNXaWR0aCAvIDYwMCwgY2FudmFzSGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgem9vbUxldmVsICo9IGZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgICAgdmFyIHhEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFggLSByYW5nZS5taW5YKSAqIDEuMTtcbiAgICAgICAgdmFyIHlEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFkgLSByYW5nZS5taW5ZKSAqIDEuMTtcbiAgICAgICAgdmFyIHhab29tTGV2ZWwgPSBjYW52YXNXaWR0aCAvIHhEaXN0YW5jZTtcbiAgICAgICAgdmFyIHlab29tTGV2ZWwgPSBjYW52YXNIZWlnaHQgLyB5RGlzdGFuY2U7XG4gICAgICAgIHpvb21MZXZlbCA9IHhab29tTGV2ZWwgPD0geVpvb21MZXZlbCA/IHhab29tTGV2ZWwgOiB5Wm9vbUxldmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoem9vbUxldmVsID4gb3B0aW9ucy5tYXhab29tTGV2ZWwpIHtcbiAgICAgICAgem9vbUxldmVsID0gb3B0aW9ucy5tYXhab29tTGV2ZWw7XG4gICAgICB9IGVsc2UgaWYgKHpvb21MZXZlbCA8IG9wdGlvbnMubWluWm9vbUxldmVsKSB7XG4gICAgICAgIHpvb21MZXZlbCA9IG9wdGlvbnMubWluWm9vbUxldmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyID0gTmV0d29ya1V0aWwuZmluZENlbnRlcihyYW5nZSk7XG4gICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgcG9zaXRpb246IGNlbnRlcixcbiAgICAgICAgc2NhbGU6IHpvb21MZXZlbCxcbiAgICAgICAgYW5pbWF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblxuICAgICAgfTtcbiAgICAgIHRoaXMubW92ZVRvKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgIH0gLy8gYW5pbWF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXIgYSBub2RlIGluIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMobm9kZUlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCxcbiAgICAgICAgICB5OiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSBub2RlUG9zaXRpb247XG4gICAgICAgIG9wdGlvbnMubG9ja2VkT25Ob2RlID0gbm9kZUlkO1xuICAgICAgICB0aGlzLm1vdmVUbyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlOiBcIiArIG5vZGVJZCArIFwiIGNhbm5vdCBiZSBmb3VuZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBtb3ZlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5hbmltYXRpb24gPSB7ZHVyYXRpb246bnVtYmVyLCBlYXNpbmdGdW5jdGlvbjpTdHJpbmd9IHx8IEJvb2xlYW4gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC54ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHggaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9ICtvcHRpb25zLm9mZnNldC54O1xuXG4gICAgICAgICAgaWYgKCFfaXNGaW5pdGUob3B0aW9ucy5vZmZzZXQueCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJvZmZzZXQueFwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeSBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLm9mZnNldC55ID0gK29wdGlvbnMub2Zmc2V0Lnk7XG5cbiAgICAgICAgICBpZiAoIV9pc0Zpbml0ZShvcHRpb25zLm9mZnNldC55KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcIm9mZnNldC55XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMub2Zmc2V0ID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeCBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnggPSArb3B0aW9ucy5wb3NpdGlvbi54O1xuXG4gICAgICAgICAgaWYgKCFfaXNGaW5pdGUob3B0aW9ucy5wb3NpdGlvbi54KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInBvc2l0aW9uLnhcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ueSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB5IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueSA9ICtvcHRpb25zLnBvc2l0aW9uLnk7XG5cbiAgICAgICAgICBpZiAoIV9pc0Zpbml0ZShvcHRpb25zLnBvc2l0aW9uLnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwicG9zaXRpb24ueVwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSB0aGlzLmdldFZpZXdQb3NpdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgdGhlIHNjYWxlIGlzIHZhbGlkLlxuICAgICAgICBvcHRpb25zLnNjYWxlID0gK29wdGlvbnMuc2NhbGU7XG5cbiAgICAgICAgaWYgKCEob3B0aW9ucy5zY2FsZSA+IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInNjYWxlXCIgaGFzIHRvIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID0gMTAwMDtcbiAgICAgIH0gLy8gZGVmYXVsdCBkdXJhdGlvblxuXG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID0gXCJlYXNlSW5PdXRRdWFkXCI7XG4gICAgICB9IC8vIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG5cblxuICAgICAgdGhpcy5hbmltYXRlVmlldyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMudGltZSAgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBhbmltYXRlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIGFuaW1hdGUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5lYXNpbmdGdW5jdGlvbiA9IFN0cmluZyAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgZWFzZUluT3V0Q3ViaWMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJblF1YXJ0LCBlYXNlT3V0UXVhcnQsIGVhc2VJbk91dFF1YXJ0LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZVZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVZpZXcob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbjsgLy8gcmVsZWFzZSBpZiBzb21ldGhpbmcgZm9jdXNzZWQgb24gdGhlIG5vZGVcblxuICAgICAgdGhpcy5yZWxlYXNlTm9kZSgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5sb2NrZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IG9wdGlvbnMubG9ja2VkT25Ob2RlO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IG9wdGlvbnMub2Zmc2V0O1xuICAgICAgfSAvLyBmb3JjZWZ1bGx5IGNvbXBsZXRlIHRoZSBvbGQgYW5pbWF0aW9uIGlmIGl0IHdhcyBzdGlsbCBydW5uaW5nXG5cblxuICAgICAgaWYgKHRoaXMuZWFzaW5nVGltZSAhPSAwKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25SZWRyYXcodHJ1ZSk7IC8vIGJ5IHNldHRpbmcgZWFzaW5ndGltZSB0byAxLCB3ZSBmaW5pc2ggdGhlIGFuaW1hdGlvbi5cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZVNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB0aGlzLnRhcmdldFNjYWxlID0gb3B0aW9ucy5zY2FsZTsgLy8gc2V0IHRoZSBzY2FsZSBzbyB0aGUgdmlld0NlbnRlciBpcyBiYXNlZCBvbiB0aGUgY29ycmVjdCB6b29tIGxldmVsLiBUaGlzIGlzIG92ZXJyaWRkZW4gaW4gdGhlIHRyYW5zaXRpb25SZWRyYXdcbiAgICAgIC8vIGJ1dCBhdCBsZWFzdCB0aGVuIHdlJ2xsIGhhdmUgdGhlIHRhcmdldCB0cmFuc2l0aW9uXG5cbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHtcbiAgICAgICAgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgIHg6IHZpZXdDZW50ZXIueCAtIG9wdGlvbnMucG9zaXRpb24ueCxcbiAgICAgICAgeTogdmlld0NlbnRlci55IC0gb3B0aW9ucy5wb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdGhpcy50YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueCxcbiAgICAgICAgeTogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueVxuICAgICAgfTsgLy8gaWYgdGhlIHRpbWUgaXMgc2V0IHRvIDAsIGRvbid0IGRvIGFuIGFuaW1hdGlvblxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMuX2xvY2tlZFJlZHJhdykuY2FsbChfY29udGV4dDMsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnRhcmdldFNjYWxlO1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0gdGhpcy50YXJnZXRUcmFuc2xhdGlvbjtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDQ7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDEgLyAoNjAgKiBvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiAqIDAuMDAxKSB8fCAxIC8gNjA7IC8vIDYwIGZvciA2MCBzZWNvbmRzLCAwLjAwMSBmb3IgbWlsbGknc1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbjtcbiAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBiaW5kJDYoX2NvbnRleHQ0ID0gdGhpcy5fdHJhbnNpdGlvblJlZHJhdykuY2FsbChfY29udGV4dDQsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB1c2VkIHRvIGFuaW1hdGUgc21vb3RobHkgYnkgaGlqYWNraW5nIHRoZSByZWRyYXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvY2tlZFJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9ja2VkUmVkcmF3KCkge1xuICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLngsXG4gICAgICAgIHk6IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS55XG4gICAgICB9O1xuICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gbm9kZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG5vZGVQb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdmFyIHNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB2YXIgdGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueCxcbiAgICAgICAgeTogc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55XG4gICAgICB9O1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0YXJnZXRUcmFuc2xhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHN0YXRlIG9mIGEgbG9ja2VkIG9uIE5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbGVhc2VOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2VOb2RlKCkge1xuICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZpZXdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmluaXNoZWQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl90cmFuc2l0aW9uUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2l0aW9uUmVkcmF3KCkge1xuICAgICAgdmFyIGZpbmlzaGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHRoaXMuZWFzaW5nVGltZSArPSB0aGlzLmFuaW1hdGlvblNwZWVkO1xuICAgICAgdGhpcy5lYXNpbmdUaW1lID0gZmluaXNoZWQgPT09IHRydWUgPyAxLjAgOiB0aGlzLmVhc2luZ1RpbWU7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSBlYXNpbmdGdW5jdGlvbnNbdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbl0odGhpcy5lYXNpbmdUaW1lKTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy5zb3VyY2VTY2FsZSArICh0aGlzLnRhcmdldFNjYWxlIC0gdGhpcy5zb3VyY2VTY2FsZSkgKiBwcm9ncmVzcztcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyAodGhpcy50YXJnZXRUcmFuc2xhdGlvbi54IC0gdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54KSAqIHByb2dyZXNzLFxuICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyAodGhpcy50YXJnZXRUcmFuc2xhdGlvbi55IC0gdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55KSAqIHByb2dyZXNzXG4gICAgICB9OyAvLyBjbGVhbnVwXG5cbiAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgPj0gMS4wKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmVhc2luZ1RpbWUgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDU7XG5cbiAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IGJpbmQkNihfY29udGV4dDUgPSB0aGlzLl9sb2NrZWRSZWRyYXcpLmNhbGwoX2NvbnRleHQ1LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFuaW1hdGlvbkZpbmlzaGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWV3O1xufSgpO1xuXG52YXIgY3NzXzI0OHokMSA9IFwiZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbiB7XFxuICB3aWR0aDogMzRweDtcXG4gIGhlaWdodDogMzRweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMTdweDtcXG4gIGJvcmRlci1yYWRpdXM6IDE3cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAycHggMnB4O1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b246aG92ZXIge1xcbiAgYm94LXNoYWRvdzogMCAwIDNweCAzcHggcmdiYSg1NiwgMjA3LCAyMSwgMC4zKTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbjphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMCAwIDFweCAzcHggcmdiYSg1NiwgMjA3LCAyMSwgMC45NSk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLXVwIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQnBoSlJFRlVlTnFjVjJ0d1U5Y1IvbmJQbFZUSHhwS1JiTm5CTHlFYlB5SmlzTEVjUHdnd1VNS1F0ak5KQXpOSlprZ05OSk9tSmFaQWFES2x4YVhEVElCQWNKdE9PelNZS1NrZGlpbWhBZElNanlUNGJZZ0JZeEEyQmdjVVFQTHJDaUdEUjRxdDJ4K3lYVEFTRnQxLzk1N2Q3enQzejNkMzl4RENNUVdVZmdBei9SSS9UNHBTVEFKcEFHTDhyRUNBWFg3UUZRR3E5d09IT3hZTzFvQ2dqQWRKajF3dEIwOTVHaXY5VEZ1WkFJV0hBemlBVE1QaFRBd2lIZ1VrWVBYRkp1OTJsTVAvMk1UcEIxQUtVQ1ZFZ05BY2xlVW8xTSsyRjhUTzZjclNUbmNiMVFsZUFPajJPVFNYM0dlMXArVmE0Mm01SnJuemJuc0NFOE92K0VIZ3BhMExQTHZDSmpaL3dodUlsTjh3QWNYRytlMUxVbjlobTIzOFFVODRwMUxkODNuc1h2dU83THErTHpLWUdBVDYvZG41OG0vSEpUWWY0TzNFU2hrVDhJcnB6YWIxVXo5c0dldlQ1K3RXbitqNk5CNEE1aHAvNU5TcjQzeGpmZDVyVzV0VDllM09BaENCaUN1YTUvV3NERWxzL2hkdllrbFpTd0RlZm1yVDhlWG10enVEa2I1WVozM3A5bmR5bElDQVZqV3hmMzl4dy81ZzVMdXYvOUg4NFpXTmN3TkV5cFpUODdyWGpxeUpCODVVWURNSllOM1U3VWRMSjYvNkpsZ3FWNTE3dGVScWY5dVRsdWc4ZTF6RWsyN0hnRDIybzk4V3NUQmg4Zld4dmptNkFwZE9OYkd2c2U4TE01TlVQT20xQ2ZhYnV6M25BQ0FneFgwUUVGVEpBbmpOdkxKK1NlcGIxNEtSSG5OK0V2KzFYSk9oWnMzUXUxbWJHOTdKMk5RZ3NYcm9hMWR0eHJHdWY4Y0hpMW1VdFBUYXkwbHYxRE1KU0NSVkx0b1grRmdHZ0RRTnlzQkFjZXo4OWw5bmJic1FTamk3cmxYa0VoalB4Yi9RYXRIT2NGdTBNOXp6NDE5b0ZTUmhqLzNQdWFIaXlxYXN2MUNvbjlOR3hIQVlVc29DeEFxSW1iWVNnQ1dtRmJaUXdkc3VyN04wZUM0bTZ0VDYvalVaNzUwWmViODJjK09aR0xXaC8ycC9XK0tmcm15MGhJcC9hVktwVFNJSkVxdTJRZ0Z4MmlFOEN3RHAwUmJIN0xqbmcvNHlYcitYVDNRZHloWXNvZFMwc2xHcjBnMk9yRVVLN2VDcktXODJTcXpDVnozL3lmYjZ2UndNNHhuOXJON0prUmtPUVJMbWZKbjJMQlB4UWpEQnFwOWxEN1hiWDdYOHBLVFAxNjB6UjJiZGVpWDVqWWVVL25MU1R6dE5rZW0zWEw1ZVhibHRSVWtvbkJ4ZGdaMklJVW1haFV4RVJRU0NWVCtySzVoelE4OXhRNlA4VmFhSzFmNVZtUnZxUTRHK2xiYStubG5sYjVick1odmxrN0ZCaWFQenV3UUVtRVFoZzVCT3hNaldUbmNIYzI1MDFjUUxrakRUc01DV3B5dVJReEZQMHhYSUpmcDVGeVZXNFp5N0thakMwNkl0YmlJR2c2WklUQnhEeElnYnJyMWpUU00wZmliR0lIejhPOXNLSzBHQWliRXVhOXNwQU5oNGFZMlZtY0VnK0RFa2lCZ1IvTDJoWUZnR3RjRXJrUVFBTVZKZ0J4eXk5aGJvWnp2MzJ2K0twcjdxYkVFQ1RBSU1Bb2FKYTNxUFRtTmlpQUFnSkFqazZKNXhodTZIREFJZ1FZR0xtSTI5UG9jbU1jSThNTll2VDFja2Z6RDlIL3ViNWJyNGU0TWU5V2ZPS3F0eVg2VWQyY3dDNDQ5UFJhbWlmRG02QXVjMHJUWG9rY2krWG8xRUFnQmNraUR1WUdManBUdm50Y0dJQStTRmNwNnVVQWFBSTg3OVZoV3JSdGVZQXFuL2VkcTc1OGJyWEoxMzI3UU1oZ0pjWmpBM0VCak5yZ1pqT0cxUGtBanlUR0VOTWpaUHE1RUNRME1ERTlFUkJxRlpyazBPSjNpNHgvN3Z5SWpCeEdFUnQzdGFrZ1ZKRUFwOXhxM2Y3NjlXaVBETnZTc0pkVDNIRE9FQVNQZWxtb0JSWVQzS3p0NXVNdHdhdUpFZ1NPQ3B3cmsxRElKQ29OVU13ajl2N013ZVA5WFNROC9oSlBwNDk2ZlpUQUlDdkxxY3l2MkI3blJicmdDQTAzSk41aDh1YjdBOFZxcEI0Mzd4SHZzT3kzbDNjeWFCNEwydXF4aHRpMVdMTWNTZ1pRQ3c3K2JPb29PM1BrNEpCWklZWVhJU01WNXNLSDU5VWVQTTEwR0VTUkdwSWYvYkU5MkhVNDUySHl3U0pJR0lsbGN0cmhwNllBSzUrZkhkczBsTHRKRk1YTndrVjZmRnFBMjltUk9lZnFpTUpqMWg2dW00YTV2WS85MmRLR2FCeEloVTV6SlRXVzJjSm1FZ0dPbWViM2M4RnhBZmI5bWRmMlJ6eUdHdjVNdlU3UXd1RXlTd0tIRnAvYy9NNzF6QS8yRjdiMVJham5ZZExBcU11a01WdTJZY2ZtRFlFMk1EN0grNy9YbHE2Y1JJSnFtNHpYTStxZDNUR2pWQmlyNDNLU0xsWGppRUxlNVRzWCszL3lXL1NUNDVQYUFIYkttY2NXaDEyQVA5M0pOWnl3ajBrU0FCSW9icGlYUkhqdFo2ZmFvdXQydHlaTWFkR0xYQkN4QmN2bDZOZmFBeit0S2RGbU9icHpXbDIrdElJQkFDWXkwdC95ajM0TTdIdnNLVUsrQ0dhc3N2aWNYN2FsWUR3d3ErdnlrSUVxUFZhK1E5Z2RZazUrVitVRTdsajMrRkdidUJNL1g1SlVUOFF3SVZTU1NaaVRnbW9GUjJNZmlxWUZGUGZqcGt5cmZXUG9wd3hQNDdBUDFwSzFnOS9kcWVBQUFBQUVsRlRrU3VRbUNDJyk7XFxuICBib3R0b206IDUwcHg7XFxuICBsZWZ0OiA1NXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy1kb3duIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQnBkSlJFRlVlTnFjVjIxUWxOY1ZmcDV6WDlpa29BdkxFc0FJSWdzb0h3cHFXQVFVTktMTmFOdjhpWjFKTWtORzYvUWovZERVeUNTVHRDSHBtRWt3VmszVFRvWlJNalhqNU1PRzJLaWRqSWt4UVlTQVFVQXRYNklnSU44c3U4S0NvT3piSDRzazRxNWc3Ny8zM3VlZTU1NXo3cm5uZVltWkRCMk1LY0pLbHlZYnFPc1pWSWdHRU9nU0hRb3k0QUtiRkZqcUFvNWRXbi9yTkFoOU9wTzg1Mm9lSkhZeHRybUV1NFdBTGhNYnhHMlpFOXVGQWxJbURSTFkvdC95MGIzSWcrdStpV09Lc0FsZ0laU2IwT0lmMTVrV3RLbzFOWGgxZDV4eGlTUEVOMndVQUhyR09nMTFqaXJqV1Z0SnlGbmI2WWdyem9Zd29jQ2x1MERJNWd1UERiNDNZMkxMcC9JYXFmOUpDR1NFckd2SWlmeGQ3YXFRbi9UT0pDdkZ2WjhIZjloYUVIK20vNnNGUWdIQnYxU3RzLzE1V21KTGtleWw2RnVGd0ZQem55MS9aZEU3TmZnL3hodjF1VW1IMnc2a2dnUXAreXF6ZTdkNUpiWjhJbStLcHVjU3dJNkVONy9jWXRseFphckJDdHMzcHRmcnRxOW9kamFHS2loRStzVjB2UkMzdThScVdtbWJpajE0OVcrV2Q1cDJybkVUNmJzcXNudHliNitwTzNLcWtFOEZ2THhvNzRsTlVYOXM5dVRKYjgvOWZHMkw4MUtvb2dKRllmQ20zYjl1c05xME1YeHp3MVJzVWtEcVFJQ1BxZi9iL3E4c1FpM2o0V2RtdFY0N09GZ05BTzZyK0RFVUZBdEZBYzlZdHBYbVJQNmh4VnNJMjRjdmh5b3FuRnRySzZqTTdpc2dCYTNEbDBPOTRUZUdiMjU1TXZ6WHBVSUZqVnJoeG8vZHpnb0FSQnV3RlFKa0JLOXJlQ251cnhmdlhYOENSVzN5VzFHNzQ5dlQyQnI3eXNXMG9OWDFwS0RUUEcrcm0xZ0hSYmliQUhMbS83NTIyc0tuUUNacUZnQ1VhQkNxYVMvYkV3OXZxdFdvUVJPZjNkQkJpVDZLVEFDSW1aM1l1ZXFoRGRPV2pEYkZRNEl6SWw0ZWxOVVg1YmVnVTFIRDZsUFJtVUxLZWdoaERjcHFuVW1adUQzK25rZ1RINmdaRUU5Y3RsWlNvR21HOVVJeW5TQ3NRVm5kTXlYK0laR2lCb0hNakhoMlNyZUNnbENsYVNCaVNFRzhjWW5EMjRidjdDV21zLzNGb2NPM2hudzEzcGxUZ2dBRmIxOTZOZGxQTTQ0dEMwenJTZzVJdFhteUV6MDcwVUVLQ01ScVFna2tCUTlOdkwyZVNKK3Jldm9KVE9SU3BvVDZkbzQvNy83VVNoQkZIUWV4TStIZGZ5VUhXTzhpTi91YVJ6WDMvUWpVU0xsbnFNNzJGNGNDUklZNXU5WmYrWStCQXY0QXZ6cGtRN1dBSUJSdWpBLzdWZzZjaWE5eGxJZDZJbmFmVkVBQUduUU1VQ1NrYjZ6VE1QZEJ5OGhVM0pqcnBoSXErQ3JEK012eGV5dW1ycis0SUg5eTdvMkdGNWVEZ2h1dUd4NEwyemJXWjlEYzBSb1FSYmtrRk5SZFAyLzBCSDdFdExKTEtDanIrenFoMmw1dThoYVo4NDd2VEJXMjRrUkZRWEtBdGNzVDVvcXozaWdRRU5Jb0VDa2pCSlVEWlNHZXdCbEJqL2FtbWpMcmRYMWMvdDcwZXJvMzRnTXRlOUlCeUxMQWpQclV3S3dlVDVqYXdRc2hkSXVHTWlGNVhFQlUya29pdkJsOU5lRWZKZVlId3V4dEk4MXpQcm4yejZpcDYwYzZEa1YxakxUT0NUYUUySE5qZDVaNHM5TXdXQk9ocUVIcC9JOWNXRHRVckpOb0htNEtPOVA3aGRuVEJvTVlYSThHYjZnVkNnNjNGUzUzamc5TzV0QTU3dFNPZEh5d25DQXlnckpyZmNUZ1VlNVUyY3ZOSFNQdFlZb0tDV2xyVGdzSW5lQjJBZkZSKzRGNGI2ZjlaZFR6RjZQOFl0dWQ0MDcvZHkvbkw3azlYOWk4SjlsNXkrRWY2UmZibmpQdldhOE41c3VleitLRkNncXlQWTk1TG5kM3N0djJBY0JaMittRmJ6ZStsdWkxeGMzZFhDVVVsUGFmWE54NC9hS3hjYWpXV05wL01rbFJ3OC9tUEZudGJkK2gxb0xFODQ3S2hRUXhlalZnMzZRUXFEME1QVHpIdjQyVXgrdUdhc0pOQm5QZndsbEpkNzFra1g3UlEzV0ROZjdkb3gzQkxjTk5zNnZ0MzRiYmJ2WUhKaGxUR3A2TytKVkhiMC8ySEp0WDFQSCthcUVDcUcvNVlOMW5sWGNva0d2dk82dkNjNHgrUXNrb3R4VkhCL3FhK3hiT1d1enc4TkIzbnVvK0h0MHoyaEhzdUdVM0dyV0FvWmZpM2pyeGdIcHczQlBwb2JhQ0g3dmJxT3c2bUhJODM2dllXM0VxY3E5QXRpb3FiSnk3dWZRM2xoZnU4c1IrczkrM3ZMOGtsQUNzUVN1N0FueE1ZMU14SDdZWEpwN29QcEx1bHJyais5NTc1TmkyYWVWdDF0ZVdmRVdmSFFMQ2FzcHNlSHpPVTdWV1UrYU01RzJOb3lMNGkrNmo4WFdETlFzbUdzS3UvY3YrblR0alFiL21tN2hmRU55dnFFQUs1djhvcGpQSmFMMjZLR0JwZDVUZmd1dUJ2dVpSZ0JnWTZ6TzBqbHlaWFhlOUpxUis4TUs4bnRIT01IZkhJa2h1MmIvMHlJSDcvb1hKMHlGbHhZblBVZFJidnVJTGdPNyt5KzkxbDZLYTZNK2NuQ2Y0Zk1TeXBYdnltSGYvdnpCVEQzQ3VOR1VGS1Q4bG1LNVJzNUFTcUtpQmxBR0JYRmFpU3VuaTBma3AxcEo3RWQ0ZS94c0FxTGs0NkVXc0cxRUFBQUFBU1VWT1JLNUNZSUk9Jyk7XFxuICBib3R0b206IDEwcHg7XFxuICBsZWZ0OiA1NXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy1sZWZ0IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQnQ1SlJFRlVlTnFzbDJsVWxPY1Z4Ly8zUGk5RFpSc0dCZ1lpUzJSWUJRS0lqQWhFSlc0cE5yWE5NYlpwV3RUR05rdHRZbUpNRzVzb1NaY2tSayswcCtkWVBZWTBHazBpaGxoUmo2M0doVlVnQmhERDVvSU95OEFBTXd6RDRsQ1l0eCtHcUNRS3VOeVA3L1BjKzN1Mis3LzNKVXpFWkZCWUxoNjJTN3lJWkRtVkJFSUJxT3dzUTRETmR0QkZBU3EyQTRjdVpBd1ZnQ0NQRjVMR0hNMENoeitFMVhhbXpVeUF6Q01PN0loTUkrNU1EQ0srSHBDQU5kK1UycllnQy9ZN0JvZmxZZ1ZBMlJBT29OWXR5akRUZTQ1K2hrOTZlNVF5d2FKUitOc0F3RGhvY0s2MVZDakxUWVdhY2xOQjBPVytlbjhtaGwyMmc4Qy9ybjdVK3VHRXdkb3YrQzBpK1EwbUlGV3pvRDd6d1ZVMWN6US82cGpJcmVSM0hQWDVWTDlqYWxIWGlRZ21Cb0grWExIQXRINWNzRGFYdHhETEx6SUJ2NWp5Zk9tRzJIOVU0UzdzbmJwWDQzS2FQcGdCSWhEeDFyUHpPbGJmUEM1R1FUL25kMW1TMXpBQmE2UGZQZjV5NUYvcmNKZVdwcDdmUGtseTZmN0tYQlJDb09TQVRGZlhsbDE5eDc0SERzdkZDZ2hzSkFHOEhydmx2eXRDWG03RVBWcWM1d3l6cDVOWDE1bXVFMW9tS1hYeU1uZDl5eTVyNVEzd1BnaHZKenJMQWxpbVhWMzgrN0QxRGJoUEZxMU02TzRiNnJQVldLc0NCZkhpNUVXV3Y5VGtRQllBRVBwTHZFUk1DOU44RnRSdmp0OWRQbDZ3d281alB2dWFzN1dWNWpOcUVqejh3QStDQnNhYW4rdzl4MWhyclhKdHVhWlg5N29vTGZxUExDVUVHUlIraU93QXNGMlg5OFVjMzBXM2ZiMDJ1NDFmclZxZVZtbzZGVWtrd0NBd0NXeEoyTHMvMFRQRk5CYjhUTmRwOVd2blZ6NE9BS2RtWDJRT3pjTXNBQWp6aURHTUJkM2FzQ0Y2U1hIeWtuSlRmcVFUSyt6cHZoblZLVDV6YXdDZ3pGVGdOOTRwSlh2UDdneHhqVEFJa3BCK01uU1dSTVFaWUVEblBWdC9LNGVqYlovNzc3MjZMYjZoOTV0QUFpUEVMYUoxYmNUYlJmR2VNOHh2MWF6V1NleUVhMFA5aWdrK05yMStvTkZma3B3ekpDSktJUUE2NzludE4wOHlEWFlvM3FoK0x1VXJjMEU0RWNOTDRkUDdWTkR6cFU4RlAzdnBla29RUTVDRXc0YlBkRWZhOStzQWdFWlVta21BQUFTNWhMUTlwMTFYR08rcE04VjVKTFVmTWVRQVJETWxFTUtJR0ZPVkNaWWIwQzdGejBvZVhtSVo2blp6WW9WOW9kL2pWUytHYmFoVU9ubjliN1Q2c0VPdmlVR3lBOGJNRGxVYTBXNzl3QlcvYlpmK2xyWTk4Y0RCVUk4WUN4R0RnSENKaVZWRUROOFI3UVdBRThaLysxbUd1dDJpM2VQMXIwUytYUnp0a2RCenE2TmJGN1dwYkYzVXByS3hqdmZIeGJyZnR0bGEvUUJBclZEYkpKSUFRQ1VSTVJnOHVncktJQUtCU054ekh0TjNWZG14WTBpUVlTWm1UZWVnd1RsZ2tuWUFBQjdSWkJoMk5tN3VyYmVlQzFyMTlST1Q1MmtXbjNzaGZIMkZ1MUFPM1J4alkvMGZkYWM3L2hQUEpNREUxMUdDK0hwQkptSUV1QVMzT2E2dzAxbHliTWJNZ3ZnQ0U2TzI1NXp5MjREZUNyL0J2Y2tuOSt1OFpqWFlJWXZqeG9NSnk4b2VYWnJUOUdISXFNV1R3QTJvSTZjRk1lREljQWlTRU95aWJYc21aRzBoQUZ6dXExT3lZNnhCQW5NSmdkUE9ta3MwOHpVL2Jic0I5eDE4UDM3UHFTL2I4K28vYTk2WmNMbTNQbUJINDZaNXg0MEhXMWVGdmw0VXEwdzBNd2lDQk9iNy9xVHNkNkd2Vlk1MzdEWFdhczFJdzFBaU5Kbk9nd0ppK2JYaEFiRTA4T252YVhTSVcwVHZZdzg4ZWFGL3VNL1dOZGp1M201cjlUbGhQQnpWTk5Eb1BHQy81dFJtYS9HSjgweHFqUFBValZ1dlAybmFyck1PV2QxSmx2L0UxZk43ODJVaU5QWmY5Qy9xT0thK25kT3oyaitjejA0NnNuKzZLclZPc09EaXJwT3hsZDBsVXhtRUJLL2t0dkdnRmQybDZ0YUJabjlCQXRFejV4WUl2QW40LzhyRktrZ3N0QXlaNllmK1M2N2V6bGtpU1U3M1hYUlY2eHFoOTNUeXNzUjRKRjc1ZWZCdnltTGRFMDNqZ1QvV2I1dHV0TFdwR2JUbTd3SFp4UVFBVCt5RHVLTHlIUklrNGNuQVo0cGZDRjkvSHZmUjl1aDN4Qnh0ejAwQkFOc1ZEeWxuYWM2d0FJQ2FITWlCbVc1TlJMeTR0cmNxME10WjNSbnBIbWU1SDlBdmpZZUNjMXQzcHpNSmdPU1ZueXc0ZUhaVUI5S3l1NjhpTUZQcHlzU3BwYWI4VUpWQzNSbnAvcERsWHFGN21uWXNkS1FidjdjcjZmREdXL1pjemJ0NmpnVXRWNmtJbEZ4dXlnL3RIKzZ6SlhtbEdlOEcrbWx6ZHN5QjFqM3BUQXdaOXEzL1NzcGJjOXRtRHdEMEgzVWZmWENGbHl1VGxGcG5QUmRZYjYxMmM1YzgraWRQQ3U2ZkNMREtVdWJ6c2Y2ZlNhV20wd21POWhidlpVOGZEUjJ6b1o5N091cHBBdTBVSkVERW1PSVNab2hUNnE3R2VrNXJEM0dONkZFcDFEYUFZQjdzZE5ZUFhQYW83YW5TMUZtcmc0MDJnNytqWWhHSWFPWE9hUWMrdU9OZm1Dd1pYSklmOHhLeDJLUmd4WWdPUytDUk91eW95UUtDeEloa09yNFQ2SldneEdudloxSFduZi9DZkhjQlh4Y25wUkh4WXdSS2tValNFckZLa0FRaU5qUDRrbUJSVEhiS201S2tLeHdMK0szOWZ3RFgxWEdGOGN0KytRQUFBQUJKUlU1RXJrSmdnZz09Jyk7XFxuICBib3R0b206IDEwcHg7XFxuICBsZWZ0OiAxNXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy1yaWdodCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJzMUpSRUZVZU5xc2wzdFFsT2NWeHA5ejNtK1h5Z0s3QzRzTHhrVzVvNENBa1lzc0ZTa1JqYWJqSkVPU0ptMUliWngya3JhcGlaZGVwclcwTlZWSjBwcU1NMGtZSlFscWtvWkltR2lvRTFJdGlDQWdJc0Z3RTRFczk5dkNzbHdDaGYzNnh5NUVXMUEwUG45KzczZk83NzJlOTNrSkM1RU1Dc3pGZDIwU2J5RlpOcEpBQUFDdGpXVUk4S0FOMUNSQUpUYmc5TFhOVStkQmtHK1hrbTdabWc0T1dvVWROcVpYbVFDWkhRRnN6MHlPY0NZR0VjOG1KR0RubDJVVGg1QU8yeDJEQTNPeERhQXNDRHZRMzJWRjExcVA5YVpZejZTZUZlb29pMTdwUFFFQXZaTmRUbldXS25XRnVWaGZZVDd2MHp6YTRNM0VzTWsyRVBnbk5adXNieThZN1A4eC81bEkvZ01UWU5Tbk5LUXQvMFh0ZXYxRGZRdFpsYUsrTTU0Zm1ESlhYaGc0Rzh6RUlOQmZxbExNZTI4TDlzL2xROFR5cjVpQUozMmZLL3RqK09GcTNJVU8xTytKeUdrN0dnc2lFUEZybFEvMDdiaXhYZHdFUGNrSFdaSjNNZ0c3UXc5Ky9tTElTL1c0U3lYb052UXNrcHlITGcxZThDTlEzTkkwbGFvamU3VGcvOENCdWRnR2dRd1N3Ty9ERDMyMnplL0ZGbnhMUldoaUJ6VUs5NEdMQTJmOW1TVGpmVSs3bWpxeXJWZStBWDhJNGFHZ1NoYkEwLzQ3U240WnVMY1I5MGloNnFpaDBhblJpVnBydFVFUWI0M2JZdGxYbXdOWkFFREFqL0FDTVcxTThFeHBlRFh5V01WQ0VsNHlGN3ZudFIvekxlb3Y4SkpsV2ZaUitZM045MitjeC9yZU9tdTFxdU5yazI3RVdXMHh2V3NwSmNpZ29OTmtBNEMzWWs1OXZIN3hsdHZ1M2t0RHhlN1BYMzRpbFFDUWZlY2kxajJ4Zm45NFpyR0NuZVk4dXhjSENuVy92YnI5RVFENGQySVRjOEFwckFPQVFMZXdyb1ZBQWFCOG9NaUxpUkh2bVZ5N3puTlRqV0NGclhLb0pPU0hGUStrdm5GOWYramNvMDdzOTFNRmR3bVNrSFF1WUIwVDhXWXdJY1lqMGJUUWRSdWZHbEZLSk1GVmFDYi9HdlpXNmFHSTR5ZVhPd2QybXIvdTA1enN5RFkrVzVYNjRObStmTzg1TnB1SmlDRkpUcHNsSW9vbkFERWVpVDJ6SXpJWHVoK28yNVBRTnRic05WTU9CVW4yZzA4TWlTVEhOM3Vaak5URURyNGRuWC82SCsxSC9YUGFzbUt2VytzTUdmVy9NWHplbmRlNEszaC9pYnZTWXhJQUl0eWllL0s3Y2dDaXRReENJQkZqcFRyS01nTStXUGZyaExieEZpOWlNUXRsWWpBSlNDU0JTWUJBSVBCTkkzcDg2VFBYajhiazU2UjRQVnlsRkU2MjZ1RkxRYzllZmlUVlBEbWdCSUFBdHpBTEVZTkJRUklUYTRrWWl4MjFGd0JheDY1NUNWYWdQTGs3ODA2UGoxcW8vN01yYUYvRlExNC9hTWhzellodkdxbjNLVGVmODlya2xXclNLWFVUa24zbXRKSzlCemYzWEpBMGUvUGNyZGd4SXdTQ0RQbWJaTVFnQUJKa0RCS3p2bit5eTJucEl2OXhBUEIxQ2VvMmpUWjdHYzhhZmlwSWdFaEFrQUNEd2NTUVFaQklJR254NWl0N2dnK1Uzd2djbmJaS1IxcitGblcrdjJEVnREd3RYQ1hOU0t6Nzk3b0F3RHpaN3lTUkFJQkJGc1RYbUJoMXcxK29aNEozaCt3djlsVUZkYk1ET3JPKzVJQXFXSUdadGh1VjEzbkM3N25LUng4cjdQc3N5aWJMSWtvVDEvaDY1SHNmeld5dTV0RjZOWU5CNEVZSnpLVUVUcWdjTE5WdjBEL2NEUUJyTkFubTkrTE9mVExmTkI1dTJoZjV6KzZUTWV4WWppK3RWZHJNNWxlTWJXT3RTd1F4L0YxQzJyY3VlYklxd1NPNTY4YTRXbXVOM21FWVNpVWkrcFJsMmwxcEx2WUJzS0FyVUtWd25aUllnZEhwTVdWRzQrL1dYaHdvREJYRTdPbWtIeko2Sk5lbUxmdjUxYm5pR3F6VlBvSWt5TGJwZks3Wk1GSWtFNkZsck1uN1FsK0JiaUhnK3pYR2JnTGp5bERweW9zRDU4S1ptS00wY2ZXSEk5Ly9hRDVvMVZDWnJuTzgzVnVRUU9qYTVQTUNmd0s4bjNLMkNoSWJMVk9EOUtCMzZsZTNBK3UvczJRODFDMnlSYXZRbVFOZFZuYW1Mbm1xNG5IRDlqcEIwcndtNzdqcGpUVzlFOTA2QnUxOGZXbFdDUUhBb3g5Q3RHb1hUd21TOElUaFp5WFBCKzI5aW51b0U2Yk1zRE05dWZFQU1OSHFKdVU4bGpNdEFLQTJCN0loemFXTmlMZldqVlFiM0oxMC9TR3VFWlo3QWYxWDcrbGx1WjNIa3BnRVFQTDI5MU0rcWJ6SmdYUWNHNjB5cEtsVlRHd3NNeGNGYUpXNi9oRFhWWlp2Q3ozUmxybVJpUUh3eTluUm4yYk02Ym5hczRjTGZINnMxUklvcnNKY0ZEQTJQVG9SN1o3UWV6ZlFEOXF6d3ZJNlR5VFpDNDd0dFhlaVQrMmMxK3dCZ09uZG9UUEx0N21ybUNSanZmVUxRNE8xeHNWVmNodTdiOUd5c1lVQXF5M2xuc2ROYjBhWG1RdWo3UFlXTDJldHVSbDZTME9mWExqaUdRSWRFWTZLNWVzYzJCV2hqdmtxWExPNngwOFZQS3hWNmlZQXd1Qmt2NU5wdk5tdGJyaGFYMit0V2RZNzBlVk5JTmh0TFcwL3NqcnY2QjAvWWRKbGNHbFIyQXZFNGhVbEt3SFE3QlU1Y3o4TFJ4MEhhUFk3Z1hiNTNMLzY3K21VZnVkUG1QL3R3T1dTNkFRaS9qNkI0aVdTL0lsWUsreUdZSkRCMXdXTEVyTFJLZC9vbU9KYkFXZjAzd0VBeU85bSsvVHRTM0FBQUFBQVNVVk9SSzVDWUlJPScpO1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgbGVmdDogOTVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtem9vbUluIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQmlCSlJFRlVlTnFrVjJ0UWxPY1ZmcDd6dmd2RFJlNjZ5OGh0WFVCUjFHb0ZJK0J0Rkp2UnRqUEpCR2VhSDJhOERHbWJ0dGdTVFdiU0pFdzZUV09zcmJicFRJZUpaR3FhVGlwVGE2TEpaRFRWVVRZUWROQW9ob3NvNnFMdWNuRVJOMEF4Y2IvOCtIYUpVSERYOVB6NnZublBlNTd2WEo1enprZUVJd2FZY3dCTC9WclcwVENLcVpBTklORXZCaFNrM3c5ZVVtQzlIempjc2Zhck9oQkdLSk44NEdrVkpIY2V0dnFGdTRTQUlZRUxZbHBtNExwUVFNcW9RUUtWbnplTzdFWVYvQThObkhNQUd3SFdRSm1BanRnODk1TGtGYTdGVTFkMjU4VXZHTEJHcEk0QVFNOWRkMlRyd05uNDAxNm45YlMzTHFOenNEMVZLUEFiZmhDeXFmbFIzMXRoQXp2K0xhK1F4b3RDb05pNnBuMUQxczlhVmxpLzN4dE9WazcyZmpUMVhWZjE3RTl1SFpzcEZCRDh6ZGsxM3BkQ0Fqc095RzZLVVNFRW5yVC90UEhsdVcrY3c3ZVExOXEyejYvdDJyc1lKRWpaMDdTNmQrdWt3STUveVE3UnhuWUMyRFpueDhkYkhOczZ4eHM4NVQyUjlHcHJaY21Wd1lzMkJZV3NtQnpQODNtN25JVkpTNzNqZGZkZCs3UGpqVXUvWFdVQ0dUdFByZTdaSGp4VFkzS3E4RG9WOE91NXU0OXNuUEdyS3hONThzeVo5YVZYQnp0c2lnb1VCZCtYdDJOYmZaOGxsYVZ2YWgrdk96OWhjWCtDSmVuV3A3ZU9PWVM2ZVBwVFUxdzM5dmsrQXdDekZQZERRYkZHRlBDVVkydjlocXhmWEowc2hOZUhMdHNVRmM2VWVxdWJWdmRWa3dMWDBHWGJaUHBsNlp1dS9pajl4L1ZDQlUxZFU3YmZkRllBSURzU0ZSQ2dlT3FhOWhmeS9uRGh3ZndUS09yUmQwVTk1bjBpcWNoOStjS1M1SlZ0cE1DZGtsbGhBaHVnQ0hjUndBYjd6MXRDRXA4Q0NYQVdBSlJvQ0ZYSVludGkrc1lXVFEwdGxsMHdRTWsraEdVQWtCT1g3MTR4YlYxSXl1aHhIaElNQy9pUjVPVjlNMkptdWhVMVZoN1BYaWFrcklVUWhjbkxYZUhReFBUNEd5QXRGcWd3Z0FQRjVpSUZXa2V1MVNTTENLQXdlWG4zL1pSNXJYVjdTZGRRcHkzWURvTmVtczlxVEk1aEdDaXRtMU1PQUF4MGFhRkNlclRkODR6akJlZDNFZ3E5QURBL3JxRDdRM2N0UUM0UkVEbWtZSGI4Z29HZ3NSMnR6NVYwRFYreFVkUW9xQVE4MVJ5YlU0SWdGV2dBQ2dwYUxMQ0lCVW8wYnY2M3kvYVh5NitXQkhXejQvSUhTSUdBdVZvb2lhUmdXcUQzQXNEVm9RNmJFZ3RPcmZKVWh3cmYwV1V0aytyOHNMNnd2SHZrNWlqVlVpSlNSclFadVVSdGZvR011YUNvUnlmUC95TXkwWHlrZ0FBMERQUlR4TnAzMXgyWkZ1VVlCZ0I3Yks3SE5kaHBLejZXWHE2b1FDb29LZ2hNS2hrZ2ppNzd2Qm9BMWprWGxBdlZmUlFqRk1VY214U2tSV2Q2Z3BqZXUzMlIya3hUdnloS2gxRFFldWQ4ZkZCaDI2emZPZTB4dVI0SmdBYnp5d0NvUlN6ZmVEVUthdEpLVVFLK0NqS2lIWjZuWjJ4ekJuVTdCOXZpeFR5N3FDSFNRRWhKVTMrRHRkVDZtQWNBRmlXVWVQL3h5UEgzSndyZm8zWHp5c2VtUmNFQThGNVJZOGg2YVBFMVd3TUxRNE9RL0VCQU5IbWRHV0hselp5eGszYXlCMG03NzF5R29vWXkrS0UwbDM1eDBpQnhaZWhTNmllOVIxUENNYUR2Q3pXRFhBNGhaMjgzcHR3Y3ZwNnFxREJueWFvNkFXRVFyQlFRLzd5K2QzWW9BK05CVEFhRWxvOTczcDh0VkZDUXlpcFcrYzNwZE51N0J3Qk9lK3RtL2VuaUsva1BGV293cE1mdnVLcnp6dzgwelNLSWtXc0plMGJIWXUxNjNCTndNd0RzdjdHMzZPRE50ek1uTTVJV1pmZVFnc2NiaXN2TFBsMWFEaExUbzdJOGsrbi9wK2R3NXBHZWcwV0tHaVMzMUs2dnZUZG1BN254OXVEWjlBM3hNVUlwYnZTZXpFNk1TT21iTldYZXdIaEQ2ZEgyM283QmxxUXZ2cndUSzZLUUZwWGwyV3l2Y0U2TFRCMmVDUFNkcnVydm1jVW5PL2NWZlBENnBNdGV5ZkdzM1FLcFVGUW9TOXRVL3hQSDh4ZStUZGQ2OTNwTi9wSHVnMFhtcW50dnoxdUxEbzlaOXY1bm5ybitkdnVqckkxSk1VSmQzT1k3bjk3dWE0NmRvdU9HcGtkbERvVURlRzdnMU5TL3UvNWEwT2c5c2NDc0IreXNXWFNvTXV5RmZ0V0p2TTBFMzFTQmptV1B6bkhQankrOE5qZGhZZmVNbUpsM0VpTlNSZ0NpLzI1ZnBHdTRNNjcxempscm02ODVzMmZFblVvUTVsckxMVzh1UExqM29YOWhxZ3hJdzhuOFgxTFU3eU1rSXRDSHpSRVpyR1FWNk9ObXk1VGdnSGsyNDdzTC8xakZxb2YvaFJuL0FXZnFDMHBJK1FIQklrM3RJQ1hSckZUcEY4aGxKYXFlZmg2eUZ4UTZId1FZbEs4SEFLeXQzV3NXeGw3ZkFBQUFBRWxGVGtTdVFtQ0MnKTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIHJpZ2h0OiAxNXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy16b29tT3V0IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQlY1SlJFRlVlTnEwbDJ0UVZWVVlodC8zVy92QUNNcjE2SUZSUURpQWdDaHBnaWlrTXFZMVdqbk45S3NmR09YWVRPVmdrdmJEVXNadVhySzBxWm1HVVN2TnNwakk4VFpPbW82QUdCb1pZbHk4WUI2UXc4MERCd1E2akozZGozME9aWm1pd3Z0djc3WFc5Nnk5MWw3djl5MWlNTkxCdUNJODR0WmtJWFU5Z3dxeEFJTGRva05CT3R6Z0pRV1d1WUVERnhmY0xBR2gzeTBrNzlpYUQ0bWZqT1Z1NFdZaG9JdG5nQmlSNlJrdUZKQXlFSkJBM20vbHJpM0loL3Vld1hGRnlBRzRBOG9BV2tjbTJtZUV6ckZOSDUzVmtoZzR4V254Q1hjQlFHdS8zYmZHZVRid2pLUFVjc1pSRWxuZlV4Y3VGTGgxTndoNXZ1cng3czhHRGJaK0wrdEkvVTBoa0dHWlg1YzkvcFhxT1pZbjJnYXpLOFZ0aDBmdnNSVWtuYngrYklKUVFQQ3RzL01kYSs0S3RoYkpGb3FlS3dTZWpYNnBmTzJranl0eEgxcGZ1eXFsc0dIN2RKQWdaV3ZGbzIzTC85bXVib0YrSnh0RTAvT0V3TXFKRzQ2dVNIaW5GdmVwVFBPOGxoR2FYK2ZQSFNkakNLYVB5L2IzdjdhejU4aC93SEZGeUlIQ1JpcmdqVWxiZnNpSldYRUZENmlVb09rZFFhYVE2ejlkUDJZVmFobGpGNCt5WGR2Wi9ldmY0RytoUWsyc0VBVXN0aTR2V3hhMzVnS0dTQk1EcDNUMjNPeHhWWGRYUmlqS292U0Z6cmVyQzZFTEFNVDZJaGNDWkl5ZVg3YzY4WVB6R0dMbHhxODlQeU0wcTVZVTJNMVJ1UUFnMEVFUmJpYUE3T2hsMVJnbVBUTTJwMXFqQmsxTW02R0RFcnNmc3dBZ0xpRFpQbWZNd3JiaEFxZUh6bTZQOFo5Z1Y5U1FkVHgybHBDeUFFS2toYzYyWVppVkVqVGRSZ28welhlQlJuSW1BYVNGem03eGRqanRPQkd5dm1aVlprTnZmWmpYRGhVMTQrQlRvRkVES1JBUXBBSjBIUlRqUDZYSHBZVUtFWDdSelM5YlY1YytGSlRtQUlDVWdOU1dRL1pDZ0p3aElPSklRVkxnRktjWHZLSG05Y3lHdml0aEZEVUFGUXFFQ2hvMUNCVUlnZ1lhcEFKMVFFRkJFeE5NWW9JU0RVMS9OSVI5Y3ZuZFRHL2MySUJrcDJmQzhacFFna25CR0kvM0FzRHZ2UmZEbEpod2VtNXp3WU1zN1ZObGFVdGJYRTFoM21lemo5bWxHU3NYckJremtGc0dLR29EbWVkQkpMZkxqeFFRZ0FZZEhSU3h0UGZiZmNlTnNQWUJRUFRJK0daYlQzMVl4ckdJcFlvS3BJS2lna0FnRk9nZ05CcmJRQkJDQmFFTTJMK2lHR21UZ25GK1VjMWVwcU8vM1ZlakFvQU9VWlNMUWtGTjE3bEFiNGVWQ2UrVlJ2dkhONHNINnQxZmVxQW1NVUdvUEh2dmhkTHpUanpmS29qMHN6YS9HTE95MUJ1M3ZxYzIwUGdsNVlJR2tWT0VaRlowbkxMTXN6emREQURUZ2pJZFg2VWYzemZVeDZtNnU4cmlLUmhPQ2NtREFxTENVUm81M09lNHJyc3lVbEdEMG5sSXF1YmRLTlpKWE9tOUZINnk3WWg1dUtCbk84dk5UWDJONFlvS0UyZk1MUkVRT3NFOEFmRk40L2FrNFFJZmJkMlhKRlJRa0x4ODVydU43TlRwMkFvQVp4d2xDUjlkV0pjODFORGR0b0xrYzg2S0JJSndYUTNhT3BDUHF3dWhSMlNQYkNCbFVjMk55b2dRWDNON3dxZ1U1MUJBZjJ3OUVGWFV0Q3RMcUFEcVM3NmV2Ni9pbGdyazJxNmVzeEhaZ2Y1Q3lTaDNGTWNHKzVqYkUwWk5kajRvZEhkRHdXUEdjWk5OTzFNUGJyeHR6ZFc0cyt0STVIUEJ3UVRUenppS1kzdi83SEdsaG1TMjNnOTBUK09PNUwxTnU3TU13M0Z2L1R4MWY5Ny9GbnNBWVB1aTgvRDRuQkIvb1paUjIzMHVvcTY3YXVRb0xhQjM3SWlvM3NFQUs1Mm5SMzlwK3pTMTNIRmlpbEhlWXRPT2FiZEM3MWpRenoyUitBTEJiY3JqV05GK2NmYVV3TFNyazRLbXRzVDRUK2dLOWpHN0FLS2p2OTNYMWxjZlVOTlZhYW50cm9wcWRkbkRDY0lvYTdsazI5UzkyKy81Q3BPdlEwNFZKNzlLVWUvN2lJL0hoNDBVNmMzUHl1UGpobVdLTjhHOEZ2bncxQS96bVgvdlY1aC9UK0NYc3RSTVVwNGtPRk9qWmlVbFdCa0ZRWWRBTGl0UlpYUnpmM1JxV3VtZGdGNzlOUURCT2EyVi9pWVNIQUFBQUFCSlJVNUVya0pnZ2c9PScpO1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgcmlnaHQ6IDU1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLXpvb21FeHRlbmRzIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQnB0SlJFRlVlTnFzbDIxUWxOY1Z4Ly8vY3g5aElpcHVBSkhhc2dIbFJkdzB4YXk3eUs3c21nNnNiMkRTZHRxWmR1TFVORU5tT2sxdFF1TTRVN1V6VHZzaFNSbEZaem9OQ1dTU1NUSnArNlZOa0xDQWVRSEJvQ0NncU5CRTB3VXFMK0t1d0lpaVpaOStlSGEzYUFTM1NmOHpPOC9MM250Kzk1eDd6N24zWVdscEtVUUVKQUVnY2g5K0pvbGE5eEVDMkFEQlZnQU9LcXdDWUFxS0RnVUpCSUhQQld3RldRTmRieVpGQndBQzBHR0lBSFFTajMvOEhIUmRoelliZERmd2c0SWpBc0d2SUNnWEFyb1lCaUNFRGtCQkFDQlpveVNUNGdEd1FxaDdtUTRjRWtoUUQwRUJJSWdnUk1RQWgyRWlFdkVZQUdyZFIzWVNxSVlDSUVEYW90VkRlWW51L3J5RWpTT3I0M1BIbDhXbVRCUEE2UFJRN0lXSnJ2aFQvdWJrVS83bTFFdlgrMUtFVWg3VWcrV2tQRVhnZFVTa1IreHJkME5KNHFqcjhBRUk5cEdBSTdtbzc4bUhmbkYrWS9LMks3aUhVaGV1dkpHNmNPVU56L0x2RHdQb2JycFNsL1J1ZjJWT3k5VVBzNFJTVFNBTndINFk0NDlFVmRudDlvakhJZWdoQ0hZTGdSK24vN3p0NE5wMzJ0SVdaVTRoU3BualZrMXQvY2FQZk9PMy9mKytNTkg1VFZKY2lzb0VvbzRrc2dic1h3WWZkUjEra1FwbFF1Q0ZOUzgyUHAvOSsxNThSVGtUQzBjZTBPS3V0UWVPcDVQTUUwcWNVQnF5Qm13R09DOHZ6NEFXVk95RTRDVXFZTy9EaCtwM3BqLy9CYjZtSGxscUN5eGQ4T0RWVDY5K3VGS29PWVRTbnpGZzdTSnB6SEZOUVlXaVFyVUlzQ045Vit1T2gzNzV6ejE3OXBTR0kxRlNVdUsxMisyK2FHRHQ3ZTNtdXJvNlQvaDU3OTY5bFpkdkRyVCtaYkE2bjBCMW5mUFZON2UwUGpNaklnSUlka0VBUjFKUjMyOXlEdmFFMCtsL2hRS0ExV3IxYmQ2ODJTc2lrVVc3SytPM1Blc1ROdmFTQWlYYUxoR0J2Tzg2UkZFb0o0QWRhYytlRHhzZ2laS1NFbTlOVFkzbjVNbVQ1bWpCSFIwZDV2cjZlcyttVFp1OFNxbkkreCtzK09sNWpSbzBhdVgxanRlcFFhRUFBREtXV0liY3k3WkdVbWI3OXUxZXU5M3VJK210cmEzMUhMajVUR0RzOXJCSklDQ05uMUdSQ0tHQ1VKQVV1enp3NkNmYlRCNlB4N3QyN1ZvZkFHL1lYbDZDZXl3OUxtdklOM1V4WlVhZktSQUNXeUNFTGNIVlAzdms0ZkRhYkRaZisyTi9EOWcrZnNMRUVGU29vRkdEb2daTkZrQlJnU0NzVGNXbTA2NmpnUkFVNGV0L0Y1dTlueFJvc21DTFJtRStRZGdTWENOemhXL3M5ckRKNjN3Vkp4NzdWK1Y4WVM2VU5hVzhCZE9jcXp4KzNVanQwRjhCY3IxR01JTVU1Q3pKSForcmc2SUdDWVYyUGltb3lJSzZseklXcnhrUFRWR21Sb3FKRkN5TFRabWVxNE1CNWYzQlZBRG5icGNRa3pTdFVRTUFrMFlLQlBmenhsaEE5NU5RUWU0M1FCb3RCRUNBRkZ5WkhvNmR6NkNLQ2l6QVBGUGl2elVXcXhtMkFxSWdud2tGdlpObjR1Y3pHSzNIYWg3d3BldDk4VVo4NVI4YUtTY0ljWFlFV3BNTGt4OGZ2bGVIcE5qbEFXdFRzYWtRYTBwVktHY0pRcU1HVXFDSEJ2ZmRqcC9nVFA2eHdGemc4NVBkeWFIMko0U1Vvd0tpdzM4ODllNEtCQUNuVDU4Mlc1dUtUVjJ1dXNBZFVGbGd6QmNGUW9GR0RUMzVId1crODJtaHFhZW54d3dBNFd0WWZSTm5Va01aVXFzSnBFa244Y1hVNXlrdFl3Mkpqc1RDTVFEd2VyMGVrdDZHaGdaUFVWR1JkM2Z1N3FqcWRVOU1qN21scGNWRDB0dlMwdUt4V0N5VkFOQjVyUzN4OHMzQkZFVUZnVFRMdHVabmRRSExCTVNmQjZweVp0ZnFNRFEzTnpmcVRjSmlzZmljVHFjM0JJKzhieGg5TDhjb3Jhck0zZm5Eb0lUK3JBQ0FVLzdtN01PZkhiQ0V3UURRMk5qbzZlcnFpbnFUT0hmdVhOamppSTIzK3lzdFo4YzdzbW1rV2dWSmNOKytmUkFSZkxEaGxhY0VVcVZFUTFubTc3eFBySGpTaC8rRGpvM1dtTi9zLzZPSEVPZ0lQcjJoNjN0VnVxNUR1ZDF1a0VUV29LM3pvcmt6VGlpT05uL1RLbE5NNGxqMjRtK1BmMTNvMndPVkhxR0E1TXNBWGpLUHJEYXFuTXZsUW5qVHpoeTBObHcwZDVvSTVwM3lONjJhbXJrK3ZlNUI1K2hYZ2I0N1dHWDUyK1YzTmdvRk92UUtBR1Vra1RxY2JaeTVYQzdYSFlmNHpFRnIzYVhVN2ppaDV1aWRQUE90dnNteml4WnI4Vk1ySGpCSGRkTHNIaitaOUZiL245YTErVC9KRGFYZXkwSXBFekVLa0huVThKajc5KytQZUV3U1NpbVFSR1ArR3o4ajVEVkZCVktRdGpCajZKR2xOdC9EOFkrT3BNZGxUcGhpRXFjQjR0cXRzVmpmalV0TExreDBKL2RPbmpXUFRnK2xFQVJJRUh3YVFKVlFJWWdnQUNDL3F4aTZybjhaSEw0WEVUU3NmME1VMUhPay9DRkdZZ0F3c2tVcVk1ZUJpdFJ4em43L2EwVjFFRUJ3ZHFrTjZqUEk3eTR4UG1IbUM1dW5iV2RRUk1xUDJkODZxQU5Pa3NVNmd2bUFyTlFSTkNscUFCblFnWXVLMGtySSt3Q09BeUgzREsvdnFPWGhhZjNQQU83bUlSakROVjI1QUFBQUFFbEZUa1N1UW1DQycpO1xcbiAgYm90dG9tOiA1MHB4O1xcbiAgcmlnaHQ6IDE1cHg7XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokMSk7XG5cbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEFsZXggb24gMTEvNi8yMDE0LlxyXG4gKi9cbmZ1bmN0aW9uIGtleWNoYXJtKG9wdGlvbnMpIHtcbiAgdmFyIHByZXZlbnREZWZhdWx0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByZXZlbnREZWZhdWx0IHx8IGZhbHNlO1xuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCB3aW5kb3c7XG4gIHZhciBfZXhwb3J0RnVuY3Rpb25zID0ge307XG4gIHZhciBfYm91bmQgPSB7XG4gICAga2V5ZG93bjoge30sXG4gICAga2V5dXA6IHt9XG4gIH07XG4gIHZhciBfa2V5cyA9IHt9O1xuICB2YXIgaTsgLy8gYSAtIHpcblxuICBmb3IgKGkgPSA5NzsgaSA8PSAxMjI7IGkrKykge1xuICAgIF9rZXlzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0ge1xuICAgICAgY29kZTogNjUgKyAoaSAtIDk3KSxcbiAgICAgIHNoaWZ0OiBmYWxzZVxuICAgIH07XG4gIH0gLy8gQSAtIFpcblxuXG4gIGZvciAoaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgICBfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtcbiAgICAgIGNvZGU6IGksXG4gICAgICBzaGlmdDogdHJ1ZVxuICAgIH07XG4gIH0gLy8gMCAtIDlcblxuXG4gIGZvciAoaSA9IDA7IGkgPD0gOTsgaSsrKSB7XG4gICAgX2tleXNbJycgKyBpXSA9IHtcbiAgICAgIGNvZGU6IDQ4ICsgaSxcbiAgICAgIHNoaWZ0OiBmYWxzZVxuICAgIH07XG4gIH0gLy8gRjEgLSBGMTJcblxuXG4gIGZvciAoaSA9IDE7IGkgPD0gMTI7IGkrKykge1xuICAgIF9rZXlzWydGJyArIGldID0ge1xuICAgICAgY29kZTogMTExICsgaSxcbiAgICAgIHNoaWZ0OiBmYWxzZVxuICAgIH07XG4gIH0gLy8gbnVtMCAtIG51bTlcblxuXG4gIGZvciAoaSA9IDA7IGkgPD0gOTsgaSsrKSB7XG4gICAgX2tleXNbJ251bScgKyBpXSA9IHtcbiAgICAgIGNvZGU6IDk2ICsgaSxcbiAgICAgIHNoaWZ0OiBmYWxzZVxuICAgIH07XG4gIH0gLy8gbnVtcGFkIG1pc2NcblxuXG4gIF9rZXlzWydudW0qJ10gPSB7XG4gICAgY29kZTogMTA2LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snbnVtKyddID0ge1xuICAgIGNvZGU6IDEwNyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ251bS0nXSA9IHtcbiAgICBjb2RlOiAxMDksXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydudW0vJ10gPSB7XG4gICAgY29kZTogMTExLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snbnVtLiddID0ge1xuICAgIGNvZGU6IDExMCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTsgLy8gYXJyb3dzXG5cbiAgX2tleXNbJ2xlZnQnXSA9IHtcbiAgICBjb2RlOiAzNyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3VwJ10gPSB7XG4gICAgY29kZTogMzgsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydyaWdodCddID0ge1xuICAgIGNvZGU6IDM5LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snZG93biddID0ge1xuICAgIGNvZGU6IDQwLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9OyAvLyBleHRyYSBrZXlzXG5cbiAgX2tleXNbJ3NwYWNlJ10gPSB7XG4gICAgY29kZTogMzIsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydlbnRlciddID0ge1xuICAgIGNvZGU6IDEzLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snc2hpZnQnXSA9IHtcbiAgICBjb2RlOiAxNixcbiAgICBzaGlmdDogdW5kZWZpbmVkXG4gIH07XG4gIF9rZXlzWydlc2MnXSA9IHtcbiAgICBjb2RlOiAyNyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2JhY2tzcGFjZSddID0ge1xuICAgIGNvZGU6IDgsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWyd0YWInXSA9IHtcbiAgICBjb2RlOiA5LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snY3RybCddID0ge1xuICAgIGNvZGU6IDE3LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snYWx0J10gPSB7XG4gICAgY29kZTogMTgsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydkZWxldGUnXSA9IHtcbiAgICBjb2RlOiA0NixcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3BhZ2V1cCddID0ge1xuICAgIGNvZGU6IDMzLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sncGFnZWRvd24nXSA9IHtcbiAgICBjb2RlOiAzNCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTsgLy8gc3ltYm9sc1xuXG4gIF9rZXlzWyc9J10gPSB7XG4gICAgY29kZTogMTg3LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snLSddID0ge1xuICAgIGNvZGU6IDE4OSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ10nXSA9IHtcbiAgICBjb2RlOiAyMjEsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydbJ10gPSB7XG4gICAgY29kZTogMjE5LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuXG4gIHZhciBkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQsICdrZXlkb3duJyk7XG4gIH07XG5cbiAgdmFyIHVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQsICdrZXl1cCcpO1xuICB9OyAvLyBoYW5kbGUgdGhlIGFjdHVhbHkgYm91bmQga2V5IHdpdGggdGhlIGV2ZW50XG5cblxuICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHR5cGUpIHtcbiAgICBpZiAoX2JvdW5kW3R5cGVdW2V2ZW50LmtleUNvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYm91bmRbaV0uc2hpZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSB0cnVlICYmIGV2ZW50LnNoaWZ0S2V5ID09IHRydWUpIHtcbiAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkgPT0gZmFsc2UpIHtcbiAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZlbnREZWZhdWx0ID09IHRydWUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIGJpbmQgYSBrZXkgdG8gYSBjYWxsYmFja1xuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgIH1cblxuICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xuICAgIH1cblxuICAgIGlmIChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xuICAgIH1cblxuICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdLnB1c2goe1xuICAgICAgZm46IGNhbGxiYWNrLFxuICAgICAgc2hpZnQ6IF9rZXlzW2tleV0uc2hpZnRcbiAgICB9KTtcbiAgfTsgLy8gYmluZCBhbGwga2V5cyB0byBhIGNhbGwgYmFjayAoZGVtbyBwdXJwb3NlcylcblxuXG4gIF9leHBvcnRGdW5jdGlvbnMuYmluZEFsbCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHR5cGUgPSAna2V5ZG93bic7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIF9rZXlzKSB7XG4gICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQoa2V5LCBjYWxsYmFjaywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBnZXQgdGhlIGtleSBsYWJlbCBmcm9tIGFuIGV2ZW50XG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLmdldEtleSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xuICAgICAgaWYgKF9rZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IHRydWUgJiYgX2tleXNba2V5XS5zaGlmdCA9PSB0cnVlICYmIGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSA9PSBmYWxzZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSAmJiBrZXkgPT0gJ3NoaWZ0Jykge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJ1bmtub3duIGtleSwgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcbiAgfTsgLy8gdW5iaW5kIGVpdGhlciBhIHNwZWNpZmljIGNhbGxiYWNrIGZyb20gYSBrZXkgb3IgYWxsIG9mIHRoZW0gKGJ5IGxlYXZpbmcgY2FsbGJhY2sgdW5kZWZpbmVkKVxuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy51bmJpbmQgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHR5cGUgPSAna2V5ZG93bic7XG4gICAgfVxuXG4gICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIiArIGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBuZXdCaW5kaW5ncyA9IFtdO1xuICAgICAgdmFyIGJvdW5kID0gX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV07XG5cbiAgICAgIGlmIChib3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIShib3VuZFtpXS5mbiA9PSBjYWxsYmFjayAmJiBib3VuZFtpXS5zaGlmdCA9PSBfa2V5c1trZXldLnNoaWZ0KSkge1xuICAgICAgICAgICAgbmV3QmluZGluZ3MucHVzaChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gbmV3QmluZGluZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XG4gICAgfVxuICB9OyAvLyByZXNldCBhbGwgYm91bmQgdmFyaWFibGVzLlxuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYm91bmQgPSB7XG4gICAgICBrZXlkb3duOiB7fSxcbiAgICAgIGtleXVwOiB7fVxuICAgIH07XG4gIH07IC8vIHVuYmluZCBhbGwgbGlzdGVuZXJzIGFuZCByZXNldCBhbGwgdmFyaWFibGVzLlxuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIF9ib3VuZCA9IHtcbiAgICAgIGtleWRvd246IHt9LFxuICAgICAga2V5dXA6IHt9XG4gICAgfTtcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd24sIHRydWUpO1xuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwLCB0cnVlKTtcbiAgfTsgLy8gY3JlYXRlIGxpc3RlbmVycy5cblxuXG4gIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93biwgdHJ1ZSk7XG4gIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwLCB0cnVlKTsgLy8gcmV0dXJuIHRoZSBwdWJsaWMgZnVuY3Rpb25zLlxuXG4gIHJldHVybiBfZXhwb3J0RnVuY3Rpb25zO1xufVxuXG4vKipcbiAqIE5hdmlnYXRpb24gSGFuZGxlclxuICovXG5cbnZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBOYXZpZ2F0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5hdmlnYXRpb25IYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgdGhpcy5ib3VuZEZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWN0aXZhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWN0aXZhdGVkID0gdHJ1ZTtcblxuICAgICAgX3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVhY3RpdmF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcblxuICAgICAgX3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5hdmlnYXRpb25IYW5kbGVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHJlZnJlc2hlcyBuYXZpZ2F0aW9uIGFuZCBzZXRzIGtleSBiaW5kaW5nc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2aWdhdGlvbkJ1dHRvbnMgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaWNvbnNDcmVhdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMubG9hZE5hdmlnYXRpb25FbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaWNvbnNDcmVhdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2xlYW5OYXZpZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgcHJldmlvdXMgbmF2aWdhdGlvbiBpdGVtc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW5OYXZpZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuTmF2aWdhdGlvbigpIHtcbiAgICAgIC8vIGNsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9IC8vIGNsZWFuIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcblxuXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uRE9NICYmIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMgbm9kZXMuIFRoZXkgYXJlIGRyYXduIG92ZXIgdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGFuZCBhcmUgbm90IGFmZmVjdGVkIGJ5IHNjYWxlIGFuZCB0cmFuc2xhdGlvblxuICAgICAqIHRoZXkgaGF2ZSBhIHRyaWdnZXJGdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgb24gY2xpY2suIElmIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBpcyBkZXBlbmRlbnRcbiAgICAgKiBvbiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCBvciB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQsIHdlIGZsYWcgaG9yaXpvbnRhbEFsaWduTGVmdCBhbmQgdmVydGljYWxBbGlnblRvcCBmYWxzZS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGxvY2F0aW9uIHdpbGwgYmUgY29ycmVjdGVkIGJ5IHRoZSBfcmVsb2NhdGVOYXZpZ2F0aW9uIGZ1bmN0aW9uIG9uIGEgc2l6ZSBjaGFuZ2Ugb2YgdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkTmF2aWdhdGlvbkVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTSA9IHt9O1xuICAgICAgdmFyIG5hdmlnYXRpb25EaXZzID0gW1widXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiem9vbUluXCIsIFwiem9vbU91dFwiLCBcInpvb21FeHRlbmRzXCJdO1xuICAgICAgdmFyIG5hdmlnYXRpb25EaXZBY3Rpb25zID0gW1wiX21vdmVVcFwiLCBcIl9tb3ZlRG93blwiLCBcIl9tb3ZlTGVmdFwiLCBcIl9tb3ZlUmlnaHRcIiwgXCJfem9vbUluXCIsIFwiX3pvb21PdXRcIiwgXCJfZml0XCJdO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLmNsYXNzTmFtZSA9IFwidmlzLW5hdmlnYXRpb25cIjtcbiAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdmlnYXRpb25EaXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtXCIgKyBuYXZpZ2F0aW9uRGl2c1tpXTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcbiAgICAgICAgdmFyIGhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSk7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldID09PSBcIl9maXRcIikge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIG9uVG91Y2goaGFtbWVyLCBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLl9maXQpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICAgICAgb25Ub3VjaChoYW1tZXIsIGJpbmQkNihfY29udGV4dDIgPSB0aGlzLmJpbmRUb1JlZHJhdykuY2FsbChfY29udGV4dDIsIHRoaXMsIG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICAgIH0gLy8gdXNlIGEgaGFtbWVyIGZvciB0aGUgcmVsZWFzZSBzbyB3ZSBkbyBub3QgcmVxdWlyZSB0aGUgb25lIHVzZWQgaW4gdGhlIHJlc3Qgb2YgdGhlIG5ldHdvcmtcbiAgICAgIC8vIHRoZSBvbmUgdGhlIHJlc3QgdXNlcyBjYW4gYmUgb3ZlcmxvYWRlZCBieSB0aGUgbWFuaXB1bGF0aW9uIHN5c3RlbS5cblxuXG4gICAgICB2YXIgaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgIG9uUmVsZWFzZShoYW1tZXJGcmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX3N0b3BNb3ZlbWVudCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyRnJhbWUpO1xuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJpbmRUb1JlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVG9SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gPSBiaW5kJDYoX2NvbnRleHQzID0gdGhpc1thY3Rpb25dKS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEZyb21SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRnJvbVJlZHJhdyhhY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml0KCkge1xuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiA3MDApIHtcbiAgICAgICAgLy8gVE9ETzogZml4IHVnbHkgaGFjayB0byBhdm9pZCBoYW1tZXIncyBkb3VibGUgZmlyZWluZyBvZiBldmVudCAoYmVjYXVzZSB3ZSB1c2UgcmVsZWFzZT8pXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIiwge1xuICAgICAgICAgIGR1cmF0aW9uOiA3MDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgc3RvcHMgYWxsIG1vdmVtZW50IGluZHVjZWQgYnkgdGhlIG5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdG9wTW92ZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BNb3ZlbWVudCgpIHtcbiAgICAgIGZvciAodmFyIGJvdW5kQWN0aW9uIGluIHRoaXMuYm91bmRGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvdW5kRnVuY3Rpb25zLCBib3VuZEFjdGlvbikpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYm91bmRBY3Rpb25dKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9ucyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZVVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlVXAoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVEb3duKCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVMZWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTGVmdCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLng7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlUmlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVSaWdodCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLng7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl96b29tSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21JbigpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgKiAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdHgsXG4gICAgICAgIHk6IHR5XG4gICAgICB9O1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICBkaXJlY3Rpb246IFwiK1wiLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfem9vbU91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbU91dCgpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgLyAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdHgsXG4gICAgICAgIHk6IHR5XG4gICAgICB9O1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICBkaXJlY3Rpb246IFwiLVwiLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBiaW5kIGFsbCBrZXlzIHVzaW5nIGtleWNoYXJtLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7XG4gICAgICAgICAgICBjb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5jYW52YXMuZnJhbWUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5rZXljaGFybS5yZXNldCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDQsIF9jb250ZXh0NSwgX2NvbnRleHQ2LCBfY29udGV4dDcsIF9jb250ZXh0OCwgX2NvbnRleHQ5LCBfY29udGV4dDEwLCBfY29udGV4dDExLCBfY29udGV4dDEyLCBfY29udGV4dDEzLCBfY29udGV4dDE0LCBfY29udGV4dDE1LCBfY29udGV4dDE2LCBfY29udGV4dDE3LCBfY29udGV4dDE4LCBfY29udGV4dDE5LCBfY29udGV4dDIwLCBfY29udGV4dDIxLCBfY29udGV4dDIyLCBfY29udGV4dDIzLCBfY29udGV4dDI0LCBfY29udGV4dDI1LCBfY29udGV4dDI2LCBfY29udGV4dDI3O1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0NCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ0LCBcInVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZVVwXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDUgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NSwgXCJkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZURvd25cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0NiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ2LCBcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlTGVmdFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQ3ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDcsIFwicmlnaHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlUmlnaHRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0OCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ4LCBcIj1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0OSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ5LCBcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTAgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTAsIFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTEgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTEsIFwiLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTIgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTIsIFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTMgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTMsIFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxNCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNCwgXCJwYWdldXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTUgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTUsIFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDE2ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE2LCBcInVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVVcFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTcgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTcsIFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlRG93blwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTggPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTgsIFwibGVmdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlTGVmdFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTkgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTksIFwicmlnaHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyMCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMCwgXCI9XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjEgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjEsIFwibnVtK1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDIyID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIyLCBcIm51bS1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjMgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjMsIFwiLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyNCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyNCwgXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDI1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI1LCBcIl1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyNiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyNiwgXCJwYWdldXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyNyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyNywgXCJwYWdlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmF2aWdhdGlvbkhhbmRsZXI7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MTU7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQxNSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDE1LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIEhhbmRsZXIgZm9yIGludGVyYWN0aW9uc1xuICovXG5cbnZhciBJbnRlcmFjdGlvbkhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0ge1NlbGVjdGlvbkhhbmRsZXJ9IHNlbGVjdGlvbkhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIEludGVyYWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMsIHNlbGVjdGlvbkhhbmRsZXIpIHtcbiAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MiwgX2NvbnRleHQzLCBfY29udGV4dDQsIF9jb250ZXh0NSwgX2NvbnRleHQ2LCBfY29udGV4dDcsIF9jb250ZXh0OCwgX2NvbnRleHQ5LCBfY29udGV4dDEwLCBfY29udGV4dDExLCBfY29udGV4dDEyLCBfY29udGV4dDEzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyYWN0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5uYXZpZ2F0aW9uSGFuZGxlciA9IG5ldyBOYXZpZ2F0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpOyAvLyBiaW5kIHRoZSBldmVudHMgZnJvbSBoYW1tZXIgdG8gZnVuY3Rpb25zIGluIHRoaXMgb2JqZWN0XG5cbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAgPSBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLm9uVGFwKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaCA9IGJpbmQkNihfY29udGV4dDIgPSB0aGlzLm9uVG91Y2gpLmNhbGwoX2NvbnRleHQyLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXAgPSBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5vbkRvdWJsZVRhcCkuY2FsbChfY29udGV4dDMsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQgPSBiaW5kJDYoX2NvbnRleHQ0ID0gdGhpcy5vbkhvbGQpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQgPSBiaW5kJDYoX2NvbnRleHQ1ID0gdGhpcy5vbkRyYWdTdGFydCkuY2FsbChfY29udGV4dDUsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWcgPSBiaW5kJDYoX2NvbnRleHQ2ID0gdGhpcy5vbkRyYWcpLmNhbGwoX2NvbnRleHQ2LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kID0gYmluZCQ2KF9jb250ZXh0NyA9IHRoaXMub25EcmFnRW5kKS5jYWxsKF9jb250ZXh0NywgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbCA9IGJpbmQkNihfY29udGV4dDggPSB0aGlzLm9uTW91c2VXaGVlbCkuY2FsbChfY29udGV4dDgsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoID0gYmluZCQ2KF9jb250ZXh0OSA9IHRoaXMub25QaW5jaCkuY2FsbChfY29udGV4dDksIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZSA9IGJpbmQkNihfY29udGV4dDEwID0gdGhpcy5vbk1vdXNlTW92ZSkuY2FsbChfY29udGV4dDEwLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlID0gYmluZCQ2KF9jb250ZXh0MTEgPSB0aGlzLm9uUmVsZWFzZSkuY2FsbChfY29udGV4dDExLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0ID0gYmluZCQ2KF9jb250ZXh0MTIgPSB0aGlzLm9uQ29udGV4dCkuY2FsbChfY29udGV4dDEyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy5kcmFnID0ge307XG4gICAgdGhpcy5waW5jaCA9IHt9O1xuICAgIHRoaXMucG9wdXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3B1cE9iaiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyID0gYmluZCQ2KF9jb250ZXh0MTMgPSB0aGlzLmdldFBvaW50ZXIpLmNhbGwoX2NvbnRleHQxMywgdGhpcyk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNwZWVkOiB7XG4gICAgICAgICAgeDogMTAsXG4gICAgICAgICAgeTogMTAsXG4gICAgICAgICAgem9vbTogMC4wMlxuICAgICAgICB9LFxuICAgICAgICBiaW5kVG9XaW5kb3c6IHRydWUsXG4gICAgICAgIGF1dG9Gb2N1czogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25CdXR0b25zOiBmYWxzZSxcbiAgICAgIHRvb2x0aXBEZWxheTogMzAwLFxuICAgICAgem9vbVZpZXc6IHRydWUsXG4gICAgICB6b29tU3BlZWQ6IDFcbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhJbnRlcmFjdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucG9wdXBUaW1lcik7XG4gICAgICAgIGRlbGV0ZSBfdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGV4dGVuZCBhbGwgYnV0IHRoZSB2YWx1ZXMgaW4gZmllbGRzXG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJoaWRlRWRnZXNPbkRyYWdcIiwgXCJoaWRlRWRnZXNPblpvb21cIiwgXCJoaWRlTm9kZXNPbkRyYWdcIiwgXCJrZXlib2FyZFwiLCBcIm11bHRpc2VsZWN0XCIsIFwic2VsZWN0YWJsZVwiLCBcInNlbGVjdENvbm5lY3RlZEVkZ2VzXCJdO1xuICAgICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gbWVyZ2UgdGhlIGtleWJvYXJkIG9wdGlvbnMgaW4uXG5cbiAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgXCJrZXlib2FyZFwiKTtcblxuICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwKSB7XG4gICAgICAgICAgYXNzaWduJDIodGhpcy5vcHRpb25zLnRvb2x0aXAsIG9wdGlvbnMudG9vbHRpcCk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9vbHRpcC5jb2xvciA9IHBhcnNlQ29sb3Iob3B0aW9ucy50b29sdGlwLmNvbG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFuZGxlci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9pbnRlciBsb2NhdGlvbiBmcm9tIGEgdG91Y2ggbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gdG91Y2hcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50ZXIodG91Y2gpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRvdWNoLnggLSBnZXRBYnNvbHV0ZUxlZnQodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzKSxcbiAgICAgICAgeTogdG91Y2gueSAtIGdldEFic29sdXRlVG9wKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcylcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHN0YXJ0IG9mIGEgdG91Y2ggZ2VzdHVyZSwgc3RvcmUgdGhlIHBvaW50ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblRvdWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVG91Y2goZXZlbnQpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNTApIHtcbiAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5kcmFnLnBpbmNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlOyAvLyB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGV2ZW50IGJlY2F1c2Ugd2UgaGF2ZSB0d28gaGFtbWVyIGluc3RhbmNlcy4gKG9uIGNhbnZhcyBhbmQgb24gZnJhbWUpXG5cbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRhcC9jbGljayBldmVudDogc2VsZWN0L3Vuc2VsZWN0IGEgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25UYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UYXAoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdCAmJiAoZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLmN0cmxLZXkgfHwgZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLm1ldGFLZXkpO1xuICAgICAgdGhpcy5jaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgbXVsdGlzZWxlY3QpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdEFuZEVtaXQocG9pbnRlciwgZXZlbnQpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNsaWNrXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRvdWJsZXRhcCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Eb3VibGVUYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZG91YmxlQ2xpY2tcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbG9uZyB0YXAgZXZlbnQ6IG11bHRpIHNlbGVjdCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Ib2xkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uSG9sZChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0O1xuICAgICAgdGhpcy5jaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgbXVsdGlzZWxlY3QpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdEFuZEVtaXQocG9pbnRlciwgZXZlbnQpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNsaWNrXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJob2xkXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSByZWxlYXNlIG9mIHRoZSBzY3JlZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVsZWFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlbGVhc2UoZXZlbnQpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTApIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcInJlbGVhc2VcIiwgZXZlbnQsIHBvaW50ZXIpOyAvLyB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGV2ZW50IGJlY2F1c2Ugd2UgaGF2ZSB0d28gaGFtbWVyIGluc3RhbmNlcy4gKG9uIGNhbnZhcyBhbmQgb24gZnJhbWUpXG5cbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29udGV4dChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoe1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJvbmNvbnRleHRcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW5kIGRlc2VsZWN0IG5vZGVzIGRlcGVuZGluZyBjdXJyZW50IHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthZGQ9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1NlbGVjdGlvbkNoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIpIHtcbiAgICAgIHZhciBhZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoYWRkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RBZGRpdGlvbmFsT25Qb2ludChwb2ludGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPblBvaW50KHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG5vZGUgYW5kIGVkZ2UgaWQncyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgc2Vjb25kIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX0gZmlyc3RTZXRcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19IHNlY29uZFNldFxuICAgICAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lRGlmZmVyZW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lRGlmZmVyZW5jZShmaXJzdFNldCwgc2Vjb25kU2V0KSB7XG4gICAgICB2YXIgYXJyYXlEaWZmID0gZnVuY3Rpb24gYXJyYXlEaWZmKGZpcnN0QXJyLCBzZWNvbmRBcnIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3RBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmaXJzdEFycltpXTtcblxuICAgICAgICAgIGlmIChpbmRleE9mKHNlY29uZEFycikuY2FsbChzZWNvbmRBcnIsIHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IGFycmF5RGlmZihmaXJzdFNldC5ub2Rlcywgc2Vjb25kU2V0Lm5vZGVzKSxcbiAgICAgICAgZWRnZXM6IGFycmF5RGlmZihmaXJzdFNldC5lZGdlcywgc2Vjb25kU2V0LmVkZ2VzKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgb25EcmFnU3RhcnQuXG4gICAgICogSXQgaXMgc2VwYXJhdGVkIG91dCBiZWNhdXNlIHdlIGNhbiB0aGVuIG92ZXJsb2FkIGl0IGZvciB0aGUgZGF0YW1hbmlwdWxhdGlvbiBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgICAgLy8gaWYgYWxyZWFkeSBkcmFnZ2luZywgZG8gbm90IHN0YXJ0XG4gICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gb24gdG91Y2ggc2NyZWVucyB3aXRoIG11bHRpcGxlIGZpbmdlcnNcbiAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvL2luIGNhc2UgdGhlIHRvdWNoIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gYW4gZXh0ZXJuYWwgZGl2LCBkbyB0aGUgaW5pdGlhbCB0b3VjaCBub3cuXG5cblxuICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH0gLy8gbm90ZTogZHJhZy5wb2ludGVyIGlzIHNldCBpbiBvblRvdWNoIHRvIGdldCB0aGUgaW5pdGlhbCB0b3VjaCBsb2NhdGlvblxuXG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdCh0aGlzLmRyYWcucG9pbnRlcik7XG4gICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5kcmFnLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgdGhpcy5kcmFnLnRyYW5zbGF0aW9uID0gYXNzaWduJDIoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG5cbiAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cgPSB0cnVlO1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0ID0ge1xuICAgICAgICAgIHg6IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCksXG4gICAgICAgICAgeTogdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZCA9IHtcbiAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSBub2RlLmlkOyAvLyBzZWxlY3QgdGhlIGNsaWNrZWQgbm9kZSBpZiBub3QgeWV0IHNlbGVjdGVkXG5cbiAgICAgICAgaWYgKG5vZGUuaXNTZWxlY3RlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgbm9kZXM6IFtub2RlLmlkXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIGFmdGVyIHNlbGVjdCB0byBjb250YWluIHRoZSBub2RlXG5cblxuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlcik7IC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYW5kIHN0YXR1c1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzKCkpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9ub2RlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgICAgaWQ6IF9ub2RlLmlkLFxuICAgICAgICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgICAgICAgLy8gc3RvcmUgb3JpZ2luYWwgeCwgeSwgeEZpeGVkIGFuZCB5Rml4ZWQsIG1ha2UgdGhlIG5vZGUgdGVtcG9yYXJpbHkgRml4ZWRcbiAgICAgICAgICAgICAgeDogX25vZGUueCxcbiAgICAgICAgICAgICAgeTogX25vZGUueSxcbiAgICAgICAgICAgICAgeEZpeGVkOiBfbm9kZS5vcHRpb25zLmZpeGVkLngsXG4gICAgICAgICAgICAgIHlGaXhlZDogX25vZGUub3B0aW9ucy5maXhlZC55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX25vZGUub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9ub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWcuc2VsZWN0aW9uLnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIHRodXMgdGhlIHZpZXcgaXMgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLCBldmVudCwgdGhpcy5kcmFnLnBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkcmFnIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZHJhZy5waW5jaGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gcmVtb3ZlIHRoZSBmb2N1cyBvbiBub2RlIGlmIGl0IGlzIGZvY3Vzc2VkIG9uIGJ5IHRoZSBmb2N1c09uTm9kZVxuXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ1bmxvY2tOb2RlXCIpO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmRyYWdOb2RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIpOyAvLyBjYWxjdWxhdGUgZGVsdGEncyBhbmQgbmV3IGxvY2F0aW9uXG5cbiAgICAgICAgdmFyIGRlbHRhWCA9IHBvaW50ZXIueCAtIHRoaXMuZHJhZy5wb2ludGVyLng7XG4gICAgICAgIHZhciBkZWx0YVkgPSBwb2ludGVyLnkgLSB0aGlzLmRyYWcucG9pbnRlci55OyAvLyB1cGRhdGUgcG9zaXRpb24gb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG5cbiAgICAgICAgZm9yRWFjaCQyKHNlbGVjdGlvbikuY2FsbChzZWxlY3Rpb24sIGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdGlvbi5ub2RlOyAvLyBvbmx5IG1vdmUgdGhlIG5vZGUgaWYgaXQgd2FzIG5vdCBmaXhlZCBpbml0aWFsbHlcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ueEZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS54ID0gX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9YY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi54KSArIGRlbHRhWCk7XG4gICAgICAgICAgfSAvLyBvbmx5IG1vdmUgdGhlIG5vZGUgaWYgaXQgd2FzIG5vdCBmaXhlZCBpbml0aWFsbHlcblxuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi55Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnkgPSBfdGhpczIuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1ljb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLnkpICsgZGVsdGFZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBzdGFydCB0aGUgc2ltdWxhdGlvbiBvZiB0aGUgcGh5c2ljc1xuXG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBzZWxlY3Rpb24gYm94XG4gICAgICAgIGlmIChldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTsgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cblxuICAgICAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZCA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCksXG4gICAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH0gLy8gbW92ZSB0aGUgbmV0d29ya1xuXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnVmlldyA9PT0gdHJ1ZSAmJiAhZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIGlmIHRoZSBkcmFnIHdhcyBub3Qgc3RhcnRlZCBwcm9wZXJseSBiZWNhdXNlIHRoZSBjbGljayBzdGFydGVkIG91dHNpZGUgdGhlIG5ldHdvcmsgZGl2LCBzdGFydCBpdCBub3cuXG5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpZmZYID0gcG9pbnRlci54IC0gdGhpcy5kcmFnLnBvaW50ZXIueDtcbiAgICAgICAgICB2YXIgZGlmZlkgPSBwb2ludGVyLnkgLSB0aGlzLmRyYWcucG9pbnRlci55O1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgICAgeDogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnggKyBkaWZmWCxcbiAgICAgICAgICAgIHk6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi55ICsgZGlmZllcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25EcmFnRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ0VuZChldmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZHJhZy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93KSB7XG4gICAgICAgIHZhciBfY29udGV4dDE0O1xuXG4gICAgICAgIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdyA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VsZWN0aW9uQm94UG9zaXRpb24gPSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uO1xuICAgICAgICB2YXIgc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXggPSB7XG4gICAgICAgICAgbWluWDogTWF0aC5taW4oc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueCwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLngpLFxuICAgICAgICAgIG1pblk6IE1hdGgubWluKHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LnksIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC55KSxcbiAgICAgICAgICBtYXhYOiBNYXRoLm1heChzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC54LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueCksXG4gICAgICAgICAgbWF4WTogTWF0aC5tYXgoc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueSwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLnkpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRvQmVTZWxlY3RlZE5vZGVzID0gZmlsdGVyKF9jb250ZXh0MTQgPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQxNCwgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICByZXR1cm4gbm9kZS54ID49IHNlbGVjdGlvbkJveFBvc2l0aW9uTWluTWF4Lm1pblggJiYgbm9kZS54IDw9IHNlbGVjdGlvbkJveFBvc2l0aW9uTWluTWF4Lm1heFggJiYgbm9kZS55ID49IHNlbGVjdGlvbkJveFBvc2l0aW9uTWluTWF4Lm1pblkgJiYgbm9kZS55IDw9IHNlbGVjdGlvbkJveFBvc2l0aW9uTWluTWF4Lm1heFk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvckVhY2gkMih0b0JlU2VsZWN0ZWROb2RlcykuY2FsbCh0b0JlU2VsZWN0ZWROb2RlcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QoX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIiwgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3JFYWNoJDIoc2VsZWN0aW9uKS5jYWxsKHNlbGVjdGlvbiwgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgeEZpeGVkIGFuZCB5Rml4ZWRcbiAgICAgICAgICAgIHMubm9kZS5vcHRpb25zLmZpeGVkLnggPSBzLnhGaXhlZDtcbiAgICAgICAgICAgIHMubm9kZS5vcHRpb25zLmZpeGVkLnkgPSBzLnlGaXhlZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwaW5jaCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUGluY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QaW5jaChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMucGluY2hbXCJzY2FsZVwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSAxO1xuICAgICAgfSAvLyBUT0RPOiBlbmFibGVkIG1vdmluZyB3aGlsZSBwaW5jaGluZz9cblxuXG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnBpbmNoLnNjYWxlICogZXZlbnQuc2NhbGU7XG4gICAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBab29tIHRoZSBuZXR3b3JrIGluIG9yIG91dFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIGEgbnVtYmVyIGFyb3VuZCAxLCBhbmQgYmV0d2VlbiAwLjAxIGFuZCAxMFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciAgICBQb3NpdGlvbiBvbiBzY3JlZW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKHNjYWxlLCBwb2ludGVyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuXG4gICAgICAgIGlmIChzY2FsZSA8IDAuMDAwMDEpIHtcbiAgICAgICAgICBzY2FsZSA9IDAuMDAwMDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NhbGUgPiAxMCkge1xuICAgICAgICAgIHNjYWxlID0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGhpcy5kcmFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnLmRyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwcmVTY2FsZURyYWdQb2ludGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXModGhpcy5kcmFnLnBvaW50ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyArIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgLyAyXG5cblxuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHR4LFxuICAgICAgICAgIHk6IHR5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByZVNjYWxlRHJhZ1BvaW50ZXIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHBvc3RTY2FsZURyYWdQb2ludGVyID0gdGhpcy5jYW52YXMuY2FudmFzVG9ET00ocHJlU2NhbGVEcmFnUG9pbnRlcik7XG4gICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIueCA9IHBvc3RTY2FsZURyYWdQb2ludGVyLng7XG4gICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIueSA9IHBvc3RTY2FsZURyYWdQb2ludGVyLnk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG5cbiAgICAgICAgaWYgKHNjYWxlT2xkIDwgc2NhbGUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiK1wiLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCItXCIsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciBmb3IgbW91c2Ugd2hlZWwgZXZlbnQsIHVzZWQgdG8gem9vbSB0aGUgdGltZWxpbmVcbiAgICAgKiBTZWUgaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAgICAgKiAgICAgaHR0cHM6Ly9naXRodWIuY29tL0VpZ2h0TWVkaWEvaGFtbWVyLmpzL2lzc3Vlcy8yNTZcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VXaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgLy8gSWYgZGVsdGEgaXMgbm9uemVybywgaGFuZGxlIGl0LlxuICAgICAgICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gICAgICAgIC8vIGFuZCBuZWdhdGl2ZSwgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIGRvd24uXG4gICAgICAgIGlmIChldmVudC5kZWx0YVkgIT09IDApIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIHNjYWxlICo9IDEgKyAoZXZlbnQuZGVsdGFZIDwgMCA/IDEgOiAtMSkgKiAodGhpcy5vcHRpb25zLnpvb21TcGVlZCAqIDAuMSk7IC8vIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciBsb2NhdGlvblxuXG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoe1xuICAgICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICB9KTsgLy8gYXBwbHkgdGhlIG5ldyBzY2FsZVxuXG4gICAgICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICAgICAgfSAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWwuXG5cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXIgZm9yIGNoZWNraW5nIHdoZXRoZXIgdGhlIHRpdGxlIG1vdmVzIG92ZXIgYSBub2RlIHdpdGggYSB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9wdXBWaXNpYmxlID0gZmFsc2U7IC8vIGNoZWNrIGlmIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIG5vZGUgaXMgc3RpbGwgc2VsZWN0ZWRcblxuICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tIaWRlUG9wdXAocG9pbnRlcik7XG4gICAgICAgIH0gLy8gaWYgdGhlIHBvcHVwIHdhcyBub3QgaGlkZGVuIGFib3ZlXG5cblxuICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcG9wdXBWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNldFBvc2l0aW9uKHBvaW50ZXIueCArIDMsIHBvaW50ZXIueSAtIDUpO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmIHdlIGJpbmQgdGhlIGtleWJvYXJkIHRvIHRoZSBkaXYsIHdlIGhhdmUgdG8gaGlnaGxpZ2h0IGl0IHRvIHVzZSBpdC4gVGhpcyBoaWdobGlnaHRzIGl0IG9uIG1vdXNlIG92ZXIuXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5hdXRvRm9jdXMgJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gZmFsc2UgJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuZm9jdXMoKTtcbiAgICAgIH0gLy8gc3RhcnQgYSB0aW1lb3V0IHRoYXQgd2lsbCBjaGVjayBpZiB0aGUgbW91c2UgaXMgcG9zaXRpb25lZCBhYm92ZSBhbiBlbGVtZW50XG5cblxuICAgICAgaWYgKHBvcHVwVmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvcHVwVGltZXIpOyAvLyBzdG9wIGFueSBydW5uaW5nIGNhbGN1bGF0aW9uVGltZXJcblxuICAgICAgICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5kcmFnLmRyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cFRpbWVyID0gc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczQuX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpO1xuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy50b29sdGlwRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFkZGluZyBob3ZlciBoaWdobGlnaHRzXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuaG92ZXJPYmplY3QoZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBpcyBhbiBlbGVtZW50IG9uIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgbmV0d29ya1xuICAgICAqIChhIG5vZGUgb3IgZWRnZSkuIElmIHNvLCBhbmQgaWYgdGhpcyBlbGVtZW50IGhhcyBhIHRpdGxlLFxuICAgICAqIHNob3cgYSBwb3B1cCB3aW5kb3cgd2l0aCBpdHMgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlciwgeTpudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja1Nob3dQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTaG93UG9wdXAocG9pbnRlcikge1xuICAgICAgdmFyIHggPSB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpO1xuXG4gICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG5cbiAgICAgIHZhciBwb2ludGVyT2JqID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiB4LFxuICAgICAgICBib3R0b206IHlcbiAgICAgIH07XG4gICAgICB2YXIgcHJldmlvdXNQb3B1cE9iaklkID0gdGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy5wb3B1cE9iai5pZDtcbiAgICAgIHZhciBub2RlVW5kZXJDdXJzb3IgPSBmYWxzZTtcbiAgICAgIHZhciBwb3B1cFR5cGUgPSBcIm5vZGVcIjsgLy8gY2hlY2sgaWYgYSBub2RlIGlzIHVuZGVyIHRoZSBjdXJzb3IuXG5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2VhcmNoIHRoZSBub2RlcyBmb3Igb3ZlcmxhcCwgc2VsZWN0IHRoZSB0b3Agb25lIGluIGNhc2Ugb2YgbXVsdGlwbGUgbm9kZXNcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgICAgaWYgKG5vZGUuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vZGVVbmRlckN1cnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUluZGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBub2Rlc1tvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV1dOyAvLyBpZiB5b3UgaG92ZXIgb3ZlciBhIG5vZGUsIHRoZSB0aXRsZSBvZiB0aGUgZWRnZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgc2hvd24uXG5cbiAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQgJiYgbm9kZVVuZGVyQ3Vyc29yID09PSBmYWxzZSkge1xuICAgICAgICAvLyBzZWFyY2ggdGhlIGVkZ2VzIGZvciBvdmVybGFwXG4gICAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG5cbiAgICAgICAgICBpZiAoZWRnZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIGVkZ2UuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZXMucHVzaChlZGdlSW5kaWNlc1tfaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdmVybGFwcGluZ0VkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnBvcHVwT2JqID0gZWRnZXNbb3ZlcmxhcHBpbmdFZGdlc1tvdmVybGFwcGluZ0VkZ2VzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICBwb3B1cFR5cGUgPSBcImVkZ2VcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wb3B1cE9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNob3cgcG9wdXAgbWVzc2FnZSB3aW5kb3dcbiAgICAgICAgaWYgKHRoaXMucG9wdXBPYmouaWQgIT09IHByZXZpb3VzUG9wdXBPYmpJZCkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcHVwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXAgPSBuZXcgUG9wdXAodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlID0gcG9wdXBUeXBlO1xuICAgICAgICAgIHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZCA9IHRoaXMucG9wdXBPYmouaWQ7IC8vIGFkanVzdCBhIHNtYWxsIG9mZnNldCBzdWNoIHRoYXQgdGhlIG1vdXNlIGN1cnNvciBpcyBsb2NhdGVkIGluIHRoZVxuICAgICAgICAgIC8vIGJvdHRvbSBsZWZ0IGxvY2F0aW9uIG9mIHRoZSBwb3B1cCwgYW5kIHlvdSBjYW4gZWFzaWx5IG1vdmUgb3ZlciB0aGVcbiAgICAgICAgICAvLyBwb3B1cCBhcmVhXG5cbiAgICAgICAgICB0aGlzLnBvcHVwLnNldFBvc2l0aW9uKHBvaW50ZXIueCArIDMsIHBvaW50ZXIueSAtIDUpO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2V0VGV4dCh0aGlzLnBvcHVwT2JqLmdldFRpdGxlKCkpO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2hvdygpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzaG93UG9wdXBcIiwgdGhpcy5wb3B1cE9iai5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwLmhpZGUoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaGlkZVBvcHVwXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwb3B1cCBtdXN0IGJlIGhpZGRlbiwgd2hpY2ggaXMgdGhlIGNhc2Ugd2hlbiB0aGUgbW91c2UgaXMgbm9cbiAgICAgKiBsb25nZXIgaG92ZXJpbmcgb24gdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tIaWRlUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgdmFyIHN0aWxsT25PYmogPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlID09PSBcIm5vZGVcIikge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTsgLy8gaWYgdGhlIG1vdXNlIGlzIHN0aWxsIG9uZSB0aGUgbm9kZSwgd2UgaGF2ZSB0byBjaGVjayBpZiBpdCBpcyBub3QgYWxzbyBvbiBvbmUgdGhhdCBpcyBkcmF3biBvbiB0b3Agb2YgaXQuXG4gICAgICAgICAgLy8gd2UgaW5pdGlhbGx5IG9ubHkgY2hlY2sgc3RpbGxPbk9iaiBiZWNhdXNlIHRoaXMgaXMgbXVjaCBmYXN0ZXIuXG5cbiAgICAgICAgICBpZiAoc3RpbGxPbk9iaiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG92ZXJOb2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSBvdmVyTm9kZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvdmVyTm9kZS5pZCA9PT0gdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGlsbE9uT2JqID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGlsbE9uT2JqID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnBvcHVwT2JqID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvcHVwLmhpZGUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhpZGVQb3B1cFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJhY3Rpb25IYW5kbGVyO1xufSgpO1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgcmVkZWZpbmVBbGwkMSA9IHJlZGVmaW5lQWxsJDM7XG52YXIgZ2V0V2Vha0RhdGEgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHMuZ2V0V2Vha0RhdGE7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRkO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCRqO1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMztcbnZhciBBcnJheUl0ZXJhdGlvbk1vZHVsZSA9IGFycmF5SXRlcmF0aW9uO1xudmFyIGhhc093biA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcbnZhciBmaW5kID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZDtcbnZhciBmaW5kSW5kZXggPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kSW5kZXg7XG52YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMkMShbXS5zcGxpY2UpO1xudmFyIGlkID0gMDsgLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG5cbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHJldHVybiBzdG9yZS5mcm96ZW4gfHwgKHN0b3JlLmZyb3plbiA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcblxudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW50cmllcyA9IFtdO1xufTtcblxudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBmaW5kKHN0b3JlLmVudHJpZXMsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5cblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7ZWxzZSB0aGlzLmVudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleCh0aGlzLmVudHJpZXMsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgc3BsaWNlKHRoaXMuZW50cmllcywgaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcbnZhciBjb2xsZWN0aW9uV2VhayQxID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBQcm90b3R5cGUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGlkOiBpZCsrLFxuICAgICAgICBmcm96ZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwge1xuICAgICAgICB0aGF0OiB0aGF0LFxuICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5zZXQoa2V5LCB2YWx1ZSk7ZWxzZSBkYXRhW3N0YXRlLmlkXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsJDEoUHJvdG90eXBlLCB7XG4gICAgICAvLyBgeyBXZWFrTWFwLCBXZWFrU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5kZWxldGVcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghaXNPYmplY3QkMShrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07XG4gICAgICB9LFxuICAgICAgLy8gYHsgV2Vha01hcCwgV2Vha1NldCB9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5oYXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdCQxKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXNPd24oZGF0YSwgc3RhdGUuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsJDEoUHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyBgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5nZXRcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuXG4gICAgICAgIGlmIChpc09iamVjdCQxKGtleSkpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5nZXQoa2V5KTtcbiAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGFbc3RhdGUuaWRdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyBgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmFkZFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG59O1xuXG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkUDtcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgcmVkZWZpbmVBbGwgPSByZWRlZmluZUFsbCQzO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHM7XG52YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24kMztcbnZhciBjb2xsZWN0aW9uV2VhayA9IGNvbGxlY3Rpb25XZWFrJDE7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCRqO1xudmFyIGlzRXh0ZW5zaWJsZSA9IG9iamVjdElzRXh0ZW5zaWJsZTtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZW5mb3JjZTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSBuYXRpdmVXZWFrTWFwO1xudmFyIElTX0lFMTEgPSAhZ2xvYmFsJDEuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsJDE7XG52YXIgSW50ZXJuYWxXZWFrTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTsgLy8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAtY29uc3RydWN0b3JcblxuXG52YXIgJFdlYWtNYXAgPSBjb2xsZWN0aW9uKCdXZWFrTWFwJywgd3JhcHBlciwgY29sbGVjdGlvbldlYWspOyAvLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG4vLyBXZSBjYW4ndCB1c2UgZmVhdHVyZSBkZXRlY3Rpb24gYmVjYXVzZSBpdCBjcmFzaCBzb21lIG9sZCBJRSBidWlsZHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80ODVcblxuaWYgKE5BVElWRV9XRUFLX01BUCAmJiBJU19JRTExKSB7XG4gIEludGVybmFsV2Vha01hcCA9IGNvbGxlY3Rpb25XZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsICdXZWFrTWFwJywgdHJ1ZSk7XG4gIEludGVybmFsTWV0YWRhdGFNb2R1bGUuZW5hYmxlKCk7XG4gIHZhciBXZWFrTWFwUHJvdG90eXBlID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlRGVsZXRlID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZVsnZGVsZXRlJ10pO1xuICB2YXIgbmF0aXZlSGFzID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5oYXMpO1xuICB2YXIgbmF0aXZlR2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5nZXQpO1xuICB2YXIgbmF0aXZlU2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5zZXQpO1xuICByZWRlZmluZUFsbChXZWFrTWFwUHJvdG90eXBlLCB7XG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZSh0aGlzLCBrZXkpIHx8IHN0YXRlLmZyb3plblsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZSh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSkgPyBuYXRpdmVHZXQodGhpcywga2V5KSA6IHN0YXRlLmZyb3plbi5nZXQoa2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZUdldCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICBuYXRpdmVIYXModGhpcywga2V5KSA/IG5hdGl2ZVNldCh0aGlzLCBrZXksIHZhbHVlKSA6IHN0YXRlLmZyb3plbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgcGF0aCA9IHBhdGgkeTtcbnZhciB3ZWFrTWFwJDIgPSBwYXRoLldlYWtNYXA7XG5cbnZhciBwYXJlbnQkMSA9IHdlYWtNYXAkMjtcbnZhciB3ZWFrTWFwJDEgPSBwYXJlbnQkMTtcblxudmFyIHdlYWtNYXAgPSB3ZWFrTWFwJDE7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSwgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MjsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQyLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDMoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyO1xuLyoqXHJcbiAqIEBwYXJhbSBwcmV2XHJcbiAqIEBwYXJhbSBuZXh0XHJcbiAqL1xuXG5mdW5jdGlvbiBkaWZmU2V0cyhwcmV2LCBuZXh0KSB7XG4gIHZhciBkaWZmID0gbmV3IHNldCgpO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG5leHQpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGl0ZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKCFwcmV2LmhhcyhpdGVtKSkge1xuICAgICAgICBkaWZmLmFkZChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmO1xufVxuXG52YXIgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IpO1xuXG4gICAgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbi5zZXQodGhpcywgbmV3IHNldCgpKTtcblxuICAgIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLnNldCh0aGlzLCBuZXcgc2V0KCkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBpdGVtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaXRlbXMgPSBpdGVtczsgX2kgPCBfaXRlbXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gX2l0ZW1zW19pXTtcblxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2l0ZW1zMiA9IGl0ZW1zOyBfaTIgPCBfaXRlbXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfaXRlbXMyW19pMl07XG5cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLmRlbGV0ZShpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2hhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFuZ2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkZWQ6IF90b0NvbnN1bWFibGVBcnJheShkaWZmU2V0cyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIFwiZlwiKSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpKSksXG4gICAgICAgIGRlbGV0ZWQ6IF90b0NvbnN1bWFibGVBcnJheShkaWZmU2V0cyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIiksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpKSksXG4gICAgICAgIHByZXZpb3VzOiBfdG9Db25zdW1hYmxlQXJyYXkobmV3IHNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIFwiZlwiKSkpLFxuICAgICAgICBjdXJyZW50OiBfdG9Db25zdW1hYmxlQXJyYXkobmV3IHNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5nZXRDaGFuZ2VzKCk7XG5cbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLCBcImZcIik7XG5cbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIG5ldyBzZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIikpLCBcImZcIik7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhjaGFuZ2VzLmFkZGVkKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhjaGFuZ2VzLmRlbGV0ZWQpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2l0ZW0gPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICBfaXRlbS51bnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcjtcbn0oKTtcblxuX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiA9IG5ldyB3ZWFrTWFwKCksIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uID0gbmV3IHdlYWtNYXAoKTtcbnZhciBTZWxlY3Rpb25BY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdGlvbkFjY3VtdWxhdG9yKCkge1xuICAgIHZhciBjb21taXRIYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmdW5jdGlvbiAoKSB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb25BY2N1bXVsYXRvcik7XG5cbiAgICBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMuc2V0KHRoaXMsIG5ldyBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSk7XG5cbiAgICBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMuc2V0KHRoaXMsIG5ldyBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSk7XG5cbiAgICBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlci5zZXQodGhpcywgdm9pZCAwKTtcblxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIsIGNvbW1pdEhhbmRsZXIsIFwiZlwiKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb25BY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwic2l6ZU5vZGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplRWRnZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVzKCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VzKCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVzKCkge1xuICAgICAgdmFyIF9jbGFzc1ByaXZhdGVGaWVsZEdlO1xuXG4gICAgICAoX2NsYXNzUHJpdmF0ZUZpZWxkR2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpKS5hZGQuYXBwbHkoX2NsYXNzUHJpdmF0ZUZpZWxkR2UsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VzKCkge1xuICAgICAgdmFyIF9jbGFzc1ByaXZhdGVGaWVsZEdlMjtcblxuICAgICAgKF9jbGFzc1ByaXZhdGVGaWVsZEdlMiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikpLmFkZC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZTIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZU5vZGVzKG5vZGUpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuZGVsZXRlKG5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVFZGdlcyhlZGdlKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmRlbGV0ZShlZGdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmNsZWFyKCk7XG5cbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTMsIF9jb250ZXh0O1xuXG4gICAgICB2YXIgc3VtbWFyeSA9IHtcbiAgICAgICAgbm9kZXM6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuY29tbWl0KCksXG4gICAgICAgIGVkZ2VzOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmNvbW1pdCgpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgcmVzdFtfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICAoX2NsYXNzUHJpdmF0ZUZpZWxkR2UzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlciwgXCJmXCIpKS5jYWxsLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlMywgY29uY2F0KF9jb250ZXh0ID0gW3RoaXMsIHN1bW1hcnldKS5jYWxsKF9jb250ZXh0LCByZXN0KSk7XG5cbiAgICAgIHJldHVybiBzdW1tYXJ5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3Rpb25BY2N1bXVsYXRvcjtcbn0oKTtcbl9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcyA9IG5ldyB3ZWFrTWFwKCksIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcyA9IG5ldyB3ZWFrTWFwKCksIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyID0gbmV3IHdlYWtNYXAoKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQzOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDMsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxuICogVGhlIGhhbmRsZXIgZm9yIHNlbGVjdGlvbnNcbiAqL1xuXG52YXIgU2VsZWN0aW9uSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBTZWxlY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzOyAvLyBUT0RPOiBDb25zaWRlciBmaXJpbmcgYW4gZXZlbnQgb24gYW55IGNoYW5nZSB0byB0aGUgc2VsZWN0aW9uLCBub3RcbiAgICAvLyBvbmx5IHRob3NlIGNhdXNlZCBieSBjbGlja3MgYW5kIHRhcHMuIEl0IHdvdWxkIGJlIGVhc3kgdG8gaW1wbGVtZW50XG4gICAgLy8gbm93IGFuZCAoYXQgbGVhc3QgdG8gbWUpIGl0IHNlZW1zIGxpa2Ugc29tZXRoaW5nIHRoYXQgY291bGQgYmVcbiAgICAvLyBxdWl0ZSB1c2VmdWwuXG5cbiAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvciA9IG5ldyBTZWxlY3Rpb25BY2N1bXVsYXRvcigpO1xuICAgIHRoaXMuaG92ZXJPYmogPSB7XG4gICAgICBub2Rlczoge30sXG4gICAgICBlZGdlczoge31cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb25IYW5kbGVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmllbGRzID0gW1wibXVsdGlzZWxlY3RcIiwgXCJob3ZlckNvbm5lY3RlZEVkZ2VzXCIsIFwic2VsZWN0YWJsZVwiLCBcInNlbGVjdENvbm5lY3RlZEVkZ2VzXCJdO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlcyB0aGUgc2VsZWN0aW9uIHBhcnQgb2YgdGhlIHRhcDtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0T25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpOyAvLyB1bnNlbGVjdCBhZnRlciBnZXR0aW5nIHRoZSBvYmplY3RzIGluIG9yZGVyIHRvIHJlc3RvcmUgd2lkdGggYW5kIGhlaWdodC5cblxuICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RBZGRpdGlvbmFsT25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RBZGRpdGlvbmFsT25Qb2ludChwb2ludGVyKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG9iai5pc1NlbGVjdGVkKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhbmRhcmQgZmllbGRzIGZvciBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIE9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0QmFzZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgcHJvcGVydGllc1tcInBvaW50ZXJcIl0gPSB7XG4gICAgICAgIERPTToge1xuICAgICAgICAgIHg6IHBvaW50ZXIueCxcbiAgICAgICAgICB5OiBwb2ludGVyLnlcbiAgICAgICAgfSxcbiAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKVxuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXNbXCJldmVudFwiXSA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGV2ZW50IHdoaWNoIHRoZSB1c2VyIGNhbiBjYXRjaC5cbiAgICAgKlxuICAgICAqIFRoaXMgYWRkcyBzb21lIGV4dHJhIGRhdGEgdG8gdGhlIGV2ZW50IHdpdGggcmVzcGVjdCB0byBjdXJzb3IgcG9zaXRpb24gYW5kXG4gICAgICogc2VsZWN0ZWQgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgTmFtZSBvZiBldmVudCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyICAgICAgICAgICAgT2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgdW5kZWZpbmVkfSBvbGRTZWxlY3Rpb24gICAgICAgICAgICAgSWYgcHJlc2VudCwgc2VsZWN0aW9uIHN0YXRlIGJlZm9yZSBldmVudCBvY2N1cmVkXG4gICAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gW2VtcHR5U2VsZWN0aW9uPWZhbHNlXSAgSW5kaWNhdGUgaWYgc2VsZWN0aW9uIGRhdGEgc2hvdWxkIGJlIHBhc3NlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVDbGlja0V2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlQ2xpY2tFdmVudChldmVudFR5cGUsIGV2ZW50LCBwb2ludGVyLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBlbXB0eVNlbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIGlmIChlbXB0eVNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gdG1wLm5vZGVzO1xuICAgICAgICBwcm9wZXJ0aWVzLmVkZ2VzID0gdG1wLmVkZ2VzO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllc1tcInByZXZpb3VzU2VsZWN0aW9uXCJdID0gb2xkU2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRUeXBlID09IFwiY2xpY2tcIikge1xuICAgICAgICAvLyBGb3IgdGhlIHRpbWUgYmVpbmcsIHJlc3RyaWN0IHRoaXMgZnVuY3Rpb25hbGl0eSB0b1xuICAgICAgICAvLyBqdXN0IHRoZSBjbGljayBldmVudC5cbiAgICAgICAgcHJvcGVydGllcy5pdGVtcyA9IHRoaXMuZ2V0Q2xpY2tlZEl0ZW1zKHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuY29udHJvbEVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wZXJ0aWVzLmNvbnRyb2xFZGdlID0gZXZlbnQuY29udHJvbEVkZ2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoZXZlbnRUeXBlLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGlnaGxpZ2h0RWRnZXM9dGhpcy5vcHRpb25zLnNlbGVjdENvbm5lY3RlZEVkZ2VzXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0T2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLnNlbGVjdENvbm5lY3RlZEVkZ2VzO1xuXG4gICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0RWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRfc2VsZWN0aW9uQWNjdW07XG5cbiAgICAgICAgICAgIChfdGhpcyRfc2VsZWN0aW9uQWNjdW0gPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvcikuYWRkRWRnZXMuYXBwbHkoX3RoaXMkX3NlbGVjdGlvbkFjY3VtLCBfdG9Db25zdW1hYmxlQXJyYXkob2JqLmVkZ2VzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuYWRkTm9kZXMob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5hZGRFZGdlcyhvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXNlbGVjdE9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21TZWxlY3Rpb24ob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IFtdO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3ZlcmxhcHBpbmdOb2RlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcG9zaXRpb24gb2JqZWN0IGluIGNhbnZhc3NwYWNlIGZyb20gYSBzaW5nbGUgcG9pbnQgaW4gc2NyZWVuc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcG9pbnRlclRvUG9zaXRpb25PYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpIHtcbiAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGNhbnZhc1Bvcy54IC0gMSxcbiAgICAgICAgdG9wOiBjYW52YXNQb3MueSArIDEsXG4gICAgICAgIHJpZ2h0OiBjYW52YXNQb3MueCArIDEsXG4gICAgICAgIGJvdHRvbTogY2FudmFzUG9zLnkgLSAxXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvcCBub2RlIGF0IHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybk5vZGU9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7Tm9kZSB8IHVuZGVmaW5lZH0gbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgLy8gd2UgZmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBuYXZpZ2F0aW9uIGNvbnRyb2xzIGVsZW1lbnRcbiAgICAgIHZhciBwb3NpdGlvbk9iamVjdCA9IHRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IHRoaXMuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvc2l0aW9uT2JqZWN0KTsgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZVxuICAgICAgLy8gb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG5cblxuICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocmV0dXJuTm9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgZWRnZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3QsIHNlbGVjdG9yIGlzIGFyb3VuZCBjZW50ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gb3ZlcmxhcHBpbmdFZGdlcyBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0LCBvdmVybGFwcGluZ0VkZ2VzKSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG5cbiAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0uaXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSkge1xuICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZXMucHVzaChlZGdlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZXMgPSBbXTtcblxuICAgICAgdGhpcy5fZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0LCBvdmVybGFwcGluZ0VkZ2VzKTtcblxuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWRnZXMgbmVhcmVzdCB0byB0aGUgcGFzc2VkIHBvaW50IChsaWtlIGEgY2xpY2spXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5FZGdlPXRydWVdXG4gICAgICogQHJldHVybnMge0VkZ2UgfCB1bmRlZmluZWR9IG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlQXQocG9pbnRlcikge1xuICAgICAgdmFyIHJldHVybkVkZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZWRnZXMsIHBpY2sgY2xvc2VzdCB3aXRoaW4gMTBcbiAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHZhciBtaW5kaXN0ID0gMTA7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlID0gbnVsbDtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkuZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlSW5kaWNlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICAgIHZhciB4RnJvbSA9IGVkZ2UuZnJvbS54O1xuICAgICAgICAgIHZhciB5RnJvbSA9IGVkZ2UuZnJvbS55O1xuICAgICAgICAgIHZhciB4VG8gPSBlZGdlLnRvLng7XG4gICAgICAgICAgdmFyIHlUbyA9IGVkZ2UudG8ueTtcbiAgICAgICAgICB2YXIgZGlzdCA9IGVkZ2UuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgY2FudmFzUG9zLngsIGNhbnZhc1Bvcy55KTtcblxuICAgICAgICAgIGlmIChkaXN0IDwgbWluZGlzdCkge1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlID0gZWRnZUlkO1xuICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGFwcGluZ0VkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJldHVybkVkZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmVkZ2VzW292ZXJsYXBwaW5nRWRnZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIG9iamVjdCB0byB0aGUgc2VsZWN0aW9uIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkVG9Ib3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9Ib3ZlcihvYmopIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHRoaXMuaG92ZXJPYmoubm9kZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc2luZ2xlIG9wdGlvbiBmcm9tIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUZyb21TZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21TZWxlY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMkX3NlbGVjdGlvbkFjY3VtMjtcblxuICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVOb2RlcyhvYmopO1xuXG4gICAgICAgIChfdGhpcyRfc2VsZWN0aW9uQWNjdW0yID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IpLmRlbGV0ZUVkZ2VzLmFwcGx5KF90aGlzJF9zZWxlY3Rpb25BY2N1bTIsIF90b0NvbnN1bWFibGVBcnJheShvYmouZWRnZXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZUVkZ2VzKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0IGFsbCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdEFsbCgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWROb2RlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3Iuc2l6ZU5vZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBlZGdlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkRWRnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkRWRnZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVFZGdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ob3ZlckNvbm5lY3RlZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ob3ZlckNvbm5lY3RlZEVkZ2VzKG5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgIGVkZ2UuaG92ZXIgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2FkZFRvSG92ZXIoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgaGlnaGxpZ2h0IGZyb20gYSBub2RlIG9yIGVkZ2UsIGluIHJlc3BvbnNlIHRvIG1vdXNlIG1vdmVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7Tm9kZXx2aXMuRWRnZX0gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVtaXRCbHVyRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICBpZiAob2JqZWN0LmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIG9iamVjdC5ob3ZlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5ub2RlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyTm9kZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmVkZ2UgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJsdXJFZGdlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgaGlnaGxpZ2h0IGZvciBhIG5vZGUgb3IgZWRnZSwgaW4gcmVzcG9uc2UgdG8gbW91c2UgbW92ZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtOb2RlfHZpcy5FZGdlfSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaG92ZXJDaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVtaXRIb3ZlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRIb3ZlckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgb2JqZWN0LmhvdmVyID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKG9iamVjdCk7XG5cbiAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIHByb3BlcnRpZXMubm9kZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJOb2RlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuZWRnZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJFZGdlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBob3ZlckNoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyBpbiByZXNwb25zZSB0byBhIG1vdXNlIG1vdmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIHwgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaG92ZXJPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaG92ZXJPYmplY3QoZXZlbnQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKTtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG92ZXJDaGFuZ2VkID0gZmFsc2U7IC8vIHJlbW92ZSBhbGwgbm9kZSBob3ZlciBoaWdobGlnaHRzXG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmhvdmVyT2JqLm5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ob3Zlck9iai5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmIG9iamVjdC5pZCAhPSBub2RlSWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgRWRnZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0Qmx1ckV2ZW50KGV2ZW50LCBwb2ludGVyLCB0aGlzLmhvdmVyT2JqLm5vZGVzW25vZGVJZF0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHJlbW92aW5nIGFsbCBlZGdlIGhvdmVyIGhpZ2hsaWdodHNcblxuXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ob3Zlck9iai5lZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmouZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgaG92ZXIgaGFzIGJlZW4gY2hhbmdlZCBoZXJlIGl0IG1lYW5zIHRoYXQgdGhlIG5vZGUgaGFzIGJlZW4gaG92ZXJlZCBvdmVyIG9yIG9mZlxuICAgICAgICAgIC8vIHdlIHRoZW4gZG8gbm90IHVzZSB0aGUgZW1pdEJsdXJFdmVudCBtZXRob2QgaGVyZS5cbiAgICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF0uaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgfSAvLyBpZiB0aGUgYmx1ciByZW1haW5zIHRoZSBzYW1lIGFuZCB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZCAobW91c2Ugb2ZmKSBvciBhbm90aGVyXG4gICAgICAgICAgLy8gZWRnZSBoYXMgYmVlbiBob3ZlcmVkLCBvciBhbm90aGVyIG5vZGUgaGFzIGJlZW4gaG92ZXJlZCB3ZSBibHVyIHRoZSBlZGdlLlxuICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UgJiYgb2JqZWN0LmlkICE9IGVkZ2VJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmICFvYmplY3QuaG92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhvdmVyZWRFZGdlc0NvdW50ID0ga2V5cyQ0KHRoaXMuaG92ZXJPYmouZWRnZXMpLmxlbmd0aDtcblxuICAgICAgICB2YXIgaG92ZXJlZE5vZGVzQ291bnQgPSBrZXlzJDQodGhpcy5ob3Zlck9iai5ub2RlcykubGVuZ3RoO1xuXG4gICAgICAgIHZhciBuZXdPbmx5SG92ZXJlZEVkZ2UgPSBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIGhvdmVyZWRFZGdlc0NvdW50ID09PSAwICYmIGhvdmVyZWROb2Rlc0NvdW50ID09PSAwO1xuICAgICAgICB2YXIgbmV3T25seUhvdmVyZWROb2RlID0gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiBob3ZlcmVkRWRnZXNDb3VudCA9PT0gMCAmJiBob3ZlcmVkTm9kZXNDb3VudCA9PT0gMDtcblxuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkIHx8IG5ld09ubHlIb3ZlcmVkRWRnZSB8fCBuZXdPbmx5SG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0aGlzLmVtaXRIb3ZlckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgdGhpcy5vcHRpb25zLmhvdmVyQ29ubmVjdGVkRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9ob3ZlckNvbm5lY3RlZEVkZ2VzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdmVyQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdCB0aGUgc2VsZWN0aW9uIGNoYW5nZXMgYnV0IGRvbid0IGVtaXQgYW55IGV2ZW50cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFdpdGhvdXRFbWl0dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXRXaXRob3V0RW1pdHRpbmcoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFuZCBkZXNlbGVjdCBub2RlcyBkZXBlbmRpbmcgY3VycmVudCBzZWxlY3Rpb24gY2hhbmdlLlxuICAgICAqXG4gICAgICogRm9yIGNoYW5naW5nIG5vZGVzLCBzZWxlY3QvZGVzZWxlY3QgZXZlbnRzIGFyZSBmaXJlZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IEZvciBhIGdpdmVuIGVkZ2UsIGlmIG9uZSBjb25uZWN0aW5nIG5vZGUgaXMgZGVzZWxlY3RlZCBhbmQgd2l0aCB0aGVcbiAgICAgKiBzYW1lIGNsaWNrIHRoZSBvdGhlciBub2RlIGlzIHNlbGVjdGVkLCBubyBldmVudHMgZm9yIHRoZSBlZGdlIHdpbGwgZmlyZS4gSXRcbiAgICAgKiB3YXMgc2VsZWN0ZWQgYW5kIGl0IHdpbGwgcmVtYWluIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIC0gVGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlXG4gICAgICogY2xpY2ssIHRhcCwgZHJhZ2VuZOKApiB0aGF0IHRyaWdnZXJlZCB0aGlzLlxuICAgICAqIEBwYXJhbSB7VUlFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdEFuZEVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VzID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCk7XG5cbiAgICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IHtcbiAgICAgICAgbm9kZXM6IHNlbGVjdGlvbkNoYW5nZXMubm9kZXMucHJldmlvdXMsXG4gICAgICAgIGVkZ2VzOiBzZWxlY3Rpb25DaGFuZ2VzLmVkZ2VzLnByZXZpb3VzXG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5kZWxldGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkZXNlbGVjdEVkZ2VcIiwgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5ub2Rlcy5kZWxldGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkZXNlbGVjdE5vZGVcIiwgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5ub2Rlcy5hZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwic2VsZWN0Tm9kZVwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMuZWRnZXMuYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdEVkZ2VcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IC8vIGZpcmUgdGhlIHNlbGVjdCBldmVudCBpZiBhbnl0aGluZyBoYXMgYmVlbiBzZWxlY3RlZCBvciBkZXNlbGVjdGVkXG5cblxuICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHNlbGVjdCBvciB1bnNlbGVjdFxuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdFwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBhbmQgZWRnZSBpZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e25vZGVzOiBBcnJheS48c3RyaW5nPiwgZWRnZXM6IEFycmF5LjxzdHJpbmc+fX0gQXJyYXlzIHdpdGggdGhlXG4gICAgICogaWRzIG9mIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IHRoaXMuZ2V0U2VsZWN0ZWROb2RlSWRzKCksXG4gICAgICAgIGVkZ2VzOiB0aGlzLmdldFNlbGVjdGVkRWRnZUlkcygpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldE5vZGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggc2VsZWN0ZWQgZWRnZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkRWRnZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIGlkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZUlkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVJZHMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHJldHVybiBtYXAkMyhfY29udGV4dCA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldE5vZGVzKCkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWRnZSBpZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgZWRnZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZEVkZ2VJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlSWRzKCkge1xuICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0MiA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5pZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzZWxlY3Rpb24ubm9kZXMgJiYgIXNlbGVjdGlvbi5lZGdlcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2VsZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggbm9kZXMgYW5kL29yIGVkZ2VzIHByb3BlcnRpZXNcIik7XG4gICAgICB9IC8vIGZpcnN0IHVuc2VsZWN0IGFueSBzZWxlY3RlZCBub2RlLCBpZiBvcHRpb24gaXMgdHJ1ZSBvciB1bmRlZmluZWRcblxuXG4gICAgICBpZiAob3B0aW9ucy51bnNlbGVjdEFsbCB8fCBvcHRpb25zLnVuc2VsZWN0QWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uLm5vZGVzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHNlbGVjdGlvbi5ub2RlcyksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkXTtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOb2RlIHdpdGggaWQgXCInICsgaWQgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9IC8vIGRvbid0IHNlbGVjdCBlZGdlcyB3aXRoIGl0XG5cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3Qobm9kZSwgb3B0aW9ucy5oaWdobGlnaHRFZGdlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbi5lZGdlcykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoc2VsZWN0aW9uLmVkZ2VzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX2lkID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbX2lkXTtcblxuICAgICAgICAgICAgaWYgKCFlZGdlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFZGdlIHdpdGggaWQgXCInICsgX2lkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChlZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcblxuICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB6ZXJvIG9yIG1vcmUgbm9kZXMgd2l0aCB0aGUgb3B0aW9uIHRvIGhpZ2hsaWdodCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGlnaGxpZ2h0RWRnZXNdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3ROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROb2RlcyhzZWxlY3Rpb24pIHtcbiAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgXCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkc1wiO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oe1xuICAgICAgICBub2Rlczogc2VsZWN0aW9uXG4gICAgICB9LCB7XG4gICAgICAgIGhpZ2hsaWdodEVkZ2VzOiBoaWdobGlnaHRFZGdlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB6ZXJvIG9yIG1vcmUgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0RWRnZXMoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93IFwiU2VsZWN0aW9uIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBpZHNcIjtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgZWRnZXM6IHNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBzZWxlY3Rpb246IHJlbW92ZSBpZHMgb2Ygbm9kZXMgd2hpY2ggbm8gbG9uZ2VyIGV4aXN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGUuaWQpKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlTm9kZXMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZWRnZSBpbiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZS5pZCkpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVFZGdlcyhlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHRoZSB2aXN1YWwgZWxlbWVudHMgY2xpY2tlZCB3aGljaCBhcmUgb24gdGhlIGdpdmVuIHBvaW50LlxuICAgICAqXG4gICAgICogQWxsIGVsZW1lbnRzIGFyZSByZXR1cm5lZDsgdGhpcyBpbmNsdWRlcyBub2RlcywgZWRnZXMgYW5kIHRoZWlyIGxhYmVscy5cbiAgICAgKiBUaGUgb3JkZXIgcmV0dXJuZWQgaXMgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgaS5lLiBlbGVtZW50IDAgb2YgdGhlIHJldHVyblxuICAgICAqIHZhbHVlIGlzIHRoZSB0b3Btb3N0IGl0ZW0gY2xpY2tlZCBvbi5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgY29uc2lzdHMgb2YgYW4gYXJyYXkgb2YgdGhlIGZvbGxvd2luZyBwb3NzaWJsZSBlbGVtZW50czpcbiAgICAgKlxuICAgICAqIC0gYHtub2RlSWQ6bnVtYmVyfWAgICAgICAgICAgICAgLSBub2RlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqIC0gYHtub2RlSWQ6bnVtYmVyLCBsYWJlbElkOjB9YCAgLSBsYWJlbCBvZiBub2RlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqIC0gYHtlZGdlSWQ6bnVtYmVyfWAgICAgICAgICAgICAgLSBlZGdlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqIC0gYHtlZGdlOm51bWJlciwgbGFiZWxJZDowfWAgICAgLSBsYWJlbCBvZiBlZGdlIHdpdGggZ2l2ZW4gaWQgY2xpY2tlZCBvblxuICAgICAqXG4gICAgICogIyMgTk9URVNcbiAgICAgKlxuICAgICAqIC0gQ3VycmVudGx5LCB0aGVyZSBpcyBvbmx5IG9uZSBsYWJlbCBhc3NvY2lhdGVkIHdpdGggYSBub2RlIG9yIGFuIGVkZ2UsXG4gICAgICogICBidXQgdGhpcyBpcyBleHBlY3RlZCB0byBjaGFuZ2Ugc29tZXdoZXJlIGluIHRoZSBmdXR1cmUuXG4gICAgICogLSBTaW5jZSB0aGVyZSBpcyBubyB6LWluZGV4aW5nIHlldCwgaXQgaXMgbm90IHJlYWxseSBwb3NzaWJsZSB0byBzZXQgdGhlIG5vZGVzIGFuZFxuICAgICAqICAgZWRnZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIEZvciB0aGUgdGltZSBiZWluZywgbm9kZXMgY29tZSBmaXJzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvaW50ZXIgIG1vdXNlIHBvc2l0aW9uIGluIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48bm9kZUNsaWNrSXRlbXxub2RlTGFiZWxDbGlja0l0ZW18ZWRnZUNsaWNrSXRlbXxlZGdlTGFiZWxDbGlja0l0ZW0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDbGlja2VkSXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpY2tlZEl0ZW1zKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgdmFyIGl0ZW1zID0gW107IC8vIE5vdGUgcmV2ZXJzZSBvcmRlcjsgd2Ugd2FudCB0aGUgdG9wbW9zdCBjbGlja2VkIGl0ZW1zIHRvIGJlIGZpcnN0IGluIHRoZSBhcnJheVxuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgc2VsZWN0ZWQgbm9kZXMgYXJlIGRpc3JlZ2FyZGVkIGhlcmU7IHRoZXNlIG5vcm1hbGx5IGRpc3BsYXkgb24gdG9wXG5cbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICB2YXIgcmV0ID0gbm9kZS5nZXRJdGVtc09uUG9pbnQocG9pbnQpO1xuICAgICAgICBpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCByZXQpOyAvLyBBcHBlbmQgdGhlIHJldHVybiB2YWx1ZSB0byB0aGUgcnVubmluZyBsaXN0LlxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIF9pID0gZWRnZUluZGljZXMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG5cbiAgICAgICAgdmFyIF9yZXQgPSBlZGdlLmdldEl0ZW1zT25Qb2ludChwb2ludCk7XG5cbiAgICAgICAgaXRlbXMucHVzaC5hcHBseShpdGVtcywgX3JldCk7IC8vIEFwcGVuZCB0aGUgcmV0dXJuIHZhbHVlIHRvIHRoZSBydW5uaW5nIGxpc3QuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0aW9uSGFuZGxlcjtcbn0oKTtcblxudmFyIHRpbXNvcnQkMSA9IHt9O1xuXG4vKioqKlxuICogVGhlIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE1hcmNvIFppY2NhcmRpXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKioqKi9cblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAge1xuICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9XG4gIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgICBleHBvcnRzLnNvcnQgPSBzb3J0O1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG4gICAgdmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG4gICAgdmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuICAgIHZhciBQT1dFUlNfT0ZfVEVOID0gWzFlMCwgMWUxLCAxZTIsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOV07XG5cbiAgICBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgICBpZiAoeCA8IDFlNSkge1xuICAgICAgICBpZiAoeCA8IDFlMikge1xuICAgICAgICAgIHJldHVybiB4IDwgMWUxID8gMCA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IDFlNCkge1xuICAgICAgICAgIHJldHVybiB4IDwgMWUzID8gMiA6IDM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxZTcpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTYgPyA1IDogNjtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxZTkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTggPyA3IDogODtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxwaGFiZXRpY2FsQ29tcGFyZShhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKH5+YSA9PT0gYSAmJiB+fmIgPT09IGIpIHtcbiAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhIDwgMCB8fCBiIDwgMCkge1xuICAgICAgICAgIGlmIChiID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgYiA9IC1iO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsID0gbG9nMTAoYSk7XG4gICAgICAgIHZhciBibCA9IGxvZzEwKGIpO1xuICAgICAgICB2YXIgdCA9IDA7XG5cbiAgICAgICAgaWYgKGFsIDwgYmwpIHtcbiAgICAgICAgICBhICo9IFBPV0VSU19PRl9URU5bYmwgLSBhbCAtIDFdO1xuICAgICAgICAgIGIgLz0gMTA7XG4gICAgICAgICAgdCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGFsID4gYmwpIHtcbiAgICAgICAgICBiICo9IFBPV0VSU19PRl9URU5bYWwgLSBibCAtIDFdO1xuICAgICAgICAgIGEgLz0gMTA7XG4gICAgICAgICAgdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgYVN0ciA9IFN0cmluZyhhKTtcbiAgICAgIHZhciBiU3RyID0gU3RyaW5nKGIpO1xuXG4gICAgICBpZiAoYVN0ciA9PT0gYlN0cikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFTdHIgPCBiU3RyID8gLTEgOiAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICB2YXIgciA9IDA7XG5cbiAgICAgIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgIHIgfD0gbiAmIDE7XG4gICAgICAgIG4gPj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuICsgcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgICAgICBydW5IaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgIGhpLS07XG5cbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICAgICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuICAgICAgICB2YXIgbGVmdCA9IGxvO1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcblxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgfVxuXG4gICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgfVxuXG4gICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgVGltU29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbVNvcnQpO1xuXG4gICAgICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBudWxsO1xuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucnVuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2tTaXplID0gMDtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICB0aGlzLnRtcFN0b3JhZ2VMZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG1wID0gbmV3IEFycmF5KHRoaXMudG1wU3RvcmFnZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhY2tMZW5ndGggPSB0aGlzLmxlbmd0aCA8IDEyMCA/IDUgOiB0aGlzLmxlbmd0aCA8IDE1NDIgPyAxMCA6IHRoaXMubGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcbiAgICAgICAgdGhpcy5ydW5TdGFydCA9IG5ldyBBcnJheSh0aGlzLnN0YWNrTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ydW5MZW5ndGggPSBuZXcgQXJyYXkodGhpcy5zdGFja0xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLnB1c2hSdW4gPSBmdW5jdGlvbiBwdXNoUnVuKHJ1blN0YXJ0LCBydW5MZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ydW5TdGFydFt0aGlzLnN0YWNrU2l6ZV0gPSBydW5TdGFydDtcbiAgICAgICAgdGhpcy5ydW5MZW5ndGhbdGhpcy5zdGFja1NpemVdID0gcnVuTGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSArPSAxO1xuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VSdW5zID0gZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICBpZiAobiA+PSAxICYmIHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8PSB0aGlzLnJ1bkxlbmd0aFtuXSArIHRoaXMucnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgdGhpcy5ydW5MZW5ndGhbbiAtIDJdIDw9IHRoaXMucnVuTGVuZ3RoW25dICsgdGhpcy5ydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ydW5MZW5ndGhbbiAtIDFdIDwgdGhpcy5ydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucnVuTGVuZ3RoW25dID4gdGhpcy5ydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1lcmdlQXQobik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLmZvcmNlTWVyZ2VSdW5zID0gZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgIGlmIChuID4gMCAmJiB0aGlzLnJ1bkxlbmd0aFtuIC0gMV0gPCB0aGlzLnJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1lcmdlQXQobik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlQXQgPSBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciBzdGFydDEgPSB0aGlzLnJ1blN0YXJ0W2ldO1xuICAgICAgICB2YXIgbGVuZ3RoMSA9IHRoaXMucnVuTGVuZ3RoW2ldO1xuICAgICAgICB2YXIgc3RhcnQyID0gdGhpcy5ydW5TdGFydFtpICsgMV07XG4gICAgICAgIHZhciBsZW5ndGgyID0gdGhpcy5ydW5MZW5ndGhbaSArIDFdO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgIGlmIChpID09PSB0aGlzLnN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgICAgICB0aGlzLnJ1blN0YXJ0W2kgKyAxXSA9IHRoaXMucnVuU3RhcnRbaSArIDJdO1xuICAgICAgICAgIHRoaXMucnVuTGVuZ3RoW2kgKyAxXSA9IHRoaXMucnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2tTaXplLS07XG4gICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgIHN0YXJ0MSArPSBrO1xuICAgICAgICBsZW5ndGgxIC09IGs7XG5cbiAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgICAgICB0aGlzLm1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlTG93ID0gZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLnRtcDtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IHRoaXMubWluR2FsbG9wO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgbWluR2FsbG9wKTtcblxuICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcblxuICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AtLTtcbiAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtaW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICBtaW5HYWxsb3AgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1pbkdhbGxvcCArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VIaWdoID0gZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgdG1wID0gdGhpcy50bXA7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluR2FsbG9wID0gdGhpcy5taW5HYWxsb3A7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcC0tO1xuICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWluR2FsbG9wICs9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgIHRoaXMubWluR2FsbG9wID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVGltU29ydDtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuIG9ubHkgc29ydCBhcnJheXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICAgIGNvbXBhcmUgPSBhbHBoYWJldGljYWxDb21wYXJlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoaSA9IGxvO1xuICAgICAgICBsbyA9IGNvbXBhcmU7XG4gICAgICAgIGNvbXBhcmUgPSBhbHBoYWJldGljYWxDb21wYXJlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxvKSB7XG4gICAgICAgIGxvID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoaSkge1xuICAgICAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG4gICAgICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgICAgIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuICB9KTtcbn0pKHRpbXNvcnQkMSk7XG5cbnZhciB0aW1zb3J0ID0gdGltc29ydCQxO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEludGVyZmFjZSBkZWZpbml0aW9uIGZvciBkaXJlY3Rpb24gc3RyYXRlZ3kgY2xhc3Nlcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGRlc2NyaWJlcyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgU3RyYXRlZ3lcbiAqIHBhdHRlcm4gY2xhc3NlcyB1c2VkIHRvIGRpZmZlcmVudGlhdGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAqIGRpcmVjdGlvbiBvZiBoaWVyYXJjaGljYWwgcmVzdWx0cy5cbiAqXG4gKiBGb3IgYSBnaXZlbiBkaXJlY3Rpb24sIG9uZSBjb29yZGluYXRlIHdpbGwgYmUgJ2ZpeGVkJywgbWVhbmluZyB0aGF0IGl0IGlzXG4gKiBkZXRlcm1pbmVkIGJ5IGxldmVsLlxuICogVGhlIG90aGVyIGNvb3JkaW5hdGUgaXMgJ3VuZml4ZWQnLCBtZWFuaW5nIHRoYXQgdGhlIG5vZGVzIG9uIGEgZ2l2ZW4gbGV2ZWxcbiAqIGNhbiBzdGlsbCBtb3ZlIGFsb25nIHRoYXQgY29vcmRpbmF0ZS4gU286XG4gKlxuICogLSBgdmVydGljYWxgIGxheW91dDogYHhgIHVuZml4ZWQsIGB5YCBmaXhlZCBwZXIgbGV2ZWxcbiAqIC0gYGhvcml6b250YWxgIGxheW91dDogYHhgIGZpeGVkIHBlciBsZXZlbCwgYHlgIHVuZml4ZWRcbiAqXG4gKiBUaGUgbG9jYWwgbWV0aG9kcyBhcmUgc3R1YnMgYW5kIHNob3VsZCBiZSByZWdhcmRlZCBhcyBhYnN0cmFjdC5cbiAqIERlcml2ZWQgY2xhc3NlcyAqKm11c3QqKiBpbXBsZW1lbnQgYWxsIHRoZSBtZXRob2RzIHRoZW1zZWx2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRGlyZWN0aW9uSW50ZXJmYWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGlyZWN0aW9uSW50ZXJmYWNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXJlY3Rpb25JbnRlcmZhY2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERpcmVjdGlvbkludGVyZmFjZSwgW3tcbiAgICBrZXk6IFwiYWJzdHJhY3RcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyFcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBkdW1teSBjYWxsIHdoaWNoIGlzIHVzZWQgdG8gc3VwcHJlc3MgdGhlIGpzZG9jIGVycm9ycyBvZiB0eXBlOlxuICAgICAqXG4gICAgICogICBcIidwYXJhbScgaXMgYXNzaWduZWQgYSB2YWx1ZSBidXQgbmV2ZXIgdXNlZFwiXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWtlX3VzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWtlX3VzZSgpIHsvLyBEbyBub3RoaW5nIHNwZWNpYWxcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHlwZSB0byB1c2UgdG8gdHJhbnNsYXRlIGR5bmFtaWMgY3VydmVzIHRvLCBpbiB0aGUgY2FzZSBvZiBoaWVyYXJjaGljYWwgbGF5b3V0LlxuICAgICAqIER5bmFtaWMgY3VydmVzIGRvIG5vdCB3b3JrIGZvciB0aGVzZS5cbiAgICAgKlxuICAgICAqIFRoZSB2YWx1ZSBzaG91bGQgYmUgcGVycGVuZGljdWxhciB0byB0aGUgYWN0dWFsIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gRGlyZWN0aW9uLCBlaXRoZXIgJ3ZlcnRpY2FsJyBvciAnaG9yaXpvbnRhbCdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImN1cnZlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRoYXQgaXMgbm90IGZpeGVkIGZvciB0aGlzIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZWFkXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgb2YgdGhlIHVuZml4ZWQgY29vcmRpbmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdGhhdCBpcyBub3QgZml4ZWQgZm9yIHRoaXMgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWxdIGlmIHNwZWNpZmllZCwgdGhlIGhpZXJhcmNoeSBsZXZlbCB0aGF0IHRoaXMgbm9kZSBzaG91bGQgYmUgZml4ZWQgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgcG9zaXRpb24sIGxldmVsKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3aWR0aCBvZiBhIHRyZWUuXG4gICAgICpcbiAgICAgKiBBIGB0cmVlYCBoZXJlIGlzIGEgc3Vic2V0IG9mIG5vZGVzIHdpdGhpbiB0aGUgbmV0d29yayB3aGljaCBhcmUgbm90IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyxcbiAgICAgKiBvbmx5IGFtb25nIHRoZW1zZWx2ZXMuIEluIGVzc2VuY2UsIGl0IGlzIGEgc3ViLW5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG51bWJlciBvZiBhIHRyZWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgd2lkdGggb2YgYSB0cmVlIGluIHRoZSB2aWV3IGNvb3JkaW5hdGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdGhpcy5mYWtlX3VzZShpbmRleCk7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTb3J0IGFycmF5IG9mIG5vZGVzIG9uIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogTm90ZToqKiBjaHJvbWUgaGFzIG5vbi1zdGFibGUgc29ydGluZyBpbXBsZW1lbnRhdGlvbiwgd2hpY2hcbiAgICAgKiBoYXMgYSB0ZW5kZW5jeSB0byBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBpdGVtcyxcbiAgICAgKiBldmVuIGlmIHRoZSBjdXN0b20gc29ydCBmdW5jdGlvbiByZXR1cm5zIDAuXG4gICAgICpcbiAgICAgKiBGb3IgdGhpcyByZWFzb24sIGFuIGV4dGVybmFsIHNvcnQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCxcbiAgICAgKiB3aGljaCBoYXMgdGhlIGFkZGVkIGJlbmVmaXQgb2YgYmVpbmcgZmFzdGVyIHRoYW4gdGhlIHN0YW5kYXJkXG4gICAgICogcGxhdGZvcm1zIGltcGxlbWVudGF0aW9uLiBUaGlzIGhhcyBiZWVuIHZlcmlmaWVkIG9uIGBub2RlLmpzYCxcbiAgICAgKiBgZmlyZWZveGAgYW5kIGBjaHJvbWVgIChhbGwgbGludXgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVBcnJheSBhcnJheSBvZiBub2RlcyB0byBzb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGVBcnJheSk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbiB0aGUgZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSB0byB0aGUgZ2l2ZW4gbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgVGhlIGxldmVsIHRvIGZpeCB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlLCBsZXZlbCk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvZmZzZXQgdG8gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZUlkfSBub2RlSWQgSWQgb2YgdGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmYgT2Zmc2V0IHRvIGFkZCB0byB0aGUgdW5maXhlZCBjb29yZGluYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZUlkLCBkaWZmKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlyZWN0aW9uSW50ZXJmYWNlO1xufSgpO1xuLyoqXG4gKiBWZXJ0aWNhbCBTdHJhdGVneVxuICpcbiAqIENvb3JkaW5hdGUgYHlgIGlzIGZpeGVkIG9uIGxldmVscywgY29vcmRpbmF0ZSBgeGAgaXMgdW5maXhlZC5cbiAqXG4gKiBAYXVnbWVudHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFZlcnRpY2FsU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXJlY3Rpb25JbnRlcmZhY2UpIHtcbiAgX2luaGVyaXRzKFZlcnRpY2FsU3RyYXRlZ3ksIF9EaXJlY3Rpb25JbnRlcmZhY2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVmVydGljYWxTdHJhdGVneSk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXQgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgTGF5b3V0RW5naW5lIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gVmVydGljYWxTdHJhdGVneShsYXlvdXQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVydGljYWxTdHJhdGVneSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmxheW91dCA9IGxheW91dDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVmVydGljYWxTdHJhdGVneSwgW3tcbiAgICBrZXk6IFwiY3VydmVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS54O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmFkZFRvT3JkZXJpbmcobm9kZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnggPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlcy5taW5feCxcbiAgICAgICAgbWF4OiByZXMubWF4X3hcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgdGltc29ydC5zb3J0KG5vZGVBcnJheSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEueCAtIGIueDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXgobm9kZSwgbGV2ZWwpIHtcbiAgICAgIG5vZGUueSA9IHRoaXMubGF5b3V0Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIGxldmVsO1xuICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KG5vZGVJZCwgZGlmZikge1xuICAgICAgdGhpcy5sYXlvdXQuYm9keS5ub2Rlc1tub2RlSWRdLnggKz0gZGlmZjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmVydGljYWxTdHJhdGVneTtcbn0oRGlyZWN0aW9uSW50ZXJmYWNlKTtcbi8qKlxuICogSG9yaXpvbnRhbCBTdHJhdGVneVxuICpcbiAqIENvb3JkaW5hdGUgYHhgIGlzIGZpeGVkIG9uIGxldmVscywgY29vcmRpbmF0ZSBgeWAgaXMgdW5maXhlZC5cbiAqXG4gKiBAYXVnbWVudHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIEhvcml6b250YWxTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZTIpIHtcbiAgX2luaGVyaXRzKEhvcml6b250YWxTdHJhdGVneSwgX0RpcmVjdGlvbkludGVyZmFjZTIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEhvcml6b250YWxTdHJhdGVneSk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXQgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgTGF5b3V0RW5naW5lIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gSG9yaXpvbnRhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9yaXpvbnRhbFN0cmF0ZWd5KTtcblxuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczIubGF5b3V0ID0gbGF5b3V0O1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSG9yaXpvbnRhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS55O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmFkZFRvT3JkZXJpbmcobm9kZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnkgPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlcy5taW5feSxcbiAgICAgICAgbWF4OiByZXMubWF4X3lcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgdGltc29ydC5zb3J0KG5vZGVBcnJheSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXgobm9kZSwgbGV2ZWwpIHtcbiAgICAgIG5vZGUueCA9IHRoaXMubGF5b3V0Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIGxldmVsO1xuICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KG5vZGVJZCwgZGlmZikge1xuICAgICAgdGhpcy5sYXlvdXQuYm9keS5ub2Rlc1tub2RlSWRdLnkgKz0gZGlmZjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSG9yaXpvbnRhbFN0cmF0ZWd5O1xufShEaXJlY3Rpb25JbnRlcmZhY2UpO1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgJGV2ZXJ5ID0gYXJyYXlJdGVyYXRpb24uZXZlcnk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZXZlcnknKTsgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuXG4kKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhU1RSSUNUX01FVEhPRFxufSwge1xuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgZXZlcnkkMyA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5ldmVyeTtcblxudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCA9IGV2ZXJ5JDM7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBldmVyeSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5ldmVyeTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCBpc1Byb3RvdHlwZU9mKEFycmF5UHJvdG90eXBlLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5ldmVyeSA/IG1ldGhvZCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQgPSBldmVyeSQyO1xudmFyIGV2ZXJ5JDEgPSBwYXJlbnQ7XG5cbnZhciBldmVyeSA9IGV2ZXJ5JDE7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0OTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ5LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qKlxyXG4gKiBUcnkgdG8gYXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBjeWNsaWMg4oCcaGllcmFyY2h54oCdLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHBhcmFtIGxldmVscyAtIElmIHByZXNlbnQgbGV2ZWxzIHdpbGwgYmUgYWRkZWQgdG8gaXQsIGlmIG5vdCBhIG5ldyBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkLlxyXG4gKiBAcmV0dXJucyBQb3B1bGF0ZWQgbm9kZSBsZXZlbHMuXHJcbiAqL1xuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uQ3ljbGljKG5vZGVzLCBsZXZlbHMpIHtcbiAgdmFyIGVkZ2VzID0gbmV3IHNldCgpO1xuXG4gIGZvckVhY2gkMihub2RlcykuY2FsbChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICBmb3JFYWNoJDIoX2NvbnRleHQgPSBub2RlLmVkZ2VzKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkKSB7XG4gICAgICAgIGVkZ2VzLmFkZChlZGdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZm9yRWFjaCQyKGVkZ2VzKS5jYWxsKGVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBmcm9tSWQgPSBlZGdlLmZyb20uaWQ7XG4gICAgdmFyIHRvSWQgPSBlZGdlLnRvLmlkO1xuXG4gICAgaWYgKGxldmVsc1tmcm9tSWRdID09IG51bGwpIHtcbiAgICAgIGxldmVsc1tmcm9tSWRdID0gMDtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzW3RvSWRdID09IG51bGwgfHwgbGV2ZWxzW2Zyb21JZF0gPj0gbGV2ZWxzW3RvSWRdKSB7XG4gICAgICBsZXZlbHNbdG9JZF0gPSBsZXZlbHNbZnJvbUlkXSArIDE7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbGV2ZWxzO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgaGllcmFyY2h5LiBMZWF2ZXMgd2lsbCBiZSBsaW5lZCB1cCBhdCB0aGUgYm90dG9tIGFuZCBhbGwgb3RoZXIgbm9kZXMgYXMgY2xvc2UgdG8gdGhlaXIgY2hpbGRyZW4gYXMgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcmV0dXJucyBQb3B1bGF0ZWQgbm9kZSBsZXZlbHMuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvbkxlYXZlcyhub2Rlcykge1xuICByZXR1cm4gZmlsbExldmVsc0J5RGlyZWN0aW9uKCAvLyBQaWNrIG9ubHkgbGVhdmVzIChub2RlcyB3aXRob3V0IGNoaWxkcmVuKS5cbiAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX2NvbnRleHQyLCBfY29udGV4dDM7XG5cbiAgICByZXR1cm4gZXZlcnkoX2NvbnRleHQyID0gZmlsdGVyKF9jb250ZXh0MyA9IG5vZGUuZWRnZXMgLy8gVGFrZSBvbmx5IHZpc2libGUgbm9kZXMgaW50byBhY2NvdW50LlxuICAgICkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaGFzKGVkZ2UudG9JZCk7XG4gICAgfSkgLy8gQ2hlY2sgdGhhdCBhbGwgZWRnZXMgbGVhZCB0byB0aGlzIG5vZGUgKGxlYWYpLlxuICAgICkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS50byA9PT0gbm9kZTtcbiAgICB9KTtcbiAgfSwgLy8gVXNlIHRoZSBsb3dlc3QgbGV2ZWwuXG4gIGZ1bmN0aW9uIChuZXdMZXZlbCwgb2xkTGV2ZWwpIHtcbiAgICByZXR1cm4gb2xkTGV2ZWwgPiBuZXdMZXZlbDtcbiAgfSwgLy8gR28gYWdhaW5zdCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcy5cbiAgXCJmcm9tXCIsIG5vZGVzKTtcbn1cbi8qKlxyXG4gKiBBc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGhpZXJhcmNoeS4gUm9vdHMgd2lsbCBiZSBsaW5lZCB1cCBhdCB0aGUgdG9wIGFuZCBhbGwgbm9kZXMgYXMgY2xvc2UgdG8gdGhlaXIgcGFyZW50cyBhcyBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvblJvb3RzKG5vZGVzKSB7XG4gIHJldHVybiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb24oIC8vIFBpY2sgb25seSByb290cyAobm9kZXMgd2l0aG91dCBwYXJlbnRzKS5cbiAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDU7XG5cbiAgICByZXR1cm4gZXZlcnkoX2NvbnRleHQ0ID0gZmlsdGVyKF9jb250ZXh0NSA9IG5vZGUuZWRnZXMgLy8gVGFrZSBvbmx5IHZpc2libGUgbm9kZXMgaW50byBhY2NvdW50LlxuICAgICkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaGFzKGVkZ2UudG9JZCk7XG4gICAgfSkgLy8gQ2hlY2sgdGhhdCBhbGwgZWRnZXMgbGVhZCBmcm9tIHRoaXMgbm9kZSAocm9vdCkuXG4gICAgKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmZyb20gPT09IG5vZGU7XG4gICAgfSk7XG4gIH0sIC8vIFVzZSB0aGUgaGlnaGVzdCBsZXZlbC5cbiAgZnVuY3Rpb24gKG5ld0xldmVsLCBvbGRMZXZlbCkge1xuICAgIHJldHVybiBvbGRMZXZlbCA8IG5ld0xldmVsO1xuICB9LCAvLyBHbyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcy5cbiAgXCJ0b1wiLCBub2Rlcyk7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpc0VudHJ5Tm9kZSAtIENoZWNrcyBhbmQgcmV0dXJuIHRydWUgaWYgdGhlIGdyYXBoIHNob3VsZCBiZSB0cmF2ZXJzZWQgZnJvbSB0aGlzIG5vZGUuXHJcbiAqIEBwYXJhbSBzaG91bGRMZXZlbEJlUmVwbGFjZWQgLSBDaGVja3MgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGV2ZWwgb2YgZ2l2ZW4gbm9kZSBzaG91bGQgYmUgdXBkYXRlZCB0byB0aGUgbmV3IHZhbHVlLlxyXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gV2hldGVyIHRoZSBncmFwaCBzaG91bGQgYmUgdHJhdmVyc2VkIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzIGBcInRvXCJgIG9yIGluIHRoZSBvdGhlciB3YXkgYFwiZnJvbVwiYC5cclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvbihpc0VudHJ5Tm9kZSwgc2hvdWxkTGV2ZWxCZVJlcGxhY2VkLCBkaXJlY3Rpb24sIG5vZGVzKSB7XG4gIHZhciBfY29udGV4dDY7XG5cbiAgdmFyIGxldmVscyA9IGNyZWF0ZSQ1KG51bGwpOyAvLyBJZiBhY3ljbGljLCB0aGUgZ3JhcGggY2FuIGJlIHdhbGtlZCB0aHJvdWdoIHdpdGggKG1vc3QgbGlrZWx5IHdheSkgZmV3ZXJcbiAgLy8gc3RlcHMgdGhhbiB0aGUgbnVtYmVyIGJlbGxvdy4gVGhlIGV4YWN0IHZhbHVlIGlzbid0IHRvbyBpbXBvcnRhbnQgYXMgbG9uZ1xuICAvLyBhcyBpdCdzIHF1aWNrIHRvIGNvbXB1dGUgKGRvZXNuJ3QgaW1wYWN0IGFjeWNsaWMgZ3JhcGhzIHRvbyBtdWNoKSwgaXNcbiAgLy8gaGlnaGVyIHRoYW4gdGhlIG51bWJlciBvZiBzdGVwcyBhY3R1YWxseSBuZWVkZWQgKGRvZXNuJ3QgY3V0IG9mZiBiZWZvcmVcbiAgLy8gYWN5Y2xpYyBncmFwaCBpcyB3YWxrZWQgdGhyb3VnaCkgYW5kIHByZXZlbnRzIGluZmluaXRlIGxvb3BzIChjdXRzIG9mZiBmb3JcbiAgLy8gY3ljbGljIGdyYXBocykuXG5cblxuICB2YXIgbGltaXQgPSByZWR1Y2UoX2NvbnRleHQ2ID0gX3RvQ29uc3VtYWJsZUFycmF5KHZhbHVlcyhub2RlcykuY2FsbChub2RlcykpKS5jYWxsKF9jb250ZXh0NiwgZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgIHJldHVybiBhY2MgKyAxICsgbm9kZS5lZGdlcy5sZW5ndGg7XG4gIH0sIDApO1xuXG4gIHZhciBlZGdlSWRQcm9wID0gZGlyZWN0aW9uICsgXCJJZFwiO1xuICB2YXIgbmV3TGV2ZWxEaWZmID0gZGlyZWN0aW9uID09PSBcInRvXCIgPyAxIDogLTE7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobm9kZXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICBlbnRyeU5vZGVJZCA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIGVudHJ5Tm9kZSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICBpZiAoIC8vIFNraXAgaWYgdGhlIG5vZGUgaXMgbm90IHZpc2libGUuXG4gICAgICAhbm9kZXMuaGFzKGVudHJ5Tm9kZUlkKSB8fCAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCBhbiBlbnRyeSBub2RlLlxuICAgICAgIWlzRW50cnlOb2RlKGVudHJ5Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgIH0gLy8gTGluZSB1cCBhbGwgdGhlIGVudHJ5IG5vZGVzIG9uIGxldmVsIDAuXG5cblxuICAgICAgbGV2ZWxzW2VudHJ5Tm9kZUlkXSA9IDA7XG4gICAgICB2YXIgc3RhY2sgPSBbZW50cnlOb2RlXTtcbiAgICAgIHZhciBkb25lID0gMDtcbiAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuXG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgICB2YXIgX2NvbnRleHQ3LCBfY29udGV4dDg7XG5cbiAgICAgICAgaWYgKCFub2Rlcy5oYXMoZW50cnlOb2RlSWQpKSB7XG4gICAgICAgICAgLy8gU2tpcCBpZiB0aGUgbm9kZSBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0xldmVsID0gbGV2ZWxzW25vZGUuaWRdICsgbmV3TGV2ZWxEaWZmO1xuXG4gICAgICAgIGZvckVhY2gkMihfY29udGV4dDcgPSBmaWx0ZXIoX2NvbnRleHQ4ID0gbm9kZS5lZGdlcykuY2FsbChfY29udGV4dDgsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuICgvLyBJZ25vcmUgZGlzY29ubmVjdGVkIGVkZ2VzLlxuICAgICAgICAgICAgZWRnZS5jb25uZWN0ZWQgJiYgLy8gSWdub3JlIGNpcmN1bGFyIGVkZ2VzLlxuICAgICAgICAgICAgZWRnZS50byAhPT0gZWRnZS5mcm9tICYmIC8vIElnbm9yZSBlZGdlcyBsZWFkaW5nIHRvIHRoZSBub2RlIHRoYXQncyBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgZWRnZVtkaXJlY3Rpb25dICE9PSBub2RlICYmIC8vIElnbm9yZSBlZGdlcyBjb25uZWN0aW5nIHRvIGFuIGludmlzaWJsZSBub2RlLlxuICAgICAgICAgICAgbm9kZXMuaGFzKGVkZ2UudG9JZCkgJiYgLy8gSWdub3JlIGVkZ2VzIGNvbm5lY3RpbmcgZnJvbSBhbiBpbnZpc2libGUgbm9kZS5cbiAgICAgICAgICAgIG5vZGVzLmhhcyhlZGdlLmZyb21JZClcbiAgICAgICAgICApO1xuICAgICAgICB9KSkuY2FsbChfY29udGV4dDcsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgdmFyIHRhcmdldE5vZGVJZCA9IGVkZ2VbZWRnZUlkUHJvcF07XG4gICAgICAgICAgdmFyIG9sZExldmVsID0gbGV2ZWxzW3RhcmdldE5vZGVJZF07XG5cbiAgICAgICAgICBpZiAob2xkTGV2ZWwgPT0gbnVsbCB8fCBzaG91bGRMZXZlbEJlUmVwbGFjZWQobmV3TGV2ZWwsIG9sZExldmVsKSkge1xuICAgICAgICAgICAgbGV2ZWxzW3RhcmdldE5vZGVJZF0gPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZWRnZVtkaXJlY3Rpb25dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb25lID4gbGltaXQpIHtcbiAgICAgICAgICAvLyBUaGlzIHdvdWxkIHJ1biBmb3JldmVyIG9uIGEgY3ljbGljIGdyYXBoLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiB7XG4gICAgICAgICAgICAgIHY6IGZpbGxMZXZlbHNCeURpcmVjdGlvbkN5Y2xpYyhub2RlcywgbGV2ZWxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKytkb25lO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAobm9kZSA9IHN0YWNrLnBvcCgpKSB7XG4gICAgICAgIHZhciBfcmV0MiA9IF9sb29wMigpO1xuXG4gICAgICAgIGlmIChfcmV0MiA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgaWYgKF90eXBlb2YoX3JldDIpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICBpZiAoX3R5cGVvZihfcmV0KSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiBsZXZlbHM7XG59XG5cbi8qKlxuICogVGhlcmUncyBhIG1peC11cCB3aXRoIHRlcm1zIGluIHRoZSBjb2RlLiBGb2xsb3dpbmcgYXJlIHRoZSBmb3JtYWwgZGVmaW5pdGlvbnM6XG4gKlxuICogICB0cmVlICAgLSBhIHN0cmljdCBoaWVyYXJjaGljYWwgbmV0d29yaywgaS5lLiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnRcbiAqICAgZm9yZXN0IC0gYSBjb2xsZWN0aW9uIG9mIHRyZWVzLiBUaGVzZSBkaXN0aW5jdCB0cmVlcyBhcmUgdGh1cyBub3QgY29ubmVjdGVkLlxuICpcbiAqIFNvOlxuICogLSBpbiBhIG5ldHdvcmsgdGhhdCBpcyBub3QgYSB0cmVlLCB0aGVyZSBleGlzdCBub2RlcyB3aXRoIG11bHRpcGxlIHBhcmVudHMuXG4gKiAtIGEgbmV0d29yayBjb25zaXN0aW5nIG9mIHVuY29ubmVjdGVkIHN1Yi1uZXR3b3Jrcywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lXG4gKiAgIGlzIG5vdCBhIHRyZWUsIGlzIG5vdCBhIGZvcmVzdC5cbiAqXG4gKiBJbiB0aGUgY29kZSwgdGhlIGRlZmluaXRpb25zIGFyZTpcbiAqXG4gKiAgIHRyZWUgICAtIGFueSBkaXNjb25uZWN0ZWQgc3ViLW5ldHdvcmssIHN0cmljdCBoaWVyYXJjaGljYWwgb3Igbm90LlxuICogICBmb3Jlc3QgLSBhIGJ1bmNoIG9mIHRoZXNlIHN1Yi1uZXR3b3Jrc1xuICpcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHJlZSBhbmQgbm90LXRyZWUgaXMgaW1wb3J0YW50IGluIHRoZSBjb2RlLCBub3RhYmx5IHdpdGhpblxuICogdG8gdGhlIGJsb2NrLXNoaWZ0aW5nIGFsZ29yaXRobS4gVGhlIGFsZ29yaXRobSBhc3N1bWVzIGZvcm1hbCB0cmVlcyBhbmQgZmFpbHNcbiAqIGZvciBub3QtdHJlZXMsIG9mdGVuIGluIGEgc3BlY3RhY3VsYXIgbWFubmVyIChzZWFyY2ggZm9yICdleHBsb2RpbmcgbmV0d29yaycgaW4gdGhlIGlzc3VlcykuXG4gKlxuICogSW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggdGhlIGRlZmluaXRpb25zIGluIHRoZSBmb2xsb3dpbmcgY29kZSwgdGhlIGFkamVjdGl2ZSAnZm9ybWFsJyBpc1xuICogdXNlZC4gSWYgJ2Zvcm1hbCcgaXMgYWJzZW50LCB5b3UgbXVzdCBhc3N1bWUgdGhlIG5vbi1mb3JtYWwgZGVmaW5pdGlvbi5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBOT1RFU1xuICogPT09PT1cbiAqXG4gKiBBIGhpZXJhcmNoaWNhbCBsYXlvdXQgaXMgYSBkaWZmZXJlbnQgdGhpbmcgZnJvbSBhIGhpZXJhcmNoaWNhbCBuZXR3b3JrLlxuICogVGhlIGxheW91dCBpcyBhIHdheSB0byBhcnJhbmdlIHRoZSBub2RlcyBpbiB0aGUgdmlldzsgdGhpcyBjYW4gYmUgZG9uZVxuICogb24gbm9uLWhpZXJhcmNoaWNhbCBuZXR3b3JrcyBhcyB3ZWxsLiBUaGUgY29udmVyc2UgaXMgYWxzbyBwb3NzaWJsZS5cbiAqL1xuLyoqXG4gKiBDb250YWluZXIgZm9yIGRlcml2ZWQgZGF0YSBvbiBjdXJyZW50IG5ldHdvcmssIHJlbGF0aW5nIHRvIGhpZXJhcmNoeS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBIaWVyYXJjaGljYWxTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsU3RhdHVzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTdGF0dXMpO1xuXG4gICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZSA9IHt9OyAvLyBjaGlsZCBpZCdzIHBlciBub2RlIGlkXG5cbiAgICB0aGlzLnBhcmVudFJlZmVyZW5jZSA9IHt9OyAvLyBwYXJlbnQgaWQncyBwZXIgbm9kZSBpZFxuXG4gICAgdGhpcy50cmVlcyA9IHt9OyAvLyB0cmVlIGlkIHBlciBub2RlIGlkOyBpLmUuIHRvIHdoaWNoIHRyZWUgZG9lcyBnaXZlbiBub2RlIGlkIGJlbG9uZ1xuXG4gICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyA9IHt9OyAvLyBUaGUgbm9kZXMgcGVyIGxldmVsLCBpbiB0aGUgZGlzcGxheSBvcmRlclxuXG4gICAgdGhpcy5sZXZlbHMgPSB7fTsgLy8gaGllcmFyY2h5IGxldmVsIHBlciBub2RlIGlkXG5cbiAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4ID0ge307IC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGV2ZWwgc29ydGluZyBvcmRlciwgcGVyIG5vZGUgaWQuXG5cbiAgICB0aGlzLmlzVHJlZSA9IGZhbHNlOyAvLyBUcnVlIGlmIGN1cnJlbnQgbmV0d29yayBpcyBhIGZvcm1hbCB0cmVlXG5cbiAgICB0aGlzLnRyZWVJbmRleCA9IC0xOyAvLyBIaWdoZXN0IHRyZWUgaWQgaW4gY3VycmVudCBuZXR3b3JrLlxuICB9XG4gIC8qKlxuICAgKiBBZGQgdGhlIHJlbGF0aW9uIGJldHdlZW4gZ2l2ZW4gbm9kZXMgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50Tm9kZUlkXG4gICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGROb2RlSWRcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsU3RhdHVzLCBbe1xuICAgIGtleTogXCJhZGRSZWxhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGlvbihwYXJlbnROb2RlSWQsIGNoaWxkTm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXS5wdXNoKGNoaWxkTm9kZUlkKTtcblxuICAgICAgaWYgKHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0ucHVzaChwYXJlbnROb2RlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBmb3IgYSBmb3JtYWwgdHJlZSBvciBmb3JtYWwgZm9yZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgY2FzZSBpZiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBQcmU6IHBhcmVudFJlZmVyZW5jZSBpbml0J2VkIHByb3Blcmx5IGZvciBjdXJyZW50IG5ldHdvcmtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrSWZUcmVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrSWZUcmVlKCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnBhcmVudFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRSZWZlcmVuY2VbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuaXNUcmVlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNUcmVlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VwYXJhdGUgdHJlZXMgaW4gdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJudW1UcmVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1UcmVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyZWVJbmRleCArIDE7IC8vIFRoaXMgYXNzdW1lcyB0aGUgaW5kZXhlcyBhcmUgYXNzaWduZWQgY29uc2VjaXRpdmVseVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSB0cmVlIGlkIHRvIGEgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0cmVlSWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRyZWVJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmVlSW5kZXgobm9kZSwgdHJlZUlkKSB7XG4gICAgICBpZiAodHJlZUlkID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gRG9uJ3QgYm90aGVyXG5cbiAgICAgIGlmICh0aGlzLnRyZWVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy50cmVlc1tub2RlLmlkXSA9IHRyZWVJZDtcbiAgICAgICAgdGhpcy50cmVlSW5kZXggPSBNYXRoLm1heCh0cmVlSWQsIHRoaXMudHJlZUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIGxldmVsIGZvciBnaXZlbiBpZCBpcyBkZWZpbmVkLlxuICAgICAqXG4gICAgICogU2V0cyBsZXZlbCB0byB6ZXJvIGZvciBnaXZlbiBub2RlIGlkIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnN1cmVMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVMZXZlbChub2RlSWQpIHtcbiAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUlkXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbWF4aW11bSBsZXZlbCBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIFRPRE86IE5ldmVyIGVudGVyZWQ7IGZpbmQgYSB0ZXN0IGNhc2UgdG8gdGVzdCB0aGlzIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4TGV2ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4TGV2ZWwobm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYWNjdW11bGF0b3IgPSB7fTtcblxuICAgICAgdmFyIF9nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIF9nZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgICAgaWYgKGFjY3VtdWxhdG9yW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcltub2RlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxldmVsID0gX3RoaXMubGV2ZWxzW25vZGVJZF07XG5cbiAgICAgICAgaWYgKF90aGlzLmNoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF0pIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBNYXRoLm1heChsZXZlbCwgX2dldE1heExldmVsKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjdW11bGF0b3Jbbm9kZUlkXSA9IGxldmVsO1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX2dldE1heExldmVsKG5vZGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlQVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZUJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxldmVsRG93bnN0cmVhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVBLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUEuaWRdID0gMDtcbiAgICAgICAgfSAvLyBzZXQgbGV2ZWxcblxuXG4gICAgICAgIHRoaXMubGV2ZWxzW25vZGVCLmlkXSA9IHRoaXMubGV2ZWxzW25vZGVBLmlkXSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNtYWxsIHV0aWwgbWV0aG9kIHRvIHNldCB0aGUgbWluaW11bSBsZXZlbHMgb2YgdGhlIG5vZGVzIHRvIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE1pbkxldmVsVG9aZXJvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1pbkxldmVsVG9aZXJvKG5vZGVzKSB7XG4gICAgICB2YXIgbWluTGV2ZWwgPSAxZTk7IC8vIGdldCB0aGUgbWluaW11bSBsZXZlbFxuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1pbkxldmVsID0gTWF0aC5taW4odGhpcy5sZXZlbHNbbm9kZUlkXSwgbWluTGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBzdWJ0cmFjdCB0aGUgbWluaW11bSBmcm9tIHRoZSBzZXQgc28gd2UgaGF2ZSBhIHJhbmdlIHN0YXJ0aW5nIGZyb20gMFxuXG5cbiAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgX25vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5sZXZlbHNbX25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sZXZlbHNbX25vZGVJZF0gLT0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWluIGFuZCBtYXggeHktY29vcmRpbmF0ZXMgb2YgYSBnaXZlbiB0cmVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e21pbl94OiBudW1iZXIsIG1heF94OiBudW1iZXIsIG1pbl95OiBudW1iZXIsIG1heF95OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUobm9kZXMsIGluZGV4KSB7XG4gICAgICB2YXIgbWluX3ggPSAxZTk7XG4gICAgICB2YXIgbWF4X3ggPSAtMWU5O1xuICAgICAgdmFyIG1pbl95ID0gMWU5O1xuICAgICAgdmFyIG1heF95ID0gLTFlOTtcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMudHJlZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRyZWVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obm9kZS54LCBtaW5feCk7XG4gICAgICAgICAgICBtYXhfeCA9IE1hdGgubWF4KG5vZGUueCwgbWF4X3gpO1xuICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbihub2RlLnksIG1pbl95KTtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobm9kZS55LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbl94OiBtaW5feCxcbiAgICAgICAgbWF4X3g6IG1heF94LFxuICAgICAgICBtaW5feTogbWluX3ksXG4gICAgICAgIG1heF95OiBtYXhfeVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50KHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0d28gbm9kZXMgaGF2ZSBhIHNhbWUgYW5jZXN0b3Igbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNTYW1lUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1NhbWVQYXJlbnQobm9kZTEsIG5vZGUyKSB7XG4gICAgICB2YXIgcGFyZW50czEgPSB0aGlzLnBhcmVudFJlZmVyZW5jZVtub2RlMS5pZF07XG4gICAgICB2YXIgcGFyZW50czIgPSB0aGlzLnBhcmVudFJlZmVyZW5jZVtub2RlMi5pZF07XG5cbiAgICAgIGlmIChwYXJlbnRzMSA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudHMyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGFyZW50czFbaV0gPT0gcGFyZW50czJbal0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgaW4gdGhlIHNhbWUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBpcyBzbywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpblNhbWVTdWJOZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluU2FtZVN1Yk5ldHdvcmsobm9kZTEsIG5vZGUyKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlc1tub2RlMS5pZF0gPT09IHRoaXMudHJlZXNbbm9kZTIuaWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHRoZSBkaXN0aW5jdCBsZXZlbHMgaW4gdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGV2ZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExldmVscygpIHtcbiAgICAgIHJldHVybiBrZXlzJDQodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgdG8gdGhlIG9yZGVyaW5nIHBlciBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb09yZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvT3JkZXJpbmcobm9kZSwgbGV2ZWwpIHtcbiAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuXG4gICAgICBmb3IgKHZhciBuIGluIGN1ckxldmVsKSB7XG4gICAgICAgIC8vaWYgKGN1ckxldmVsW25dLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgIGlmIChjdXJMZXZlbFtuXSA9PT0gbm9kZSkge1xuICAgICAgICAgIGlzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1ByZXNlbnQpIHtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb25JbmRleFtub2RlLmlkXSA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFN0YXR1cztcbn0oKTtcbi8qKlxuICogVGhlIExheW91dCBFbmdpbmVcbiAqL1xuXG5cbnZhciBMYXlvdXRFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIExheW91dEVuZ2luZShib2R5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheW91dEVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5OyAvLyBNYWtlIHN1cmUgdGhlcmUgYWx3YXlzIGlzIHNvbWUgUk5HIGJlY2F1c2UgdGhlIHNldE9wdGlvbnMgbWV0aG9kIHdvbid0XG4gICAgLy8gc2V0IGl0IHVubGVzcyB0aGVyZSdzIGEgc2VlZCBmb3IgaXQuXG5cbiAgICB0aGlzLl9yZXNldFJORyhNYXRoLnJhbmRvbSgpICsgXCI6XCIgKyBub3ckMSgpKTtcblxuICAgIHRoaXMuc2V0UGh5c2ljcyA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMub3B0aW9uc0JhY2t1cCA9IHtcbiAgICAgIHBoeXNpY3M6IHt9XG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcmFuZG9tU2VlZDogdW5kZWZpbmVkLFxuICAgICAgaW1wcm92ZWRMYXlvdXQ6IHRydWUsXG4gICAgICBjbHVzdGVyVGhyZXNob2xkOiAxNTAsXG4gICAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGxldmVsU2VwYXJhdGlvbjogMTUwLFxuICAgICAgICBub2RlU3BhY2luZzogMTAwLFxuICAgICAgICB0cmVlU3BhY2luZzogMjAwLFxuICAgICAgICBibG9ja1NoaWZ0aW5nOiB0cnVlLFxuICAgICAgICBlZGdlTWluaW1pemF0aW9uOiB0cnVlLFxuICAgICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aW9uOiBcIlVEXCIsXG4gICAgICAgIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICAgIHNvcnRNZXRob2Q6IFwiaHVic2l6ZVwiIC8vIGh1YnNpemUsIGRpcmVjdGVkXG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhMYXlvdXRFbmdpbmUsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUxvYWRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5sYXlvdXROZXR3b3JrKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcblxuXG4gICAgICAgIHZhciB0eXBlID0gX3RoaXMyLmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTsgLy8gZm9yY2UgYWxsIGVkZ2VzIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG5cblxuICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLCB0eXBlLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBoaWVyYXJjaGljYWwgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsO1xuICAgICAgICB2YXIgcHJldkhpZXJhcmNoaWNhbFN0YXRlID0gaGllcmFyY2hpY2FsLmVuYWJsZWQ7XG4gICAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoW1wicmFuZG9tU2VlZFwiLCBcImltcHJvdmVkTGF5b3V0XCIsIFwiY2x1c3RlclRocmVzaG9sZFwiXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgXCJoaWVyYXJjaGljYWxcIik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9tU2VlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fcmVzZXRSTkcob3B0aW9ucy5yYW5kb21TZWVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIG92ZXJyaWRkZW4gb3B0aW9ucyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSAvLyBtYWtlIHN1cmUgdGhlIGxldmVsIHNlcGFyYXRpb24gaXMgdGhlIHJpZ2h0IHdheSB1cFxuXG5cbiAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJSTFwiIHx8IGhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiRFVcIikge1xuICAgICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgIGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICBoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uU3RyYXRlZ3koKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0XCIpOyAvLyBiZWNhdXNlIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIG5lZWRzIGl0J3Mgb3duIHBoeXNpY3MgYW5kIHNtb290aCBjdXJ2ZSBzZXR0aW5ncyxcbiAgICAgICAgICAvLyB3ZSBhZGFwdCB0aGUgb3RoZXIgb3B0aW9ucyBpZiBuZWVkZWQuXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5hZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoYWxsT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgb3ZlcnJpZGRlbiBvcHRpb25zIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVmcmVzaFwiKTtcbiAgICAgICAgICAgIHJldHVybiBkZWVwRXh0ZW5kKGFsbE9wdGlvbnMsIHRoaXMub3B0aW9uc0JhY2t1cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igd2l0aCBnaXZlbiBzZWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IHNlZWQgLSBUaGUgc2VlZCB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRoZSB0aGUgUk5HLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0Uk5HXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldFJORyhzZWVkKSB7XG4gICAgICB0aGlzLmluaXRpYWxSYW5kb21TZWVkID0gc2VlZDtcbiAgICAgIHRoaXMuX3JuZyA9IEFsZWEodGhpcy5pbml0aWFsUmFuZG9tU2VlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBiYWNrdXBQaHlzaWNzID0gdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3M7IC8vIHNldCB0aGUgcGh5c2ljc1xuXG4gICAgICAgIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgPT09IHVuZGVmaW5lZCB8fCBhbGxPcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3MgPSB7XG4gICAgICAgICAgICBlbmFibGVkOiBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBiYWNrdXBQaHlzaWNzLmVuYWJsZWQsXG4gICAgICAgICAgICBzb2x2ZXI6IFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9IGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGJhY2t1cFBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGJhY2t1cFBoeXNpY3Muc29sdmVyIHx8IFwiYmFybmVzSHV0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhbGxPcHRpb25zLnBoeXNpY3MpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgXCJiYXJuZXNIdXRcIjtcbiAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyID0gXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIjtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5zb2x2ZXIgPSBcImJhcm5lc0h1dFwiO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgIHNvbHZlcjogXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIlxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gZ2V0IHRoZSB0eXBlIG9mIHN0YXRpYyBzbW9vdGggY3VydmUgaW4gY2FzZSBpdCBpcyByZXF1aXJlZFxuXG5cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTsgLy8gZGlzYWJsZSBzbW9vdGggY3VydmVzIGlmIG5vdGhpbmcgaXMgZGVmaW5lZC4gSWYgc21vb3RoIGN1cnZlcyBoYXZlIGJlZW4gdHVybmVkIG9uLFxuICAgICAgICAvLyB0dXJuIHRoZW0gaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cblxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5lZGdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwiZHluYW1pY1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc21vb3RoID0gYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGg7IC8vIGFsbG93IGN1c3RvbSB0eXBlcyBleGNlcHQgZm9yIGR5bmFtaWNcblxuICAgICAgICAgICAgaWYgKHNtb290aC50eXBlICE9PSB1bmRlZmluZWQgJiYgc21vb3RoLnR5cGUgIT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBzbW9vdGgudHlwZTtcbiAgICAgICAgICAgIH0gLy8gVE9ETzogdGhpcyBpcyBvcHRpb25zIG1lcmdpbmc7IHNlZSBpZiB0aGUgc3RhbmRhcmQgcm91dGluZXMgY2FuIGJlIHVzZWQgaGVyZS5cblxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogc21vb3RoLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiZHluYW1pY1wiIDogc21vb3RoLnR5cGUsXG4gICAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07IC8vIE5PVEU6IENvcHlpbmcgYW4gb2JqZWN0IHRvIHNlbGY7IHRoaXMgaXMgYmFzaWNhbGx5IHNldHRpbmcgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCB2YXJpYWJsZXNcblxuICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHJvdW5kbmVzczogc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogc21vb3RoLnJvdW5kbmVzcyxcbiAgICAgICAgICAgICAgZm9yY2VEaXJlY3Rpb246IHNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBzbW9vdGguZm9yY2VEaXJlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICAvLyBPbmx5IGFwcGxpZXMgdG8gZWRnZXMgdGhhdCBkbyBub3QgdXNlIHRoZSBnbG9iYWwgb3B0aW9ucyBmb3Igc21vb3RoLlxuXG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25Jbml0aWFsbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25Jbml0aWFsbHkobm9kZXNBcnJheSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZXNldFJORyh0aGlzLmluaXRpYWxSYW5kb21TZWVkKTtcblxuICAgICAgICB2YXIgcmFkaXVzID0gbm9kZXNBcnJheS5sZW5ndGggKyA1MDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG5cbiAgICAgICAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5QSSAqIHRoaXMuX3JuZygpO1xuXG4gICAgICAgICAgaWYgKG5vZGUueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGUueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBLYW1hZGEgS2F3YWkgdG8gcG9zaXRpb24gbm9kZXMuIFRoaXMgaXMgcXVpdGUgYSBoZWF2eSBhbGdvcml0aG0gc28gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzIHdlXG4gICAgICogY2x1c3RlciB0aGVtIGZpcnN0IHRvIHJlZHVjZSB0aGUgYW1vdW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGF5b3V0TmV0d29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXROZXR3b3JrKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaW1wcm92ZWRMYXlvdXQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7IC8vIGZpcnN0IGNoZWNrIGlmIHdlIHNob3VsZCBLYW1hZGEgS2F3YWkgdG8gbGF5b3V0LiBUaGUgdGhyZXNob2xkIGlzIGlmIGxlc3MgdGhhbiBoYWxmIG9mIHRoZSB2aXNpYmxlXG4gICAgICAgIC8vIG5vZGVzIGhhdmUgcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2UgdXNlIHRoaXMuXG5cbiAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tpXV07XG5cbiAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRGVmaW5lZCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24gd2UgY29udGludWVcblxuXG4gICAgICAgIGlmIChwb3NpdGlvbkRlZmluZWQgPCAwLjUgKiBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBNQVhfTEVWRUxTID0gMTA7XG4gICAgICAgICAgdmFyIGxldmVsID0gMDtcbiAgICAgICAgICB2YXIgY2x1c3RlclRocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5jbHVzdGVyVGhyZXNob2xkOyAvL1xuICAgICAgICAgIC8vIERlZmluZSB0aGUgb3B0aW9ucyBmb3IgdGhlIGhpZGRlbiBjbHVzdGVyIG5vZGVzXG4gICAgICAgICAgLy8gVGhlc2Ugb3B0aW9ucyBkb24ndCBwcm9wYWdhdGUgb3V0c2lkZSB0aGUgY2x1c3RlcmluZyBwaGFzZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFNvbWUgb3B0aW9ucyBhcmUgZXhwbGljaXRseSBkaXNhYmxlZCwgYmVjYXVzZSB0aGV5IG1heSBiZSBzZXQgaW4gZ3JvdXAgb3IgZGVmYXVsdCBub2RlIG9wdGlvbnMuXG4gICAgICAgICAgLy8gVGhlIGNsdXN0ZXJzIGFyZSBuZXZlciBkaXNwbGF5ZWQsIHNvIG1vc3QgZXhwbGljaXQgc2V0dGluZ3MgaGVyZSBzZXJ2ZSBhcyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIGV4cGxpY2l0IHNldHRpbmcgb2YgJ3NoYXBlJyBpcyB0byBhdm9pZCBgc2hhcGU6ICdpbWFnZSdgOyBpbWFnZXMgYXJlIG5vdCBwYXNzZWQgdG8gdGhlIGhpZGRlblxuICAgICAgICAgIC8vIGNsdXN0ZXIgbm9kZXMsIGxlYWRpbmcgdG8gYW4gZXhjZXB0aW9uIG9uIGNyZWF0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gQWxsIHNldHRpbmdzIGhlcmUgYXJlIHBlcmZvcm1hbmNlIHJlbGF0ZWQsIGV4Y2VwdCB3aGVuIG5vdGVkIG90aGVyd2lzZS5cbiAgICAgICAgICAvL1xuXG4gICAgICAgICAgdmFyIGNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgLy8gQnVnZml4OiBhdm9pZCB0eXBlICdpbWFnZScsIG5vIGltYWdlcyBzdXBwbGllZFxuICAgICAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICAgICAgLy8gYXZvaWQgbGFiZWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZ3JvdXA6IFwiXCIsXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGdyb3VwIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBtdWx0aTogZmFsc2VcbiAgICAgICAgICAgICAgfSAvLyBhdm9pZCBmb250IHByb3BhZ2F0aW9uXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbHVzdGVyRWRnZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGxhYmVsIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBtdWx0aTogZmFsc2VcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gYXZvaWQgZm9udCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSAvLyBhdm9pZCBkcmF3aW5nIHBlbmFsdHkgZm9yIGNvbXBsZXggZWRnZXNcblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTsgLy8gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzLCB3ZSBjbHVzdGVyIGJlZm9yZSB3ZSBydW4gdGhlIGFsZ29yaXRobS5cbiAgICAgICAgICAvLyBOT1RFOiB0aGlzIHBhcnQgZmFpbHMgdG8gZmluZCBjbHVzdGVycyBmb3IgbGFyZ2Ugc2NhbGUtZnJlZSBuZXR3b3Jrcywgd2hpY2ggc2hvdWxkXG4gICAgICAgICAgLy8gICAgICAgYmUgZWFzaWx5IGNsdXN0ZXJhYmxlLlxuICAgICAgICAgIC8vIFRPRE86IGV4YW1pbmUgd2h5IHRoaXMgaXMgc29cblxuICAgICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCA+IGNsdXN0ZXJUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydExlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkICYmIGxldmVsIDw9IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWUoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBpbmRpY2VzLmxlbmd0aDsgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcblxuICAgICAgICAgICAgICBpZiAobGV2ZWwgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyQnJpZGdlcyhjbHVzdGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFmdGVyID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfbGF5b3V0RmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoaXMgbmV0d29yayBjb3VsZCBub3QgYmUgcG9zaXRpb25lZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGltcHJvdmVkIGxheW91dCBhbGdvcml0aG0uXCIgKyBcIiBQbGVhc2UgZGlzYWJsZSBpbXByb3ZlZExheW91dCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gLy9jb25zb2xlLnRpbWVFbmQoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coYmVmb3JlLGxldmVsLGFmdGVyKTtcblxuICAgICAgICAgICAgfSAvLyBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgZWRnZXNcblxuXG4gICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgc3ByaW5nTGVuZ3RoOiBNYXRoLm1heCgxNTAsIDIgKiBzdGFydExlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZXZlbCA+IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoZSBjbHVzdGVyaW5nIGRpZG4ndCBzdWNjZWVkIHdpdGhpbiB0aGUgYW1vdW50IG9mIGludGVyYXRpb25zIGFsbG93ZWQsXCIgKyBcIiBwcm9ncmVzc2luZyB3aXRoIHBhcnRpYWwgcmVzdWx0LlwiKTtcbiAgICAgICAgICB9IC8vIHBvc2l0aW9uIHRoZSBzeXN0ZW0gZm9yIHRoZXNlIG5vZGVzIGFuZCBlZGdlc1xuXG5cbiAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zb2x2ZShpbmRpY2VzLCB0aGlzLmJvZHkuZWRnZUluZGljZXMsIHRydWUpOyAvLyBzaGlmdCB0byBjZW50ZXIgcG9pbnRcblxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTsgLy8gcGVydHVyYiB0aGUgbm9kZXMgYSBsaXR0bGUgYml0IHRvIGZvcmNlIHRoZSBwaHlzaWNzIHRvIGtpY2sgaW5cblxuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDcwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHBlcnR1cmIgdGhlIG5vZGVzIHRoYXQgYXJlbid0IGZpeGVkXG4gICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tfaV1dO1xuXG4gICAgICAgICAgICBpZiAoX25vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBfbm9kZS54ICs9ICgwLjUgLSB0aGlzLl9ybmcoKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICAgIF9ub2RlLnkgKz0gKDAuNSAtIHRoaXMuX3JuZygpKSAqIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHVuY2x1c3RlciBhbGwgY2x1c3RlcnNcblxuXG4gICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7IC8vIHJlcG9zaXRpb24gYWxsIGJlemllciBub2Rlcy5cblxuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZSBhbGwgdGhlIG5vZGVzIHRvd2FyZHMgdG8gdGhlIGNlbnRlciBzbyBncmF2aXRhdGlvbmFsIHB1bGwgd2lsIG5vdCBtb3ZlIHRoZSBub2RlcyBhd2F5IGZyb20gdmlld1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaGlmdFRvQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdFRvQ2VudGVyKCkge1xuICAgICAgdmFyIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2VDb3JlKHRoaXMuYm9keS5ub2RlcywgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKTtcbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgbm9kZS54IC09IGNlbnRlci54O1xuICAgICAgICBub2RlLnkgLT0gY2VudGVyLnk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIGNsdXN0ZXJzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY2x1c3RlckFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjbHVzdGVyQWxsKCkge1xuICAgICAgdmFyIGNsdXN0ZXJzUHJlc2VudCA9IHRydWU7XG5cbiAgICAgIHdoaWxlIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsUmFuZG9tU2VlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiB0byBsYXlvdXQgdGhlIG5vZGVzIGluIGEgaGllcmFyY2hpY2FsIHdheS5cbiAgICAgKiBJdCBjaGVja3MgaWYgdGhlIG5vZGUgZGV0YWlscyBhcmUgc3VwcGxpZWQgY29ycmVjdGx5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBIaWVyYXJjaGljYWxMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlICYmIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBodWJzIGFuZCBjaGVjayBpZiB0aGUgdXNlciBoYXMgZGVmaW5lZCBhIGxldmVsIGZvciBhIG5vZGUuXG4gICAgICAgIHZhciBub2RlLCBub2RlSWQ7XG4gICAgICAgIHZhciBkZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsID0ge307XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsID0gbmV3IEhpZXJhcmNoaWNhbFN0YXR1cygpO1xuXG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXSA9IG5vZGUub3B0aW9ucy5sZXZlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgdGhlIHVzZXIgZGVmaW5lZCBzb21lIGxldmVscyBidXQgbm90IGFsbCwgYWxlcnQgYW5kIHJ1biB3aXRob3V0IGhpZXJhcmNoaWNhbCBsYXlvdXRcblxuXG4gICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSAmJiBkZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1c2UgdGhlIGhpZXJhcmNoaWNhbCBsYXlvdXQsIG5vZGVzIHJlcXVpcmUgZWl0aGVyIG5vIHByZWRlZmluZWQgbGV2ZWxzXCIgKyBcIiBvciBsZXZlbHMgaGF2ZSB0byBiZSBkZWZpbmVkIGZvciBhbGwgbm9kZXMuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmluZSBsZXZlbHMgaWYgdW5kZWZpbmVkIGJ5IHRoZSB1c2Vycy4gQmFzZWQgb24gaHVic2l6ZS5cbiAgICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBzb3J0TWV0aG9kID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zb3J0TWV0aG9kO1xuXG4gICAgICAgICAgICBpZiAoc29ydE1ldGhvZCA9PT0gXCJodWJzaXplXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09IFwiZGlyZWN0ZWRcIikge1xuICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0TWV0aG9kID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBmYWxsYmFjayBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgYXJlIG5vZGVzIGJ1dCBubyBlZGdlc1xuXG5cbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwuZW5zdXJlTGV2ZWwoX25vZGVJZDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gY2hlY2sgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgbm9kZXMgcGVyIGxldmVsLlxuXG5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKCk7IC8vIGdldCB0aGUgcGFyZW50IGNoaWxkcmVuIHJlbGF0aW9ucy5cblxuXG4gICAgICAgICAgdGhpcy5fZ2VuZXJhdGVNYXAoKTsgLy8gcGxhY2UgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMuXG5cblxuICAgICAgICAgIHRoaXMuX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pOyAvLyBjb25kZW5zZSB0aGUgd2hpdGVzcGFjZS5cblxuXG4gICAgICAgICAgdGhpcy5fY29uZGVuc2VIaWVyYXJjaHkoKTsgLy8gc2hpZnQgdG8gY2VudGVyIHNvIGdyYXZpdHkgZG9lcyBub3QgaGF2ZSB0byBkbyBtdWNoXG5cblxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbmRlbnNlSGllcmFyY2h5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25kZW5zZUhpZXJhcmNoeSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBHbG9iYWwgdmFyIGluIHRoaXMgc2NvcGUgdG8gZGVmaW5lIHdoZW4gdGhlIG1vdmVtZW50IGhhcyBzdG9wcGVkLlxuICAgICAgdmFyIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBicmFuY2hlcyA9IHt9OyAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgIC8vIHRoZSBtYWluIG1ldGhvZCB0byBzaGlmdCB0aGUgdHJlZXNcblxuICAgICAgdmFyIHNoaWZ0VHJlZXMgPSBmdW5jdGlvbiBzaGlmdFRyZWVzKCkge1xuICAgICAgICB2YXIgdHJlZVNpemVzID0gZ2V0VHJlZVNpemVzKCk7XG4gICAgICAgIHZhciBzaGlmdEJ5ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWVTaXplcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IHRyZWVTaXplc1tpXS5tYXggLSB0cmVlU2l6ZXNbaSArIDFdLm1pbjtcbiAgICAgICAgICBzaGlmdEJ5ICs9IGRpZmYgKyBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwudHJlZVNwYWNpbmc7XG4gICAgICAgICAgc2hpZnRUcmVlKGkgKyAxLCBzaGlmdEJ5KTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gc2hpZnQgYSBzaW5nbGUgdHJlZSBieSBhbiBvZmZzZXRcblxuXG4gICAgICB2YXIgc2hpZnRUcmVlID0gZnVuY3Rpb24gc2hpZnRUcmVlKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHRyZWVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC50cmVlcztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdHJlZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyZWVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAodHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zaGlmdChub2RlSWQsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBnZXQgdGhlIHdpZHRoIG9mIGFsbCB0cmVlc1xuXG5cbiAgICAgIHZhciBnZXRUcmVlU2l6ZXMgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZXMoKSB7XG4gICAgICAgIHZhciB0cmVlV2lkdGhzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpczMuaGllcmFyY2hpY2FsLm51bVRyZWVzKCk7IGkrKykge1xuICAgICAgICAgIHRyZWVXaWR0aHMucHVzaChfdGhpczMuZGlyZWN0aW9uLmdldFRyZWVTaXplKGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgfTsgLy8gZ2V0IGEgbWFwIG9mIGFsbCBub2RlcyBpbiB0aGlzIGJyYW5jaFxuXG5cbiAgICAgIHZhciBnZXRCcmFuY2hOb2RlcyA9IGZ1bmN0aW9uIGdldEJyYW5jaE5vZGVzKHNvdXJjZSwgbWFwKSB7XG4gICAgICAgIGlmIChtYXBbc291cmNlLmlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcFtzb3VyY2UuaWRdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMoX3RoaXMzLmJvZHkubm9kZXNbY2hpbGRyZW5baV1dLCBtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gZ2V0IGEgbWluIG1heCB3aWR0aCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIG1vdmVtZW50IHNwYWNlIGl0IGhhcyBvbiBlaXRoZXIgc2lkZXNcbiAgICAgIC8vIHdlIHVzZSBtaW4gbWF4IHRlcm1pbm9sb2d5IGJlY2F1c2Ugd2lkdGggYW5kIGhlaWdodCBjYW4gaW50ZXJjaGFuZ2UgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxheW91dFxuXG5cbiAgICAgIHZhciBnZXRCcmFuY2hCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE1hcCkge1xuICAgICAgICB2YXIgbWF4TGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDFlOTtcbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgIHZhciBtYXggPSAtMWU5O1xuXG4gICAgICAgIGZvciAodmFyIGJyYW5jaE5vZGUgaW4gYnJhbmNoTWFwKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChicmFuY2hNYXAsIGJyYW5jaE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW2JyYW5jaE5vZGVdO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZS5pZF07XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIGdldCB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLlxuXG5cbiAgICAgICAgICAgIHZhciBfdGhpczMkX2dldFNwYWNlQXJvdW4gPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBicmFuY2hNYXApLFxuICAgICAgICAgICAgICAgIF90aGlzMyRfZ2V0U3BhY2VBcm91bjIgPSBfc2xpY2VkVG9BcnJheShfdGhpczMkX2dldFNwYWNlQXJvdW4sIDIpLFxuICAgICAgICAgICAgICAgIG1pblNwYWNlTm9kZSA9IF90aGlzMyRfZ2V0U3BhY2VBcm91bjJbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2VOb2RlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuMlsxXTtcblxuICAgICAgICAgICAgbWluU3BhY2UgPSBNYXRoLm1pbihtaW5TcGFjZU5vZGUsIG1pblNwYWNlKTtcbiAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2VOb2RlLCBtYXhTcGFjZSk7IC8vIHRoZSB3aWR0aCBpcyBvbmx5IHJlbGV2YW50IGZvciB0aGUgbGV2ZWxzIHR3byBub2RlcyBoYXZlIGluIGNvbW1vbi4gVGhpcyBpcyB3aHkgd2UgZmlsdGVyIG9uIHRoaXMuXG5cbiAgICAgICAgICAgIGlmIChsZXZlbCA8PSBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihwb3NpdGlvbiwgbWluKTtcbiAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgocG9zaXRpb24sIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW4sIG1heCwgbWluU3BhY2UsIG1heFNwYWNlXTtcbiAgICAgIH07IC8vIGNoZWNrIHdoYXQgdGhlIG1heGltdW0gbGV2ZWwgaXMgdGhlc2Ugbm9kZXMgaGF2ZSBpbiBjb21tb24uXG5cblxuICAgICAgdmFyIGdldENvbGxpc2lvbkxldmVsID0gZnVuY3Rpb24gZ2V0Q29sbGlzaW9uTGV2ZWwobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIHZhciBtYXhMZXZlbDEgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUxLmlkKTtcblxuICAgICAgICB2YXIgbWF4TGV2ZWwyID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChub2RlMi5pZCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heExldmVsMSwgbWF4TGV2ZWwyKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENvbmRlbnNlIGVsZW1lbnRzLiBUaGVzZSBjYW4gYmUgbm9kZXMgb3IgYnJhbmNoZXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxsYmFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbGV2ZWxzXG4gICAgICAgKiBAcGFyYW0geyp9IGNlbnRlclBhcmVudHNcbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciBzaGlmdEVsZW1lbnRzQ2xvc2VyID0gZnVuY3Rpb24gc2hpZnRFbGVtZW50c0Nsb3NlcihjYWxsYmFjaywgbGV2ZWxzLCBjZW50ZXJQYXJlbnRzKSB7XG4gICAgICAgIHZhciBoaWVyID0gX3RoaXMzLmhpZXJhcmNoaWNhbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IGhpZXIuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuXG4gICAgICAgICAgaWYgKGxldmVsTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbE5vZGVzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbm9kZTEgPSBsZXZlbE5vZGVzW2pdO1xuICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBsZXZlbE5vZGVzW2ogKyAxXTsgLy8gTk9URTogbG9naWMgbWFpbnRhaW5lZCBhcyBpdCB3YXM7IGlmIG5vZGVzIGhhdmUgc2FtZSBhbmNlc3RvcixcbiAgICAgICAgICAgICAgLy8gICAgICAgdGhlbiBvZiBjb3Vyc2UgdGhleSBhcmUgaW4gdGhlIHNhbWUgc3ViLW5ldHdvcmsuXG5cbiAgICAgICAgICAgICAgaWYgKGhpZXIuaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpICYmIGhpZXIuaW5TYW1lU3ViTmV0d29yayhub2RlMSwgbm9kZTIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobm9kZTEsIG5vZGUyLCBjZW50ZXJQYXJlbnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gY2FsbGJhY2sgZm9yIHNoaWZ0aW5nIGJyYW5jaGVzXG5cblxuICAgICAgdmFyIGJyYW5jaFNoaWZ0Q2FsbGJhY2sgPSBmdW5jdGlvbiBicmFuY2hTaGlmdENhbGxiYWNrKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgY2VudGVyUGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgIHZhciBwb3MxID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlMSk7XG5cbiAgICAgICAgdmFyIHBvczIgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUyKTtcblxuICAgICAgICB2YXIgZGlmZkFicyA9IE1hdGguYWJzKHBvczIgLSBwb3MxKTtcbiAgICAgICAgdmFyIG5vZGVTcGFjaW5nID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nOyAvL2NvbnNvbGUubG9nKFwiTk9XIENIRUNLSU5HOlwiLCBub2RlMS5pZCwgbm9kZTIuaWQsIGRpZmZBYnMpO1xuXG4gICAgICAgIGlmIChkaWZmQWJzID4gbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMxID0ge307XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMiA9IHt9O1xuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUxLCBicmFuY2hOb2RlczEpO1xuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUyLCBicmFuY2hOb2RlczIpOyAvLyBjaGVjayB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBicmFuY2hlc1xuXG4gICAgICAgICAgdmFyIG1heExldmVsID0gZ2V0Q29sbGlzaW9uTGV2ZWwobm9kZTEsIG5vZGUyKTtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZUJvdW5kYXJ5MSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMSwgbWF4TGV2ZWwpO1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlQm91bmRhcnkyID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCk7XG4gICAgICAgICAgdmFyIG1heDEgPSBicmFuY2hOb2RlQm91bmRhcnkxWzFdO1xuICAgICAgICAgIHZhciBtaW4yID0gYnJhbmNoTm9kZUJvdW5kYXJ5MlswXTtcbiAgICAgICAgICB2YXIgbWluU3BhY2UyID0gYnJhbmNoTm9kZUJvdW5kYXJ5MlsyXTsgLy9jb25zb2xlLmxvZyhub2RlMS5pZCwgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCksIG5vZGUyLmlkLFxuICAgICAgICAgIC8vICAgICAgICAgICAgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCksIG1heExldmVsKTtcblxuICAgICAgICAgIHZhciBkaWZmQnJhbmNoID0gTWF0aC5hYnMobWF4MSAtIG1pbjIpO1xuXG4gICAgICAgICAgaWYgKGRpZmZCcmFuY2ggPiBub2RlU3BhY2luZykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG1heDEgLSBtaW4yICsgbm9kZVNwYWNpbmc7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gLW1pblNwYWNlMiArIG5vZGVTcGFjaW5nOyAvL2NvbnNvbGUubG9nKFwiUkVTRVRUSU5HIE9GRlNFVFwiLCBtYXgxIC0gbWluMiArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsIC1taW5TcGFjZTIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTSElGVElOR1wiLCBub2RlMi5pZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgX3RoaXMzLl9zaGlmdEJsb2NrKG5vZGUyLmlkLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoY2VudGVyUGFyZW50ID09PSB0cnVlKSBfdGhpczMuX2NlbnRlclBhcmVudChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7fSlcblxuICAgICAgfTtcblxuICAgICAgdmFyIG1pbmltaXplRWRnZUxlbmd0aCA9IGZ1bmN0aW9uIG1pbmltaXplRWRnZUxlbmd0aChpdGVyYXRpb25zLCBub2RlKSB7XG4gICAgICAgIC8vd2luZG93LkNBTExCQUNLUy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwidHNcIixub2RlLmlkKTtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICAgIHZhciBhbGxFZGdlcyA9IG5vZGUuZWRnZXM7XG4gICAgICAgIHZhciBub2RlTGV2ZWwgPSBfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTsgLy8gZ2F0aGVyIGNvbnN0YW50c1xuXG4gICAgICAgIHZhciBDMiA9IF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uO1xuICAgICAgICB2YXIgcmVmZXJlbmNlTm9kZXMgPSB7fTtcbiAgICAgICAgdmFyIGFib3ZlRWRnZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBhbGxFZGdlc1tpXTtcblxuICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLnRvSWQgPT0gbm9kZUlkID8gZWRnZS5mcm9tIDogZWRnZS50bztcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGVzW2FsbEVkZ2VzW2ldLmlkXSA9IG90aGVyTm9kZTtcblxuICAgICAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW290aGVyTm9kZS5pZF0gPCBub2RlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgYWJvdmVFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG5cblxuICAgICAgICB2YXIgZ2V0RnggPSBmdW5jdGlvbiBnZXRGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTJdLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTJdLmlkXSkgLSBwb2ludDtcbiAgICAgICAgICAgICAgc3VtICs9IGEgLyBNYXRoLnNxcnQoYSAqIGEgKyBDMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTsgLy8gZG91Ymx5IGRpZmZlcmVudGlhdGVkIHN1bSBvZiBsZW5ndGhzIGJhc2VkIG9uIG9ubHkgbW92aW5nIG9uZSBub2RlIG92ZXIgb25lIGF4aXNcblxuXG4gICAgICAgIHZhciBnZXRERnggPSBmdW5jdGlvbiBnZXRERngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgIHN1bSAtPSBDMiAqIE1hdGgucG93KGEgKiBhICsgQzIsIC0xLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEd1ZXNzID0gZnVuY3Rpb24gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgZ3Vlc3MgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpOyAvLyBOZXd0b24ncyBtZXRob2QgZm9yIG9wdGltaXphdGlvblxuXG5cbiAgICAgICAgICB2YXIgZ3Vlc3NNYXAgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGl0ZXJhdGlvbnM7IF9pNCsrKSB7XG4gICAgICAgICAgICB2YXIgZnggPSBnZXRGeChndWVzcywgZWRnZXMpO1xuICAgICAgICAgICAgdmFyIGRmeCA9IGdldERGeChndWVzcywgZWRnZXMpOyAvLyB3ZSBsaW1pdCB0aGUgbW92ZW1lbnQgdG8gYXZvaWQgaW5zdGFiaWxpdHkuXG5cbiAgICAgICAgICAgIHZhciBsaW1pdCA9IDQwO1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5tYXgoLWxpbWl0LCBNYXRoLm1pbihsaW1pdCwgTWF0aC5yb3VuZChmeCAvIGRmeCkpKTtcbiAgICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MgLSByYXRpbzsgLy8gcmVkdWNlIGR1cGxpY2F0ZXNcblxuICAgICAgICAgICAgaWYgKGd1ZXNzTWFwW2d1ZXNzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBndWVzc01hcFtndWVzc10gPSBfaTQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGd1ZXNzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3ZlQnJhbmNoID0gZnVuY3Rpb24gbW92ZUJyYW5jaChndWVzcykge1xuICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcbiAgICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTsgLy8gY2hlY2sgbW92YWJsZSBhcmVhIG9mIHRoZSBicmFuY2hcblxuXG4gICAgICAgICAgaWYgKGJyYW5jaGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBicmFuY2hOb2RlcyA9IHt9O1xuICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZSwgYnJhbmNoTm9kZXMpO1xuICAgICAgICAgICAgYnJhbmNoZXNbbm9kZS5pZF0gPSBicmFuY2hOb2RlcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYnJhbmNoQm91bmRhcnkgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hlc1tub2RlLmlkXSk7XG4gICAgICAgICAgdmFyIG1pblNwYWNlQnJhbmNoID0gYnJhbmNoQm91bmRhcnlbMl07XG4gICAgICAgICAgdmFyIG1heFNwYWNlQnJhbmNoID0gYnJhbmNoQm91bmRhcnlbM107XG4gICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjsgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcblxuICAgICAgICAgIHZhciBicmFuY2hPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSBNYXRoLm1pbihkaWZmLCBtYXhTcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gLU1hdGgubWluKC1kaWZmLCBtaW5TcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJyYW5jaE9mZnNldCAhPSAwKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIGJyYW5jaDpcIixicmFuY2hPZmZzZXQsIG1heFNwYWNlQnJhbmNoLCBtaW5TcGFjZUJyYW5jaClcbiAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlLmlkLCBicmFuY2hPZmZzZXQpOyAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuXG5cbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW92ZU5vZGUgPSBmdW5jdGlvbiBtb3ZlTm9kZShndWVzcykge1xuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpOyAvLyBwb3NpdGlvbiBub2RlIGlmIHRoZXJlIGlzIHNwYWNlXG5cblxuICAgICAgICAgIHZhciBfdGhpczMkX2dldFNwYWNlQXJvdW4zID0gX3RoaXMzLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSksXG4gICAgICAgICAgICAgIF90aGlzMyRfZ2V0U3BhY2VBcm91bjQgPSBfc2xpY2VkVG9BcnJheShfdGhpczMkX2dldFNwYWNlQXJvdW4zLCAyKSxcbiAgICAgICAgICAgICAgbWluU3BhY2UgPSBfdGhpczMkX2dldFNwYWNlQXJvdW40WzBdLFxuICAgICAgICAgICAgICBtYXhTcGFjZSA9IF90aGlzMyRfZ2V0U3BhY2VBcm91bjRbMV07XG5cbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uOyAvLyBjaGVjayBpZiB3ZSBhcmUgYWxsb3dlZCB0byBtb3ZlIHRoZSBub2RlOlxuXG4gICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IE1hdGgubWluKG5vZGVQb3NpdGlvbiArIChtYXhTcGFjZSAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksIGd1ZXNzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IE1hdGgubWF4KG5vZGVQb3NpdGlvbiAtIChtaW5TcGFjZSAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksIGd1ZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gIT09IG5vZGVQb3NpdGlvbikge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vdmluZyBOb2RlOlwiLGRpZmYsIG1pblNwYWNlLCBtYXhTcGFjZSk7XG4gICAgICAgICAgICBfdGhpczMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKG5vZGUsIG5ld1Bvc2l0aW9uKTsgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcblxuXG4gICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGd1ZXNzID0gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgYWJvdmVFZGdlcyk7XG4gICAgICAgIG1vdmVCcmFuY2goZ3Vlc3MpO1xuICAgICAgICBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFsbEVkZ2VzKTtcbiAgICAgICAgbW92ZU5vZGUoZ3Vlc3MpOyAvL30pXG4gICAgICB9OyAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG5cblxuICAgICAgdmFyIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcblxuICAgICAgICBsZXZlbHMgPSByZXZlcnNlKGxldmVscykuY2FsbChsZXZlbHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tqXTtcbiAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBtaW5pbWl6ZUVkZ2VMZW5ndGgoMTAwMCwgbGV2ZWxOb2Rlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCBJTiBcIiArIGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG5cblxuICAgICAgdmFyIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCA9IGZ1bmN0aW9uIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcChpdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuXG4gICAgICAgIGxldmVscyA9IHJldmVyc2UobGV2ZWxzKS5jYWxsKGxldmVscyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2hpZnRFbGVtZW50c0Nsb3NlcihicmFuY2hTaGlmdENhbGxiYWNrLCBsZXZlbHMsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgSU4gXCIgKyAoaSsxKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGNlbnRlciBhbGwgcGFyZW50c1xuXG5cbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50cygpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpczMuYm9keS5ub2Rlcywgbm9kZUlkKSkgX3RoaXMzLl9jZW50ZXJQYXJlbnQoX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGNlbnRlciBhbGwgcGFyZW50c1xuXG5cbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuXG4gICAgICAgIGxldmVscyA9IHJldmVyc2UobGV2ZWxzKS5jYWxsKGxldmVscyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgX3RoaXMzLl9jZW50ZXJQYXJlbnQobGV2ZWxOb2Rlc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyB0aGUgYWN0dWFsIHdvcmsgaXMgZG9uZSBoZXJlLlxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmJsb2NrU2hpZnRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwKDUpO1xuICAgICAgICBjZW50ZXJBbGxQYXJlbnRzKCk7XG4gICAgICB9IC8vIG1pbmltaXplIGVkZ2UgbGVuZ3RoXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZWRnZU1pbmltaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCgyMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnBhcmVudENlbnRyYWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpO1xuICAgICAgfVxuXG4gICAgICBzaGlmdFRyZWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZ2l2ZXMgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS4gSUYgYSBtYXAgaXMgc3VwcGxpZWQsIGl0IHdpbGwgb25seSBjaGVjayBhZ2FpbnN0IG5vZGVzIE5PVCBpbiB0aGUgbWFwLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBvbmx5IGdldCB0aGUgZGlzdGFuY2VzIHRvIG5vZGVzIG91dHNpZGUgb2YgYSBicmFuY2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3tOb2RlLmlkOiB2aXMuTm9kZX19IG1hcFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNwYWNlQXJvdW5kTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUsIG1hcCkge1xuICAgICAgdmFyIHVzZU1hcCA9IHRydWU7XG5cbiAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1c2VNYXAgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25JbmRleFtub2RlLmlkXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICAgIHZhciBvcmRlcmluZyA9IHRoaXMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHByZXZOb2RlID0gb3JkZXJpbmdbaW5kZXggLSAxXTtcblxuICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW3ByZXZOb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocHJldk5vZGUpO1xuICAgICAgICAgICAgbWluU3BhY2UgPSBwb3NpdGlvbiAtIHByZXZQb3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG9yZGVyaW5nLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBvcmRlcmluZ1tpbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKHVzZU1hcCA9PT0gdHJ1ZSAmJiBtYXBbbmV4dE5vZGUuaWRdID09PSB1bmRlZmluZWQgfHwgdXNlTWFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG5leHRQb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihuZXh0Tm9kZSk7XG4gICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlLCBuZXh0UG9zIC0gcG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWluU3BhY2UsIG1heFNwYWNlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byBjZW50ZXIgYSBwYXJlbnQgbm9kZSBhbmQgY2hlY2sgaWYgaXQgZG9lcyBub3QgY3Jvc3Mgb3RoZXIgbm9kZXMgd2hlbiBpdCBkb2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jZW50ZXJQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NlbnRlclBhcmVudChub2RlKSB7XG4gICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdKSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0gdGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJlbnRJZCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJhbmdlIG9mIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gdGhpcy5fZ2V0Q2VudGVyUG9zaXRpb24oY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihwYXJlbnROb2RlKTtcblxuICAgICAgICAgICAgdmFyIF90aGlzJF9nZXRTcGFjZUFyb3VuZCA9IHRoaXMuX2dldFNwYWNlQXJvdW5kTm9kZShwYXJlbnROb2RlKSxcbiAgICAgICAgICAgICAgICBfdGhpcyRfZ2V0U3BhY2VBcm91bmQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldFNwYWNlQXJvdW5kLCAyKSxcbiAgICAgICAgICAgICAgICBtaW5TcGFjZSA9IF90aGlzJF9nZXRTcGFjZUFyb3VuZDJbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfdGhpcyRfZ2V0U3BhY2VBcm91bmQyWzFdO1xuXG4gICAgICAgICAgICB2YXIgZGlmZiA9IHBvc2l0aW9uIC0gbmV3UG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChkaWZmIDwgMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1heFNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyB8fCBkaWZmID4gMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1pblNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihwYXJlbnROb2RlLCBuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcGxhY2VzIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzIGJhc2VkIG9uIHRoZSBoaWVyYXJjaGlhbCBkaXN0cmlidXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGlzdHJpYnV0aW9uIHwgb2J0YWluZWQgYnkgdGhlIGZ1bmN0aW9uIHRoaXMuX2dldERpc3RyaWJ1dGlvbigpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZU5vZGVzQnlIaWVyYXJjaHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzID0ge307IC8vIHN0YXJ0IHBsYWNpbmcgYWxsIHRoZSBsZXZlbCAwIG5vZGVzIGZpcnN0LiBUaGVuIHJlY3Vyc2l2ZWx5IHBvc2l0aW9uIHRoZWlyIGJyYW5jaGVzLlxuXG4gICAgICBmb3IgKHZhciBsZXZlbCBpbiBkaXN0cmlidXRpb24pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaXN0cmlidXRpb24sIGxldmVsKSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIC8vIHNvcnQgbm9kZXMgaW4gbGV2ZWwgYnkgcG9zaXRpb246XG4gICAgICAgICAgdmFyIG5vZGVBcnJheSA9IGtleXMkNChkaXN0cmlidXRpb25bbGV2ZWxdKTtcblxuICAgICAgICAgIG5vZGVBcnJheSA9IHRoaXMuX2luZGV4QXJyYXlUb05vZGVzKG5vZGVBcnJheSk7XG5cbiAgICAgICAgICBzb3J0KF9jb250ZXh0ID0gdGhpcy5kaXJlY3Rpb24pLmNhbGwoX2NvbnRleHQsIG5vZGVBcnJheSk7XG5cbiAgICAgICAgICB2YXIgaGFuZGxlZE5vZGVDb3VudCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlQXJyYXlbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IHNwYWNpbmcgKiBoYW5kbGVkTm9kZUNvdW50OyAvLyBXZSBnZXQgdGhlIFggb3IgWSB2YWx1ZXMgd2UgbmVlZCBhbmQgc3RvcmUgdGhlbSBpbiBwb3MgYW5kIHByZXZpb3VzUG9zLlxuICAgICAgICAgICAgICAvLyBUaGUgZ2V0IGFuZCBzZXQgbWFrZSBzdXJlIHdlIGdldCBYIG9yIFlcblxuICAgICAgICAgICAgICBpZiAoaGFuZGxlZE5vZGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlQXJyYXlbaSAtIDFdKSArIHNwYWNpbmc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBwb3MsIGxldmVsKTtcblxuICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcyk7XG5cbiAgICAgICAgICAgICAgaGFuZGxlZE5vZGVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcmVjdXJzaXZlbHkgY2FsbGVkIGZ1bmN0aW9uIHRvIGVudW1lcmF0ZSB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgbGFyZ2VzdCBodWJzIGFuZCBwbGFjZSB0aGUgbm9kZXNcbiAgICAgKiBvbiBhIFggcG9zaXRpb24gdGhhdCBlbnN1cmVzIHRoZXJlIHdpbGwgYmUgbm8gb3ZlcmxhcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyZW50TGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlQnJhbmNoTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlQnJhbmNoTm9kZXMocGFyZW50SWQsIHBhcmVudExldmVsKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICB2YXIgY2hpbGRSZWYgPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07IC8vIGlmIHRoaXMgaXMgbm90IGEgcGFyZW50LCBjYW5jZWwgdGhlIHBsYWNpbmcuIFRoaXMgY2FuIGhhcHBlbiB3aXRoIG11bHRpcGxlIHBhcmVudHMgdG8gb25lIGNoaWxkLlxuXG4gICAgICBpZiAoY2hpbGRSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGdldCBhIGxpc3Qgb2YgY2hpbGROb2Rlc1xuXG5cbiAgICAgIHZhciBjaGlsZE5vZGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHRoaXMuYm9keS5ub2Rlc1tjaGlsZFJlZltpXV0pO1xuICAgICAgfSAvLyB1c2UgdGhlIHBvc2l0aW9ucyB0byBvcmRlciB0aGUgbm9kZXMuXG5cblxuICAgICAgc29ydChfY29udGV4dDIgPSB0aGlzLmRpcmVjdGlvbikuY2FsbChfY29udGV4dDIsIGNoaWxkTm9kZXMpOyAvLyBwb3NpdGlvbiB0aGUgY2hpbGROb2Rlc1xuXG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tfaTVdO1xuICAgICAgICB2YXIgY2hpbGROb2RlTGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbY2hpbGROb2RlLmlkXTsgLy8gY2hlY2sgaWYgdGhlIGNoaWxkIG5vZGUgaXMgYmVsb3cgdGhlIHBhcmVudCBub2RlIGFuZCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHBvc2l0aW9uZWQuXG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZUxldmVsID4gcGFyZW50TGV2ZWwgJiYgdGhpcy5wb3NpdGlvbmVkTm9kZXNbY2hpbGROb2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBhbW91bnQgb2Ygc3BhY2UgcmVxdWlyZWQgZm9yIHRoaXMgbm9kZS4gSWYgcGFyZW50IHRoZSB3aWR0aCBpcyBiYXNlZCBvbiB0aGUgYW1vdW50IG9mIGNoaWxkcmVuLlxuICAgICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICB2YXIgcG9zID0gdm9pZCAwOyAvLyB3ZSBnZXQgdGhlIFggb3IgWSB2YWx1ZXMgd2UgbmVlZCBhbmQgc3RvcmUgdGhlbSBpbiBwb3MgYW5kIHByZXZpb3VzUG9zLlxuICAgICAgICAgIC8vIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuXG4gICAgICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGNoaWxkTm9kZXNbX2k1IC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihjaGlsZE5vZGUsIHBvcywgY2hpbGROb2RlTGV2ZWwpO1xuXG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKGNoaWxkTm9kZSwgY2hpbGROb2RlTGV2ZWwsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNlbnRlciB0aGUgcGFyZW50IG5vZGVzLlxuXG5cbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRDZW50ZXJQb3NpdGlvbihjaGlsZE5vZGVzKTtcblxuICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSwgY2VudGVyLCBwYXJlbnRMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBmb3Igb3ZlcmxhcCBhbmQgaWYgcmVxdWlyZWQgc2hpZnRzIHRoZSBicmFuY2guIEl0IGFsc28ga2VlcHMgcmVjb3JkcyBvZiBwb3NpdGlvbmVkIG5vZGVzLlxuICAgICAqIEZpbmFsbHkgaXQgd2lsbCBjYWxsIF9wbGFjZUJyYW5jaE5vZGVzIHRvIHBsYWNlIHRoZSBicmFuY2ggbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKSB7XG4gICAgICAvLyBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIGZvciBmb3JtYWwgdHJlZXMgYW5kIGZvcm1hbCBmb3Jlc3RzXG4gICAgICAvLyBFYXJseSBleGl0IGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlXG4gICAgICBpZiAoIXRoaXMuaGllcmFyY2hpY2FsLmlzVHJlZSkgcmV0dXJuOyAvLyBpZiBvdmVybGFwIGhhcyBiZWVuIGRldGVjdGVkLCB3ZSBzaGlmdCB0aGUgYnJhbmNoXG5cbiAgICAgIGlmICh0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcHJldmlvdXNQb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbih0aGlzLmJvZHkubm9kZXNbdGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdXSk7XG5cbiAgICAgICAgaWYgKHBvcyAtIHByZXZpb3VzUG9zIDwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgIHZhciBkaWZmID0gcHJldmlvdXNQb3MgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIC0gcG9zO1xuXG4gICAgICAgICAgdmFyIHNoYXJlZFBhcmVudCA9IHRoaXMuX2ZpbmRDb21tb25QYXJlbnQodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdLCBub2RlLmlkKTtcblxuICAgICAgICAgIHRoaXMuX3NoaWZ0QmxvY2soc2hhcmVkUGFyZW50LndpdGhDaGlsZCwgZGlmZik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdID0gbm9kZS5pZDsgLy8gc3RvcmUgY2hhbmdlIGluIHBvc2l0aW9uLlxuXG4gICAgICB0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3BsYWNlQnJhbmNoTm9kZXMobm9kZS5pZCwgbGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlcyBhbiBhcnJheSB3aXRoIG5vZGUgaW5kaWNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICAgICAqIFVzZWQgZm9yIHNvcnRpbmcgYmFzZWQgb24gbm9kZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZS5pZD59IGlkQXJyYXlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE5vZGU+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luZGV4QXJyYXlUb05vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmRleEFycmF5VG9Ob2RlcyhpZEFycmF5KSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW2lkQXJyYXlbaV1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGdldCB0aGUgZGlzdHJpYnV0aW9uIG9mIGxldmVscyBiYXNlZCBvbiBodWJzaXplXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdHJpYnV0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0cmlidXRpb24oKSB7XG4gICAgICB2YXIgZGlzdHJpYnV0aW9uID0ge307XG4gICAgICB2YXIgbm9kZUlkLCBub2RlOyAvLyB3ZSBmaXggWSBiZWNhdXNlIHRoZSBoaWVyYXJjaHkgaXMgdmVydGljYWwsXG4gICAgICAvLyB3ZSBmaXggWCBzbyB3ZSBkbyBub3QgZ2l2ZSBhIG5vZGUgYW4geCBwb3NpdGlvbiBmb3IgYSBzZWNvbmQgdGltZS5cbiAgICAgIC8vIHRoZSBmaXggb2YgWCBpcyByZW1vdmVkIGFmdGVyIHRoZSB4IHZhbHVlIGhhcyBiZWVuIHNldC5cblxuICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdID09PSB1bmRlZmluZWQgPyAwIDogdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF07XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24uZml4KG5vZGUsIGxldmVsKTtcblxuICAgICAgICAgIGlmIChkaXN0cmlidXRpb25bbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXN0cmlidXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYWN0aXZlIChpLmUuIHZpc2libGUpIGVkZ2VzIGZvciB0aGlzIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2U+fSBBcnJheSBvZiBlZGdlIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWN0aXZlRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFjdGl2ZUVkZ2VzKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JFYWNoJDEobm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICBpZiAoaW5kZXhPZihfY29udGV4dDMgPSBfdGhpczQuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDMsIGVkZ2UuaWQpICE9PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVic2l6ZXMgZm9yIGFsbCBhY3RpdmUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SHViU2l6ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemVzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBodWJTaXplcyA9IHt9O1xuICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICBmb3JFYWNoJDEobm9kZUlkcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzNS5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgdmFyIGh1YlNpemUgPSBfdGhpczUuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpLmxlbmd0aDtcblxuICAgICAgICBodWJTaXplc1todWJTaXplXSA9IHRydWU7XG4gICAgICB9KTsgLy8gTWFrZSBhbiBhcnJheSBvZiB0aGUgc2l6ZSBzb3J0ZWQgZGVzY2VuZGluZ1xuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JFYWNoJDEoaHViU2l6ZXMsIGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKE51bWJlcihzaXplKSk7XG4gICAgICB9KTtcblxuICAgICAgc29ydCh0aW1zb3J0KS5jYWxsKHRpbXNvcnQsIHJlc3VsdCwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgcmVjdXJzaXZlIGJyYW5jaGluZyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUxldmVsc0J5SHVic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBsZXZlbERvd25zdHJlYW0gPSBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWwubGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaHViU2l6ZXMgPSB0aGlzLl9nZXRIdWJTaXplcygpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBodWJTaXplID0gaHViU2l6ZXNbaV07XG4gICAgICAgIGlmIChodWJTaXplID09PSAwKSByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXM2LmJvZHkubm9kZUluZGljZXMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzNi5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICBpZiAoaHViU2l6ZSA9PT0gX3RoaXM2Ll9nZXRBY3RpdmVFZGdlcyhub2RlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIF90aGlzNi5fY3Jhd2xOZXR3b3JrKGxldmVsRG93bnN0cmVhbSwgbm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodWJTaXplcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKGkpO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUT0RPOiByZWxlYXNlIGZlYXR1cmVcbiAgICAgKiBUT0RPOiBEZXRlcm1pbmUgaWYgdGhpcyBmZWF0dXJlIGlzIG5lZWRlZCBhdCBhbGxcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBtaW5MZXZlbCA9IDEwMDAwMDsgLy8gVE9ETzogdGhpcyBzaG91bGQgY29tZSBmcm9tIG9wdGlvbnMuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gVGhpcyBzaG91bGQgZXZlbnR1YWxseSBiZSBpbXBsZW1lbnRlZCB3aXRoIHRoZXNlIHBhcmFtZXRlcnMgdXNlZC5cblxuICAgICAgdmFyIGN1c3RvbUNhbGxiYWNrID0gZnVuY3Rpb24gY3VzdG9tQ2FsbGJhY2sobm9kZUEsIG5vZGVCLCBlZGdlKSB7fTsgLy8gVE9ETzogcGVyaGFwcyBtb3ZlIHRvIEhpZXJhcmNoaWNhbFN0YXR1cy5cbiAgICAgIC8vICAgICAgIEJ1dCBJIGN1cnJlbnRseSBkb24ndCBzZWUgdGhlIHBvaW50LCB0aGlzIG1ldGhvZCBpcyBub3QgdXNlZC5cblxuXG4gICAgICB2YXIgbGV2ZWxCeURpcmVjdGlvbiA9IGZ1bmN0aW9uIGxldmVsQnlEaXJlY3Rpb24obm9kZUEsIG5vZGVCLCBlZGdlKSB7XG4gICAgICAgIHZhciBsZXZlbEEgPSBfdGhpczcuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF07IC8vIHNldCBpbml0aWFsIGxldmVsXG5cbiAgICAgICAgaWYgKGxldmVsQSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IGN1c3RvbUNhbGxiYWNrKE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlQSwgXCJub2RlXCIpLCBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZUIsIFwibm9kZVwiKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGVkZ2UsIFwiZWRnZVwiKSk7XG4gICAgICAgIF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVCLmlkXSA9IGxldmVsQSArIGRpZmY7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxCeURpcmVjdGlvbik7XG5cbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCkge1xuICAgICAgdmFyIF9jb250ZXh0NCxcbiAgICAgICAgICBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgbm9kZXMgPSByZWR1Y2UoX2NvbnRleHQ0ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGFjYywgaWQpIHtcbiAgICAgICAgYWNjLnNldChpZCwgX3RoaXM4LmJvZHkubm9kZXNbaWRdKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIG5ldyBtYXAoKSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNoYWtlVG93YXJkcyA9PT0gXCJyb290c1wiKSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVscyA9IGZpbGxMZXZlbHNCeURpcmVjdGlvblJvb3RzKG5vZGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVscyA9IGZpbGxMZXZlbHNCeURpcmVjdGlvbkxlYXZlcyhub2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm9va2tlZXBpbmcgb2YgcGFyZW50IGFuZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlTWFwKCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHZhciBmaWxsSW5SZWxhdGlvbnMgPSBmdW5jdGlvbiBmaWxsSW5SZWxhdGlvbnMocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gICAgICAgIGlmIChfdGhpczkuaGllcmFyY2hpY2FsLmxldmVsc1tjaGlsZE5vZGUuaWRdID4gX3RoaXM5LmhpZXJhcmNoaWNhbC5sZXZlbHNbcGFyZW50Tm9kZS5pZF0pIHtcbiAgICAgICAgICBfdGhpczkuaGllcmFyY2hpY2FsLmFkZFJlbGF0aW9uKHBhcmVudE5vZGUuaWQsIGNoaWxkTm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhmaWxsSW5SZWxhdGlvbnMpO1xuXG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5jaGVja0lmVHJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmF3bCBvdmVyIHRoZSBlbnRpcmUgbmV0d29yayBhbmQgdXNlIGEgY2FsbGJhY2sgb24gZWFjaCBub2RlIGNvdXBsZSB0aGF0IGlzIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWZ1bmN0aW9uKCl7fV0gICAgICAgICAgfCB3aWxsIHJlY2VpdmUgbm9kZUEsIG5vZGVCIGFuZCB0aGUgY29ubmVjdGluZyBlZGdlLiBBIGFuZCBCIGFyZSBkaXN0aW5jdC5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHN0YXJ0aW5nTm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmF3bE5ldHdvcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyYXdsTmV0d29yaygpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHZhciBzdGFydGluZ05vZGVJZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHByb2dyZXNzID0ge307XG5cbiAgICAgIHZhciBjcmF3bGVyID0gZnVuY3Rpb24gY3Jhd2xlcihub2RlLCB0cmVlKSB7XG4gICAgICAgIGlmIChwcm9ncmVzc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMxMC5oaWVyYXJjaGljYWwuc2V0VHJlZUluZGV4KG5vZGUsIHRyZWUpO1xuXG4gICAgICAgICAgcHJvZ3Jlc3Nbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGU7XG5cbiAgICAgICAgICB2YXIgZWRnZXMgPSBfdGhpczEwLl9nZXRBY3RpdmVFZGdlcyhub2RlKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJz09PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBlZGdlLmZyb207XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS50bztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChub2RlLmlkICE9IGNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCAnIT09JyBiZWNhdXNlIGlkJ3MgY2FuIGJlIHN0cmluZyBhbmQgbnVtZXJpY1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUsIGNoaWxkTm9kZSwgZWRnZSk7XG4gICAgICAgICAgICAgICAgY3Jhd2xlcihjaGlsZE5vZGUsIHRyZWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoc3RhcnRpbmdOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDcmF3bCBvdmVyIGFsbCBub2Rlc1xuICAgICAgICB2YXIgdHJlZUluZGV4ID0gMDsgLy8gU2VydmVzIHRvIHBhc3MgYSB1bmlxdWUgaWQgZm9yIHRoZSBjdXJyZW50IGRpc3RpbmN0IHRyZWVcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG5cbiAgICAgICAgICBpZiAocHJvZ3Jlc3Nbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgY3Jhd2xlcihub2RlLCB0cmVlSW5kZXgpO1xuICAgICAgICAgICAgdHJlZUluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmF3bCBmcm9tIHRoZSBnaXZlbiBzdGFydGluZyBub2RlXG4gICAgICAgIHZhciBfbm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbc3RhcnRpbmdOb2RlSWRdO1xuXG4gICAgICAgIGlmIChfbm9kZTIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlIG5vdCBmb3VuZDpcIiwgc3RhcnRpbmdOb2RlSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyYXdsZXIoX25vZGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hpZnQgYSBicmFuY2ggYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHBhcmVudElkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NoaWZ0QmxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0QmxvY2socGFyZW50SWQsIGRpZmYpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgdmFyIHByb2dyZXNzID0ge307XG5cbiAgICAgIHZhciBzaGlmdGVyID0gZnVuY3Rpb24gc2hpZnRlcihwYXJlbnRJZCkge1xuICAgICAgICBpZiAocHJvZ3Jlc3NbcGFyZW50SWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3Jlc3NbcGFyZW50SWRdID0gdHJ1ZTtcblxuICAgICAgICBfdGhpczExLmRpcmVjdGlvbi5zaGlmdChwYXJlbnRJZCwgZGlmZik7XG5cbiAgICAgICAgdmFyIGNoaWxkUmVmID0gX3RoaXMxMS5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdO1xuXG4gICAgICAgIGlmIChjaGlsZFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2hpZnRlcihjaGlsZFJlZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzaGlmdGVyKHBhcmVudElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIGNvbW1vbiBwYXJlbnQgYmV0d2VlbiBicmFuY2hlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGRBXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjaGlsZEJcbiAgICAgKiBAcmV0dXJucyB7e2ZvdW5kUGFyZW50LCB3aXRoQ2hpbGR9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZENvbW1vblBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZENvbW1vblBhcmVudChjaGlsZEEsIGNoaWxkQikge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyZW50cyA9IHt9O1xuXG4gICAgICB2YXIgaXRlcmF0ZVBhcmVudHMgPSBmdW5jdGlvbiBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcblxuICAgICAgICBpZiAocGFyZW50UmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFJlZltpXTtcbiAgICAgICAgICAgIHBhcmVudHNbcGFyZW50XSA9IHRydWU7XG4gICAgICAgICAgICBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGZpbmRQYXJlbnQgPSBmdW5jdGlvbiBmaW5kUGFyZW50KHBhcmVudHMsIGNoaWxkKSB7XG4gICAgICAgIHZhciBwYXJlbnRSZWYgPSBfdGhpczEyLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2VbY2hpbGRdO1xuXG4gICAgICAgIGlmIChwYXJlbnRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50UmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50UmVmW2ldO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50c1twYXJlbnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3VuZFBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgIHdpdGhDaGlsZDogY2hpbGRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJyYW5jaCA9IGZpbmRQYXJlbnQocGFyZW50cywgcGFyZW50KTtcblxuICAgICAgICAgICAgaWYgKGJyYW5jaC5mb3VuZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmRQYXJlbnQ6IG51bGwsXG4gICAgICAgICAgd2l0aENoaWxkOiBjaGlsZFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgY2hpbGRBKTtcbiAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudHMsIGNoaWxkQik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3RyYXRlZ3kgcGF0dGVybiBmb3IgaGFuZGxpbmcgdGhlIGNvb3JkaW5hdGVzIGdpdmVuIHRoZSBjdXJyZW50IGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpbmRpdmlkdWFsIGluc3RhbmNlcyBjb250YWluIGFsbCB0aGUgb3BlcmF0aW9ucyBhbmQgZGF0YSBzcGVjaWZpYyB0byBhIGxheW91dCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RVcGRhdGU9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERpcmVjdGlvblN0cmF0ZWd5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERpcmVjdGlvblN0cmF0ZWd5KCkge1xuICAgICAgdmFyIGlzVmVydGljYWwgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJVRFwiIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIkRVXCI7XG5cbiAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlcnRpY2FsU3RyYXRlZ3kodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBIb3Jpem9udGFsU3RyYXRlZ3kodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIGEgYnJhbmNoIGZyb20gdGhlIHBhc3NlZCBsaXN0IG9mIGNoaWxkIG5vZGVzXG4gICAgICpcbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGUgcG9zaXRpb25zIG9mIGFsbCB0aGUgY2hpbGQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlfHZpcy5Ob2RlLmlkPn0gY2hpbGROb2RlcyAgQXJyYXkgb2YgZWl0aGVyIGNoaWxkIG5vZGVzIG9yIG5vZGUgaWQnc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDZW50ZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2VudGVyUG9zaXRpb24oY2hpbGROb2Rlcykge1xuICAgICAgdmFyIG1pblBvcyA9IDFlOTtcbiAgICAgIHZhciBtYXhQb3MgPSAtMWU5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpXS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIGNoaWxkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGUpO1xuICAgICAgICBtaW5Qb3MgPSBNYXRoLm1pbihtaW5Qb3MsIHBvc2l0aW9uKTtcbiAgICAgICAgbWF4UG9zID0gTWF0aC5tYXgobWF4UG9zLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwLjUgKiAobWluUG9zICsgbWF4UG9zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF5b3V0RW5naW5lO1xufSgpO1xuXG52YXIgY3NzXzI0OHogPSBcImRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiB7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG5cXG4gIGJvcmRlci13aWR0aDogMDtcXG4gIGJvcmRlci1ib3R0b206IDFweDtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6ICNkNmQ5ZDg7XFxuICBiYWNrZ3JvdW5kOiAjZmZmZmZmOyAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNmZmZmZmYgMCUsXFxuICAgICNmY2ZjZmMgNDglLFxcbiAgICAjZmFmYWZhIDUwJSxcXG4gICAgI2ZjZmNmYyAxMDAlXFxuICApOyAvKiBGRjMuNisgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxuICAgIGxpbmVhcixcXG4gICAgbGVmdCB0b3AsXFxuICAgIGxlZnQgYm90dG9tLFxcbiAgICBjb2xvci1zdG9wKDAlLCAjZmZmZmZmKSxcXG4gICAgY29sb3Itc3RvcCg0OCUsICNmY2ZjZmMpLFxcbiAgICBjb2xvci1zdG9wKDUwJSwgI2ZhZmFmYSksXFxuICAgIGNvbG9yLXN0b3AoMTAwJSwgI2ZjZmNmYylcXG4gICk7IC8qIENocm9tZSxTYWZhcmk0KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2ZmZmZmZiAwJSxcXG4gICAgI2ZjZmNmYyA0OCUsXFxuICAgICNmYWZhZmEgNTAlLFxcbiAgICAjZmNmY2ZjIDEwMCVcXG4gICk7IC8qIENocm9tZTEwKyxTYWZhcmk1LjErICovXFxuICBiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2ZmZmZmZiAwJSxcXG4gICAgI2ZjZmNmYyA0OCUsXFxuICAgICNmYWZhZmEgNTAlLFxcbiAgICAjZmNmY2ZjIDEwMCVcXG4gICk7IC8qIE9wZXJhIDExLjEwKyAqL1xcbiAgYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZmZmZmZmIDAlLFxcbiAgICAjZmNmY2ZjIDQ4JSxcXG4gICAgI2ZhZmFmYSA1MCUsXFxuICAgICNmY2ZjZmMgMTAwJVxcbiAgKTsgLyogSUUxMCsgKi9cXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXG4gICAgdG8gYm90dG9tLFxcbiAgICAjZmZmZmZmIDAlLFxcbiAgICAjZmNmY2ZjIDQ4JSxcXG4gICAgI2ZhZmFmYSA1MCUsXFxuICAgICNmY2ZjZmMgMTAwJVxcbiAgKTsgLyogVzNDICovXFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj0nI2ZmZmZmZicsIGVuZENvbG9yc3RyPScjZmNmY2ZjJyxHcmFkaWVudFR5cGU9MCApOyAvKiBJRTYtOSAqL1xcblxcbiAgcGFkZGluZy10b3A6IDRweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMjhweDtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtZWRpdC1tb2RlLFxcbmRpdi52aXMtbmV0d29yayBidXR0b24udmlzLWVkaXQtbW9kZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiA1cHg7XFxuICBoZWlnaHQ6IDMwcHg7XFxufVxcblxcbi8qIEZJWE1FOiBzaG91bGRuJ3QgdGhlIHZpcy1jbG9zZSBidXR0b24gYmUgYSBjaGlsZCBvZiB0aGUgdmlzLW1hbmlwdWxhdGlvbiBkaXY/ICovXFxuXFxuZGl2LnZpcy1uZXR3b3JrIGJ1dHRvbi52aXMtY2xvc2Uge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMzBweDtcXG4gIGhlaWdodDogMzBweDtcXG5cXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMjBweCAzcHg7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFjQUFBQUhDQVlBQUFERVVsZlRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBRHZHYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZ284ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMalV0WXpBeU1TQTNPUzR4TlRRNU1URXNJREl3TVRNdk1UQXZNamt0TVRFNk5EYzZNVFlnSUNBZ0lDQWdJQ0krQ2lBZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SStDaUFnSUNBZ0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbmh0Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZlRzF3VFUwOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXRiUzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25OMFJYWjBQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2YzFSNWNHVXZVbVZ6YjNWeVkyVkZkbVZ1ZENNaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9tUmpQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012Wld4bGJXVnVkSE12TVM0eEx5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjR2h2ZEc5emFHOXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNCb2IzUnZjMmh2Y0M4eExqQXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenAwYVdabVBTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM1JwWm1Zdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02WlhocFpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzlsZUdsbUx6RXVNQzhpUGdvZ0lDQWdJQ0FnSUNBOGVHMXdPa055WldGMGIzSlViMjlzUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzaHRjRHBEY21WaGRHOXlWRzl2YkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBEY21WaGRHVkVZWFJsUGpJd01UUXRNREl0TVRSVU1URTZOVFU2TXpVck1ERTZNREE4TDNodGNEcERjbVZoZEdWRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4ZUcxd09rMWxkR0ZrWVhSaFJHRjBaVDR5TURFMExUQXlMVEUwVkRFeU9qQTFPakUzS3pBeE9qQXdQQzk0YlhBNlRXVjBZV1JoZEdGRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4ZUcxd09rMXZaR2xtZVVSaGRHVStNakF4TkMwd01pMHhORlF4TWpvd05Ub3hOeXN3TVRvd01Ed3ZlRzF3T2sxdlpHbG1lVVJoZEdVK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwSmJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNk5qVTBZbU01WW1RdE1XSTJZaTFqWWpSaExUbGxPV1F0TldZMk16Z3hORFZqWmprMFBDOTRiWEJOVFRwSmJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlJHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qazRNbU0yTUdJd0xXVXpaak10TURrME1DMDRNalUwTFRGaVpUbGlOV0UwWlRFNE16d3ZlRzF3VFUwNlJHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qazRNbU0yTUdJd0xXVXpaak10TURrME1DMDRNalUwTFRGaVpUbGlOV0UwWlRFNE16d3ZlRzF3VFUwNlQzSnBaMmx1WVd4RWIyTjFiV1Z1ZEVsRVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlNHbHpkRzl5ZVQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwVFpYRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbU55WldGMFpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRvNU9ESmpOakJpTUMxbE0yWXpMVEE1TkRBdE9ESTFOQzB4WW1VNVlqVmhOR1V4T0RNOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ESXRNVFJVTVRFNk5UVTZNelVyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pJeE9EWXhObU0yTFRNMU1XTXROREkwT1MwNFlXRmtMV0prWkRRMlpUY3pOV0UwTkR3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TkMwd01pMHhORlF4TVRvMU5Ub3pOU3N3TVRvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbU5vWVc1blpXUStMend2YzNSRmRuUTZZMmhoYm1kbFpENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBuTmhkbVZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZOalUwWW1NNVltUXRNV0kyWWkxallqUmhMVGxsT1dRdE5XWTJNemd4TkRWalpqazBQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTBMVEF5TFRFMFZERXlPakExT2pFM0t6QXhPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2VTJWeFBnb2dJQ0FnSUNBZ0lDQThMM2h0Y0UxTk9raHBjM1J2Y25rK0NpQWdJQ0FnSUNBZ0lEeGtZenBtYjNKdFlYUSthVzFoWjJVdmNHNW5QQzlrWXpwbWIzSnRZWFErQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBqTThMM0JvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUNXpVa2RDSUVsRlF6WXhPVFkyTFRJdU1Ud3ZjR2h2ZEc5emFHOXdPa2xEUTFCeWIyWnBiR1UrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGpFOEwzUnBabVk2VDNKcFpXNTBZWFJwYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lNREF3TUM4eE1EQXdNRHd2ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajRLSUNBZ0lDQWdJQ0FnUEhScFptWTZXVkpsYzI5c2RYUnBiMjQrTnpJd01EQXdMekV3TURBd1BDOTBhV1ptT2xsU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwU1pYTnZiSFYwYVc5dVZXNXBkRDR5UEM5MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwRGIyeHZjbE53WVdObFBqRThMMlY0YVdZNlEyOXNiM0pUY0dGalpUNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpjOEwyVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcFFhWGhsYkZsRWFXMWxibk5wYjI0K056d3ZaWGhwWmpwUWFYaGxiRmxFYVcxbGJuTnBiMjQrQ2lBZ0lDQWdJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQZ29nSUNBOEwzSmtaanBTUkVZK0Nqd3ZlRHA0YlhCdFpYUmhQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBbzhQM2h3WVdOclpYUWdaVzVrUFNKM0lqOCtjWlVaTXdBQUFDQmpTRkpOQUFCNkpRQUFnSU1BQVBuL0FBQ0E2UUFBZFRBQUFPcGdBQUE2bUFBQUYyK1NYOFZHQUFBQTJFbEVRVlI0MmdETEFEVC9BUzB0TFVRRkJRVVZGeGNYdFBIeDhmUGw1ZVVOQ0FnSVRDa3BLZXNFSHg4ZkdnWUdCakgrL3Y0YStQajRxZ1FFQkZVNk9qb2RNVEV4endRVUZCU3ZFQkFRRWZYMTlTRDE5ZlZxTkRRMENFbEpTZC85L2YydkF3RUJBZnJuNStma0J3Y0hMUllXRmdzWEZ4ZnoyOXZibzlMUzB1d0REUTBORGZQejgxb3JLeXNYSXlNaitPRGc0QXZoNGVFYS9mMzkxZ01rSkNSWVB6OC9LVWhJU09NQ0FnS2g4Zkh4SFJzYkd4NFVGQlFRQkRrNU9lWTdPenY3Q0FnSXRQYjI5dk1FQkFTYUpTVWxUUTBORGVzREFFd3BUMEtvOFJpMkFBQUFBRWxGVGtTdVFtQ0MnKTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBidXR0b24udmlzLWNsb3NlOmhvdmVyIHtcXG4gIG9wYWNpdHk6IDAuNjtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uLFxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLWVkaXQtbW9kZSBidXR0b24udmlzLWJ1dHRvbiB7XFxuICBmbG9hdDogbGVmdDtcXG4gIGZvbnQtZmFtaWx5OiB2ZXJkYW5hO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwcHggMHB4O1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGhlaWdodDogMjRweDtcXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcGFkZGluZzogMHB4IDhweCAwcHggOHB4O1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uOmhvdmVyIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uOmFjdGl2ZSB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDhweCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbi52aXMtYmFjayB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmdBQUFBWUNBWUFBQURnZHozNEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFFRU9hVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnbzhlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqVXRZekF5TVNBM09TNHhOVFE1TVRFc0lESXdNVE12TVRBdk1qa3RNVEU2TkRjNk1UWWdJQ0FnSUNBZ0lDSStDaUFnSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0NpQWdJQ0FnSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uaHRjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSRmRuUTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpVVjJaVzUwSXlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uQm9iM1J2YzJodmNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzl3YUc5MGIzTm9iM0F2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVY0YVdZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZaWGhwWmk4eExqQXZJajRLSUNBZ0lDQWdJQ0FnUEhodGNEcERjbVZoZEc5eVZHOXZiRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nS0ZkcGJtUnZkM01wUEM5NGJYQTZRM0psWVhSdmNsUnZiMncrQ2lBZ0lDQWdJQ0FnSUR4NGJYQTZRM0psWVhSbFJHRjBaVDR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzk0YlhBNlEzSmxZWFJsUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTlpYUmhaR0YwWVVSaGRHVStNakF4TkMwd01pMHdORlF4TlRvd01Ub3dPU3N3TVRvd01Ed3ZlRzF3T2sxbGRHRmtZWFJoUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTmIyUnBabmxFWVhSbFBqSXdNVFF0TURJdE1EUlVNVFU2TURFNk1Ea3JNREU2TURBOEwzaHRjRHBOYjJScFpubEVZWFJsUGdvZ0lDQWdJQ0FnSUNBOFpHTTZabTl5YldGMFBtbHRZV2RsTDNCdVp6d3ZaR002Wm05eWJXRjBQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPbUkyWWpRd01qVmtMVEF4TmpRdE16VTBPQzFoT1RkbExUUTRabVl4TVdNM05UWXpNend2ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pa1J2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZlRzF3VFUwNlJHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5NGJYQk5UVHBQY21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K1kzSmxZWFJsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRVYyZERwcGJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmQyaGxiajR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzl6ZEVWMmREcDNhR1Z1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1ExTTJJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG5OaGRtVmtQQzl6ZEVWMmREcGhZM1JwYjI0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwcGJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNlJVRTJNRUV5TkVVeE9UZzBSVE14TVVGRVFVWkZSa1UyUlVNek16TkZNRE04TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURFdE1qTlVNVGs2TVRnNk1EY3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEVXpZZ0tGZHBibVJ2ZDNNcFBDOXpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZMmhoYm1kbFpENHZQQzl6ZEVWMmREcGphR0Z1WjJWa1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzSmtaanBzYVQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K2MyRjJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tbHVjM1JoYm1ObFNVUStlRzF3TG1scFpEcG1PV1EzT0dZNFpDMWxOelkwTFRjMU5EZ3RPRFppTnkxaU5tUTFPR016WkRnMk9UYzhMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREl0TURSVU1UVTZNREU2TURrck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwamFHRnVaMlZrUGk4OEwzTjBSWFowT21Ob1lXNW5aV1ErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajVqYjI1MlpYSjBaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStabkp2YlNCaGNIQnNhV05oZEdsdmJpOTJibVF1WVdSdlltVXVjR2h2ZEc5emFHOXdJSFJ2SUdsdFlXZGxMM0J1Wnp3dmMzUkZkblE2Y0dGeVlXMWxkR1Z5Y3o0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG1SbGNtbDJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStZMjl1ZG1WeWRHVmtJR1p5YjIwZ1lYQndiR2xqWVhScGIyNHZkbTVrTG1Ga2IySmxMbkJvYjNSdmMyaHZjQ0IwYnlCcGJXRm5aUzl3Ym1jOEwzTjBSWFowT25CaGNtRnRaWFJsY25NK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1ellYWmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09tSTJZalF3TWpWa0xUQXhOalF0TXpVME9DMWhPVGRsTFRRNFptWXhNV00zTlRZek16d3ZjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uZG9aVzQrTWpBeE5DMHdNaTB3TkZReE5Ub3dNVG93T1Nzd01Ub3dNRHd2YzNSRmRuUTZkMmhsYmo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21Ob1lXNW5aV1ErTHp3dmMzUkZkblE2WTJoaGJtZGxaRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ1BDOTRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThjM1JTWldZNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09tWTVaRGM0Wmpoa0xXVTNOalF0TnpVME9DMDRObUkzTFdJMlpEVTRZek5rT0RZNU56d3ZjM1JTWldZNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbVJ2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZjM1JTWldZNlpHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbTl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRkpsWmpwdmNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEd3ZlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMCtDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2UTI5c2IzSk5iMlJsUGpNOEwzQm9iM1J2YzJodmNEcERiMnh2Y2sxdlpHVStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2U1VORFVISnZabWxzWlQ1elVrZENJRWxGUXpZeE9UWTJMVEl1TVR3dmNHaHZkRzl6YUc5d09rbERRMUJ5YjJacGJHVStDaUFnSUNBZ0lDQWdJRHgwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQakU4TDNScFptWTZUM0pwWlc1MFlYUnBiMjQrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbGhTWlhOdmJIVjBhVzl1UGpjeU1EQTVNQzh4TURBd01Ed3ZkR2xtWmpwWVVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQSFJwWm1ZNldWSmxjMjlzZFhScGIyNCtOekl3TURrd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpFOEwyVjRhV1k2UTI5c2IzSlRjR0ZqWlQ0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dFUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3haUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXVVJwYldWdWMybHZiajRLSUNBZ0lDQWdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtDaUFnSUR3dmNtUm1PbEpFUmo0S1BDOTRPbmh0Y0cxbGRHRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0Nqdy9lSEJoWTJ0bGRDQmxibVE5SW5jaVB6NGpxMVUvQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFWVFNVUkJWSGphbkZWZlRGTm5GUCtkNzd2ZThxZVZGYkJycGNWZ1JyQ1JGaWtGQnlMeHdTQWFFMzJvUkNIRDZKTXh4aGhuOEcyUnh4SDNNc09UYnlZc21DQXhQTW1NTVl0a0lVWW1LNjBPTzBxQUsyM0JGbE5vYjB1aDN4N1dTNWpMWlBwTGJtNitrL1A5enJtNXY5ODU1UEY0VUZoWUNBQmdqSUV4QmdBZ0lxUlNxUklpNmdEUVJrUTFSR1RCM3dnUjBlOEFIZ0g0U2EvWFIvRUJpQWlKUkFKMDRjSUY1T2ZuZzRnMm4wZ2tVa3hFTndGMGM4NDNMekhHUUVRUVFrQ0xFeEVBOUFMb3RWZ3NVUUFRUW1nTlFoSkNiRjVrakNFVUNsMG1vajR0NW5hN2ZUVTFOVXBWVlZYVVlyRWtBU0FjRGhlOGVmT214T2Z6V1NjbUpxb0JkQk5SOTlMUzBoV3oyZHluTlNTRUFGMjhlQkdGaFlWZ2pDRWNEbjlIUkQxRWhJTUhEM285SHM5a1dWbFpBaDlCS0JRcUdCNGVkcjU4K2RLWis2SmJKcE9wQndCV1YxZkI2K3JxSU1zeUlwSElGY1pZTDJNTXJhMnRZNWN1WFJyZnVYTm5CdHZBWURCazNHNjNvcXBxWm01dXpncmdTREtaakJvTWh1ZVpUQWJjNVhJaEZvdVZFdEZUeGhpT0hUczJkdjc4ZVM4K0VmdjM3NCtvcXBxWm5aMjFjczVQSkpQSlBsbVdreXlubkJ1TU1UUTBOSGk3dXJvK21WeUR4K1B4dWx3dTcxWk9sa3FsU29ub0poR2h2YjM5czhrMW5EeDUwc3M1aHlSSk45UHBkS2xFUkIyYVdqU1ZhRWlsVXZ6Qmd3Y09SVkVzNWVYbG9YUG56azFzVjhCa01pVWREb2ZQNy9kWFo3UFpEaWxuSWh3NGNHQmVTMXBiVzJQMzd0MXpCd0tCaWtRaVVVUkVXRmhZc0hITzBkN2V2bTBSdTkwKy8rclZxMnJPK1hHSmlKeEVoTXJLeWhnQWpJNk9Xb2VIaDV0V1ZsYSs0SnpEWnJPOWJXNXVuaHdjSEd6eisvMzJucDRlK3hhRGJmb0hBTXhtYzZpam8yTzBvcUlpSmtrU05qWTJIQklSbVJsak1Kdk55V2ZQbmxuNysvdFBNTVpRWGw2KzBOYlc5cUsydGpZY2o4ZmxvYUVocUtwcStIQ2tiRDNQek13WUJnWUcwTlhWOVV1dXNGbmEya0VnRUxBUUVRNGRPdlNpczdQek40MUFyOWRucmwyN05xQ05rdi9DM2J0M3p5NHRMVm1JQ0p4ekVCRkpSQlFtb3JMRnhjV0NxcXFxMFBqNGVPM1kySmhiVVpUZHJhMnRMMnByYThPSlJHTEhuVHQzemtxUzlLK2h1SFU0RWhITVpuTW9HbzBXNU9JaDduSzVqakxHS3ExVzY5dkRodzhyUnFNeE1qYzN0MnQ1ZVhuWDVPUmtsYy9uTStmbDVTV25wcWErMHV2MUsvbjUrV3M2blc1Tmx1WE5kMTVlM3BwT3AxdXoyV3l6Wjg2Y0dRMEdnNlpBSUZDWnpXWi9sWWpva1JEaXVOL3Z0N1cwdE13M05UVXBicmQ3OFA3OSsrNWdNRmdSaVVUS0hqNThXTVlZUTNWMTlldFRwMDV0cTZMcDZXa2I1eHhDaUVmYzdYWlBNOGE2RnhjWFRmWDE5YS8xZW4yR2N5NXFhbXJlTmpZMi9xR3E2am9SWmUxMis5VHAwNmUzSlkvRllnV1BIejgrbWh2cjMvQ1dscGJrK3ZwNlBtT3NlV1ZsQlM2WFM5R1NKVWtTZHJzOTNORFE4T2UrZmZ2Qy84ZkpJeU1qZGRGbzlFc2k2cFZsZVZqVDJtMEE4SHE5enFHaEllZm5qb2tuVDU0NEE0R0FNL2VEYnhNUmVGTlRFMHBLU3BLcXFzYUk2UGo4L0x4VlZkV00zVzZQZkNyNXhNVEUxemxsWFMwdUxuNmFTcVhBR3hzYm9kUHBvTmZybjZ1cUNzNzVFVVZSckpGSVpNZmV2WHNYZFRyZHhzZUlFNG1FUERJeVV1LzMrK3R5bmQ4eUdvMjlSSVIwT2cyNmZ2MDZpb3FLd0JnRDV4enYzcjI3ekJqckl5SklrZ1NId3pGWldWbXA3Tm16SjFaYVdwb0FnR2cwV3Fnb1N2SE16SXcxR0F3NnR2amhpdEZvN05QVzVmdjM3MEhkM2Qwb0tDZ0E1M3pUUU12THkrVkNpS3VTSkgwclNkTG16dFp5dElXdjVSUFJEMFQwWTNGeDhkeldmYnk2dWdvcEhvLy93NG1jYzhpeVBNYzV2NUZPcDcvUFpyT2RRb2hXSW5JQzJDMkVnQkJpZ1lpOFFvaWZzOWxzdjA2bld5SWlhRnhhZ1hnOGpyOEdBR3h1SWU3TEJlV2hBQUFBQUVsRlRrU3VRbUNDJyk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBkaXYudmlzLW5vbmU6aG92ZXIge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCA4cHggcmdiYSgwLCAwLCAwLCAwKTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGRpdi52aXMtbm9uZTphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCA4cHggcmdiYSgwLCAwLCAwLCAwKTtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGRpdi52aXMtbm9uZSB7XFxuICBwYWRkaW5nOiAwcHg7XFxuICBsaW5lLWhlaWdodDogMjNweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGRpdi5ub3RpZmljYXRpb24ge1xcbiAgbWFyZ2luOiAycHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1hZGQge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJnQUFBQVlDQVlBQUFEZ2R6MzRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBRUVPYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZ284ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMalV0WXpBeU1TQTNPUzR4TlRRNU1URXNJREl3TVRNdk1UQXZNamt0TVRFNk5EYzZNVFlnSUNBZ0lDQWdJQ0krQ2lBZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SStDaUFnSUNBZ0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbmh0Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZaR005SW1oMGRIQTZMeTl3ZFhKc0xtOXlaeTlrWXk5bGJHVnRaVzUwY3k4eExqRXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUkZkblE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVVYyWlc1MEl5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbkJvYjNSdmMyaHZjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5d2FHOTBiM05vYjNBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZEdsbVpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzkwYVdabUx6RXVNQzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T21WNGFXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2WlhocFppOHhMakF2SWo0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBEY21WaGRHOXlWRzl2YkQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTBNZ0tGZHBibVJ2ZDNNcFBDOTRiWEE2UTNKbFlYUnZjbFJ2YjJ3K0NpQWdJQ0FnSUNBZ0lEeDRiWEE2UTNKbFlYUmxSR0YwWlQ0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5NGJYQTZRM0psWVhSbFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5aWFJoWkdGMFlVUmhkR1UrTWpBeE5DMHdNaTB3TkZReE5EbzBNRG95T1Nzd01Ub3dNRHd2ZUcxd09rMWxkR0ZrWVhSaFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5iMlJwWm5sRVlYUmxQakl3TVRRdE1ESXRNRFJVTVRRNk5EQTZNamtyTURFNk1EQThMM2h0Y0RwTmIyUnBabmxFWVhSbFBnb2dJQ0FnSUNBZ0lDQThaR002Wm05eWJXRjBQbWx0WVdkbEwzQnVaend2WkdNNlptOXliV0YwUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2U1c1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pWa05XSXdObVF3TFRWbU1qQXRPR0UwTkMxaE16SXdMV1ptTVRFek16UXdORGMwWWp3dmVHMXdUVTA2U1c1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2tSdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOTRiWEJOVFRwUGNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtZM0psWVhSbFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBuTmhkbVZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZSVUUyTUVFeU5FVXhPVGcwUlRNeE1VRkVRVVpGUmtVMlJVTXpNek5GTURNOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ERXRNak5VTVRrNk1UZzZNRGNyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFV6WWdLRmRwYm1SdmQzTXBQQzl6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WTJoaGJtZGxaRDR2UEM5emRFVjJkRHBqYUdGdVoyVmtQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMM0prWmpwc2FUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtjMkYyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbWx1YzNSaGJtTmxTVVErZUcxd0xtbHBaRG8yT1dWbVlXRTFOUzAxWlRJNUxUSXpOR1V0WVRVek15MHhORGt4WWpNMU5ETm1ZbUU4TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURJdE1EUlVNVFE2TkRBNk1qa3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzTjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGphR0Z1WjJWa1BpODhMM04wUlhaME9tTm9ZVzVuWldRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1amIyNTJaWEowWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWm5KdmJTQmhjSEJzYVdOaGRHbHZiaTkyYm1RdVlXUnZZbVV1Y0dodmRHOXphRzl3SUhSdklHbHRZV2RsTDNCdVp6d3ZjM1JGZG5RNmNHRnlZVzFsZEdWeWN6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBtUmxjbWwyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWTI5dWRtVnlkR1ZrSUdaeWIyMGdZWEJ3YkdsallYUnBiMjR2ZG01a0xtRmtiMkpsTG5Cb2IzUnZjMmh2Y0NCMGJ5QnBiV0ZuWlM5d2JtYzhMM04wUlhaME9uQmhjbUZ0WlhSbGNuTStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNXpZWFpsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPalZrTldJd05tUXdMVFZtTWpBdE9HRTBOQzFoTXpJd0xXWm1NVEV6TXpRd05EYzBZand2YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbmRvWlc0K01qQXhOQzB3TWkwd05GUXhORG8wTURveU9Tc3dNVG93TUR3dmMzUkZkblE2ZDJobGJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblErUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tTm9ZVzVuWldRK0x6d3ZjM1JGZG5RNlkyaGhibWRsWkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdQQzk0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPalk1WldaaFlUVTFMVFZsTWprdE1qTTBaUzFoTlRNekxURTBPVEZpTXpVME0yWmlZVHd2YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT21SdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2YzNSU1pXWTZaRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT205eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEZKbFpqcHZjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHd2ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjArQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBqTThMM0JvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUNXpVa2RDSUVsRlF6WXhPVFkyTFRJdU1Ud3ZjR2h2ZEc5emFHOXdPa2xEUTFCeWIyWnBiR1UrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGpFOEwzUnBabVk2VDNKcFpXNTBZWFJwYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lNREE1TUM4eE1EQXdNRHd2ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajRLSUNBZ0lDQWdJQ0FnUEhScFptWTZXVkpsYzI5c2RYUnBiMjQrTnpJd01Ea3dMekV3TURBd1BDOTBhV1ptT2xsU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwU1pYTnZiSFYwYVc5dVZXNXBkRDR5UEM5MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwRGIyeHZjbE53WVdObFBqRThMMlY0YVdZNlEyOXNiM0pUY0dGalpUNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WlJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV1VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrQ2lBZ0lEd3ZjbVJtT2xKRVJqNEtQQzk0T25odGNHMWxkR0UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDancvZUhCaFkydGxkQ0JsYm1ROUluY2lQejVXS3FwOUFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBWVhTVVJCVkhqYWZGWnRVRlRYR1g3ZTl6MjdzdmV1TUN3WVY4RWxyQTdZU0ZZSHRKVVBrYWFJMGFScUc4d1AwMHpVemxqRElOTlNBLzJST3RwTzI0U3huYWhseGpZZDdTU2ptVWt5bWN4WWxEaFFQekhHaXNFVnA4SHdZV0NWVlZnRXNyc3VMbkw3NCs1dXFURjlaKzdjTy9kOFBPOTV6dk84NTFCbFpTVjBYUWNBTURPWUdRQkFSRGhYM0pSbU1EWVp3TFBNV0F6R0hBQ1lJZ3dTNDZvQk5CTnd0T0w4Q3dFOEVrU0VVQ2dFMnJKbEMydzJHNGdvOFp3by9iTURnbm9HNmd4TGZBQUFZdlBETUNDc3pLVEFNSUFHQWhyV25mMTVBQUFNd3dBUklSS0pnRFp2M2d5NzNRNGlBalBqeElyOVZWT01SaGJBWUtCOHp2ck8wbGxyZkVzZEt3TFplazZZQVBTRnZ0U3UzR3RMYXd1MFpKNjYyNVNIR0JRQjFUODh0Nk14dm9wZ01BamF1blVyZEYwSE0rUDR5djI3RE1ZZUptQjFScVczSm5mM3RRWDJwMEw0UDlFWHVxRWQ3UG1EcCtYdU1VOXNSYnZYbm50MVR4eEFDZ29LWUxWYWNienNRRFVKR2tTQVRlNnFpMjh1UHR6dXNNNkt4aWU2TkhMR1VYM2x4VlVOWDlTdFBIbm40d3kzbmp1VVljdTZuMnBOaTY2YXZjRVhuQnlQL252OGFpYUl5cnF6MmdPNUE5KzlGSTFHSWZuNStXaFpkVEFkakZNa3dNdlpPeTd1V25UQU96M0w0WWs3MW0zdDY5ZmRmVERvVUdUQmVIVFVmaUhRNmxvN1oyT1hKdnBEQUNoS2UrYU9DZEtSS1d4WjIrMXFiM3l5ZDNHWW1Sa1E3R1FCVnM5OXdmdjZvbjNlUjJrNFBkVGtERWJIN0l1Uzgvc3ZsZC81NjFQSlMvcERrMS9iend4OTRwemU3eGM1di9IK1lQWTZyNUJBa2RySnpPRFRLNDZsRTZQZVlFSnQ3dSs4aitPWndDQmlFQWdBb05nS0pvRVFmNlB2TnZkclhndFpvTmhTZjdxMEtaM0IyQVFtVk16ZTBKbXQ1NFMvRGNEQ1ZpZzJOY3ZFVUd4SkFFNFBsK1lPcjBpdjZCUlNJUEFtQmVCWkFtSGxFMnNINHAxdWhycTFzME1ubkVRTUJzZjh3UkFTQUlDUVFDQ0lUTjFYNy9zT3VjMGtnT1ZwMy9mUHMyV0h2K2NvRzdnUU9KVW5MR3NVQ1R4RWpQelVvaEVBK05mSVdVZHR4MCtlZnpBMWtTU2tJR3lCQVFOQ0tnSEFFQkFKM3U3OVU3a2lBY1dvZW0vZ2I1RmQzM25ySDNrcCtTTVd0dUFCK0dsbE1KeE1qQ3g5UVJnQTN1aXFMNWt3SGlUbHB4YjNzbWxmTURHWUdQUDFoY01Ba0p2czhTY3BmZEpzcGRqK01LNlBmKzUrdTI5dnliNGxSNCtCR0V6aVZFU0FrRXB3NkF2MU9oVXBIQ3o0cU9YYnpGV3o0TmNkai92L28wOEx0OTJPRERnWkRDRUZKWW9VR0g0bXp1Z1A5MnB1UFRmMHBEM0g3d3ZmZEZaZHFTeG5NdFdqb0dBQW1HOWZPTHhqd2VzZGpUMi9YeklRN2tzM3N5Y1lNU0V3R0hOdFdmNWJrWDVOa1lDSkJ4VUJYaUdWMFhIdm9zT3Q1NFpleTMzai9LKzhQMzMrK3ZqbmJpR0piYkxFK0o5U0FOQWI2bkoyQjc5d2NVd0VUQXdRUTdmTWpQek12ZlA4amE4N0hVSUtNT2lhQXFNWmhyR21MZEF5NzhlWnJ3d3NUUzBlT2JUcytJZHRnVmFueEJVRXhxR2JiNVZ6cklJU0dJb1VYc21xYmdFaEpsZENRV3FSZjI3U3ZQQW4vbzhYbWdMaFpzVWtSNGxsMzdtaGszbjk0WjRPbHpZLzdOTGNZWmZtN28xejJ6VDR2c3ZVTlNYcXByQkNrbWlURmJQWDkwL2ZoOEdJVDJzZit6VFBkRE1mNGRWbk5nNHorRTBpeHNHZUJzOWpkNVZpU2dMSGpDYi9wZWFSK01EM2Q0L1pKZzJsbHl1RzJWd3k3UVdBczhQTm5uMWY3dmtHU0d4QXpFNm1rK2t4a3gvcC80dW5mZlNDUjBoQW9MMUVCQ1lpUE5kV05jd2tOUVRDUjdmZVdYNmcrN2YvQTdJOHJjdy9VNlVFZTBOZHJoYy9XN210TDl6dG1xbFNnc3RTUy96VEoyOGRhbHBPcGtScnlyd2Jod0JBQ2dzTE1XUEdET1Q0bGwzcXllcUFrSlRkQ0Y3UC9DclVZL0drTEwxckUrMmhUYlNIOCswTGIvV0V1aHpoeWFBOTA1YmxmOVZkLzg5NVduWndMSHJQZXZpci9jdk9CMW9MWXBUdExybTZvWUdJTURFeEFhcXRyVVZLU2dxWUdTS0NrMFdIcTVpa2tXRVd0TkwwaW12NXFVVytSY2xMUmpKc3JoQkF1SDEvUUw4UjdIUjR4eTVuZXNjdVAyM0U2aE9BNm1MditzYjR1VHc2T2dxcXE2dURwbWtRa2NTdG9yWDRYUmNNMUZqWitrdkZGakNKS1UxV3BrTkpKVXFJTXRYMVJ5TGVYM0p0UTBKUmhtR1laL0wyN2R1Um5KeWN1RkdJU09KOXBxaDVsckI2aVlncUdPeFJyT2FhNTREY1ptS3ZrSnhrOEpIQzlyS2grS1ZoT3NENCtEaitNd0FESWY4bjVtNHhHd0FBQUFCSlJVNUVya0pnZ2c9PScpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b24udmlzLWVkaXQsXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtZWRpdC1tb2RlIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1lZGl0IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCZ0FBQUFZQ0FZQUFBRGdkejM0QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUVFT2FWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGdvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWlCNE9uaHRjSFJyUFNKQlpHOWlaU0JZVFZBZ1EyOXlaU0ExTGpVdFl6QXlNU0EzT1M0eE5UUTVNVEVzSURJd01UTXZNVEF2TWprdE1URTZORGM2TVRZZ0lDQWdJQ0FnSUNJK0NpQWdJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrQ2lBZ0lDQWdJRHh5WkdZNlJHVnpZM0pwY0hScGIyNGdjbVJtT21GaWIzVjBQU0lpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWdvZ0lDQWdJQ0FnSUNBZ0lDQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25Cb2IzUnZjMmh2Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOXdhRzkwYjNOb2IzQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9tVjRhV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdlpYaHBaaTh4TGpBdklqNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwRGNtVmhkRzl5Vkc5dmJENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1EwTWdLRmRwYm1SdmQzTXBQQzk0YlhBNlEzSmxZWFJ2Y2xSdmIydytDaUFnSUNBZ0lDQWdJRHg0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOTRiWEE2UTNKbFlYUmxSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOWlhSaFpHRjBZVVJoZEdVK01qQXhOQzB3TWkwd05WUXhORG94TWpveU5Tc3dNVG93TUR3dmVHMXdPazFsZEdGa1lYUmhSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOYjJScFpubEVZWFJsUGpJd01UUXRNREl0TURWVU1UUTZNVEk2TWpVck1ERTZNREE4TDNodGNEcE5iMlJwWm5sRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4WkdNNlptOXliV0YwUG1sdFlXZGxMM0J1Wnp3dlpHTTZabTl5YldGMFBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qWTVPVE0zWkdaakxUSmpOelF0WVRVMFlTMDVPVEl6TFRReU1tWmhORE5rTWpsak5Ed3ZlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmVHMXdUVTA2Ukc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2s5eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzk0YlhCTlRUcFBjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHg0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrWTNKbFlYUmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRFVjJkRHBwYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2ZDJobGJqNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOXpkRVYyZERwM2FHVnVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMklDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbk5oZG1Wa1BDOXpkRVYyZERwaFkzUnBiMjQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBwYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2UlVFMk1FRXlORVV4T1RnMFJUTXhNVUZFUVVaRlJrVTJSVU16TXpORk1ETThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREV0TWpOVU1UazZNVGc2TURjck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRVellnS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrYzJGMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRvek9XTmhOekU1WkMwM1l6TmxMVFV5TkdFdFltWTFOUzAzTkdWbU1tTTFNekUwWVRjOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ESXRNRFZVTVRRNk1USTZNalVyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBqYUdGdVoyVmtQaTg4TDNOMFJYWjBPbU5vWVc1blpXUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNWpiMjUyWlhKMFpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1puSnZiU0JoY0hCc2FXTmhkR2x2Ymk5MmJtUXVZV1J2WW1VdWNHaHZkRzl6YUc5d0lIUnZJR2x0WVdkbEwzQnVaend2YzNSRmRuUTZjR0Z5WVcxbGRHVnljejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbVJsY21sMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1kyOXVkbVZ5ZEdWa0lHWnliMjBnWVhCd2JHbGpZWFJwYjI0dmRtNWtMbUZrYjJKbExuQm9iM1J2YzJodmNDQjBieUJwYldGblpTOXdibWM4TDNOMFJYWjBPbkJoY21GdFpYUmxjbk0rQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pZNU9UTTNaR1pqTFRKak56UXRZVFUwWVMwNU9USXpMVFF5TW1aaE5ETmtNamxqTkR3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TkMwd01pMHdOVlF4TkRveE1qb3lOU3N3TVRvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbU5vWVc1blpXUStMend2YzNSRmRuUTZZMmhoYm1kbFpENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnUEM5NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOGMzUlNaV1k2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pNNVkyRTNNVGxrTFRkak0yVXROVEkwWVMxaVpqVTFMVGMwWldZeVl6VXpNVFJoTnp3dmMzUlNaV1k2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmMzUlNaV1k2Wkc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRGSmxaanB2Y21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR3dmVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQak04TDNCb2IzUnZjMmh2Y0RwRGIyeHZjazF2WkdVK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDV6VWtkQ0lFbEZRell4T1RZMkxUSXVNVHd2Y0dodmRHOXphRzl3T2tsRFExQnliMlpwYkdVK0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2s5eWFXVnVkR0YwYVc5dVBqRThMM1JwWm1ZNlQzSnBaVzUwWVhScGIyNCtDaUFnSUNBZ0lDQWdJRHgwYVdabU9saFNaWE52YkhWMGFXOXVQamN5TURBNU1DOHhNREF3TUR3dmRHbG1aanBZVW1WemIyeDFkR2x2Ymo0S0lDQWdJQ0FnSUNBZ1BIUnBabVk2V1ZKbGMyOXNkWFJwYjI0K056SXdNRGt3THpFd01EQXdQQzkwYVdabU9sbFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFNaWE52YkhWMGFXOXVWVzVwZEQ0eVBDOTBhV1ptT2xKbGMyOXNkWFJwYjI1VmJtbDBQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcERiMnh2Y2xOd1lXTmxQakU4TDJWNGFXWTZRMjlzYjNKVGNHRmpaVDRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV0VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFpSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQWdJRHd2Y21SbU9sSkVSajRLUEM5NE9uaHRjRzFsZEdFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2p3L2VIQmhZMnRsZENCbGJtUTlJbmNpUHo0eWtuaW5BQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQVlwU1VSQlZIamFmRlp0VEZ2bkZYN09lYStOdWRpWTJId2FtNENCbGdRd1hkS1JFREtVb1lnMGpiUkoyOVJKMlZaMW1qUkZVeFNwQTNWVGZrekpma1FiUzdzcFU2cnR4NVoyVXRwcFNjamFIeHZMdWlhdFdpMmpMRW9NSVVEQ2gyM2cyZ2JqNyt0UHVQdmhPdXJhd1BsMWRjOTluK2M1NXozM2ZWNDZjZUlFWkZrR0FEQXppQWdBUUVSb2UvOVpLNEdQTS9BY2dic0lYQWNBQkNnTXZrZkFxQWE4OWVEb0p5RjhMb2dJcXFxQ2hvYUdZREFZSHI4a0l0Uzh1YzhpSUg2aUFhOUlrQW81RUFRWDhwcW1nVVZCQ0JnZ1lGZ0RodjAvR0FzQmdLWnBJQ0prTWhuUTRPQWdaRmtHRVlHWlVYbXArMGNTK0NLQndXQTBEVlJQT2c1WmwycTZ6YUh5SmxuVkFNUVhWVGt3SHJVcUgwWHN2bit0ZFFBQU1RRGdwUExTMk1WaUZZOHJrR1Vaekl6YVMvdC94cUN6R2dndHo5ZTY5N3pzbktob0xVdGltNGpPcS9MRTZ4N1gwbnNoMTZkRVo1YS9PM2EyU0NBT0hqd0luVTZIdWpkNlRoSjRtQ0RRK2IyRzIzMnY3djZ2d2FyUGJRbjhNR2xNcitYMGtwRTNXcjVadDVoTDVIUGhxWVNkUUlmS0oreWh4RFBLV0M2WGcranQ3VVhENWI1S0J0MWtDSFM4NUxqZDgvT24zTnVwZm5oRmFaajRyV2ZmMUI5OEIxUi9oblVtS2QzNmJkdENObDRnMGVuNGVkTkUvY1h3THE4cU1UTUlQQVF3bW8vV3VIdk9iQTgrOWM1OGsvZEt0RDBUeVpXWE41WUdBN2VqN2VwS3hzcE0vLzdTb05PZFdjL0p5cTJ3aXdoRHpQeFQ4Y1AwanlzM1ZNTTdPbUwwLzc3em40WWR1aTNiOHVpSzBqRDdSckE3N2M5V2Q1N2NlZlBwRisyVDZiV3NGUFdrYWlQVENXdlRzWnBIRlUrWHJTKzhHM0FSMDhGNlgrMUZKdkJ4UVF6SFFPV2syU21yVzRGUFgvVTJMVndQdURaaitmSktsMmtoUHBleUFxQTlyelIvWXF3dWlXWFg4dGFOL0NhYkdrclZ1cTlZSmxrUVFEak9BSjVqQWh6OVZ0OVc0TjUvck5wOEkrdnRNVi9hWm00ekxuVU5OdDB1cmRZbkY2OEhXb0pqNFdvMW1MR1VOUnI4TEVnRGdOcWVDaDh4UUlLT3NnQzdpQWpWZTgzclQ5elFhOHVOTTI4dTcwa3NwZXNzdThxOHpxL1YzTmNacFZ6YjkrMHptVmhPdnZ2cmhhTVZ6ckpnMHplcTd4TVZDQ3dkcG5XU0dCcWpVeUp3TFRGZ2J2eGllM3czMXVvV1IxWTc0cjYwcmR4WnFyUjhxODV0MlcyTUdDcDEyYm0vS0MzaHlhU1RpTWh4dUdyS2NhaHFwYmpPYURPb0VoT0VvRnFKUUNDSnZxQTg1STZiZlRkRGpRbGYybGJ4Vk5sUzZ3dDE5eXk3alJIWlpsRG5yaW5Oai82c0hNaG5OdzJPZ2NvN083OWU1Zm0veFF5d1JCQkNFQXV3bjRnUTk2YmtZajRWeXVxOU4xWjNCajRPZDViczBNWHQvZFpaMjFjdGlxRmFuMTc0cTk4NVArTGZwK1UxZzdYRE9OLzFjdFA0NThXbFZqTHlKaE9JU1pFMHdNMFMxUWZ1UkMzbFRqa0pBS0tFdE5DOWVJT2hTaDl4SExaT0pSWlRGdVhEc0VvU3RMa1IvNzY4dW1tc2FKRzlQYjlvZSs5Sit4YWVTVm9raVFEU0pwaEFvNXVhQnVXamlLUDRRVHFTMWNVV1U3YXllc042Nnd1MjJmckQxdm1WVzZHVzZUOHU5ZVZqR3laenMrdzc4TnF1MGEybWJ2VnUxS0VKUUFnZVpSTDBsaVFZeXgrR09tS2VRcHUwck1Zc0FKUE5FRkdEMmRMb2RMSXk2YzlZczdHOHllU1VsM3RmMi9YM3JjQlZKU092MzRsM3NDQm9naTd6MUxIL3JCSGpsNElKOTMvbmNRRkFuamVJbUpEMFo4enVDd3U5cTNkakRYcVRsQUtJRDV4dis5dDJSOG44VmNVRkJsalE4R3lmZTQwQllCTTREd0RMdDhLdWU3OVpjRmtiemZFZGJVYnYrb040YzlLVHRzZm0xTWJZUXFxaCsyenJWWllLcy83RWYrYnlpbXQxUE9ZaUpoRGhQQkZCSWlJRVhoeGZzNy9kZllvSUYrYXVCZllURS9wZWJ4L1Y4aHFCUDJPRHZEMzR5dnVoL1dDQW1VNzVCeDZzSWdhSS92NSs2UFY2SkxxVXNZcjdkcERBb2VoczBoNzNwSFRXcnZLZ1RoWWJSU3Q5VW1TamVmM01wYVV2Qno0TzcyVW1BRGdUT1BKZ3VHaVpvcisvSHlVbEpXQm1KRnorRDh4VHRsVWlPcGJ3cG1ybXJ3ZWVTWHJUK2cxMWs0U0JOM1JHS1VjQVZDVmRGaHlQMW5yZURiWS8vTlB5RVhVbFUvUHA0WFl5Y0dUNlYwVXgyV3dXZE83Y09aU1dsa0lJOGRpWDdTUFBOZ0RhS2RieG9OQXh3QVRCQUVrRUVnU1dDRVFBcVBBTXdxdk1kQ0V3TU8wdFZxWnBXc0dUVDU4K0RhUFIrUGhHSVlRQUFBZ2gwUDdCM2lvVy9CMGlHaUNHaXdYYkN1T0hGU0p5czZBYllGeWUyVCt4V2hUM1dZSkVJb0gvRFFCTXcza2VzOE9KUGdBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtZWRpdC1tb2RlIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1lZGl0LnZpcy1lZGl0LW1vZGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZjZmNmYztcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbi52aXMtY29ubmVjdCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmdBQUFBWUNBWUFBQURnZHozNEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFFRU9hVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnbzhlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqVXRZekF5TVNBM09TNHhOVFE1TVRFc0lESXdNVE12TVRBdk1qa3RNVEU2TkRjNk1UWWdJQ0FnSUNBZ0lDSStDaUFnSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0NpQWdJQ0FnSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uaHRjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSRmRuUTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpVVjJaVzUwSXlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uQm9iM1J2YzJodmNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzl3YUc5MGIzTm9iM0F2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVY0YVdZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZaWGhwWmk4eExqQXZJajRLSUNBZ0lDQWdJQ0FnUEhodGNEcERjbVZoZEc5eVZHOXZiRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nS0ZkcGJtUnZkM01wUEM5NGJYQTZRM0psWVhSdmNsUnZiMncrQ2lBZ0lDQWdJQ0FnSUR4NGJYQTZRM0psWVhSbFJHRjBaVDR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzk0YlhBNlEzSmxZWFJsUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTlpYUmhaR0YwWVVSaGRHVStNakF4TkMwd01pMHdORlF4TkRvek9EbzFOeXN3TVRvd01Ed3ZlRzF3T2sxbGRHRmtZWFJoUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTmIyUnBabmxFWVhSbFBqSXdNVFF0TURJdE1EUlVNVFE2TXpnNk5UY3JNREU2TURBOEwzaHRjRHBOYjJScFpubEVZWFJsUGdvZ0lDQWdJQ0FnSUNBOFpHTTZabTl5YldGMFBtbHRZV2RsTDNCdVp6d3ZaR002Wm05eWJXRjBQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamxtWWpVd01EVTBMV0UzT0RFdE1XUTBPQzA1WlRsbExUVTJaV1E1WXpobFlqZGpOand2ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pa1J2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZlRzF3VFUwNlJHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5NGJYQk5UVHBQY21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K1kzSmxZWFJsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRVYyZERwcGJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmQyaGxiajR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzl6ZEVWMmREcDNhR1Z1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1ExTTJJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG5OaGRtVmtQQzl6ZEVWMmREcGhZM1JwYjI0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwcGJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNlJVRTJNRUV5TkVVeE9UZzBSVE14TVVGRVFVWkZSa1UyUlVNek16TkZNRE04TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURFdE1qTlVNVGs2TVRnNk1EY3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEVXpZZ0tGZHBibVJ2ZDNNcFBDOXpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZMmhoYm1kbFpENHZQQzl6ZEVWMmREcGphR0Z1WjJWa1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzSmtaanBzYVQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K2MyRjJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tbHVjM1JoYm1ObFNVUStlRzF3TG1scFpEbzNaV1JoTWpJME1DMHlZVFF4TFRObE5EUXRZV00yTXkxaU56TmlZVEU1T1dJM1kyRThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREl0TURSVU1UUTZNemc2TlRjck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwamFHRnVaMlZrUGk4OEwzTjBSWFowT21Ob1lXNW5aV1ErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajVqYjI1MlpYSjBaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStabkp2YlNCaGNIQnNhV05oZEdsdmJpOTJibVF1WVdSdlltVXVjR2h2ZEc5emFHOXdJSFJ2SUdsdFlXZGxMM0J1Wnp3dmMzUkZkblE2Y0dGeVlXMWxkR1Z5Y3o0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG1SbGNtbDJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStZMjl1ZG1WeWRHVmtJR1p5YjIwZ1lYQndiR2xqWVhScGIyNHZkbTVrTG1Ga2IySmxMbkJvYjNSdmMyaHZjQ0IwYnlCcGJXRm5aUzl3Ym1jOEwzTjBSWFowT25CaGNtRnRaWFJsY25NK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1ellYWmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qbG1ZalV3TURVMExXRTNPREV0TVdRME9DMDVaVGxsTFRVMlpXUTVZemhsWWpkak5qd3ZjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uZG9aVzQrTWpBeE5DMHdNaTB3TkZReE5Eb3pPRG8xTnlzd01Ub3dNRHd2YzNSRmRuUTZkMmhsYmo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21Ob1lXNW5aV1ErTHp3dmMzUkZkblE2WTJoaGJtZGxaRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ1BDOTRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThjM1JTWldZNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qZGxaR0V5TWpRd0xUSmhOREV0TTJVME5DMWhZell6TFdJM00ySmhNVGs1WWpkallUd3ZjM1JTWldZNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbVJ2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZjM1JTWldZNlpHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbTl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRkpsWmpwdmNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEd3ZlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMCtDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2UTI5c2IzSk5iMlJsUGpNOEwzQm9iM1J2YzJodmNEcERiMnh2Y2sxdlpHVStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2U1VORFVISnZabWxzWlQ1elVrZENJRWxGUXpZeE9UWTJMVEl1TVR3dmNHaHZkRzl6YUc5d09rbERRMUJ5YjJacGJHVStDaUFnSUNBZ0lDQWdJRHgwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQakU4TDNScFptWTZUM0pwWlc1MFlYUnBiMjQrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbGhTWlhOdmJIVjBhVzl1UGpjeU1EQTVNQzh4TURBd01Ed3ZkR2xtWmpwWVVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQSFJwWm1ZNldWSmxjMjlzZFhScGIyNCtOekl3TURrd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpFOEwyVjRhV1k2UTI5c2IzSlRjR0ZqWlQ0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dFUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3haUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXVVJwYldWdWMybHZiajRLSUNBZ0lDQWdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtDaUFnSUR3dmNtUm1PbEpFUmo0S1BDOTRPbmh0Y0cxbGRHRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0Nqdy9lSEJoWTJ0bGRDQmxibVE5SW5jaVB6NHVieHMrQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFVdFNVUkJWSGphakpaL2JOVDFHY2Rmei9QNTNQVjZCNFc3Vmx0THFkQWFwbElPaU1Pb3l4eEpDU3MvR3YveUI0Z3pKcm9Bb3NtbURrbHdrWVdSMGJRc2Rta3lrb29qVHBjc1dZTHhEL2xSWmRNUWtUSFJ0a0xaUnFHMHRJVmU3NjYydlR1NDNuMzJ4L1ZLWi9qaDg5Y24zOC96dk43UDUvbDg4endmMmJsekp6NmZEd0FSUVVTbTFuOHMzMUNNMC9WQW5iTm1zVVB1QXNEcGdFTytCZzRDNy8vaXl2NWh2bU1pUWlxVlFwcWFtdkI2dlZOd0VlRzFKWnRDQnJZaS9NcmtBd0ROZ2pod0FsYnpJQ0JMQTByRGIwKy84MzlDNlhRYWFXeHNwTEN3OERwODZjYk5tcVZGSlFkZEU2S3pkalo5RDg5ZytCNmZTeUNPY3luMW54aWwrTzl4S2c1SHFXRlNIR1hManJQN1cvSUNxVlFLMmJObkR6NmZEeEZoNjVLTnZ4YkhEaEY0ckpqMmJYUG8rSUdmY1c1aDV4TDRmOTlQK0ZDRU1JQW9iNzV4OXQwZEFNbGtFbE5YVjRlMWx0ZVhiTnFpUW9NYWVPRk9qcmRVODY4U0QybHVZeUVQNmRVaCtzWW1TSGVPVTZHTzVaOFZMeDUrTk5aeElwUEo1QVMyTDN1cFJPQ29Ddno4TG83dm5rZjc3Y0FIaHBpei96SUw5dld6OEw4cC9OdnVwbU0wUTdwam5Bb0xxejh0RHJjOE1uUXFZVlVWaFZkRjRMRWc3YitydkRuOHdERGxIMFdvUHB1a0xKSW1TQmFNd2pjSnFtd1d0czJqUFpMRy84a3dZVkZlVmRYWFpjRmY0eVZEYzJjTktmQkZtRDlYKzBuY0NQNThGNDhlRytGZW8yQ0FVa3ZzNGRsMFYvdUp2ZFhMaWlWK3V0KytuN1lMU2Z4UGZNTUc1NENoekIzV0llc1ZXQjJpODJidzFBUjZmSlI3QzRWc2ZZaXY2dS9rM0E5bkVnUDR6WGtlOERpWUh5QU9NSytReFBJZ25aOUdxU0hyMWl0UUo4REsyZlRlckRRK1MvYkhSWFFKYUhTQ3dOSVoyWGgrNytTM1ZBbXdOTUJBL3R1UFp0RXJnS3F1VW1kTVdJRmxSVVJ2ZGFtUk5FWEd3SVdybFA0N3BUTXpMaXVueGdoR013VEx2Y1RXbEhBcDc3czRRTlNyWU1RdHNzNlpNZ1dxQ201Y0hvREhPMW5iazZLOHpFTjgrM3phdHYySG4xYjU5RXFKWmR4bVlVRVJnOVA5S3dwSWlBT1RkV1VXQlh1THpCL3ZaRzNQMVVuNFBOcDJkMU1ibXlENDVUV0N4dUNzUW0weDU2YkhHSEZZRVp3eG9rN3RvQUE5U2Z3M2hDY29ML05Pd2k5UU81d21XTzFqNEpFZ1p4VGtvZG1jV1JHa2YzcGNYMHI4eG9BYUJpeEt1NFU1L3h3bmRNKzB0cEF2UzZtUCtQWksybmIxVUJ2UEVLd0tNTER2UGo0RVNHYzU1bEd5MzAzc2RKS1FkWkIycmtNZGN0QUIvNGd6TisvUTJFTk5kNEx5VWkveE4rYlR0cXVYMnRoazVuazR3STNnQUYrT01OY0ExbkZRRGZLK0JZNUdxYmt3V2FiVFk1UVpoWFdsbk54MW50clkxUno4N2Z1dncyOW0vU244SitQVUdBRmo1VDE5YmFBMUlzcHVCWnA3Y3gxeDRTd0cxY0VmK2xnUlNST3M4akd3YitIdDRRQi9HU1NzQWhZYW5vMzlMV0lCeE5FSWJQMTRoUER1aXlTMlZ0SnVIWFFsS0t2eE0vamlYRHEvRC94UGx3aWZHTWtKWkIyTklvS3ByNjlueGVpWnhMSGljRlNGVldmR3FCaWRJUDNMU2pyV2x0RDk0Q3l1ZkYvNGtRZ1B1VnoyTHo5MytkRFJhOWV1NVFROEhnOC9pWGVlK0R5NENLTXM3eHFuNG53S3o5SWlyaFFxbVZ1QjQybThleSt4N0xNb0Q2aUFPTjc4MmVDaGhxbVJ1WGZ2WGdLQkFLcUtxdEkwLzhuTktyUUk0QlZZWGt6SGd6UHBDODhnV3VITC9jYVhyaExvR2lOMGFwU0tyMFpaUkJaTTdxMnc1Wm5MUjFvQW5IT01qWTBocmEydEZCUVVZSXlabXN0dlZUMVo2ZURsQXVFVnE3bWVyeG13dWVOUERYeTlQdnliaktQNW1jdEhMazQvWFRLWlJKcWJtL0g3L1ZOdzFWeUVNWWJXNEZOM1dOV25uY2hLb3k1c0hlVkdCUlg2VldpM3ltRng3cjExSXg4TVRYL3k1QzJSU1BDL0FRQjYxZXJvd2JwcVN3QUFBQUJKUlU1RXJrSmdnZz09Jyk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbi52aXMtZGVsZXRlIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCZ0FBQUFZQ0FZQUFBRGdkejM0QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUVFT2FWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGdvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWlCNE9uaHRjSFJyUFNKQlpHOWlaU0JZVFZBZ1EyOXlaU0ExTGpVdFl6QXlNU0EzT1M0eE5UUTVNVEVzSURJd01UTXZNVEF2TWprdE1URTZORGM2TVRZZ0lDQWdJQ0FnSUNJK0NpQWdJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrQ2lBZ0lDQWdJRHh5WkdZNlJHVnpZM0pwY0hScGIyNGdjbVJtT21GaWIzVjBQU0lpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWdvZ0lDQWdJQ0FnSUNBZ0lDQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25Cb2IzUnZjMmh2Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOXdhRzkwYjNOb2IzQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9tVjRhV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdlpYaHBaaTh4TGpBdklqNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwRGNtVmhkRzl5Vkc5dmJENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1EwTWdLRmRwYm1SdmQzTXBQQzk0YlhBNlEzSmxZWFJ2Y2xSdmIydytDaUFnSUNBZ0lDQWdJRHg0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOTRiWEE2UTNKbFlYUmxSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOWlhSaFpHRjBZVVJoZEdVK01qQXhOQzB3TWkwd05GUXhORG8wTVRvd05Dc3dNVG93TUR3dmVHMXdPazFsZEdGa1lYUmhSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOYjJScFpubEVZWFJsUGpJd01UUXRNREl0TURSVU1UUTZOREU2TURRck1ERTZNREE4TDNodGNEcE5iMlJwWm5sRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4WkdNNlptOXliV0YwUG1sdFlXZGxMM0J1Wnp3dlpHTTZabTl5YldGMFBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qYzNORGt6WW1VeExURXlaR0l0T1RnME5DMWlORFl5TFRnMk5HVm1OR0l6TXpNM01Ud3ZlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmVHMXdUVTA2Ukc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2s5eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzk0YlhCTlRUcFBjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHg0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrWTNKbFlYUmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRFVjJkRHBwYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2ZDJobGJqNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOXpkRVYyZERwM2FHVnVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMklDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbk5oZG1Wa1BDOXpkRVYyZERwaFkzUnBiMjQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBwYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2UlVFMk1FRXlORVV4T1RnMFJUTXhNVUZFUVVaRlJrVTJSVU16TXpORk1ETThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREV0TWpOVU1UazZNVGc2TURjck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRVellnS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrYzJGMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRvd05tRTNOV1l3TXkwNE1EZGhMV1V6TkdZdFlqazFaaTFqWkdVMk1qTTBNemc0T0dZOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ESXRNRFJVTVRRNk5ERTZNRFFyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBqYUdGdVoyVmtQaTg4TDNOMFJYWjBPbU5vWVc1blpXUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNWpiMjUyWlhKMFpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1puSnZiU0JoY0hCc2FXTmhkR2x2Ymk5MmJtUXVZV1J2WW1VdWNHaHZkRzl6YUc5d0lIUnZJR2x0WVdkbEwzQnVaend2YzNSRmRuUTZjR0Z5WVcxbGRHVnljejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbVJsY21sMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1kyOXVkbVZ5ZEdWa0lHWnliMjBnWVhCd2JHbGpZWFJwYjI0dmRtNWtMbUZrYjJKbExuQm9iM1J2YzJodmNDQjBieUJwYldGblpTOXdibWM4TDNOMFJYWjBPbkJoY21GdFpYUmxjbk0rQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjM05Ea3pZbVV4TFRFeVpHSXRPVGcwTkMxaU5EWXlMVGcyTkdWbU5HSXpNek0zTVR3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TkMwd01pMHdORlF4TkRvME1Ub3dOQ3N3TVRvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbU5vWVc1blpXUStMend2YzNSRmRuUTZZMmhoYm1kbFpENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnUEM5NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOGMzUlNaV1k2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pBMllUYzFaakF6TFRnd04yRXRaVE0wWmkxaU9UVm1MV05rWlRZeU16UXpPRGc0Wmp3dmMzUlNaV1k2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmMzUlNaV1k2Wkc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRGSmxaanB2Y21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR3dmVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQak04TDNCb2IzUnZjMmh2Y0RwRGIyeHZjazF2WkdVK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDV6VWtkQ0lFbEZRell4T1RZMkxUSXVNVHd2Y0dodmRHOXphRzl3T2tsRFExQnliMlpwYkdVK0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2s5eWFXVnVkR0YwYVc5dVBqRThMM1JwWm1ZNlQzSnBaVzUwWVhScGIyNCtDaUFnSUNBZ0lDQWdJRHgwYVdabU9saFNaWE52YkhWMGFXOXVQamN5TURBNU1DOHhNREF3TUR3dmRHbG1aanBZVW1WemIyeDFkR2x2Ymo0S0lDQWdJQ0FnSUNBZ1BIUnBabVk2V1ZKbGMyOXNkWFJwYjI0K056SXdNRGt3THpFd01EQXdQQzkwYVdabU9sbFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFNaWE52YkhWMGFXOXVWVzVwZEQ0eVBDOTBhV1ptT2xKbGMyOXNkWFJwYjI1VmJtbDBQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcERiMnh2Y2xOd1lXTmxQakU4TDJWNGFXWTZRMjlzYjNKVGNHRmpaVDRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV0VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFpSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQWdJRHd2Y21SbU9sSkVSajRLUEM5NE9uaHRjRzFsZEdFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2p3L2VIQmhZMnRsZENCbGJtUTlJbmNpUHo0YVlKellBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQVlHU1VSQlZIamFsSlo3VUpUbkZjWi83M20vNzJQZEpZMVJiaG9RcDZsa1hSQXZtSVl4ZENVYWRMVk9velBOdEdPYmFwMUpzS2lwamlTaGJkb1JiZUtFaVFIcFFLM3hqMHhhMDNhYW1UYmFUR3lBWVYxUUdlcUZpK0p5aVpGTEFsbUVTQmtXUm1TM2Z5enNsR2ttblo1L3YvTTg3M09lNzV6enZxcW9xQWlielFhQWlLQ1VBa0FwUmRISUsvTkZzeDJOUjkxbk9TSUxBRERvSnl6TmFNNHh4YnR2UEhoMGlDK0ppWWtKMU9IRGg0bUppVUVwRlNYUHYvemlQQzI4VElpWERDT1NyQUNsUURTRXBzQ3dKUElockVCUlFwaVN5dFhsUXdEaGNCaWxGUGZ1M1VNVkZ4ZGp0OXVqRlR6ZmNMQkFEQ29FRUFGcjFaYnJyTmpjaDJ2dEVJbVBCZ0hvYjdmVGNXRStiVlhKTkovTmlGUWxFR0x2aWVYSEttWXFHQjhmUngwNWNnU2J6WWFJc1B2eXdWOHBLRmFBN2ZHdExUeno2MVlXcG8veFZUSFFidWZzcTVsY2V6OXpXdVdoazVtdkZ3TUVnMEgwK3ZYck1VMlRuMXdwM0N0Q2lRNURqR2QzQS9tL3Y4SURDWlA4cjRpTm15UnJXeC9qLzVxa3R5a1pwWEt6QWpWRFZ4UHpHcWVtcHREcjFxMWpYM05SbklKYXJjREtLMmhnUjJVTFhSZm5jdjdVWXY3eHBvdmhuaGlXNU16K2tlZmVTS082TEoxQTF4ekV1ay9Pam00bVJpYnB1WmFNWlczT0N0UlVORDYwTm1pSUNDSVVTaGlzeDdhMnNMTWlRbjRzNzd1RVFnSWFibnFkZkhJbGdUMS9xUWVnOHZzNWRIaGRDTkIxd1luM1JJaUM5OTVqMjZzdGpBYnNOSCtZaVpKQ0VTblMxWS9YeElYdThyNFlJUHYvVmtWczNDVG5UeTJtczM0eHJvMStzcDlwbzZzeGxUdTM0dWx0bXNQVnZ5NmlzODZGQ0hnTytERHM0OXpwanVmQnBDRytzZVlPQzlPSGFUaWRpZWljYjlvdVZBaEt0b3VBc2VJNzEwbWE3cEx1cXdtZ1lmSHFBRnQrNldkTG9RL0xCbDExTG03VnVkQWE4dmI3MlBDaW45VGxBV0lzR0doTEFDRCtrU0FabnVzWUJpaTFYUUFQWVdEbGx0Nm92MmxyQmtEQlIyKzZPZnVhazIvLzNNK0cvVDR3QUFQVzdmUGhLZlJUVmVxazlxUWJGS1JtRFVUeFMzTjdRWUdZbXd6Q2txa2xCR2xQREVjVE52K3NnOXROQ2JUWHV2Qld1akUwYkhyWmo5SkUxQi93VTFQbTVQd0pONllCUzlhMmtWdlFFY1ducmg1R1RGRDNseGtZa3FSTWdZUWx3VmxkVXZEbmVuNzNMSFRVdXFpdGRLTTBlQXI5QUZRZmQxSi95bzJhSm4rMnNuNFdkbjVxRUZPREpza2dCSWp4NVQwdUNyUUEwOHBuSWpTOVBFUkRqUG5mT0tYQU1FQkVDVW9HRUlIQmorMnprdDc2VVE2ZFhoZUdBZXYzK2NnNzRLZjZ1SlBxY2ljYmZ1b25kN2NQeTRTT2l5Nyt0RDluRnZadXJ4MDBLT2szQ05FQyttRSt2alNQQmM3SVdxZ3FUYVBUNjBJTWNPL3hzWEdhM0hmS2pSZ1JkYmw3L0tEZzBqdHViamU2YUhqN2M3SjNkZ0xRMnpvUHd3UTkxU29vT1FkQVcxVktWTUh0eTBrQTVCYjQ4QnljSm4vTGpXRkdiTHY0dGh2dmI1M2tGdmpKK1hFZFdrUGZqUVZSL0NjTktZZ0dNYzhKV3Q1RmEyaitNSVBQdXlJMnBhNElvSFNrdDZ2TEl1UmFROXEzMmtoenQ0R0N4dE51Nms0NkdlaUlSMmxJZkRRUXNhZlB6cTFMR1JHTDlHazlkK3Zyd2V3dmZIUFFPb2V4UVZqeGRCL2F1ay96bWFVTWRzZno2YlZVdElhbFQ3Ynh2ZVAxWkhoNkdQRFBZZVN6ZUQ2OWtjcElmeHltRldMTnJrYStsamhCVFdrV3d6MkppSlQ4NFlIbnoyaVB4MFAyMFBrbVJGNWk2SFlpd1pGSnNuL1l6ZGV6YnpFM2NRaWJZNXhWMjY2ejZSZlhvaGFrYit4QjlDamFuQ0Q5cVRiVzdHcms0V1YzOFZabTBsNmRoUWlFdzl0YUhTdURxclMwRklmRHdYTTNYOW1ITXN2UkFrL3NhdURwUXkzOFArR3R6T1RHQjltRXBrRDBDMmRTOG44ek9qcUs5bmc4V0paRlUrSlRqYXNHdmFDTlhQcHZKQlBvTWxtME9vRE5NZldWeE9OZldOU1VQVVo3VFVRNTZ0Q1psUHdTZ01uSlNWUnBhU214c2JGRTFyYXc4Mlp4QVpaUlFVaUJZVUtHcDVVbE9YMmtyQnptb1VWamlJS2hIZ2U5cmZQbytXY3kzWmVYSVlBU2dMMS9YNVJmTVhNdmo0Nk9vc3JMeTdIWmJHaXRVVW9oSXV6b2VtMFJvZkFMYU9zZ2hnV0dqa3kwTWlKVEw4YjBsT3ZJOGhOMURLWEtQMGpkM1ROVFdEZ2NKaGdNb280ZVBZckQ0WWkrS21hZUxscHJucnRYRm85aC9BQWxHMUFxRTh5Rm1CckMrak8wYmdIOUVWcE8vMUYyRGM1Zy8vT0FzYkV4L2owQWYrVVNzUXluTDFVQUFBQUFTVVZPUks1Q1lJST0nKTtcXG59XFxuLyogdG9wIHJpZ2h0IGJvdHRvbSBsZWZ0ICovXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGRpdi52aXMtbGFiZWwsXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtZWRpdC1tb2RlIGRpdi52aXMtbGFiZWwge1xcbiAgbWFyZ2luOiAwIDAgMCAyM3B4O1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBkaXYudmlzLXNlcGFyYXRvci1saW5lIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDFweDtcXG4gIGhlaWdodDogMjFweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiZGJkYmQ7XFxuICBtYXJnaW46IDBweCA3cHggMCAxNXB4OyAvKnRvcCByaWdodCBib3R0b20gbGVmdCovXFxufVxcblxcbi8qIFRPRE86IGlzIHRoaXMgcmVkdW5kYW50P1xcbmRpdi5uZXR3b3JrLW5hdmlnYXRpb25fd3JhcHBlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcbiovXFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MzI7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MzIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQzMiwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIENsZWFycyB0aGUgdG9vbGJhciBkaXYgZWxlbWVudCBvZiBjaGlsZHJlblxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIE1hbmlwdWxhdGlvblN5c3RlbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9uSGFuZGxlcn0gc2VsZWN0aW9uSGFuZGxlclxuICAgKiBAcGFyYW0ge0ludGVyYWN0aW9uSGFuZGxlcn0gaW50ZXJhY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBNYW5pcHVsYXRpb25TeXN0ZW0oYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyLCBpbnRlcmFjdGlvbkhhbmRsZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBfY29udGV4dCxcbiAgICAgICAgX2NvbnRleHQyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hbmlwdWxhdGlvblN5c3RlbSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBpbnRlcmFjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlID0gW107XG4gICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7XG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW11cbiAgICB9O1xuICAgIHRoaXMuZ3VpRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5Nb2RlID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGluaXRpYWxseUFjdGl2ZTogZmFsc2UsXG4gICAgICBhZGROb2RlOiB0cnVlLFxuICAgICAgYWRkRWRnZTogdHJ1ZSxcbiAgICAgIGVkaXROb2RlOiB1bmRlZmluZWQsXG4gICAgICBlZGl0RWRnZTogdHJ1ZSxcbiAgICAgIGRlbGV0ZU5vZGU6IHRydWUsXG4gICAgICBkZWxldGVFZGdlOiB0cnVlLFxuICAgICAgY29udHJvbE5vZGVTdHlsZToge1xuICAgICAgICBzaGFwZTogXCJkb3RcIixcbiAgICAgICAgc2l6ZTogNixcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICBib3JkZXI6IFwiIzNjM2MzY1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjMDdmOTY4XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwiIzNjM2MzY1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogMlxuICAgICAgfVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9jbGVhbigpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGJpbmQkNihfY29udGV4dCA9IHRoaXMuX3Jlc3RvcmUpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldERhdGFcIiwgYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuX3Jlc3RvcmUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIHNvbWV0aGluZyBjaGFuZ2VzIGluIHRoZSBkYXRhIGR1cmluZyBlZGl0aW5nLCBzd2l0Y2ggYmFjayB0byB0aGUgaW5pdGlhbCBkYXRhbWFuaXB1bGF0aW9uIHN0YXRlIGFuZCBjbG9zZSBhbGwgZWRpdCBtb2Rlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFuaXB1bGF0aW9uU3lzdGVtLCBbe1xuICAgIGtleTogXCJfcmVzdG9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZSgpIHtcbiAgICAgIGlmICh0aGlzLmluTW9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGFsbE9wdGlvbnMsIGdsb2JhbE9wdGlvbnMpIHtcbiAgICAgIGlmIChhbGxPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFsbE9wdGlvbnMubG9jYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlID0gYWxsT3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGdsb2JhbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsbE9wdGlvbnMubG9jYWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZXMgPSBhbGxPcHRpb25zLmxvY2FsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZXMgPSBnbG9iYWxPcHRpb25zLmxvY2FsZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0dXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZWRpdC1tb2RlLiBEcmF3cyB0aGUgRE9NIHJlcXVpcmVkIGFuZCBjbGVhbnMgdXAgYWZ0ZXIgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlKCkge1xuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIEVkaXQgTW9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZUVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYWluIHRvb2xiYXIuIFJlbW92ZXMgZnVuY3Rpb25zIGJvdW5kIHRvIHRoZSBzZWxlY3QgZXZlbnQuIEJpbmRzIGFsbCB0aGUgYnV0dG9ucyBvZiB0aGUgdG9vbGJhci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93TWFuaXB1bGF0b3JUb29sYmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dNYW5pcHVsYXRvclRvb2xiYXIoKSB7XG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTsgLy8gcmVzZXQgZ2xvYmFsIHZhcmlhYmxlc1xuXG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307IC8vIGlmIHRoZSBndWkgaXMgZW5hYmxlZCwgZHJhdyBhbGwgZWxlbWVudHMuXG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MywgX2NvbnRleHQ0O1xuXG4gICAgICAgIC8vIGEgX3Jlc3RvcmUgd2lsbCBoaWRlIHRoZXNlIG1lbnVzXG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHZhciBzZWxlY3RlZE5vZGVDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRFZGdlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkVG90YWxDb3VudCA9IHNlbGVjdGVkTm9kZUNvdW50ICsgc2VsZWN0ZWRFZGdlQ291bnQ7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdmFyIG5lZWRTZXBlcmF0b3IgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpO1xuXG4gICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAxICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlQ291bnQgPT09IDEgJiYgc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmVkaXRFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH0gLy8gcmVtb3ZlIGJ1dHRvbnNcblxuXG4gICAgICAgIGlmIChzZWxlY3RlZFRvdGFsQ291bnQgIT09IDApIHtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPiAwICYmIHRoaXMub3B0aW9ucy5kZWxldGVOb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAwICYmIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG5cblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDMsIHRoaXMpKTsgLy8gcmVmcmVzaCB0aGlzIGJhciBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHNlbGVjdGVkXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoXCJzZWxlY3RcIiwgYmluZCQ2KF9jb250ZXh0NCA9IHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcikuY2FsbChfY29udGV4dDQsIHRoaXMpKTtcbiAgICAgIH0gLy8gcmVkcmF3IHRvIHNob3cgYW55IHBvc3NpYmxlIGNoYW5nZXNcblxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSB0b29sYmFyIGZvciBhZGRpbmcgTm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVNb2RlKCkge1xuICAgICAgdmFyIF9jb250ZXh0NjtcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG5cblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5pbk1vZGUgPSBcImFkZE5vZGVcIjtcblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQ1O1xuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiYWRkRGVzY3JpcHRpb25cIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZERlc2NyaXB0aW9uXCJdKTsgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG5cblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBiaW5kJDYoX2NvbnRleHQ1ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDUsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiY2xpY2tcIiwgYmluZCQ2KF9jb250ZXh0NiA9IHRoaXMuX3BlcmZvcm1BZGROb2RlKS5jYWxsKF9jb250ZXh0NiwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxsIHRoZSBib3VuZCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2YgdGhlIG5vZGUuIFRoZSBub2RlIGhhcyB0byBiZSBzZWxlY3RlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVkaXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXROb2RlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfSAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKVswXTtcblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmluTW9kZSA9IFwiZWRpdE5vZGVcIjtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRlZXBFeHRlbmQoe30sIG5vZGUub3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgZGF0YS54ID0gbm9kZS54O1xuICAgICAgICAgICAgZGF0YS55ID0gbm9kZS55O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdE5vZGUoZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXMyLmluTW9kZSA9PT0gXCJlZGl0Tm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpczIuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJlZGl0Q2x1c3RlckVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0Q2x1c3RlckVycm9yXCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZnVuY3Rpb24gaGFzIGJlZW4gY29uZmlndXJlZCB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2Ygbm9kZXMuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGNvbm5lY3Qgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VNb2RlKCkge1xuICAgICAgdmFyIF9jb250ZXh0OCwgX2NvbnRleHQ5LCBfY29udGV4dDEwLCBfY29udGV4dDExLCBfY29udGV4dDEyO1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiYWRkRWRnZVwiO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDc7XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbXCJlZGdlRGVzY3JpcHRpb25cIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkZ2VEZXNjcmlwdGlvblwiXSk7IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgYmluZCQ2KF9jb250ZXh0NyA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQ3LCB0aGlzKSk7XG4gICAgICB9IC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIGZ1bmN0aW9uc1xuXG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVG91Y2hcIiwgYmluZCQ2KF9jb250ZXh0OCA9IHRoaXMuX2hhbmRsZUNvbm5lY3QpLmNhbGwoX2NvbnRleHQ4LCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ0VuZFwiLCBiaW5kJDYoX2NvbnRleHQ5ID0gdGhpcy5fZmluaXNoQ29ubmVjdCkuY2FsbChfY29udGV4dDksIHRoaXMpKTtcblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnXCIsIGJpbmQkNihfY29udGV4dDEwID0gdGhpcy5fZHJhZ0NvbnRyb2xOb2RlKS5jYWxsKF9jb250ZXh0MTAsIHRoaXMpKTtcblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25SZWxlYXNlXCIsIGJpbmQkNihfY29udGV4dDExID0gdGhpcy5fZmluaXNoQ29ubmVjdCkuY2FsbChfY29udGV4dDExLCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1N0YXJ0XCIsIGJpbmQkNihfY29udGV4dDEyID0gdGhpcy5fZHJhZ1N0YXJ0RWRnZSkuY2FsbChfY29udGV4dDEyLCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uSG9sZFwiLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgdG9vbGJhciB0byBlZGl0IGVkZ2VzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlZGl0RWRnZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEVkZ2VNb2RlKCkge1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc24ndCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfSAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJlZGl0RWRnZVwiO1xuXG4gICAgICBpZiAoX3R5cGVvZih0aGlzLm9wdGlvbnMuZWRpdEVkZ2UpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UuZWRpdFdpdGhvdXREcmFnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMoKVswXTtcblxuICAgICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG5cbiAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBlZGdlLnRvLmlkKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDEzO1xuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiZWRpdEVkZ2VEZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdEVkZ2VEZXNjcmlwdGlvblwiXSk7IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgYmluZCQ2KF9jb250ZXh0MTMgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0MTMsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMoKVswXTtcblxuICAgICAgaWYgKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX2NvbnRleHQxNCwgX2NvbnRleHQxNSwgX2NvbnRleHQxNiwgX2NvbnRleHQxNztcblxuICAgICAgICB2YXIgX2VkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07IC8vIGNyZWF0ZSBjb250cm9sIG5vZGVzXG5cbiAgICAgICAgdmFyIGNvbnRyb2xOb2RlRnJvbSA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUoX2VkZ2UuZnJvbS54LCBfZWRnZS5mcm9tLnkpO1xuXG4gICAgICAgIHZhciBjb250cm9sTm9kZVRvID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShfZWRnZS50by54LCBfZWRnZS50by55KTtcblxuICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVUby5pZCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjb250cm9sTm9kZUZyb20uaWRdID0gY29udHJvbE5vZGVGcm9tO1xuICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChjb250cm9sTm9kZUZyb20uaWQpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbY29udHJvbE5vZGVUby5pZF0gPSBjb250cm9sTm9kZVRvO1xuICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChjb250cm9sTm9kZVRvLmlkKTsgLy8gdGVtcG9yYXJpbHkgb3ZlcmxvYWQgVUkgZnVuY3Rpb25zLCBjbGVhbmVkIHVwIGF1dG9tYXRpY2FsbHkgYmVjYXVzZSBvZiBfdGVtcG9yYXJ5QmluZFVJXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ub3VjaFwiLCBiaW5kJDYoX2NvbnRleHQxNCA9IHRoaXMuX2NvbnRyb2xOb2RlVG91Y2gpLmNhbGwoX2NvbnRleHQxNCwgdGhpcykpOyAvLyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb25cblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVGFwXCIsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uSG9sZFwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdTdGFydFwiLCBiaW5kJDYoX2NvbnRleHQxNSA9IHRoaXMuX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KS5jYWxsKF9jb250ZXh0MTUsIHRoaXMpKTsgLy8gdXNlZCB0byBzZWxlY3QgY29udHJvbCBub2RlXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdcIiwgYmluZCQ2KF9jb250ZXh0MTYgPSB0aGlzLl9jb250cm9sTm9kZURyYWcpLmNhbGwoX2NvbnRleHQxNiwgdGhpcykpOyAvLyB1c2VkIHRvIGRyYWcgY29udHJvbCBub2RlXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdFbmRcIiwgYmluZCQ2KF9jb250ZXh0MTcgPSB0aGlzLl9jb250cm9sTm9kZURyYWdFbmQpLmNhbGwoX2NvbnRleHQxNywgdGhpcykpOyAvLyB1c2VkIHRvIGNvbm5lY3Qgb3IgcmV2ZXJ0IGNvbnRyb2wgbm9kZXNcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uTW91c2VNb3ZlXCIsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgLy8gY3JlYXRlIGZ1bmN0aW9uIHRvIHBvc2l0aW9uIGNvbnRyb2wgbm9kZXMgY29ycmVjdGx5IG9uIG1vdmVtZW50XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCBiZWNhdXNlIHdlIHVzZSB0aGUgdGVtcG9yYXJ5IGJpbmRcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcImJlZm9yZURyYXdpbmdcIiwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBfZWRnZS5lZGdlVHlwZS5maW5kQm9yZGVyUG9zaXRpb25zKGN0eCk7XG5cbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVGcm9tLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnggPSBwb3NpdGlvbnMuZnJvbS54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnkgPSBwb3NpdGlvbnMuZnJvbS55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250cm9sTm9kZVRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udHJvbE5vZGVUby54ID0gcG9zaXRpb25zLnRvLng7XG4gICAgICAgICAgICBjb250cm9sTm9kZVRvLnkgPSBwb3NpdGlvbnMudG8ueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRlbGV0ZSBldmVyeXRoaW5nIGluIHRoZSBzZWxlY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVNlbGVjdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGVkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfSAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJkZWxldGVcIjtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUlkcygpO1xuICAgICAgdmFyIHNlbGVjdGVkRWRnZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKCk7XG4gICAgICB2YXIgZGVsZXRlRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tzZWxlY3RlZE5vZGVzW2ldXS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiZGVsZXRlQ2x1c3RlckVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJkZWxldGVDbHVzdGVyRXJyb3JcIl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkZWxldGVGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIG5vZGVzOiBzZWxlY3RlZE5vZGVzLFxuICAgICAgICAgIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRlbGV0ZUZ1bmN0aW9uLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uKGRhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXMzLmluTW9kZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEuZWRnZXMpO1xuXG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLm5vZGVzKTtcblxuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG5cbiAgICAgICAgICAgICAgX3RoaXMzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcblxuICAgICAgICAgICAgICBfdGhpczMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZGVsZXRlIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKHNlbGVjdGVkRWRnZXMpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9IC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQUklWQVRFICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICAvKipcbiAgICAgKiBkcmF3IG9yIHJlbW92ZSB0aGUgRE9NXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBFbmFibGUgdGhlIEdVSVxuICAgICAgICB0aGlzLmd1aUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVdyYXBwZXJzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVNYW5pcHVsYXRpb25ET00oKTsgLy8gZGlzYWJsZSB0aGUgZ3VpXG5cblxuICAgICAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSBkaXYgb3ZlcmxheXMgdGhhdCBjb250YWluIHRoZSBET01cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlV3JhcHBlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVdyYXBwZXJzKCkge1xuICAgICAgLy8gbG9hZCB0aGUgbWFuaXB1bGF0b3IgSFRNTCBlbGVtZW50cy4gQWxsIHN0eWxpbmcgZG9uZSBpbiBjc3MuXG4gICAgICBpZiAodGhpcy5tYW5pcHVsYXRpb25EaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmNsYXNzTmFtZSA9IFwidmlzLW1hbmlwdWxhdGlvblwiO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICB9IC8vIGNvbnRhaW5lciBmb3IgdGhlIGVkaXQgYnV0dG9uLlxuXG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuY2xhc3NOYW1lID0gXCJ2aXMtZWRpdC1tb2RlXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIH0gLy8gY29udGFpbmVyIGZvciB0aGUgY2xvc2UgZGl2IGJ1dHRvblxuXG5cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF90aGlzJG9wdGlvbnMkbG9jYWxlcywgX3RoaXMkb3B0aW9ucyRsb2NhbGVzMjtcblxuICAgICAgICB0aGlzLmNsb3NlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5jbGFzc05hbWUgPSBcInZpcy1jbG9zZVwiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgKF90aGlzJG9wdGlvbnMkbG9jYWxlcyA9IChfdGhpcyRvcHRpb25zJGxvY2FsZXMyID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV0pID09PSBudWxsIHx8IF90aGlzJG9wdGlvbnMkbG9jYWxlczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMkbG9jYWxlczJbXCJjbG9zZVwiXSkgIT09IG51bGwgJiYgX3RoaXMkb3B0aW9ucyRsb2NhbGVzICE9PSB2b2lkIDAgPyBfdGhpcyRvcHRpb25zJGxvY2FsZXMgOiB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY2xvc2VcIl0pO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlRGl2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgYSBuZXcgdGFyZ2V0IG5vZGUuIFVzZWQgZm9yIGNyZWF0aW5nIG5ldyBlZGdlcyBhbmQgZWRpdGluZyBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TmV3VGFyZ2V0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TmV3VGFyZ2V0Tm9kZSh4LCB5KSB7XG4gICAgICB2YXIgY29udHJvbE5vZGVTdHlsZSA9IGRlZXBFeHRlbmQoe30sIHRoaXMub3B0aW9ucy5jb250cm9sTm9kZVN0eWxlKTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUuaWQgPSBcInRhcmdldE5vZGVcIiArIHY0KCk7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5waHlzaWNzID0gZmFsc2U7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnggPSB4O1xuICAgICAgY29udHJvbE5vZGVTdHlsZS55ID0geTsgLy8gd2UgaGF2ZSB0byBkZWZpbmUgdGhlIGJvdW5kaW5nIGJveCBpbiBvcmRlciBmb3IgdGhlIG5vZGVzIHRvIGJlIGRyYXduIGltbWVkaWF0ZWx5XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNvbnRyb2xOb2RlU3R5bGUpO1xuICAgICAgbm9kZS5zaGFwZS5ib3VuZGluZ0JveCA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgcmlnaHQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgYm90dG9tOiB5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZWRpdCBidXR0b25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFZGl0QnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0QnV0dG9uKCkge1xuICAgICAgdmFyIF9jb250ZXh0MTg7XG5cbiAgICAgIC8vIHJlc3RvcmUgZXZlcnl0aGluZyB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIChpZiBhcHBsaWNhYmxlKVxuICAgICAgdGhpcy5fY2xlYW4oKTsgLy8gcmVzZXQgdGhlIG1hbmlwdWxhdGlvbkRPTVxuXG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307IC8vIGVtcHR5IHRoZSBlZGl0TW9kZURpdlxuXG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7IC8vIGNyZWF0ZSB0aGUgY29udGVudHMgZm9yIHRoZSBlZGl0TW9kZSBidXR0b25cblxuICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE1vZGVcIiwgXCJ2aXMtZWRpdCB2aXMtZWRpdC1tb2RlXCIsIGxvY2FsZVtcImVkaXRcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRcIl0pO1xuXG4gICAgICB0aGlzLmVkaXRNb2RlRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7IC8vIGJpbmQgYSBoYW1tZXIgbGlzdGVuZXIgdG8gdGhlIGJ1dHRvbiwgY2FsbGluZyB0aGUgZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUuXG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MTggPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0MTgsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBjbGVhbnMgdXAgYWZ0ZXIgZXZlcnl0aGluZyB0aGlzIG1vZHVsZSBkb2VzLiBUZW1wb3JhcnkgZWxlbWVudHMsIGZ1bmN0aW9ucyBhbmQgZXZlbnRzIGFyZSByZW1vdmVkLCBwaHlzaWNzIHJlc3RvcmVkLCBoYW1tZXJzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgIC8vIG5vdCBpbiBtb2RlXG4gICAgICB0aGlzLmluTW9kZSA9IGZhbHNlOyAvLyBfY2xlYW4gdGhlIGRpdnNcblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7IC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG5cbiAgICAgICAgdGhpcy5fY2xlYW51cERPTUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9IC8vIHJlbW92ZSB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzXG5cblxuICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTsgLy8gcmVzdG9yZSBvdmVybG9hZGVkIFVJIGZ1bmN0aW9uc1xuXG5cbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeVVJcygpOyAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zXG5cblxuICAgICAgdGhpcy5fdW5iaW5kVGVtcG9yYXJ5RXZlbnRzKCk7IC8vIHJlc3RvcmUgdGhlIHBoeXNpY3MgaWYgcmVxdWlyZWRcblxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzdG9yZVBoeXNpY3NcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhY2ggZG9tIGVsZW1lbnQgaGFzIGl0J3Mgb3duIGhhbW1lci4gVGhleSBhcmUgc3RvcmVkIGluIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy4gVGhpcyBjbGVhbnMgdGhlbSB1cC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW51cERPTUV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwRE9NRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQxOTtcblxuICAgICAgLy8gX2NsZWFuIERPTSBldmVudCBsaXN0ZW5lciBiaW5kaW5nc1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNwbGljZSQxKF9jb250ZXh0MTkgPSB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlKS5jYWxsKF9jb250ZXh0MTksIDApKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgRE9NIGVsZW1lbnRzIGNyZWF0ZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZU1hbmlwdWxhdGlvbkRPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCkge1xuICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgIHRoaXMuX2NsZWFuKCk7IC8vIGVtcHR5IHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuXG5cbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5jbG9zZURpdik7IC8vIHJlbW92ZSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcblxuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGVEaXYpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfSAvLyBzZXQgdGhlIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkXG5cblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgc2VwZXJhdG9yIGxpbmUuIHRoZSBpbmRleCBpcyB0byBkaWZmZXJlbnRpYXRlIGluIHRoZSBtYW5pcHVsYXRpb24gZG9tXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTFdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVTZXBlcmF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVNlcGVyYXRvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiICsgaW5kZXhdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiICsgaW5kZXhdLmNsYXNzTmFtZSA9IFwidmlzLXNlcGFyYXRvci1saW5lXCI7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIiArIGluZGV4XSk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVBZGROb2RlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjA7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJhZGROb2RlXCIsIFwidmlzLWFkZFwiLCBsb2NhbGVbXCJhZGROb2RlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJhZGROb2RlXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQyMCA9IHRoaXMuYWRkTm9kZU1vZGUpLmNhbGwoX2NvbnRleHQyMCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUFkZEVkZ2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMTtcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImFkZEVkZ2VcIiwgXCJ2aXMtY29ubmVjdFwiLCBsb2NhbGVbXCJhZGRFZGdlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJhZGRFZGdlXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQyMSA9IHRoaXMuYWRkRWRnZU1vZGUpLmNhbGwoX2NvbnRleHQyMSwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXROb2RlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIyO1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE5vZGVcIiwgXCJ2aXMtZWRpdFwiLCBsb2NhbGVbXCJlZGl0Tm9kZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdE5vZGVcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDIyID0gdGhpcy5lZGl0Tm9kZSkuY2FsbChfY29udGV4dDIyLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRWRpdEVkZ2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjM7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0RWRnZVwiLCBcInZpcy1lZGl0XCIsIGxvY2FsZVtcImVkaXRFZGdlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0RWRnZVwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MjMgPSB0aGlzLmVkaXRFZGdlTW9kZSkuY2FsbChfY29udGV4dDIzLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRGVsZXRlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyNDtcblxuICAgICAgdmFyIGRlbGV0ZUJ0bkNsYXNzO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkZWxldGVCdG5DbGFzcyA9IFwidmlzLWRlbGV0ZS1ydGxcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUJ0bkNsYXNzID0gXCJ2aXMtZGVsZXRlXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJkZWxldGVcIiwgZGVsZXRlQnRuQ2xhc3MsIGxvY2FsZVtcImRlbFwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZGVsXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQyNCA9IHRoaXMuZGVsZXRlU2VsZWN0ZWQpLmNhbGwoX2NvbnRleHQyNCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUJhY2tCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyNTtcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImJhY2tcIiwgXCJ2aXMtYmFja1wiLCBsb2NhbGVbXCJiYWNrXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJiYWNrXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQyNSA9IHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcikuY2FsbChfY29udGV4dDI1LCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge2xhYmVsfSBsYWJlbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbENsYXNzTmFtZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQnV0dG9uKGlkLCBjbGFzc05hbWUsIGxhYmVsKSB7XG4gICAgICB2YXIgbGFiZWxDbGFzc05hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwidmlzLWxhYmVsXCI7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiRGl2XCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIFwiICsgY2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJMYWJlbFwiXS5jbGFzc05hbWUgPSBsYWJlbENsYXNzTmFtZTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJMYWJlbFwiXS5pbm5lclRleHQgPSBsYWJlbDtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0uYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdKTtcbiAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiRGl2XCJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVEZXNjcmlwdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRGVzY3JpcHRpb24obGFiZWwpIHtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wiZGVzY3JpcHRpb25MYWJlbFwiXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0uY2xhc3NOYW1lID0gXCJ2aXMtbm9uZVwiO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVuZCBvZiBET00gZnVuY3Rpb25zIGZvciBidXR0b25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGJpbmRzIGFuIGV2ZW50IHVudGlsIGNsZWFudXAgYnkgdGhlIGNsZWFuIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0Z1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl90ZW1wb3JhcnlCaW5kRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RlbXBvcmFyeUJpbmRFdmVudChldmVudCwgbmV3RnVuY3Rpb24pIHtcbiAgICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgYm91bmRGdW5jdGlvbjogbmV3RnVuY3Rpb25cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oZXZlbnQsIG5ld0Z1bmN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBvdmVycmlkZXMgYW4gVUkgZnVuY3Rpb24gdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBVSWZ1bmN0aW9uTmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0Z1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl90ZW1wb3JhcnlCaW5kVUlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RlbXBvcmFyeUJpbmRVSShVSWZ1bmN0aW9uTmFtZSwgbmV3RnVuY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbVUlmdW5jdGlvbk5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tVSWZ1bmN0aW9uTmFtZV0gPSB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbVUlmdW5jdGlvbk5hbWVdO1xuICAgICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbVUlmdW5jdGlvbk5hbWVdID0gbmV3RnVuY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIFVJIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LiBUeXBvPyBZb3UgdHJpZWQ6IFwiICsgVUlmdW5jdGlvbk5hbWUgKyBcIiBwb3NzaWJsZSBhcmU6IFwiICsgc3RyaW5naWZ5JDEoa2V5cyQ0KHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdG9yZSB0aGUgb3ZlcnJpZGRlbiBVSSBmdW5jdGlvbnMgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VuYmluZFRlbXBvcmFyeVVJc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5VUlzKCkge1xuICAgICAgZm9yICh2YXIgZnVuY3Rpb25OYW1lIGluIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zLCBmdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW2Z1bmN0aW9uTmFtZV0gPSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZCB0aGUgZXZlbnRzIGNyZWF0ZWQgYnkgX3RlbXBvcmFyeUJpbmRFdmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91bmJpbmRUZW1wb3JhcnlFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ldmVudDtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW2ldLmJvdW5kRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihldmVudE5hbWUsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYW4gaGFtbWVyIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBib3VuZEZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmluZEVsZW1lbnRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRFbGVtZW50RXZlbnRzKGRvbUVsZW1lbnQsIGJvdW5kRnVuY3Rpb24pIHtcbiAgICAgIC8vIEJpbmQgdG91Y2ggZXZlbnRzLlxuICAgICAgdmFyIGhhbW1lciA9IG5ldyBIYW1tZXIoZG9tRWxlbWVudCwge30pO1xuICAgICAgb25Ub3VjaChoYW1tZXIsIGJvdW5kRnVuY3Rpb24pO1xuXG4gICAgICB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW1tZXIuZGVzdHJveSgpO1xuICAgICAgfSk7IC8vIEJpbmQga2V5Ym9hcmQgZXZlbnRzLlxuXG5cbiAgICAgIHZhciBrZXl1cExpc3RlbmVyID0gZnVuY3Rpb24ga2V5dXBMaXN0ZW5lcihfcmVmKSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gX3JlZi5rZXlDb2RlLFxuICAgICAgICAgICAga2V5ID0gX3JlZi5rZXk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCIgfHwga2V5Q29kZSA9PT0gMTMgfHwga2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgICBib3VuZEZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGtleXVwTGlzdGVuZXIsIGZhbHNlKTtcblxuICAgICAgdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5dXBMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lYXRseSBjbGVhbiB1cCB0ZW1wb3JhcnkgZWRnZXMgYW5kIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpIHtcbiAgICAgIC8vIF9jbGVhbiB0ZW1wb3JhcnkgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjY7XG5cbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXS5kaXNjb25uZWN0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dO1xuXG4gICAgICAgIHZhciBpbmRleFRlbXBFZGdlID0gaW5kZXhPZihfY29udGV4dDI2ID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjYsIHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldKTtcblxuICAgICAgICBpZiAoaW5kZXhUZW1wRWRnZSAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQyNztcblxuICAgICAgICAgIHNwbGljZSQxKF9jb250ZXh0MjcgPSB0aGlzLmJvZHkuZWRnZUluZGljZXMpLmNhbGwoX2NvbnRleHQyNywgaW5kZXhUZW1wRWRnZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gX2NsZWFuIHRlbXBvcmFyeSBub2Rlc1xuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9jb250ZXh0Mjg7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV1dO1xuXG4gICAgICAgIHZhciBpbmRleFRlbXBOb2RlID0gaW5kZXhPZihfY29udGV4dDI4ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjgsIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW19pXSk7XG5cbiAgICAgICAgaWYgKGluZGV4VGVtcE5vZGUgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0Mjk7XG5cbiAgICAgICAgICBzcGxpY2UkMShfY29udGV4dDI5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjksIGluZGV4VGVtcE5vZGUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0ge1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGVkZ2VzOiBbXVxuICAgICAgfTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoZSB0b3VjaCBpcyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluaXRpYWwgY2xpY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVUb3VjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVUb3VjaChldmVudCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSBhc3NpZ24kMih7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGRyYWcgc3RhcnQgaXMgdXNlZCB0byBtYXJrIG9uZSBvZiB0aGUgY29udHJvbCBub2RlcyBhcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVEcmFnU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG4gICAgICB2YXIgdG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMV1dO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgdG9TZWxlY3QgPSB0by5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgaWYgKGZyb21TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gZnJvbTtcbiAgICAgICAgZWRnZS5lZGdlVHlwZS5mcm9tID0gZnJvbTtcbiAgICAgIH0gZWxzZSBpZiAodG9TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdG87XG4gICAgICAgIGVkZ2UuZWRnZVR5cGUudG8gPSB0bztcbiAgICAgIH0gLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgc2VsZWN0IGl0IGhlcmUuXG5cblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRyYWdnaW5nIHRoZSBjb250cm9sIG5vZGVzIG9yIHRoZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVEcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWcoZXZlbnQpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJkaXNhYmxlUGh5c2ljc1wiKTtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgcG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueSA9IHBvcy55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ0VuZChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTsgLy8gaWYgdGhlIG5vZGUgdGhhdCB3YXMgZHJhZ2dlZCBpcyBub3QgYSBjb250cm9sIG5vZGUsIHJldHVyblxuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB3ZSB1c2UgdGhlIHNlbGVjdGlvbiB0byBmaW5kIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gV2UgZXhwbGljaXRseSBERXNlbGVjdCB0aGUgY29udHJvbCBub2RlIGhlcmUuXG5cblxuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2RlSWRzW2ldICE9PSB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuXG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJjcmVhdGVFZGdlRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCA9PT0gZnJvbS5pZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKG5vZGUuaWQsIGVkZ2UudG8uaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBub2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UudXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc3RvcmVQaHlzaWNzXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzZWxlY3Rpb24gZXZlbnQuIEl0IGNoZWNrcyBpZiB5b3Ugd2FudCB0byBjb25uZWN0IGEgY2x1c3RlciBhbmQgY2hhbmdlcyB0aGUgZGVzY3JpcHRpb25cbiAgICAgKiB0byB3YWxrIHRoZSB1c2VyIHRocm91Z2ggdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlQ29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ29ubmVjdChldmVudCkge1xuICAgICAgLy8gY2hlY2sgdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTAwKSB7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uID0gYXNzaWduJDIoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuZHJhZy5wb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7IC8vIERyYWcgcG9pbnRlciBpcyBub3QgdXBkYXRlZCB3aGVuIGFkZGluZyBlZGdlc1xuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLmRyYWcudHJhbnNsYXRpb24gPSB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRoZSB0ZW1wb3JhcnkgbGluZSBjYW4gbG9vayBhdFxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKG5vZGUueCwgbm9kZS55KTtcblxuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RhcmdldE5vZGUuaWRdID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKHRhcmdldE5vZGUuaWQpOyAvLyBjcmVhdGUgYSB0ZW1wb3JhcnkgZWRnZVxuXG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe1xuICAgICAgICAgICAgICBpZDogXCJjb25uZWN0aW9uRWRnZVwiICsgdjQoKSxcbiAgICAgICAgICAgICAgZnJvbTogbm9kZS5pZCxcbiAgICAgICAgICAgICAgdG86IHRhcmdldE5vZGUuaWQsXG4gICAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlLFxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGludW91c1wiLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2Nvbm5lY3Rpb25FZGdlLmlkXSA9IGNvbm5lY3Rpb25FZGdlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaCh0YXJnZXROb2RlLmlkKTtcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYWdDb250cm9sTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ0NvbnRyb2xOb2RlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7IC8vIHJlbWVtYmVyIHRoZSBlZGdlIGlkXG5cblxuICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbm5lY3RGcm9tSWQgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZDtcbiAgICAgIH0gLy8gZ2V0IHRoZSBvdmVybGFwcGluZyBub2RlIGJ1dCBOT1QgdGhlIHRlbXBvcmFyeSBub2RlO1xuXG5cbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzMDtcblxuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAoaW5kZXhPZihfY29udGV4dDMwID0gdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMpLmNhbGwoX2NvbnRleHQzMCwgb3ZlcmxhcHBpbmdOb2RlSWRzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnQuY29udHJvbEVkZ2UgPSB7XG4gICAgICAgIGZyb206IGNvbm5lY3RGcm9tSWQsXG4gICAgICAgIHRvOiBub2RlID8gbm9kZS5pZCA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjb250cm9sTm9kZURyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSB0ZW1wIG5vZGUgaW4gdGhlIGFkZCBlZGdlIG1vZGUuXG5cbiAgICAgICAgdGFyZ2V0Tm9kZS54ID0gdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KTtcbiAgICAgICAgdGFyZ2V0Tm9kZS55ID0gdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vbkRyYWcoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRoZSBuZXcgZWRnZSB0byB0aGUgdGFyZ2V0IGlmIG9uZSBleGlzdHMsIG90aGVyd2lzZSByZW1vdmUgdGVtcCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmlzaENvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaENvbm5lY3QoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTsgLy8gcmVtZW1iZXIgdGhlIGVkZ2UgaWRcblxuXG4gICAgICB2YXIgY29ubmVjdEZyb21JZCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdEZyb21JZCA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkO1xuICAgICAgfSAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG5cblxuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG5cbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBfY29udGV4dDMxO1xuXG4gICAgICAgIC8vIGlmIHRoZSBub2RlIGlkIGlzIE5PVCBhIHRlbXBvcmFyeSBub2RlLCBhY2NlcHQgdGhlIG5vZGUuXG4gICAgICAgIGlmIChpbmRleE9mKF9jb250ZXh0MzEgPSB0aGlzLnRlbXBvcmFyeUlkcy5ub2RlcykuY2FsbChfY29udGV4dDMxLCBvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBjbGVhbiB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzLlxuXG5cbiAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7IC8vIHBlcmZvcm0gdGhlIGNvbm5lY3Rpb25cblxuXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY29ubmVjdEZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbbm9kZS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUFkZEVkZ2UoY29ubmVjdEZyb21JZCwgbm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LmNvbnRyb2xFZGdlID0ge1xuICAgICAgICBmcm9tOiBjb25uZWN0RnJvbUlkLFxuICAgICAgICB0bzogbm9kZSA/IG5vZGUuaWQgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY29udHJvbE5vZGVEcmFnRW5kXCIsIGV2ZW50LCBwb2ludGVyKTsgLy8gTm8gbmVlZCB0byBkbyBfZ2VuZXJhdGVjbGlja2V2ZW50KCdkcmFnRW5kJykgaGVyZSwgdGhlIHJlZ3VsYXIgZHJhZ0VuZCBldmVudCBmaXJlcy5cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYWdTdGFydEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdTdGFydEVkZ2UoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPRiBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBlcmZvcm1pbmcgYWxsIHRoZSBhY3R1YWwgZGF0YSBtYW5pcHVsYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBub2RlIG9uIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbGlja0RhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1BZGROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtQWRkTm9kZShjbGlja0RhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIGlkOiB2NCgpLFxuICAgICAgICB4OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueCxcbiAgICAgICAgeTogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLnksXG4gICAgICAgIGxhYmVsOiBcIm5ld1wiXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGROb2RlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNC5pbk1vZGUgPT09IFwiYWRkTm9kZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICBfdGhpczQuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzNC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBhZGQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtQWRkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZEVkZ2Uoc291cmNlTm9kZUlkLCB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIGZyb206IHNvdXJjZU5vZGVJZCxcbiAgICAgICAgdG86IHRhcmdldE5vZGVJZFxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkRWRnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkRWRnZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczUuaW5Nb2RlID09PSBcImFkZEVkZ2VcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgX3RoaXM1LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuXG4gICAgICAgICAgICAgIF90aGlzNS5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM1LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGNvbm5lY3QgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0d28gbm9kZXMgd2l0aCBhIG5ldyBlZGdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBzb3VyY2VOb2RlSWRcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHRhcmdldE5vZGVJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybUVkaXRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtRWRpdEVkZ2Uoc291cmNlTm9kZUlkLCB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIGlkOiB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkLFxuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWQsXG4gICAgICAgIGxhYmVsOiB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXQodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCkubGFiZWxcbiAgICAgIH07XG4gICAgICB2YXIgZWVGdW5jdCA9IHRoaXMub3B0aW9ucy5lZGl0RWRnZTtcblxuICAgICAgaWYgKF90eXBlb2YoZWVGdW5jdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZWVGdW5jdCA9IGVlRnVuY3QuZWRpdFdpdGhvdXREcmFnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVlRnVuY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZWVGdW5jdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBlZUZ1bmN0KGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgPT09IG51bGwgfHwgZmluYWxpemVkRGF0YSA9PT0gdW5kZWZpbmVkIHx8IF90aGlzNi5pbk1vZGUgIT09IFwiZWRpdEVkZ2VcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZWRnZXNbZGVmYXVsdERhdGEuaWRdLnVwZGF0ZUVkZ2VUeXBlKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcblxuICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuXG4gICAgICAgICAgICAgIF90aGlzNi5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hbmlwdWxhdGlvblN5c3RlbTtcbn0oKTtcblxuLyoqXHJcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBvcHRpb25zLiBJdCB3aWxsIGNoZWNrIGlmIHRoZSB0eXBlcyBhcmUgY29ycmVjdCwgaWYgcmVxdWlyZWQgaWYgdGhlIG9wdGlvbiBpcyBvbmVcclxuICogb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlxyXG4gKlxyXG4gKiBfX2FueV9fIG1lYW5zIHRoYXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGRvZXMgbm90IG1hdHRlci5cclxuICogX190eXBlX18gaXMgYSByZXF1aXJlZCBmaWVsZCBmb3IgYWxsIG9iamVjdHMgYW5kIGNvbnRhaW5zIHRoZSBhbGxvd2VkIHR5cGVzIG9mIGFsbCBvYmplY3RzXHJcbiAqL1xudmFyIHN0cmluZyA9IFwic3RyaW5nXCI7XG52YXIgYm9vbCA9IFwiYm9vbGVhblwiO1xudmFyIG51bWJlciA9IFwibnVtYmVyXCI7XG52YXIgYXJyYXkgPSBcImFycmF5XCI7XG52YXIgb2JqZWN0ID0gXCJvYmplY3RcIjsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxuXG52YXIgZG9tID0gXCJkb21cIjtcbnZhciBhbnkgPSBcImFueVwiOyAvLyBMaXN0IG9mIGVuZHBvaW50c1xuXG52YXIgZW5kUG9pbnRzID0gW1wiYXJyb3dcIiwgXCJiYXJcIiwgXCJib3hcIiwgXCJjaXJjbGVcIiwgXCJjcm93XCIsIFwiY3VydmVcIiwgXCJkaWFtb25kXCIsIFwiaW1hZ2VcIiwgXCJpbnZfY3VydmVcIiwgXCJpbnZfdHJpYW5nbGVcIiwgXCJ0cmlhbmdsZVwiLCBcInZlZVwiXTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLSBUaGUgX18qX18gZm9ybWF0IGlzIHVzZWQgdG8gcHJldmVudCBjb2xsaXNpb25zIHdpdGggYWN0dWFsIG9wdGlvbiBuYW1lcy4gKi9cblxudmFyIG5vZGVPcHRpb25zID0ge1xuICBib3JkZXJXaWR0aDoge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IHtcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgYnJva2VuSW1hZ2U6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgY2hvc2VuOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBub2RlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgY29sb3I6IHtcbiAgICBib3JkZXI6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgaGlnaGxpZ2h0OiB7XG4gICAgICBib3JkZXI6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgYm9yZGVyOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9XG4gIH0sXG4gIG9wYWNpdHk6IHtcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgZml4ZWQ6IHtcbiAgICB4OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBmb250OiB7XG4gICAgYWxpZ246IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBmYWNlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc3Ryb2tlQ29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICB2YWRqdXN0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbXVsdGk6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgYm9sZDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1vZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvbGRpdGFsOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRhbDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1vZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vbm86IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH1cbiAgfSxcbiAgZ3JvdXA6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgaGVpZ2h0Q29uc3RyYWludDoge1xuICAgIG1pbmltdW06IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB2YWxpZ246IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9XG4gIH0sXG4gIGhpZGRlbjoge1xuICAgIGJvb2xlYW46IGJvb2xcbiAgfSxcbiAgaWNvbjoge1xuICAgIGZhY2U6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBjb2RlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgd2VpZ2h0OiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGlkOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgaW1hZ2U6IHtcbiAgICBzZWxlY3RlZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIHVuc2VsZWN0ZWQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH1cbiAgfSxcbiAgaW1hZ2VQYWRkaW5nOiB7XG4gICAgdG9wOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9XG4gIH0sXG4gIGxhYmVsOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGxhYmVsSGlnaGxpZ2h0Qm9sZDoge1xuICAgIGJvb2xlYW46IGJvb2xcbiAgfSxcbiAgbGV2ZWw6IHtcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgbWFyZ2luOiB7XG4gICAgdG9wOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9XG4gIH0sXG4gIG1hc3M6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICBwaHlzaWNzOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBzY2FsaW5nOiB7XG4gICAgbWluOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbWF4OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIG1pbjoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG1heFZpc2libGU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkcmF3VGhyZXNob2xkOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjoge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBzaGFkb3c6IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB4OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgeToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgc3RyaW5nOiBbXCJjdXN0b21cIiwgXCJlbGxpcHNlXCIsIFwiY2lyY2xlXCIsIFwiZGF0YWJhc2VcIiwgXCJib3hcIiwgXCJ0ZXh0XCIsIFwiaW1hZ2VcIiwgXCJjaXJjdWxhckltYWdlXCIsIFwiZGlhbW9uZFwiLCBcImRvdFwiLCBcInN0YXJcIiwgXCJ0cmlhbmdsZVwiLCBcInRyaWFuZ2xlRG93blwiLCBcInNxdWFyZVwiLCBcImljb25cIiwgXCJoZXhhZ29uXCJdXG4gIH0sXG4gIGN0eFJlbmRlcmVyOiB7XG4gICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICB9LFxuICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICBib3JkZXJEYXNoZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBhcnJheTogYXJyYXlcbiAgICB9LFxuICAgIGJvcmRlclJhZGl1czoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGludGVycG9sYXRpb246IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHVzZUltYWdlU2l6ZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgdXNlQm9yZGVyV2l0aEltYWdlOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBjb29yZGluYXRlT3JpZ2luOiB7XG4gICAgICBzdHJpbmc6IFtcImNlbnRlclwiLCBcInRvcC1sZWZ0XCJdXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIHNpemU6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICB0aXRsZToge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIGRvbTogZG9tLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICB2YWx1ZToge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICB3aWR0aENvbnN0cmFpbnQ6IHtcbiAgICBtaW5pbXVtOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbWF4aW11bToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgeDoge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIHk6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICBfX3R5cGVfXzoge1xuICAgIG9iamVjdDogb2JqZWN0XG4gIH1cbn07XG52YXIgYWxsT3B0aW9ucyA9IHtcbiAgY29uZmlndXJlOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgZmlsdGVyOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBhcnJheTogYXJyYXksXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBjb250YWluZXI6IHtcbiAgICAgIGRvbTogZG9tXG4gICAgfSxcbiAgICBzaG93QnV0dG9uOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBhcnJheTogYXJyYXksXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfVxuICB9LFxuICBlZGdlczoge1xuICAgIGFycm93czoge1xuICAgICAgdG86IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RyaW5nOiBlbmRQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBpbWFnZVdpZHRoOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RyaW5nOiBlbmRQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VXaWR0aDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlSGVpZ2h0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmcm9tOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlRmFjdG9yOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0cmluZzogZW5kUG9pbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlV2lkdGg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBpbWFnZUhlaWdodDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgc3RyaW5nOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJtaWRkbGVcIl0sXG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmRQb2ludE9mZnNldDoge1xuICAgICAgZnJvbToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHRvOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhc2hlczoge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBhcnJheTogYXJyYXlcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgY2hvc2VuOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgZWRnZToge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaW5oZXJpdDoge1xuICAgICAgICBzdHJpbmc6IFtcImZyb21cIiwgXCJ0b1wiLCBcImJvdGhcIl0sXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXNoZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBhcnJheTogYXJyYXlcbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzdHJva2VDb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGFsaWduOiB7XG4gICAgICAgIHN0cmluZzogW1wiaG9yaXpvbnRhbFwiLCBcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXVxuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtdWx0aToge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJvbGQ6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBib2xkaXRhbDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0YWw6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtb25vOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRkZW46IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhvdmVyV2lkdGg6IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCIsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGxlbmd0aDoge1xuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIHBoeXNpY3M6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1heDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1heFZpc2libGU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBkcmF3VGhyZXNob2xkOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHtcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Rpb25XaWR0aDoge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIixcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzZWxmUmVmZXJlbmNlU2l6ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHNlbGZSZWZlcmVuY2U6IHtcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhbmdsZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHJlbmRlckJlaGluZFRoZU5vZGU6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIHNtb290aDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBzdHJpbmc6IFtcImR5bmFtaWNcIiwgXCJjb250aW51b3VzXCIsIFwiZGlzY3JldGVcIiwgXCJkaWFnb25hbENyb3NzXCIsIFwic3RyYWlnaHRDcm9zc1wiLCBcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBcImN1cnZlZENXXCIsIFwiY3VydmVkQ0NXXCIsIFwiY3ViaWNCZXppZXJcIl1cbiAgICAgIH0sXG4gICAgICByb3VuZG5lc3M6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmb3JjZURpcmVjdGlvbjoge1xuICAgICAgICBzdHJpbmc6IFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBcIm5vbmVcIl0sXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHdpZHRoQ29uc3RyYWludDoge1xuICAgICAgbWF4aW11bToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGdyb3Vwczoge1xuICAgIHVzZURlZmF1bHRHcm91cHM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIF9fYW55X186IG5vZGVPcHRpb25zLFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGRyYWdWaWV3OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhpZGVFZGdlc09uWm9vbToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaGlkZU5vZGVzT25EcmFnOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHNwZWVkOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgem9vbToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJpbmRUb1dpbmRvdzoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgYXV0b0ZvY3VzOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgbXVsdGlzZWxlY3Q6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIG5hdmlnYXRpb25CdXR0b25zOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBzZWxlY3RhYmxlOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaG92ZXJDb25uZWN0ZWRFZGdlczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgdG9vbHRpcERlbGF5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgem9vbVZpZXc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHpvb21TcGVlZDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAgcmFuZG9tU2VlZDoge1xuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiLFxuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgaW1wcm92ZWRMYXlvdXQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGNsdXN0ZXJUaHJlc2hvbGQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGxldmVsU2VwYXJhdGlvbjoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG5vZGVTcGFjaW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgdHJlZVNwYWNpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBibG9ja1NoaWZ0aW5nOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBlZGdlTWluaW1pemF0aW9uOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgZGlyZWN0aW9uOiB7XG4gICAgICAgIHN0cmluZzogW1wiVURcIiwgXCJEVVwiLCBcIkxSXCIsIFwiUkxcIl1cbiAgICAgIH0sXG4gICAgICBzb3J0TWV0aG9kOiB7XG4gICAgICAgIHN0cmluZzogW1wiaHVic2l6ZVwiLCBcImRpcmVjdGVkXCJdXG4gICAgICB9LFxuICAgICAgc2hha2VUb3dhcmRzOiB7XG4gICAgICAgIHN0cmluZzogW1wibGVhdmVzXCIsIFwicm9vdHNcIl1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBtYW5pcHVsYXRpb246IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBpbml0aWFsbHlBY3RpdmU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGFkZE5vZGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBhZGRFZGdlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgZWRpdE5vZGU6IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGVkaXRFZGdlOiB7XG4gICAgICBlZGl0V2l0aG91dERyYWc6IHtcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVOb2RlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgZGVsZXRlRWRnZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRyb2xOb2RlU3R5bGU6IG5vZGVPcHRpb25zLFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIG5vZGVzOiBub2RlT3B0aW9ucyxcbiAgcGh5c2ljczoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGJhcm5lc0h1dDoge1xuICAgICAgdGhldGE6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICB0aGV0YToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG5vZGVEaXN0YW5jZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbm9kZURpc3RhbmNlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG1pblZlbG9jaXR5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc29sdmVyOiB7XG4gICAgICBzdHJpbmc6IFtcImJhcm5lc0h1dFwiLCBcInJlcHVsc2lvblwiLCBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiLCBcImZvcmNlQXRsYXMyQmFzZWRcIl1cbiAgICB9LFxuICAgIHN0YWJpbGl6YXRpb246IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGl0ZXJhdGlvbnM6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB1cGRhdGVJbnRlcnZhbDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG9ubHlEeW5hbWljRWRnZXM6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGZpdDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVzdGVwOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgYWRhcHRpdmVUaW1lc3RlcDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgd2luZDoge1xuICAgICAgeDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgLy9nbG9iYWxzIDpcbiAgYXV0b1Jlc2l6ZToge1xuICAgIGJvb2xlYW46IGJvb2xcbiAgfSxcbiAgY2xpY2tUb1VzZToge1xuICAgIGJvb2xlYW46IGJvb2xcbiAgfSxcbiAgbG9jYWxlOiB7XG4gICAgc3RyaW5nOiBzdHJpbmdcbiAgfSxcbiAgbG9jYWxlczoge1xuICAgIF9fYW55X186IHtcbiAgICAgIGFueTogYW55XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGhlaWdodDoge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIHdpZHRoOiB7XG4gICAgc3RyaW5nOiBzdHJpbmdcbiAgfSxcbiAgX190eXBlX186IHtcbiAgICBvYmplY3Q6IG9iamVjdFxuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cblxuLyoqXHJcbiAqIFRoaXMgcHJvdmlkZXMgcmFuZ2VzLCBpbml0aWFsIHZhbHVlcywgc3RlcHMgYW5kIGRyb3Bkb3duIG1lbnUgY2hvaWNlcyBmb3IgdGhlXHJcbiAqIGNvbmZpZ3VyYXRpb24uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIENoZWNrYm94OiBgYm9vbGVhbmBcclxuICogICBUaGUgdmFsdWUgc3VwbGxpZWQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxyXG4gKlxyXG4gKiBUZXh0IGZpZWxkOiBgc3RyaW5nYFxyXG4gKiAgIFRoZSBwYXNzZWQgdGV4dCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUuIEFueSB0ZXh0IHdpbGwgYmVcclxuICogICBhY2NlcHRlZCBhZnRlcndhcmRzLlxyXG4gKlxyXG4gKiBOdW1iZXIgcmFuZ2U6IGBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXWBcclxuICogICBUaGUgbWVhbmluZ3MgYXJlIGBbaW5pdGlhbCB2YWx1ZSwgbWluLCBtYXgsIHN0ZXBdYC5cclxuICpcclxuICogRHJvcGRvd246IGBbRXhjbHVkZTxzdHJpbmcsIFwiY29sb3JcIj4sIC4uLihzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKVtdXWBcclxuICogICBUcmFuc2xhdGlvbnMgZm9yIHBlb3BsZSB3aXRoIHBvb3IgdW5kZXJzdGFuZGluZyBvZiBUeXBlU2NyaXB0OiB0aGUgZmlyc3RcclxuICogICB2YWx1ZSBhbHdheXMgaGFzIHRvIGJlIGEgc3RyaW5nIGJ1dCBuZXZlciBgXCJjb2xvclwiYCwgdGhlIHJlc3QgY2FuIGJlIGFueVxyXG4gKiAgIGNvbWJpbmF0aW9uIG9mIHN0cmluZ3MsIG51bWJlcnMgYW5kIGJvb2xlYW5zLlxyXG4gKlxyXG4gKiBDb2xvciBwaWNrZXI6IGBbXCJjb2xvclwiLCBzdHJpbmddYFxyXG4gKiAgIFRoZSBmaXJzdCB2YWx1ZSBzYXlzIHRoaXMgd2lsbCBiZSBhIGNvbG9yIHBpY2tlciBub3QgYSBkcm9wZG93biBtZW51LiBUaGVcclxuICogICBuZXh0IHZhbHVlIGlzIHRoZSBpbml0aWFsIGNvbG9yLlxyXG4gKi9cblxudmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IFsxLCAwLCAxMCwgMV0sXG4gICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogWzIsIDAsIDEwLCAxXSxcbiAgICBjb2xvcjoge1xuICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiM5N0MyRkNcIl0sXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwiI0QyRTVGRlwiXVxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiNEMkU1RkZcIl1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9wYWNpdHk6IFswLCAwLCAxLCAwLjFdLFxuICAgIGZpeGVkOiB7XG4gICAgICB4OiBmYWxzZSxcbiAgICAgIHk6IGZhbHNlXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjMzQzNDM0XCJdLFxuICAgICAgc2l6ZTogWzE0LCAwLCAxMDAsIDFdLFxuICAgICAgZmFjZTogW1wiYXJpYWxcIiwgXCJ2ZXJkYW5hXCIsIFwidGFob21hXCJdLFxuICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCJub25lXCJdLFxuICAgICAgc3Ryb2tlV2lkdGg6IFswLCAwLCA1MCwgMV0sXG4gICAgICBzdHJva2VDb2xvcjogW1wiY29sb3JcIiwgXCIjZmZmZmZmXCJdXG4gICAgfSxcbiAgICAvL2dyb3VwOiAnc3RyaW5nJyxcbiAgICBoaWRkZW46IGZhbHNlLFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAvL2ljb246IHtcbiAgICAvLyAgZmFjZTogJ3N0cmluZycsICAvLydGb250QXdlc29tZScsXG4gICAgLy8gIGNvZGU6ICdzdHJpbmcnLCAgLy8nXFx1ZjAwNycsXG4gICAgLy8gIHNpemU6IFs1MCwgMCwgMjAwLCAxXSwgIC8vNTAsXG4gICAgLy8gIGNvbG9yOiBbJ2NvbG9yJywnIzJCN0NFOSddICAgLy8nI2FhMDBmZidcbiAgICAvL30sXG4gICAgLy9pbWFnZTogJ3N0cmluZycsIC8vIC0tPiBVUkxcbiAgICBwaHlzaWNzOiB0cnVlLFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogWzEwLCAwLCAyMDAsIDFdLFxuICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbWluOiBbMTQsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IFs1LCAwLCAyMCwgMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgeDogWzUsIC0zMCwgMzAsIDFdLFxuICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgfSxcbiAgICBzaGFwZTogW1wiZWxsaXBzZVwiLCBcImJveFwiLCBcImNpcmNsZVwiLCBcImRhdGFiYXNlXCIsIFwiZGlhbW9uZFwiLCBcImRvdFwiLCBcInNxdWFyZVwiLCBcInN0YXJcIiwgXCJ0ZXh0XCIsIFwidHJpYW5nbGVcIiwgXCJ0cmlhbmdsZURvd25cIiwgXCJoZXhhZ29uXCJdLFxuICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgYm9yZGVyRGFzaGVzOiBmYWxzZSxcbiAgICAgIGJvcmRlclJhZGl1czogWzYsIDAsIDIwLCAxXSxcbiAgICAgIGludGVycG9sYXRpb246IHRydWUsXG4gICAgICB1c2VJbWFnZVNpemU6IGZhbHNlXG4gICAgfSxcbiAgICBzaXplOiBbMjUsIDAsIDIwMCwgMV1cbiAgfSxcbiAgZWRnZXM6IHtcbiAgICBhcnJvd3M6IHtcbiAgICAgIHRvOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLFxuICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sXG4gICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgfSxcbiAgICAgIGZyb206IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sXG4gICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZW5kUG9pbnRPZmZzZXQ6IHtcbiAgICAgIGZyb206IFswLCAtMTAsIDEwLCAxXSxcbiAgICAgIHRvOiBbMCwgLTEwLCAxMCwgMV1cbiAgICB9LFxuICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IFtcImNvbG9yXCIsIFwiIzg0ODQ4NFwiXSxcbiAgICAgIGhpZ2hsaWdodDogW1wiY29sb3JcIiwgXCIjODQ4NDg0XCJdLFxuICAgICAgaG92ZXI6IFtcImNvbG9yXCIsIFwiIzg0ODQ4NFwiXSxcbiAgICAgIGluaGVyaXQ6IFtcImZyb21cIiwgXCJ0b1wiLCBcImJvdGhcIiwgdHJ1ZSwgZmFsc2VdLFxuICAgICAgb3BhY2l0eTogWzEsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICBkYXNoZXM6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiBbXCJjb2xvclwiLCBcIiMzNDM0MzRcIl0sXG4gICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sXG4gICAgICBmYWNlOiBbXCJhcmlhbFwiLCBcInZlcmRhbmFcIiwgXCJ0YWhvbWFcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIm5vbmVcIl0sXG4gICAgICBzdHJva2VXaWR0aDogWzIsIDAsIDUwLCAxXSxcbiAgICAgIHN0cm9rZUNvbG9yOiBbXCJjb2xvclwiLCBcIiNmZmZmZmZcIl0sXG4gICAgICBhbGlnbjogW1wiaG9yaXpvbnRhbFwiLCBcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXVxuICAgIH0sXG4gICAgaGlkZGVuOiBmYWxzZSxcbiAgICBob3ZlcldpZHRoOiBbMS41LCAwLCA1LCAwLjFdLFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICBwaHlzaWNzOiB0cnVlLFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogWzEsIDAsIDEwMCwgMV0sXG4gICAgICBtYXg6IFsxNSwgMCwgMTAwLCAxXSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4VmlzaWJsZTogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Rpb25XaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBzZWxmUmVmZXJlbmNlU2l6ZTogWzIwLCAwLCAyMDAsIDFdLFxuICAgIHNlbGZSZWZlcmVuY2U6IHtcbiAgICAgIHNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICAgIGFuZ2xlOiBbTWF0aC5QSSAvIDIsIC02ICogTWF0aC5QSSwgNiAqIE1hdGguUEksIE1hdGguUEkgLyA4XSxcbiAgICAgIHJlbmRlckJlaGluZFRoZU5vZGU6IHRydWVcbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgeDogWzUsIC0zMCwgMzAsIDFdLFxuICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgfSxcbiAgICBzbW9vdGg6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICB0eXBlOiBbXCJkeW5hbWljXCIsIFwiY29udGludW91c1wiLCBcImRpc2NyZXRlXCIsIFwiZGlhZ29uYWxDcm9zc1wiLCBcInN0cmFpZ2h0Q3Jvc3NcIiwgXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJjdXJ2ZWRDV1wiLCBcImN1cnZlZENDV1wiLCBcImN1YmljQmV6aWVyXCJdLFxuICAgICAgZm9yY2VEaXJlY3Rpb246IFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBcIm5vbmVcIl0sXG4gICAgICByb3VuZG5lc3M6IFswLjUsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICB3aWR0aDogWzEsIDAsIDMwLCAxXVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICAvL3JhbmRvbVNlZWQ6IFswLCAwLCA1MDAsIDFdLFxuICAgIC8vaW1wcm92ZWRMYXlvdXQ6IHRydWUsXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGxldmVsU2VwYXJhdGlvbjogWzE1MCwgMjAsIDUwMCwgNV0sXG4gICAgICBub2RlU3BhY2luZzogWzEwMCwgMjAsIDUwMCwgNV0sXG4gICAgICB0cmVlU3BhY2luZzogWzIwMCwgMjAsIDUwMCwgNV0sXG4gICAgICBibG9ja1NoaWZ0aW5nOiB0cnVlLFxuICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBbXCJVRFwiLCBcIkRVXCIsIFwiTFJcIiwgXCJSTFwiXSxcbiAgICAgIHNvcnRNZXRob2Q6IFtcImh1YnNpemVcIiwgXCJkaXJlY3RlZFwiXSxcbiAgICAgIHNoYWtlVG93YXJkczogW1wibGVhdmVzXCIsIFwicm9vdHNcIl0gLy8gbGVhdmVzLCByb290c1xuXG4gICAgfVxuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IGZhbHNlLFxuICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZSxcbiAgICBob3ZlcjogZmFsc2UsXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDogWzEwLCAwLCA0MCwgMV0sXG4gICAgICAgIHk6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB6b29tOiBbMC4wMiwgMCwgMC4xLCAwLjAwNV1cbiAgICAgIH0sXG4gICAgICBiaW5kVG9XaW5kb3c6IHRydWUsXG4gICAgICBhdXRvRm9jdXM6IHRydWVcbiAgICB9LFxuICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgIHRvb2x0aXBEZWxheTogWzMwMCwgMCwgMTAwMCwgMjVdLFxuICAgIHpvb21WaWV3OiB0cnVlLFxuICAgIHpvb21TcGVlZDogWzEsIDAuMSwgMiwgMC4xXVxuICB9LFxuICBtYW5pcHVsYXRpb246IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlXG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGJhcm5lc0h1dDoge1xuICAgICAgdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstMjAwMCwgLTMwMDAwLCAwLCA1MF0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMywgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDQsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIHRoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiBbLTUwLCAtNTAwLCAwLCAxXSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4wMSwgMCwgMSwgMC4wMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDgsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuNCwgMCwgMSwgMC4wMV0sXG4gICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgcmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbMjAwLCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA1LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIG5vZGVEaXN0YW5jZTogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjAxLCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIG5vZGVEaXN0YW5jZTogWzEyMCwgMCwgNTAwLCA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eTogWzUwLCAwLCAxNTAsIDFdLFxuICAgIG1pblZlbG9jaXR5OiBbMC4xLCAwLjAxLCAwLjUsIDAuMDFdLFxuICAgIHNvbHZlcjogW1wiYmFybmVzSHV0XCIsIFwiZm9yY2VBdGxhczJCYXNlZFwiLCBcInJlcHVsc2lvblwiLCBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXSxcbiAgICB0aW1lc3RlcDogWzAuNSwgMC4wMSwgMSwgMC4wMV0sXG4gICAgd2luZDoge1xuICAgICAgeDogWzAsIC0xMCwgMTAsIDAuMV0sXG4gICAgICB5OiBbMCwgLTEwLCAxMCwgMC4xXVxuICAgIH0gLy9hZGFwdGl2ZVRpbWVzdGVwOiB0cnVlXG5cbiAgfVxufTtcbnZhciBjb25maWd1cmF0b3JIaWRlT3B0aW9uID0gZnVuY3Rpb24gY29uZmlndXJhdG9ySGlkZU9wdGlvbihwYXJlbnRQYXRoLCBvcHRpb25OYW1lLCBvcHRpb25zKSB7XG4gIHZhciBfY29udGV4dDtcblxuICBpZiAoaW5jbHVkZXMocGFyZW50UGF0aCkuY2FsbChwYXJlbnRQYXRoLCBcInBoeXNpY3NcIikgJiYgaW5jbHVkZXMoX2NvbnRleHQgPSBjb25maWd1cmVPcHRpb25zLnBoeXNpY3Muc29sdmVyKS5jYWxsKF9jb250ZXh0LCBvcHRpb25OYW1lKSAmJiBvcHRpb25zLnBoeXNpY3Muc29sdmVyICE9PSBvcHRpb25OYW1lICYmIG9wdGlvbk5hbWUgIT09IFwid2luZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRjb25maWd1cmF0b3JIaWRlT3B0aW9uOiBjb25maWd1cmF0b3JIaWRlT3B0aW9uLFxuXHRhbGxPcHRpb25zOiBhbGxPcHRpb25zLFxuXHRjb25maWd1cmVPcHRpb25zOiBjb25maWd1cmVPcHRpb25zXG59KTtcblxuLyoqXG4gKiAgVGhlIEZsb3lk4oCTV2Fyc2hhbGwgYWxnb3JpdGhtIGlzIGFuIGFsZ29yaXRobSBmb3IgZmluZGluZyBzaG9ydGVzdCBwYXRocyBpblxuICogIGEgd2VpZ2h0ZWQgZ3JhcGggd2l0aCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBlZGdlIHdlaWdodHMgKGJ1dCB3aXRoIG5vIG5lZ2F0aXZlXG4gKiAgY3ljbGVzKS4gLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZOKAk1dhcnNoYWxsX2FsZ29yaXRobVxuICovXG52YXIgRmxveWRXYXJzaGFsbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBGbG95ZFdhcnNoYWxsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbG95ZFdhcnNoYWxsKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheS48RWRnZT59IGVkZ2VzQXJyYXlcbiAgICogQHJldHVybnMge3t9fVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGbG95ZFdhcnNoYWxsLCBbe1xuICAgIGtleTogXCJnZXREaXN0YW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VzKGJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBEX21hdHJpeCA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0gYm9keS5lZGdlczsgLy8gcHJlcGFyZSBtYXRyaXggd2l0aCBsYXJnZSBudW1iZXJzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG4gICAgICAgIHZhciBjZWxsID0ge307XG4gICAgICAgIERfbWF0cml4W25vZGVdID0gY2VsbDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsW25vZGVzQXJyYXlbal1dID0gaSA9PSBqID8gMCA6IDFlOTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBwdXQgdGhlIHdlaWdodHMgZm9yIHRoZSBlZGdlcyBpbi4gVGhpcyBhc3N1bWVzIHVuaWRpcmVjdGlvbmFsaXR5LlxuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlc0FycmF5Lmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VzQXJyYXlbX2ldXTsgLy8gZWRnZSBoYXMgdG8gYmUgY29ubmVjdGVkIGlmIGl0IGNvdW50cyB0byB0aGUgZGlzdGFuY2VzLiBJZiBpdCBpcyBjb25uZWN0ZWQgdG8gaW5uZXIgY2x1c3RlcnMgaXQgd2lsbCBjcmFzaCBzbyB3ZSBhbHNvIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBEX21hdHJpeFxuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBEX21hdHJpeFtlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiBEX21hdHJpeFtlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBEX21hdHJpeFtlZGdlLmZyb21JZF1bZWRnZS50b0lkXSA9IDE7XG4gICAgICAgICAgRF9tYXRyaXhbZWRnZS50b0lkXVtlZGdlLmZyb21JZF0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlQ291bnQgPSBub2Rlc0FycmF5Lmxlbmd0aDsgLy8gQWRhcHRlZCBGbG95ZFdhcnNoYWxsIGJhc2VkIG9uIHVuaWRpcmVjdGlvbmFsaXR5IHRvIGdyZWF0bHkgcmVkdWNlIGNvbXBsZXhpdHkuXG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbm9kZUNvdW50OyBrKyspIHtcbiAgICAgICAgdmFyIGtub2RlID0gbm9kZXNBcnJheVtrXTtcbiAgICAgICAgdmFyIGtjb2xtID0gRF9tYXRyaXhba25vZGVdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVDb3VudCAtIDE7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGlub2RlID0gbm9kZXNBcnJheVtfaTJdO1xuICAgICAgICAgIHZhciBpY29sbSA9IERfbWF0cml4W2lub2RlXTtcblxuICAgICAgICAgIGZvciAodmFyIF9qID0gX2kyICsgMTsgX2ogPCBub2RlQ291bnQ7IF9qKyspIHtcbiAgICAgICAgICAgIHZhciBqbm9kZSA9IG5vZGVzQXJyYXlbX2pdO1xuICAgICAgICAgICAgdmFyIGpjb2xtID0gRF9tYXRyaXhbam5vZGVdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IE1hdGgubWluKGljb2xtW2pub2RlXSwgaWNvbG1ba25vZGVdICsga2NvbG1bam5vZGVdKTtcbiAgICAgICAgICAgIGljb2xtW2pub2RlXSA9IHZhbDtcbiAgICAgICAgICAgIGpjb2xtW2lub2RlXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERfbWF0cml4O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGbG95ZFdhcnNoYWxsO1xufSgpO1xuXG4vKipcbiAqIEthbWFkYUthd2FpIHBvc2l0aW9ucyB0aGUgbm9kZXMgaW5pdGlhbGx5IGJhc2VkIG9uXG4gKlxuICogXCJBTiBBTEdPUklUSE0gRk9SIERSQVdJTkcgR0VORVJBTCBVTkRJUkVDVEVEIEdSQVBIU1wiXG4gKiAtLSBUb21paGlzYSBLQU1BREEgYW5kIFNhdG9ydSBLQVdBSSBpbiAxOTg5XG4gKlxuICogUG9zc2libGUgb3B0aW1pemF0aW9ucyBpbiB0aGUgZGlzdGFuY2UgY2FsY3VsYXRpb24gY2FuIGJlIGltcGxlbWVudGVkLlxuICovXG5cbnZhciBLYW1hZGFLYXdhaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUxlbmd0aFxuICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZVN0cmVuZ3RoXG4gICAqL1xuICBmdW5jdGlvbiBLYW1hZGFLYXdhaShib2R5LCBlZGdlTGVuZ3RoLCBlZGdlU3RyZW5ndGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2FtYWRhS2F3YWkpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IGVkZ2VMZW5ndGg7XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IGVkZ2VTdHJlbmd0aDtcbiAgICB0aGlzLmRpc3RhbmNlU29sdmVyID0gbmV3IEZsb3lkV2Fyc2hhbGwoKTtcbiAgfVxuICAvKipcbiAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhLYW1hZGFLYXdhaSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gb3B0aW9ucy5zcHJpbmdMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zcHJpbmdDb25zdGFudCkge1xuICAgICAgICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBvcHRpb25zLnNwcmluZ0NvbnN0YW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBzeXN0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc0FycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48dmlzLkVkZ2U+fSBlZGdlc0FycmF5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlQ2x1c3RlcnM9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZShub2Rlc0FycmF5LCBlZGdlc0FycmF5KSB7XG4gICAgICB2YXIgaWdub3JlQ2x1c3RlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgLy8gZ2V0IGRpc3RhbmNlIG1hdHJpeFxuICAgICAgdmFyIERfbWF0cml4ID0gdGhpcy5kaXN0YW5jZVNvbHZlci5nZXREaXN0YW5jZXModGhpcy5ib2R5LCBub2Rlc0FycmF5LCBlZGdlc0FycmF5KTsgLy8gZGlzdGFuY2UgbWF0cml4XG4gICAgICAvLyBnZXQgdGhlIEwgTWF0cml4XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUxfbWF0cml4KERfbWF0cml4KTsgLy8gZ2V0IHRoZSBLIE1hdHJpeFxuXG5cbiAgICAgIHRoaXMuX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KTsgLy8gaW5pdGlhbCBFIE1hdHJpeFxuXG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVfbWF0cml4KCk7IC8vIGNhbGN1bGF0ZSBwb3NpdGlvbnNcblxuXG4gICAgICB2YXIgdGhyZXNob2xkID0gMC4wMTtcbiAgICAgIHZhciBpbm5lclRocmVzaG9sZCA9IDE7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IE1hdGgubWF4KDEwMDAsIE1hdGgubWluKDEwICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCwgNjAwMCkpO1xuICAgICAgdmFyIG1heElubmVySXRlcmF0aW9ucyA9IDU7XG4gICAgICB2YXIgbWF4RW5lcmd5ID0gMWU5O1xuICAgICAgdmFyIGhpZ2hFX25vZGVJZCA9IDAsXG4gICAgICAgICAgZEVfZHggPSAwLFxuICAgICAgICAgIGRFX2R5ID0gMCxcbiAgICAgICAgICBkZWx0YV9tID0gMCxcbiAgICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcblxuICAgICAgd2hpbGUgKG1heEVuZXJneSA+IHRocmVzaG9sZCAmJiBpdGVyYXRpb25zIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyYXRpb25zICs9IDE7XG5cbiAgICAgICAgdmFyIF90aGlzJF9nZXRIaWdoZXN0RW5lciA9IHRoaXMuX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKTtcblxuICAgICAgICB2YXIgX3RoaXMkX2dldEhpZ2hlc3RFbmVyMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRIaWdoZXN0RW5lciwgNCk7XG5cbiAgICAgICAgaGlnaEVfbm9kZUlkID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlswXTtcbiAgICAgICAgbWF4RW5lcmd5ID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlsxXTtcbiAgICAgICAgZEVfZHggPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzJdO1xuICAgICAgICBkRV9keSA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbM107XG4gICAgICAgIGRlbHRhX20gPSBtYXhFbmVyZ3k7XG4gICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChkZWx0YV9tID4gaW5uZXJUaHJlc2hvbGQgJiYgc3ViSXRlcmF0aW9ucyA8IG1heElubmVySXRlcmF0aW9ucykge1xuICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgKz0gMTtcblxuICAgICAgICAgIHRoaXMuX21vdmVOb2RlKGhpZ2hFX25vZGVJZCwgZEVfZHgsIGRFX2R5KTtcblxuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0RW5lcmd5ID0gdGhpcy5fZ2V0RW5lcmd5KGhpZ2hFX25vZGVJZCk7XG5cbiAgICAgICAgICB2YXIgX3RoaXMkX2dldEVuZXJneTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0RW5lcmd5LCAzKTtcblxuICAgICAgICAgIGRlbHRhX20gPSBfdGhpcyRfZ2V0RW5lcmd5MlswXTtcbiAgICAgICAgICBkRV9keCA9IF90aGlzJF9nZXRFbmVyZ3kyWzFdO1xuICAgICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEVuZXJneTJbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBub2RlIHdpdGggdGhlIGhpZ2hlc3QgZW5lcmd5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZUNsdXN0ZXJzXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SGlnaGVzdEVuZXJneU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBtYXhFbmVyZ3kgPSAwO1xuICAgICAgdmFyIG1heEVuZXJneU5vZGVJZCA9IG5vZGVzQXJyYXlbMF07XG4gICAgICB2YXIgZEVfZHhfbWF4ID0gMCxcbiAgICAgICAgICBkRV9keV9tYXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWR4ID0gMDsgbm9kZUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBub2RlSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdOyAvLyBieSBub3QgZXZhbHVhdGluZyBub2RlcyB3aXRoIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHNob3VsZCBvbmx5IG1vdmUgbm9kZXMgdGhhdCBoYXZlIG5vIHBvc2l0aW9ucy5cblxuICAgICAgICBpZiAobm9kZXNbbV0ucHJlZGVmaW5lZFBvc2l0aW9uICE9PSB0cnVlIHx8IG5vZGVzW21dLmlzQ2x1c3RlciA9PT0gdHJ1ZSAmJiBpZ25vcmVDbHVzdGVycyA9PT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnggIT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC55ICE9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kzID0gdGhpcy5fZ2V0RW5lcmd5KG0pLFxuICAgICAgICAgICAgICBfdGhpcyRfZ2V0RW5lcmd5NCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRFbmVyZ3kzLCAzKSxcbiAgICAgICAgICAgICAgZGVsdGFfbSA9IF90aGlzJF9nZXRFbmVyZ3k0WzBdLFxuICAgICAgICAgICAgICBkRV9keCA9IF90aGlzJF9nZXRFbmVyZ3k0WzFdLFxuICAgICAgICAgICAgICBkRV9keSA9IF90aGlzJF9nZXRFbmVyZ3k0WzJdO1xuXG4gICAgICAgICAgaWYgKG1heEVuZXJneSA8IGRlbHRhX20pIHtcbiAgICAgICAgICAgIG1heEVuZXJneSA9IGRlbHRhX207XG4gICAgICAgICAgICBtYXhFbmVyZ3lOb2RlSWQgPSBtO1xuICAgICAgICAgICAgZEVfZHhfbWF4ID0gZEVfZHg7XG4gICAgICAgICAgICBkRV9keV9tYXggPSBkRV9keTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFttYXhFbmVyZ3lOb2RlSWQsIG1heEVuZXJneSwgZEVfZHhfbWF4LCBkRV9keV9tYXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGVuZXJneSBvZiBhIHNpbmdsZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRFbmVyZ3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVuZXJneShtKSB7XG4gICAgICB2YXIgX3RoaXMkRV9zdW1zJG0gPSBfc2xpY2VkVG9BcnJheSh0aGlzLkVfc3Vtc1ttXSwgMiksXG4gICAgICAgICAgZEVfZHggPSBfdGhpcyRFX3N1bXMkbVswXSxcbiAgICAgICAgICBkRV9keSA9IF90aGlzJEVfc3VtcyRtWzFdO1xuXG4gICAgICB2YXIgZGVsdGFfbSA9IE1hdGguc3FydChNYXRoLnBvdyhkRV9keCwgMikgKyBNYXRoLnBvdyhkRV9keSwgMikpO1xuICAgICAgcmV0dXJuIFtkZWx0YV9tLCBkRV9keCwgZEVfZHldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlIGJhc2VkIG9uIGl0J3MgZW5lcmd5XG4gICAgICogdGhlIGR4IGFuZCBkeSBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsaW5lYXIgc3lzdGVtIHByb3Bvc2VkIGJ5IEthbWFkYSBhbmQgS2F3YWlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRFX2R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRFX2R5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZU5vZGUobSwgZEVfZHgsIGRFX2R5KSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBkMkVfZHgyID0gMDtcbiAgICAgIHZhciBkMkVfZHhkeSA9IDA7XG4gICAgICB2YXIgZDJFX2R5MiA9IDA7XG4gICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgdmFyIGttID0gdGhpcy5LX21hdHJpeFttXTtcbiAgICAgIHZhciBsbSA9IHRoaXMuTF9tYXRyaXhbbV07XG5cbiAgICAgIGZvciAodmFyIGlJZHggPSAwOyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG5cbiAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICB2YXIga21hdCA9IGttW2ldO1xuICAgICAgICAgIHZhciBsbWF0ID0gbG1baV07XG4gICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5wb3coTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMiksIDEuNSk7XG4gICAgICAgICAgZDJFX2R4MiArPSBrbWF0ICogKDEgLSBsbWF0ICogTWF0aC5wb3coeV9tIC0geV9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBkMkVfZHhkeSArPSBrbWF0ICogKGxtYXQgKiAoeF9tIC0geF9pKSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGQyRV9keTIgKz0ga21hdCAqICgxIC0gbG1hdCAqIE1hdGgucG93KHhfbSAtIHhfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWFrZSB0aGUgdmFyaWFibGUgbmFtZXMgZWFzaWVyIHRvIG1ha2UgdGhlIHNvbHZpbmcgb2YgdGhlIGxpbmVhciBzeXN0ZW0gZWFzaWVyIHRvIHJlYWRcblxuXG4gICAgICB2YXIgQSA9IGQyRV9keDIsXG4gICAgICAgICAgQiA9IGQyRV9keGR5LFxuICAgICAgICAgIEMgPSBkRV9keCxcbiAgICAgICAgICBEID0gZDJFX2R5MixcbiAgICAgICAgICBFID0gZEVfZHk7IC8vIHNvbHZlIHRoZSBsaW5lYXIgc3lzdGVtIGZvciBkeCBhbmQgZHlcblxuICAgICAgdmFyIGR5ID0gKEMgLyBBICsgRSAvIEIpIC8gKEIgLyBBIC0gRCAvIEIpO1xuICAgICAgdmFyIGR4ID0gLShCICogZHkgKyBDKSAvIEE7IC8vIG1vdmUgdGhlIG5vZGVcblxuICAgICAgbm9kZXNbbV0ueCArPSBkeDtcbiAgICAgIG5vZGVzW21dLnkgKz0gZHk7IC8vIFJlY2FsY3VsYXRlIEVfbWF0cml4IChzaG91bGQgYmUgaW5jcmVtZW50YWwpXG5cbiAgICAgIHRoaXMuX3VwZGF0ZUVfbWF0cml4KG0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIEwgbWF0cml4OiBlZGdlIGxlbmd0aCB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRF9tYXRyaXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUxfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVMX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IHRoaXMuc3ByaW5nTGVuZ3RoO1xuICAgICAgdGhpcy5MX21hdHJpeCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuTF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBlZGdlTGVuZ3RoICogRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBLIG1hdHJpeDogc3ByaW5nIGNvbnN0YW50cyB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRF9tYXRyaXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUtfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVLX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgZWRnZVN0cmVuZ3RoID0gdGhpcy5zcHJpbmdDb25zdGFudDtcbiAgICAgIHRoaXMuS19tYXRyaXggPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuS19tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZVN0cmVuZ3RoICogTWF0aC5wb3coRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0sIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIG1hdHJpeCB3aXRoIGFsbCBlbmVyZ2llcyBiZXR3ZWVuIG5vZGVzXG4gICAgICpcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRV9tYXRyaXgoKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHRoaXMuRV9tYXRyaXggPSB7fTtcbiAgICAgIHRoaXMuRV9zdW1zID0ge307XG5cbiAgICAgIGZvciAodmFyIG1JZHggPSAwOyBtSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IG1JZHgrKykge1xuICAgICAgICB0aGlzLkVfbWF0cml4W25vZGVzQXJyYXlbbUlkeF1dID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9tSWR4ID0gMDsgX21JZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgX21JZHgrKykge1xuICAgICAgICB2YXIgbSA9IG5vZGVzQXJyYXlbX21JZHhdO1xuICAgICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICAgIHZhciBkRV9keSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaUlkeCA9IF9tSWR4OyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcblxuICAgICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5zcXJ0KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpKTtcbiAgICAgICAgICAgIHRoaXMuRV9tYXRyaXhbbV1baUlkeF0gPSBbdGhpcy5LX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSkgKiBkZW5vbWluYXRvciksIHRoaXMuS19tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpXTtcbiAgICAgICAgICAgIHRoaXMuRV9tYXRyaXhbaV1bX21JZHhdID0gdGhpcy5FX21hdHJpeFttXVtpSWR4XTtcbiAgICAgICAgICAgIGRFX2R4ICs9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF1bMF07XG4gICAgICAgICAgICBkRV9keSArPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvL1N0b3JlIHN1bVxuXG5cbiAgICAgICAgdGhpcy5FX3N1bXNbbV0gPSBbZEVfZHgsIGRFX2R5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1ldGhvZCwganVzdCBkb2luZyBzaW5nbGUgY29sdW1uIChyb3dzIGFyZSBhdXRvLXVwZGF0ZWQpICh1cGRhdGUgYWxsIHN1bXMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlRV9tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUVfbWF0cml4KG0pIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGNvbG0gPSB0aGlzLkVfbWF0cml4W21dO1xuICAgICAgdmFyIGtjb2xtID0gdGhpcy5LX21hdHJpeFttXTtcbiAgICAgIHZhciBsY29sbSA9IHRoaXMuTF9tYXRyaXhbbV07XG4gICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgdmFyIGRFX2R4ID0gMDtcbiAgICAgIHZhciBkRV9keSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGlJZHggPSAwOyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG5cbiAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAvL0tlZXAgb2xkIGVuZXJneSB2YWx1ZSBmb3Igc3VtIG1vZGlmaWNhdGlvbiBiZWxvd1xuICAgICAgICAgIHZhciBjZWxsID0gY29sbVtpSWR4XTtcbiAgICAgICAgICB2YXIgb2xkRHggPSBjZWxsWzBdO1xuICAgICAgICAgIHZhciBvbGREeSA9IGNlbGxbMV07IC8vQ2FsYyBuZXcgZW5lcmd5OlxuXG4gICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5zcXJ0KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpKTtcbiAgICAgICAgICB2YXIgZHggPSBrY29sbVtpXSAqICh4X20gLSB4X2kgLSBsY29sbVtpXSAqICh4X20gLSB4X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIHZhciBkeSA9IGtjb2xtW2ldICogKHlfbSAtIHlfaSAtIGxjb2xtW2ldICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgY29sbVtpSWR4XSA9IFtkeCwgZHldO1xuICAgICAgICAgIGRFX2R4ICs9IGR4O1xuICAgICAgICAgIGRFX2R5ICs9IGR5OyAvL2FkZCBuZXcgZW5lcmd5IHRvIHN1bSBvZiBlYWNoIGNvbHVtblxuXG4gICAgICAgICAgdmFyIHN1bSA9IHRoaXMuRV9zdW1zW2ldO1xuICAgICAgICAgIHN1bVswXSArPSBkeCAtIG9sZER4O1xuICAgICAgICAgIHN1bVsxXSArPSBkeSAtIG9sZER5O1xuICAgICAgICB9XG4gICAgICB9IC8vU3RvcmUgc3VtIGF0IC0xIGluZGV4XG5cblxuICAgICAgdGhpcy5FX3N1bXNbbV0gPSBbZEVfZHgsIGRFX2R5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gS2FtYWRhS2F3YWk7XG59KCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV0d29yayB2aXN1YWxpemF0aW9uLCBkaXNwbGF5aW5nIG5vZGVzIGFuZCBlZGdlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgIFRoZSBET00gZWxlbWVudCBpbiB3aGljaCB0aGUgTmV0d29yayB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjcmVhdGVkLiBOb3JtYWxseSBhIGRpdiBlbGVtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5fSBlZGdlc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICBPcHRpb25zXG4gKiBAY2xhc3MgTmV0d29ya1xuICovXG5cbmZ1bmN0aW9uIE5ldHdvcmsoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfY29udGV4dCxcbiAgICAgIF9jb250ZXh0MixcbiAgICAgIF9jb250ZXh0MyxcbiAgICAgIF9jb250ZXh0NCxcbiAgICAgIF90aGlzID0gdGhpcztcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmV0d29yaykpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3JcIik7XG4gIH0gLy8gc2V0IGNvbnN0YW50IHZhbHVlc1xuXG5cbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbG9jYWxlOiBcImVuXCIsXG4gICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICBjbGlja1RvVXNlOiBmYWxzZVxuICB9O1xuXG4gIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIC8qKlxuICAgKiBDb250YWluZXJzIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAqXG4gICAqICdlZGdlcycgYW5kICdub2RlcycgY29udGFpbiB0aGUgZnVsbCBkZWZpbml0aW9ucyBvZiBhbGwgdGhlIG5ldHdvcmsgZWxlbWVudHMuXG4gICAqICdub2RlSW5kaWNlcycgYW5kICdlZGdlSW5kaWNlcycgY29udGFpbiB0aGUgaWQncyBvZiB0aGUgYWN0aXZlIGVsZW1lbnRzLlxuICAgKlxuICAgKiBUaGUgZGlzdGluY3Rpb24gaXMgaW1wb3J0YW50LCBiZWNhdXNlIGEgZGVmaW5lZCBub2RlIG5lZWQgbm90IGJlIGFjdGl2ZSwgaS5lLlxuICAgKiB2aXNpYmxlIG9uIHRoZSBjYW52YXMuIFRoaXMgaGFwcGVucyBpbiBwYXJ0aWN1bGFyIHdoZW4gY2x1c3RlcnMgYXJlIGRlZmluZWQsIGluXG4gICAqIHRoYXQgY2FzZSB0aGVyZSB3aWxsIGJlIG5vZGVzIGFuZCBlZGdlcyBub3QgZGlzcGxheWVkLlxuICAgKiBUaGUgYm90dG9tIGxpbmUgaXMgdGhhdCBhbGwgY29kZSB3aXRoIGFjdGlvbnMgcmVsYXRlZCB0byB2aXNpYmlsaXR5LCAqbXVzdCogdXNlXG4gICAqICdub2RlSW5kaWNlcycgYW5kICdlZGdlSW5kaWNlcycsIG5vdCAnbm9kZXMnIGFuZCAnZWRnZXMnIGRpcmVjdGx5LlxuICAgKi9cblxuXG4gIHRoaXMuYm9keSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBmb3IgZm9sbG93aW5nIGZpZWxkc1xuICAgIG5vZGVzOiB7fSxcbiAgICBub2RlSW5kaWNlczogW10sXG4gICAgZWRnZXM6IHt9LFxuICAgIGVkZ2VJbmRpY2VzOiBbXSxcbiAgICBlbWl0dGVyOiB7XG4gICAgICBvbjogYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5vbikuY2FsbChfY29udGV4dCwgdGhpcyksXG4gICAgICBvZmY6IGJpbmQkNihfY29udGV4dDIgPSB0aGlzLm9mZikuY2FsbChfY29udGV4dDIsIHRoaXMpLFxuICAgICAgZW1pdDogYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMuZW1pdCkuY2FsbChfY29udGV4dDMsIHRoaXMpLFxuICAgICAgb25jZTogYmluZCQ2KF9jb250ZXh0NCA9IHRoaXMub25jZSkuY2FsbChfY29udGV4dDQsIHRoaXMpXG4gICAgfSxcbiAgICBldmVudExpc3RlbmVyczoge1xuICAgICAgb25UYXA6IGZ1bmN0aW9uIG9uVGFwKCkge30sXG4gICAgICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKCkge30sXG4gICAgICBvbkRvdWJsZVRhcDogZnVuY3Rpb24gb25Eb3VibGVUYXAoKSB7fSxcbiAgICAgIG9uSG9sZDogZnVuY3Rpb24gb25Ib2xkKCkge30sXG4gICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7fSxcbiAgICAgIG9uRHJhZzogZnVuY3Rpb24gb25EcmFnKCkge30sXG4gICAgICBvbkRyYWdFbmQ6IGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHt9LFxuICAgICAgb25Nb3VzZVdoZWVsOiBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoKSB7fSxcbiAgICAgIG9uUGluY2g6IGZ1bmN0aW9uIG9uUGluY2goKSB7fSxcbiAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHt9LFxuICAgICAgb25SZWxlYXNlOiBmdW5jdGlvbiBvblJlbGVhc2UoKSB7fSxcbiAgICAgIG9uQ29udGV4dDogZnVuY3Rpb24gb25Db250ZXh0KCkge31cbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIG5vZGVzOiBudWxsLFxuICAgICAgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgICBlZGdlczogbnVsbCAvLyBBIERhdGFTZXQgb3IgRGF0YVZpZXdcblxuICAgIH0sXG4gICAgZnVuY3Rpb25zOiB7XG4gICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge30sXG4gICAgICBjcmVhdGVFZGdlOiBmdW5jdGlvbiBjcmVhdGVFZGdlKCkge30sXG4gICAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiBnZXRQb2ludGVyKCkge31cbiAgICB9LFxuICAgIG1vZHVsZXM6IHt9LFxuICAgIHZpZXc6IHtcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgdHJhbnNsYXRpb246IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uQm94OiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBiaW5kIHRoZSBldmVudCBsaXN0ZW5lcnNcblxuICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpOyAvLyBzZXR0aW5nIHVwIGFsbCBtb2R1bGVzXG5cbiAgdGhpcy5pbWFnZXMgPSBuZXcgSW1hZ2VzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgfSk7IC8vIG9iamVjdCB3aXRoIGltYWdlc1xuXG4gIHRoaXMuZ3JvdXBzID0gbmV3IEdyb3VwcygpOyAvLyBvYmplY3Qgd2l0aCBncm91cHNcblxuICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcy5ib2R5KTsgLy8gRE9NIGhhbmRsZXJcblxuICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBuZXcgU2VsZWN0aW9uSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gU2VsZWN0aW9uIGhhbmRsZXJcblxuICB0aGlzLmludGVyYWN0aW9uSGFuZGxlciA9IG5ldyBJbnRlcmFjdGlvbkhhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyKTsgLy8gSW50ZXJhY3Rpb24gaGFuZGxlciBoYW5kbGVzIGFsbCB0aGUgaGFtbWVyIGJpbmRpbmdzICh0aGF0IGFyZSBib3VuZCBieSBjYW52YXMpLCBrZXlcblxuICB0aGlzLnZpZXcgPSBuZXcgVmlldyh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gY2FtZXJhIGhhbmRsZXIsIGRvZXMgYW5pbWF0aW9ucyBhbmQgem9vbXNcblxuICB0aGlzLnJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyByZW5kZXJlciwgc3RhcnRzIHJlbmRlcmxvb3AsIGhhcyBldmVudHMgdGhhdCBtb2R1bGVzIGNhbiBob29rIGludG9cblxuICB0aGlzLnBoeXNpY3MgPSBuZXcgUGh5c2ljc0VuZ2luZSh0aGlzLmJvZHkpOyAvLyBwaHlzaWNzIGVuZ2luZSwgZG9lcyBhbGwgdGhlIHNpbXVsYXRpb25zXG5cbiAgdGhpcy5sYXlvdXRFbmdpbmUgPSBuZXcgTGF5b3V0RW5naW5lKHRoaXMuYm9keSk7IC8vIGxheW91dCBlbmdpbmUgZm9yIGluaXRhbCBsYXlvdXQgYW5kIGhpZXJhcmNoaWNhbCBsYXlvdXRcblxuICB0aGlzLmNsdXN0ZXJpbmcgPSBuZXcgQ2x1c3RlckVuZ2luZSh0aGlzLmJvZHkpOyAvLyBjbHVzdGVyaW5nIGFwaVxuXG4gIHRoaXMubWFuaXB1bGF0aW9uID0gbmV3IE1hbmlwdWxhdGlvblN5c3RlbSh0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyKTsgLy8gZGF0YSBtYW5pcHVsYXRpb24gc3lzdGVtXG5cbiAgdGhpcy5ub2Rlc0hhbmRsZXIgPSBuZXcgTm9kZXNIYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzLCB0aGlzLmxheW91dEVuZ2luZSk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBub2RlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG5cbiAgdGhpcy5lZGdlc0hhbmRsZXIgPSBuZXcgRWRnZXNIYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzKTsgLy8gSGFuZGxlIGFkZGluZywgZGVsZXRpbmcgYW5kIHVwZGF0aW5nIG9mIGVkZ2VzIGFzIHdlbGwgYXMgZ2xvYmFsIG9wdGlvbnNcblxuICB0aGlzLmJvZHkubW9kdWxlc1tcImthbWFkYUthd2FpXCJdID0gbmV3IEthbWFkYUthd2FpKHRoaXMuYm9keSwgMTUwLCAwLjA1KTsgLy8gTGF5b3V0aW5nIGFsZ29yaXRobS5cblxuICB0aGlzLmJvZHkubW9kdWxlc1tcImNsdXN0ZXJpbmdcIl0gPSB0aGlzLmNsdXN0ZXJpbmc7IC8vIGNyZWF0ZSB0aGUgRE9NIGVsZW1lbnRzXG5cbiAgdGhpcy5jYW52YXMuX2NyZWF0ZSgpOyAvLyBhcHBseSBvcHRpb25zXG5cblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIGxvYWQgZGF0YSAodGhlIGRpc2FibGUgc3RhcnQgdmFyaWFibGUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgZW5hYmxlZCBjbHVzdGVyaW5nKVxuXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn0gLy8gRXh0ZW5kIE5ldHdvcmsgd2l0aCBhbiBFbWl0dGVyIG1peGluXG5cbkVtaXR0ZXIoTmV0d29yay5wcm90b3R5cGUpO1xuLyoqXG4gKiBTZXQgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cblxuTmV0d29yay5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDsgLy8gVGhpcyBlbnN1cmVzIHRoYXQgb3B0aW9ucyBoYW5kbGluZyBkb2Vzbid0IGNyYXNoIGluIHRoZSBoYW5kbGluZ1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlcnJvckZvdW5kID0gVmFsaWRhdG9yLnZhbGlkYXRlKG9wdGlvbnMsIGFsbE9wdGlvbnMpO1xuXG4gICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LlwiLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUpO1xuICAgIH0gLy8gY29weSB0aGUgZ2xvYmFsIGZpZWxkcyBvdmVyXG5cblxuICAgIHZhciBmaWVsZHMgPSBbXCJsb2NhbGVcIiwgXCJsb2NhbGVzXCIsIFwiY2xpY2tUb1VzZVwiXTtcbiAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gbm9ybWFsaXplIHRoZSBsb2NhbGUgb3IgdXNlIEVuZ2xpc2hcblxuICAgIGlmIChvcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmxvY2FsZSA9IG5vcm1hbGl6ZUxhbmd1YWdlQ29kZShvcHRpb25zLmxvY2FsZXMgfHwgdGhpcy5vcHRpb25zLmxvY2FsZXMsIG9wdGlvbnMubG9jYWxlKTtcbiAgICB9IC8vIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIGNhbiBhZGFwdCB0aGUgZWRnZXMgYW5kIHRoZSBwaHlzaWNzIHRvIGl0J3Mgb3duIG9wdGlvbnMgYmVjYXVzZSBub3QgYWxsIGNvbWJpbmF0aW9ucyB3b3JrIHdpdGggdGhlIGhpZXJhcmljaGljYWwgc3lzdGVtLlxuXG5cbiAgICBvcHRpb25zID0gdGhpcy5sYXlvdXRFbmdpbmUuc2V0T3B0aW9ucyhvcHRpb25zLmxheW91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5jYW52YXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gb3B0aW9ucyBmb3IgY2FudmFzIGFyZSBpbiBnbG9iYWxzXG4gICAgLy8gcGFzcyB0aGUgb3B0aW9ucyB0byB0aGUgbW9kdWxlc1xuXG4gICAgdGhpcy5ncm91cHMuc2V0T3B0aW9ucyhvcHRpb25zLmdyb3Vwcyk7XG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLm5vZGVzKTtcbiAgICB0aGlzLmVkZ2VzSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuZWRnZXMpO1xuICAgIHRoaXMucGh5c2ljcy5zZXRPcHRpb25zKG9wdGlvbnMucGh5c2ljcyk7XG4gICAgdGhpcy5tYW5pcHVsYXRpb24uc2V0T3B0aW9ucyhvcHRpb25zLm1hbmlwdWxhdGlvbiwgb3B0aW9ucywgdGhpcy5vcHRpb25zKTsgLy8gbWFuaXB1bGF0aW9uIHVzZXMgdGhlIGxvY2FsZXMgaW4gdGhlIGdsb2JhbHNcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pOyAvLyBvcHRpb25zIGZvciByZW5kZXJpbmcgYXJlIGluIGludGVyYWN0aW9uXG5cbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3Igc2VsZWN0aW9uIGFyZSBpbiBpbnRlcmFjdGlvblxuICAgIC8vIHJlbG9hZCB0aGUgc2V0dGluZ3Mgb2YgdGhlIG5vZGVzIHRvIGFwcGx5IGNoYW5nZXMgaW4gZ3JvdXBzIHRoYXQgYXJlIG5vdCByZWZlcmVuY2VkIGJ5IHBvaW50ZXIuXG5cbiAgICBpZiAob3B0aW9ucy5ncm91cHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hOb2Rlc1wiKTtcbiAgICB9IC8vIHRoZXNlIHR3byBkbyBub3QgaGF2ZSBvcHRpb25zIGF0IHRoZSBtb21lbnQsIGhlcmUgZm9yIGNvbXBsZXRlbmVzc1xuICAgIC8vdGhpcy52aWV3LnNldE9wdGlvbnMob3B0aW9ucy52aWV3KTtcbiAgICAvL3RoaXMuY2x1c3RlcmluZy5zZXRPcHRpb25zKG9wdGlvbnMuY2x1c3RlcmluZyk7XG5cblxuICAgIGlmIChcImNvbmZpZ3VyZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0b3IgPSBuZXcgQ29uZmlndXJhdG9yKHRoaXMsIHRoaXMuYm9keS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMsIHRoaXMuY2FudmFzLnBpeGVsUmF0aW8sIGNvbmZpZ3VyYXRvckhpZGVPcHRpb24pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcbiAgICB9IC8vIGlmIHRoZSBjb25maWd1cmF0aW9uIHN5c3RlbSBpcyBlbmFibGVkLCBjb3B5IGFsbCBvcHRpb25zIGFuZCBwdXQgdGhlbSBpbnRvIHRoZSBjb25maWcgc3lzdGVtXG5cblxuICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRvciAmJiB0aGlzLmNvbmZpZ3VyYXRvci5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgIHZhciBuZXR3b3JrT3B0aW9ucyA9IHtcbiAgICAgICAgbm9kZXM6IHt9LFxuICAgICAgICBlZGdlczoge30sXG4gICAgICAgIGxheW91dDoge30sXG4gICAgICAgIGludGVyYWN0aW9uOiB7fSxcbiAgICAgICAgbWFuaXB1bGF0aW9uOiB7fSxcbiAgICAgICAgcGh5c2ljczoge30sXG4gICAgICAgIGdsb2JhbDoge31cbiAgICAgIH07XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLm5vZGVzLCB0aGlzLm5vZGVzSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZWRnZXMsIHRoaXMuZWRnZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5sYXlvdXQsIHRoaXMubGF5b3V0RW5naW5lLm9wdGlvbnMpOyAvLyBsb2FkIHRoZSBzZWxlY3Rpb25IYW5kbGVyIGFuZCByZW5kZXIgZGVmYXVsdCBvcHRpb25zIGluIHRvIHRoZSBpbnRlcmFjdGlvbiBncm91cFxuXG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnJlbmRlcmVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLm1hbmlwdWxhdGlvbiwgdGhpcy5tYW5pcHVsYXRpb24ub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLnBoeXNpY3MsIHRoaXMucGh5c2ljcy5vcHRpb25zKTsgLy8gbG9hZCBnbG9iYWxzIGludG8gdGhlIGdsb2JhbCBvYmplY3RcblxuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5nbG9iYWwsIHRoaXMuY2FudmFzLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5nbG9iYWwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKG5ldHdvcmtPcHRpb25zKTtcbiAgICB9IC8vIGhhbmRsZSBuZXR3b3JrIGdsb2JhbCBvcHRpb25zXG5cblxuICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3Iub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLnNldFNpemUoKTsgLy8gc3RhcnQgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi4gQ2FuIGJlIHNhZmVseSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICB9XG59O1xuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc2libGUgbm9kZXMgYW5kIGVkZ2VzIGxpc3Qgd2l0aCB0aGUgbW9zdCByZWNlbnQgbm9kZSBzdGF0ZS5cbiAqXG4gKiBWaXNpYmxlIG5vZGVzIGFyZSBzdG9yZWQgaW4gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLlxuICogVmlzaWJsZSBlZGdlcyBhcmUgc3RvcmVkIGluIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5cbiAqIEEgbm9kZSBvciBlZGdlcyBpcyB2aXNpYmxlIGlmIGl0IGlzIG5vdCBoaWRkZW4gb3IgY2x1c3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmlzaWJsZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICB0aGlzLmJvZHkubm9kZUluZGljZXMgPSBbXTtcbiAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzID0gW107XG5cbiAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgaWYgKCF0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkTm9kZShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTsgLy8gSXQgY2FuIGhhcHBlbiB0aGF0IHRoaXMgaXMgZXhlY3V0ZWQgKmFmdGVyKiBhIG5vZGUgZWRnZSBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAgLy8gYnV0ICpiZWZvcmUqIHRoZSBlZGdlIGl0c2VsZiBoYXMgYmVlbiByZW1vdmVkLiBUYWtpbmcgdGhpcyBpbnRvIGFjY291bnQuXG5cbiAgICAgIHZhciBmcm9tTm9kZSA9IG5vZGVzW2VkZ2UuZnJvbUlkXTtcbiAgICAgIHZhciB0b05vZGUgPSBub2Rlc1tlZGdlLnRvSWRdO1xuICAgICAgdmFyIGVkZ2VOb2Rlc1ByZXNlbnQgPSBmcm9tTm9kZSAhPT0gdW5kZWZpbmVkICYmIHRvTm9kZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGlzVmlzaWJsZSA9ICF0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkRWRnZShlZGdlSWQpICYmIGVkZ2Uub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlICYmIGVkZ2VOb2Rlc1ByZXNlbnQgJiYgZnJvbU5vZGUub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlICYmIC8vIEFsc28gaGlkZGVuIGlmIGFueSBvZiBpdHMgY29ubmVjdGluZyBub2RlcyBhcmUgaGlkZGVuXG4gICAgICB0b05vZGUub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlOyAvLyBpZGVtXG5cbiAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goZWRnZS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBCaW5kIGFsbCBldmVudHNcbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmJpbmRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgLy8gVGhpcyBldmVudCB3aWxsIHRyaWdnZXIgYSByZWJ1aWxkaW5nIG9mIHRoZSBjYWNoZSBldmVyeXRoaW5nLlxuICAvLyBVc2VkIHdoZW4gbm9kZXMgb3IgZWRnZXMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQuXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpczMuZWRnZXNIYW5kbGVyLl91cGRhdGVTdGF0ZSgpO1xuXG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICB9KTsgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiBvcHRpb25zIG9mIEVYSVNUSU5HIG5vZGVzIG9yIGVkZ2VzIGhhdmUgY2hhbmdlZC5cblxuICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gT3JkZXIgaW1wb3J0YW50IGluIGZvbGxvd2luZyBibG9ja1xuICAgIF90aGlzMy5jbHVzdGVyaW5nLl91cGRhdGVTdGF0ZSgpO1xuXG4gICAgX3RoaXMzLl91cGRhdGVWaXNpYmxlSW5kaWNlcygpO1xuXG4gICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5Lm5vZGVzKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5lZGdlcyk7IC8vIHN0YXJ0IHNpbXVsYXRpb24gKGNhbiBiZSBjYWxsZWQgc2FmZWx5LCBldmVuIGlmIGFscmVhZHkgcnVubmluZylcblxuXG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuXG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gIH0pO1xufTtcbi8qKlxuICogU2V0IG5vZGVzIGFuZCBlZGdlcywgYW5kIG9wdGlvbmFsbHkgb3B0aW9ucyBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW25vZGVzXSBBcnJheSB3aXRoIG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbZWRnZXNdIEFycmF5IHdpdGggZWRnZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbZG90XSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIERPVCBmb3JtYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbZ2VwaGldIFN0cmluZyBjb250YWluaW5nIGRhdGEgaW4gZ2VwaGkgSlNPTiBmb3JtYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T3B0aW9uc30gW29wdGlvbnNdIE9iamVjdCB3aXRoIG9wdGlvbnNcbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAvLyByZXNldCB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXNldFBoeXNpY3NcIik7XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXREYXRhXCIpOyAvLyB1bnNlbGVjdCBhbGwgdG8gZW5zdXJlIG5vIHNlbGVjdGlvbnMgZnJvbSBvbGQgZGF0YSBhcmUgY2FycmllZCBvdmVyLlxuXG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuZG90ICYmIChkYXRhLm5vZGVzIHx8IGRhdGEuZWRnZXMpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgJyArICcgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtcbiAgfSAvLyBzZXQgb3B0aW9uc1xuXG5cbiAgdGhpcy5zZXRPcHRpb25zKGRhdGEgJiYgZGF0YS5vcHRpb25zKTsgLy8gc2V0IGFsbCBkYXRhXG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5kb3QpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZG90IHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0RG90IG1ldGhvZCB0byBjb252ZXJ0IERPVCBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnREb3QoZG90U3RyaW5nKTtcIik7IC8vIHBhcnNlIERPVCBmaWxlXG5cbiAgICB2YXIgZG90RGF0YSA9IERPVFRvR3JhcGgoZGF0YS5kb3QpO1xuICAgIHRoaXMuc2V0RGF0YShkb3REYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmdlcGhpKSB7XG4gICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZ2VwaGkgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnRHZXBoaSBtZXRob2QgdG8gY29udmVydCBnZXBoaSBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnRHZXBoaShnZXBoaUpzb24pO1wiKTtcbiAgICB2YXIgZ2VwaGlEYXRhID0gcGFyc2VHZXBoaShkYXRhLmdlcGhpKTtcbiAgICB0aGlzLnNldERhdGEoZ2VwaGlEYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEubm9kZXMsIHRydWUpO1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldERhdGEoZGF0YSAmJiBkYXRhLmVkZ2VzLCB0cnVlKTtcbiAgfSAvLyBlbWl0IGNoYW5nZSBpbiBkYXRhXG5cblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpOyAvLyBlbWl0IGRhdGEgbG9hZGVkXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhTG9hZGVkXCIpOyAvLyBmaW5kIGEgc3RhYmxlIHBvc2l0aW9uIG9yIHN0YXJ0IGFuaW1hdGluZyB0byBhIHN0YWJsZSBwb3NpdGlvblxuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UGh5c2ljc1wiKTtcbn07XG4vKipcbiAqIENsZWFucyB1cCBhbGwgYmluZGluZ3Mgb2YgdGhlIG5ldHdvcmssIHJlbW92aW5nIGl0IGZ1bGx5IGZyb20gdGhlIG1lbW9yeSBJRiB0aGUgdmFyaWFibGUgaXMgc2V0IHRvIG51bGwgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICogdmFyIG5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoLi4pO1xuICogbmV0d29yay5kZXN0cm95KCk7XG4gKiBuZXR3b3JrID0gbnVsbDtcbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJkZXN0cm95XCIpOyAvLyBjbGVhciBldmVudHNcblxuICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgdGhpcy5vZmYoKTsgLy8gZGVsZXRlIG1vZHVsZXNcblxuICBkZWxldGUgdGhpcy5ncm91cHM7XG4gIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyO1xuICBkZWxldGUgdGhpcy52aWV3O1xuICBkZWxldGUgdGhpcy5yZW5kZXJlcjtcbiAgZGVsZXRlIHRoaXMucGh5c2ljcztcbiAgZGVsZXRlIHRoaXMubGF5b3V0RW5naW5lO1xuICBkZWxldGUgdGhpcy5jbHVzdGVyaW5nO1xuICBkZWxldGUgdGhpcy5tYW5pcHVsYXRpb247XG4gIGRlbGV0ZSB0aGlzLm5vZGVzSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuZWRnZXNIYW5kbGVyO1xuICBkZWxldGUgdGhpcy5jb25maWd1cmF0b3I7XG4gIGRlbGV0ZSB0aGlzLmltYWdlcztcblxuICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSBjb250aW51ZTtcbiAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gIH1cblxuICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLCBlZGdlSWQpKSBjb250aW51ZTtcbiAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gIH0gLy8gcmVtb3ZlIHRoZSBjb250YWluZXIgYW5kIGV2ZXJ5dGhpbmcgaW5zaWRlIGl0IHJlY3Vyc2l2ZWx5XG5cblxuICByZWN1cnNpdmVET01EZWxldGUodGhpcy5ib2R5LmNvbnRhaW5lcik7XG59O1xuLyoqXG4gKiBVcGRhdGUgdGhlIHZhbHVlcyBvZiBhbGwgb2JqZWN0IGluIHRoZSBnaXZlbiBhcnJheSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnRcbiAqIHZhbHVlIHJhbmdlIG9mIHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqICAgIEFuIG9iamVjdCBjb250YWluaW5nIGEgc2V0IG9mIEVkZ2VzIG9yIE5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3RzIG11c3QgaGF2ZSBhIG1ldGhvZCBnZXRWYWx1ZSgpIGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4KS5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVSYW5nZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGlkOyAvLyBkZXRlcm1pbmUgdGhlIHJhbmdlIG9mIHRoZSBvYmplY3RzXG5cbiAgdmFyIHZhbHVlTWluID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVNYXggPSB1bmRlZmluZWQ7XG4gIHZhciB2YWx1ZVRvdGFsID0gMDtcblxuICBmb3IgKGlkIGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpZCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtpZF0uZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVNaW4gPSB2YWx1ZU1pbiA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1pbih2YWx1ZSwgdmFsdWVNaW4pO1xuICAgICAgICB2YWx1ZU1heCA9IHZhbHVlTWF4ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWF4KHZhbHVlLCB2YWx1ZU1heCk7XG4gICAgICAgIHZhbHVlVG90YWwgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGFkanVzdCB0aGUgcmFuZ2Ugb2YgYWxsIG9iamVjdHNcblxuXG4gIGlmICh2YWx1ZU1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGlkIGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGlkKSkge1xuICAgICAgICBvYmpbaWRdLnNldFZhbHVlUmFuZ2UodmFsdWVNaW4sIHZhbHVlTWF4LCB2YWx1ZVRvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBOZXR3b3JrIGlzIGFjdGl2ZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuYWN0aXZhdG9yIHx8IHRoaXMuYWN0aXZhdG9yLmFjdGl2ZTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5zZXRTaXplLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuY2FudmFzVG9ET00gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLkRPTXRvQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuLyoqXG4gKiBOb2RlcyBjYW4gYmUgaW4gY2x1c3RlcnMuIENsdXN0ZXJzIGNhbiBhbHNvIGJlIGluIGNsdXN0ZXJzLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW5kIGFycmF5IG9mXG4gKiBub2RlSWRzIHNob3dpbmcgd2hlcmUgdGhlIG5vZGUgaXMuXG4gKlxuICogSWYgYW55IG5vZGVJZCBpbiB0aGUgY2hhaW4sIGVzcGVjaWFsbHkgdGhlIGZpcnN0IHBhc3NlZCBpbiBhcyBhIHBhcmFtZXRlciwgaXMgbm90IHByZXNlbnQgaW5cbiAqIHRoZSBjdXJyZW50IG5vZGVzIGxpc3QsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBjbHVzdGVyICdBJyBjb250YWlucyBjbHVzdGVyICdCJyxcbiAqIGNsdXN0ZXIgJ0InIGNvbnRhaW5zIGNsdXN0ZXIgJ0MnLFxuICogY2x1c3RlciAnQycgY29udGFpbnMgbm9kZSAnZnJlZCcuXG4gKiBganNuZXR3b3JrLmNsdXN0ZXJpbmcuZmluZE5vZGUoJ2ZyZWQnKWAgd2lsbCByZXR1cm4gYFsnQScsJ0InLCdDJywnZnJlZCddYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVJZFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuZmluZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZmluZE5vZGUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuaXNDbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmlzQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5vcGVuQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Tm9kZXNJbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0Tm9kZXNJbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlckJ5Q29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlDb25uZWN0aW9uLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUh1YnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5SHVic2l6ZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS51cGRhdGVDbHVzdGVyZWROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLnVwZGF0ZUNsdXN0ZXJlZE5vZGUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Q2x1c3RlcmVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0Q2x1c3RlcmVkRWRnZXMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0QmFzZUVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0QmFzZUVkZ2UuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0QmFzZUVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldEJhc2VFZGdlcy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS51cGRhdGVFZGdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLnVwZGF0ZUVkZ2UuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbi8qKlxuICogVGhpcyBtZXRob2Qgd2lsbCBjbHVzdGVyIGFsbCBub2RlcyB3aXRoIDEgZWRnZSB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29ubmVjdGVkIG5vZGUuXG4gKiBUaGUgb3B0aW9ucyBvYmplY3QgaXMgZXhwbGFpbmVkIGluIGZ1bGwgPGEgZGF0YS1zY3JvbGw9XCJcIiBkYXRhLW9wdGlvbnM9XCJ7ICZxdW90O2Vhc2luZyZxdW90OzogJnF1b3Q7ZWFzZUluQ3ViaWMmcXVvdDsgfVwiIGhyZWY9XCIjb3B0aW9uc09iamVjdFwiPmJlbG93PC9hPi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuY2x1c3Rlck91dGxpZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJPdXRsaWVycy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXRFbmdpbmUuZ2V0U2VlZC5hcHBseSh0aGlzLmxheW91dEVuZ2luZSwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmVuYWJsZUVkaXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZW5hYmxlRWRpdE1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kaXNhYmxlRWRpdE1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5hZGROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZE5vZGVNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZWRpdE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZDogUGxlYXNlIHVzZSBlZGl0Tm9kZSBpbnN0ZWFkIG9mIGVkaXROb2RlTW9kZS5cIik7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmFkZEVkZ2VNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkRWRnZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0RWRnZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0RWRnZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5kZWxldGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRQb3NpdGlvbi5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnN0b3JlUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuc3RvcmVQb3NpdGlvbnMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5tb3ZlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLm1vdmVOb2RlLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRCb3VuZGluZ0JveC5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZE5vZGVzID0gZnVuY3Rpb24gKG9iamVjdElkKSB7XG4gIGlmICh0aGlzLmJvZHkubm9kZXNbb2JqZWN0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMuZWRnZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZEVkZ2VzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc3RhcnRTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YXJ0U2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zdG9wU2ltdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdG9wU2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zdGFiaWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhYmlsaXplLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3RlZE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUlkcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2RlQXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbm9kZS5pZDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0RWRnZUF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuXG4gIGlmIChlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVkZ2UuaWQ7XG4gIH1cblxuICByZXR1cm4gZWRnZTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnNlbGVjdE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnNlbGVjdEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEVkZ2VzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnVuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0V2l0aG91dEVtaXR0aW5nLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlZHJhdy5hcHBseSh0aGlzLnJlbmRlcmVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZ2V0U2NhbGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Vmlld1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmdldFZpZXdQb3NpdGlvbi5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZml0LmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5tb3ZlVG8uYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZm9jdXMuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUucmVsZWFzZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcucmVsZWFzZU5vZGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0T3B0aW9uc0Zyb21Db25maWd1cmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgaWYgKHRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuY29uZmlndXJhdG9yLmdldE9wdGlvbnMuYXBwbHkodGhpcy5jb25maWd1cmF0b3IpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG52YXIgcGFyc2VET1ROZXR3b3JrID0gRE9UVG9HcmFwaDtcbi8vIG92ZXJmbG93IGluIFVNRCBidWlsZHMuIFRoZXkgYWxsIGV4cG9ydCB2aXMgbmFtZXNwYWNlIHRoZXJlZm9yZSByZWV4cG9ydGluZ1xuLy8gbGVhZHMgdG8gbG9hZGluZyB2aXMgdG8gbG9hZCB2aXMgdG8gbG9hZCB2aXPigKZcblxuZXhwb3J0IHsgRGF0YVNldCwgRGF0YVZpZXcsIE5ldHdvcmssIEltYWdlcyBhcyBOZXR3b3JrSW1hZ2VzLCBRdWV1ZSwgaW5kZXggYXMgZGF0YSwgZG90cGFyc2VyIGFzIG5ldHdvcmtET1RQYXJzZXIsIGdlcGhpUGFyc2VyIGFzIG5ldHdvcmtHZXBoaVBhcnNlciwgb3B0aW9ucyBhcyBuZXR3b3JrT3B0aW9ucywgcGFyc2VET1ROZXR3b3JrLCBwYXJzZUdlcGhpIGFzIHBhcnNlR2VwaGlOZXR3b3JrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMtbmV0d29yay5qcy5tYXBcbiIsImV4cG9ydCAqIGZyb20gXCIuL2VzbVwiO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIiIsIi8vIG1vZHVsZSBjYWNoZSBhcmUgdXNlZCBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy92aXNfc3VmZml4X3RyZWUudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=