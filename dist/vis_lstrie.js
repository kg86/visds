/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/lstrie.ts":
/*!***********************!*\
  !*** ./src/lstrie.ts ***!
  \***********************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);

// Linear Size Suffix Trie
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build_lstrie = exports.StrTree = void 0;
const lcp = (x, y) => {
    const n = Math.min(x.length, y.length);
    let i = 0;
    for (; i < n; i++) {
        if (x[i] !== y[i])
            break;
    }
    return i;
};
class Node {
    constructor(birth_time, in_edge_label, value, explicit) {
        this.birth_time = birth_time;
        this.in_edge_label = in_edge_label;
        this.children = new Map();
        this.value = value;
        this.is_explicit = explicit;
    }
    get is_leaf() {
        return this.children.size === 0;
    }
    get height() {
        let max = -1;
        for (let child of this.children.values()) {
            max = Math.max(max, child.height);
        }
        return 1 + max;
    }
}
class StrTree {
    constructor() {
        this.nodes = [];
        this.root = this.create_node("", -1, true);
        this.slinks = new Map();
        this.elinks = new Map();
    }
    create_node(in_edge_label, value, is_explicit) {
        const node = new Node(this.nodes.length, in_edge_label, value, is_explicit);
        this.nodes.push(node);
        return node;
    }
    find_branch(parent, text, match_len_all = 0) {
        if (text.length === 0 || !parent.children.has(text[0])) {
            return [parent, parent, 0, match_len_all];
        }
        const child = parent.children.get(text[0]);
        const match_len = lcp(child.in_edge_label, text);
        if (match_len < child.in_edge_label.length) {
            return [parent, child, match_len, match_len_all + match_len];
        }
        else {
            return this.find_branch(child, text.substr(match_len), match_len_all + match_len);
        }
    }
    split(parent, child, match_len, is_explicit) {
        if (match_len === 0)
            return child;
        const branch_node = this.create_node(child.in_edge_label.substr(0, match_len), -1, is_explicit);
        parent.children.set(branch_node.in_edge_label[0], branch_node);
        child.in_edge_label = child.in_edge_label.substr(match_len);
        branch_node.children.set(child.in_edge_label[0], child);
        return branch_node;
    }
    insert(text, i, create_implicit_node) {
        const [parent, child, match_len_edge, match_len_all] = this.find_branch(this.root, text);
        console.log("insert [", text, "] match_len=", match_len_edge, " match_len_all=", match_len_all);
        // check whether or not the point is implicit node.
        if (match_len_all === text.length && !create_implicit_node)
            return;
        console.log("create_implicit_node", create_implicit_node);
        if (match_len_edge < text.length) {
            const branch_node = child === parent
                ? parent
                : this.split(parent, child, match_len_edge, true);
            const leaf = this.create_node(text.substr(match_len_all), i, true);
            branch_node.children.set(leaf.in_edge_label[0], leaf);
        }
    }
    build_suffix_links() {
        const rec = (node, node_label, reverse) => {
            if (node !== this.root) {
                const [parent, child] = this.find_branch(this.root, node_label.substr(1));
                if (child === parent) {
                    if (reverse)
                        this.slinks.set(parent, node);
                    else
                        this.slinks.set(node, parent);
                }
            }
            for (const child of node.children.values()) {
                rec(child, node_label + child.in_edge_label, reverse);
            }
        };
        rec(this.root, "", false);
    }
    // chrochemore et al.'s link
    build_extend_suffix_links() {
        // traverse all implicit nodes
        // if there is a suffix link to a explicit node
        // create an implicit node and its suffix link
        const rec = (parent, child, label) => {
            for (let i = 1; i < child.in_edge_label.length; i++) {
                const edge_label = label + child.in_edge_label.substr(0, i);
                const edge_label_suf = edge_label.substr(1);
                const [to_parent, to_child, match_len_edge, match_len_all] = this.find_branch(this.root, edge_label_suf);
                if (to_child === to_parent && to_parent.is_explicit) {
                    // create a node and its suffix link
                    const branch_node = this.split(parent, child, i, false);
                    this.elinks.set(branch_node, to_parent);
                    rec(branch_node, child, edge_label);
                    return;
                }
            }
            for (let child_child of child.children.values()) {
                rec(child, child_child, label + child.in_edge_label);
            }
        };
        rec(this.root, this.root, "");
    }
    get json() {
        const nodes = [];
        const edges = [];
        const nid = new Map();
        const height = this.root.height;
        // if true, use a node depth as level of visnetwork
        // otherwise, use a height, maximum distance to its leafs
        const use_depth = false;
        const create_json_node = (node, depth) => {
            if (!nid.has(node)) {
                nid.set(node, nodes.length);
                const ndic = {
                    label: node.value === undefined ? "" : "" + node.value,
                    id: nid.get(node),
                    level: use_depth ? depth : height - node.height,
                    shape: node.is_leaf ? "box" : "circle",
                    color: {
                        border: node.is_explicit ? "#2B7CE9" : "#000000",
                        background: node.is_explicit ? "#D2E5FF" : "#000000",
                    },
                };
                nodes.push(ndic);
            }
        };
        const rec = (parent, depth) => {
            create_json_node(parent, depth);
            const children = Array.from(parent.children.entries());
            children.sort();
            console.log("children", children);
            children.forEach(([key, child]) => {
                create_json_node(child, depth + 1);
                const edge = {
                    from: nid.get(parent),
                    to: nid.get(child),
                    id: nid.get(parent) + "-" + nid.get(child),
                    label: child.in_edge_label,
                    font: { align: "top" },
                    color: {
                        color: "#2B7CE9",
                    },
                };
                edges.push(edge);
                rec(child, depth + 1);
            });
        };
        rec(this.root, 0);
        // suffix link
        const slinks = [];
        console.log(Array.from(this.slinks.entries()));
        for (const [from_node, to_node] of Array.from(this.slinks.entries()).concat(Array.from(this.elinks.entries()))) {
            const slink = {
                from: nid.get(from_node),
                to: nid.get(to_node),
                id: "s" + nid.get(from_node) + "-" + nid.get(to_node),
                dashes: true,
                color: { color: from_node.is_explicit ? "#848484" : "#ff0000" },
                smooth: { type: "curvedCW", roundness: 0.4 },
            };
            slinks.push(slink);
        }
        const edges_all = edges.concat(slinks);
        return {
            root: nid.get(this.root),
            nodes,
            edges: edges_all,
        };
    }
}
exports.StrTree = StrTree;
const build_lstrie = (text, show_suffix_links, show_extended_suffix_links, create_implicit_node) => {
    const lstrie = new StrTree();
    for (let i = 0; i < text.length; i++) {
        lstrie.insert(text.substring(i), i, create_implicit_node);
    }
    if (show_suffix_links)
        lstrie.build_suffix_links();
    if (show_extended_suffix_links)
        lstrie.build_extend_suffix_links();
    console.log("eslinks");
    for (const [from, to] of lstrie.elinks.entries()) {
        console.log("eslink[" + from.birth_time + ", " + to.birth_time + "]");
    }
    return lstrie;
};
exports.build_lstrie = build_lstrie;
const main = (text) => {
    const lstrie = (0, exports.build_lstrie)(text, false, false, false);
    console.log(lstrie.json);
};
if (__webpack_require__.c[__webpack_require__.s] === module) {
    main(process.argv.length === 3 ? process.argv[2] : "abaabac");
}


/***/ }),

/***/ "./src/vis_lstrie.ts":
/*!***************************!*\
  !*** ./src/vis_lstrie.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const standalone_1 = __webpack_require__(/*! vis-network/standalone */ "./node_modules/vis-network/standalone/index.js");
const lstrie_1 = __webpack_require__(/*! ./lstrie */ "./src/lstrie.ts");
const visjs_default_options = __webpack_require__(/*! ./visjs_default_options */ "./src/visjs_default_options.ts");
const options = visjs_default_options.options;
const container = document.getElementById("network");
const network = new standalone_1.Network(container, {}, options);
let networkData = {};
const load_params_from_url = () => {
    const queryString = window.location.search;
    // console.log('querystring', queryString)
    const urlParams = new URLSearchParams(queryString);
    let params = {
        input_text: "cocoa",
        show_suffix_links: true,
        show_extended_suffix_links: true,
        create_implicit_node: false,
    };
    const keys = ["input_text", "show_suffix_links", "implicit_cdawg"];
    const undefined_values = ["", "true", "true"];
    for (let key of keys) {
        const urlkey = urlParams.get(key);
    }
    const urlkey = urlParams.get("input_text");
    if (urlkey !== null)
        params.input_text = urlkey;
    params.show_suffix_links = urlParams.get("show_suffix_links") === "true";
    params.show_extended_suffix_links =
        urlParams.get("show_extended_suffix_links") === "true";
    params.create_implicit_node =
        urlParams.get("create_implicit_node") === "true";
    params.create_implicit_node = true;
    return params;
};
const load_params_from_html = () => {
    const input_text = document.getElementById("input_text")
        .value;
    const show_suffix_links = document.getElementById("show_suffix_links").checked;
    const show_extend_suffix_links = document.getElementById("show_extended_suffix_links").checked;
    const create_implicit_node = document.getElementById("create_implicit_node").checked;
    const params = {
        input_text: input_text,
        show_suffix_links: show_suffix_links,
        show_extended_suffix_links: show_extend_suffix_links,
        create_implicit_node: create_implicit_node,
    };
    return params;
};
const set_params_to_url = (params) => {
    const url = new URL(window.location.toString());
    for (let key of Object.keys(params)) {
        url.searchParams.set(key, params[key].toString());
    }
    history.replaceState({}, "", url.toString());
};
const set_params_to_html = (params) => {
    const input_text = document.getElementById("input_text");
    const show_suffix_links = document.getElementById("show_suffix_links");
    const show_extended_suffix_links = document.getElementById("show_extended_suffix_links");
    const create_implicit_node = document.getElementById("create_implicit_node");
    input_text.value = params.input_text;
    show_suffix_links.checked = params.show_suffix_links;
    show_extended_suffix_links.checked = params.show_extended_suffix_links;
    create_implicit_node.checked = params.create_implicit_node;
};
const redraw = () => {
    // load and set parameters
    const params = load_params_from_html();
    set_params_to_url(params);
    console.log("params", params);
    const lstrie = (0, lstrie_1.build_lstrie)(params.input_text, params.show_suffix_links, params.show_extended_suffix_links, params.create_implicit_node);
    console.log(lstrie);
    const json = lstrie.json;
    console.log(json);
    networkData = {
        nodes: new standalone_1.DataSet(json.nodes),
        edges: new standalone_1.DataSet(json.edges),
    };
    network.setData(networkData);
};
const main = () => {
    // set event listener
    const input_text = document.getElementById("input_text");
    input_text.addEventListener("input", redraw);
    input_text.addEventListener("propertychange", redraw);
    const show_sl_btn = document.getElementById("show_suffix_links");
    show_sl_btn.addEventListener("change", redraw);
    const show_esl_btn = document.getElementById("show_extended_suffix_links");
    show_esl_btn.addEventListener("change", redraw);
    const create_inode_btn = document.getElementById("create_implicit_node");
    create_inode_btn.addEventListener("change", redraw);
    network.on("hoverEdge", function (e) {
        console.log("hoverEdge", e);
        // console.log('networkData.edges', networkData.edges.get(e.edge))
        // @ts-ignore
        networkData.edges.update({ id: e.edge, font: { size: 34 } });
    });
    network.on("blurEdge", function (e) {
        console.log("blurEdge", e);
        // @ts-ignore
        networkData.edges.update({ id: e.edge, font: { size: 14 } });
    });
    // load and set parameters
    const params = load_params_from_url();
    set_params_to_html(params);
    redraw();
};
main();


/***/ }),

/***/ "./src/visjs_default_options.ts":
/*!**************************************!*\
  !*** ./src/visjs_default_options.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.options = void 0;
exports.options = {
    height: "100%",
    layout: {
        hierarchical: {
            // enabled: true
            // direction: 'UD',
            direction: "LR",
            // sortMethod: 'directed',
            treeSpacing: 185,
            levelSeparation: 95,
            nodeSpacing: 40,
        },
    },
    nodes: {
        size: 10,
    },
    edges: {
        arrows: {
            to: {
                enabled: true,
                scaleFactor: 0.5,
            },
        },
        // edge label is not displayed at the center of the edge
        // if `smooth` is specified
        smooth: {
            enabled: true,
            // type: 'dynamic',
            type: "vertical",
            // type: 'horizontal', // This is better for UD
            // type: 'continuous',
            // type: 'curvedCCW',
            // type: 'straightCross',
            roundness: 1.0,
        },
    },
    interaction: {
        hover: true,
        navigationButtons: true,
    },
    physics: false,
};


/***/ }),

/***/ "./node_modules/vis-network/standalone/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/vis-network/standalone/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.DataSet),
/* harmony export */   "DataView": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.DataView),
/* harmony export */   "Network": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.Network),
/* harmony export */   "NetworkImages": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.NetworkImages),
/* harmony export */   "Queue": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.Queue),
/* harmony export */   "data": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.data),
/* harmony export */   "networkDOTParser": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkDOTParser),
/* harmony export */   "networkGephiParser": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkGephiParser),
/* harmony export */   "networkOptions": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkOptions),
/* harmony export */   "parseDOTNetwork": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.parseGephiNetwork)
/* harmony export */ });
/* harmony import */ var _vis_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vis-network */ "./node_modules/vis-network/standalone/esm/vis-network.js");



/***/ }),

/***/ "./node_modules/vis-network/standalone/esm/vis-network.js":
/*!****************************************************************!*\
  !*** ./node_modules/vis-network/standalone/esm/vis-network.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* binding */ DataSet),
/* harmony export */   "DataView": () => (/* binding */ DataView),
/* harmony export */   "Network": () => (/* binding */ Network),
/* harmony export */   "NetworkImages": () => (/* binding */ Images),
/* harmony export */   "Queue": () => (/* binding */ Queue),
/* harmony export */   "data": () => (/* binding */ index),
/* harmony export */   "networkDOTParser": () => (/* binding */ dotparser),
/* harmony export */   "networkGephiParser": () => (/* binding */ gephiParser),
/* harmony export */   "networkOptions": () => (/* binding */ options),
/* harmony export */   "parseDOTNetwork": () => (/* binding */ parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* binding */ parseGephi)
/* harmony export */ });
/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.1.2
 * @date    2022-03-28T20:13:51.046Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global$P = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

var fails$t = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$s = fails$t;
var functionBindNative = !fails$s(function () {
  var test = function () {
    /* empty */
  }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$4 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$6 = FunctionPrototype$3.apply;
var call$d = FunctionPrototype$3.call; // eslint-disable-next-line es/no-reflect -- safe

var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$d.bind(apply$6) : function () {
  return call$d.apply(apply$6, arguments);
});

var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$d = FunctionPrototype$2.bind;
var call$c = FunctionPrototype$2.call;
var uncurryThis$w = NATIVE_BIND$3 && bind$d.bind(call$c, call$c);
var functionUncurryThis = NATIVE_BIND$3 ? function (fn) {
  return fn && uncurryThis$w(fn);
} : function (fn) {
  return fn && function () {
    return call$c.apply(fn, arguments);
  };
};

// https://tc39.es/ecma262/#sec-iscallable

var isCallable$h = function (argument) {
  return typeof argument == 'function';
};

var objectGetOwnPropertyDescriptor = {};

var fails$r = fails$t; // Detect IE8's incomplete defineProperty implementation

var descriptors = !fails$r(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] != 7;
});

var NATIVE_BIND$2 = functionBindNative;
var call$b = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$b.bind(call$b) : function () {
  return call$b.apply(call$b, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor$8 && !$propertyIsEnumerable$2.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$8(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;

var createPropertyDescriptor$5 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var uncurryThis$v = functionUncurryThis;
var toString$a = uncurryThis$v({}.toString);
var stringSlice$1 = uncurryThis$v(''.slice);

var classofRaw$1 = function (it) {
  return stringSlice$1(toString$a(it), 8, -1);
};

var global$O = global$P;
var uncurryThis$u = functionUncurryThis;
var fails$q = fails$t;
var classof$f = classofRaw$1;
var Object$a = global$O.Object;
var split = uncurryThis$u(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails$q(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object$a('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$f(it) == 'String' ? split(it, '') : Object$a(it);
} : Object$a;

var global$N = global$P;
var TypeError$j = global$N.TypeError; // `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible

var requireObjectCoercible$5 = function (it) {
  if (it == undefined) throw TypeError$j("Can't call method on " + it);
  return it;
};

var IndexedObject$3 = indexedObject;
var requireObjectCoercible$4 = requireObjectCoercible$5;

var toIndexedObject$b = function (it) {
  return IndexedObject$3(requireObjectCoercible$4(it));
};

var isCallable$g = isCallable$h;

var isObject$j = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$g(it);
};

var path$y = {};

var path$x = path$y;
var global$M = global$P;
var isCallable$f = isCallable$h;

var aFunction = function (variable) {
  return isCallable$f(variable) ? variable : undefined;
};

var getBuiltIn$9 = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path$x[namespace]) || aFunction(global$M[namespace]) : path$x[namespace] && path$x[namespace][method] || global$M[namespace] && global$M[namespace][method];
};

var uncurryThis$t = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$t({}.isPrototypeOf);

var getBuiltIn$8 = getBuiltIn$9;
var engineUserAgent = getBuiltIn$8('navigator', 'userAgent') || '';

var global$L = global$P;
var userAgent$3 = engineUserAgent;
var process = global$L.process;
var Deno = global$L.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us

  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
} // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0


if (!version && userAgent$3) {
  match = userAgent$3.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent$3.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

var engineV8Version = version;

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION$2 = engineV8Version;
var fails$p = fails$t; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$p(function () {
  var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
});

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL$2 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

var global$K = global$P;
var getBuiltIn$7 = getBuiltIn$9;
var isCallable$e = isCallable$h;
var isPrototypeOf$m = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$9 = global$K.Object;
var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$7('Symbol');
  return isCallable$e($Symbol) && isPrototypeOf$m($Symbol.prototype, Object$9(it));
};

var global$J = global$P;
var String$4 = global$J.String;

var tryToString$4 = function (argument) {
  try {
    return String$4(argument);
  } catch (error) {
    return 'Object';
  }
};

var global$I = global$P;
var isCallable$d = isCallable$h;
var tryToString$3 = tryToString$4;
var TypeError$i = global$I.TypeError; // `Assert: IsCallable(argument) is true`

var aCallable$7 = function (argument) {
  if (isCallable$d(argument)) return argument;
  throw TypeError$i(tryToString$3(argument) + ' is not a function');
};

var aCallable$6 = aCallable$7; // `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod

var getMethod$3 = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable$6(func);
};

var global$H = global$P;
var call$a = functionCall;
var isCallable$c = isCallable$h;
var isObject$i = isObject$j;
var TypeError$h = global$H.TypeError; // `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive

var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$c(fn = input.toString) && !isObject$i(val = call$a(fn, input))) return val;
  if (isCallable$c(fn = input.valueOf) && !isObject$i(val = call$a(fn, input))) return val;
  if (pref !== 'string' && isCallable$c(fn = input.toString) && !isObject$i(val = call$a(fn, input))) return val;
  throw TypeError$h("Can't convert object to primitive value");
};

var shared$4 = {exports: {}};

var global$G = global$P; // eslint-disable-next-line es/no-object-defineproperty -- safe

var defineProperty$e = Object.defineProperty;

var setGlobal$1 = function (key, value) {
  try {
    defineProperty$e(global$G, key, {
      value: value,
      configurable: true,
      writable: true
    });
  } catch (error) {
    global$G[key] = value;
  }

  return value;
};

var global$F = global$P;
var setGlobal = setGlobal$1;
var SHARED = '__core-js_shared__';
var store$3 = global$F[SHARED] || setGlobal(SHARED, {});
var sharedStore = store$3;

var store$2 = sharedStore;
(shared$4.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.21.1',
  mode: 'pure' ,
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var global$E = global$P;
var requireObjectCoercible$3 = requireObjectCoercible$5;
var Object$8 = global$E.Object; // `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject

var toObject$e = function (argument) {
  return Object$8(requireObjectCoercible$3(argument));
};

var uncurryThis$s = functionUncurryThis;
var toObject$d = toObject$e;
var hasOwnProperty = uncurryThis$s({}.hasOwnProperty); // `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty

var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$d(it), key);
};

var uncurryThis$r = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$9 = uncurryThis$r(1.0.toString);

var uid$4 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$9(++id$2 + postfix, 36);
};

var global$D = global$P;
var shared$3 = shared$4.exports;
var hasOwn$h = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL$1 = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore$1 = shared$3('wks');
var Symbol$3 = global$D.Symbol;
var symbolFor = Symbol$3 && Symbol$3['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$3;

var wellKnownSymbol$j = function (name) {
  if (!hasOwn$h(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name] == 'string')) {
    var description = 'Symbol.' + name;

    if (NATIVE_SYMBOL$1 && hasOwn$h(Symbol$3, name)) {
      WellKnownSymbolsStore$1[name] = Symbol$3[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore$1[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
    }
  }

  return WellKnownSymbolsStore$1[name];
};

var global$C = global$P;
var call$9 = functionCall;
var isObject$h = isObject$j;
var isSymbol$2 = isSymbol$3;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$i = wellKnownSymbol$j;
var TypeError$g = global$C.TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$i('toPrimitive'); // `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive

var toPrimitive$1 = function (input, pref) {
  if (!isObject$h(input) || isSymbol$2(input)) return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
  var result;

  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$9(exoticToPrim, input, pref);
    if (!isObject$h(result) || isSymbol$2(result)) return result;
    throw TypeError$g("Can't convert object to primitive value");
  }

  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol$1 = isSymbol$3; // `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey

var toPropertyKey$4 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol$1(key) ? key : key + '';
};

var global$B = global$P;
var isObject$g = isObject$j;
var document$1 = global$B.document; // typeof document.createElement is 'object' in old IE

var EXISTS$1 = isObject$g(document$1) && isObject$g(document$1.createElement);

var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};

var DESCRIPTORS$h = descriptors;
var fails$o = fails$t;
var createElement = documentCreateElement$1; // Thanks to IE8 for its funny defineProperty

var ie8DomDefine = !DESCRIPTORS$h && !fails$o(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var DESCRIPTORS$g = descriptors;
var call$8 = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$a = toIndexedObject$b;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$g = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$a(O);
  P = toPropertyKey$3(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$2(O, P);
  } catch (error) {
    /* empty */
  }
  if (hasOwn$g(O, P)) return createPropertyDescriptor$4(!call$8(propertyIsEnumerableModule$2.f, O, P), O[P]);
};

var fails$n = fails$t;
var isCallable$b = isCallable$h;
var replacement = /#|\.prototype\./;

var isForced$1 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$n(detection) : !!detection;
};

var normalize = isForced$1.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = 'N';
var POLYFILL = isForced$1.POLYFILL = 'P';
var isForced_1 = isForced$1;

var uncurryThis$q = functionUncurryThis;
var aCallable$5 = aCallable$7;
var NATIVE_BIND$1 = functionBindNative;
var bind$c = uncurryThis$q(uncurryThis$q.bind); // optional / simple context binding

var functionBindContext = function (fn, that) {
  aCallable$5(fn);
  return that === undefined ? fn : NATIVE_BIND$1 ? bind$c(fn, that) : function
    /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

var objectDefineProperty = {};

var DESCRIPTORS$f = descriptors;
var fails$m = fails$t; // V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334

var v8PrototypeDefineBug = DESCRIPTORS$f && fails$m(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {
    /* empty */
  }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var global$A = global$P;
var isObject$f = isObject$j;
var String$3 = global$A.String;
var TypeError$f = global$A.TypeError; // `Assert: Type(argument) is Object`

var anObject$d = function (argument) {
  if (isObject$f(argument)) return argument;
  throw TypeError$f(String$3(argument) + ' is not an object');
};

var global$z = global$P;
var DESCRIPTORS$e = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$c = anObject$d;
var toPropertyKey$2 = toPropertyKey$4;
var TypeError$e = global$z.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable'; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty

objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$2(P);
  anObject$c(Attributes);

  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);

    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }

  return $defineProperty$1(O, P, Attributes);
} : $defineProperty$1 : function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$2(P);
  anObject$c(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty$1(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError$e('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$d = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;
var createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var global$y = global$P;
var apply$5 = functionApply;
var uncurryThis$p = functionUncurryThis;
var isCallable$a = isCallable$h;
var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
var isForced = isForced_1;
var path$w = path$y;
var bind$b = functionBindContext;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$f = hasOwnProperty_1;

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();

        case 1:
          return new NativeConstructor(a);

        case 2:
          return new NativeConstructor(a, b);
      }

      return new NativeConstructor(a, b, c);
    }

    return apply$5(NativeConstructor, this, arguments);
  };

  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/


var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? global$y : STATIC ? global$y[TARGET] : (global$y[TARGET] || {}).prototype;
  var target = GLOBAL ? path$w : path$w[TARGET] || createNonEnumerableProperty$5(path$w, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native

    USE_NATIVE = !FORCED && nativeSource && hasOwn$f(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE) if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$7(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key]; // export native or implementation

    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue; // bind timers to global for call from export context

    if (options.bind && USE_NATIVE) resultProperty = bind$b(sourceProperty, global$y); // wrap global constructors for prevent changs in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods
    else if (PROTO && isCallable$a(sourceProperty)) resultProperty = uncurryThis$p(sourceProperty); // default case
    else resultProperty = sourceProperty; // add a flag to not completely full polyfills

    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$5(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty$5(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';

      if (!hasOwn$f(path$w, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty$5(path$w, VIRTUAL_PROTOTYPE, {});
      } // export virtual prototype methods


      createNonEnumerableProperty$5(path$w[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods

      if (options.real && targetPrototype && !targetPrototype[key]) {
        createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);
      }
    }
  }
};

var ceil = Math.ceil;
var floor$1 = Math.floor; // `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity

var toIntegerOrInfinity$4 = function (argument) {
  var number = +argument; // eslint-disable-next-line no-self-compare -- safe

  return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
};

var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$3 = Math.max;
var min$2 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

var toAbsoluteIndex$5 = function (index, length) {
  var integer = toIntegerOrInfinity$3(index);
  return integer < 0 ? max$3(integer + length, 0) : min$2(integer, length);
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$1 = Math.min; // `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength

var toLength$1 = function (argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength = toLength$1; // `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike

var lengthOfArrayLike$d = function (obj) {
  return toLength(obj.length);
};

var toIndexedObject$9 = toIndexedObject$b;
var toAbsoluteIndex$4 = toAbsoluteIndex$5;
var lengthOfArrayLike$c = lengthOfArrayLike$d; // `Array.prototype.{ indexOf, includes }` methods implementation

var createMethod$5 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$9($this);
    var length = lengthOfArrayLike$c(O);
    var index = toAbsoluteIndex$4(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$5(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$5(false)
};

var hiddenKeys$6 = {};

var uncurryThis$o = functionUncurryThis;
var hasOwn$e = hasOwnProperty_1;
var toIndexedObject$8 = toIndexedObject$b;
var indexOf$4 = arrayIncludes.indexOf;
var hiddenKeys$5 = hiddenKeys$6;
var push$5 = uncurryThis$o([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$8(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !hasOwn$e(hiddenKeys$5, key) && hasOwn$e(O, key) && push$5(result, key); // Don't enum bug & hidden keys


  while (names.length > i) if (hasOwn$e(O, key = names[i++])) {
    ~indexOf$4(result, key) || push$5(result, key);
  }

  return result;
};

var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3; // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe

var objectKeys$4 = Object.keys || function keys(O) {
  return internalObjectKeys$1(O, enumBugKeys$2);
};

var objectGetOwnPropertySymbols = {};

objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var DESCRIPTORS$c = descriptors;
var uncurryThis$n = functionUncurryThis;
var call$7 = functionCall;
var fails$l = fails$t;
var objectKeys$3 = objectKeys$4;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var toObject$c = toObject$e;
var IndexedObject$2 = indexedObject; // eslint-disable-next-line es/no-object-assign -- safe

var $assign = Object.assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

var defineProperty$d = Object.defineProperty;
var concat$6 = uncurryThis$n([].concat); // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign

var objectAssign = !$assign || fails$l(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS$c && $assign({
    b: 1
  }, $assign(defineProperty$d({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty$d(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

  var A = {};
  var B = {}; // eslint-disable-next-line es/no-symbol -- safe

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys$3($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject$c(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
  var propertyIsEnumerable = propertyIsEnumerableModule$1.f;

  while (argumentsLength > index) {
    var S = IndexedObject$2(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat$6(objectKeys$3(S), getOwnPropertySymbols(S)) : objectKeys$3(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS$c || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

var $$J = _export;
var assign$5 = objectAssign; // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing

$$J({
  target: 'Object',
  stat: true,
  forced: Object.assign !== assign$5
}, {
  assign: assign$5
});

var path$v = path$y;
var assign$4 = path$v.Object.assign;

var parent$1a = assign$4;
var assign$3 = parent$1a;

var assign$2 = assign$3;

var uncurryThis$m = functionUncurryThis;
var arraySlice$5 = uncurryThis$m([].slice);

var global$x = global$P;
var uncurryThis$l = functionUncurryThis;
var aCallable$4 = aCallable$7;
var isObject$e = isObject$j;
var hasOwn$d = hasOwnProperty_1;
var arraySlice$4 = arraySlice$5;
var NATIVE_BIND = functionBindNative;
var Function$2 = global$x.Function;
var concat$5 = uncurryThis$l([].concat);
var join = uncurryThis$l([].join);
var factories = {};

var construct$4 = function (C, argsLength, args) {
  if (!hasOwn$d(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';

    factories[argsLength] = Function$2('C,a', 'return new C(' + join(list, ',') + ')');
  }

  return factories[argsLength](C, args);
}; // `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind


var functionBind = NATIVE_BIND ? Function$2.bind : function bind(that
/* , ...args */
) {
  var F = aCallable$4(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice$4(arguments, 1);

  var boundFunction = function
    /* args... */
  bound() {
    var args = concat$5(partArgs, arraySlice$4(arguments));
    return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);
  };

  if (isObject$e(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};

var $$I = _export;
var bind$a = functionBind; // `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind

$$I({
  target: 'Function',
  proto: true,
  forced: Function.bind !== bind$a
}, {
  bind: bind$a
});

var path$u = path$y;

var entryVirtual$l = function (CONSTRUCTOR) {
  return path$u[CONSTRUCTOR + 'Prototype'];
};

var entryVirtual$k = entryVirtual$l;
var bind$9 = entryVirtual$k('Function').bind;

var isPrototypeOf$l = objectIsPrototypeOf;
var method$h = bind$9;
var FunctionPrototype$1 = Function.prototype;

var bind$8 = function (it) {
  var own = it.bind;
  return it === FunctionPrototype$1 || isPrototypeOf$l(FunctionPrototype$1, it) && own === FunctionPrototype$1.bind ? method$h : own;
};

var parent$19 = bind$8;
var bind$7 = parent$19;

var bind$6 = bind$7;

/**
 * Draw a circle.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the circle.
 */
function drawCircle(ctx, x, y, r) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI, false);
  ctx.closePath();
}
/**
 * Draw a square.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the square.
 */

function drawSquare(ctx, x, y, r) {
  ctx.beginPath();
  ctx.rect(x - r, y - r, r * 2, r * 2);
  ctx.closePath();
}
/**
 * Draw an equilateral triangle standing on a side.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */

function drawTriangle(ctx, x, y, r) {
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 1.15;
  y += 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle

  var h = Math.sqrt(s * s - s2 * s2); // height

  ctx.moveTo(x, y - (h - ir));
  ctx.lineTo(x + s2, y + ir);
  ctx.lineTo(x - s2, y + ir);
  ctx.lineTo(x, y - (h - ir));
  ctx.closePath();
}
/**
 * Draw an equilateral triangle standing on a vertex.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */

function drawTriangleDown(ctx, x, y, r) {
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 1.15;
  y -= 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle

  var h = Math.sqrt(s * s - s2 * s2); // height

  ctx.moveTo(x, y + (h - ir));
  ctx.lineTo(x + s2, y - ir);
  ctx.lineTo(x - s2, y - ir);
  ctx.lineTo(x, y + (h - ir));
  ctx.closePath();
}
/**
 * Draw a star.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The outer radius of the star.
 */

function drawStar(ctx, x, y, r) {
  // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 0.82;
  y += 0.1 * r;

  for (var n = 0; n < 10; n++) {
    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
  }

  ctx.closePath();
}
/**
 * Draw a diamond.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the diamond.
 * @remarks
 * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
 */

function drawDiamond(ctx, x, y, r) {
  ctx.beginPath();
  ctx.lineTo(x, y + r);
  ctx.lineTo(x + r, y);
  ctx.lineTo(x, y - r);
  ctx.lineTo(x - r, y);
  ctx.closePath();
}
/**
 * Draw a rectangle with rounded corners.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the rectangle.
 * @param h - The height of the rectangle.
 * @param r - The radius of the corners.
 * @remarks
 * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
 */

function drawRoundRect(ctx, x, y, w, h, r) {
  var r2d = Math.PI / 180;

  if (w - 2 * r < 0) {
    r = w / 2;
  } //ensure that the radius isn't too large for x


  if (h - 2 * r < 0) {
    r = h / 2;
  } //ensure that the radius isn't too large for y


  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
  ctx.lineTo(x + w, y + h - r);
  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
  ctx.lineTo(x + r, y + h);
  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
  ctx.lineTo(x, y + r);
  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
  ctx.closePath();
}
/**
 * Draw an ellipse.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the ellipse.
 * @param h - The height of the ellipse.
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 *
 * Postfix '_vis' added to discern it from standard method ellipse().
 */

function drawEllipse(ctx, x, y, w, h) {
  var kappa = 0.5522848,
      ox = w / 2 * kappa,
      // control point offset horizontal
  oy = h / 2 * kappa,
      // control point offset vertical
  xe = x + w,
      // x-end
  ye = y + h,
      // y-end
  xm = x + w / 2,
      // x-middle
  ym = y + h / 2; // y-middle

  ctx.beginPath();
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
}
/**
 * Draw an isometric cylinder.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the database.
 * @param h - The height of the database.
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 */

function drawDatabase(ctx, x, y, w, h) {
  var f = 1 / 3;
  var wEllipse = w;
  var hEllipse = h * f;
  var kappa = 0.5522848,
      ox = wEllipse / 2 * kappa,
      // control point offset horizontal
  oy = hEllipse / 2 * kappa,
      // control point offset vertical
  xe = x + wEllipse,
      // x-end
  ye = y + hEllipse,
      // y-end
  xm = x + wEllipse / 2,
      // x-middle
  ym = y + hEllipse / 2,
      // y-middle
  ymb = y + (h - hEllipse / 2),
      // y-midlle, bottom ellipse
  yeb = y + h; // y-end, bottom ellipse

  ctx.beginPath();
  ctx.moveTo(xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.lineTo(xe, ymb);
  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);
  ctx.lineTo(x, ym);
}
/**
 * Draw a dashed line.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The start position on the x axis.
 * @param y - The start position on the y axis.
 * @param x2 - The end position on the x axis.
 * @param y2 - The end position on the y axis.
 * @param pattern - List of lengths starting with line and then alternating between space and line.
 * @author David Jordan
 * @remarks
 * date 2012-08-08
 * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
 */

function drawDashedLine(ctx, x, y, x2, y2, pattern) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  var patternLength = pattern.length;
  var dx = x2 - x;
  var dy = y2 - y;
  var slope = dy / dx;
  var distRemaining = Math.sqrt(dx * dx + dy * dy);
  var patternIndex = 0;
  var draw = true;
  var xStep = 0;
  var dashLength = +pattern[0];

  while (distRemaining >= 0.1) {
    dashLength = +pattern[patternIndex++ % patternLength];

    if (dashLength > distRemaining) {
      dashLength = distRemaining;
    }

    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    xStep = dx < 0 ? -xStep : xStep;
    x += xStep;
    y += slope * xStep;

    if (draw === true) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
    }

    distRemaining -= dashLength;
    draw = !draw;
  }
}
/**
 * Draw a hexagon.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the hexagon.
 */

function drawHexagon(ctx, x, y, r) {
  ctx.beginPath();
  var sides = 6;
  var a = Math.PI * 2 / sides;
  ctx.moveTo(x + r, y);

  for (var i = 1; i < sides; i++) {
    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
  }

  ctx.closePath();
}
var shapeMap = {
  circle: drawCircle,
  dashedLine: drawDashedLine,
  database: drawDatabase,
  diamond: drawDiamond,
  ellipse: drawEllipse,
  ellipse_vis: drawEllipse,
  hexagon: drawHexagon,
  roundRect: drawRoundRect,
  square: drawSquare,
  star: drawStar,
  triangle: drawTriangle,
  triangleDown: drawTriangleDown
};
/**
 * Returns either custom or native drawing function base on supplied name.
 *
 * @param name - The name of the function. Either the name of a
 * CanvasRenderingContext2D property or an export from shapes.ts without the
 * draw prefix.
 * @returns The function that can be used for rendering. In case of native
 * CanvasRenderingContext2D function the API is normalized to
 * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.
 */

function getShape(name) {
  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {
    return shapeMap[name];
  } else {
    return function (ctx) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      CanvasRenderingContext2D.prototype[name].call(ctx, args);
    };
  }
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$6 = ".vis-overlay {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";
styleInject(css_248z$6);

var css_248z$5 = "/* override some bootstrap styles screwing up the timelines css */\n\n.vis [class*=\"span\"] {\n  min-height: 0;\n  width: auto;\n}\n";
styleInject(css_248z$5);

var css_248z$4 = "div.vis-color-picker {\n  position: absolute;\n  top: 0px;\n  left: 30px;\n  margin-top: -140px;\n  margin-left: 30px;\n  width: 310px;\n  height: 444px;\n  z-index: 1;\n  padding: 10px;\n  border-radius: 15px;\n  background-color: #ffffff;\n  display: none;\n  box-shadow: rgba(0, 0, 0, 0.5) 0px 0px 10px 0px;\n}\n\ndiv.vis-color-picker div.vis-arrow {\n  position: absolute;\n  top: 147px;\n  left: 5px;\n}\n\ndiv.vis-color-picker div.vis-arrow::after,\ndiv.vis-color-picker div.vis-arrow::before {\n  right: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\ndiv.vis-color-picker div.vis-arrow:after {\n  border-color: rgba(255, 255, 255, 0);\n  border-right-color: #ffffff;\n  border-width: 30px;\n  margin-top: -30px;\n}\n\ndiv.vis-color-picker div.vis-color {\n  position: absolute;\n  width: 289px;\n  height: 289px;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-brightness {\n  position: absolute;\n  top: 313px;\n}\n\ndiv.vis-color-picker div.vis-opacity {\n  position: absolute;\n  top: 350px;\n}\n\ndiv.vis-color-picker div.vis-selector {\n  position: absolute;\n  top: 137px;\n  left: 137px;\n  width: 15px;\n  height: 15px;\n  border-radius: 15px;\n  border: 1px solid #ffffff;\n  background: #4c4c4c; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #4c4c4c),\n    color-stop(12%, #595959),\n    color-stop(25%, #666666),\n    color-stop(39%, #474747),\n    color-stop(50%, #2c2c2c),\n    color-stop(51%, #000000),\n    color-stop(60%, #111111),\n    color-stop(76%, #2b2b2b),\n    color-stop(91%, #1c1c1c),\n    color-stop(100%, #131313)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */\n}\n\ndiv.vis-color-picker div.vis-new-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 159px;\n  text-align: right;\n  padding-right: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-initial-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 10px;\n  text-align: left;\n  padding-left: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-label {\n  position: absolute;\n  width: 300px;\n  left: 10px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-brightness {\n  top: 300px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-opacity {\n  top: 338px;\n}\n\ndiv.vis-color-picker div.vis-button {\n  position: absolute;\n  width: 68px;\n  height: 25px;\n  border-radius: 10px;\n  vertical-align: middle;\n  text-align: center;\n  line-height: 25px;\n  top: 410px;\n  border: 2px solid #d9d9d9;\n  background-color: #f7f7f7;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-button.vis-cancel {\n  /*border:2px solid #ff4e33;*/\n  /*background-color: #ff7761;*/\n  left: 5px;\n}\ndiv.vis-color-picker div.vis-button.vis-load {\n  /*border:2px solid #a153e6;*/\n  /*background-color: #cb8dff;*/\n  left: 82px;\n}\ndiv.vis-color-picker div.vis-button.vis-apply {\n  /*border:2px solid #4588e6;*/\n  /*background-color: #82b6ff;*/\n  left: 159px;\n}\ndiv.vis-color-picker div.vis-button.vis-save {\n  /*border:2px solid #45e655;*/\n  /*background-color: #6dff7c;*/\n  left: 236px;\n}\n\ndiv.vis-color-picker input.vis-range {\n  width: 290px;\n  height: 20px;\n}\n\n/* TODO: is this redundant?\ndiv.vis-color-picker input.vis-range-brightness {\n  width: 289px !important;\n}\n\n\ndiv.vis-color-picker input.vis-saturation-range {\n  width: 289px !important;\n}*/\n";
styleInject(css_248z$4);

var css_248z$3 = "div.vis-configuration {\n  position: relative;\n  display: block;\n  float: left;\n  font-size: 12px;\n}\n\ndiv.vis-configuration-wrapper {\n  display: block;\n  width: 700px;\n}\n\ndiv.vis-configuration-wrapper::after {\n  clear: both;\n  content: \"\";\n  display: block;\n}\n\ndiv.vis-configuration.vis-config-option-container {\n  display: block;\n  width: 495px;\n  background-color: #ffffff;\n  border: 2px solid #f7f8fa;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n}\n\ndiv.vis-configuration.vis-config-button {\n  display: block;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n  background-color: #f7f8fa;\n  border: 2px solid #ceced0;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n  cursor: pointer;\n  margin-bottom: 30px;\n}\n\ndiv.vis-configuration.vis-config-button.hover {\n  background-color: #4588e6;\n  border: 2px solid #214373;\n  color: #ffffff;\n}\n\ndiv.vis-configuration.vis-config-item {\n  display: block;\n  float: left;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-item.vis-config-s2 {\n  left: 10px;\n  background-color: #f7f8fa;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s3 {\n  left: 20px;\n  background-color: #e4e9f0;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s4 {\n  left: 30px;\n  background-color: #cfd8e6;\n  padding-left: 5px;\n  border-radius: 3px;\n}\n\ndiv.vis-configuration.vis-config-header {\n  font-size: 18px;\n  font-weight: bold;\n}\n\ndiv.vis-configuration.vis-config-label {\n  width: 120px;\n  height: 25px;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-label.vis-config-s3 {\n  width: 110px;\n}\ndiv.vis-configuration.vis-config-label.vis-config-s4 {\n  width: 100px;\n}\n\ndiv.vis-configuration.vis-config-colorBlock {\n  top: 1px;\n  width: 30px;\n  height: 19px;\n  border: 1px solid #444444;\n  border-radius: 2px;\n  padding: 0px;\n  margin: 0px;\n  cursor: pointer;\n}\n\ninput.vis-configuration.vis-config-checkbox {\n  left: -5px;\n}\n\ninput.vis-configuration.vis-config-rangeinput {\n  position: relative;\n  top: -5px;\n  width: 60px;\n  /*height:13px;*/\n  padding: 1px;\n  margin: 0;\n  pointer-events: none;\n}\n\ninput.vis-configuration.vis-config-range {\n  /*removes default webkit styles*/\n  -webkit-appearance: none;\n\n  /*fix for FF unable to apply focus style bug */\n  border: 0px solid white;\n  background-color: rgba(0, 0, 0, 0);\n\n  /*required for proper track sizing in FF*/\n  width: 300px;\n  height: 20px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-runnable-track {\n  width: 300px;\n  height: 5px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  border: 1px solid #14334b;\n  height: 17px;\n  width: 17px;\n  border-radius: 50%;\n  background: #3876c2; /* Old browsers */\n  background: -moz-linear-gradient(top, #3876c2 0%, #385380 100%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #3876c2),\n    color-stop(100%, #385380)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #3876c2 0%, #385380 100%); /* IE10+ */\n  background: linear-gradient(to bottom, #3876c2 0%, #385380 100%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */\n  box-shadow: #111927 0px 0px 1px 0px;\n  margin-top: -7px;\n}\ninput.vis-configuration.vis-config-range:focus {\n  outline: none;\n}\ninput.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {\n  background: #9d9d9d; /* Old browsers */\n  background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #9d9d9d),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #9d9d9d 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n}\n\ninput.vis-configuration.vis-config-range::-moz-range-track {\n  width: 300px;\n  height: 10px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-moz-range-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n\n  border-radius: 50%;\n  background: #385380;\n}\n\n/*hide the outline behind the border*/\ninput.vis-configuration.vis-config-range:-moz-focusring {\n  outline: 1px solid white;\n  outline-offset: -1px;\n}\n\ninput.vis-configuration.vis-config-range::-ms-track {\n  width: 300px;\n  height: 5px;\n\n  /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */\n  background: transparent;\n\n  /*leave room for the larger thumb to overflow with a transparent border */\n  border-color: transparent;\n  border-width: 6px 0;\n\n  /*remove default tick marks*/\n  color: transparent;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-lower {\n  background: #777;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-upper {\n  background: #ddd;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n  border-radius: 50%;\n  background: #385380;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-lower {\n  background: #888;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-upper {\n  background: #ccc;\n}\n\n.vis-configuration-popup {\n  position: absolute;\n  background: rgba(57, 76, 89, 0.85);\n  border: 2px solid #f2faff;\n  line-height: 30px;\n  height: 30px;\n  width: 150px;\n  text-align: center;\n  color: #ffffff;\n  font-size: 14px;\n  border-radius: 4px;\n  -webkit-transition: opacity 0.3s ease-in-out;\n  -moz-transition: opacity 0.3s ease-in-out;\n  transition: opacity 0.3s ease-in-out;\n}\n.vis-configuration-popup:after,\n.vis-configuration-popup:before {\n  left: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.vis-configuration-popup:after {\n  border-color: rgba(136, 183, 213, 0);\n  border-left-color: rgba(57, 76, 89, 0.85);\n  border-width: 8px;\n  margin-top: -8px;\n}\n.vis-configuration-popup:before {\n  border-color: rgba(194, 225, 245, 0);\n  border-left-color: #f2faff;\n  border-width: 12px;\n  margin-top: -12px;\n}\n";
styleInject(css_248z$3);

var css_248z$2 = "div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size: 14px;\n  color: #000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";
styleInject(css_248z$2);

var componentEmitter = {exports: {}};

(function (module) {
  /**
   * Expose `Emitter`.
   */
  {
    module.exports = Emitter;
  }
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */


  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    } // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.


    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1),
        callbacks = this._callbacks['$' + event];

    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */


  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };
})(componentEmitter);

var Emitter = componentEmitter.exports;

var wellKnownSymbol$h = wellKnownSymbol$j;
var TO_STRING_TAG$3 = wellKnownSymbol$h('toStringTag');
var test$2 = {};
test$2[TO_STRING_TAG$3] = 'z';
var toStringTagSupport = String(test$2) === '[object z]';

var global$w = global$P;
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$9 = isCallable$h;
var classofRaw = classofRaw$1;
var wellKnownSymbol$g = wellKnownSymbol$j;
var TO_STRING_TAG$2 = wellKnownSymbol$g('toStringTag');
var Object$7 = global$w.Object; // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof$e = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object$7(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && isCallable$9(O.callee) ? 'Arguments' : result;
};

var global$v = global$P;
var classof$d = classof$e;
var String$2 = global$v.String;

var toString$8 = function (argument) {
  if (classof$d(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String$2(argument);
};

var uncurryThis$k = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$7 = toString$8;
var requireObjectCoercible$2 = requireObjectCoercible$5;
var charAt$3 = uncurryThis$k(''.charAt);
var charCodeAt$1 = uncurryThis$k(''.charCodeAt);
var stringSlice = uncurryThis$k(''.slice);

var createMethod$4 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$7(requireObjectCoercible$2($this));
    var position = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt$1(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$3(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$4(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$4(true)
};

var uncurryThis$j = functionUncurryThis;
var isCallable$8 = isCallable$h;
var store$1 = sharedStore;
var functionToString = uncurryThis$j(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

if (!isCallable$8(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$2 = store$1.inspectSource;

var global$u = global$P;
var isCallable$7 = isCallable$h;
var inspectSource$1 = inspectSource$2;
var WeakMap$1 = global$u.WeakMap;
var nativeWeakMap = isCallable$7(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));

var shared$2 = shared$4.exports;
var uid$2 = uid$4;
var keys$7 = shared$2('keys');

var sharedKey$4 = function (key) {
  return keys$7[key] || (keys$7[key] = uid$2(key));
};

var NATIVE_WEAK_MAP$1 = nativeWeakMap;
var global$t = global$P;
var uncurryThis$i = functionUncurryThis;
var isObject$d = isObject$j;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var hasOwn$c = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$4 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$d = global$t.TypeError;
var WeakMap = global$t.WeakMap;
var set$3, get$6, has;

var enforce = function (it) {
  return has(it) ? get$6(it) : set$3(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject$d(it) || (state = get$6(it)).type !== TYPE) {
      throw TypeError$d('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (NATIVE_WEAK_MAP$1 || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap());
  var wmget = uncurryThis$i(store.get);
  var wmhas = uncurryThis$i(store.has);
  var wmset = uncurryThis$i(store.set);

  set$3 = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$d(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };

  get$6 = function (it) {
    return wmget(store, it) || {};
  };

  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$3('state');
  hiddenKeys$4[STATE] = true;

  set$3 = function (it, metadata) {
    if (hasOwn$c(it, STATE)) throw new TypeError$d(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$4(it, STATE, metadata);
    return metadata;
  };

  get$6 = function (it) {
    return hasOwn$c(it, STATE) ? it[STATE] : {};
  };

  has = function (it) {
    return hasOwn$c(it, STATE);
  };
}

var internalState = {
  set: set$3,
  get: get$6,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var DESCRIPTORS$b = descriptors;
var hasOwn$b = hasOwnProperty_1;
var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$b(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

var PROPER = EXISTS && function something() {
  /* empty */
}.name === 'something';

var CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype, 'name').configurable);
var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var objectDefineProperties = {};

var DESCRIPTORS$a = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$b = anObject$d;
var toIndexedObject$7 = toIndexedObject$b;
var objectKeys$2 = objectKeys$4; // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe

objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$b(O);
  var props = toIndexedObject$7(Properties);
  var keys = objectKeys$2(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) definePropertyModule$3.f(O, key = keys[index++], props[key]);

  return O;
};

var getBuiltIn$6 = getBuiltIn$9;
var html$1 = getBuiltIn$6('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */
var anObject$a = anObject$d;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$3 = hiddenKeys$6;
var html = html$1;
var documentCreateElement = documentCreateElement$1;
var sharedKey$2 = sharedKey$4;
var GT = '>';
var LT = '<';
var PROTOTYPE$1 = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$2('IE_PROTO');

var EmptyConstructor = function () {
  /* empty */
};

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak

  return temp;
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
}; // Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug


var activeXDocument;

var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) {
    /* ignore */
  }

  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

  var length = enumBugKeys$1.length;

  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];

  return NullProtoObject();
};

hiddenKeys$3[IE_PROTO$1] = true; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$a(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();

  return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);
};

var fails$k = fails$t;
var correctPrototypeGetter = !fails$k(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var global$s = global$P;
var hasOwn$a = hasOwnProperty_1;
var isCallable$6 = isCallable$h;
var toObject$b = toObject$e;
var sharedKey$1 = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var IE_PROTO = sharedKey$1('IE_PROTO');
var Object$6 = global$s.Object;
var ObjectPrototype$2 = Object$6.prototype; // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$6.getPrototypeOf : function (O) {
  var object = toObject$b(O);
  if (hasOwn$a(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;

  if (isCallable$6(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }

  return object instanceof Object$6 ? ObjectPrototype$2 : null;
};

var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

var redefine$4 = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty$3(target, key, value);
};

var fails$j = fails$t;
var isCallable$5 = isCallable$h;
var create$a = objectCreate;
var getPrototypeOf$8 = objectGetPrototypeOf;
var redefine$3 = redefine$4;
var wellKnownSymbol$f = wellKnownSymbol$j;
var ITERATOR$6 = wellKnownSymbol$f('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object

var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$8(getPrototypeOf$8(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$j(function () {
  var test = {}; // FF44- legacy iterators case

  return IteratorPrototype$1[ITERATOR$6].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};else IteratorPrototype$1 = create$a(IteratorPrototype$1); // `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

if (!isCallable$5(IteratorPrototype$1[ITERATOR$6])) {
  redefine$3(IteratorPrototype$1, ITERATOR$6, function () {
    return this;
  });
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$c = classof$e; // `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring

var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return '[object ' + classof$c(this) + ']';
};

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineProperty$c = objectDefineProperty.f;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var hasOwn$9 = hasOwnProperty_1;
var toString$6 = objectToString;
var wellKnownSymbol$e = wellKnownSymbol$j;
var TO_STRING_TAG$1 = wellKnownSymbol$e('toStringTag');

var setToStringTag$5 = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;

    if (!hasOwn$9(target, TO_STRING_TAG$1)) {
      defineProperty$c(target, TO_STRING_TAG$1, {
        configurable: true,
        value: TAG
      });
    }

    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty$2(target, 'toString', toString$6);
    }
  }
};

var iterators = {};

var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$9 = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;
var setToStringTag$4 = setToStringTag$5;
var Iterators$5 = iterators;

var returnThis$1 = function () {
  return this;
};

var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$9(IteratorPrototype, {
    next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)
  });
  setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators$5[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var global$r = global$P;
var isCallable$4 = isCallable$h;
var String$1 = global$r.String;
var TypeError$c = global$r.TypeError;

var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$4(argument)) return argument;
  throw TypeError$c("Can't set " + String$1(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */
var uncurryThis$h = functionUncurryThis;
var anObject$9 = anObject$d;
var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe

var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis$h(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject$9(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var $$H = _export;
var call$6 = functionCall;
var FunctionName = functionName;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$7 = objectGetPrototypeOf;
var setToStringTag$3 = setToStringTag$5;
var redefine$2 = redefine$4;
var wellKnownSymbol$d = wellKnownSymbol$j;
var Iterators$4 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$5 = wellKnownSymbol$d('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () {
  return this;
};

var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$5] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$7(anyNativeIterator.call(new Iterable()));

    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {


      setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      Iterators$4[TO_STRING_TAG] = returnThis;
    }
  } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    {
      INCORRECT_VALUES_NAME = true;

      defaultIterator = function values() {
        return call$6(nativeIterator, this);
      };
    }
  } // export additional methods


  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine$2(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$H({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  } // define iterator


  if ((FORCED) && IterablePrototype[ITERATOR$5] !== defaultIterator) {
    redefine$2(IterablePrototype, ITERATOR$5, defaultIterator, {
      name: DEFAULT
    });
  }

  Iterators$4[NAME] = defaultIterator;
  return methods;
};

var charAt$2 = stringMultibyte.charAt;
var toString$5 = toString$8;
var InternalStateModule$5 = internalState;
var defineIterator$2 = defineIterator$3;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator

defineIterator$2(String, 'String', function (iterated) {
  setInternalState$5(this, {
    type: STRING_ITERATOR,
    string: toString$5(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt$2(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

var call$5 = functionCall;
var anObject$8 = anObject$d;
var getMethod$1 = getMethod$3;

var iteratorClose$2 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$8(iterator);

  try {
    innerResult = getMethod$1(iterator, 'return');

    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }

    innerResult = call$5(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }

  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$8(innerResult);
  return value;
};

var anObject$7 = anObject$d;
var iteratorClose$1 = iteratorClose$2; // call something on iterator step with safe closing on error

var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject$7(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose$1(iterator, 'throw', error);
  }
};

var wellKnownSymbol$c = wellKnownSymbol$j;
var Iterators$3 = iterators;
var ITERATOR$4 = wellKnownSymbol$c('iterator');
var ArrayPrototype$i = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod$2 = function (it) {
  return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$i[ITERATOR$4] === it);
};

var uncurryThis$g = functionUncurryThis;
var fails$i = fails$t;
var isCallable$3 = isCallable$h;
var classof$b = classof$e;
var getBuiltIn$5 = getBuiltIn$9;
var inspectSource = inspectSource$2;

var noop = function () {
  /* empty */
};

var empty = [];
var construct$3 = getBuiltIn$5('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$g(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$3(argument)) return false;

  try {
    construct$3(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$3(argument)) return false;

  switch (classof$b(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction':
      return false;
  }

  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor

var isConstructor$4 = !construct$3 || fails$i(function () {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;

var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;

var createProperty$6 = function (object, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object) definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$1(0, value));else object[propertyKey] = value;
};

var classof$a = classof$e;
var getMethod = getMethod$3;
var Iterators$2 = iterators;
var wellKnownSymbol$b = wellKnownSymbol$j;
var ITERATOR$3 = wellKnownSymbol$b('iterator');

var getIteratorMethod$8 = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR$3) || getMethod(it, '@@iterator') || Iterators$2[classof$a(it)];
};

var global$q = global$P;
var call$4 = functionCall;
var aCallable$3 = aCallable$7;
var anObject$6 = anObject$d;
var tryToString$2 = tryToString$4;
var getIteratorMethod$7 = getIteratorMethod$8;
var TypeError$b = global$q.TypeError;

var getIterator$7 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;
  if (aCallable$3(iteratorMethod)) return anObject$6(call$4(iteratorMethod, argument));
  throw TypeError$b(tryToString$2(argument) + ' is not iterable');
};

var global$p = global$P;
var bind$5 = functionBindContext;
var call$3 = functionCall;
var toObject$a = toObject$e;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$3 = isConstructor$4;
var lengthOfArrayLike$b = lengthOfArrayLike$d;
var createProperty$5 = createProperty$6;
var getIterator$6 = getIterator$7;
var getIteratorMethod$6 = getIteratorMethod$8;
var Array$5 = global$p.Array; // `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from

var arrayFrom = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject$a(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$3(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind$5(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod$6(O);
  var index = 0;
  var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod && !(this == Array$5 && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator = getIterator$6(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];

    for (; !(step = call$3(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$5(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$b(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array$5(length);

    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$5(result, index, value);
    }
  }

  result.length = index;
  return result;
};

var wellKnownSymbol$a = wellKnownSymbol$j;
var ITERATOR$2 = wellKnownSymbol$a('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

var $$G = _export;
var from$6 = arrayFrom;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
}); // `Array.from` method
// https://tc39.es/ecma262/#sec-array.from

$$G({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from$6
});

var path$t = path$y;
var from$5 = path$t.Array.from;

var parent$18 = from$5;
var from$4 = parent$18;

var from$3 = from$4;

var toIndexedObject$6 = toIndexedObject$b;
var Iterators$1 = iterators;
var InternalStateModule$4 = internalState;
objectDefineProperty.f;
var defineIterator$1 = defineIterator$3;
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$1 = InternalStateModule$4.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator

defineIterator$1(Array, 'Array', function (iterated, kind) {
  setInternalState$4(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$6(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject

Iterators$1.Arguments = Iterators$1.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var getIteratorMethod$5 = getIteratorMethod$8;
var getIteratorMethod_1 = getIteratorMethod$5;

// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

var DOMIterables$4 = domIterables;
var global$o = global$P;
var classof$9 = classof$e;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var Iterators = iterators;
var wellKnownSymbol$9 = wellKnownSymbol$j;
var TO_STRING_TAG = wellKnownSymbol$9('toStringTag');

for (var COLLECTION_NAME in DOMIterables$4) {
  var Collection = global$o[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype && classof$9(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }

  Iterators[COLLECTION_NAME] = Iterators.Array;
}

var parent$17 = getIteratorMethod_1;
var getIteratorMethod$4 = parent$17;

var parent$16 = getIteratorMethod$4;
var getIteratorMethod$3 = parent$16;

var parent$15 = getIteratorMethod$3;
var getIteratorMethod$2 = parent$15;

var getIteratorMethod$1 = getIteratorMethod$2;

var classof$8 = classofRaw$1; // `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe

var isArray$d = Array.isArray || function isArray(argument) {
  return classof$8(argument) == 'Array';
};

var objectGetOwnPropertyNames = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe

objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys$2);
};

var objectGetOwnPropertyNamesExternal = {};

var global$n = global$P;
var toAbsoluteIndex$3 = toAbsoluteIndex$5;
var lengthOfArrayLike$a = lengthOfArrayLike$d;
var createProperty$4 = createProperty$6;
var Array$4 = global$n.Array;
var max$2 = Math.max;

var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$a(O);
  var k = toAbsoluteIndex$3(start, length);
  var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);
  var result = Array$4(max$2(fin - k, 0));

  for (var n = 0; k < fin; k++, n++) createProperty$4(result, n, O[k]);

  result.length = n;
  return result;
};

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof$7 = classofRaw$1;
var toIndexedObject$5 = toIndexedObject$b;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$3 = arraySliceSimple;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error) {
    return arraySlice$3(windowNames);
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
  return windowNames && classof$7(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$5(it));
};

var wellKnownSymbolWrapped = {};

var wellKnownSymbol$8 = wellKnownSymbol$j;
wellKnownSymbolWrapped.f = wellKnownSymbol$8;

var path$s = path$y;
var hasOwn$8 = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$b = objectDefineProperty.f;

var defineWellKnownSymbol$l = function (NAME) {
  var Symbol = path$s.Symbol || (path$s.Symbol = {});
  if (!hasOwn$8(Symbol, NAME)) defineProperty$b(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule$1.f(NAME)
  });
};

var global$m = global$P;
var isArray$c = isArray$d;
var isConstructor$2 = isConstructor$4;
var isObject$c = isObject$j;
var wellKnownSymbol$7 = wellKnownSymbol$j;
var SPECIES$3 = wellKnownSymbol$7('species');
var Array$3 = global$m.Array; // a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

var arraySpeciesConstructor$1 = function (originalArray) {
  var C;

  if (isArray$c(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (isConstructor$2(C) && (C === Array$3 || isArray$c(C.prototype))) C = undefined;else if (isObject$c(C)) {
      C = C[SPECIES$3];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array$3 : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1; // `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate$4 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind$4 = functionBindContext;
var uncurryThis$f = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$9 = toObject$e;
var lengthOfArrayLike$9 = lengthOfArrayLike$d;
var arraySpeciesCreate$3 = arraySpeciesCreate$4;
var push$4 = uncurryThis$f([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

var createMethod$3 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$9($this);
    var self = IndexedObject$1(O);
    var boundFunction = bind$4(callbackfn, that);
    var length = lengthOfArrayLike$9(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate$3;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);

      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3:
            return true;
          // some

          case 5:
            return value;
          // find

          case 6:
            return index;
          // findIndex

          case 2:
            push$4(target, value);
          // filter
        } else switch (TYPE) {
          case 4:
            return false;
          // every

          case 7:
            push$4(target, value);
          // filterReject
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$3(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$3(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$3(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$3(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$3(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$3(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$3(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$3(7)
};

var $$F = _export;
var global$l = global$P;
var getBuiltIn$4 = getBuiltIn$9;
var apply$4 = functionApply;
var call$2 = functionCall;
var uncurryThis$e = functionUncurryThis;
var DESCRIPTORS$9 = descriptors;
var NATIVE_SYMBOL = nativeSymbol;
var fails$h = fails$t;
var hasOwn$7 = hasOwnProperty_1;
var isArray$b = isArray$d;
var isCallable$2 = isCallable$h;
var isObject$b = isObject$j;
var isPrototypeOf$k = objectIsPrototypeOf;
var isSymbol = isSymbol$3;
var anObject$5 = anObject$d;
var toObject$8 = toObject$e;
var toIndexedObject$4 = toIndexedObject$b;
var toPropertyKey = toPropertyKey$4;
var $toString = toString$8;
var createPropertyDescriptor = createPropertyDescriptor$5;
var nativeObjectCreate = objectCreate;
var objectKeys$1 = objectKeys$4;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var arraySlice$2 = arraySlice$5;
var redefine$1 = redefine$4;
var shared = shared$4.exports;
var sharedKey = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$1 = uid$4;
var wellKnownSymbol$6 = wellKnownSymbol$j;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$k = defineWellKnownSymbol$l;
var setToStringTag$2 = setToStringTag$5;
var InternalStateModule$3 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol$6('toPrimitive');
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState = InternalStateModule$3.getterFor(SYMBOL);
var ObjectPrototype$1 = Object[PROTOTYPE];
var $Symbol = global$l.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError$a = global$l.TypeError;
var QObject = global$l.QObject;
var $stringify$1 = getBuiltIn$4('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;
var nativeDefineProperty = definePropertyModule$1.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push$3 = uncurryThis$e([].push);
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks'); // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = DESCRIPTORS$9 && fails$h(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () {
      return nativeDefineProperty(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
  nativeDefineProperty(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap$1 = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState$3(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS$9) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject$5(O);
  var key = toPropertyKey(P);
  anObject$5(Attributes);

  if (hasOwn$7(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$7(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$7(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject$5(O);
  var properties = toIndexedObject$4(Properties);
  var keys = objectKeys$1(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys, function (key) {
    if (!DESCRIPTORS$9 || call$2($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call$2(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype$1 && hasOwn$7(AllSymbols, P) && !hasOwn$7(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn$7(this, P) || !hasOwn$7(AllSymbols, P) || hasOwn$7(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject$4(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype$1 && hasOwn$7(AllSymbols, key) && !hasOwn$7(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && hasOwn$7(AllSymbols, key) && !(hasOwn$7(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (!hasOwn$7(AllSymbols, key) && !hasOwn$7(hiddenKeys$1, key)) push$3(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (hasOwn$7(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$7(ObjectPrototype$1, key))) {
      push$3(result, AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor


if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf$k(SymbolPrototype, this)) throw TypeError$a('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid$1(description);

    var setter = function (value) {
      if (this === ObjectPrototype$1) call$2(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$7(this, HIDDEN) && hasOwn$7(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (DESCRIPTORS$9 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, {
      configurable: true,
      set: setter
    });
    return wrap$1(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];
  redefine$1(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });
  redefine$1($Symbol, 'withoutSetter', function (description) {
    return wrap$1(uid$1(description), description);
  });
  propertyIsEnumerableModule.f = $propertyIsEnumerable$1;
  definePropertyModule$1.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$1.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap$1(wellKnownSymbol$6(name), name);
  };

  if (DESCRIPTORS$9) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
  }
}

$$F({
  global: true,
  wrap: true,
  forced: !NATIVE_SYMBOL,
  sham: !NATIVE_SYMBOL
}, {
  Symbol: $Symbol
});
$forEach$1(objectKeys$1(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol$k(name);
});
$$F({
  target: SYMBOL,
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = $toString(key);
    if (hasOwn$7(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError$a(sym + ' is not a symbol');
    if (hasOwn$7(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () {
    USE_SETTER = true;
  },
  useSimple: function () {
    USE_SETTER = false;
  }
});
$$F({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL,
  sham: !DESCRIPTORS$9
}, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$F({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

$$F({
  target: 'Object',
  stat: true,
  forced: fails$h(function () {
    getOwnPropertySymbolsModule$1.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule$1.f(toObject$8(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify

if ($stringify$1) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$h(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return $stringify$1([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || $stringify$1({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || $stringify$1(Object(symbol)) != '{}';
  });
  $$F({
    target: 'JSON',
    stat: true,
    forced: FORCED_JSON_STRINGIFY
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice$2(arguments);
      var $replacer = replacer;
      if (!isObject$b(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!isArray$b(replacer)) replacer = function (key, value) {
        if (isCallable$2($replacer)) value = call$2($replacer, this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return apply$4($stringify$1, null, args);
    }
  });
} // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


if (!SymbolPrototype[TO_PRIMITIVE]) {
  var valueOf = SymbolPrototype.valueOf; // eslint-disable-next-line no-unused-vars -- required for .length

  redefine$1(SymbolPrototype, TO_PRIMITIVE, function (hint) {
    // TODO: improve hint logic
    return call$2(valueOf, this);
  });
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag$2($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;

var path$r = path$y;
var getOwnPropertySymbols$2 = path$r.Object.getOwnPropertySymbols;

var parent$14 = getOwnPropertySymbols$2;
var getOwnPropertySymbols$1 = parent$14;

var getOwnPropertySymbols = getOwnPropertySymbols$1;

var getOwnPropertyDescriptor$6 = {exports: {}};

var $$E = _export;
var fails$g = fails$t;
var toIndexedObject$3 = toIndexedObject$b;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$8 = descriptors;
var FAILS_ON_PRIMITIVES$4 = fails$g(function () {
  nativeGetOwnPropertyDescriptor(1);
});
var FORCED$6 = !DESCRIPTORS$8 || FAILS_ON_PRIMITIVES$4; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

$$E({
  target: 'Object',
  stat: true,
  forced: FORCED$6,
  sham: !DESCRIPTORS$8
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject$3(it), key);
  }
});

var path$q = path$y;
var Object$5 = path$q.Object;

var getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor(it, key) {
  return Object$5.getOwnPropertyDescriptor(it, key);
};

if (Object$5.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$5.sham = true;

var parent$13 = getOwnPropertyDescriptor$6.exports;
var getOwnPropertyDescriptor$4 = parent$13;

var getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$4;

var getBuiltIn$3 = getBuiltIn$9;
var uncurryThis$d = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$4 = anObject$d;
var concat$4 = uncurryThis$d([].concat); // all object keys, includes non-enumerable and symbols

var ownKeys$a = getBuiltIn$3('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule$1.f(anObject$4(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$4(keys, getOwnPropertySymbols(it)) : keys;
};

var $$D = _export;
var DESCRIPTORS$7 = descriptors;
var ownKeys$9 = ownKeys$a;
var toIndexedObject$2 = toIndexedObject$b;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var createProperty$3 = createProperty$6; // `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors

$$D({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS$7
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject$2(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
    var keys = ownKeys$9(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty$3(result, key, descriptor);
    }

    return result;
  }
});

var path$p = path$y;
var getOwnPropertyDescriptors$2 = path$p.Object.getOwnPropertyDescriptors;

var parent$12 = getOwnPropertyDescriptors$2;
var getOwnPropertyDescriptors$1 = parent$12;

var getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;

var defineProperties$4 = {exports: {}};

var $$C = _export;
var DESCRIPTORS$6 = descriptors;
var defineProperties$3 = objectDefineProperties.f; // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe

$$C({
  target: 'Object',
  stat: true,
  forced: Object.defineProperties !== defineProperties$3,
  sham: !DESCRIPTORS$6
}, {
  defineProperties: defineProperties$3
});

var path$o = path$y;
var Object$4 = path$o.Object;

var defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {
  return Object$4.defineProperties(T, D);
};

if (Object$4.defineProperties.sham) defineProperties$2.sham = true;

var parent$11 = defineProperties$4.exports;
var defineProperties$1 = parent$11;

var defineProperties = defineProperties$1;

var defineProperty$a = {exports: {}};

var $$B = _export;
var DESCRIPTORS$5 = descriptors;
var defineProperty$9 = objectDefineProperty.f; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe

$$B({
  target: 'Object',
  stat: true,
  forced: Object.defineProperty !== defineProperty$9,
  sham: !DESCRIPTORS$5
}, {
  defineProperty: defineProperty$9
});

var path$n = path$y;
var Object$3 = path$n.Object;

var defineProperty$8 = defineProperty$a.exports = function defineProperty(it, key, desc) {
  return Object$3.defineProperty(it, key, desc);
};

if (Object$3.defineProperty.sham) defineProperty$8.sham = true;

var parent$10 = defineProperty$a.exports;
var defineProperty$7 = parent$10;

var defineProperty$6 = defineProperty$7;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var parent$$ = defineProperty$7;
var defineProperty$5 = parent$$;

var parent$_ = defineProperty$5;
var defineProperty$4 = parent$_;

var defineProperty$3 = defineProperty$4;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;

    defineProperty$3(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);

  defineProperty$3(Constructor, "prototype", {
    writable: false
  });

  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    defineProperty$3(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var $$A = _export;
var isArray$a = isArray$d; // `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray

$$A({
  target: 'Array',
  stat: true
}, {
  isArray: isArray$a
});

var path$m = path$y;
var isArray$9 = path$m.Array.isArray;

var parent$Z = isArray$9;
var isArray$8 = parent$Z;

var parent$Y = isArray$8;
var isArray$7 = parent$Y;

var parent$X = isArray$7;
var isArray$6 = parent$X;

var isArray$5 = isArray$6;

function _arrayWithHoles(arr) {
  if (isArray$5(arr)) return arr;
}

var fails$f = fails$t;
var wellKnownSymbol$5 = wellKnownSymbol$j;
var V8_VERSION$1 = engineV8Version;
var SPECIES$2 = wellKnownSymbol$5('species');

var arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION$1 >= 51 || !fails$f(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES$2] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var $$z = _export;
var global$k = global$P;
var fails$e = fails$t;
var isArray$4 = isArray$d;
var isObject$a = isObject$j;
var toObject$7 = toObject$e;
var lengthOfArrayLike$8 = lengthOfArrayLike$d;
var createProperty$2 = createProperty$6;
var arraySpeciesCreate$2 = arraySpeciesCreate$4;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$4 = wellKnownSymbol$j;
var V8_VERSION = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$4('isConcatSpreadable');
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
var TypeError$9 = global$k.TypeError; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$e(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$4('concat');

var isConcatSpreadable = function (O) {
  if (!isObject$a(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray$4(O);
};

var FORCED$5 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

$$z({
  target: 'Array',
  proto: true,
  forced: FORCED$5
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$7(this);
    var A = arraySpeciesCreate$2(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$8(E);
        if (n + len > MAX_SAFE_INTEGER$1) throw TypeError$9(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) if (k in E) createProperty$2(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER$1) throw TypeError$9(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty$2(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

var defineWellKnownSymbol$j = defineWellKnownSymbol$l; // `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator

defineWellKnownSymbol$j('asyncIterator');

var defineWellKnownSymbol$i = defineWellKnownSymbol$l; // `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance

defineWellKnownSymbol$i('hasInstance');

var defineWellKnownSymbol$h = defineWellKnownSymbol$l; // `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable

defineWellKnownSymbol$h('isConcatSpreadable');

var defineWellKnownSymbol$g = defineWellKnownSymbol$l; // `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator

defineWellKnownSymbol$g('iterator');

var defineWellKnownSymbol$f = defineWellKnownSymbol$l; // `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match

defineWellKnownSymbol$f('match');

var defineWellKnownSymbol$e = defineWellKnownSymbol$l; // `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall

defineWellKnownSymbol$e('matchAll');

var defineWellKnownSymbol$d = defineWellKnownSymbol$l; // `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace

defineWellKnownSymbol$d('replace');

var defineWellKnownSymbol$c = defineWellKnownSymbol$l; // `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search

defineWellKnownSymbol$c('search');

var defineWellKnownSymbol$b = defineWellKnownSymbol$l; // `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species

defineWellKnownSymbol$b('species');

var defineWellKnownSymbol$a = defineWellKnownSymbol$l; // `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split

defineWellKnownSymbol$a('split');

var defineWellKnownSymbol$9 = defineWellKnownSymbol$l; // `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive

defineWellKnownSymbol$9('toPrimitive');

var defineWellKnownSymbol$8 = defineWellKnownSymbol$l; // `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag

defineWellKnownSymbol$8('toStringTag');

var defineWellKnownSymbol$7 = defineWellKnownSymbol$l; // `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables

defineWellKnownSymbol$7('unscopables');

var global$j = global$P;
var setToStringTag$1 = setToStringTag$5; // JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag

setToStringTag$1(global$j.JSON, 'JSON', true);

var path$l = path$y;
var symbol$5 = path$l.Symbol;

var parent$W = symbol$5;
var symbol$4 = parent$W;

var parent$V = symbol$4;
var symbol$3 = parent$V;

var defineWellKnownSymbol$6 = defineWellKnownSymbol$l; // `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-using-statement

defineWellKnownSymbol$6('asyncDispose');

var defineWellKnownSymbol$5 = defineWellKnownSymbol$l; // `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-using-statement

defineWellKnownSymbol$5('dispose');

var defineWellKnownSymbol$4 = defineWellKnownSymbol$l; // `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching

defineWellKnownSymbol$4('matcher');

var defineWellKnownSymbol$3 = defineWellKnownSymbol$l; // `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators

defineWellKnownSymbol$3('metadata');

var defineWellKnownSymbol$2 = defineWellKnownSymbol$l; // `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable

defineWellKnownSymbol$2('observable');

var defineWellKnownSymbol$1 = defineWellKnownSymbol$l; // `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching

defineWellKnownSymbol$1('patternMatch');

var defineWellKnownSymbol = defineWellKnownSymbol$l;
defineWellKnownSymbol('replaceAll');

var parent$U = symbol$3; // TODO: Remove from `core-js@4`
// TODO: Remove from `core-js@4`

var symbol$2 = parent$U;

var symbol$1 = symbol$2;

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof symbol$1 !== "undefined" && getIteratorMethod$1(arr) || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var $$y = _export;
var global$i = global$P;
var isArray$3 = isArray$d;
var isConstructor$1 = isConstructor$4;
var isObject$9 = isObject$j;
var toAbsoluteIndex$2 = toAbsoluteIndex$5;
var lengthOfArrayLike$7 = lengthOfArrayLike$d;
var toIndexedObject$1 = toIndexedObject$b;
var createProperty$1 = createProperty$6;
var wellKnownSymbol$3 = wellKnownSymbol$j;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var un$Slice = arraySlice$5;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3('slice');
var SPECIES$1 = wellKnownSymbol$3('species');
var Array$2 = global$i.Array;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

$$y({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$3
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject$1(this);
    var length = lengthOfArrayLike$7(O);
    var k = toAbsoluteIndex$2(start, length);
    var fin = toAbsoluteIndex$2(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray$3(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (isConstructor$1(Constructor) && (Constructor === Array$2 || isArray$3(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject$9(Constructor)) {
        Constructor = Constructor[SPECIES$1];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array$2 || Constructor === undefined) {
        return un$Slice(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array$2 : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$1(result, n, O[k]);

    result.length = n;
    return result;
  }
});

var entryVirtual$j = entryVirtual$l;
var slice$6 = entryVirtual$j('Array').slice;

var isPrototypeOf$j = objectIsPrototypeOf;
var method$g = slice$6;
var ArrayPrototype$h = Array.prototype;

var slice$5 = function (it) {
  var own = it.slice;
  return it === ArrayPrototype$h || isPrototypeOf$j(ArrayPrototype$h, it) && own === ArrayPrototype$h.slice ? method$g : own;
};

var parent$T = slice$5;
var slice$4 = parent$T;

var parent$S = slice$4;
var slice$3 = parent$S;

var parent$R = slice$3;
var slice$2 = parent$R;

var slice$1 = slice$2;

var parent$Q = from$4;
var from$2 = parent$Q;

var parent$P = from$2;
var from$1 = parent$P;

var from = from$1;

function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$9(o, minLen) {
  var _context;

  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);

  var n = slice$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);

  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest();
}

var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var iterator$5 = WrappedWellKnownSymbolModule.f('iterator');

var parent$O = iterator$5;
var iterator$4 = parent$O;

var parent$N = iterator$4;
var iterator$3 = parent$N;

var parent$M = iterator$3;
var iterator$2 = parent$M;

var iterator$1 = iterator$2;

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof symbol$1 && "symbol" == typeof iterator$1 ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _arrayWithoutHoles(arr) {
  if (isArray$5(arr)) return _arrayLikeToArray$9(arr);
}

function _iterableToArray(iter) {
  if (typeof symbol$1 !== "undefined" && getIteratorMethod$1(iter) != null || iter["@@iterator"] != null) return from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread();
}

var symbol = symbol$4;

var entryVirtual$i = entryVirtual$l;
var concat$3 = entryVirtual$i('Array').concat;

var isPrototypeOf$i = objectIsPrototypeOf;
var method$f = concat$3;
var ArrayPrototype$g = Array.prototype;

var concat$2 = function (it) {
  var own = it.concat;
  return it === ArrayPrototype$g || isPrototypeOf$i(ArrayPrototype$g, it) && own === ArrayPrototype$g.concat ? method$f : own;
};

var parent$L = concat$2;
var concat$1 = parent$L;

var concat = concat$1;

var slice = slice$4;

var $$x = _export;
var ownKeys$8 = ownKeys$a; // `Reflect.ownKeys` method
// https://tc39.es/ecma262/#sec-reflect.ownkeys

$$x({
  target: 'Reflect',
  stat: true
}, {
  ownKeys: ownKeys$8
});

var path$k = path$y;
var ownKeys$7 = path$k.Reflect.ownKeys;

var parent$K = ownKeys$7;
var ownKeys$6 = parent$K;

var ownKeys$5 = ownKeys$6;

var isArray$2 = isArray$8;

var $$w = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2('map'); // `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species

$$w({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$2
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$h = entryVirtual$l;
var map$6 = entryVirtual$h('Array').map;

var isPrototypeOf$h = objectIsPrototypeOf;
var method$e = map$6;
var ArrayPrototype$f = Array.prototype;

var map$5 = function (it) {
  var own = it.map;
  return it === ArrayPrototype$f || isPrototypeOf$h(ArrayPrototype$f, it) && own === ArrayPrototype$f.map ? method$e : own;
};

var parent$J = map$5;
var map$4 = parent$J;

var map$3 = map$4;

var $$v = _export;
var toObject$6 = toObject$e;
var nativeKeys = objectKeys$4;
var fails$d = fails$t;
var FAILS_ON_PRIMITIVES$3 = fails$d(function () {
  nativeKeys(1);
}); // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys

$$v({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$3
}, {
  keys: function keys(it) {
    return nativeKeys(toObject$6(it));
  }
});

var path$j = path$y;
var keys$6 = path$j.Object.keys;

var parent$I = keys$6;
var keys$5 = parent$I;

var keys$4 = keys$5;

var $$u = _export;
var global$h = global$P;
var uncurryThis$c = functionUncurryThis;
var Date$1 = global$h.Date;
var getTime = uncurryThis$c(Date$1.prototype.getTime); // `Date.now` method
// https://tc39.es/ecma262/#sec-date.now

$$u({
  target: 'Date',
  stat: true
}, {
  now: function now() {
    return getTime(new Date$1());
  }
});

var path$i = path$y;
var now$3 = path$i.Date.now;

var parent$H = now$3;
var now$2 = parent$H;

var now$1 = now$2;

var fails$c = fails$t;

var arrayMethodIsStrict$6 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$c(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () {
      return 1;
    }, 1);
  });
};

var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$6;
var STRICT_METHOD$5 = arrayMethodIsStrict$5('forEach'); // `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach

var arrayForEach = !STRICT_METHOD$5 ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;

var $$t = _export;
var forEach$6 = arrayForEach; // `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe

$$t({
  target: 'Array',
  proto: true,
  forced: [].forEach != forEach$6
}, {
  forEach: forEach$6
});

var entryVirtual$g = entryVirtual$l;
var forEach$5 = entryVirtual$g('Array').forEach;

var parent$G = forEach$5;
var forEach$4 = parent$G;

var classof$6 = classof$e;
var hasOwn$6 = hasOwnProperty_1;
var isPrototypeOf$g = objectIsPrototypeOf;
var method$d = forEach$4;
var ArrayPrototype$e = Array.prototype;
var DOMIterables$3 = {
  DOMTokenList: true,
  NodeList: true
};

var forEach$3 = function (it) {
  var own = it.forEach;
  return it === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.forEach || hasOwn$6(DOMIterables$3, classof$6(it)) ? method$d : own;
};

var forEach$2 = forEach$3;

var $$s = _export;
var uncurryThis$b = functionUncurryThis;
var isArray$1 = isArray$d;
var un$Reverse = uncurryThis$b([].reverse);
var test$1 = [1, 2]; // `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794

$$s({
  target: 'Array',
  proto: true,
  forced: String(test$1) === String(test$1.reverse())
}, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray$1(this)) this.length = this.length;
    return un$Reverse(this);
  }
});

var entryVirtual$f = entryVirtual$l;
var reverse$3 = entryVirtual$f('Array').reverse;

var isPrototypeOf$f = objectIsPrototypeOf;
var method$c = reverse$3;
var ArrayPrototype$d = Array.prototype;

var reverse$2 = function (it) {
  var own = it.reverse;
  return it === ArrayPrototype$d || isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.reverse ? method$c : own;
};

var parent$F = reverse$2;
var reverse$1 = parent$F;

var reverse = reverse$1;

var $$r = _export;
var global$g = global$P;
var toAbsoluteIndex$1 = toAbsoluteIndex$5;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var lengthOfArrayLike$6 = lengthOfArrayLike$d;
var toObject$5 = toObject$e;
var arraySpeciesCreate$1 = arraySpeciesCreate$4;
var createProperty = createProperty$6;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('splice');
var TypeError$8 = global$g.TypeError;
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species

$$r({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$1
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject$5(this);
    var len = lengthOfArrayLike$6(O);
    var actualStart = toAbsoluteIndex$1(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError$8(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate$1(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var entryVirtual$e = entryVirtual$l;
var splice$4 = entryVirtual$e('Array').splice;

var isPrototypeOf$e = objectIsPrototypeOf;
var method$b = splice$4;
var ArrayPrototype$c = Array.prototype;

var splice$3 = function (it) {
  var own = it.splice;
  return it === ArrayPrototype$c || isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.splice ? method$b : own;
};

var parent$E = splice$3;
var splice$2 = parent$E;

var splice$1 = splice$2;

var $$q = _export;
var $includes = arrayIncludes.includes;
// https://tc39.es/ecma262/#sec-array.prototype.includes

$$q({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var entryVirtual$d = entryVirtual$l;
var includes$4 = entryVirtual$d('Array').includes;

var isObject$8 = isObject$j;
var classof$5 = classofRaw$1;
var wellKnownSymbol$2 = wellKnownSymbol$j;
var MATCH$1 = wellKnownSymbol$2('match'); // `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp

var isRegexp = function (it) {
  var isRegExp;
  return isObject$8(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$5(it) == 'RegExp');
};

var global$f = global$P;
var isRegExp = isRegexp;
var TypeError$7 = global$f.TypeError;

var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw TypeError$7("The method doesn't accept regular expressions");
  }

  return it;
};

var wellKnownSymbol$1 = wellKnownSymbol$j;
var MATCH = wellKnownSymbol$1('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) {
      /* empty */
    }
  }

  return false;
};

var $$p = _export;
var uncurryThis$a = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible$1 = requireObjectCoercible$5;
var toString$4 = toString$8;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$a(''.indexOf); // `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes

$$p({
  target: 'String',
  proto: true,
  forced: !correctIsRegExpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~stringIndexOf(toString$4(requireObjectCoercible$1(this)), toString$4(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$c = entryVirtual$l;
var includes$3 = entryVirtual$c('String').includes;

var isPrototypeOf$d = objectIsPrototypeOf;
var arrayMethod = includes$4;
var stringMethod = includes$3;
var ArrayPrototype$b = Array.prototype;
var StringPrototype = String.prototype;

var includes$2 = function (it) {
  var own = it.includes;
  if (it === ArrayPrototype$b || isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.includes) return arrayMethod;

  if (typeof it == 'string' || it === StringPrototype || isPrototypeOf$d(StringPrototype, it) && own === StringPrototype.includes) {
    return stringMethod;
  }

  return own;
};

var parent$D = includes$2;
var includes$1 = parent$D;

var includes = includes$1;

var $$o = _export;
var fails$b = fails$t;
var toObject$4 = toObject$e;
var nativeGetPrototypeOf = objectGetPrototypeOf;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$2 = fails$b(function () {
  nativeGetPrototypeOf(1);
}); // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

$$o({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$2,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$4(it));
  }
});

var path$h = path$y;
var getPrototypeOf$6 = path$h.Object.getPrototypeOf;

var parent$C = getPrototypeOf$6;
var getPrototypeOf$5 = parent$C;

var getPrototypeOf$4 = getPrototypeOf$5;

var $$n = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species

$$n({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$b = entryVirtual$l;
var filter$3 = entryVirtual$b('Array').filter;

var isPrototypeOf$c = objectIsPrototypeOf;
var method$a = filter$3;
var ArrayPrototype$a = Array.prototype;

var filter$2 = function (it) {
  var own = it.filter;
  return it === ArrayPrototype$a || isPrototypeOf$c(ArrayPrototype$a, it) && own === ArrayPrototype$a.filter ? method$a : own;
};

var parent$B = filter$2;
var filter$1 = parent$B;

var filter = filter$1;

var DESCRIPTORS$4 = descriptors;
var uncurryThis$9 = functionUncurryThis;
var objectKeys = objectKeys$4;
var toIndexedObject = toIndexedObject$b;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable = uncurryThis$9($propertyIsEnumerable);
var push$2 = uncurryThis$9([].push); // `Object.{ entries, values }` methods implementation

var createMethod$2 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS$4 || propertyIsEnumerable(O, key)) {
        push$2(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod$2(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod$2(false)
};

var $$m = _export;
var $values = objectToArray.values; // `Object.values` method
// https://tc39.es/ecma262/#sec-object.values

$$m({
  target: 'Object',
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});

var path$g = path$y;
path$g.Object.values;

var whitespaces$4 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var uncurryThis$8 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$5;
var toString$3 = toString$8;
var whitespaces$3 = whitespaces$4;
var replace$1 = uncurryThis$8(''.replace);
var whitespace = '[' + whitespaces$3 + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$1 = function (TYPE) {
  return function ($this) {
    var string = toString$3(requireObjectCoercible($this));
    if (TYPE & 1) string = replace$1(string, ltrim, '');
    if (TYPE & 2) string = replace$1(string, rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3)
};

var global$e = global$P;
var fails$a = fails$t;
var uncurryThis$7 = functionUncurryThis;
var toString$2 = toString$8;
var trim$1 = stringTrim.trim;
var whitespaces$2 = whitespaces$4;
var $parseInt$1 = global$e.parseInt;
var Symbol$2 = global$e.Symbol;
var ITERATOR$1 = Symbol$2 && Symbol$2.iterator;
var hex = /^[+-]?0x/i;
var exec$1 = uncurryThis$7(hex.exec);
var FORCED$4 = $parseInt$1(whitespaces$2 + '08') !== 8 || $parseInt$1(whitespaces$2 + '0x16') !== 22 // MS Edge 18- broken with boxed symbols
|| ITERATOR$1 && !fails$a(function () {
  $parseInt$1(Object(ITERATOR$1));
}); // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

var numberParseInt = FORCED$4 ? function parseInt(string, radix) {
  var S = trim$1(toString$2(string));
  return $parseInt$1(S, radix >>> 0 || (exec$1(hex, S) ? 16 : 10));
} : $parseInt$1;

var $$l = _export;
var $parseInt = numberParseInt; // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

$$l({
  global: true,
  forced: parseInt != $parseInt
}, {
  parseInt: $parseInt
});

var path$f = path$y;
var _parseInt$2 = path$f.parseInt;

var parent$A = _parseInt$2;
var _parseInt$1 = parent$A;

var _parseInt = _parseInt$1;

/* eslint-disable es/no-array-prototype-indexof -- required for testing */


var $$k = _export;
var uncurryThis$6 = functionUncurryThis;
var $IndexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$6;
var un$IndexOf = uncurryThis$6([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
var STRICT_METHOD$4 = arrayMethodIsStrict$4('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof

$$k({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || !STRICT_METHOD$4
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
    return NEGATIVE_ZERO // convert -0 to +0
    ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
  }
});

var entryVirtual$a = entryVirtual$l;
var indexOf$3 = entryVirtual$a('Array').indexOf;

var isPrototypeOf$b = objectIsPrototypeOf;
var method$9 = indexOf$3;
var ArrayPrototype$9 = Array.prototype;

var indexOf$2 = function (it) {
  var own = it.indexOf;
  return it === ArrayPrototype$9 || isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.indexOf ? method$9 : own;
};

var parent$z = indexOf$2;
var indexOf$1 = parent$z;

var indexOf = indexOf$1;

var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$9 = fails$t;
var whitespaces$1 = whitespaces$4;
var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
// of whitespaces and has a correct name

var stringTrimForced = function (METHOD_NAME) {
  return fails$9(function () {
    return !!whitespaces$1[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces$1[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $$j = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced; // `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim

$$j({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
});

var entryVirtual$9 = entryVirtual$l;
entryVirtual$9('String').trim;

var $$i = _export;
var DESCRIPTORS$3 = descriptors;
var create$8 = objectCreate; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

$$i({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS$3
}, {
  create: create$8
});

var path$e = path$y;
var Object$2 = path$e.Object;

var create$7 = function create(P, D) {
  return Object$2.create(P, D);
};

var parent$y = create$7;
var create$6 = parent$y;

var create$5 = create$6;

var $$h = _export;
var global$d = global$P;
var getBuiltIn$2 = getBuiltIn$9;
var apply$3 = functionApply;
var uncurryThis$5 = functionUncurryThis;
var fails$8 = fails$t;
var Array$1 = global$d.Array;
var $stringify = getBuiltIn$2('JSON', 'stringify');
var exec = uncurryThis$5(/./.exec);
var charAt$1 = uncurryThis$5(''.charAt);
var charCodeAt = uncurryThis$5(''.charCodeAt);
var replace = uncurryThis$5(''.replace);
var numberToString = uncurryThis$5(1.0.toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var fix = function (match, offset, string) {
  var prev = charAt$1(string, offset - 1);
  var next = charAt$1(string, offset + 1);

  if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  }

  return match;
};

var FORCED$3 = fails$8(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
});

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  // https://github.com/tc39/proposal-well-formed-stringify
  $$h({
    target: 'JSON',
    stat: true,
    forced: FORCED$3
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++) args[i] = arguments[i];

      var result = apply$3($stringify, null, args);
      return typeof result == 'string' ? replace(result, tester, fix) : result;
    }
  });
}

var path$d = path$y;
var apply$2 = functionApply; // eslint-disable-next-line es/no-json -- safe

if (!path$d.JSON) path$d.JSON = {
  stringify: JSON.stringify
}; // eslint-disable-next-line no-unused-vars -- required for `.length`

var stringify$3 = function stringify(it, replacer, space) {
  return apply$2(path$d.JSON.stringify, null, arguments);
};

var parent$x = stringify$3;
var stringify$2 = parent$x;

var stringify$1 = stringify$2;

var global$c = global$P;
var TypeError$6 = global$c.TypeError;

var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw TypeError$6('Not enough arguments');
  return passed;
};

var $$g = _export;
var global$b = global$P;
var apply$1 = functionApply;
var isCallable$1 = isCallable$h;
var userAgent$2 = engineUserAgent;
var arraySlice$1 = arraySlice$5;
var validateArgumentsLength = validateArgumentsLength$1;
var MSIE = /MSIE .\./.test(userAgent$2); // <- dirty ie9- check

var Function$1 = global$b.Function;

var wrap = function (scheduler) {
  return function (handler, timeout
  /* , ...arguments */
  ) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
    var fn = isCallable$1(handler) ? handler : Function$1(handler);
    var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      apply$1(fn, this, args);
    } : fn, timeout);
  };
}; // ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


$$g({
  global: true,
  bind: true,
  forced: MSIE
}, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global$b.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global$b.setInterval)
});

var path$c = path$y;
var setTimeout$2 = path$c.setTimeout;

var setTimeout$1 = setTimeout$2;

var toObject$3 = toObject$e;
var toAbsoluteIndex = toAbsoluteIndex$5;
var lengthOfArrayLike$5 = lengthOfArrayLike$d; // `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill

var arrayFill = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject$3(this);
  var length = lengthOfArrayLike$5(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

var $$f = _export;
var fill$4 = arrayFill;
// https://tc39.es/ecma262/#sec-array.prototype.fill

$$f({
  target: 'Array',
  proto: true
}, {
  fill: fill$4
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var entryVirtual$8 = entryVirtual$l;
var fill$3 = entryVirtual$8('Array').fill;

var isPrototypeOf$a = objectIsPrototypeOf;
var method$8 = fill$3;
var ArrayPrototype$8 = Array.prototype;

var fill$2 = function (it) {
  var own = it.fill;
  return it === ArrayPrototype$8 || isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.fill ? method$8 : own;
};

var parent$w = fill$2;
var fill$1 = parent$w;

var fill = fill$1;

/*! Hammer.JS - v2.0.17-rc - 2019-12-16
 * http://naver.github.io/egjs
 *
 * Forked By Naver egjs
 * Copyright (c) hammerjs
 * Licensed under the MIT license */
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */


var assign;

if (typeof Object.assign !== 'function') {
  assign = function assign(target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];

      if (source !== undefined && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
} else {
  assign = Object.assign;
}

var assign$1 = assign;
var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = typeof document === "undefined" ? {
  style: {}
} : document.createElement('div');
var TYPE_FUNCTION = 'function';
var round = Math.round,
    abs$1 = Math.abs;
var now = Date.now;
/**
 * @private
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */

function prefixed(obj, property) {
  var prefix;
  var prop;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;

  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;

    if (prop in obj) {
      return prop;
    }

    i++;
  }

  return undefined;
}
/* eslint-disable no-new-func, no-nested-ternary */


var win;

if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {};
} else {
  win = window;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }

  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
    // If css.supports is not supported but there is native touch-action assume it supports
    // all values. This is the case for IE 10 and 11.
    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
  });
  return touchMap;
}

var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = ('ontouchstart' in win);
var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];
/**
 * @private
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */

function each(obj, iterator, context) {
  var i;

  if (!obj) {
    return;
  }

  if (obj.forEach) {
    obj.forEach(iterator, context);
  } else if (obj.length !== undefined) {
    i = 0;

    while (i < obj.length) {
      iterator.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
  }
}
/**
 * @private
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */


function boolOrFn(val, args) {
  if (typeof val === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || undefined : undefined, args);
  }

  return val;
}
/**
 * @private
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */


function inStr(str, find) {
  return str.indexOf(find) > -1;
}
/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */


function cleanTouchActions(actions) {
  // none
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }

  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
  // for different directions, e.g. horizontal pan but vertical swipe?)
  // we need none (as otherwise with pan-x pan-y combined none of these
  // recognizers will work, since the browser would handle all panning

  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  } // pan-x OR pan-y


  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  } // manipulation


  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }

  return TOUCH_ACTION_AUTO;
}
/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */


var TouchAction = /*#__PURE__*/function () {
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  /**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */


  var _proto = TouchAction.prototype;

  _proto.set = function set(value) {
    // find out the touch-action by the event handlers
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }

    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
    }

    this.actions = value.toLowerCase().trim();
  };
  /**
   * @private
   * just re-set the touchAction value
   */


  _proto.update = function update() {
    this.set(this.manager.options.touchAction);
  };
  /**
   * @private
   * compute the value for the touchAction property based on the recognizer's settings
   * @returns {String} value
   */


  _proto.compute = function compute() {
    var actions = [];
    each(this.manager.recognizers, function (recognizer) {
      if (boolOrFn(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return cleanTouchActions(actions.join(' '));
  };
  /**
   * @private
   * this method is called on each input cycle and provides the preventing of the browser behavior
   * @param {Object} input
   */


  _proto.preventDefaults = function preventDefaults(input) {
    var srcEvent = input.srcEvent;
    var direction = input.offsetDirection; // if the touch action did prevented once this session

    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }

    var actions = this.actions;
    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

    if (hasNone) {
      // do not prevent defaults if this is a tap gesture
      var isTapPointer = input.pointers.length === 1;
      var isTapMovement = input.distance < 2;
      var isTapTouchTime = input.deltaTime < 250;

      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }

    if (hasPanX && hasPanY) {
      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
      return;
    }

    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  };
  /**
   * @private
   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
   * @param {Object} srcEvent
   */


  _proto.preventSrc = function preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  };

  return TouchAction;
}();
/**
 * @private
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */


function hasParent(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}
/**
 * @private
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */


function getCenter(pointers) {
  var pointersLength = pointers.length; // no need to loop when only one touch

  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }

  var x = 0;
  var y = 0;
  var i = 0;

  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }

  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}
/**
 * @private
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */


function simpleCloneInputData(input) {
  // make a simple copy of the pointers because we will get a reference if we don't
  // we only need clientXY for the calculations
  var pointers = [];
  var i = 0;

  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }

  return {
    timeStamp: now(),
    pointers: pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
/**
 * @private
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */


function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x * x + y * y);
}
/**
 * @private
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */


function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}
/**
 * @private
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */


function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }

  if (abs$1(x) >= abs$1(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }

  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

function computeDeltaXY(session, input) {
  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
  // jscs throwing error on defalut destructured values and without defaults tests fail

  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};

  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }

  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
/**
 * @private
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */


function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}
/**
 * @private
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */


function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
/**
 * @private
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */


function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
/**
 * @private
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */


function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;

  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    // use latest velocity info if it doesn't overtake a minimum period
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }

  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
/**
* @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */


function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length; // store the first input to calculate the distance and direction

  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  } // to compute scale and rotation we need to store the multiple touches


  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }

  var firstInput = session.firstInput,
      firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input); // find the correct target

  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;

  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = srcEvent.target;
  }

  if (hasParent(srcEventTarget, target)) {
    target = srcEventTarget;
  }

  input.target = target;
}
/**
 * @private
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */


function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;

  if (isFirst) {
    manager.session = {};
  } // source event is the normalized value of the domEvents
  // like 'touchstart, mouseup, pointerdown'


  input.eventType = eventType; // compute scale, rotation etc

  computeInputData(manager, input); // emit secret event

  manager.emit('hammer.input', input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
/**
 * @private
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */


function splitStr(str) {
  return str.trim().split(/\s+/g);
}
/**
 * @private
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function addEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.addEventListener(type, handler, false);
  });
}
/**
 * @private
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function removeEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.removeEventListener(type, handler, false);
  });
}
/**
 * @private
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */


function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
/**
 * @private
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */


var Input = /*#__PURE__*/function () {
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }
  /**
   * @private
   * should handle the inputEvent data and trigger the callback
   * @virtual
   */


  var _proto = Input.prototype;

  _proto.handler = function handler() {};
  /**
   * @private
   * bind the events
   */


  _proto.init = function init() {
    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  /**
   * @private
   * unbind the events
   */


  _proto.destroy = function destroy() {
    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };

  return Input;
}();
/**
 * @private
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */


function inArray(src, find, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find);
  } else {
    var i = 0;

    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
        // do not use === here, test fails
        return i;
      }

      i++;
    }

    return -1;
  }
}

var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
}; // in IE10 the pointer types is defined as an enum

var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

};
var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

if (win.MSPointerEvent && !win.PointerEvent) {
  POINTER_ELEMENT_EVENTS = 'MSPointerDown';
  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}
/**
 * @private
 * Pointer events input
 * @constructor
 * @extends Input
 */


var PointerEventInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(PointerEventInput, _Input);

  function PointerEventInput() {
    var _this;

    var proto = PointerEventInput.prototype;
    proto.evEl = POINTER_ELEMENT_EVENTS;
    proto.evWin = POINTER_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = PointerEventInput.prototype;

  _proto.handler = function handler(ev) {
    var store = this.store;
    var removePointer = false;
    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      removePointer = true;
    } // it not found, so the pointer hasn't been down (so it's probably a hover)


    if (storeIndex < 0) {
      return;
    } // update the event in the store


    store[storeIndex] = ev;
    this.callback(this.manager, eventType, {
      pointers: store,
      changedPointers: [ev],
      pointerType: pointerType,
      srcEvent: ev
    });

    if (removePointer) {
      // remove from the store
      store.splice(storeIndex, 1);
    }
  };

  return PointerEventInput;
}(Input);
/**
 * @private
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */


function toArray(obj) {
  return Array.prototype.slice.call(obj, 0);
}
/**
 * @private
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */


function uniqueArray(src, key, sort) {
  var results = [];
  var values = [];
  var i = 0;

  while (i < src.length) {
    var val = key ? src[i][key] : src[i];

    if (inArray(values, val) < 0) {
      results.push(src[i]);
    }

    values[i] = val;
    i++;
  }

  if (sort) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function (a, b) {
        return a[key] > b[key];
      });
    }
  }

  return results;
}

var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */

var TouchInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(TouchInput, _Input);

  function TouchInput() {
    var _this;

    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

    return _this;
  }

  var _proto = TouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = TOUCH_INPUT_MAP[ev.type];
    var touches = getTouches.call(this, ev, type);

    if (!touches) {
      return;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return TouchInput;
}(Input);

function getTouches(ev, type) {
  var allTouches = toArray(ev.touches);
  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }

  var i;
  var targetTouches;
  var changedTouches = toArray(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target; // get target touches from touches

  targetTouches = allTouches.filter(function (touch) {
    return hasParent(touch.target, target);
  }); // collect touches

  if (type === INPUT_START) {
    i = 0;

    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  } // filter changed touches to only contain touches that exist in the collected target ids


  i = 0;

  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    } // cleanup removed touches


    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }

    i++;
  }

  if (!changedTargetTouches.length) {
    return;
  }

  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
}

var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
/**
 * @private
 * Mouse events input
 * @constructor
 * @extends Input
 */

var MouseInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(MouseInput, _Input);

  function MouseInput() {
    var _this;

    var proto = MouseInput.prototype;
    proto.evEl = MOUSE_ELEMENT_EVENTS;
    proto.evWin = MOUSE_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.pressed = false; // mousedown state

    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = MouseInput.prototype;

  _proto.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

    if (eventType & INPUT_START && ev.button === 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which !== 1) {
      eventType = INPUT_END;
    } // mouse must be down


    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: INPUT_TYPE_MOUSE,
      srcEvent: ev
    });
  };

  return MouseInput;
}(Input);
/**
 * @private
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */


var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers,
      touch = _eventData$changedPoi[0];

  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);

    var removeLastTouch = function removeLastTouch() {
      var i = lts.indexOf(lastTouch);

      if (i > -1) {
        lts.splice(i, 1);
      }
    };

    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}

function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}

function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;

  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);

    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }

  return false;
}

var TouchMouseInput = /*#__PURE__*/function () {
  var TouchMouseInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(TouchMouseInput, _Input);

    function TouchMouseInput(_manager, callback) {
      var _this;

      _this = _Input.call(this, _manager, callback) || this;

      _this.handler = function (manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


        if (isTouch) {
          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {
          return;
        }

        _this.callback(manager, inputEvent, inputData);
      };

      _this.touch = new TouchInput(_this.manager, _this.handler);
      _this.mouse = new MouseInput(_this.manager, _this.handler);
      _this.primaryTouch = null;
      _this.lastTouches = [];
      return _this;
    }
    /**
     * @private
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */


    var _proto = TouchMouseInput.prototype;
    /**
     * @private
     * remove the event listeners
     */

    _proto.destroy = function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    };

    return TouchMouseInput;
  }(Input);

  return TouchMouseInput;
}();
/**
 * @private
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */


function createInputInstance(manager) {
  var Type; // let inputClass = manager.options.inputClass;

  var inputClass = manager.options.inputClass;

  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }

  return new Type(manager, inputHandler);
}
/**
 * @private
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */


function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }

  return false;
}

var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
/**
 * @private
 * get a unique id
 * @returns {number} uniqueId
 */

var _uniqueId = 1;

function uniqueId() {
  return _uniqueId++;
}
/**
 * @private
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */


function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;

  if (manager) {
    return manager.get(otherRecognizer);
  }

  return otherRecognizer;
}
/**
 * @private
 * get a usable string, used as event postfix
 * @param {constant} state
 * @returns {String} state
 */


function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return 'cancel';
  } else if (state & STATE_ENDED) {
    return 'end';
  } else if (state & STATE_CHANGED) {
    return 'move';
  } else if (state & STATE_BEGAN) {
    return 'start';
  }

  return '';
}
/**
 * @private
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */

/**
 * @private
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */


var Recognizer = /*#__PURE__*/function () {
  function Recognizer(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = _extends({
      enable: true
    }, options);
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @return {Recognizer}
   */


  var _proto = Recognizer.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

    this.manager && this.manager.touchAction.update();
    return this;
  };
  /**
   * @private
   * recognize simultaneous with an other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.recognizeWith = function recognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
      return this;
    }

    var simultaneous = this.simultaneous;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }

    return this;
  };
  /**
   * @private
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    delete this.simultaneous[otherRecognizer.id];
    return this;
  };
  /**
   * @private
   * recognizer can only run when an other is failing
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.requireFailure = function requireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
      return this;
    }

    var requireFail = this.requireFail;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (inArray(requireFail, otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }

    return this;
  };
  /**
   * @private
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    var index = inArray(this.requireFail, otherRecognizer);

    if (index > -1) {
      this.requireFail.splice(index, 1);
    }

    return this;
  };
  /**
   * @private
   * has require failures boolean
   * @returns {boolean}
   */


  _proto.hasRequireFailures = function hasRequireFailures() {
    return this.requireFail.length > 0;
  };
  /**
   * @private
   * if the recognizer can recognize simultaneous with an other recognizer
   * @param {Recognizer} otherRecognizer
   * @returns {Boolean}
   */


  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
    return !!this.simultaneous[otherRecognizer.id];
  };
  /**
   * @private
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   * @param {Object} input
   */


  _proto.emit = function emit(input) {
    var self = this;
    var state = this.state;

    function emit(event) {
      self.manager.emit(event, input);
    } // 'panstart' and 'panmove'


    if (state < STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }

    emit(self.options.event); // simple 'eventName' events

    if (input.additionalEvent) {
      // additional event(panleft, panright, pinchin, pinchout...)
      emit(input.additionalEvent);
    } // panend and pancancel


    if (state >= STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }
  };
  /**
   * @private
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   * @param {Object} input
   */


  _proto.tryEmit = function tryEmit(input) {
    if (this.canEmit()) {
      return this.emit(input);
    } // it's failing anyway


    this.state = STATE_FAILED;
  };
  /**
   * @private
   * can we emit?
   * @returns {boolean}
   */


  _proto.canEmit = function canEmit() {
    var i = 0;

    while (i < this.requireFail.length) {
      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
        return false;
      }

      i++;
    }

    return true;
  };
  /**
   * @private
   * update the recognizer
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    // make a new copy of the inputData
    // so we can change the inputData without messing up the other recognizers
    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?

    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
      this.reset();
      this.state = STATE_FAILED;
      return;
    } // reset when we've reached the end


    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
      this.state = STATE_POSSIBLE;
    }

    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
    // so trigger an event

    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
      this.tryEmit(inputDataClone);
    }
  };
  /**
   * @private
   * return the state of the recognizer
   * the actual recognizing happens in this method
   * @virtual
   * @param {Object} inputData
   * @returns {constant} STATE
   */

  /* jshint ignore:start */


  _proto.process = function process(inputData) {};
  /* jshint ignore:end */

  /**
   * @private
   * return the preferred touch-action
   * @virtual
   * @returns {Array}
   */


  _proto.getTouchAction = function getTouchAction() {};
  /**
   * @private
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   * @virtual
   */


  _proto.reset = function reset() {};

  return Recognizer;
}();
/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */


var TapRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(TapRecognizer, _Recognizer);

  function TapRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
    }, options)) || this; // previous time and center,
    // used for tap counting

    _this.pTime = false;
    _this.pCenter = false;
    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }

  var _proto = TapRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTouchTime = input.deltaTime < options.time;
    this.reset();

    if (input.eventType & INPUT_START && this.count === 0) {
      return this.failTimeout();
    } // we only allow little movement
    // and we've reached an end event, so a tap is possible


    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== INPUT_END) {
        return this.failTimeout();
      }

      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;

      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }

      this._input = input; // if tap count matches we have recognized it,
      // else it has began recognizing...

      var tapCount = this.count % options.taps;

      if (tapCount === 0) {
        // no failing requirements, immediately trigger the tap event
        // or wait as long as the multitap interval to trigger
        if (!this.hasRequireFailures()) {
          return STATE_RECOGNIZED;
        } else {
          this._timer = setTimeout(function () {
            _this2.state = STATE_RECOGNIZED;

            _this2.tryEmit();
          }, options.interval);
          return STATE_BEGAN;
        }
      }
    }

    return STATE_FAILED;
  };

  _proto.failTimeout = function failTimeout() {
    var _this3 = this;

    this._timer = setTimeout(function () {
      _this3.state = STATE_FAILED;
    }, this.options.interval);
    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit() {
    if (this.state === STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  };

  return TapRecognizer;
}(Recognizer);
/**
 * @private
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */


var AttrRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(AttrRecognizer, _Recognizer);

  function AttrRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _Recognizer.call(this, _extends({
      pointers: 1
    }, options)) || this;
  }
  /**
   * @private
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {Boolean} recognized
   */


  var _proto = AttrRecognizer.prototype;

  _proto.attrTest = function attrTest(input) {
    var optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  };
  /**
   * @private
   * Process the input and return the state for the recognizer
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {*} State
   */


  _proto.process = function process(input) {
    var state = this.state;
    var eventType = input.eventType;
    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
      return state | STATE_CANCELLED;
    } else if (isRecognized || isValid) {
      if (eventType & INPUT_END) {
        return state | STATE_ENDED;
      } else if (!(state & STATE_BEGAN)) {
        return STATE_BEGAN;
      }

      return state | STATE_CHANGED;
    }

    return STATE_FAILED;
  };

  return AttrRecognizer;
}(Recognizer);
/**
 * @private
 * direction cons to string
 * @param {constant} direction
 * @returns {String}
 */


function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return 'down';
  } else if (direction === DIRECTION_UP) {
    return 'up';
  } else if (direction === DIRECTION_LEFT) {
    return 'left';
  } else if (direction === DIRECTION_RIGHT) {
    return 'right';
  }

  return '';
}
/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(PanRecognizer, _AttrRecognizer);

  function PanRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _AttrRecognizer.call(this, _extends({
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    }, options)) || this;
    _this.pX = null;
    _this.pY = null;
    return _this;
  }

  var _proto = PanRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    var direction = this.options.direction;
    var actions = [];

    if (direction & DIRECTION_HORIZONTAL) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }

    if (direction & DIRECTION_VERTICAL) {
      actions.push(TOUCH_ACTION_PAN_X);
    }

    return actions;
  };

  _proto.directionTest = function directionTest(input) {
    var options = this.options;
    var hasMoved = true;
    var distance = input.distance;
    var direction = input.direction;
    var x = input.deltaX;
    var y = input.deltaY; // lock to axis?

    if (!(direction & options.direction)) {
      if (options.direction & DIRECTION_HORIZONTAL) {
        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        hasMoved = x !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        hasMoved = y !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }

    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  };

  _proto.attrTest = function attrTest(input) {
    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
  };

  _proto.emit = function emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    var direction = directionStr(input.direction);

    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PanRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);

  function SwipeRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    }, options)) || this;
  }

  var _proto = SwipeRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return PanRecognizer.prototype.getTouchAction.call(this);
  };

  _proto.attrTest = function attrTest(input) {
    var direction = this.options.direction;
    var velocity;

    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
      velocity = input.overallVelocity;
    } else if (direction & DIRECTION_HORIZONTAL) {
      velocity = input.overallVelocityX;
    } else if (direction & DIRECTION_VERTICAL) {
      velocity = input.overallVelocityY;
    }

    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;
  };

  _proto.emit = function emit(input) {
    var direction = directionStr(input.offsetDirection);

    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }

    this.manager.emit(this.options.event, input);
  };

  return SwipeRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */


var PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(PinchRecognizer, _AttrRecognizer);

  function PinchRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'pinch',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = PinchRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
  };

  _proto.emit = function emit(input) {
    if (input.scale !== 1) {
      var inOut = input.scale < 1 ? 'in' : 'out';
      input.additionalEvent = this.options.event + inOut;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PinchRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */


var RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(RotateRecognizer, _AttrRecognizer);

  function RotateRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'rotate',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = RotateRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
  };

  return RotateRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */


var PressRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(PressRecognizer, _Recognizer);

  function PressRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
    }, options)) || this;
    _this._timer = null;
    _this._input = null;
    return _this;
  }

  var _proto = PressRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_AUTO];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTime = input.deltaTime > options.time;
    this._input = input; // we only allow little movement
    // and we've reached an end event, so a tap is possible

    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
      this.reset();
    } else if (input.eventType & INPUT_START) {
      this.reset();
      this._timer = setTimeout(function () {
        _this2.state = STATE_RECOGNIZED;

        _this2.tryEmit();
      }, options.time);
    } else if (input.eventType & INPUT_END) {
      return STATE_RECOGNIZED;
    }

    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit(input) {
    if (this.state !== STATE_RECOGNIZED) {
      return;
    }

    if (input && input.eventType & INPUT_END) {
      this.manager.emit(this.options.event + "up", input);
    } else {
      this._input.timeStamp = now();
      this.manager.emit(this.options.event, this._input);
    }
  };

  return PressRecognizer;
}(Recognizer);

var defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,

  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,

  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,

  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,

  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,

  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: "none",

    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: "none",

    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: "none",

    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: "none",

    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: "none",

    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
/**
 * @private
 * Default recognizer setup when calling `Hammer()`
 * When creating a new Manager these will be skipped.
 * This is separated with other defaults because of tree-shaking.
 * @type {Array}
 */

var preset = [[RotateRecognizer, {
  enable: false
}], [PinchRecognizer, {
  enable: false
}, ['rotate']], [SwipeRecognizer, {
  direction: DIRECTION_HORIZONTAL
}], [PanRecognizer, {
  direction: DIRECTION_HORIZONTAL
}, ['swipe']], [TapRecognizer], [TapRecognizer, {
  event: 'doubletap',
  taps: 2
}, ['tap']], [PressRecognizer]];
var STOP = 1;
var FORCED_STOP = 2;
/**
 * @private
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */

function toggleCssProps(manager, add) {
  var element = manager.element;

  if (!element.style) {
    return;
  }

  var prop;
  each(manager.options.cssProps, function (value, name) {
    prop = prefixed(element.style, name);

    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || "";
    }
  });

  if (!add) {
    manager.oldCssProps = {};
  }
}
/**
 * @private
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */


function triggerDomEvent(event, data) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data;
  data.target.dispatchEvent(gestureEvent);
}
/**
* @private
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Manager = /*#__PURE__*/function () {
  function Manager(element, options) {
    var _this = this;

    this.options = assign$1({}, defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = _this.add(new item[0](item[1]));

      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @returns {Manager}
   */


  var _proto = Manager.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // Options that need a little more setup

    if (options.touchAction) {
      this.touchAction.update();
    }

    if (options.inputTarget) {
      // Clean up existing event listeners and reinitialize
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }

    return this;
  };
  /**
   * @private
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   * @param {Boolean} [force]
   */


  _proto.stop = function stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  };
  /**
   * @private
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    var session = this.session;

    if (session.stopped) {
      return;
    } // run the touch-action polyfill


    this.touchAction.preventDefaults(inputData);
    var recognizer;
    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
    // if no recognizer is detecting a thing, it is set to `null`

    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
    // or when we're in a new session

    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
      session.curRecognizer = null;
      curRecognizer = null;
    }

    var i = 0;

    while (i < recognizers.length) {
      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
      // 1.   allow if the session is NOT forced stopped (see the .stop() method)
      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
      //      that is being recognized.
      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
      //      this can be setup with the `recognizeWith()` method on the recognizer.

      if (session.stopped !== FORCED_STOP && ( // 1
      !curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        // 3
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
      // current active recognizer. but only if we don't already have an active recognizer


      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
        session.curRecognizer = recognizer;
        curRecognizer = recognizer;
      }

      i++;
    }
  };
  /**
   * @private
   * get a recognizer by its event name.
   * @param {Recognizer|String} recognizer
   * @returns {Recognizer|Null}
   */


  _proto.get = function get(recognizer) {
    if (recognizer instanceof Recognizer) {
      return recognizer;
    }

    var recognizers = this.recognizers;

    for (var i = 0; i < recognizers.length; i++) {
      if (recognizers[i].options.event === recognizer) {
        return recognizers[i];
      }
    }

    return null;
  };
  /**
   * @private add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   * @param {Recognizer} recognizer
   * @returns {Recognizer|Manager}
   */


  _proto.add = function add(recognizer) {
    if (invokeArrayArg(recognizer, "add", this)) {
      return this;
    } // remove existing


    var existing = this.get(recognizer.options.event);

    if (existing) {
      this.remove(existing);
    }

    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  };
  /**
   * @private
   * remove a recognizer by name or instance
   * @param {Recognizer|String} recognizer
   * @returns {Manager}
   */


  _proto.remove = function remove(recognizer) {
    if (invokeArrayArg(recognizer, "remove", this)) {
      return this;
    }

    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

    if (recognizer) {
      var recognizers = this.recognizers;
      var index = inArray(recognizers, targetRecognizer);

      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }

    return this;
  };
  /**
   * @private
   * bind event
   * @param {String} events
   * @param {Function} handler
   * @returns {EventEmitter} this
   */


  _proto.on = function on(events, handler) {
    if (events === undefined || handler === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    });
    return this;
  };
  /**
   * @private unbind event, leave emit blank to remove all handlers
   * @param {String} events
   * @param {Function} [handler]
   * @returns {EventEmitter} this
   */


  _proto.off = function off(events, handler) {
    if (events === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      if (!handler) {
        delete handlers[event];
      } else {
        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
      }
    });
    return this;
  };
  /**
   * @private emit event to the listeners
   * @param {String} event
   * @param {Object} data
   */


  _proto.emit = function emit(event, data) {
    // we also want to trigger dom events
    if (this.options.domEvents) {
      triggerDomEvent(event, data);
    } // no handlers, so skip it all


    var handlers = this.handlers[event] && this.handlers[event].slice();

    if (!handlers || !handlers.length) {
      return;
    }

    data.type = event;

    data.preventDefault = function () {
      data.srcEvent.preventDefault();
    };

    var i = 0;

    while (i < handlers.length) {
      handlers[i](data);
      i++;
    }
  };
  /**
   * @private
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */


  _proto.destroy = function destroy() {
    this.element && toggleCssProps(this, false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  };

  return Manager;
}();

var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Touch events input
 * @constructor
 * @extends Input
 */

var SingleTouchInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(SingleTouchInput, _Input);

  function SingleTouchInput() {
    var _this;

    var proto = SingleTouchInput.prototype;
    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.started = false;
    return _this;
  }

  var _proto = SingleTouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

    if (type === INPUT_START) {
      this.started = true;
    }

    if (!this.started) {
      return;
    }

    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
      this.started = false;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return SingleTouchInput;
}(Input);

function normalizeSingleTouches(ev, type) {
  var all = toArray(ev.touches);
  var changed = toArray(ev.changedTouches);

  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), 'identifier', true);
  }

  return [all, changed];
}
/**
 * @private
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */


function deprecate(method, name, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
  return function () {
    var e = new Error('get-stack-trace');
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
    var log = window.console && (window.console.warn || window.console.log);

    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }

    return method.apply(this, arguments);
  };
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */


var extend = deprecate(function (dest, src, merge) {
  var keys = Object.keys(src);
  var i = 0;

  while (i < keys.length) {
    if (!merge || merge && dest[keys[i]] === undefined) {
      dest[keys[i]] = src[keys[i]];
    }

    i++;
  }

  return dest;
}, 'extend', 'Use `assign`.');
/**
 * @private
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */

var merge$2 = deprecate(function (dest, src) {
  return extend(dest, src, true);
}, 'merge', 'Use `assign`.');
/**
 * @private
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */

function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;

  if (properties) {
    assign$1(childP, properties);
  }
}
/**
 * @private
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */


function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
/**
 * @private
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Hammer$2 = /*#__PURE__*/function () {
  var Hammer =
  /**
    * @private
    * @const {string}
    */
  function Hammer(element, options) {
    if (options === void 0) {
      options = {};
    }

    return new Manager(element, _extends({
      recognizers: preset.concat()
    }, options));
  };

  Hammer.VERSION = "2.0.17-rc";
  Hammer.DIRECTION_ALL = DIRECTION_ALL;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Hammer.DIRECTION_UP = DIRECTION_UP;
  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Hammer.DIRECTION_NONE = DIRECTION_NONE;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.INPUT_START = INPUT_START;
  Hammer.INPUT_MOVE = INPUT_MOVE;
  Hammer.INPUT_END = INPUT_END;
  Hammer.INPUT_CANCEL = INPUT_CANCEL;
  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
  Hammer.STATE_BEGAN = STATE_BEGAN;
  Hammer.STATE_CHANGED = STATE_CHANGED;
  Hammer.STATE_ENDED = STATE_ENDED;
  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
  Hammer.STATE_CANCELLED = STATE_CANCELLED;
  Hammer.STATE_FAILED = STATE_FAILED;
  Hammer.Manager = Manager;
  Hammer.Input = Input;
  Hammer.TouchAction = TouchAction;
  Hammer.TouchInput = TouchInput;
  Hammer.MouseInput = MouseInput;
  Hammer.PointerEventInput = PointerEventInput;
  Hammer.TouchMouseInput = TouchMouseInput;
  Hammer.SingleTouchInput = SingleTouchInput;
  Hammer.Recognizer = Recognizer;
  Hammer.AttrRecognizer = AttrRecognizer;
  Hammer.Tap = TapRecognizer;
  Hammer.Pan = PanRecognizer;
  Hammer.Swipe = SwipeRecognizer;
  Hammer.Pinch = PinchRecognizer;
  Hammer.Rotate = RotateRecognizer;
  Hammer.Press = PressRecognizer;
  Hammer.on = addEventListeners;
  Hammer.off = removeEventListeners;
  Hammer.each = each;
  Hammer.merge = merge$2;
  Hammer.extend = extend;
  Hammer.bindFn = bindFn;
  Hammer.assign = assign$1;
  Hammer.inherit = inherit;
  Hammer.bindFn = bindFn;
  Hammer.prefixed = prefixed;
  Hammer.toArray = toArray;
  Hammer.inArray = inArray;
  Hammer.uniqueArray = uniqueArray;
  Hammer.splitStr = splitStr;
  Hammer.boolOrFn = boolOrFn;
  Hammer.hasParent = hasParent;
  Hammer.addEventListeners = addEventListeners;
  Hammer.removeEventListeners = removeEventListeners;
  Hammer.defaults = assign$1({}, defaults, {
    preset: preset
  });
  return Hammer;
}(); //  style loader but by script tag, not by the loader.
var RealHammer = Hammer$2;

function _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$8(o, minLen) { var _context21; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = slice(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Use this symbol to delete properies in deepObjectAssign.
 */

var DELETE = symbol("DELETE");
/**
 * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.
 *
 * @param base - The base object that fullfils the whole interface T.
 * @param updates - Updates that may change or delete props.
 * @returns A brand new instance with all the supplied objects deeply merged.
 */


function pureDeepObjectAssign(base) {
  var _context;

  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    updates[_key - 1] = arguments[_key];
  }

  return deepObjectAssign.apply(void 0, concat(_context = [{}, base]).call(_context, updates));
}
/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @param values - Objects to be deeply merged.
 * @returns The first object from values.
 */


function deepObjectAssign() {
  var merged = deepObjectAssignNonentry.apply(void 0, arguments);
  stripDelete(merged);
  return merged;
}
/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @remarks
 * This doesn't strip the DELETE symbols so they may end up in the final object.
 * @param values - Objects to be deeply merged.
 * @returns The first object from values.
 */


function deepObjectAssignNonentry() {
  for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values[_key2] = arguments[_key2];
  }

  if (values.length < 2) {
    return values[0];
  } else if (values.length > 2) {
    var _context2;

    return deepObjectAssignNonentry.apply(void 0, concat(_context2 = [deepObjectAssign(values[0], values[1])]).call(_context2, _toConsumableArray(slice(values).call(values, 2))));
  }

  var a = values[0];
  var b = values[1];

  var _iterator = _createForOfIteratorHelper$8(ownKeys$5(b)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prop = _step.value;
      if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;else if (b[prop] === DELETE) {
        delete a[prop];
      } else if (a[prop] !== null && b[prop] !== null && _typeof(a[prop]) === "object" && _typeof(b[prop]) === "object" && !isArray$2(a[prop]) && !isArray$2(b[prop])) {
        a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
      } else {
        a[prop] = clone(b[prop]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return a;
}
/**
 * Deep clone given object or array. In case of primitive simply return.
 *
 * @param a - Anything.
 * @returns Deep cloned object/array or unchanged a.
 */


function clone(a) {
  if (isArray$2(a)) {
    return map$3(a).call(a, function (value) {
      return clone(value);
    });
  } else if (_typeof(a) === "object" && a !== null) {
    return deepObjectAssignNonentry({}, a);
  } else {
    return a;
  }
}
/**
 * Strip DELETE from given object.
 *
 * @param a - Object which may contain DELETE but won't after this is executed.
 */


function stripDelete(a) {
  for (var _i = 0, _Object$keys = keys$4(a); _i < _Object$keys.length; _i++) {
    var prop = _Object$keys[_i];

    if (a[prop] === DELETE) {
      delete a[prop];
    } else if (_typeof(a[prop]) === "object" && a[prop] !== null) {
      stripDelete(a[prop]);
    }
  }
}
/**
 * Seedable, fast and reasonably good (not crypto but more than okay for our
 * needs) random number generator.
 *
 * @remarks
 * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.
 * Original algorithm created by Johannes Baagøe \<baagoe\@baagoe.com\> in 2010.
 */

/**
 * Create a seeded pseudo random generator based on Alea by Johannes Baagøe.
 *
 * @param seed - All supplied arguments will be used as a seed. In case nothing
 * is supplied the current time will be used to seed the generator.
 * @returns A ready to use seeded generator.
 */


function Alea() {
  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    seed[_key3] = arguments[_key3];
  }

  return AleaImplementation(seed.length ? seed : [now$1()]);
}
/**
 * An implementation of [[Alea]] without user input validation.
 *
 * @param seed - The data that will be used to seed the generator.
 * @returns A ready to use seeded generator.
 */


function AleaImplementation(seed) {
  var _mashSeed = mashSeed(seed),
      _mashSeed2 = _slicedToArray(_mashSeed, 3),
      s0 = _mashSeed2[0],
      s1 = _mashSeed2[1],
      s2 = _mashSeed2[2];

  var c = 1;

  var random = function random() {
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    s0 = s1;
    s1 = s2;
    return s2 = t - (c = t | 0);
  };

  random.uint32 = function () {
    return random() * 0x100000000;
  }; // 2^32


  random.fract53 = function () {
    return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16;
  }; // 2^-53


  random.algorithm = "Alea";
  random.seed = seed;
  random.version = "0.9";
  return random;
}
/**
 * Turn arbitrary data into values [[AleaImplementation]] can use to generate
 * random numbers.
 *
 * @param seed - Arbitrary data that will be used as the seed.
 * @returns Three numbers to use as initial values for [[AleaImplementation]].
 */


function mashSeed() {
  var mash = Mash();
  var s0 = mash(" ");
  var s1 = mash(" ");
  var s2 = mash(" ");

  for (var i = 0; i < arguments.length; i++) {
    s0 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s0 < 0) {
      s0 += 1;
    }

    s1 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s1 < 0) {
      s1 += 1;
    }

    s2 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s2 < 0) {
      s2 += 1;
    }
  }

  return [s0, s1, s2];
}
/**
 * Create a new mash function.
 *
 * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns
 * them into numbers.
 */


function Mash() {
  var n = 0xefc8249d;
  return function (data) {
    var string = data.toString();

    for (var i = 0; i < string.length; i++) {
      n += string.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };
}
/**
 * Setup a mock hammer.js object, for unit testing.
 *
 * Inspiration: https://github.com/uber/deck.gl/pull/658
 *
 * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
 */


function hammerMock() {
  var noop = function noop() {};

  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,
    get: function get() {
      return {
        set: noop
      };
    }
  };
}

var Hammer$1 = typeof window !== "undefined" ? window.Hammer || RealHammer : function () {
  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
  return hammerMock();
};
/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 *
 * @param {Element} container
 * @class Activator
 */

function Activator$1(container) {
  var _this = this,
      _context3;

  this._cleanupQueue = [];
  this.active = false;
  this._dom = {
    container: container,
    overlay: document.createElement("div")
  };

  this._dom.overlay.classList.add("vis-overlay");

  this._dom.container.appendChild(this._dom.overlay);

  this._cleanupQueue.push(function () {
    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);
  });

  var hammer = Hammer$1(this._dom.overlay);
  hammer.on("tap", bind$6(_context3 = this._onTapOverlay).call(_context3, this));

  this._cleanupQueue.push(function () {
    hammer.destroy(); // FIXME: cleaning up hammer instances doesn't work (Timeline not removed
    // from memory)
  }); // block all touch events (except tap)


  var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];

  forEach$2(events).call(events, function (event) {
    hammer.on(event, function (event) {
      event.srcEvent.stopPropagation();
    });
  }); // attach a click event to the window, in order to deactivate when clicking outside the timeline


  if (document && document.body) {
    this._onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        _this.deactivate();
      }
    };

    document.body.addEventListener("click", this._onClick);

    this._cleanupQueue.push(function () {
      document.body.removeEventListener("click", _this._onClick);
    });
  } // prepare escape key listener for deactivating when active


  this._escListener = function (event) {
    if ("key" in event ? event.key === "Escape" : event.keyCode === 27
    /* the keyCode is for IE11 */
    ) {
      _this.deactivate();
    }
  };
} // turn into an event emitter


Emitter(Activator$1.prototype); // The currently active activator

Activator$1.current = null;
/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */

Activator$1.prototype.destroy = function () {
  var _context4, _context5;

  this.deactivate();

  var _iterator2 = _createForOfIteratorHelper$8(reverse(_context4 = splice$1(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var callback = _step2.value;
      callback();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};
/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */


Activator$1.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator$1.current) {
    Activator$1.current.deactivate();
  }

  Activator$1.current = this;
  this.active = true;
  this._dom.overlay.style.display = "none";

  this._dom.container.classList.add("vis-active");

  this.emit("change");
  this.emit("activate"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event

  document.body.addEventListener("keydown", this._escListener);
};
/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */


Activator$1.prototype.deactivate = function () {
  this.active = false;
  this._dom.overlay.style.display = "block";

  this._dom.container.classList.remove("vis-active");

  document.body.removeEventListener("keydown", this._escListener);
  this.emit("change");
  this.emit("deactivate");
};
/**
 * Handle a tap event: activate the container
 *
 * @param {Event}  event   The event
 * @private
 */


Activator$1.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.srcEvent.stopPropagation();
};
/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 *
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */


function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }

    element = element.parentNode;
  }

  return false;
} // utility functions

var fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var rgbRE = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;
var rgbaRE = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;
/**
 * Remove everything in the DOM object.
 *
 * @param DOMobject - Node whose child nodes will be recursively deleted.
 */


function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      var child = DOMobject.firstChild;

      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
/**
 * Test whether given object is a string.
 *
 * @param value - Input value of unknown type.
 * @returns True if string, false otherwise.
 */


function isString(value) {
  return value instanceof String || typeof value === "string";
}
/**
 * Test whether given object is a object (not primitive or null).
 *
 * @param value - Input value of unknown type.
 * @returns True if not null object, false otherwise.
 */


function isObject$7(value) {
  return _typeof(value) === "object" && value !== null;
}
/**
 * Copy property from b to a if property present in a.
 * If property in b explicitly set to null, delete it if `allowDeletion` set.
 *
 * Internal helper routine, should not be exported. Not added to `exports` for that reason.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param prop - Name of property to copy from b to a.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 */


function copyOrDelete(a, b, prop, allowDeletion) {
  var doDeletion = false;

  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== undefined;
  }

  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop]; // Remember, this is a reference copy!
  }
}
/**
 * Fill an object with a possibly partially defined other object.
 *
 * Only copies values for the properties already present in a.
 * That means an object is not created on a property if only the b object has it.
 *
 * @param a - The object that will have it's properties updated.
 * @param b - The object with property updates.
 * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.
 */


function fillIfDefined(a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // NOTE: iteration of properties of a
  // NOTE: prototype properties iterated over as well
  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (b[prop] === null || _typeof(b[prop]) !== "object") {
        // Note: typeof null === 'object'
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        var aProp = a[prop];
        var bProp = b[prop];

        if (isObject$7(aProp) && isObject$7(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
/**
 * Extend object a with selected properties of object b.
 * Only properties with defined values are copied.
 *
 * @remarks
 * Previous version of this routine implied that multiple source objects could
 * be used; however, the implementation was **wrong**. Since multiple (\>1)
 * sources weren't used anywhere in the `vis.js` code, this has been removed
 * @param props - Names of first-level properties to copy over.
 * @param a - Target object.
 * @param b - Source object.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 * @returns Argument a.
 */


function selectiveDeepExtend(props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  if (isArray$2(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }

  for (var p = 0; p < props.length; p++) {
    var prop = props[p];

    if (Object.prototype.hasOwnProperty.call(b, prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }

        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$2(b[prop])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Extend object `a` with properties of object `b`, ignoring properties which
 * are explicitly specified to be excluded.
 *
 * @remarks
 * The properties of `b` are considered for copying. Properties which are
 * themselves objects are are also extended. Only properties with defined
 * values are copied.
 * @param propsToExclude - Names of properties which should *not* be copied.
 * @param a - Object to extend.
 * @param b - Object to take properties from for extension.
 * @param allowDeletion - If true, delete properties in a that are explicitly
 * set to null in b.
 * @returns Argument a.
 */


function selectiveNotDeepExtend(propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  // NOTE: array properties have an else-below; apparently, there is a problem here.
  if (isArray$2(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }

  for (var prop in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop)) {
      continue;
    } // Handle local properties only


    if (includes(propsToExclude).call(propsToExclude, prop)) {
      continue;
    } // In exclusion list, skip


    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === undefined) {
        a[prop] = {};
      }

      if (a[prop].constructor === Object) {
        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (isArray$2(b[prop])) {
      a[prop] = [];

      for (var i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }

  return a;
}
/**
 * Deep extend an object a with the properties of object b.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param protoExtend - If true, the prototype values will also be extended.
 * (That is the options objects that inherit from others will also get the
 * inherited options).
 * @param allowDeletion - If true, the values of fields that are null will be deleted.
 * @returns Argument a.
 */


function deepExtend(a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var prop in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {
      if (_typeof(b[prop]) === "object" && b[prop] !== null && getPrototypeOf$4(b[prop]) === Object.prototype) {
        if (a[prop] === undefined) {
          a[prop] = deepExtend({}, b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else if (_typeof(a[prop]) === "object" && a[prop] !== null && getPrototypeOf$4(a[prop]) === Object.prototype) {
          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$2(b[prop])) {
        var _context6;

        a[prop] = slice(_context6 = b[prop]).call(_context6);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - First part.
 * @param newValue - The value to be aadded into the array.
 * @returns A new array with all items from arr and newValue (which is last).
 */


function copyAndExtendArray(arr, newValue) {
  var _context7;

  return concat(_context7 = []).call(_context7, _toConsumableArray(arr), [newValue]);
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - The array to be copied.
 * @returns Shallow copy of arr.
 */


function copyArray(arr) {
  return slice(arr).call(arr);
}
/**
 * Retrieve the absolute left value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 * @returns The absolute left position of this element in the browser page.
 */


function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
/**
 * Retrieve the absolute top value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 * @returns The absolute top position of this element in the browser page.
 */


function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).
 * In case of an Object, the method loops over all properties of the object.
 *
 * @param object - An Object or Array to be iterated over.
 * @param callback - Array.forEach-like callback.
 */


function forEach$1(object, callback) {
  if (isArray$2(object)) {
    // array
    var len = object.length;

    for (var i = 0; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }
}
/**
 * Add and event listener. Works for all browsers.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.addEventListener(action, —, —).
 * @param listener - Same as Element.addEventListener(—, listener, —).
 * @param useCapture - Same as Element.addEventListener(—, —, useCapture).
 */


function addEventListener(element, action, listener, useCapture) {
  if (element.addEventListener) {
    var _context8;

    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === "mousewheel" && includes(_context8 = navigator.userAgent).call(_context8, "Firefox")) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    // @TODO: IE types? Does anyone care?
    element.attachEvent("on" + action, listener); // IE browsers
  }
}
/**
 * Remove an event listener from an element.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.removeEventListener(action, —, —).
 * @param listener - Same as Element.removeEventListener(—, listener, —).
 * @param useCapture - Same as Element.removeEventListener(—, —, useCapture).
 */


function removeEventListener(element, action, listener, useCapture) {
  if (element.removeEventListener) {
    var _context9;

    // non-IE browsers
    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === "mousewheel" && includes(_context9 = navigator.userAgent).call(_context9, "Firefox")) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // @TODO: IE types? Does anyone care?
    element.detachEvent("on" + action, listener); // IE browsers
  }
}
/**
 * Convert hex color string into RGB color object.
 *
 * @remarks
 * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}
 * @param hex - Hex color string (3 or 6 digits, with or without #).
 * @returns RGB color object.
 */

function hexToRGB(hex) {
  var result;

  switch (hex.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1] + result[1], 16),
        g: _parseInt(result[2] + result[2], 16),
        b: _parseInt(result[3] + result[3], 16)
      } : null;

    case 6:
    case 7:
      result = fullHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1], 16),
        g: _parseInt(result[2], 16),
        b: _parseInt(result[3], 16)
      } : null;

    default:
      return null;
  }
}
/**
 * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.
 *
 * @param color - The color string (hex, RGB, RGBA).
 * @param opacity - The new opacity.
 * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.
 */


function overrideOpacity(color, opacity) {
  if (includes(color).call(color, "rgba")) {
    return color;
  } else if (includes(color).call(color, "rgb")) {
    var rgb = color.substr(indexOf(color).call(color, "(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var _rgb = hexToRGB(color);

    if (_rgb == null) {
      return color;
    } else {
      return "rgba(" + _rgb.r + "," + _rgb.g + "," + _rgb.b + "," + opacity + ")";
    }
  }
}
/**
 * Convert RGB \<0, 255\> into hex color string.
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 * @returns Hex color string (for example: '#0acdc0').
 */


function RGBToHex(red, green, blue) {
  var _context10;

  return "#" + slice(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);
}
/**
 * Parse a color property into an object with border, background, and highlight colors.
 *
 * @param inputColor - Shorthand color string or input color object.
 * @param defaultColor - Full color object to fill in missing values in inputColor.
 * @returns Color object.
 */


function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    var colorStr = inputColor;

    if (isValidRGB(colorStr)) {
      var _context11;

      var rgb = map$3(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(",")).call(_context11, function (value) {
        return _parseInt(value);
      });

      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);
    }

    if (isValidHex(colorStr) === true) {
      var hsv = hexToHSV(colorStr);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      var color = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color;
    } else {
      var _color = {
        background: inputColor.background || undefined,
        border: inputColor.border || undefined,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || undefined,
          border: inputColor.highlight && inputColor.highlight.border || undefined
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || undefined,
          background: inputColor.hover && inputColor.hover.background || undefined
        }
      };
      return _color;
    }
  }
}
/**
 * Convert RGB \<0, 255\> into HSV object.
 *
 * @remarks
 * {@link http://www.javascripter.net/faq/rgb2hsv.htm}
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 * @returns HSV color object.
 */


function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue)); // Black-gray-white

  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  } // Colors other than black-gray-white:


  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}
/**
 * Convert HSV \<0, 1\> into RGB color object.
 *
 * @remarks
 * {@link https://gist.github.com/mjijackson/5311256}
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 * @returns RGB color object.
 */


function HSVToRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;

    case 1:
      r = q, g = v, b = p;
      break;

    case 2:
      r = p, g = v, b = t;
      break;

    case 3:
      r = p, g = q, b = v;
      break;

    case 4:
      r = t, g = p, b = v;
      break;

    case 5:
      r = v, g = p, b = q;
      break;
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
/**
 * Convert HSV \<0, 1\> into hex color string.
 *
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 * @returns Hex color string.
 */


function HSVToHex(h, s, v) {
  var rgb = HSVToRGB(h, s, v);
  return RGBToHex(rgb.r, rgb.g, rgb.b);
}
/**
 * Convert hex color string into HSV \<0, 1\>.
 *
 * @param hex - Hex color string.
 * @returns HSV color object.
 */


function hexToHSV(hex) {
  var rgb = hexToRGB(hex);

  if (!rgb) {
    throw new TypeError("'".concat(hex, "' is not a valid color."));
  }

  return RGBToHSV(rgb.r, rgb.g, rgb.b);
}
/**
 * Validate hex color string.
 *
 * @param hex - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidHex(hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
}
/**
 * Validate RGB color string.
 *
 * @param rgb - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGB(rgb) {
  return rgbRE.test(rgb);
}
/**
 * Validate RGBA color string.
 *
 * @param rgba - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGBA(rgba) {
  return rgbaRE.test(rgba);
}
/**
 * This recursively redirects the prototype of JSON objects to the referenceObject.
 * This is used for default options.
 *
 * @param referenceObject - The original object.
 * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.
 */


function bridgeObject(referenceObject) {
  if (referenceObject === null || _typeof(referenceObject) !== "object") {
    return null;
  }

  if (referenceObject instanceof Element) {
    // Avoid bridging DOM objects
    return referenceObject;
  }

  var objectTo = create$5(referenceObject);

  for (var i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (_typeof(referenceObject[i]) == "object") {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }

  return objectTo;
}
/**
 * This is used to set the options of subobjects in the options object.
 *
 * A requirement of these subobjects is that they have an 'enabled' element
 * which is optional for the user but mandatory for the program.
 *
 * The added value here of the merge is that option 'enabled' is set as required.
 *
 * @param mergeTarget - Either this.options or the options used for the groups.
 * @param options - Options.
 * @param option - Option key in the options argument.
 * @param globalOptions - Global options, passed in to determine value of option 'enabled'.
 */


function mergeOptions(mergeTarget, options, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  // Local helpers
  var isPresent = function isPresent(obj) {
    return obj !== null && obj !== undefined;
  };

  var isObject = function isObject(obj) {
    return obj !== null && _typeof(obj) === "object";
  }; // https://stackoverflow.com/a/34491287/1223531


  var isEmpty = function isEmpty(obj) {
    for (var x in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x)) {
        return false;
      }
    }

    return true;
  }; // Guards


  if (!isObject(mergeTarget)) {
    throw new Error("Parameter mergeTarget must be an object");
  }

  if (!isObject(options)) {
    throw new Error("Parameter options must be an object");
  }

  if (!isPresent(option)) {
    throw new Error("Parameter option must have a value");
  }

  if (!isObject(globalOptions)) {
    throw new Error("Parameter globalOptions must be an object");
  } //
  // Actual merge routine, separated from main logic
  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.
  //


  var doMerge = function doMerge(target, options, option) {
    if (!isObject(target[option])) {
      target[option] = {};
    }

    var src = options[option];
    var dst = target[option];

    for (var prop in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop)) {
        dst[prop] = src[prop];
      }
    }
  }; // Local initialization


  var srcOption = options[option];
  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : undefined;
  var globalEnabled = globalOption ? globalOption.enabled : undefined; /////////////////////////////////////////
  // Main routine
  /////////////////////////////////////////

  if (srcOption === undefined) {
    return; // Nothing to do
  }

  if (typeof srcOption === "boolean") {
    if (!isObject(mergeTarget[option])) {
      mergeTarget[option] = {};
    }

    mergeTarget[option].enabled = srcOption;
    return;
  }

  if (srcOption === null && !isObject(mergeTarget[option])) {
    // If possible, explicit copy from globals
    if (isPresent(globalOption)) {
      mergeTarget[option] = create$5(globalOption);
    } else {
      return; // Nothing to do
    }
  }

  if (!isObject(srcOption)) {
    return;
  } //
  // Ensure that 'enabled' is properly set. It is required internally
  // Note that the value from options will always overwrite the existing value
  //


  var enabled = true; // default value

  if (srcOption.enabled !== undefined) {
    enabled = srcOption.enabled;
  } else {
    // Take from globals, if present
    if (globalEnabled !== undefined) {
      enabled = globalOption.enabled;
    }
  }

  doMerge(mergeTarget, options, option);
  mergeTarget[option].enabled = enabled;
}
/*
 * Easing Functions.
 * Only considering the t value for the range [0, 1] => [0, 1].
 *
 * Inspiration: from http://gizma.com/easing/
 * https://gist.github.com/gre/1650294
 */


var easingFunctions = {
  /**
   * Provides no easing and no acceleration.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  linear: function linear(t) {
    return t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
// It works only for single property objects,
// otherwise it combines all of the types in a union.
// export function topMost<K1 extends string, V1> (
//   pile: Record<K1, undefined | V1>[],
//   accessors: K1 | [K1]
// ): undefined | V1
// export function topMost<K1 extends string, K2 extends string, V1, V2> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],
//   accessors: [K1, K2]
// ): undefined | V1 | V2
// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],
//   accessors: [K1, K2, K3]
// ): undefined | V1 | V2 | V3

/**
 * Get the top most property value from a pile of objects.
 *
 * @param pile - Array of objects, no required format.
 * @param accessors - Array of property names.
 * For example `object['foo']['bar']` → `['foo', 'bar']`.
 * @returns Value of the property with given accessors path from the first pile item where it's not undefined.
 */


function topMost(pile, accessors) {
  var candidate;

  if (!isArray$2(accessors)) {
    accessors = [accessors];
  }

  var _iterator3 = _createForOfIteratorHelper$8(pile),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var member = _step3.value;

      if (member) {
        candidate = member[accessors[0]];

        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }

        if (typeof candidate !== "undefined") {
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return candidate;
}

var htmlColors = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
};
/**
 * @param {number} [pixelRatio=1]
 */

var ColorPicker$1 = /*#__PURE__*/function () {
  /**
   * @param {number} [pixelRatio=1]
   */
  function ColorPicker$1() {
    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    _classCallCheck(this, ColorPicker$1);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.hueCircle = undefined;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.previousColor = undefined;
    this.applied = false; // bound by

    this.updateCallback = function () {};

    this.closeCallback = function () {}; // create all DOM elements


    this._create();
  }
  /**
   * this inserts the colorPicker into a div from the DOM
   *
   * @param {Element} container
   */


  _createClass(ColorPicker$1, [{
    key: "insertTo",
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }

      this.container = container;
      this.container.appendChild(this.frame);

      this._bindHammer();

      this._setSize();
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */

  }, {
    key: "setUpdateCallback",
    value: function setUpdateCallback(callback) {
      if (typeof callback === "function") {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker update callback is not a function.");
      }
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */

  }, {
    key: "setCloseCallback",
    value: function setCloseCallback(callback) {
      if (typeof callback === "function") {
        this.closeCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
      }
    }
    /**
     *
     * @param {string} color
     * @returns {string}
     * @private
     */

  }, {
    key: "_isColorString",
    value: function _isColorString(color) {
      if (typeof color === "string") {
        return htmlColors[color];
      }
    }
    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     *
     * @param {string | object} color
     * @param {boolean} [setInitial=true]
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (color === "none") {
        return;
      }

      var rgba; // if a html color shorthand is used, convert to hex

      var htmlColor = this._isColorString(color);

      if (htmlColor !== undefined) {
        color = htmlColor;
      } // check format


      if (isString(color) === true) {
        if (isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
          rgba = {
            r: rgbaArray[0],
            g: rgbaArray[1],
            b: rgbaArray[2],
            a: 1.0
          };
        } else if (isValidRGBA(color) === true) {
          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");

          rgba = {
            r: _rgbaArray[0],
            g: _rgbaArray[1],
            b: _rgbaArray[2],
            a: _rgbaArray[3]
          };
        } else if (isValidHex(color) === true) {
          var rgbObj = hexToRGB(color);
          rgba = {
            r: rgbObj.r,
            g: rgbObj.g,
            b: rgbObj.b,
            a: 1.0
          };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : "1.0";
            rgba = {
              r: color.r,
              g: color.g,
              b: color.b,
              a: alpha
            };
          }
        }
      } // set color


      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + stringify$1(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }
    /**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */

  }, {
    key: "show",
    value: function show() {
      if (this.closeCallback !== undefined) {
        this.closeCallback();
        this.closeCallback = undefined;
      }

      this.applied = false;
      this.frame.style.display = "block";

      this._generateHueCircle();
    } // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     *
     * @param {boolean} [storePrevious=true]
     * @private
     */

  }, {
    key: "_hide",
    value: function _hide() {
      var _this2 = this;

      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = assign$2({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = "none"; // call the closing callback, restoring the onclick method.
      // this is in a setTimeout because it will trigger the show again before the click is done.

      setTimeout$1(function () {
        if (_this2.closeCallback !== undefined) {
          _this2.closeCallback();

          _this2.closeCallback = undefined;
        }
      }, 0);
    }
    /**
     * bound to the save button. Saves and hides.
     *
     * @private
     */

  }, {
    key: "_save",
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;

      this._hide();
    }
    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     *
     * @private
     */

  }, {
    key: "_apply",
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);

      this._updatePicker(this.color);
    }
    /**
     * load the color from the previous session.
     *
     * @private
     */

  }, {
    key: "_loadLast",
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }
    /**
     * set the color, place the picker
     *
     * @param {object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */

  }, {
    key: "_setColor",
    value: function _setColor(rgba) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // store the initial color
      if (setInitial === true) {
        this.initialColor = assign$2({}, rgba);
      }

      this.color = rgba;
      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";

      this._updatePicker(rgba);
    }
    /**
     * bound to opacity control
     *
     * @param {number} value
     * @private
     */

  }, {
    key: "_setOpacity",
    value: function _setOpacity(value) {
      this.color.a = value / 100;

      this._updatePicker(this.color);
    }
    /**
     * bound to brightness control
     *
     * @param {number} value
     * @private
     */

  }, {
    key: "_setBrightness",
    value: function _setBrightness(value) {
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba["a"] = this.color.a;
      this.color = rgba;

      this._updatePicker();
    }
    /**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     *
     * @param {object} rgba
     * @private
     */

  }, {
    key: "_updatePicker",
    value: function _updatePicker() {
      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;
      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext("2d");

      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);

      fill(ctx).call(ctx);

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;
      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
    /**
     * used by create to set the size of the canvas.
     *
     * @private
     */

  }, {
    key: "_setSize",
    value: function _setSize() {
      this.colorPickerCanvas.style.width = "100%";
      this.colorPickerCanvas.style.height = "100%";
      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }
    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     *
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      var _context16, _context17, _context18, _context19;

      this.frame = document.createElement("div");
      this.frame.className = "vis-color-picker";
      this.colorPickerDiv = document.createElement("div");
      this.colorPickerSelector = document.createElement("div");
      this.colorPickerSelector.className = "vis-selector";
      this.colorPickerDiv.appendChild(this.colorPickerSelector);
      this.colorPickerCanvas = document.createElement("canvas");
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = "vis-color";
      this.opacityDiv = document.createElement("div");
      this.opacityDiv.className = "vis-opacity";
      this.brightnessDiv = document.createElement("div");
      this.brightnessDiv.className = "vis-brightness";
      this.arrowDiv = document.createElement("div");
      this.arrowDiv.className = "vis-arrow";
      this.opacityRange = document.createElement("input");

      try {
        this.opacityRange.type = "range"; // Not supported on IE9

        this.opacityRange.min = "0";
        this.opacityRange.max = "100";
      } catch (err) {// TODO: Add some error handling.
      }

      this.opacityRange.value = "100";
      this.opacityRange.className = "vis-range";
      this.brightnessRange = document.createElement("input");

      try {
        this.brightnessRange.type = "range"; // Not supported on IE9

        this.brightnessRange.min = "0";
        this.brightnessRange.max = "100";
      } catch (err) {// TODO: Add some error handling.
      }

      this.brightnessRange.value = "100";
      this.brightnessRange.className = "vis-range";
      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);
      var me = this;

      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };

      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };

      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };

      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerText = "brightness:";
      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerText = "opacity:";
      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerText = "new";
      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerText = "initial";
      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerText = "cancel";
      this.cancelButton.onclick = bind$6(_context16 = this._hide).call(_context16, this, false);
      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerText = "apply";
      this.applyButton.onclick = bind$6(_context17 = this._apply).call(_context17, this);
      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerText = "save";
      this.saveButton.onclick = bind$6(_context18 = this._save).call(_context18, this);
      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerText = "load last";
      this.loadButton.onclick = bind$6(_context19 = this._loadLast).call(_context19, this);
      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);
      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }
    /**
     * bind hammer to the color picker
     *
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer$1(this.colorPickerCanvas);
      this.hammer.get("pinch").set({
        enable: true
      });
      this.hammer.on("hammer.input", function (event) {
        if (event.isFirst) {
          _this3._moveSelector(event);
        }
      });
      this.hammer.on("tap", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panstart", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panmove", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panend", function (event) {
        _this3._moveSelector(event);
      });
    }
    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     *
     * @private
     */

  }, {
    key: "_generateHueCircle",
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext("2d");

        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }

        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // draw hue circle

        var x, y, hue, sat;
        this.centerCoordinates = {
          x: w * 0.5,
          y: h * 0.5
        };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb;

        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }

        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();
        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }

      this.generated = true;
    }
    /**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_moveSelector",
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;
      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;
      var x = left - centerX;
      var y = top - centerY;
      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;
      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px"; // set color

      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba["a"] = this.color.a;
      this.color = rgba; // update previews

      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
  }]);

  return ColorPicker$1;
}();
/**
 * Wrap given text (last argument) in HTML elements (all preceding arguments).
 *
 * @param {...any} rest - List of tag names followed by inner text.
 * @returns An element or a text node.
 */


function wrapInTag() {
  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }

  if (rest.length < 1) {
    throw new TypeError("Invalid arguments.");
  } else if (rest.length === 1) {
    return document.createTextNode(rest[0]);
  } else {
    var element = document.createElement(rest[0]);
    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray(slice(rest).call(rest, 1))));
    return element;
  }
}
/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 */


var Configurator$1 = /*#__PURE__*/function () {
  /**
   * @param {object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {object} defaultContainer    | the default container of the module
   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   * @param {Function} hideOption        | custom logic to dynamically hide options
   */
  function Configurator$1(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var hideOption = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
      return false;
    };

    _classCallCheck(this, Configurator$1);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.hideOption = hideOption;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };

    assign$2(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker$1(pixelRatio);
    this.wrapper = undefined;
  }
  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {object} options
   */


  _createClass(Configurator$1, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};

        this._removePopup();

        var enabled = true;

        if (typeof options === "string") {
          this.options.filter = options;
        } else if (isArray$2(options)) {
          this.options.filter = options.join();
        } else if (_typeof(options) === "object") {
          if (options == null) {
            throw new TypeError("options cannot be null");
          }

          if (options.container !== undefined) {
            this.options.container = options.container;
          }

          if (filter(options) !== undefined) {
            this.options.filter = filter(options);
          }

          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }

          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === "boolean") {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === "function") {
          this.options.filter = options;
          enabled = true;
        }

        if (filter(this.options) === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }

      this._clean();
    }
    /**
     *
     * @param {object} moduleOptions
     */

  }, {
    key: "setModuleOptions",
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;

      if (this.options.enabled === true) {
        this._clean();

        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }

        this._create();
      }
    }
    /**
     * Create all DOM elements
     *
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      this._clean();

      this.changedOptions = [];

      var filter$1 = filter(this.options);

      var counter = 0;
      var show = false;

      for (var _option in this.configureOptions) {
        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {
          this.allowCreation = false;
          show = false;

          if (typeof filter$1 === "function") {
            show = filter$1(_option, []);
            show = show || this._handleObject(this.configureOptions[_option], [_option], true);
          } else if (filter$1 === true || indexOf(filter$1).call(filter$1, _option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true; // linebreak between categories

            if (counter > 0) {
              this._makeItem([]);
            } // a header for the category


            this._makeHeader(_option); // get the sub options


            this._handleObject(this.configureOptions[_option], [_option]);
          }

          counter++;
        }
      }

      this._makeButton();

      this._push(); //~ this.colorPicker.insertTo(this.container);

    }
    /**
     * draw all DOM elements on the screen
     *
     * @private
     */

  }, {
    key: "_push",
    value: function _push() {
      this.wrapper = document.createElement("div");
      this.wrapper.className = "vis-configuration-wrapper";
      this.container.appendChild(this.wrapper);

      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }
    /**
     * delete all DOM elements
     *
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }

      this.domElements = [];

      this._removePopup();
    }
    /**
     * get the value from the actualOptions if it exists
     *
     * @param {Array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */

  }, {
    key: "_getValue",
    value: function _getValue(path) {
      var base = this.moduleOptions;

      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }

      return base;
    }
    /**
     * all option elements are wrapped in an item
     *
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */

  }, {
    key: "_makeItem",
    value: function _makeItem(path) {
      if (this.allowCreation === true) {
        var item = document.createElement("div");
        item.className = "vis-configuration vis-config-item vis-config-s" + path.length;

        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          domElements[_key6 - 1] = arguments[_key6];
        }

        forEach$2(domElements).call(domElements, function (element) {
          item.appendChild(element);
        });

        this.domElements.push(item);
        return this.domElements.length;
      }

      return 0;
    }
    /**
     * header for major subjects
     *
     * @param {string} name
     * @private
     */

  }, {
    key: "_makeHeader",
    value: function _makeHeader(name) {
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-header";
      div.innerText = name;

      this._makeItem([], div);
    }
    /**
     * make a label, if it is an object label, it gets different styling.
     *
     * @param {string} name
     * @param {Array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_makeLabel",
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-label vis-config-s" + path.length;

      if (objectLabel === true) {
        while (div.firstChild) {
          div.removeChild(div.firstChild);
        }

        div.appendChild(wrapInTag("i", "b", name));
      } else {
        div.innerText = name + ":";
      }

      return div;
    }
    /**
     * make a dropdown list for multiple possible string optoins
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeDropdown",
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement("select");
      select.className = "vis-configuration vis-config-select";
      var selectedValue = 0;

      if (value !== undefined) {
        if (indexOf(arr).call(arr, value) !== -1) {
          selectedValue = indexOf(arr).call(arr, value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var _option2 = document.createElement("option");

        _option2.value = arr[i];

        if (i === selectedValue) {
          _option2.selected = "selected";
        }

        _option2.innerText = arr[i];
        select.appendChild(_option2);
      }

      var me = this;

      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, select);
    }
    /**
     * make a range object for numeric options
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeRange",
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement("input");
      range.className = "vis-configuration vis-config-range";

      try {
        range.type = "range"; // not supported on IE9

        range.min = min;
        range.max = max;
      } catch (err) {// TODO: Add some error handling.
      }

      range.step = step; // set up the popup settings in case they are needed.

      var popupString = "";
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.2;

        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = "range increased";
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = "range increased";
        }

        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = "range increased";
        }

        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement("input");
      input.className = "vis-configuration vis-config-rangeinput";
      input.value = range.value;
      var me = this;

      range.onchange = function () {
        input.value = this.value;

        me._update(Number(this.value), path);
      };

      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);

      var itemIndex = this._makeItem(path, label, range, input); // if a popup is needed AND it has not been shown for this value, show it.


      if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;

        this._setupPopup(popupString, itemIndex);
      }
    }
    /**
     * make a button object
     *
     * @private
     */

  }, {
    key: "_makeButton",
    value: function _makeButton() {
      var _this4 = this;

      if (this.options.showButton === true) {
        var generateButton = document.createElement("div");
        generateButton.className = "vis-configuration vis-config-button";
        generateButton.innerText = "generate options";

        generateButton.onclick = function () {
          _this4._printOptions();
        };

        generateButton.onmouseover = function () {
          generateButton.className = "vis-configuration vis-config-button hover";
        };

        generateButton.onmouseout = function () {
          generateButton.className = "vis-configuration vis-config-button";
        };

        this.optionsContainer = document.createElement("div");
        this.optionsContainer.className = "vis-configuration vis-config-option-container";
        this.domElements.push(this.optionsContainer);
        this.domElements.push(generateButton);
      }
    }
    /**
     * prepare the popup
     *
     * @param {string} string
     * @param {number} index
     * @private
     */

  }, {
    key: "_setupPopup",
    value: function _setupPopup(string, index) {
      var _this5 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerText = string;

        div.onclick = function () {
          _this5._removePopup();
        };

        this.popupCounter += 1;
        this.popupDiv = {
          html: div,
          index: index
        };
      }
    }
    /**
     * remove the popup from the dom
     *
     * @private
     */

  }, {
    key: "_removePopup",
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }
    /**
     * Show the popup if it is needed.
     *
     * @private
     */

  }, {
    key: "_showPopupIfNeeded",
    value: function _showPopupIfNeeded() {
      var _this6 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;

        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout$1(function () {
          _this6.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout$1(function () {
          _this6._removePopup();
        }, 1800);
      }
    }
    /**
     * make a checkbox for boolean options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeCheckbox",
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "vis-configuration vis-config-checkbox";
      checkbox.checked = defaultValue;

      if (value !== undefined) {
        checkbox.checked = value;

        if (value !== defaultValue) {
          if (_typeof(defaultValue) === "object") {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({
                path: path,
                value: value
              });
            }
          } else {
            this.changedOptions.push({
              path: path,
              value: value
            });
          }
        }
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a text input field for string options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeTextInput",
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement("input");
      checkbox.type = "text";
      checkbox.className = "vis-configuration vis-config-text";
      checkbox.value = value;

      if (value !== defaultValue) {
        this.changedOptions.push({
          path: path,
          value: value
        });
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a color field with a color picker for color fields
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeColorField",
    value: function _makeColorField(arr, value, path) {
      var _this7 = this;

      var defaultColor = arr[1];
      var div = document.createElement("div");
      value = value === undefined ? defaultColor : value;

      if (value !== "none") {
        div.className = "vis-configuration vis-config-colorBlock";
        div.style.backgroundColor = value;
      } else {
        div.className = "vis-configuration vis-config-colorBlock none";
      }

      value = value === undefined ? defaultColor : value;

      div.onclick = function () {
        _this7._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, div);
    }
    /**
     * used by the color buttons to call the color picker.
     *
     * @param {number} value
     * @param {HTMLElement} div
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_showColorPicker",
    value: function _showColorPicker(value, div, path) {
      var _this8 = this;

      // clear the callback from this div
      div.onclick = function () {};

      this.colorPicker.insertTo(div);
      this.colorPicker.show();
      this.colorPicker.setColor(value);
      this.colorPicker.setUpdateCallback(function (color) {
        var colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
        div.style.backgroundColor = colorString;

        _this8._update(colorString, path);
      }); // on close of the colorpicker, restore the callback.

      this.colorPicker.setCloseCallback(function () {
        div.onclick = function () {
          _this8._showColorPicker(value, div, path);
        };
      });
    }
    /**
     * parse an object and draw the correct items
     *
     * @param {object} obj
     * @param {Array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_handleObject",
    value: function _handleObject(obj) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var show = false;

      var filter$1 = filter(this.options);

      var visibleInSet = false;

      for (var subObj in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = copyAndExtendArray(path, subObj);

          if (typeof filter$1 === "function") {
            show = filter$1(subObj, path); // if needed we must go deeper into the object.

            if (show === false) {
              if (!isArray$2(item) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;

            var value = this._getValue(newPath);

            if (isArray$2(item)) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === "string") {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === "boolean") {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // skip the options that are not enabled
              if (!this.hideOption(path, subObj, this.moduleOptions)) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = copyAndExtendArray(newPath, "enabled");

                  var enabledValue = this._getValue(enabledPath);

                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);

                    this._makeItem(newPath, label);

                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var _label = this._makeLabel(subObj, newPath, true);

                  this._makeItem(newPath, _label);

                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error("dont know how to handle", item, subObj, newPath);
            }
          }
        }
      }

      return visibleInSet;
    }
    /**
     * handle the array type of option
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_handleArray",
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === "string" && arr[0] === "color") {
        this._makeColorField(arr, value, path);

        if (arr[1] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === "string") {
        this._makeDropdown(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === "number") {
        this._makeRange(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: Number(value)
          });
        }
      }
    }
    /**
     * called to update the network with the new settings.
     *
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_update",
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }

      this.initialized = true;
      this.parent.setOptions(options);
    }
    /**
     *
     * @param {string | boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */

  }, {
    key: "_constructOptions",
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var pointer = optionsObj; // when dropdown boxes can be string or boolean, we typecast it into correct types

      value = value === "true" ? true : value;
      value = value === "false" ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== "global") {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }

          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }

      return optionsObj;
    }
    /**
     * @private
     */

  }, {
    key: "_printOptions",
    value: function _printOptions() {
      var options = this.getOptions();

      while (this.optionsContainer.firstChild) {
        this.optionsContainer.removeChild(this.optionsContainer.firstChild);
      }

      this.optionsContainer.appendChild(wrapInTag("pre", "const options = " + stringify$1(options, null, 2)));
    }
    /**
     *
     * @returns {{}} options
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = {};

      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }

      return options;
    }
  }]);

  return Configurator$1;
}();
/**
 * Popup is a class to create a popup window with some text
 */


var Popup$1 = /*#__PURE__*/function () {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')
   */
  function Popup$1(container, overflowMethod) {
    _classCallCheck(this, Popup$1);

    this.container = container;
    this.overflowMethod = overflowMethod || "cap";
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false; // create the frame

    this.frame = document.createElement("div");
    this.frame.className = "vis-tooltip";
    this.container.appendChild(this.frame);
  }
  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */


  _createClass(Popup$1, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.x = _parseInt(x);
      this.y = _parseInt(y);
    }
    /**
     * Set the content for the popup window. This can be HTML code or text.
     *
     * @param {string | Element} content
     */

  }, {
    key: "setText",
    value: function setText(content) {
      if (content instanceof Element) {
        while (this.frame.firstChild) {
          this.frame.removeChild(this.frame.firstChild);
        }

        this.frame.appendChild(content);
      } else {
        // String containing literal text, element has to be used for HTML due to
        // XSS risks associated with innerHTML (i.e. prevent XSS by accident).
        this.frame.innerText = content;
      }
    }
    /**
     * Show the popup window
     *
     * @param {boolean} [doShow]    Show or hide the window
     */

  }, {
    key: "show",
    value: function show(doShow) {
      if (doShow === undefined) {
        doShow = true;
      }

      if (doShow === true) {
        var height = this.frame.clientHeight;
        var width = this.frame.clientWidth;
        var maxHeight = this.frame.parentNode.clientHeight;
        var maxWidth = this.frame.parentNode.clientWidth;
        var left = 0,
            top = 0;

        if (this.overflowMethod == "flip") {
          var isLeft = false,
              isTop = true; // Where around the position it's located

          if (this.y - height < this.padding) {
            isTop = false;
          }

          if (this.x + width > maxWidth - this.padding) {
            isLeft = true;
          }

          if (isLeft) {
            left = this.x - width;
          } else {
            left = this.x;
          }

          if (isTop) {
            top = this.y - height;
          } else {
            top = this.y;
          }
        } else {
          top = this.y - height;

          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }

          if (top < this.padding) {
            top = this.padding;
          }

          left = this.x;

          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }

          if (left < this.padding) {
            left = this.padding;
          }
        }

        this.frame.style.left = left + "px";
        this.frame.style.top = top + "px";
        this.frame.style.visibility = "visible";
        this.hidden = false;
      } else {
        this.hide();
      }
    }
    /**
     * Hide the popup window
     */

  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
      this.frame.style.left = "0";
      this.frame.style.top = "0";
      this.frame.style.visibility = "hidden";
    }
    /**
     * Remove the popup window
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM
    }
  }]);

  return Popup$1;
}();

var errorFound = false;
var allOptions$1;
var VALIDATOR_PRINT_STYLE$1 = "background: #FFeeee; color: #dd0000";
/**
 *  Used to validate options.
 */

var Validator$1 = /*#__PURE__*/function () {
  function Validator$1() {
    _classCallCheck(this, Validator$1);
  }

  _createClass(Validator$1, null, [{
    key: "validate",
    value:
    /**
     * Main function to be called
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {object} subObject
     * @returns {boolean}
     * @static
     */
    function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions$1 = referenceOptions;
      var usedOptions = referenceOptions;

      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }

      Validator$1.parse(options, usedOptions, []);
      return errorFound;
    }
    /**
     * Will traverse an object recursively and check every value
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "parse",
    value: function parse(options, referenceOptions, path) {
      for (var _option3 in options) {
        if (Object.prototype.hasOwnProperty.call(options, _option3)) {
          Validator$1.check(_option3, options, referenceOptions, path);
        }
      }
    }
    /**
     * Check every value. If the value is an object, call the parse function on that object.
     *
     * @param {string} option
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "check",
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator$1.getSuggestion(option, referenceOptions, path);
        return;
      }

      var referenceOption = option;
      var is_object = true;

      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // NOTE: This only triggers if the __any__ is in the top level of the options object.
        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!
        // TODO: Examine if needed, remove if possible
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        referenceOption = "__any__"; // if the any-subgroup is not a predefined object in the configurator,
        // we do not look deeper into the object.

        is_object = Validator$1.getType(options[option]) === "object";
      }

      var refOptionObj = referenceOptions[referenceOption];

      if (is_object && refOptionObj.__type__ !== undefined) {
        refOptionObj = refOptionObj.__type__;
      }

      Validator$1.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
    }
    /**
     *
     * @param {string}  option           | the option property
     * @param {object}  options          | The supplied options object
     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */

  }, {
    key: "checkFields",
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var log = function log(message) {
        console.error("%c" + message + Validator$1.printLocation(path, option), VALIDATOR_PRINT_STYLE$1);
      };

      var optionType = Validator$1.getType(options[option]);
      var refOptionType = refOptionObj[optionType];

      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator$1.getType(refOptionType) === "array" && indexOf(refOptionType).call(refOptionType, options[option]) === -1) {
          log('Invalid option detected in "' + option + '".' + " Allowed values are:" + Validator$1.print(refOptionType) + ' not "' + options[option] + '". ');
          errorFound = true;
        } else if (optionType === "object" && referenceOption !== "__any__") {
          path = copyAndExtendArray(path, option);
          Validator$1.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj["any"] === undefined) {
        // type of the field is incorrect and the field cannot be any
        log('Invalid type received for "' + option + '". Expected: ' + Validator$1.print(keys$4(refOptionObj)) + ". Received [" + optionType + '] "' + options[option] + '"');
        errorFound = true;
      }
    }
    /**
     *
     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object
     * @returns {string}
     * @static
     */

  }, {
    key: "getType",
    value: function getType(object) {
      var type = _typeof(object);

      if (type === "object") {
        if (object === null) {
          return "null";
        }

        if (object instanceof Boolean) {
          return "boolean";
        }

        if (object instanceof Number) {
          return "number";
        }

        if (object instanceof String) {
          return "string";
        }

        if (isArray$2(object)) {
          return "array";
        }

        if (object instanceof Date) {
          return "date";
        }

        if (object.nodeType !== undefined) {
          return "dom";
        }

        if (object._isAMomentObject === true) {
          return "moment";
        }

        return "object";
      } else if (type === "number") {
        return "number";
      } else if (type === "boolean") {
        return "boolean";
      } else if (type === "string") {
        return "string";
      } else if (type === undefined) {
        return "undefined";
      }

      return type;
    }
    /**
     * @param {string} option
     * @param {object} options
     * @param {Array.<string>} path
     * @static
     */

  }, {
    key: "getSuggestion",
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator$1.findInOptions(option, options, path, false);
      var globalSearch = Validator$1.findInOptions(option, allOptions$1, [], true);
      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;
      var msg;

      if (localSearch.indexMatch !== undefined) {
        msg = " in " + Validator$1.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        msg = " in " + Validator$1.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator$1.printLocation(globalSearch.path, globalSearch.closestMatch, "");
      } else if (localSearch.distance <= localSearchThreshold) {
        msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator$1.printLocation(localSearch.path, option);
      } else {
        msg = ". Did you mean one of these: " + Validator$1.print(keys$4(options)) + Validator$1.printLocation(path, option);
      }

      console.error('%cUnknown option detected: "' + option + '"' + msg, VALIDATOR_PRINT_STYLE$1);
      errorFound = true;
    }
    /**
     * traverse the options in search for a match.
     *
     * @param {string} option
     * @param {object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */

  }, {
    key: "findInOptions",
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var min = 1e9;
      var closestMatch = "";
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;

      for (var op in options) {
        var distance = void 0;

        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator$1.findInOptions(option, options[op], copyAndExtendArray(path, op));

          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          var _context20;

          if (indexOf(_context20 = op.toLowerCase()).call(_context20, lowerCaseOption) !== -1) {
            indexMatch = op;
          }

          distance = Validator$1.levenshteinDistance(option, op);

          if (min > distance) {
            closestMatch = op;
            closestMatchPath = copyArray(path);
            min = distance;
          }
        }
      }

      return {
        closestMatch: closestMatch,
        path: closestMatchPath,
        distance: min,
        indexMatch: indexMatch
      };
    }
    /**
     * @param {Array.<string>} path
     * @param {object} option
     * @param {string} prefix
     * @returns {string}
     * @static
     */

  }, {
    key: "printLocation",
    value: function printLocation(path, option) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Problem value found at: \n";
      var str = "\n\n" + prefix + "options = {\n";

      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += "  ";
        }

        str += path[i] + ": {\n";
      }

      for (var _j = 0; _j < path.length + 1; _j++) {
        str += "  ";
      }

      str += option + "\n";

      for (var _i3 = 0; _i3 < path.length + 1; _i3++) {
        for (var _j2 = 0; _j2 < path.length - _i3; _j2++) {
          str += "  ";
        }

        str += "}\n";
      }

      return str + "\n\n";
    }
    /**
     * @param {object} options
     * @returns {string}
     * @static
     */

  }, {
    key: "print",
    value: function print(options) {
      return stringify$1(options).replace(/(")|(\[)|(\])|(,"__type__")/g, "").replace(/(,)/g, ", ");
    }
    /**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */

  }, {
    key: "levenshteinDistance",
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      var matrix = []; // increment along the first column of each row

      var i;

      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      } // increment each column in the first row


      var j;

      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      } // Fill in the rest of the matrix


      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator$1;
}();

var Activator = Activator$1;
var Configurator = Configurator$1;
var Hammer = Hammer$1;
var Popup = Popup$1;
var VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;
var Validator = Validator$1;

/* eslint-disable no-prototype-builtins */

/* eslint-disable no-unused-vars */

/* eslint-disable no-var */

/**
 * Parse a text source containing data in DOT language into a JSON object.
 * The object contains two lists: one with nodes and one with edges.
 *
 * DOT language reference: http://www.graphviz.org/doc/info/lang.html
 *
 * DOT language attributes: http://graphviz.org/content/attrs
 *
 * @param {string} data     Text containing a graph in DOT-notation
 * @returns {object} graph   An object containing two parameters:
 *                          {Object[]} nodes
 *                          {Object[]} edges
 *
 * -------------------------------------------
 * TODO
 * ====
 *
 * For label handling, this is an incomplete implementation. From docs (quote #3015):
 *
 * > the escape sequences "\n", "\l" and "\r" divide the label into lines, centered,
 * > left-justified, and right-justified, respectively.
 *
 * Source: http://www.graphviz.org/content/attrs#kescString
 *
 * > As another aid for readability, dot allows double-quoted strings to span multiple physical
 * > lines using the standard C convention of a backslash immediately preceding a newline
 * > character
 * > In addition, double-quoted strings can be concatenated using a '+' operator.
 * > As HTML strings can contain newline characters, which are used solely for formatting,
 * > the language does not allow escaped newlines or concatenation operators to be used
 * > within them.
 *
 * - Currently, only '\\n' is handled
 * - Note that text explicitly says 'labels'; the dot parser currently handles escape
 *   sequences in **all** strings.
 */
function parseDOT(data) {
  dot = data;
  return parseGraph();
} // mapping of attributes from DOT (the keys) to vis.js (the values)

var NODE_ATTR_MAPPING = {
  fontsize: "font.size",
  fontcolor: "font.color",
  labelfontcolor: "font.color",
  fontname: "font.face",
  color: ["color.border", "color.background"],
  fillcolor: "color.background",
  tooltip: "title",
  labeltooltip: "title"
};

var EDGE_ATTR_MAPPING = create$5(NODE_ATTR_MAPPING);

EDGE_ATTR_MAPPING.color = "color.color";
EDGE_ATTR_MAPPING.style = "dashes"; // token types enumeration

var TOKENTYPE = {
  NULL: 0,
  DELIMITER: 1,
  IDENTIFIER: 2,
  UNKNOWN: 3
}; // map with all delimiters

var DELIMITERS = {
  "{": true,
  "}": true,
  "[": true,
  "]": true,
  ";": true,
  "=": true,
  ",": true,
  "->": true,
  "--": true
};
var dot = ""; // current dot file

var index$1 = 0; // current index in dot file

var c = ""; // current token character in expr

var token = ""; // current token

var tokenType = TOKENTYPE.NULL; // type of the token

/**
 * Get the first character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */

function first() {
  index$1 = 0;
  c = dot.charAt(0);
}
/**
 * Get the next character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */


function next() {
  index$1++;
  c = dot.charAt(index$1);
}
/**
 * Preview the next character from the dot file.
 *
 * @returns {string} cNext
 */


function nextPreview() {
  return dot.charAt(index$1 + 1);
}
/**
 * Test whether given character is alphabetic or numeric ( a-zA-Z_0-9.:# )
 *
 * @param {string} c
 * @returns {boolean} isAlphaNumeric
 */


function isAlphaNumeric(c) {
  var charCode = c.charCodeAt(0);

  if (charCode < 47) {
    // #.
    return charCode === 35 || charCode === 46;
  }

  if (charCode < 59) {
    // 0-9 and :
    return charCode > 47;
  }

  if (charCode < 91) {
    // A-Z
    return charCode > 64;
  }

  if (charCode < 96) {
    // _
    return charCode === 95;
  }

  if (charCode < 123) {
    // a-z
    return charCode > 96;
  }

  return false;
}
/**
 * Merge all options of object b into object b
 *
 * @param {object} a
 * @param {object} b
 * @returns {object} a
 */


function merge$1(a, b) {
  if (!a) {
    a = {};
  }

  if (b) {
    for (var name in b) {
      if (b.hasOwnProperty(name)) {
        a[name] = b[name];
      }
    }
  }

  return a;
}
/**
 * Set a value in an object, where the provided parameter name can be a
 * path with nested parameters. For example:
 *
 *     var obj = {a: 2};
 *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
 *
 * @param {object} obj
 * @param {string} path  A parameter name or dot-separated parameter path,
 *                      like "color.highlight.border".
 * @param {*} value
 */


function setValue(obj, path, value) {
  var keys = path.split(".");
  var o = obj;

  while (keys.length) {
    var key = keys.shift();

    if (keys.length) {
      // this isn't the end point
      if (!o[key]) {
        o[key] = {};
      }

      o = o[key];
    } else {
      // this is the end point
      o[key] = value;
    }
  }
}
/**
 * Add a node to a graph object. If there is already a node with
 * the same id, their attributes will be merged.
 *
 * @param {object} graph
 * @param {object} node
 */


function addNode(graph, node) {
  var i, len;
  var current = null; // find root graph (in case of subgraph)

  var graphs = [graph]; // list with all graphs from current graph to root graph

  var root = graph;

  while (root.parent) {
    graphs.push(root.parent);
    root = root.parent;
  } // find existing node (at root level) by its id


  if (root.nodes) {
    for (i = 0, len = root.nodes.length; i < len; i++) {
      if (node.id === root.nodes[i].id) {
        current = root.nodes[i];
        break;
      }
    }
  }

  if (!current) {
    // this is a new node
    current = {
      id: node.id
    };

    if (graph.node) {
      // clone default attributes
      current.attr = merge$1(current.attr, graph.node);
    }
  } // add node to this (sub)graph and all its parent graphs


  for (i = graphs.length - 1; i >= 0; i--) {
    var _context;

    var g = graphs[i];

    if (!g.nodes) {
      g.nodes = [];
    }

    if (indexOf(_context = g.nodes).call(_context, current) === -1) {
      g.nodes.push(current);
    }
  } // merge attributes


  if (node.attr) {
    current.attr = merge$1(current.attr, node.attr);
  }
}
/**
 * Add an edge to a graph object
 *
 * @param {object} graph
 * @param {object} edge
 */


function addEdge(graph, edge) {
  if (!graph.edges) {
    graph.edges = [];
  }

  graph.edges.push(edge);

  if (graph.edge) {
    var attr = merge$1({}, graph.edge); // clone default attributes

    edge.attr = merge$1(attr, edge.attr); // merge attributes
  }
}
/**
 * Create an edge to a graph object
 *
 * @param {object} graph
 * @param {string | number | object} from
 * @param {string | number | object} to
 * @param {string} type
 * @param {object | null} attr
 * @returns {object} edge
 */


function createEdge(graph, from, to, type, attr) {
  var edge = {
    from: from,
    to: to,
    type: type
  };

  if (graph.edge) {
    edge.attr = merge$1({}, graph.edge); // clone default attributes
  }

  edge.attr = merge$1(edge.attr || {}, attr); // merge attributes
  // Move arrows attribute from attr to edge temporally created in
  // parseAttributeList().

  if (attr != null) {
    if (attr.hasOwnProperty("arrows") && attr["arrows"] != null) {
      edge["arrows"] = {
        to: {
          enabled: true,
          type: attr.arrows.type
        }
      };
      attr["arrows"] = null;
    }
  }

  return edge;
}
/**
 * Get next token in the current dot file.
 * The token and token type are available as token and tokenType
 */


function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = ""; // skip over whitespaces

  while (c === " " || c === "\t" || c === "\n" || c === "\r") {
    // space, tab, enter
    next();
  }

  do {
    var isComment = false; // skip comment

    if (c === "#") {
      // find the previous non-space character
      var i = index$1 - 1;

      while (dot.charAt(i) === " " || dot.charAt(i) === "\t") {
        i--;
      }

      if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
        // the # is at the start of a line, this is indeed a line comment
        while (c != "" && c != "\n") {
          next();
        }

        isComment = true;
      }
    }

    if (c === "/" && nextPreview() === "/") {
      // skip line comment
      while (c != "" && c != "\n") {
        next();
      }

      isComment = true;
    }

    if (c === "/" && nextPreview() === "*") {
      // skip block comment
      while (c != "") {
        if (c === "*" && nextPreview() === "/") {
          // end of block comment found. skip these last two characters
          next();
          next();
          break;
        } else {
          next();
        }
      }

      isComment = true;
    } // skip over whitespaces


    while (c === " " || c === "\t" || c === "\n" || c === "\r") {
      // space, tab, enter
      next();
    }
  } while (isComment); // check for end of dot file


  if (c === "") {
    // token is still empty
    tokenType = TOKENTYPE.DELIMITER;
    return;
  } // check for delimiters consisting of 2 characters


  var c2 = c + nextPreview();

  if (DELIMITERS[c2]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c2;
    next();
    next();
    return;
  } // check for delimiters consisting of 1 character


  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  } // check for an identifier (number or string)
  // TODO: more precise parsing of numbers/strings (and the port separator ':')


  if (isAlphaNumeric(c) || c === "-") {
    token += c;
    next();

    while (isAlphaNumeric(c)) {
      token += c;
      next();
    }

    if (token === "false") {
      token = false; // convert to boolean
    } else if (token === "true") {
      token = true; // convert to boolean
    } else if (!isNaN(Number(token))) {
      token = Number(token); // convert to number
    }

    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  } // check for a string enclosed by double quotes


  if (c === '"') {
    next();

    while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
      if (c === '"') {
        // skip the escape character
        token += c;
        next();
      } else if (c === "\\" && nextPreview() === "n") {
        // Honor a newline escape sequence
        token += "\n";
        next();
      } else {
        token += c;
      }

      next();
    }

    if (c != '"') {
      throw newSyntaxError('End of string " expected');
    }

    next();
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  } // something unknown is found, wrong characters, a syntax error


  tokenType = TOKENTYPE.UNKNOWN;

  while (c != "") {
    token += c;
    next();
  }

  throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
}
/**
 * Parse a graph.
 *
 * @returns {object} graph
 */


function parseGraph() {
  var graph = {};
  first();
  getToken(); // optional strict keyword

  if (token === "strict") {
    graph.strict = true;
    getToken();
  } // graph or digraph keyword


  if (token === "graph" || token === "digraph") {
    graph.type = token;
    getToken();
  } // optional graph id


  if (tokenType === TOKENTYPE.IDENTIFIER) {
    graph.id = token;
    getToken();
  } // open angle bracket


  if (token != "{") {
    throw newSyntaxError("Angle bracket { expected");
  }

  getToken(); // statements

  parseStatements(graph); // close angle bracket

  if (token != "}") {
    throw newSyntaxError("Angle bracket } expected");
  }

  getToken(); // end of file

  if (token !== "") {
    throw newSyntaxError("End of file expected");
  }

  getToken(); // remove temporary default options

  delete graph.node;
  delete graph.edge;
  delete graph.graph;
  return graph;
}
/**
 * Parse a list with statements.
 *
 * @param {object} graph
 */


function parseStatements(graph) {
  while (token !== "" && token != "}") {
    parseStatement(graph);

    if (token === ";") {
      getToken();
    }
  }
}
/**
 * Parse a single statement. Can be a an attribute statement, node
 * statement, a series of node statements and edge statements, or a
 * parameter.
 *
 * @param {object} graph
 */


function parseStatement(graph) {
  // parse subgraph
  var subgraph = parseSubgraph(graph);

  if (subgraph) {
    // edge statements
    parseEdge(graph, subgraph);
    return;
  } // parse an attribute statement


  var attr = parseAttributeStatement(graph);

  if (attr) {
    return;
  } // parse node


  if (tokenType != TOKENTYPE.IDENTIFIER) {
    throw newSyntaxError("Identifier expected");
  }

  var id = token; // id can be a string or a number

  getToken();

  if (token === "=") {
    // id statement
    getToken();

    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError("Identifier expected");
    }

    graph[id] = token;
    getToken(); // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
  } else {
    parseNodeStatement(graph, id);
  }
}
/**
 * Parse a subgraph
 *
 * @param {object} graph    parent graph object
 * @returns {object | null} subgraph
 */


function parseSubgraph(graph) {
  var subgraph = null; // optional subgraph keyword

  if (token === "subgraph") {
    subgraph = {};
    subgraph.type = "subgraph";
    getToken(); // optional graph id

    if (tokenType === TOKENTYPE.IDENTIFIER) {
      subgraph.id = token;
      getToken();
    }
  } // open angle bracket


  if (token === "{") {
    getToken();

    if (!subgraph) {
      subgraph = {};
    }

    subgraph.parent = graph;
    subgraph.node = graph.node;
    subgraph.edge = graph.edge;
    subgraph.graph = graph.graph; // statements

    parseStatements(subgraph); // close angle bracket

    if (token != "}") {
      throw newSyntaxError("Angle bracket } expected");
    }

    getToken(); // remove temporary default options

    delete subgraph.node;
    delete subgraph.edge;
    delete subgraph.graph;
    delete subgraph.parent; // register at the parent graph

    if (!graph.subgraphs) {
      graph.subgraphs = [];
    }

    graph.subgraphs.push(subgraph);
  }

  return subgraph;
}
/**
 * parse an attribute statement like "node [shape=circle fontSize=16]".
 * Available keywords are 'node', 'edge', 'graph'.
 * The previous list with default attributes will be replaced
 *
 * @param {object} graph
 * @returns {string | null} keyword Returns the name of the parsed attribute
 *                                  (node, edge, graph), or null if nothing
 *                                  is parsed.
 */


function parseAttributeStatement(graph) {
  // attribute statements
  if (token === "node") {
    getToken(); // node attributes

    graph.node = parseAttributeList();
    return "node";
  } else if (token === "edge") {
    getToken(); // edge attributes

    graph.edge = parseAttributeList();
    return "edge";
  } else if (token === "graph") {
    getToken(); // graph attributes

    graph.graph = parseAttributeList();
    return "graph";
  }

  return null;
}
/**
 * parse a node statement
 *
 * @param {object} graph
 * @param {string | number} id
 */


function parseNodeStatement(graph, id) {
  // node statement
  var node = {
    id: id
  };
  var attr = parseAttributeList();

  if (attr) {
    node.attr = attr;
  }

  addNode(graph, node); // edge statements

  parseEdge(graph, id);
}
/**
 * Parse an edge or a series of edges
 *
 * @param {object} graph
 * @param {string | number} from        Id of the from node
 */


function parseEdge(graph, from) {
  while (token === "->" || token === "--") {
    var to;
    var type = token;
    getToken();
    var subgraph = parseSubgraph(graph);

    if (subgraph) {
      to = subgraph;
    } else {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Identifier or subgraph expected");
      }

      to = token;
      addNode(graph, {
        id: to
      });
      getToken();
    } // parse edge attributes


    var attr = parseAttributeList(); // create edge

    var edge = createEdge(graph, from, to, type, attr);
    addEdge(graph, edge);
    from = to;
  }
}
/**
 * Parse a set with attributes,
 * for example [label="1.000", shape=solid]
 *
 * @returns {object | null} attr
 */


function parseAttributeList() {
  var i;
  var attr = null; // edge styles of dot and vis

  var edgeStyles = {
    dashed: true,
    solid: false,
    dotted: [1, 5]
  };
  /**
   * Define arrow types.
   * vis currently supports types defined in 'arrowTypes'.
   * Details of arrow shapes are described in
   * http://www.graphviz.org/content/arrow-shapes
   */

  var arrowTypes = {
    dot: "circle",
    box: "box",
    crow: "crow",
    curve: "curve",
    icurve: "inv_curve",
    normal: "triangle",
    inv: "inv_triangle",
    diamond: "diamond",
    tee: "bar",
    vee: "vee"
  };
  /**
   * 'attr_list' contains attributes for checking if some of them are affected
   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined
   * in DOT) make changes to 'arrows' attribute in vis.
   */

  var attr_list = new Array();
  var attr_names = new Array(); // used for checking the case.
  // parse attributes

  while (token === "[") {
    getToken();
    attr = {};

    while (token !== "" && token != "]") {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute name expected");
      }

      var name = token;
      getToken();

      if (token != "=") {
        throw newSyntaxError("Equal sign = expected");
      }

      getToken();

      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute value expected");
      }

      var value = token; // convert from dot style to vis

      if (name === "style") {
        value = edgeStyles[value];
      }

      var arrowType;

      if (name === "arrowhead") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          to: {
            enabled: true,
            type: arrowType
          }
        };
      }

      if (name === "arrowtail") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          from: {
            enabled: true,
            type: arrowType
          }
        };
      }

      attr_list.push({
        attr: attr,
        name: name,
        value: value
      });
      attr_names.push(name);
      getToken();

      if (token == ",") {
        getToken();
      }
    }

    if (token != "]") {
      throw newSyntaxError("Bracket ] expected");
    }

    getToken();
  }
  /**
   * As explained in [1], graphviz has limitations for combination of
   * arrow[head|tail] and dir. If attribute list includes 'dir',
   * following cases just be supported.
   *   1. both or none + arrowhead, arrowtail
   *   2. forward + arrowhead (arrowtail is not affedted)
   *   3. back + arrowtail (arrowhead is not affected)
   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note
   */


  if (includes(attr_names).call(attr_names, "dir")) {
    var idx = {}; // get index of 'arrows' and 'dir'

    idx.arrows = {};

    for (i = 0; i < attr_list.length; i++) {
      if (attr_list[i].name === "arrows") {
        if (attr_list[i].value.to != null) {
          idx.arrows.to = i;
        } else if (attr_list[i].value.from != null) {
          idx.arrows.from = i;
        } else {
          throw newSyntaxError("Invalid value of arrows");
        }
      } else if (attr_list[i].name === "dir") {
        idx.dir = i;
      }
    } // first, add default arrow shape if it is not assigned to avoid error


    var dir_type = attr_list[idx.dir].value;

    if (!includes(attr_names).call(attr_names, "arrows")) {
      if (dir_type === "both") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "forward") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
      } else if (dir_type === "back") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "none") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: ""
        });
        idx.arrows.to = attr_list.length - 1;
      } else {
        throw newSyntaxError('Invalid dir type "' + dir_type + '"');
      }
    }

    var from_type;
    var to_type; // update 'arrows' attribute from 'dir'.

    if (dir_type === "both") {
      // both of shapes of 'from' and 'to' are given
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };

        splice$1(attr_list).call(attr_list, idx.arrows.from, 1); // shape of 'to' is assigned and use default to 'from'

      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "arrow";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // only shape of 'from' is assigned and use default for 'to'
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
    } else if (dir_type === "back") {
      // given both of shapes, but use only 'from'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // given shape of 'to', but does not use it
      } else if (idx.arrows.to) {
        to_type = "";
        from_type = "arrow";
        idx.arrows.from = idx.arrows.to;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // assign given 'from' shape
      } else if (idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }

      attr_list[idx.arrows.from] = {
        attr: attr_list[idx.arrows.from].attr,
        name: attr_list[idx.arrows.from].name,
        value: {
          from: {
            enabled: true,
            type: attr_list[idx.arrows.from].value.from.type
          }
        }
      };
    } else if (dir_type === "none") {
      var idx_arrow;

      if (idx.arrows.to) {
        idx_arrow = idx.arrows.to;
      } else {
        idx_arrow = idx.arrows.from;
      }

      attr_list[idx_arrow] = {
        attr: attr_list[idx_arrow].attr,
        name: attr_list[idx_arrow].name,
        value: ""
      };
    } else if (dir_type === "forward") {
      // given both of shapes, but use only 'to'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // assign given 'to' shape
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // given shape of 'from', but does not use it
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = "";
        idx.arrows.to = idx.arrows.from;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }

      attr_list[idx.arrows.to] = {
        attr: attr_list[idx.arrows.to].attr,
        name: attr_list[idx.arrows.to].name,
        value: {
          to: {
            enabled: true,
            type: attr_list[idx.arrows.to].value.to.type
          }
        }
      };
    } else {
      throw newSyntaxError('Invalid dir type "' + dir_type + '"');
    } // remove 'dir' attribute no need anymore


    splice$1(attr_list).call(attr_list, idx.dir, 1);
  } // parse 'penwidth'


  var nof_attr_list;

  if (includes(attr_names).call(attr_names, "penwidth")) {
    var tmp_attr_list = [];
    nof_attr_list = attr_list.length;

    for (i = 0; i < nof_attr_list; i++) {
      // exclude 'width' from attr_list if 'penwidth' exists
      if (attr_list[i].name !== "width") {
        if (attr_list[i].name === "penwidth") {
          attr_list[i].name = "width";
        }

        tmp_attr_list.push(attr_list[i]);
      }
    }

    attr_list = tmp_attr_list;
  }

  nof_attr_list = attr_list.length;

  for (i = 0; i < nof_attr_list; i++) {
    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
  }

  return attr;
}
/**
 * Create a syntax error with extra information on current token and index.
 *
 * @param {string} message
 * @returns {SyntaxError} err
 */


function newSyntaxError(message) {
  return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index$1 + ")");
}
/**
 * Chop off text after a maximum length
 *
 * @param {string} text
 * @param {number} maxLength
 * @returns {string}
 */


function chop(text, maxLength) {
  return text.length <= maxLength ? text : text.substr(0, 27) + "...";
}
/**
 * Execute a function fn for each pair of elements in two arrays
 *
 * @param {Array | *} array1
 * @param {Array | *} array2
 * @param {Function} fn
 */


function forEach2(array1, array2, fn) {
  if (isArray$2(array1)) {
    forEach$2(array1).call(array1, function (elem1) {
      if (isArray$2(array2)) {
        forEach$2(array2).call(array2, function (elem2) {
          fn(elem1, elem2);
        });
      } else {
        fn(elem1, array2);
      }
    });
  } else {
    if (isArray$2(array2)) {
      forEach$2(array2).call(array2, function (elem2) {
        fn(array1, elem2);
      });
    } else {
      fn(array1, array2);
    }
  }
}
/**
 * Set a nested property on an object
 * When nested objects are missing, they will be created.
 * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
 *
 * @param {object} object
 * @param {string} path   A dot separated string like 'font.color'
 * @param {*} value       Value for the property
 * @returns {object} Returns the original object, allows for chaining.
 */


function setProp(object, path, value) {
  var names = path.split(".");
  var prop = names.pop(); // traverse over the nested objects

  var obj = object;

  for (var i = 0; i < names.length; i++) {
    var name = names[i];

    if (!(name in obj)) {
      obj[name] = {};
    }

    obj = obj[name];
  } // set the property value


  obj[prop] = value;
  return object;
}
/**
 * Convert an object with DOT attributes to their vis.js equivalents.
 *
 * @param {object} attr     Object with DOT attributes
 * @param {object} mapping
 * @returns {object}         Returns an object with vis.js attributes
 */


function convertAttr(attr, mapping) {
  var converted = {};

  for (var prop in attr) {
    if (attr.hasOwnProperty(prop)) {
      var visProp = mapping[prop];

      if (isArray$2(visProp)) {
        forEach$2(visProp).call(visProp, function (visPropI) {
          setProp(converted, visPropI, attr[prop]);
        });
      } else if (typeof visProp === "string") {
        setProp(converted, visProp, attr[prop]);
      } else {
        setProp(converted, prop, attr[prop]);
      }
    }
  }

  return converted;
}
/**
 * Convert a string containing a graph in DOT language into a map containing
 * with nodes and edges in the format of graph.
 *
 * @param {string} data         Text containing a graph in DOT-notation
 * @returns {object} graphData
 */


function DOTToGraph(data) {
  // parse the DOT file
  var dotData = parseDOT(data);
  var graphData = {
    nodes: [],
    edges: [],
    options: {}
  }; // copy the nodes

  if (dotData.nodes) {
    var _context2;

    forEach$2(_context2 = dotData.nodes).call(_context2, function (dotNode) {
      var graphNode = {
        id: dotNode.id,
        label: String(dotNode.label || dotNode.id)
      };
      merge$1(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));

      if (graphNode.image) {
        graphNode.shape = "image";
      }

      graphData.nodes.push(graphNode);
    });
  } // copy the edges


  if (dotData.edges) {
    var _context3;

    /**
     * Convert an edge in DOT format to an edge with VisGraph format
     *
     * @param {object} dotEdge
     * @returns {object} graphEdge
     */
    var convertEdge = function convertEdge(dotEdge) {
      var graphEdge = {
        from: dotEdge.from,
        to: dotEdge.to
      };
      merge$1(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING)); // Add arrows attribute to default styled arrow.
      // The reason why default style is not added in parseAttributeList() is
      // because only default is cleared before here.

      if (graphEdge.arrows == null && dotEdge.type === "->") {
        graphEdge.arrows = "to";
      }

      return graphEdge;
    };

    forEach$2(_context3 = dotData.edges).call(_context3, function (dotEdge) {
      var from, to;

      if (dotEdge.from instanceof Object) {
        from = dotEdge.from.nodes;
      } else {
        from = {
          id: dotEdge.from
        };
      }

      if (dotEdge.to instanceof Object) {
        to = dotEdge.to.nodes;
      } else {
        to = {
          id: dotEdge.to
        };
      }

      if (dotEdge.from instanceof Object && dotEdge.from.edges) {
        var _context4;

        forEach$2(_context4 = dotEdge.from.edges).call(_context4, function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }

      forEach2(from, to, function (from, to) {
        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
        var graphEdge = convertEdge(subEdge);
        graphData.edges.push(graphEdge);
      });

      if (dotEdge.to instanceof Object && dotEdge.to.edges) {
        var _context5;

        forEach$2(_context5 = dotEdge.to.edges).call(_context5, function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
    });
  } // copy the options


  if (dotData.attr) {
    graphData.options = dotData.attr;
  }

  return graphData;
}
/* eslint-enable no-var */

/* eslint-enable no-unused-vars */

/* eslint-enable no-prototype-builtins */

var dotparser = /*#__PURE__*/Object.freeze({
	__proto__: null,
	parseDOT: parseDOT,
	DOTToGraph: DOTToGraph
});

/**
 * Convert Gephi to Vis.
 *
 * @param gephiJSON - The parsed JSON data in Gephi format.
 * @param optionsObj - Additional options.
 * @returns The converted data ready to be used in Vis.
 */
function parseGephi(gephiJSON, optionsObj) {
  var _context;

  var options = {
    edges: {
      inheritColor: false
    },
    nodes: {
      fixed: false,
      parseColor: false
    }
  };

  if (optionsObj != null) {
    if (optionsObj.fixed != null) {
      options.nodes.fixed = optionsObj.fixed;
    }

    if (optionsObj.parseColor != null) {
      options.nodes.parseColor = optionsObj.parseColor;
    }

    if (optionsObj.inheritColor != null) {
      options.edges.inheritColor = optionsObj.inheritColor;
    }
  }

  var gEdges = gephiJSON.edges;

  var vEdges = map$3(gEdges).call(gEdges, function (gEdge) {
    var vEdge = {
      from: gEdge.source,
      id: gEdge.id,
      to: gEdge.target
    };

    if (gEdge.attributes != null) {
      vEdge.attributes = gEdge.attributes;
    }

    if (gEdge.label != null) {
      vEdge.label = gEdge.label;
    }

    if (gEdge.attributes != null && gEdge.attributes.title != null) {
      vEdge.title = gEdge.attributes.title;
    }

    if (gEdge.type === "Directed") {
      vEdge.arrows = "to";
    } // edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;
    // edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;


    if (gEdge.color && options.edges.inheritColor === false) {
      vEdge.color = gEdge.color;
    }

    return vEdge;
  });

  var vNodes = map$3(_context = gephiJSON.nodes).call(_context, function (gNode) {
    var vNode = {
      id: gNode.id,
      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null
    };

    if (gNode.attributes != null) {
      vNode.attributes = gNode.attributes;
    }

    if (gNode.label != null) {
      vNode.label = gNode.label;
    }

    if (gNode.size != null) {
      vNode.size = gNode.size;
    }

    if (gNode.attributes != null && gNode.attributes.title != null) {
      vNode.title = gNode.attributes.title;
    }

    if (gNode.title != null) {
      vNode.title = gNode.title;
    }

    if (gNode.x != null) {
      vNode.x = gNode.x;
    }

    if (gNode.y != null) {
      vNode.y = gNode.y;
    }

    if (gNode.color != null) {
      if (options.nodes.parseColor === true) {
        vNode.color = gNode.color;
      } else {
        vNode.color = {
          background: gNode.color,
          border: gNode.color,
          highlight: {
            background: gNode.color,
            border: gNode.color
          },
          hover: {
            background: gNode.color,
            border: gNode.color
          }
        };
      }
    }

    return vNode;
  });

  return {
    nodes: vNodes,
    edges: vEdges
  };
}

var gephiParser = /*#__PURE__*/Object.freeze({
	__proto__: null,
	parseGephi: parseGephi
});

// English
var en = {
  addDescription: "Click in an empty space to place a new node.",
  addEdge: "Add Edge",
  addNode: "Add Node",
  back: "Back",
  close: "Close",
  createEdgeError: "Cannot link edges to a cluster.",
  del: "Delete selected",
  deleteClusterError: "Clusters cannot be deleted.",
  edgeDescription: "Click on a node and drag the edge to another node to connect them.",
  edit: "Edit",
  editClusterError: "Clusters cannot be edited.",
  editEdge: "Edit Edge",
  editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
  editNode: "Edit Node"
}; // German

var de = {
  addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
  addEdge: "Kante hinzuf\xFCgen",
  addNode: "Knoten hinzuf\xFCgen",
  back: "Zur\xFCck",
  close: "Schließen",
  createEdgeError: "Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.",
  del: "L\xF6sche Auswahl",
  deleteClusterError: "Cluster k\xF6nnen nicht gel\xF6scht werden.",
  edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
  edit: "Editieren",
  editClusterError: "Cluster k\xF6nnen nicht editiert werden.",
  editEdge: "Kante editieren",
  editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
  editNode: "Knoten editieren"
}; // Spanish

var es = {
  addDescription: "Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.",
  addEdge: "A\xF1adir arista",
  addNode: "A\xF1adir nodo",
  back: "Atr\xE1s",
  close: "Cerrar",
  createEdgeError: "No se puede conectar una arista a un grupo.",
  del: "Eliminar selecci\xF3n",
  deleteClusterError: "No es posible eliminar grupos.",
  edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
  edit: "Editar",
  editClusterError: "No es posible editar grupos.",
  editEdge: "Editar arista",
  editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
  editNode: "Editar nodo"
}; //Italiano

var it = {
  addDescription: "Clicca per aggiungere un nuovo nodo",
  addEdge: "Aggiungi un vertice",
  addNode: "Aggiungi un nodo",
  back: "Indietro",
  close: "Chiudere",
  createEdgeError: "Non si possono collegare vertici ad un cluster",
  del: "Cancella la selezione",
  deleteClusterError: "I cluster non possono essere cancellati",
  edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
  edit: "Modifica",
  editClusterError: "I clusters non possono essere modificati.",
  editEdge: "Modifica il vertice",
  editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
  editNode: "Modifica il nodo"
}; // Dutch

var nl = {
  addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
  addEdge: "Link toevoegen",
  addNode: "Node toevoegen",
  back: "Terug",
  close: "Sluiten",
  createEdgeError: "Kan geen link maken naar een cluster.",
  del: "Selectie verwijderen",
  deleteClusterError: "Clusters kunnen niet worden verwijderd.",
  edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
  edit: "Wijzigen",
  editClusterError: "Clusters kunnen niet worden aangepast.",
  editEdge: "Link wijzigen",
  editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
  editNode: "Node wijzigen"
}; // Portuguese Brazil

var pt = {
  addDescription: "Clique em um espaço em branco para adicionar um novo nó",
  addEdge: "Adicionar aresta",
  addNode: "Adicionar nó",
  back: "Voltar",
  close: "Fechar",
  createEdgeError: "Não foi possível linkar arestas a um cluster.",
  del: "Remover selecionado",
  deleteClusterError: "Clusters não puderam ser removidos.",
  edgeDescription: "Clique em um nó e arraste a aresta até outro nó para conectá-los",
  edit: "Editar",
  editClusterError: "Clusters não puderam ser editados.",
  editEdge: "Editar aresta",
  editEdgeDescription: "Clique nos pontos de controle e os arraste para um nó para conectá-los",
  editNode: "Editar nó"
}; // Russian

var ru = {
  addDescription: "Кликните в свободное место, чтобы добавить новый узел.",
  addEdge: "Добавить ребро",
  addNode: "Добавить узел",
  back: "Назад",
  close: "Закрывать",
  createEdgeError: "Невозможно соединить ребра в кластер.",
  del: "Удалить выбранное",
  deleteClusterError: "Кластеры не могут быть удалены",
  edgeDescription: "Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.",
  edit: "Редактировать",
  editClusterError: "Кластеры недоступны для редактирования.",
  editEdge: "Редактировать ребро",
  editEdgeDescription: "Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.",
  editNode: "Редактировать узел"
}; // Chinese

var cn = {
  addDescription: "单击空白处放置新节点。",
  addEdge: "添加连接线",
  addNode: "添加节点",
  back: "返回",
  close: "關閉",
  createEdgeError: "无法将连接线连接到群集。",
  del: "删除选定",
  deleteClusterError: "无法删除群集。",
  edgeDescription: "单击某个节点并将该连接线拖动到另一个节点以连接它们。",
  edit: "编辑",
  editClusterError: "无法编辑群集。",
  editEdge: "编辑连接线",
  editEdgeDescription: "单击控制节点并将它们拖到节点上连接。",
  editNode: "编辑节点"
}; // Ukrainian

var uk = {
  addDescription: "Kлікніть на вільне місце, щоб додати новий вузол.",
  addEdge: "Додати край",
  addNode: "Додати вузол",
  back: "Назад",
  close: "Закрити",
  createEdgeError: "Не можливо об'єднати краї в групу.",
  del: "Видалити обране",
  deleteClusterError: "Групи не можуть бути видалені.",
  edgeDescription: "Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.",
  edit: "Редагувати",
  editClusterError: "Групи недоступні для редагування.",
  editEdge: "Редагувати край",
  editEdgeDescription: "Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.",
  editNode: "Редагувати вузол"
}; // French

var fr = {
  addDescription: "Cliquez dans un endroit vide pour placer un nœud.",
  addEdge: "Ajouter un lien",
  addNode: "Ajouter un nœud",
  back: "Retour",
  close: "Fermer",
  createEdgeError: "Impossible de créer un lien vers un cluster.",
  del: "Effacer la sélection",
  deleteClusterError: "Les clusters ne peuvent pas être effacés.",
  edgeDescription: "Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.",
  edit: "Éditer",
  editClusterError: "Les clusters ne peuvent pas être édités.",
  editEdge: "Éditer le lien",
  editEdgeDescription: "Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.",
  editNode: "Éditer le nœud"
}; // Czech

var cs = {
  addDescription: "Kluknutím do prázdného prostoru můžete přidat nový vrchol.",
  addEdge: "Přidat hranu",
  addNode: "Přidat vrchol",
  back: "Zpět",
  close: "Zavřít",
  createEdgeError: "Nelze připojit hranu ke shluku.",
  del: "Smazat výběr",
  deleteClusterError: "Nelze mazat shluky.",
  edgeDescription: "Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.",
  edit: "Upravit",
  editClusterError: "Nelze upravovat shluky.",
  editEdge: "Upravit hranu",
  editEdgeDescription: "Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.",
  editNode: "Upravit vrchol"
};

var locales = /*#__PURE__*/Object.freeze({
	__proto__: null,
	en: en,
	de: de,
	es: es,
	it: it,
	nl: nl,
	pt: pt,
	ru: ru,
	cn: cn,
	uk: uk,
	fr: fr,
	cs: cs
});

/**
 * Normalizes language code into the format used internally.
 *
 * @param locales - All the available locales.
 * @param rawCode - The original code as supplied by the user.
 * @returns Language code in the format language-COUNTRY or language, eventually
 * fallbacks to en.
 */
function normalizeLanguageCode(locales, rawCode) {
  try {
    var _rawCode$split = rawCode.split(/[-_ /]/, 2),
        _rawCode$split2 = _slicedToArray(_rawCode$split, 2),
        rawLanguage = _rawCode$split2[0],
        rawCountry = _rawCode$split2[1];

    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;
    var country = rawCountry != null ? rawCountry.toUpperCase() : null;

    if (language && country) {
      var code = language + "-" + country;

      if (Object.prototype.hasOwnProperty.call(locales, code)) {
        return code;
      } else {
        var _context;

        console.warn(concat(_context = "Unknown variant ".concat(country, " of language ")).call(_context, language, "."));
      }
    }

    if (language) {
      var _code = language;

      if (Object.prototype.hasOwnProperty.call(locales, _code)) {
        return _code;
      } else {
        console.warn("Unknown language ".concat(language));
      }
    }

    console.warn("Unknown locale ".concat(rawCode, ", falling back to English."));
    return "en";
  } catch (error) {
    console.error(error);
    console.warn("Unexpected error while normalizing locale ".concat(rawCode, ", falling back to English."));
    return "en";
  }
}

/**
 * Associates a canvas to a given image, containing a number of renderings
 * of the image at various sizes.
 *
 * This technique is known as 'mipmapping'.
 *
 * NOTE: Images can also be of type 'data:svg+xml`. This code also works
 *       for svg, but the mipmapping may not be necessary.
 *
 * @param {Image} image
 */
var CachedImage = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function CachedImage() {
    _classCallCheck(this, CachedImage);

    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array

    this.image = new Image();
    this.canvas = document.createElement("canvas");
  }
  /**
   * Called when the image has been successfully loaded.
   */


  _createClass(CachedImage, [{
    key: "init",
    value: function init() {
      if (this.initialized()) return;
      this.src = this.image.src; // For same interface with Image

      var w = this.image.width;
      var h = this.image.height; // Ease external access

      this.width = w;
      this.height = h;
      var h2 = Math.floor(h / 2);
      var h4 = Math.floor(h / 4);
      var h8 = Math.floor(h / 8);
      var h16 = Math.floor(h / 16);
      var w2 = Math.floor(w / 2);
      var w4 = Math.floor(w / 4);
      var w8 = Math.floor(w / 8);
      var w16 = Math.floor(w / 16); // Make canvas as small as possible

      this.canvas.width = 3 * w4;
      this.canvas.height = h2; // Coordinates and sizes of images contained in the canvas
      // Values per row:  [top x, left y, width, height]

      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];

      this._fillMipMap();
    }
    /**
     * @returns {boolean} true if init() has been called, false otherwise.
     */

  }, {
    key: "initialized",
    value: function initialized() {
      return this.coordinates !== undefined;
    }
    /**
     * Redraw main image in various sizes to the context.
     *
     * The rationale behind this is to reduce artefacts due to interpolation
     * at differing zoom levels.
     *
     * Source: http://stackoverflow.com/q/18761404/1223531
     *
     * This methods takes the resizing out of the drawing loop, in order to
     * reduce performance overhead.
     *
     * TODO: The code assumes that a 2D context can always be gotten. This is
     *       not necessarily true! OTOH, if not true then usage of this class
     *       is senseless.
     *
     * @private
     */

  }, {
    key: "_fillMipMap",
    value: function _fillMipMap() {
      var ctx = this.canvas.getContext("2d"); // First zoom-level comes from the image

      var to = this.coordinates[0];
      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]); // The rest are copy actions internal to the canvas/context

      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
        var from = this.coordinates[iterations - 1];
        var _to = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);
      }
    }
    /**
     * Draw the image, using the mipmap if necessary.
     *
     * MipMap is only used if param factor > 2; otherwise, original bitmap
     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
     *
     * Credits to 'Alex de Mulder' for original implementation.
     *
     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
     * @param {Float} factor scale factor at which to draw
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     */

  }, {
    key: "drawImageAtPosition",
    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
      if (!this.initialized()) return; //can't draw image yet not intialized

      if (factor > 2) {
        // Determine which zoomed image to use
        factor *= 0.5;
        var iterations = 0;

        while (factor > 2 && iterations < this.NUM_ITERATIONS) {
          factor *= 0.5;
          iterations += 1;
        }

        if (iterations >= this.NUM_ITERATIONS) {
          iterations = this.NUM_ITERATIONS - 1;
        } //console.log("iterations: " + iterations);


        var from = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);
      } else {
        // Draw image directly
        ctx.drawImage(this.image, left, top, width, height);
      }
    }
  }]);

  return CachedImage;
}();

/**
 * This callback is a callback that accepts an Image.
 *
 * @callback ImageCallback
 * @param {Image} image
 */

/**
 * This class loads images and keeps them stored.
 *
 * @param {ImageCallback} callback
 */

var Images = /*#__PURE__*/function () {
  /**
   * @param {ImageCallback} callback
   */
  function Images(callback) {
    _classCallCheck(this, Images);

    this.images = {};
    this.imageBroken = {};
    this.callback = callback;
  }
  /**
   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
   * @param {string} brokenUrl                Url the broken image to try and load
   * @param {Image} imageToLoadBrokenUrlOn   The image object
   */


  _createClass(Images, [{
    key: "_tryloadBrokenUrl",
    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
      //If these parameters aren't specified then exit the function because nothing constructive can be done
      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;

      if (brokenUrl === undefined) {
        console.warn("No broken url image defined");
        return;
      } //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl


      imageToLoadBrokenUrlOn.image.onerror = function () {
        console.error("Could not load brokenImage:", brokenUrl); // cache item will contain empty image, this should be OK for default
      }; //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image


      imageToLoadBrokenUrlOn.image.src = brokenUrl;
    }
    /**
     *
     * @param {vis.Image} imageToRedrawWith
     * @private
     */

  }, {
    key: "_redrawWithImage",
    value: function _redrawWithImage(imageToRedrawWith) {
      if (this.callback) {
        this.callback(imageToRedrawWith);
      }
    }
    /**
     * @param {string} url          Url of the image
     * @param {string} brokenUrl    Url of an image to use if the url image is not found
     * @returns {Image} img          The image object
     */

  }, {
    key: "load",
    value: function load(url, brokenUrl) {
      var _this = this;

      //Try and get the image from the cache, if successful then return the cached image
      var cachedImage = this.images[url];
      if (cachedImage) return cachedImage; //Create a new image

      var img = new CachedImage(); // Need to add to cache here, otherwise final return will spawn different copies of the same image,
      // Also, there will be multiple loads of the same image.

      this.images[url] = img; //Subscribe to the event that is raised if the image loads successfully

      img.image.onload = function () {
        // Properly init the cached item and then request a redraw
        _this._fixImageCoordinates(img.image);

        img.init();

        _this._redrawWithImage(img);
      }; //Subscribe to the event that is raised if the image fails to load


      img.image.onerror = function () {
        console.error("Could not load image:", url); //Try and load the image specified by the brokenUrl using

        _this._tryloadBrokenUrl(url, brokenUrl, img);
      }; //Set the source of the image to the url, this is what actually kicks off the loading of the image


      img.image.src = url; //Return the new image

      return img;
    }
    /**
     * IE11 fix -- thanks dponch!
     *
     * Local helper function
     *
     * @param {vis.Image} imageToCache
     * @private
     */

  }, {
    key: "_fixImageCoordinates",
    value: function _fixImageCoordinates(imageToCache) {
      if (imageToCache.width === 0) {
        document.body.appendChild(imageToCache);
        imageToCache.width = imageToCache.offsetWidth;
        imageToCache.height = imageToCache.offsetHeight;
        document.body.removeChild(imageToCache);
      }
    }
  }]);

  return Images;
}();

var internalMetadata = {exports: {}};

var fails$7 = fails$t;
var arrayBufferNonExtensible = fails$7(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8); // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe

    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
      value: 8
    });
  }
});

var fails$6 = fails$t;
var isObject$6 = isObject$j;
var classof$4 = classofRaw$1;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible; // eslint-disable-next-line es/no-object-isextensible -- safe

var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$1 = fails$6(function () {
  $isExtensible(1);
}); // `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible

var objectIsExtensible = FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$6(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$4(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

var fails$5 = fails$t;
var freezing = !fails$5(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});

var $$e = _export;
var uncurryThis$4 = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$5 = isObject$j;
var hasOwn$5 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid = uid$4;
var FREEZING = freezing;
var REQUIRED = false;
var METADATA = uid('meta');
var id$1 = 0;

var setMetadata = function (it) {
  defineProperty$2(it, METADATA, {
    value: {
      objectID: 'O' + id$1++,
      // object ID
      weakData: {} // weak collections IDs

    }
  });
};

var fastKey$1 = function (it, create) {
  // return a primitive with prefix
  if (!isObject$5(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!hasOwn$5(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible$1(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMetadata(it); // return object ID
  }

  return it[METADATA].objectID;
};

var getWeakData$1 = function (it, create) {
  if (!hasOwn$5(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible$1(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMetadata(it); // return the store of weak collections IDs
  }

  return it[METADATA].weakData;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible$1(it) && !hasOwn$5(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () {
    /* empty */
  };

  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis$4([].splice);
  var test = {};
  test[METADATA] = 1; // prevent exposing of metadata key

  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);

      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      }

      return result;
    };

    $$e({
      target: 'Object',
      stat: true,
      forced: true
    }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = internalMetadata.exports = {
  enable: enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

var global$a = global$P;
var bind$3 = functionBindContext;
var call$1 = functionCall;
var anObject$3 = anObject$d;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$d;
var isPrototypeOf$9 = objectIsPrototypeOf;
var getIterator$5 = getIterator$7;
var getIteratorMethod = getIteratorMethod$8;
var iteratorClose = iteratorClose$2;
var TypeError$5 = global$a.TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

var iterate$3 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$3(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }

    return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError$5(tryToString$1(iterable) + ' is not iterable'); // optimisation for array iterators

    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$4(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$9(ResultPrototype, result)) return result;
      }

      return new Result(false);
    }

    iterator = getIterator$5(iterable, iterFn);
  }

  next = iterator.next;

  while (!(step = call$1(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }

    if (typeof result == 'object' && result && isPrototypeOf$9(ResultPrototype, result)) return result;
  }

  return new Result(false);
};

var global$9 = global$P;
var isPrototypeOf$8 = objectIsPrototypeOf;
var TypeError$4 = global$9.TypeError;

var anInstance$3 = function (it, Prototype) {
  if (isPrototypeOf$8(Prototype, it)) return it;
  throw TypeError$4('Incorrect invocation');
};

var $$d = _export;
var global$8 = global$P;
var InternalMetadataModule$1 = internalMetadata.exports;
var fails$4 = fails$t;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var iterate$2 = iterate$3;
var anInstance$2 = anInstance$3;
var isCallable = isCallable$h;
var isObject$4 = isObject$j;
var setToStringTag = setToStringTag$5;
var defineProperty$1 = objectDefineProperty.f;
var forEach = arrayIteration.forEach;
var DESCRIPTORS$2 = descriptors;
var InternalStateModule$2 = internalState;
var setInternalState$2 = InternalStateModule$2.set;
var internalStateGetterFor$2 = InternalStateModule$2.getterFor;

var collection$3 = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global$8[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var exported = {};
  var Constructor;

  if (!DESCRIPTORS$2 || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$4(function () {
    new NativeConstructor().entries().next();
  }))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else {
    Constructor = wrapper(function (target, iterable) {
      setInternalState$2(anInstance$2(target, Prototype), {
        type: CONSTRUCTOR_NAME,
        collection: new NativeConstructor()
      });
      if (iterable != undefined) iterate$2(iterable, target[ADDER], {
        that: target,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor$2(CONSTRUCTOR_NAME);
    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';

      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
        createNonEnumerableProperty(Prototype, KEY, function (a, b) {
          var collection = getInternalState(this).collection;
          if (!IS_ADDER && IS_WEAK && !isObject$4(a)) return KEY == 'get' ? undefined : false;
          var result = collection[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      }
    });
    IS_WEAK || defineProperty$1(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).collection.size;
      }
    });
  }

  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$d({
    global: true,
    forced: true
  }, exported);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var redefine = redefine$4;

var redefineAll$3 = function (target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);
  }

  return target;
};

var getBuiltIn$1 = getBuiltIn$9;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol = wellKnownSymbol$j;
var DESCRIPTORS$1 = descriptors;
var SPECIES = wellKnownSymbol('species');

var setSpecies$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$1(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty = objectDefineProperty.f;
var create$4 = objectCreate;
var redefineAll$2 = redefineAll$3;
var bind$2 = functionBindContext;
var anInstance$1 = anInstance$3;
var iterate$1 = iterate$3;
var defineIterator = defineIterator$3;
var setSpecies = setSpecies$1;
var DESCRIPTORS = descriptors;
var fastKey = internalMetadata.exports.fastKey;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor$1 = InternalStateModule$1.getterFor;
var collectionStrong$2 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        index: create$4(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate$1(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll$2(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;else that.size--;
        }

        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bind$2(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll$2(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$1(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) entry = entry.previous; // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species

    setSpecies(CONSTRUCTOR_NAME);
  }
};

var collection$2 = collection$3;
var collectionStrong$1 = collectionStrong$2; // `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects

collection$2('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong$1);

var path$b = path$y;
var map$2 = path$b.Map;

var parent$v = map$2;
var map$1 = parent$v;

var map = map$1;

/**
 * This class can store groups and options specific for groups.
 */
var Groups = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function Groups() {
    _classCallCheck(this, Groups);

    this.clear();
    this._defaultIndex = 0;
    this._groupIndex = 0;
    this._defaultGroups = [{
      border: "#2B7CE9",
      background: "#97C2FC",
      highlight: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      },
      hover: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      }
    }, // 0: blue
    {
      border: "#FFA500",
      background: "#FFFF00",
      highlight: {
        border: "#FFA500",
        background: "#FFFFA3"
      },
      hover: {
        border: "#FFA500",
        background: "#FFFFA3"
      }
    }, // 1: yellow
    {
      border: "#FA0A10",
      background: "#FB7E81",
      highlight: {
        border: "#FA0A10",
        background: "#FFAFB1"
      },
      hover: {
        border: "#FA0A10",
        background: "#FFAFB1"
      }
    }, // 2: red
    {
      border: "#41A906",
      background: "#7BE141",
      highlight: {
        border: "#41A906",
        background: "#A1EC76"
      },
      hover: {
        border: "#41A906",
        background: "#A1EC76"
      }
    }, // 3: green
    {
      border: "#E129F0",
      background: "#EB7DF4",
      highlight: {
        border: "#E129F0",
        background: "#F0B3F5"
      },
      hover: {
        border: "#E129F0",
        background: "#F0B3F5"
      }
    }, // 4: magenta
    {
      border: "#7C29F0",
      background: "#AD85E4",
      highlight: {
        border: "#7C29F0",
        background: "#D3BDF0"
      },
      hover: {
        border: "#7C29F0",
        background: "#D3BDF0"
      }
    }, // 5: purple
    {
      border: "#C37F00",
      background: "#FFA807",
      highlight: {
        border: "#C37F00",
        background: "#FFCA66"
      },
      hover: {
        border: "#C37F00",
        background: "#FFCA66"
      }
    }, // 6: orange
    {
      border: "#4220FB",
      background: "#6E6EFD",
      highlight: {
        border: "#4220FB",
        background: "#9B9BFD"
      },
      hover: {
        border: "#4220FB",
        background: "#9B9BFD"
      }
    }, // 7: darkblue
    {
      border: "#FD5A77",
      background: "#FFC0CB",
      highlight: {
        border: "#FD5A77",
        background: "#FFD1D9"
      },
      hover: {
        border: "#FD5A77",
        background: "#FFD1D9"
      }
    }, // 8: pink
    {
      border: "#4AD63A",
      background: "#C2FABC",
      highlight: {
        border: "#4AD63A",
        background: "#E6FFE3"
      },
      hover: {
        border: "#4AD63A",
        background: "#E6FFE3"
      }
    }, // 9: mint
    {
      border: "#990000",
      background: "#EE0000",
      highlight: {
        border: "#BB0000",
        background: "#FF3333"
      },
      hover: {
        border: "#BB0000",
        background: "#FF3333"
      }
    }, // 10:bright red
    {
      border: "#FF6000",
      background: "#FF6000",
      highlight: {
        border: "#FF6000",
        background: "#FF6000"
      },
      hover: {
        border: "#FF6000",
        background: "#FF6000"
      }
    }, // 12: real orange
    {
      border: "#97C2FC",
      background: "#2B7CE9",
      highlight: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      },
      hover: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      }
    }, // 13: blue
    {
      border: "#399605",
      background: "#255C03",
      highlight: {
        border: "#399605",
        background: "#255C03"
      },
      hover: {
        border: "#399605",
        background: "#255C03"
      }
    }, // 14: green
    {
      border: "#B70054",
      background: "#FF007E",
      highlight: {
        border: "#B70054",
        background: "#FF007E"
      },
      hover: {
        border: "#B70054",
        background: "#FF007E"
      }
    }, // 15: magenta
    {
      border: "#AD85E4",
      background: "#7C29F0",
      highlight: {
        border: "#D3BDF0",
        background: "#7C29F0"
      },
      hover: {
        border: "#D3BDF0",
        background: "#7C29F0"
      }
    }, // 16: purple
    {
      border: "#4557FA",
      background: "#000EA1",
      highlight: {
        border: "#6E6EFD",
        background: "#000EA1"
      },
      hover: {
        border: "#6E6EFD",
        background: "#000EA1"
      }
    }, // 17: darkblue
    {
      border: "#FFC0CB",
      background: "#FD5A77",
      highlight: {
        border: "#FFD1D9",
        background: "#FD5A77"
      },
      hover: {
        border: "#FFD1D9",
        background: "#FD5A77"
      }
    }, // 18: pink
    {
      border: "#C2FABC",
      background: "#74D66A",
      highlight: {
        border: "#E6FFE3",
        background: "#74D66A"
      },
      hover: {
        border: "#E6FFE3",
        background: "#74D66A"
      }
    }, // 19: mint
    {
      border: "#EE0000",
      background: "#990000",
      highlight: {
        border: "#FF3333",
        background: "#BB0000"
      },
      hover: {
        border: "#FF3333",
        background: "#BB0000"
      }
    } // 20:bright red
    ];
    this.options = {};
    this.defaultOptions = {
      useDefaultGroups: true
    };

    assign$2(this.options, this.defaultOptions);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(Groups, [{
    key: "setOptions",
    value: function setOptions(options) {
      var optionFields = ["useDefaultGroups"];

      if (options !== undefined) {
        for (var groupName in options) {
          if (Object.prototype.hasOwnProperty.call(options, groupName)) {
            if (indexOf(optionFields).call(optionFields, groupName) === -1) {
              var group = options[groupName];
              this.add(groupName, group);
            }
          }
        }
      }
    }
    /**
     * Clear all groups
     */

  }, {
    key: "clear",
    value: function clear() {
      this._groups = new map();
      this._groupNames = [];
    }
    /**
     * Get group options of a groupname.
     * If groupname is not found, a new group may be created.
     *
     * @param {*}       groupname     Can be a number, string, Date, etc.
     * @param {boolean} [shouldCreate=true] If true, create a new group
     * @returns {object} The found or created group
     */

  }, {
    key: "get",
    value: function get(groupname) {
      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var group = this._groups.get(groupname);

      if (group === undefined && shouldCreate) {
        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {
          // create new group
          var index = this._groupIndex % this._groupNames.length;
          ++this._groupIndex;
          group = {};
          group.color = this._groups.get(this._groupNames[index]);

          this._groups.set(groupname, group);
        } else {
          // create new group
          var _index = this._defaultIndex % this._defaultGroups.length;

          this._defaultIndex++;
          group = {};
          group.color = this._defaultGroups[_index];

          this._groups.set(groupname, group);
        }
      }

      return group;
    }
    /**
     * Add custom group style.
     *
     * @param {string} groupName - The name of the group, a new group will be
     * created if a group with the same name doesn't exist, otherwise the old
     * groups style will be overwritten.
     * @param {object} style - An object containing borderColor, backgroundColor,
     * etc.
     * @returns {object} The created group object.
     */

  }, {
    key: "add",
    value: function add(groupName, style) {
      // Only push group name once to prevent duplicates which would consume more
      // RAM and also skew the distribution towards more often updated groups,
      // neither of which is desirable.
      if (!this._groups.has(groupName)) {
        this._groupNames.push(groupName);
      }

      this._groups.set(groupName, style);

      return style;
    }
  }]);

  return Groups;
}();

var $$c = _export; // `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan

$$c({
  target: 'Number',
  stat: true
}, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return number != number;
  }
});

var path$a = path$y;
var isNan$2 = path$a.Number.isNaN;

var parent$u = isNan$2;
var isNan$1 = parent$u;

var isNan = isNan$1;

var global$7 = global$P;
var globalIsFinite = global$7.isFinite; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe

var numberIsFinite$1 = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};

var $$b = _export;
var numberIsFinite = numberIsFinite$1; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite

$$b({
  target: 'Number',
  stat: true
}, {
  isFinite: numberIsFinite
});

var path$9 = path$y;
var _isFinite$2 = path$9.Number.isFinite;

var parent$t = _isFinite$2;
var _isFinite$1 = parent$t;

var _isFinite = _isFinite$1;

var $$a = _export;
var $some = arrayIteration.some;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$6;
var STRICT_METHOD$3 = arrayMethodIsStrict$3('some'); // `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some

$$a({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$3
}, {
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$7 = entryVirtual$l;
var some$3 = entryVirtual$7('Array').some;

var isPrototypeOf$7 = objectIsPrototypeOf;
var method$7 = some$3;
var ArrayPrototype$7 = Array.prototype;

var some$2 = function (it) {
  var own = it.some;
  return it === ArrayPrototype$7 || isPrototypeOf$7(ArrayPrototype$7, it) && own === ArrayPrototype$7.some ? method$7 : own;
};

var parent$s = some$2;
var some$1 = parent$s;

var some = some$1;

var global$6 = global$P;
var isConstructor = isConstructor$4;
var tryToString = tryToString$4;
var TypeError$3 = global$6.TypeError; // `Assert: IsConstructor(argument) is true`

var aConstructor$1 = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError$3(tryToString(argument) + ' is not a constructor');
};

var $$9 = _export;
var getBuiltIn = getBuiltIn$9;
var apply = functionApply;
var bind$1 = functionBind;
var aConstructor = aConstructor$1;
var anObject$2 = anObject$d;
var isObject$3 = isObject$j;
var create$3 = objectCreate;
var fails$3 = fails$t;
var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push$1 = [].push; // `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails$3(function () {
  function F() {
    /* empty */
  }

  return !(nativeConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$3(function () {
  nativeConstruct(function () {
    /* empty */
  });
});
var FORCED$2 = NEW_TARGET_BUG || ARGS_BUG;
$$9({
  target: 'Reflect',
  stat: true,
  forced: FORCED$2,
  sham: FORCED$2
}, {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aConstructor(Target);
    anObject$2(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      apply(push$1, $args, args);
      return new (apply(bind$1, Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create$3(isObject$3(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject$3(result) ? result : instance;
  }
});

var path$8 = path$y;
var construct$2 = path$8.Reflect.construct;

var parent$r = construct$2;
var construct$1 = parent$r;

var construct = construct$1;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var parent$q = create$6;
var create$2 = parent$q;

var parent$p = create$2;
var create$1 = parent$p;

var create = create$1;

var $$8 = _export;
var setPrototypeOf$5 = objectSetPrototypeOf; // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof

$$8({
  target: 'Object',
  stat: true
}, {
  setPrototypeOf: setPrototypeOf$5
});

var path$7 = path$y;
var setPrototypeOf$4 = path$7.Object.setPrototypeOf;

var parent$o = setPrototypeOf$4;
var setPrototypeOf$3 = parent$o;

var parent$n = setPrototypeOf$3;
var setPrototypeOf$2 = parent$n;

var parent$m = setPrototypeOf$2;
var setPrototypeOf$1 = parent$m;

var setPrototypeOf = setPrototypeOf$1;

function _setPrototypeOf(o, p) {
  _setPrototypeOf = setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });

  defineProperty$3(subClass, "prototype", {
    writable: false
  });

  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

var parent$l = getPrototypeOf$5;
var getPrototypeOf$3 = parent$l;

var parent$k = getPrototypeOf$3;
var getPrototypeOf$2 = parent$k;

var getPrototypeOf$1 = getPrototypeOf$2;

function _getPrototypeOf(o) {
  _getPrototypeOf = setPrototypeOf ? getPrototypeOf$1 : function _getPrototypeOf(o) {
    return o.__proto__ || getPrototypeOf$1(o);
  };
  return _getPrototypeOf(o);
}

var runtime = {exports: {}};

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function () {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function (record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
})(runtime);

var regenerator = runtime.exports;

var global$5 = global$P;
var aCallable$2 = aCallable$7;
var toObject$2 = toObject$e;
var IndexedObject = indexedObject;
var lengthOfArrayLike$3 = lengthOfArrayLike$d;
var TypeError$2 = global$5.TypeError; // `Array.prototype.{ reduce, reduceRight }` methods implementation

var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable$2(callbackfn);
    var O = toObject$2(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike$3(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError$2('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

var classof$3 = classofRaw$1;
var global$4 = global$P;
var engineIsNode = classof$3(global$4.process) == 'process';

var $$7 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$6;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD$2 = arrayMethodIsStrict$2('reduce'); // Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce

$$7({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$2 || CHROME_BUG
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$6 = entryVirtual$l;
var reduce$3 = entryVirtual$6('Array').reduce;

var isPrototypeOf$6 = objectIsPrototypeOf;
var method$6 = reduce$3;
var ArrayPrototype$6 = Array.prototype;

var reduce$2 = function (it) {
  var own = it.reduce;
  return it === ArrayPrototype$6 || isPrototypeOf$6(ArrayPrototype$6, it) && own === ArrayPrototype$6.reduce ? method$6 : own;
};

var parent$j = reduce$2;
var reduce$1 = parent$j;

var reduce = reduce$1;

var global$3 = global$P;
var isArray = isArray$d;
var lengthOfArrayLike$2 = lengthOfArrayLike$d;
var bind = functionBindContext;
var TypeError$1 = global$3.TypeError; // `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var flattenIntoArray$1 = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        elementLen = lengthOfArrayLike$2(element);
        targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$1('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
};

var flattenIntoArray_1 = flattenIntoArray$1;

var $$6 = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$1 = aCallable$7;
var toObject$1 = toObject$e;
var lengthOfArrayLike$1 = lengthOfArrayLike$d;
var arraySpeciesCreate = arraySpeciesCreate$4; // `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap

$$6({
  target: 'Array',
  proto: true
}, {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject$1(this);
    var sourceLen = lengthOfArrayLike$1(O);
    var A;
    aCallable$1(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});

var entryVirtual$5 = entryVirtual$l;
var flatMap$3 = entryVirtual$5('Array').flatMap;

var isPrototypeOf$5 = objectIsPrototypeOf;
var method$5 = flatMap$3;
var ArrayPrototype$5 = Array.prototype;

var flatMap$2 = function (it) {
  var own = it.flatMap;
  return it === ArrayPrototype$5 || isPrototypeOf$5(ArrayPrototype$5, it) && own === ArrayPrototype$5.flatMap ? method$5 : own;
};

var parent$i = flatMap$2;
var flatMap$1 = parent$i;

var flatMap = flatMap$1;

var collection$1 = collection$3;
var collectionStrong = collectionStrong$2; // `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects

collection$1('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

var path$6 = path$y;
var set$2 = path$6.Set;

var parent$h = set$2;
var set$1 = parent$h;

var set = set$1;

var iterator = iterator$4;

var getIterator$4 = getIterator$7;
var getIterator_1 = getIterator$4;

var parent$g = getIterator_1;
var getIterator$3 = parent$g;

var parent$f = getIterator$3;
var getIterator$2 = parent$f;

var parent$e = getIterator$2;
var getIterator$1 = parent$e;

var getIterator = getIterator$1;

var arraySlice = arraySliceSimple;
var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];

    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }

    if (j !== i++) array[j] = element;
  }

  return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
  }

  return array;
};

var arraySort = mergeSort;

var userAgent$1 = engineUserAgent;
var firefox = userAgent$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];

var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

var userAgent = engineUserAgent;
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];

var $$5 = _export;
var uncurryThis$3 = functionUncurryThis;
var aCallable = aCallable$7;
var toObject = toObject$e;
var lengthOfArrayLike = lengthOfArrayLike$d;
var toString$1 = toString$8;
var fails$2 = fails$t;
var internalSort = arraySort;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$6;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var un$Sort = uncurryThis$3(test.sort);
var push = uncurryThis$3(test.push); // IE8-

var FAILS_ON_UNDEFINED = fails$2(function () {
  test.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails$2(function () {
  test.sort(null);
}); // Old WebKit

var STRICT_METHOD$1 = arrayMethodIsStrict$1('sort');
var STABLE_SORT = !fails$2(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;
  var result = '';
  var code, chr, value, index; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)

  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;

      case 68:
      case 71:
        value = 4;
        break;

      default:
        value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({
        k: chr + index,
        v: value
      });
    }
  }

  test.sort(function (a, b) {
    return b.v - a.v;
  });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString$1(x) > toString$1(y) ? 1 : -1;
  };
}; // `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort


$$5({
  target: 'Array',
  proto: true,
  forced: FORCED$1
}, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);
    var array = toObject(this);
    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];

    while (index < arrayLength) delete array[index++];

    return array;
  }
});

var entryVirtual$4 = entryVirtual$l;
var sort$3 = entryVirtual$4('Array').sort;

var isPrototypeOf$4 = objectIsPrototypeOf;
var method$4 = sort$3;
var ArrayPrototype$4 = Array.prototype;

var sort$2 = function (it) {
  var own = it.sort;
  return it === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.sort ? method$4 : own;
};

var parent$d = sort$2;
var sort$1 = parent$d;

var sort = sort$1;

var entryVirtual$3 = entryVirtual$l;
var keys$3 = entryVirtual$3('Array').keys;

var parent$c = keys$3;
var keys$2 = parent$c;

var classof$2 = classof$e;
var hasOwn$4 = hasOwnProperty_1;
var isPrototypeOf$3 = objectIsPrototypeOf;
var method$3 = keys$2;
var ArrayPrototype$3 = Array.prototype;
var DOMIterables$2 = {
  DOMTokenList: true,
  NodeList: true
};

var keys$1 = function (it) {
  var own = it.keys;
  return it === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.keys || hasOwn$4(DOMIterables$2, classof$2(it)) ? method$3 : own;
};

var keys = keys$1;

var entryVirtual$2 = entryVirtual$l;
var values$3 = entryVirtual$2('Array').values;

var parent$b = values$3;
var values$2 = parent$b;

var classof$1 = classof$e;
var hasOwn$3 = hasOwnProperty_1;
var isPrototypeOf$2 = objectIsPrototypeOf;
var method$2 = values$2;
var ArrayPrototype$2 = Array.prototype;
var DOMIterables$1 = {
  DOMTokenList: true,
  NodeList: true
};

var values$1 = function (it) {
  var own = it.values;
  return it === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.values || hasOwn$3(DOMIterables$1, classof$1(it)) ? method$2 : own;
};

var values = values$1;

var entryVirtual$1 = entryVirtual$l;
var entries$3 = entryVirtual$1('Array').entries;

var parent$a = entries$3;
var entries$2 = parent$a;

var classof = classof$e;
var hasOwn$2 = hasOwnProperty_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var method$1 = entries$2;
var ArrayPrototype$1 = Array.prototype;
var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

var entries$1 = function (it) {
  var own = it.entries;
  return it === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.entries || hasOwn$2(DOMIterables, classof(it)) ? method$1 : own;
};

var entries = entries$1;

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

var _Symbol$iterator;

function ownKeys$4(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var _context32, _context33; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context32 = ownKeys$4(Object(source), !0)).call(_context32, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context33 = ownKeys$4(Object(source))).call(_context33, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$7(o, minLen) { var _context31; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = slice(_context31 = Object.prototype.toString.call(o)).call(_context31, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Create new data pipe.
 *
 * @param from - The source data set or data view.
 * @remarks
 * Example usage:
 * ```typescript
 * interface AppItem {
 *   whoami: string;
 *   appData: unknown;
 *   visData: VisItem;
 * }
 * interface VisItem {
 *   id: number;
 *   label: string;
 *   color: string;
 *   x: number;
 *   y: number;
 * }
 *
 * const ds1 = new DataSet<AppItem, "whoami">([], { fieldId: "whoami" });
 * const ds2 = new DataSet<VisItem, "id">();
 *
 * const pipe = createNewDataPipeFrom(ds1)
 *   .filter((item): boolean => item.enabled === true)
 *   .map<VisItem, "id">((item): VisItem => item.visData)
 *   .to(ds2);
 *
 * pipe.start();
 * ```
 * @returns A factory whose methods can be used to configure the pipe.
 */

function createNewDataPipeFrom(from) {
  return new DataPipeUnderConstruction(from);
}
/**
 * Internal implementation of the pipe. This should be accessible only through
 * `createNewDataPipeFrom` from the outside.
 *
 * @typeParam SI - Source item type.
 * @typeParam SP - Source item type's id property name.
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */


var SimpleDataPipe = /*#__PURE__*/function () {
  /**
   * Bound listeners for use with `DataInterface['on' | 'off']`.
   */

  /**
   * Create a new data pipe.
   *
   * @param _source - The data set or data view that will be observed.
   * @param _transformers - An array of transforming functions to be used to
   * filter or transform the items in the pipe.
   * @param _target - The data set or data view that will receive the items.
   */
  function SimpleDataPipe(_source, _transformers, _target) {
    var _context, _context2, _context3;

    _classCallCheck(this, SimpleDataPipe);

    _defineProperty(this, "_source", void 0);

    _defineProperty(this, "_transformers", void 0);

    _defineProperty(this, "_target", void 0);

    _defineProperty(this, "_listeners", {
      add: bind$6(_context = this._add).call(_context, this),
      remove: bind$6(_context2 = this._remove).call(_context2, this),
      update: bind$6(_context3 = this._update).call(_context3, this)
    });

    this._source = _source;
    this._transformers = _transformers;
    this._target = _target;
  }
  /** @inheritDoc */


  _createClass(SimpleDataPipe, [{
    key: "all",
    value: function all() {
      this._target.update(this._transformItems(this._source.get()));

      return this;
    }
    /** @inheritDoc */

  }, {
    key: "start",
    value: function start() {
      this._source.on("add", this._listeners.add);

      this._source.on("remove", this._listeners.remove);

      this._source.on("update", this._listeners.update);

      return this;
    }
    /** @inheritDoc */

  }, {
    key: "stop",
    value: function stop() {
      this._source.off("add", this._listeners.add);

      this._source.off("remove", this._listeners.remove);

      this._source.off("update", this._listeners.update);

      return this;
    }
    /**
     * Apply the transformers to the items.
     *
     * @param items - The items to be transformed.
     * @returns The transformed items.
     */

  }, {
    key: "_transformItems",
    value: function _transformItems(items) {
      var _context4;

      return reduce(_context4 = this._transformers).call(_context4, function (items, transform) {
        return transform(items);
      }, items);
    }
    /**
     * Handle an add event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the added items.
     */

  }, {
    key: "_add",
    value: function _add(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.add(this._transformItems(this._source.get(payload.items)));
    }
    /**
     * Handle an update event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the updated items.
     */

  }, {
    key: "_update",
    value: function _update(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.update(this._transformItems(this._source.get(payload.items)));
    }
    /**
     * Handle a remove event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the data of the removed items.
     */

  }, {
    key: "_remove",
    value: function _remove(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.remove(this._transformItems(payload.oldData));
    }
  }]);

  return SimpleDataPipe;
}();
/**
 * Internal implementation of the pipe factory. This should be accessible
 * only through `createNewDataPipeFrom` from the outside.
 *
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */


var DataPipeUnderConstruction = /*#__PURE__*/function () {
  /**
   * Array transformers used to transform items within the pipe. This is typed
   * as any for the sake of simplicity.
   */

  /**
   * Create a new data pipe factory. This is an internal constructor that
   * should never be called from outside of this file.
   *
   * @param _source - The source data set or data view for this pipe.
   */
  function DataPipeUnderConstruction(_source) {
    _classCallCheck(this, DataPipeUnderConstruction);

    _defineProperty(this, "_source", void 0);

    _defineProperty(this, "_transformers", []);

    this._source = _source;
  }
  /**
   * Filter the items.
   *
   * @param callback - A filtering function that returns true if given item
   * should be piped and false if not.
   * @returns This factory for further configuration.
   */


  _createClass(DataPipeUnderConstruction, [{
    key: "filter",
    value: function filter$1(callback) {
      this._transformers.push(function (input) {
        return filter(input).call(input, callback);
      });

      return this;
    }
    /**
     * Map each source item to a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * corresponding mapped item.
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     * @returns This factory for further configuration.
     */

  }, {
    key: "map",
    value: function map(callback) {
      this._transformers.push(function (input) {
        return map$3(input).call(input, callback);
      });

      return this;
    }
    /**
     * Map each source item to zero or more items of a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * an array of corresponding mapped items.
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     * @returns This factory for further configuration.
     */

  }, {
    key: "flatMap",
    value: function flatMap$1(callback) {
      this._transformers.push(function (input) {
        return flatMap(input).call(input, callback);
      });

      return this;
    }
    /**
     * Connect this pipe to given data set.
     *
     * @param target - The data set that will receive the items from this pipe.
     * @returns The pipe connected between given data sets and performing
     * configured transformation on the processed items.
     */

  }, {
    key: "to",
    value: function to(target) {
      return new SimpleDataPipe(this._source, this._transformers, target);
    }
  }]);

  return DataPipeUnderConstruction;
}();
/**
 * Determine whether a value can be used as an id.
 *
 * @param value - Input value of unknown type.
 * @returns True if the value is valid id, false otherwise.
 */


function isId(value) {
  return typeof value === "string" || typeof value === "number";
}
/**
 * A queue.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */


var Queue = /*#__PURE__*/function () {
  /** Delay in milliseconds. If defined the queue will be periodically flushed. */

  /** Maximum number of entries in the queue before it will be flushed. */

  /**
   * Construct a new Queue.
   *
   * @param options - Queue configuration.
   */
  function Queue(options) {
    _classCallCheck(this, Queue);

    _defineProperty(this, "delay", void 0);

    _defineProperty(this, "max", void 0);

    _defineProperty(this, "_queue", []);

    _defineProperty(this, "_timeout", null);

    _defineProperty(this, "_extended", null);

    // options
    this.delay = null;
    this.max = Infinity;
    this.setOptions(options);
  }
  /**
   * Update the configuration of the queue.
   *
   * @param options - Queue configuration.
   */


  _createClass(Queue, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options && typeof options.delay !== "undefined") {
        this.delay = options.delay;
      }

      if (options && typeof options.max !== "undefined") {
        this.max = options.max;
      }

      this._flushIfNeeded();
    }
    /**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     * @returns The created queue.
     */

  }, {
    key: "destroy",
    value:
    /**
     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
     */
    function destroy() {
      this.flush();

      if (this._extended) {
        var object = this._extended.object;
        var methods = this._extended.methods;

        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];

          if (method.original) {
            // @TODO: better solution?
            object[method.name] = method.original;
          } else {
            // @TODO: better solution?
            delete object[method.name];
          }
        }

        this._extended = null;
      }
    }
    /**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */

  }, {
    key: "replace",
    value: function replace(object, method) {
      /* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */
      var me = this;
      var original = object[method];

      if (!original) {
        throw new Error("Method " + method + " undefined");
      }

      object[method] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // add this call to the queue
        me.queue({
          args: args,
          fn: original,
          context: this
        });
      };
    }
    /**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */

  }, {
    key: "queue",
    value: function queue(entry) {
      if (typeof entry === "function") {
        this._queue.push({
          fn: entry
        });
      } else {
        this._queue.push(entry);
      }

      this._flushIfNeeded();
    }
    /**
     * Check whether the queue needs to be flushed.
     */

  }, {
    key: "_flushIfNeeded",
    value: function _flushIfNeeded() {
      var _this = this;

      // flush when the maximum is exceeded.
      if (this._queue.length > this.max) {
        this.flush();
      } // flush after a period of inactivity when a delay is configured


      if (this._timeout != null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }

      if (this.queue.length > 0 && typeof this.delay === "number") {
        this._timeout = setTimeout$1(function () {
          _this.flush();
        }, this.delay);
      }
    }
    /**
     * Flush all queued calls
     */

  }, {
    key: "flush",
    value: function flush() {
      var _context5, _context6;

      forEach$2(_context5 = splice$1(_context6 = this._queue).call(_context6, 0)).call(_context5, function (entry) {
        entry.fn.apply(entry.context || entry.fn, entry.args || []);
      });
    }
  }], [{
    key: "extend",
    value: function extend(object, options) {
      var queue = new Queue(options);

      if (object.flush !== undefined) {
        throw new Error("Target object already has a property flush");
      }

      object.flush = function () {
        queue.flush();
      };

      var methods = [{
        name: "flush",
        original: undefined
      }];

      if (options && options.replace) {
        for (var i = 0; i < options.replace.length; i++) {
          var name = options.replace[i];
          methods.push({
            name: name,
            // @TODO: better solution?
            original: object[name]
          }); // @TODO: better solution?

          queue.replace(object, name);
        }
      }

      queue._extended = {
        object: object,
        methods: methods
      };
      return queue;
    }
  }]);

  return Queue;
}();
/**
 * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSetPart = /*#__PURE__*/function () {
  function DataSetPart() {
    _classCallCheck(this, DataSetPart);

    _defineProperty(this, "_subscribers", {
      "*": [],
      add: [],
      remove: [],
      update: []
    });

    _defineProperty(this, "subscribe", DataSetPart.prototype.on);

    _defineProperty(this, "unsubscribe", DataSetPart.prototype.off);
  }

  _createClass(DataSetPart, [{
    key: "_trigger",
    value:
    /**
     * Trigger an event
     *
     * @param event - Event name.
     * @param payload - Event payload.
     * @param senderId - Id of the sender.
     */
    function _trigger(event, payload, senderId) {
      var _context7, _context8;

      if (event === "*") {
        throw new Error("Cannot trigger event *");
      }

      forEach$2(_context7 = concat(_context8 = []).call(_context8, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers["*"]))).call(_context7, function (subscriber) {
        subscriber(event, payload, senderId != null ? senderId : null);
      });
    }
    /**
     * Subscribe to an event, add an event listener.
     *
     * @remarks Non-function callbacks are ignored.
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "on",
    value: function on(event, callback) {
      if (typeof callback === "function") {
        this._subscribers[event].push(callback);
      } // @TODO: Maybe throw for invalid callbacks?

    }
    /**
     * Unsubscribe from an event, remove an event listener.
     *
     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "off",
    value: function off(event, callback) {
      var _context9;

      this._subscribers[event] = filter(_context9 = this._subscribers[event]).call(_context9, function (subscriber) {
        return subscriber !== callback;
      });
    }
    /**
     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
     */

  }]);

  return DataSetPart;
}();
/**
 * Data stream
 *
 * @remarks
 * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
 * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
 * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
 * @typeParam Item - The item type this stream is going to work with.
 */


_Symbol$iterator = iterator;

var DataStream = /*#__PURE__*/function () {
  /**
   * Create a new data stream.
   *
   * @param pairs - The id, item pairs.
   */
  function DataStream(pairs) {
    _classCallCheck(this, DataStream);

    _defineProperty(this, "_pairs", void 0);

    this._pairs = pairs;
  }
  /**
   * Return an iterable of key, value pairs for every entry in the stream.
   */


  _createClass(DataStream, [{
    key: _Symbol$iterator,
    value:
    /*#__PURE__*/
    regenerator.mark(function value() {
      var _iterator, _step, _step$value, id, item;

      return regenerator.wrap(function value$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$7(this._pairs);
              _context10.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context10.next = 9;
                break;
              }

              _step$value = _slicedToArray(_step.value, 2), id = _step$value[0], item = _step$value[1];
              _context10.next = 7;
              return [id, item];

            case 7:
              _context10.next = 3;
              break;

            case 9:
              _context10.next = 14;
              break;

            case 11:
              _context10.prev = 11;
              _context10.t0 = _context10["catch"](1);

              _iterator.e(_context10.t0);

            case 14:
              _context10.prev = 14;

              _iterator.f();

              return _context10.finish(14);

            case 17:
            case "end":
              return _context10.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */

  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    regenerator.mark(function entries() {
      var _iterator2, _step2, _step2$value, id, item;

      return regenerator.wrap(function entries$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper$7(this._pairs);
              _context11.prev = 1;

              _iterator2.s();

            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context11.next = 9;
                break;
              }

              _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], item = _step2$value[1];
              _context11.next = 7;
              return [id, item];

            case 7:
              _context11.next = 3;
              break;

            case 9:
              _context11.next = 14;
              break;

            case 11:
              _context11.prev = 11;
              _context11.t0 = _context11["catch"](1);

              _iterator2.e(_context11.t0);

            case 14:
              _context11.prev = 14;

              _iterator2.f();

              return _context11.finish(14);

            case 17:
            case "end":
              return _context11.stop();
          }
        }
      }, entries, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of keys in the stream.
     */

  }, {
    key: "keys",
    value:
    /*#__PURE__*/
    regenerator.mark(function keys() {
      var _iterator3, _step3, _step3$value, id;

      return regenerator.wrap(function keys$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper$7(this._pairs);
              _context12.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context12.next = 9;
                break;
              }

              _step3$value = _slicedToArray(_step3.value, 1), id = _step3$value[0];
              _context12.next = 7;
              return id;

            case 7:
              _context12.next = 3;
              break;

            case 9:
              _context12.next = 14;
              break;

            case 11:
              _context12.prev = 11;
              _context12.t0 = _context12["catch"](1);

              _iterator3.e(_context12.t0);

            case 14:
              _context12.prev = 14;

              _iterator3.f();

              return _context12.finish(14);

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, keys, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of values in the stream.
     */

  }, {
    key: "values",
    value:
    /*#__PURE__*/
    regenerator.mark(function values() {
      var _iterator4, _step4, _step4$value, item;

      return regenerator.wrap(function values$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper$7(this._pairs);
              _context13.prev = 1;

              _iterator4.s();

            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context13.next = 9;
                break;
              }

              _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];
              _context13.next = 7;
              return item;

            case 7:
              _context13.next = 3;
              break;

            case 9:
              _context13.next = 14;
              break;

            case 11:
              _context13.prev = 11;
              _context13.t0 = _context13["catch"](1);

              _iterator4.e(_context13.t0);

            case 14:
              _context13.prev = 14;

              _iterator4.f();

              return _context13.finish(14);

            case 17:
            case "end":
              return _context13.stop();
          }
        }
      }, values, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an array containing all the ids in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all ids from this stream.
     */

  }, {
    key: "toIdArray",
    value: function toIdArray() {
      var _context14;

      return map$3(_context14 = _toConsumableArray(this._pairs)).call(_context14, function (pair) {
        return pair[0];
      });
    }
    /**
     * Return an array containing all the items in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all items from this stream.
     */

  }, {
    key: "toItemArray",
    value: function toItemArray() {
      var _context15;

      return map$3(_context15 = _toConsumableArray(this._pairs)).call(_context15, function (pair) {
        return pair[1];
      });
    }
    /**
     * Return an array containing all the entries in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all entries from this stream.
     */

  }, {
    key: "toEntryArray",
    value: function toEntryArray() {
      return _toConsumableArray(this._pairs);
    }
    /**
     * Return an object map containing all the items in this stream accessible by ids.
     *
     * @remarks
     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
     * @returns The object map of all id → item pairs from this stream.
     */

  }, {
    key: "toObjectMap",
    value: function toObjectMap() {
      var map = create$5(null);

      var _iterator5 = _createForOfIteratorHelper$7(this._pairs),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              id = _step5$value[0],
              item = _step5$value[1];

          map[id] = item;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return map;
    }
    /**
     * Return a map containing all the items in this stream accessible by ids.
     *
     * @returns The map of all id → item pairs from this stream.
     */

  }, {
    key: "toMap",
    value: function toMap() {
      return new map(this._pairs);
    }
    /**
     * Return a set containing all the (unique) ids in this stream.
     *
     * @returns The set of all ids from this stream.
     */

  }, {
    key: "toIdSet",
    value: function toIdSet() {
      return new set(this.toIdArray());
    }
    /**
     * Return a set containing all the (unique) items in this stream.
     *
     * @returns The set of all items from this stream.
     */

  }, {
    key: "toItemSet",
    value: function toItemSet() {
      return new set(this.toItemArray());
    }
    /**
     * Cache the items from this stream.
     *
     * @remarks
     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
     * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
     *
     * ## Example
     * ```javascript
     * const ds = new DataSet([…])
     *
     * const cachedStream = ds.stream()
     *   .filter(…)
     *   .sort(…)
     *   .map(…)
     *   .cached(…) // Data are fetched, processed and cached here.
     *
     * ds.clear()
     * chachedStream // Still has all the items.
     * ```
     * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
     */

  }, {
    key: "cache",
    value: function cache() {
      return new DataStream(_toConsumableArray(this._pairs));
    }
    /**
     * Get the distinct values of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @typeParam T - The type of the distinct value.
     * @returns A set of all distinct properties.
     */

  }, {
    key: "distinct",
    value: function distinct(callback) {
      var set$1 = new set();

      var _iterator6 = _createForOfIteratorHelper$7(this._pairs),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _step6$value = _slicedToArray(_step6.value, 2),
              id = _step6$value[0],
              item = _step6$value[1];

          set$1.add(callback(item, id));
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return set$1;
    }
    /**
     * Filter the items of the stream.
     *
     * @param callback - The function that decides whether an item will be included.
     * @returns A new data stream with the filtered items.
     */

  }, {
    key: "filter",
    value: function filter(callback) {
      var pairs = this._pairs;
      return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
        var _iterator7, _step7, _step7$value, id, item;

        return regenerator.wrap(function _callee$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _iterator7 = _createForOfIteratorHelper$7(pairs);
                _context16.prev = 1;

                _iterator7.s();

              case 3:
                if ((_step7 = _iterator7.n()).done) {
                  _context16.next = 10;
                  break;
                }

                _step7$value = _slicedToArray(_step7.value, 2), id = _step7$value[0], item = _step7$value[1];

                if (!callback(item, id)) {
                  _context16.next = 8;
                  break;
                }

                _context16.next = 8;
                return [id, item];

              case 8:
                _context16.next = 3;
                break;

              case 10:
                _context16.next = 15;
                break;

              case 12:
                _context16.prev = 12;
                _context16.t0 = _context16["catch"](1);

                _iterator7.e(_context16.t0);

              case 15:
                _context16.prev = 15;

                _iterator7.f();

                return _context16.finish(15);

              case 18:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee, null, [[1, 12, 15, 18]]);
      })));
    }
    /**
     * Execute a callback for each item of the stream.
     *
     * @param callback - The function that will be invoked for each item.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _iterator8 = _createForOfIteratorHelper$7(this._pairs),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _step8$value = _slicedToArray(_step8.value, 2),
              id = _step8$value[0],
              item = _step8$value[1];

          callback(item, id);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     * Map the items into a different type.
     *
     * @param callback - The function that does the conversion.
     * @typeParam Mapped - The type of the item after mapping.
     * @returns A new data stream with the mapped items.
     */

  }, {
    key: "map",
    value: function map(callback) {
      var pairs = this._pairs;
      return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee2() {
        var _iterator9, _step9, _step9$value, id, item;

        return regenerator.wrap(function _callee2$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _iterator9 = _createForOfIteratorHelper$7(pairs);
                _context17.prev = 1;

                _iterator9.s();

              case 3:
                if ((_step9 = _iterator9.n()).done) {
                  _context17.next = 9;
                  break;
                }

                _step9$value = _slicedToArray(_step9.value, 2), id = _step9$value[0], item = _step9$value[1];
                _context17.next = 7;
                return [id, callback(item, id)];

              case 7:
                _context17.next = 3;
                break;

              case 9:
                _context17.next = 14;
                break;

              case 11:
                _context17.prev = 11;
                _context17.t0 = _context17["catch"](1);

                _iterator9.e(_context17.t0);

              case 14:
                _context17.prev = 14;

                _iterator9.f();

                return _context17.finish(14);

              case 17:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee2, null, [[1, 11, 14, 17]]);
      })));
    }
    /**
     * Get the item with the maximum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the maximum if found otherwise null.
     */

  }, {
    key: "max",
    value: function max(callback) {
      var iter = getIterator(this._pairs);

      var curr = iter.next();

      if (curr.done) {
        return null;
      }

      var maxItem = curr.value[1];
      var maxValue = callback(curr.value[1], curr.value[0]);

      while (!(curr = iter.next()).done) {
        var _curr$value = _slicedToArray(curr.value, 2),
            id = _curr$value[0],
            item = _curr$value[1];

        var _value = callback(item, id);

        if (_value > maxValue) {
          maxValue = _value;
          maxItem = item;
        }
      }

      return maxItem;
    }
    /**
     * Get the item with the minimum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the minimum if found otherwise null.
     */

  }, {
    key: "min",
    value: function min(callback) {
      var iter = getIterator(this._pairs);

      var curr = iter.next();

      if (curr.done) {
        return null;
      }

      var minItem = curr.value[1];
      var minValue = callback(curr.value[1], curr.value[0]);

      while (!(curr = iter.next()).done) {
        var _curr$value2 = _slicedToArray(curr.value, 2),
            id = _curr$value2[0],
            item = _curr$value2[1];

        var _value2 = callback(item, id);

        if (_value2 < minValue) {
          minValue = _value2;
          minItem = item;
        }
      }

      return minItem;
    }
    /**
     * Reduce the items into a single value.
     *
     * @param callback - The function that does the reduction.
     * @param accumulator - The initial value of the accumulator.
     * @typeParam T - The type of the accumulated value.
     * @returns The reduced value.
     */

  }, {
    key: "reduce",
    value: function reduce(callback, accumulator) {
      var _iterator10 = _createForOfIteratorHelper$7(this._pairs),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _step10$value = _slicedToArray(_step10.value, 2),
              id = _step10$value[0],
              item = _step10$value[1];

          accumulator = callback(accumulator, item, id);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      return accumulator;
    }
    /**
     * Sort the items.
     *
     * @param callback - Item comparator.
     * @returns A new stream with sorted items.
     */

  }, {
    key: "sort",
    value: function sort$1(callback) {
      var _this2 = this;

      return new DataStream(_defineProperty({}, iterator, function () {
        var _context18;

        return getIterator(sort(_context18 = _toConsumableArray(_this2._pairs)).call(_context18, function (_ref, _ref2) {
          var _ref3 = _slicedToArray(_ref, 2),
              idA = _ref3[0],
              itemA = _ref3[1];

          var _ref4 = _slicedToArray(_ref2, 2),
              idB = _ref4[0],
              itemB = _ref4[1];

          return callback(itemA, itemB, idA, idB);
        }));
      }));
    }
  }]);

  return DataStream;
}();
/**
 * Add an id to given item if it doesn't have one already.
 *
 * @remarks
 * The item will be modified.
 * @param item - The item that will have an id after a call to this function.
 * @param idProp - The key of the id property.
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 * @returns true
 */


function ensureFullItem(item, idProp) {
  if (item[idProp] == null) {
    // generate an id
    item[idProp] = v4();
  }

  return item;
}
/**
 * # DataSet
 *
 * Vis.js comes with a flexible DataSet, which can be used to hold and
 * manipulate unstructured data and listen for changes in the data. The DataSet
 * is key/value based. Data items can be added, updated and removed from the
 * DataSet, and one can subscribe to changes in the DataSet. The data in the
 * DataSet can be filtered and ordered. Data can be normalized when appending it
 * to the DataSet as well.
 *
 * ## Example
 *
 * The following example shows how to use a DataSet.
 *
 * ```javascript
 * // create a DataSet
 * var options = {};
 * var data = new vis.DataSet(options);
 *
 * // add items
 * // note that the data items can contain different properties and data formats
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // subscribe to any change in the DataSet
 * data.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an existing item
 * data.update({id: 2, group: 1});
 *
 * // remove an item
 * data.remove(4);
 *
 * // get all ids
 * var ids = data.getIds();
 * console.log('ids', ids);
 *
 * // get a specific item
 * var item1 = data.get(1);
 * console.log('item1', item1);
 *
 * // retrieve a filtered subset of the data
 * var items = data.get({
 *   filter: function (item) {
 *     return item.group == 1;
 *   }
 * });
 * console.log('filtered items', items);
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSet = /*#__PURE__*/function (_DataSetPart) {
  _inherits(DataSet, _DataSetPart);

  var _super = _createSuper$t(DataSet);

  /**
   * Construct a new DataSet.
   *
   * @param data - Initial data or options.
   * @param options - Options (type error if data is also options).
   */
  function DataSet(data, options) {
    var _this3;

    _classCallCheck(this, DataSet);

    _this3 = _super.call(this); // correctly read optional arguments

    _defineProperty(_assertThisInitialized(_this3), "flush", void 0);

    _defineProperty(_assertThisInitialized(_this3), "length", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_options", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_data", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_idProp", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_queue", null);

    if (data && !isArray$2(data)) {
      options = data;
      data = [];
    }

    _this3._options = options || {};
    _this3._data = new map(); // map with data indexed by id

    _this3.length = 0; // number of items in the DataSet

    _this3._idProp = _this3._options.fieldId || "id"; // name of the field containing id
    // add initial data when provided

    if (data && data.length) {
      _this3.add(data);
    }

    _this3.setOptions(options);

    return _this3;
  }
  /**
   * Set new options.
   *
   * @param options - The new options.
   */


  _createClass(DataSet, [{
    key: "idProp",
    get:
    /** Flush all queued calls. */

    /** @inheritDoc */

    /** @inheritDoc */
    function get() {
      return this._idProp;
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options && options.queue !== undefined) {
        if (options.queue === false) {
          // delete queue if loaded
          if (this._queue) {
            this._queue.destroy();

            this._queue = null;
          }
        } else {
          // create queue and update its options
          if (!this._queue) {
            this._queue = Queue.extend(this, {
              replace: ["add", "update", "remove"]
            });
          }

          if (options.queue && _typeof(options.queue) === "object") {
            this._queue.setOptions(options.queue);
          }
        }
      }
    }
    /**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     * @throws When an item with the same id as any of the added items already exists.
     */

  }, {
    key: "add",
    value: function add(data, senderId) {
      var _this4 = this;

      var addedIds = [];
      var id;

      if (isArray$2(data)) {
        // Array
        var idsToAdd = map$3(data).call(data, function (d) {
          return d[_this4._idProp];
        });

        if (some(idsToAdd).call(idsToAdd, function (id) {
          return _this4._data.has(id);
        })) {
          throw new Error("A duplicate id was found in the parameter array.");
        }

        for (var i = 0, len = data.length; i < len; i++) {
          id = this._addItem(data[i]);
          addedIds.push(id);
        }
      } else if (data && _typeof(data) === "object") {
        // Single item
        id = this._addItem(data);
        addedIds.push(id);
      } else {
        throw new Error("Unknown dataType");
      }

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      return addedIds;
    }
    /**
     * Update existing items. When an item does not exist, it will be created.
     *
     * @remarks
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * ## Warning for TypeScript users
     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     * @throws When the supplied data is neither an item nor an array of items.
     */

  }, {
    key: "update",
    value: function update(data, senderId) {
      var _this5 = this;

      var addedIds = [];
      var updatedIds = [];
      var oldData = [];
      var updatedData = [];
      var idProp = this._idProp;

      var addOrUpdate = function addOrUpdate(item) {
        var origId = item[idProp];

        if (origId != null && _this5._data.has(origId)) {
          var fullItem = item; // it has an id, therefore it is a fullitem

          var oldItem = assign$2({}, _this5._data.get(origId)); // update item


          var id = _this5._updateItem(fullItem);

          updatedIds.push(id);
          updatedData.push(fullItem);
          oldData.push(oldItem);
        } else {
          // add new item
          var _id = _this5._addItem(item);

          addedIds.push(_id);
        }
      };

      if (isArray$2(data)) {
        // Array
        for (var i = 0, len = data.length; i < len; i++) {
          if (data[i] && _typeof(data[i]) === "object") {
            addOrUpdate(data[i]);
          } else {
            console.warn("Ignoring input item, which is not an object at index " + i);
          }
        }
      } else if (data && _typeof(data) === "object") {
        // Single item
        addOrUpdate(data);
      } else {
        throw new Error("Unknown dataType");
      }

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        var props = {
          items: updatedIds,
          oldData: oldData,
          data: updatedData
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger("update", props, senderId);
      }

      return concat(addedIds).call(addedIds, updatedIds);
    }
    /**
     * Update existing items. When an item does not exist, an error will be thrown.
     *
     * @remarks
     * The provided properties will be deeply merged into the existing item.
     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
     *
     * After the items are updated, the DataSet will trigger an event `update`.
     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' },
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' }, // works
     *   // { id: 4, text: 'item 4 (new)' }, // would throw
     *   // { text: 'item 4 (new)' }, // would also throw
     * ])
     *
     * console.log(ids) // [2]
     * ```
     * @param data - Updates (the id and optionally other props) to the items in this data set.
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the updated items.
     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
     */

  }, {
    key: "updateOnly",
    value: function updateOnly(data, senderId) {
      var _context19,
          _this6 = this;

      if (!isArray$2(data)) {
        data = [data];
      }

      var updateEventData = map$3(_context19 = map$3(data).call(data, function (update) {
        var oldData = _this6._data.get(update[_this6._idProp]);

        if (oldData == null) {
          throw new Error("Updating non-existent items is not allowed.");
        }

        return {
          oldData: oldData,
          update: update
        };
      })).call(_context19, function (_ref5) {
        var oldData = _ref5.oldData,
            update = _ref5.update;
        var id = oldData[_this6._idProp];
        var updatedData = pureDeepObjectAssign(oldData, update);

        _this6._data.set(id, updatedData);

        return {
          id: id,
          oldData: oldData,
          updatedData: updatedData
        };
      });

      if (updateEventData.length) {
        var props = {
          items: map$3(updateEventData).call(updateEventData, function (value) {
            return value.id;
          }),
          oldData: map$3(updateEventData).call(updateEventData, function (value) {
            return value.oldData;
          }),
          data: map$3(updateEventData).call(updateEventData, function (value) {
            return value.updatedData;
          })
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger("update", props, senderId);

        return props.items;
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "get",
    value: function get(first, second) {
      // @TODO: Woudn't it be better to split this into multiple methods?
      // parse the arguments
      var id = undefined;
      var ids = undefined;
      var options = undefined;

      if (isId(first)) {
        // get(id [, options])
        id = first;
        options = second;
      } else if (isArray$2(first)) {
        // get(ids [, options])
        ids = first;
        options = second;
      } else {
        // get([, options])
        options = first;
      } // determine the return type


      var returnType = options && options.returnType === "Object" ? "Object" : "Array"; // @TODO: WTF is this? Or am I missing something?
      // var returnType
      // if (options && options.returnType) {
      //   var allowedValues = ['Array', 'Object']
      //   returnType =
      //     allowedValues.indexOf(options.returnType) == -1
      //       ? 'Array'
      //       : options.returnType
      // } else {
      //   returnType = 'Array'
      // }
      // build options

      var filter$1 = options && filter(options);

      var items = [];
      var item = undefined;
      var itemIds = undefined;
      var itemId = undefined; // convert items

      if (id != null) {
        // return a single item
        item = this._data.get(id);

        if (item && filter$1 && !filter$1(item)) {
          item = undefined;
        }
      } else if (ids != null) {
        // return a subset of items
        for (var i = 0, len = ids.length; i < len; i++) {
          item = this._data.get(ids[i]);

          if (item != null && (!filter$1 || filter$1(item))) {
            items.push(item);
          }
        }
      } else {
        var _context20;

        // return all items
        itemIds = _toConsumableArray(keys(_context20 = this._data).call(_context20));

        for (var _i = 0, _len2 = itemIds.length; _i < _len2; _i++) {
          itemId = itemIds[_i];
          item = this._data.get(itemId);

          if (item != null && (!filter$1 || filter$1(item))) {
            items.push(item);
          }
        }
      } // order the results


      if (options && options.order && id == undefined) {
        this._sort(items, options.order);
      } // filter fields of the items


      if (options && options.fields) {
        var fields = options.fields;

        if (id != undefined && item != null) {
          item = this._filterFields(item, fields);
        } else {
          for (var _i2 = 0, _len3 = items.length; _i2 < _len3; _i2++) {
            items[_i2] = this._filterFields(items[_i2], fields);
          }
        }
      } // return the results


      if (returnType == "Object") {
        var result = {};

        for (var _i3 = 0, _len4 = items.length; _i3 < _len4; _i3++) {
          var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?
          // result[resultant.id] = resultant

          var _id2 = resultant[this._idProp];
          result[_id2] = resultant;
        }

        return result;
      } else {
        if (id != null) {
          var _item;

          // a single item
          return (_item = item) !== null && _item !== void 0 ? _item : null;
        } else {
          // just return our array
          return items;
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      var data = this._data;

      var filter$1 = options && filter(options);

      var order = options && options.order;

      var itemIds = _toConsumableArray(keys(data).call(data));

      var ids = [];

      if (filter$1) {
        // get filtered items
        if (order) {
          // create ordered list
          var items = [];

          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id = itemIds[i];

            var item = this._data.get(id);

            if (item != null && filter$1(item)) {
              items.push(item);
            }
          }

          this._sort(items, order);

          for (var _i4 = 0, _len5 = items.length; _i4 < _len5; _i4++) {
            ids.push(items[_i4][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i5 = 0, _len6 = itemIds.length; _i5 < _len6; _i5++) {
            var _id3 = itemIds[_i5];

            var _item2 = this._data.get(_id3);

            if (_item2 != null && filter$1(_item2)) {
              ids.push(_item2[this._idProp]);
            }
          }
        }
      } else {
        // get all items
        if (order) {
          // create an ordered list
          var _items = [];

          for (var _i6 = 0, _len7 = itemIds.length; _i6 < _len7; _i6++) {
            var _id4 = itemIds[_i6];

            _items.push(data.get(_id4));
          }

          this._sort(_items, order);

          for (var _i7 = 0, _len8 = _items.length; _i7 < _len8; _i7++) {
            ids.push(_items[_i7][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i8 = 0, _len9 = itemIds.length; _i8 < _len9; _i8++) {
            var _id5 = itemIds[_i8];

            var _item3 = data.get(_id5);

            if (_item3 != null) {
              ids.push(_item3[this._idProp]);
            }
          }
        }
      }

      return ids;
    }
    /** @inheritDoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this;
    }
    /** @inheritDoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      var filter$1 = options && filter(options);

      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data));

      if (options && options.order) {
        // execute forEach on ordered list
        var items = this.get(options);

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var id = item[this._idProp];
          callback(item, id);
        }
      } else {
        // unordered
        for (var _i9 = 0, _len10 = itemIds.length; _i9 < _len10; _i9++) {
          var _id6 = itemIds[_i9];

          var _item4 = this._data.get(_id6);

          if (_item4 != null && (!filter$1 || filter$1(_item4))) {
            callback(_item4, _id6);
          }
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      var filter$1 = options && filter(options);

      var mappedItems = [];
      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data)); // convert and filter items


      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];

        var item = this._data.get(id);

        if (item != null && (!filter$1 || filter$1(item))) {
          mappedItems.push(callback(item, id));
        }
      } // order items


      if (options && options.order) {
        this._sort(mappedItems, options.order);
      }

      return mappedItems;
    }
    /**
     * Filter the fields of an item.
     *
     * @param item - The item whose fields should be filtered.
     * @param fields - The names of the fields that will be kept.
     * @typeParam K - Field name type.
     * @returns The item without any additional fields.
     */

  }, {
    key: "_filterFields",
    value: function _filterFields(item, fields) {
      var _context21;

      if (!item) {
        // item is null
        return item;
      }

      return reduce(_context21 = isArray$2(fields) ? // Use the supplied array
      fields : // Use the keys of the supplied object
      keys$4(fields)).call(_context21, function (filteredItem, field) {
        filteredItem[field] = item[field];
        return filteredItem;
      }, {});
    }
    /**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     * @typeParam T - The type of the items in the items array.
     */

  }, {
    key: "_sort",
    value: function _sort(items, order) {
      if (typeof order === "string") {
        // order by provided field name
        var name = order; // field name

        sort(items).call(items, function (a, b) {
          // @TODO: How to treat missing properties?
          var av = a[name];
          var bv = b[name];
          return av > bv ? 1 : av < bv ? -1 : 0;
        });
      } else if (typeof order === "function") {
        // order by sort function
        sort(items).call(items, order);
      } else {
        // TODO: extend order by an Object {field:string, direction:string}
        //       where direction can be 'asc' or 'desc'
        throw new TypeError("Order must be a function or a string");
      }
    }
    /**
     * Remove an item or multiple items by “reference” (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     * @returns The ids of the removed items.
     */

  }, {
    key: "remove",
    value: function remove(id, senderId) {
      var removedIds = [];
      var removedItems = []; // force everything to be an array for simplicity

      var ids = isArray$2(id) ? id : [id];

      for (var i = 0, len = ids.length; i < len; i++) {
        var item = this._remove(ids[i]);

        if (item) {
          var itemId = item[this._idProp];

          if (itemId != null) {
            removedIds.push(itemId);
            removedItems.push(item);
          }
        }
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }

      return removedIds;
    }
    /**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     * @returns The removed item if removed, null otherwise.
     */

  }, {
    key: "_remove",
    value: function _remove(id) {
      // @TODO: It origianlly returned the item although the docs say id.
      // The code expects the item, so probably an error in the docs.
      var ident; // confirm the id to use based on the args type

      if (isId(id)) {
        ident = id;
      } else if (id && _typeof(id) === "object") {
        ident = id[this._idProp]; // look for the identifier field using ._idProp
      } // do the removing if the item is found


      if (ident != null && this._data.has(ident)) {
        var item = this._data.get(ident) || null;

        this._data.delete(ident);

        --this.length;
        return item;
      }

      return null;
    }
    /**
     * Clear the entire data set.
     *
     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     * @returns removedIds - The ids of all removed items.
     */

  }, {
    key: "clear",
    value: function clear(senderId) {
      var _context22;

      var ids = _toConsumableArray(keys(_context22 = this._data).call(_context22));

      var items = [];

      for (var i = 0, len = ids.length; i < len; i++) {
        items.push(this._data.get(ids[i]));
      }

      this._data.clear();

      this.length = 0;

      this._trigger("remove", {
        items: ids,
        oldData: items
      }, senderId);

      return ids;
    }
    /**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     * @returns Item containing max value, or null if no items.
     */

  }, {
    key: "max",
    value: function max(field) {
      var _context23;

      var max = null;
      var maxField = null;

      var _iterator11 = _createForOfIteratorHelper$7(values(_context23 = this._data).call(_context23)),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var item = _step11.value;
          var itemField = item[field];

          if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
            max = item;
            maxField = itemField;
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return max || null;
    }
    /**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     * @returns Item containing min value, or null if no items.
     */

  }, {
    key: "min",
    value: function min(field) {
      var _context24;

      var min = null;
      var minField = null;

      var _iterator12 = _createForOfIteratorHelper$7(values(_context24 = this._data).call(_context24)),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var item = _step12.value;
          var itemField = item[field];

          if (typeof itemField === "number" && (minField == null || itemField < minField)) {
            min = item;
            minField = itemField;
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      return min || null;
    }
    /**
     * Find all distinct values of a specified field
     *
     * @param prop - The property name whose distinct values should be returned.
     * @returns Unordered array containing all distinct values. Items without specified property are ignored.
     */

  }, {
    key: "distinct",
    value: function distinct(prop) {
      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data));

      var values = [];
      var count = 0;

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];
        var item = data.get(id);
        var _value3 = item[prop];
        var exists = false;

        for (var j = 0; j < count; j++) {
          if (values[j] == _value3) {
            exists = true;
            break;
          }
        }

        if (!exists && _value3 !== undefined) {
          values[count] = _value3;
          count++;
        }
      }

      return values;
    }
    /**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     * @returns Added item's id. An id is generated when it is not present in the item.
     */

  }, {
    key: "_addItem",
    value: function _addItem(item) {
      var fullItem = ensureFullItem(item, this._idProp);
      var id = fullItem[this._idProp]; // check whether this id is already taken

      if (this._data.has(id)) {
        // item already exists
        throw new Error("Cannot add item: item with id " + id + " already exists");
      }

      this._data.set(id, fullItem);

      ++this.length;
      return id;
    }
    /**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param update - The new item
     * @returns The id of the updated item.
     */

  }, {
    key: "_updateItem",
    value: function _updateItem(update) {
      var id = update[this._idProp];

      if (id == null) {
        throw new Error("Cannot update item: item has no id (item: " + stringify$1(update) + ")");
      }

      var item = this._data.get(id);

      if (!item) {
        // item doesn't exist
        throw new Error("Cannot update item: no item with id " + id + " found");
      }

      this._data.set(id, _objectSpread$4(_objectSpread$4({}, item), update));

      return id;
    }
    /** @inheritDoc */

  }, {
    key: "stream",
    value: function stream(ids) {
      if (ids) {
        var data = this._data;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee3() {
          var _iterator13, _step13, id, item;

          return regenerator.wrap(function _callee3$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  _iterator13 = _createForOfIteratorHelper$7(ids);
                  _context25.prev = 1;

                  _iterator13.s();

                case 3:
                  if ((_step13 = _iterator13.n()).done) {
                    _context25.next = 11;
                    break;
                  }

                  id = _step13.value;
                  item = data.get(id);

                  if (!(item != null)) {
                    _context25.next = 9;
                    break;
                  }

                  _context25.next = 9;
                  return [id, item];

                case 9:
                  _context25.next = 3;
                  break;

                case 11:
                  _context25.next = 16;
                  break;

                case 13:
                  _context25.prev = 13;
                  _context25.t0 = _context25["catch"](1);

                  _iterator13.e(_context25.t0);

                case 16:
                  _context25.prev = 16;

                  _iterator13.f();

                  return _context25.finish(16);

                case 19:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee3, null, [[1, 13, 16, 19]]);
        })));
      } else {
        var _context26;

        return new DataStream(_defineProperty({}, iterator, bind$6(_context26 = entries(this._data)).call(_context26, this._data)));
      }
    }
  }]);

  return DataSet;
}(DataSetPart);
/**
 * DataView
 *
 * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
 *
 * ## Example
 * ```javascript
 * // create a DataSet
 * var data = new vis.DataSet();
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // create a DataView
 * // the view will only contain items having a property group with value 1,
 * // and will only output fields id, text, and date.
 * var view = new vis.DataView(data, {
 *   filter: function (item) {
 *     return (item.group == 1);
 *   },
 *   fields: ['id', 'text', 'date']
 * });
 *
 * // subscribe to any change in the DataView
 * view.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an item in the data set
 * data.update({id: 2, group: 1});
 *
 * // get all ids in the view
 * var ids = view.getIds();
 * console.log('ids', ids); // will output [1, 2]
 *
 * // get all items in the view
 * var items = view.get();
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataView = /*#__PURE__*/function (_DataSetPart2) {
  _inherits(DataView, _DataSetPart2);

  var _super2 = _createSuper$t(DataView);

  /**
   * Create a DataView.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @param options - Options to configure this data view.
   */
  function DataView(data, options) {
    var _context27;

    var _this7;

    _classCallCheck(this, DataView);

    _this7 = _super2.call(this);

    _defineProperty(_assertThisInitialized(_this7), "length", 0);

    _defineProperty(_assertThisInitialized(_this7), "_listener", void 0);

    _defineProperty(_assertThisInitialized(_this7), "_data", void 0);

    _defineProperty(_assertThisInitialized(_this7), "_ids", new set());

    _defineProperty(_assertThisInitialized(_this7), "_options", void 0);

    _this7._options = options || {};
    _this7._listener = bind$6(_context27 = _this7._onEvent).call(_context27, _assertThisInitialized(_this7));

    _this7.setData(data);

    return _this7;
  } // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @remarks
   * Note that when the data view is bound to a data set it won't be garbage
   * collected unless the data set is too. Use `dataView.setData(null)` or
   * `dataView.dispose()` to enable garbage collection before you lose the last
   * reference.
   */


  _createClass(DataView, [{
    key: "idProp",
    get:
    /** @inheritDoc */

    /** @inheritDoc */
    function get() {
      return this.getDataSet().idProp;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      if (this._data) {
        // unsubscribe from current dataset
        if (this._data.off) {
          this._data.off("*", this._listener);
        } // trigger a remove of all items in memory


        var ids = this._data.getIds({
          filter: filter(this._options)
        });

        var items = this._data.get(ids);

        this._ids.clear();

        this.length = 0;

        this._trigger("remove", {
          items: ids,
          oldData: items
        });
      }

      if (data != null) {
        this._data = data; // trigger an add of all added items

        var _ids = this._data.getIds({
          filter: filter(this._options)
        });

        for (var i = 0, len = _ids.length; i < len; i++) {
          var id = _ids[i];

          this._ids.add(id);
        }

        this.length = _ids.length;

        this._trigger("add", {
          items: _ids
        });
      } else {
        this._data = new DataSet();
      } // subscribe to new dataset


      if (this._data.on) {
        this._data.on("*", this._listener);
      }
    }
    /**
     * Refresh the DataView.
     * Useful when the DataView has a filter function containing a variable parameter.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var ids = this._data.getIds({
        filter: filter(this._options)
      });

      var oldIds = _toConsumableArray(this._ids);

      var newIds = {};
      var addedIds = [];
      var removedIds = [];
      var removedItems = []; // check for additions

      for (var i = 0, len = ids.length; i < len; i++) {
        var id = ids[i];
        newIds[id] = true;

        if (!this._ids.has(id)) {
          addedIds.push(id);

          this._ids.add(id);
        }
      } // check for removals


      for (var _i10 = 0, _len11 = oldIds.length; _i10 < _len11; _i10++) {
        var _id7 = oldIds[_i10];

        var item = this._data.get(_id7);

        if (item == null) {
          // @TODO: Investigate.
          // Doesn't happen during tests or examples.
          // Is it really impossible or could it eventually happen?
          // How to handle it if it does? The types guarantee non-nullable items.
          console.error("If you see this, report it please.");
        } else if (!newIds[_id7]) {
          removedIds.push(_id7);
          removedItems.push(item);

          this._ids.delete(_id7);
        }
      }

      this.length += addedIds.length - removedIds.length; // trigger events

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        });
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        });
      }
    }
    /** @inheritDoc */

  }, {
    key: "get",
    value: function get(first, second) {
      if (this._data == null) {
        return null;
      } // parse the arguments


      var ids = null;
      var options;

      if (isId(first) || isArray$2(first)) {
        ids = first;
        options = second;
      } else {
        options = first;
      } // extend the options with the default options and provided options


      var viewOptions = assign$2({}, this._options, options); // create a combined filter method when needed


      var thisFilter = filter(this._options);

      var optionsFilter = options && filter(options);

      if (thisFilter && optionsFilter) {
        viewOptions.filter = function (item) {
          return thisFilter(item) && optionsFilter(item);
        };
      }

      if (ids == null) {
        return this._data.get(viewOptions);
      } else {
        return this._data.get(ids, viewOptions);
      }
    }
    /** @inheritDoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      if (this._data.length) {
        var defaultFilter = filter(this._options);

        var optionsFilter = options != null ? filter(options) : null;
        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        return this._data.getIds({
          filter: filter$1,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      if (this._data) {
        var _context28;

        var defaultFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        forEach$2(_context28 = this._data).call(_context28, callback, {
          filter: filter$1,
          order: options && options.order
        });
      }
    }
    /** @inheritDoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      if (this._data) {
        var _context29;

        var defaultFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        return map$3(_context29 = this._data).call(_context29, callback, {
          filter: filter$1,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this._data.getDataSet();
    }
    /** @inheritDoc */

  }, {
    key: "stream",
    value: function stream(ids) {
      var _context30;

      return this._data.stream(ids || _defineProperty({}, iterator, bind$6(_context30 = keys(this._ids)).call(_context30, this._ids)));
    }
    /**
     * Render the instance unusable prior to garbage collection.
     *
     * @remarks
     * The intention of this method is to help discover scenarios where the data
     * view is being used when the programmer thinks it has been garbage collected
     * already. It's stricter version of `dataView.setData(null)`.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var _this$_data;

      if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {
        this._data.off("*", this._listener);
      }

      var message = "This data view has already been disposed of.";
      var replacement = {
        get: function get() {
          throw new Error(message);
        },
        set: function set() {
          throw new Error(message);
        },
        configurable: false
      };

      var _iterator14 = _createForOfIteratorHelper$7(ownKeys$5(DataView.prototype)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var key = _step14.value;

          defineProperty$6(this, key, replacement);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    /**
     * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
     *
     * @param event - The name of the event.
     * @param params - Parameters of the event.
     * @param senderId - Id supplied by the sender.
     */

  }, {
    key: "_onEvent",
    value: function _onEvent(event, params, senderId) {
      if (!params || !params.items || !this._data) {
        return;
      }

      var ids = params.items;
      var addedIds = [];
      var updatedIds = [];
      var removedIds = [];
      var oldItems = [];
      var updatedItems = [];
      var removedItems = [];

      switch (event) {
        case "add":
          // filter the ids of the added items
          for (var i = 0, len = ids.length; i < len; i++) {
            var id = ids[i];
            var item = this.get(id);

            if (item) {
              this._ids.add(id);

              addedIds.push(id);
            }
          }

          break;

        case "update":
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (var _i11 = 0, _len12 = ids.length; _i11 < _len12; _i11++) {
            var _id8 = ids[_i11];

            var _item5 = this.get(_id8);

            if (_item5) {
              if (this._ids.has(_id8)) {
                updatedIds.push(_id8);
                updatedItems.push(params.data[_i11]);
                oldItems.push(params.oldData[_i11]);
              } else {
                this._ids.add(_id8);

                addedIds.push(_id8);
              }
            } else {
              if (this._ids.has(_id8)) {
                this._ids.delete(_id8);

                removedIds.push(_id8);
                removedItems.push(params.oldData[_i11]);
              }
            }
          }

          break;

        case "remove":
          // filter the ids of the removed items
          for (var _i12 = 0, _len13 = ids.length; _i12 < _len13; _i12++) {
            var _id9 = ids[_i12];

            if (this._ids.has(_id9)) {
              this._ids.delete(_id9);

              removedIds.push(_id9);
              removedItems.push(params.oldData[_i12]);
            }
          }

          break;
      }

      this.length += addedIds.length - removedIds.length;

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        this._trigger("update", {
          items: updatedIds,
          oldData: oldItems,
          data: updatedItems
        }, senderId);
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }
    }
  }]);

  return DataView;
}(DataSetPart);
/**
 * Check that given value is compatible with Vis Data Set interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 * @returns True if all expected values and methods match, false otherwise.
 */


function isDataSetLike(idProp, v) {
  return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof v.add === "function" && typeof v.clear === "function" && typeof v.distinct === "function" && typeof forEach$2(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.max === "function" && typeof v.min === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.remove === "function" && typeof v.setOptions === "function" && typeof v.stream === "function" && typeof v.update === "function" && typeof v.updateOnly === "function";
}
/**
 * Check that given value is compatible with Vis Data View interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 * @returns True if all expected values and methods match, false otherwise.
 */


function isDataViewLike(idProp, v) {
  return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof forEach$2(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.stream === "function" && isDataSetLike(idProp, v.getDataSet());
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DELETE: DELETE,
	DataSet: DataSet,
	DataStream: DataStream,
	DataView: DataView,
	Queue: Queue,
	createNewDataPipeFrom: createNewDataPipeFrom,
	isDataSetLike: isDataSetLike,
	isDataViewLike: isDataViewLike
});

var global$2 = global$P;
var fails$1 = fails$t;
var uncurryThis$2 = functionUncurryThis;
var toString = toString$8;
var trim = stringTrim.trim;
var whitespaces = whitespaces$4;
var charAt = uncurryThis$2(''.charAt);
var n$ParseFloat = global$2.parseFloat;
var Symbol$1 = global$2.Symbol;
var ITERATOR = Symbol$1 && Symbol$1.iterator;
var FORCED = 1 / n$ParseFloat(whitespaces + '-0') !== -Infinity // MS Edge 18- broken with boxed symbols
|| ITERATOR && !fails$1(function () {
  n$ParseFloat(Object(ITERATOR));
}); // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

var numberParseFloat = FORCED ? function parseFloat(string) {
  var trimmedString = trim(toString(string));
  var result = n$ParseFloat(trimmedString);
  return result === 0 && charAt(trimmedString, 0) == '-' ? -0 : result;
} : n$ParseFloat;

var $$4 = _export;
var $parseFloat = numberParseFloat; // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

$$4({
  global: true,
  forced: parseFloat != $parseFloat
}, {
  parseFloat: $parseFloat
});

var path$5 = path$y;
var _parseFloat$2 = path$5.parseFloat;

var parent$9 = _parseFloat$2;
var _parseFloat$1 = parent$9;

var _parseFloat = _parseFloat$1;

var $$3 = _export;
var fails = fails$t;
var getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f; // eslint-disable-next-line es/no-object-getownpropertynames -- required for testing

var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames

$$3({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: getOwnPropertyNames$3
});

var path$4 = path$y;
var Object$1 = path$4.Object;

var getOwnPropertyNames$2 = function getOwnPropertyNames(it) {
  return Object$1.getOwnPropertyNames(it);
};

var parent$8 = getOwnPropertyNames$2;
var getOwnPropertyNames$1 = parent$8;

var getOwnPropertyNames = getOwnPropertyNames$1;

/**
 * Helper functions for components
 */

/**
 * Determine values to use for (sub)options of 'chosen'.
 *
 * This option is either a boolean or an object whose values should be examined further.
 * The relevant structures are:
 *
 * - chosen: <boolean value>
 * - chosen: { subOption: <boolean or function> }
 *
 * Where subOption is 'node', 'edge' or 'label'.
 *
 * The intention of this method appears to be to set a specific priority to the options;
 * Since most properties are either bridged or merged into the local options objects, there
 * is not much point in handling them separately.
 * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we
 *       should be able to get rid of this method.
 *
 * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'
 * @param {object}  pile       array of options objects to consider
 * @returns {boolean | Function}  value for passed subOption of 'chosen' to use
 */

function choosify(subOption, pile) {
  // allowed values for subOption
  var allowed = ["node", "edge", "label"];
  var value = true;
  var chosen = topMost(pile, "chosen");

  if (typeof chosen === "boolean") {
    value = chosen;
  } else if (_typeof(chosen) === "object") {
    if (indexOf(allowed).call(allowed, subOption) === -1) {
      throw new Error("choosify: subOption '" + subOption + "' should be one of " + "'" + allowed.join("', '") + "'");
    }

    var chosenEdge = topMost(pile, ["chosen", subOption]);

    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
      value = chosenEdge;
    }
  }

  return value;
}
/**
 * Check if the point falls within the given rectangle.
 *
 * @param {rect} rect
 * @param {point} point
 * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.
 * @returns {boolean}  true if point within rectangle, false otherwise
 */

function pointInRect(rect, point, rotationPoint) {
  if (rect.width <= 0 || rect.height <= 0) {
    return false; // early out
  }

  if (rotationPoint !== undefined) {
    // Rotate the point the same amount as the rectangle
    var tmp = {
      x: point.x - rotationPoint.x,
      y: point.y - rotationPoint.y
    };

    if (rotationPoint.angle !== 0) {
      // In order to get the coordinates the same, you need to
      // rotate in the reverse direction
      var angle = -rotationPoint.angle;
      var tmp2 = {
        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
      };
      point = tmp2;
    } else {
      point = tmp;
    } // Note that if a rotation is specified, the rectangle coordinates
    // are **not* the full canvas coordinates. They are relative to the
    // rotationPoint. Hence, the point coordinates need not be translated
    // back in this case.

  }

  var right = rect.x + rect.width;
  var bottom = rect.y + rect.width;
  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
}
/**
 * Check if given value is acceptable as a label text.
 *
 * @param {*} text value to check; can be anything at this point
 * @returns {boolean} true if valid label value, false otherwise
 */

function isValidLabel(text) {
  // Note that this is quite strict: types that *might* be converted to string are disallowed
  return typeof text === "string" && text !== "";
}
/**
 * Returns x, y of self reference circle based on provided angle
 *
 * @param {object} ctx
 * @param {number} angle
 * @param {number} radius
 * @param {VisNode} node
 * @returns {object} x and y coordinates
 */

function getSelfRefCoordinates(ctx, angle, radius, node) {
  var x = node.x;
  var y = node.y;

  if (typeof node.distanceToBorder === "function") {
    //calculating opposite and adjacent
    //distaneToBorder becomes Hypotenuse.
    //Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse
    var toBorderDist = node.distanceToBorder(ctx, angle);
    var yFromNodeCenter = Math.sin(angle) * toBorderDist;
    var xFromNodeCenter = Math.cos(angle) * toBorderDist; //xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means
    //that y does not need calculation because it is equal node.height / 2 or node.y
    //same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means
    //that x is equal node.width / 2 or node.x

    if (xFromNodeCenter === toBorderDist) {
      x += toBorderDist;
      y = node.y;
    } else if (yFromNodeCenter === toBorderDist) {
      x = node.x;
      y -= toBorderDist;
    } else {
      x += xFromNodeCenter;
      y -= yFromNodeCenter;
    }
  } else if (node.shape.width > node.shape.height) {
    x = node.x + node.shape.width * 0.5;
    y = node.y - radius;
  } else {
    x = node.x + radius;
    y = node.y - node.shape.height * 0.5;
  }

  return {
    x: x,
    y: y
  };
}

/**
 * Callback to determine text dimensions, using the parent label settings.
 *
 * @callback MeasureText
 * @param {text} text
 * @param {text} mod
 * @returns {object} { width, values} width in pixels and font attributes
 */

/**
 * Helper class for Label which collects results of splitting labels into lines and blocks.
 *
 * @private
 */
var LabelAccumulator = /*#__PURE__*/function () {
  /**
   * @param {MeasureText} measureText
   */
  function LabelAccumulator(measureText) {
    _classCallCheck(this, LabelAccumulator);

    this.measureText = measureText;
    this.current = 0;
    this.width = 0;
    this.height = 0;
    this.lines = [];
  }
  /**
   * Append given text to the given line.
   *
   * @param {number}  l    index of line to add to
   * @param {string}  text string to append to line
   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
   * @private
   */


  _createClass(LabelAccumulator, [{
    key: "_add",
    value: function _add(l, text) {
      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "normal";

      if (this.lines[l] === undefined) {
        this.lines[l] = {
          width: 0,
          height: 0,
          blocks: []
        };
      } // We still need to set a block for undefined and empty texts, hence return at this point
      // This is necessary because we don't know at this point if we're at the
      // start of an empty line or not.
      // To compensate, empty blocks are removed in `finalize()`.
      //
      // Empty strings should still have a height


      var tmpText = text;
      if (text === undefined || text === "") tmpText = " "; // Determine width and get the font properties

      var result = this.measureText(tmpText, mod);

      var block = assign$2({}, values(result));

      block.text = text;
      block.width = result.width;
      block.mod = mod;

      if (text === undefined || text === "") {
        block.width = 0;
      }

      this.lines[l].blocks.push(block); // Update the line width. We need this for determining if a string goes over max width

      this.lines[l].width += block.width;
    }
    /**
     * Returns the width in pixels of the current line.
     *
     * @returns {number}
     */

  }, {
    key: "curWidth",
    value: function curWidth() {
      var line = this.lines[this.current];
      if (line === undefined) return 0;
      return line.width;
    }
    /**
     * Add text in block to current line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: "append",
    value: function append(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";

      this._add(this.current, text, mod);
    }
    /**
     * Add text in block to current line and start a new line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: "newLine",
    value: function newLine(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";

      this._add(this.current, text, mod);

      this.current++;
    }
    /**
     * Determine and set the heights of all the lines currently contained in this instance
     *
     * Note that width has already been set.
     *
     * @private
     */

  }, {
    key: "determineLineHeights",
    value: function determineLineHeights() {
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k]; // Looking for max height of blocks in line

        var height = 0;

        if (line.blocks !== undefined) {
          // Can happen if text contains e.g. '\n '
          for (var l = 0; l < line.blocks.length; l++) {
            var block = line.blocks[l];

            if (height < block.height) {
              height = block.height;
            }
          }
        }

        line.height = height;
      }
    }
    /**
     * Determine the full size of the label text, as determined by current lines and blocks
     *
     * @private
     */

  }, {
    key: "determineLabelSize",
    value: function determineLabelSize() {
      var width = 0;
      var height = 0;

      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];

        if (line.width > width) {
          width = line.width;
        }

        height += line.height;
      }

      this.width = width;
      this.height = height;
    }
    /**
     * Remove all empty blocks and empty lines we don't need
     *
     * This must be done after the width/height determination,
     * so that these are set properly for processing here.
     *
     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
     * @private
     */

  }, {
    key: "removeEmptyBlocks",
    value: function removeEmptyBlocks() {
      var tmpLines = [];

      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k]; // Note: an empty line in between text has width zero but is still relevant to layout.
        // So we can't use width for testing empty line here

        if (line.blocks.length === 0) continue; // Discard final empty line always

        if (k === this.lines.length - 1) {
          if (line.width === 0) continue;
        }

        var tmpLine = {};

        assign$2(tmpLine, line);

        tmpLine.blocks = [];
        var firstEmptyBlock = void 0;
        var tmpBlocks = [];

        for (var l = 0; l < line.blocks.length; l++) {
          var block = line.blocks[l];

          if (block.width !== 0) {
            tmpBlocks.push(block);
          } else {
            if (firstEmptyBlock === undefined) {
              firstEmptyBlock = block;
            }
          }
        } // Ensure that there is *some* text present


        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {
          tmpBlocks.push(firstEmptyBlock);
        }

        tmpLine.blocks = tmpBlocks;
        tmpLines.push(tmpLine);
      }

      return tmpLines;
    }
    /**
     * Set the sizes for all lines and the whole thing.
     *
     * @returns {{width: (number|*), height: (number|*), lines: Array}}
     */

  }, {
    key: "finalize",
    value: function finalize() {
      //console.log(JSON.stringify(this.lines, null, 2));
      this.determineLineHeights();
      this.determineLabelSize();
      var tmpLines = this.removeEmptyBlocks(); // Return a simple hash object for further processing.

      return {
        width: this.width,
        height: this.height,
        lines: tmpLines
      };
    }
  }]);

  return LabelAccumulator;
}();

var tagPattern = {
  // HTML
  "<b>": /<b>/,
  "<i>": /<i>/,
  "<code>": /<code>/,
  "</b>": /<\/b>/,
  "</i>": /<\/i>/,
  "</code>": /<\/code>/,
  // Markdown
  "*": /\*/,
  // bold
  _: /_/,
  // ital
  "`": /`/,
  // mono
  afterBold: /[^*]/,
  afterItal: /[^_]/,
  afterMono: /[^`]/
};
/**
 * Internal helper class for parsing the markup tags for HTML and Markdown.
 *
 * NOTE: Sequences of tabs and spaces are reduced to single space.
 *       Scan usage of `this.spacing` within method
 */

var MarkupAccumulator = /*#__PURE__*/function () {
  /**
   * Create an instance
   *
   * @param {string} text  text to parse for markup
   */
  function MarkupAccumulator(text) {
    _classCallCheck(this, MarkupAccumulator);

    this.text = text;
    this.bold = false;
    this.ital = false;
    this.mono = false;
    this.spacing = false;
    this.position = 0;
    this.buffer = "";
    this.modStack = [];
    this.blocks = [];
  }
  /**
   * Return the mod label currently on the top of the stack
   *
   * @returns {string}  label of topmost mod
   * @private
   */


  _createClass(MarkupAccumulator, [{
    key: "mod",
    value: function mod() {
      return this.modStack.length === 0 ? "normal" : this.modStack[0];
    }
    /**
     * Return the mod label currently active
     *
     * @returns {string}  label of active mod
     * @private
     */

  }, {
    key: "modName",
    value: function modName() {
      if (this.modStack.length === 0) return "normal";else if (this.modStack[0] === "mono") return "mono";else {
        if (this.bold && this.ital) {
          return "boldital";
        } else if (this.bold) {
          return "bold";
        } else if (this.ital) {
          return "ital";
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "emitBlock",
    value: function emitBlock() {
      if (this.spacing) {
        this.add(" ");
        this.spacing = false;
      }

      if (this.buffer.length > 0) {
        this.blocks.push({
          text: this.buffer,
          mod: this.modName()
        });
        this.buffer = "";
      }
    }
    /**
     * Output text to buffer
     *
     * @param {string} text  text to add
     * @private
     */

  }, {
    key: "add",
    value: function add(text) {
      if (text === " ") {
        this.spacing = true;
      }

      if (this.spacing) {
        this.buffer += " ";
        this.spacing = false;
      }

      if (text != " ") {
        this.buffer += text;
      }
    }
    /**
     * Handle parsing of whitespace
     *
     * @param {string} ch  the character to check
     * @returns {boolean} true if the character was processed as whitespace, false otherwise
     */

  }, {
    key: "parseWS",
    value: function parseWS(ch) {
      if (/[ \t]/.test(ch)) {
        if (!this.mono) {
          this.spacing = true;
        } else {
          this.add(ch);
        }

        return true;
      }

      return false;
    }
    /**
     * @param {string} tagName  label for block type to set
     * @private
     */

  }, {
    key: "setTag",
    value: function setTag(tagName) {
      this.emitBlock();
      this[tagName] = true;
      this.modStack.unshift(tagName);
    }
    /**
     * @param {string} tagName  label for block type to unset
     * @private
     */

  }, {
    key: "unsetTag",
    value: function unsetTag(tagName) {
      this.emitBlock();
      this[tagName] = false;
      this.modStack.shift();
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "parseStartTag",
    value: function parseStartTag(tagName, tag) {
      // Note: if 'mono' passed as tagName, there is a double check here. This is OK
      if (!this.mono && !this[tagName] && this.match(tag)) {
        this.setTag(tagName);
        return true;
      }

      return false;
    }
    /**
     * @param {string|RegExp} tag
     * @param {number} [advance=true] if set, advance current position in text
     * @returns {boolean} true if match at given position, false otherwise
     * @private
     */

  }, {
    key: "match",
    value: function match(tag) {
      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var _this$prepareRegExp = this.prepareRegExp(tag),
          _this$prepareRegExp2 = _slicedToArray(_this$prepareRegExp, 2),
          regExp = _this$prepareRegExp2[0],
          length = _this$prepareRegExp2[1];

      var matched = regExp.test(this.text.substr(this.position, length));

      if (matched && advance) {
        this.position += length - 1;
      }

      return matched;
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "parseEndTag",
    value: function parseEndTag(tagName, tag, nextTag) {
      var checkTag = this.mod() === tagName;

      if (tagName === "mono") {
        // special handling for 'mono'
        checkTag = checkTag && this.mono;
      } else {
        checkTag = checkTag && !this.mono;
      }

      if (checkTag && this.match(tag)) {
        if (nextTag !== undefined) {
          // Purpose of the following match is to prevent a direct unset/set of a given tag
          // E.g. '*bold **still bold*' => '*bold still bold*'
          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
            this.unsetTag(tagName);
          }
        } else {
          this.unsetTag(tagName);
        }

        return true;
      }

      return false;
    }
    /**
     * @param {string|RegExp} tag  string to match in text
     * @param {value} value  string to replace tag with, if found at current position
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "replace",
    value: function replace(tag, value) {
      if (this.match(tag)) {
        this.add(value);
        this.position += length - 1;
        return true;
      }

      return false;
    }
    /**
     * Create a regular expression for the tag if it isn't already one.
     *
     * The return value is an array `[RegExp, number]`, with exactly two value, where:
     *  - RegExp is the regular expression to use
     *  - number is the lenth of the input string to match
     *
     * @param {string|RegExp} tag  string to match in text
     * @returns {Array}  regular expression to use and length of input string to match
     * @private
     */

  }, {
    key: "prepareRegExp",
    value: function prepareRegExp(tag) {
      var length;
      var regExp;

      if (tag instanceof RegExp) {
        regExp = tag;
        length = 1; // ASSUMPTION: regexp only tests one character
      } else {
        // use prepared regexp if present
        var prepared = tagPattern[tag];

        if (prepared !== undefined) {
          regExp = prepared;
        } else {
          regExp = new RegExp(tag);
        }

        length = tag.length;
      }

      return [regExp, length];
    }
  }]);

  return MarkupAccumulator;
}();
/**
 * Helper class for Label which explodes the label text into lines and blocks within lines
 *
 * @private
 */


var LabelSplitter = /*#__PURE__*/function () {
  /**
   * @param {CanvasRenderingContext2D} ctx Canvas rendering context
   * @param {Label} parent reference to the Label instance using current instance
   * @param {boolean} selected
   * @param {boolean} hover
   */
  function LabelSplitter(ctx, parent, selected, hover) {
    var _this = this;

    _classCallCheck(this, LabelSplitter);

    this.ctx = ctx;
    this.parent = parent;
    this.selected = selected;
    this.hover = hover;
    /**
     * Callback to determine text width; passed to LabelAccumulator instance
     *
     * @param  {string} text string to determine width of
     * @param  {string} mod  font type to use for this text
     * @returns {object} { width, values} width in pixels and font attributes
     */

    var textWidth = function textWidth(text, mod) {
      if (text === undefined) return 0; // TODO: This can be done more efficiently with caching
      // This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.

      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);

      var width = 0;

      if (text !== "") {
        var measure = _this.ctx.measureText(text);

        width = measure.width;
      }

      return {
        width: width,
        values: values
      };
    };

    this.lines = new LabelAccumulator(textWidth);
  }
  /**
   * Split passed text of a label into lines and blocks.
   *
   * # NOTE
   *
   * The handling of spacing is option dependent:
   *
   * - if `font.multi : false`, all spaces are retained
   * - if `font.multi : true`, every sequence of spaces is compressed to a single space
   *
   * This might not be the best way to do it, but this is as it has been working till now.
   * In order not to break existing functionality, for the time being this behaviour will
   * be retained in any code changes.
   *
   * @param {string} text  text to split
   * @returns {Array<line>}
   */


  _createClass(LabelSplitter, [{
    key: "process",
    value: function process(text) {
      if (!isValidLabel(text)) {
        return this.lines.finalize();
      }

      var font = this.parent.fontOptions; // Normalize the end-of-line's to a single representation - order important

      text = text.replace(/\r\n/g, "\n"); // Dos EOL's

      text = text.replace(/\r/g, "\n"); // Mac EOL's
      // Note that at this point, there can be no \r's in the text.
      // This is used later on splitStringIntoLines() to split multifont texts.

      var nlLines = String(text).split("\n");
      var lineCount = nlLines.length;

      if (font.multi) {
        // Multi-font case: styling tags active
        for (var i = 0; i < lineCount; i++) {
          var blocks = this.splitBlocks(nlLines[i], font.multi); // Post: Sequences of tabs and spaces are reduced to single space

          if (blocks === undefined) continue;

          if (blocks.length === 0) {
            this.lines.newLine("");
            continue;
          }

          if (font.maxWdt > 0) {
            // widthConstraint.maximum defined
            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);
            for (var j = 0; j < blocks.length; j++) {
              var mod = blocks[j].mod;
              var _text = blocks[j].text;
              this.splitStringIntoLines(_text, mod, true);
            }
          } else {
            // widthConstraint.maximum NOT defined
            for (var _j = 0; _j < blocks.length; _j++) {
              var _mod = blocks[_j].mod;
              var _text2 = blocks[_j].text;
              this.lines.append(_text2, _mod);
            }
          }

          this.lines.newLine();
        }
      } else {
        // Single-font case
        if (font.maxWdt > 0) {
          // widthConstraint.maximum defined
          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);
          for (var _i = 0; _i < lineCount; _i++) {
            this.splitStringIntoLines(nlLines[_i]);
          }
        } else {
          // widthConstraint.maximum NOT defined
          for (var _i2 = 0; _i2 < lineCount; _i2++) {
            this.lines.newLine(nlLines[_i2]);
          }
        }
      }

      return this.lines.finalize();
    }
    /**
     * normalize the markup system
     *
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {string}
     */

  }, {
    key: "decodeMarkupSystem",
    value: function decodeMarkupSystem(markupSystem) {
      var system = "none";

      if (markupSystem === "markdown" || markupSystem === "md") {
        system = "markdown";
      } else if (markupSystem === true || markupSystem === "html") {
        system = "html";
      }

      return system;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: "splitHtmlBlocks",
    value: function splitHtmlBlocks(text) {
      var s = new MarkupAccumulator(text);

      var parseEntities = function parseEntities(ch) {
        if (/&/.test(ch)) {
          var parsed = s.replace(s.text, "&lt;", "<") || s.replace(s.text, "&amp;", "&");

          if (!parsed) {
            s.add("&");
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag("bold", "<b>") || s.parseStartTag("ital", "<i>") || s.parseStartTag("mono", "<code>") || s.parseEndTag("bold", "</b>") || s.parseEndTag("ital", "</i>") || s.parseEndTag("mono", "</code>")) || parseEntities(ch);

        if (!parsed) {
          s.add(ch);
        }

        s.position++;
      }

      s.emitBlock();
      return s.blocks;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: "splitMarkdownBlocks",
    value: function splitMarkdownBlocks(text) {
      var _this2 = this;

      var s = new MarkupAccumulator(text);
      var beginable = true;

      var parseOverride = function parseOverride(ch) {
        if (/\\/.test(ch)) {
          if (s.position < _this2.text.length + 1) {
            s.position++;
            ch = _this2.text.charAt(s.position);

            if (/ \t/.test(ch)) {
              s.spacing = true;
            } else {
              s.add(ch);
              beginable = false;
            }
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag("bold", "*") || s.parseStartTag("ital", "_") || s.parseStartTag("mono", "`")) || s.parseEndTag("bold", "*", "afterBold") || s.parseEndTag("ital", "_", "afterItal") || s.parseEndTag("mono", "`", "afterMono");

        if (!parsed) {
          s.add(ch);
          beginable = false;
        }

        s.position++;
      }

      s.emitBlock();
      return s.blocks;
    }
    /**
     * Explodes a piece of text into single-font blocks using a given markup
     *
     * @param {string} text
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {Array.<{text: string, mod: string}>}
     * @private
     */

  }, {
    key: "splitBlocks",
    value: function splitBlocks(text, markupSystem) {
      var system = this.decodeMarkupSystem(markupSystem);

      if (system === "none") {
        return [{
          text: text,
          mod: "normal"
        }];
      } else if (system === "markdown") {
        return this.splitMarkdownBlocks(text);
      } else if (system === "html") {
        return this.splitHtmlBlocks(text);
      }
    }
    /**
     * @param {string} text
     * @returns {boolean} true if text length over the current max with
     * @private
     */

  }, {
    key: "overMaxWidth",
    value: function overMaxWidth(text) {
      var width = this.ctx.measureText(text).width;
      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
    }
    /**
     * Determine the longest part of the sentence which still fits in the
     * current max width.
     *
     * @param {Array} words  Array of strings signifying a text lines
     * @returns {number}      index of first item in string making string go over max
     * @private
     */

  }, {
    key: "getLongestFit",
    value: function getLongestFit(words) {
      var text = "";
      var w = 0;

      while (w < words.length) {
        var pre = text === "" ? "" : " ";
        var newText = text + pre + words[w];
        if (this.overMaxWidth(newText)) break;
        text = newText;
        w++;
      }

      return w;
    }
    /**
     * Determine the longest part of the string which still fits in the
     * current max width.
     *
     * @param {Array} words Array of strings signifying a text lines
     * @returns {number} index of first item in string making string go over max
     */

  }, {
    key: "getLongestFitWord",
    value: function getLongestFitWord(words) {
      var w = 0;

      while (w < words.length) {
        if (this.overMaxWidth(slice(words).call(words, 0, w))) break;
        w++;
      }

      return w;
    }
    /**
     * Split the passed text into lines, according to width constraint (if any).
     *
     * The method assumes that the input string is a single line, i.e. without lines break.
     *
     * This method retains spaces, if still present (case `font.multi: false`).
     * A space which falls on an internal line break, will be replaced by a newline.
     * There is no special handling of tabs; these go along with the flow.
     *
     * @param {string} str
     * @param {string} [mod='normal']
     * @param {boolean} [appendLast=false]
     * @private
     */

  }, {
    key: "splitStringIntoLines",
    value: function splitStringIntoLines(str) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";
      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // Set the canvas context font, based upon the current selected/hover state
      // and the provided mod, so the text measurement performed by getLongestFit
      // will be accurate - and not just use the font of whoever last used the canvas.
      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod); // Still-present spaces are relevant, retain them

      str = str.replace(/^( +)/g, "$1\r");
      str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
      var words = str.split("\r");

      while (words.length > 0) {
        var w = this.getLongestFit(words);

        if (w === 0) {
          // Special case: the first word is already larger than the max width.
          var word = words[0]; // Break the word to the largest part that fits the line

          var x = this.getLongestFitWord(word);
          this.lines.newLine(slice(word).call(word, 0, x), mod); // Adjust the word, so that the rest will be done next iteration

          words[0] = slice(word).call(word, x);
        } else {
          // skip any space that is replaced by a newline
          var newW = w;

          if (words[w - 1] === " ") {
            w--;
          } else if (words[newW] === " ") {
            newW++;
          }

          var text = slice(words).call(words, 0, w).join("");

          if (w == words.length && appendLast) {
            this.lines.append(text, mod);
          } else {
            this.lines.newLine(text, mod);
          } // Adjust the word, so that the rest will be done next iteration


          words = slice(words).call(words, newW);
        }
      }
    }
  }]);

  return LabelSplitter;
}();

/**
 * List of special styles for multi-fonts
 *
 * @private
 */

var multiFontStyle = ["bold", "ital", "boldital", "mono"];
/**
 * A Label to be used for Nodes or Edges.
 */

var Label = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {object} options
   * @param {boolean} [edgelabel=false]
   */
  function Label(body, options) {
    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, Label);

    this.body = body;
    this.pointToSelf = false;
    this.baseSize = undefined;
    this.fontOptions = {}; // instance variable containing the *instance-local* font options

    this.setOptions(options);
    this.size = {
      top: 0,
      left: 0,
      width: 0,
      height: 0,
      yLine: 0
    };
    this.isEdgeLabel = edgelabel;
  }
  /**
   * @param {object} options the options of the parent Node-instance
   */


  _createClass(Label, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.elementOptions = options; // Reference to the options of the parent Node-instance

      this.initFontOptions(options.font);

      if (isValidLabel(options.label)) {
        this.labelDirty = true;
      } else {
        // Bad label! Change the option value to prevent bad stuff happening
        options.label = undefined;
      }

      if (options.font !== undefined && options.font !== null) {
        // font options can be deleted at various levels
        if (typeof options.font === "string") {
          this.baseSize = this.fontOptions.size;
        } else if (_typeof(options.font) === "object") {
          var size = options.font.size;

          if (size !== undefined) {
            this.baseSize = size;
          }
        }
      }
    }
    /**
     * Init the font Options structure.
     *
     * Member fontOptions serves as an accumulator for the current font options.
     * As such, it needs to be completely separated from the node options.
     *
     * @param {object} newFontOptions the new font options to process
     * @private
     */

  }, {
    key: "initFontOptions",
    value: function initFontOptions(newFontOptions) {
      var _this = this;

      // Prepare the multi-font option objects.
      // These will be filled in propagateFonts(), if required
      forEach$1(multiFontStyle, function (style) {
        _this.fontOptions[style] = {};
      }); // Handle shorthand option, if present

      if (Label.parseFontString(this.fontOptions, newFontOptions)) {
        this.fontOptions.vadjust = 0;
        return;
      } // Copy over the non-multifont options, if specified


      forEach$1(newFontOptions, function (prop, n) {
        if (prop !== undefined && prop !== null && _typeof(prop) !== "object") {
          _this.fontOptions[n] = prop;
        }
      });
    }
    /**
     * If in-variable is a string, parse it as a font specifier.
     *
     * Note that following is not done here and have to be done after the call:
     * - Not all font options are set (vadjust, mod)
     *
     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)
     * @param {object} inOptions  font options to parse
     * @returns {boolean} true if font parsed as string, false otherwise
     * @static
     */

  }, {
    key: "constrain",
    value:
    /**
     * Set the width and height constraints based on 'nearest' value
     *
     * @param {Array} pile array of option objects to consider
     * @returns {object} the actual constraint values to use
     * @private
     */
    function constrain(pile) {
      // NOTE: constrainWidth and  constrainHeight never set!
      // NOTE: for edge labels, only 'maxWdt' set
      // Node labels can set all the fields
      var fontOptions = {
        constrainWidth: false,
        maxWdt: -1,
        minWdt: -1,
        constrainHeight: false,
        minHgt: -1,
        valign: "middle"
      };
      var widthConstraint = topMost(pile, "widthConstraint");

      if (typeof widthConstraint === "number") {
        fontOptions.maxWdt = Number(widthConstraint);
        fontOptions.minWdt = Number(widthConstraint);
      } else if (_typeof(widthConstraint) === "object") {
        var widthConstraintMaximum = topMost(pile, ["widthConstraint", "maximum"]);

        if (typeof widthConstraintMaximum === "number") {
          fontOptions.maxWdt = Number(widthConstraintMaximum);
        }

        var widthConstraintMinimum = topMost(pile, ["widthConstraint", "minimum"]);

        if (typeof widthConstraintMinimum === "number") {
          fontOptions.minWdt = Number(widthConstraintMinimum);
        }
      }

      var heightConstraint = topMost(pile, "heightConstraint");

      if (typeof heightConstraint === "number") {
        fontOptions.minHgt = Number(heightConstraint);
      } else if (_typeof(heightConstraint) === "object") {
        var heightConstraintMinimum = topMost(pile, ["heightConstraint", "minimum"]);

        if (typeof heightConstraintMinimum === "number") {
          fontOptions.minHgt = Number(heightConstraintMinimum);
        }

        var heightConstraintValign = topMost(pile, ["heightConstraint", "valign"]);

        if (typeof heightConstraintValign === "string") {
          if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
            fontOptions.valign = heightConstraintValign;
          }
        }
      }

      return fontOptions;
    }
    /**
     * Set options and update internal state
     *
     * @param {object} options  options to set
     * @param {Array}  pile     array of option objects to consider for option 'chosen'
     */

  }, {
    key: "update",
    value: function update(options, pile) {
      this.setOptions(options, true);
      this.propagateFonts(pile);
      deepExtend(this.fontOptions, this.constrain(pile));
      this.fontOptions.chooser = choosify("label", pile);
    }
    /**
     * When margins are set in an element, adjust sizes is called to remove them
     * from the width/height constraints. This must be done prior to label sizing.
     *
     * @param {{top: number, right: number, bottom: number, left: number}} margins
     */

  }, {
    key: "adjustSizes",
    value: function adjustSizes(margins) {
      var widthBias = margins ? margins.right + margins.left : 0;

      if (this.fontOptions.constrainWidth) {
        this.fontOptions.maxWdt -= widthBias;
        this.fontOptions.minWdt -= widthBias;
      }

      var heightBias = margins ? margins.top + margins.bottom : 0;

      if (this.fontOptions.constrainHeight) {
        this.fontOptions.minHgt -= heightBias;
      }
    } /////////////////////////////////////////////////////////
    // Methods for handling options piles
    // Eventually, these will be moved to a separate class
    /////////////////////////////////////////////////////////

    /**
     * Add the font members of the passed list of option objects to the pile.
     *
     * @param {Pile} dstPile  pile of option objects add to
     * @param {Pile} srcPile  pile of option objects to take font options from
     * @private
     */

  }, {
    key: "addFontOptionsToPile",
    value: function addFontOptionsToPile(dstPile, srcPile) {
      for (var i = 0; i < srcPile.length; ++i) {
        this.addFontToPile(dstPile, srcPile[i]);
      }
    }
    /**
     * Add given font option object to the list of objects (the 'pile') to consider for determining
     * multi-font option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {object} options  instance to add to pile
     * @private
     */

  }, {
    key: "addFontToPile",
    value: function addFontToPile(pile, options) {
      if (options === undefined) return;
      if (options.font === undefined || options.font === null) return;
      var item = options.font;
      pile.push(item);
    }
    /**
     * Collect all own-property values from the font pile that aren't multi-font option objectss.
     *
     * @param {Pile} pile  pile of option objects to use
     * @returns {object} object with all current own basic font properties
     * @private
     */

  }, {
    key: "getBasicOptions",
    value: function getBasicOptions(pile) {
      var ret = {}; // Scans the whole pile to get all options present

      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n]; // Convert shorthand if necessary

        var tmpShorthand = {};

        if (Label.parseFontString(tmpShorthand, fontOptions)) {
          fontOptions = tmpShorthand;
        }

        forEach$1(fontOptions, function (opt, name) {
          if (opt === undefined) return; // multi-font option need not be present

          if (Object.prototype.hasOwnProperty.call(ret, name)) return; // Keep first value we encounter

          if (indexOf(multiFontStyle).call(multiFontStyle, name) !== -1) {
            // Skip multi-font properties but we do need the structure
            ret[name] = {};
          } else {
            ret[name] = opt;
          }
        });
      }

      return ret;
    }
    /**
     * Return the value for given option for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * ---------------------------------------------------------------------
     * ## Traversal of pile for multi-fonts
     *
     * The determination of multi-font option values is a special case, because any values not
     * present in the multi-font options should by definition be taken from the main font options,
     * i.e. from the current 'parent' object of the multi-font option.
     *
     * ### Search order for multi-fonts
     *
     * 'bold' used as example:
     *
     *   - search in option group 'bold' in local properties
     *   - search in main font option group in local properties
     *
     * ---------------------------------------------------------------------
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the multi-font
     * @param {string} option  the option to search for, for the given multi-font
     * @returns {string|number} the value for the given option
     * @private
     */

  }, {
    key: "getFontOption",
    value: function getFontOption(pile, multiName, option) {
      var multiFont; // Search multi font in local properties

      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];

        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {
          multiFont = fontOptions[multiName];
          if (multiFont === undefined || multiFont === null) continue; // Convert shorthand if necessary
          // TODO: inefficient to do this conversion every time; find a better way.

          var tmpShorthand = {};

          if (Label.parseFontString(tmpShorthand, multiFont)) {
            multiFont = tmpShorthand;
          }

          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {
            return multiFont[option];
          }
        }
      } // Option is not mentioned in the multi font options; take it from the parent font options.
      // These have already been converted with getBasicOptions(), so use the converted values.


      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {
        return this.fontOptions[option];
      } // A value **must** be found; you should never get here.


      throw new Error("Did not find value for multi-font for property: '" + option + "'");
    }
    /**
     * Return all options values for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the mod-font
     * @returns {MultiFontOptions}
     * @private
     */

  }, {
    key: "getFontOptions",
    value: function getFontOptions(pile, multiName) {
      var result = {};
      var optionNames = ["color", "size", "face", "mod", "vadjust"]; // List of allowed options per multi-font

      for (var i = 0; i < optionNames.length; ++i) {
        var mod = optionNames[i];
        result[mod] = this.getFontOption(pile, multiName, mod);
      }

      return result;
    } /////////////////////////////////////////////////////////
    // End methods for handling options piles
    /////////////////////////////////////////////////////////

    /**
     * Collapse the font options for the multi-font to single objects, from
     * the chain of option objects passed (the 'pile').
     *
     * @param {Pile} pile  sequence of option objects to consider.
     *                     First item in list assumed to be the newly set options.
     */

  }, {
    key: "propagateFonts",
    value: function propagateFonts(pile) {
      var _this2 = this;

      var fontPile = []; // sequence of font objects to consider, order important
      // Note that this.elementOptions is not used here.

      this.addFontOptionsToPile(fontPile, pile);
      this.fontOptions = this.getBasicOptions(fontPile); // We set multifont values even if multi === false, for consistency (things break otherwise)

      var _loop = function _loop(i) {
        var mod = multiFontStyle[i];
        var modOptions = _this2.fontOptions[mod];

        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod); // Copy over found values


        forEach$1(tmpMultiFontOptions, function (option, n) {
          modOptions[n] = option;
        });
        modOptions.size = Number(modOptions.size);
        modOptions.vadjust = Number(modOptions.vadjust);
      };

      for (var i = 0; i < multiFontStyle.length; ++i) {
        _loop(i);
      }
    }
    /**
     * Main function. This is called from anything that wants to draw a label.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} [baseline='middle']
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover) {
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "middle";
      // if no label, return
      if (this.elementOptions.label === undefined) return; // check if we have to render the label

      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return; // This ensures that there will not be HUGE letters on screen
      // by setting an upper limit on the visible text size (regardless of zoomLevel)

      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
      } // update the size cache if required


      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);

      this._drawBackground(ctx);

      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
    }
    /**
     * Draws the label background
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: "_drawBackground",
    value: function _drawBackground(ctx) {
      if (this.fontOptions.background !== undefined && this.fontOptions.background !== "none") {
        ctx.fillStyle = this.fontOptions.background;
        var size = this.getSize();
        ctx.fillRect(size.left, size.top, size.width, size.height);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} [baseline='middle']
     * @param {number} viewFontSize
     * @private
     */

  }, {
    key: "_drawText",
    value: function _drawText(ctx, x, y) {
      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "middle";
      var viewFontSize = arguments.length > 4 ? arguments[4] : undefined;

      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);

      var _this$_setAlignment2 = _slicedToArray(_this$_setAlignment, 2);

      x = _this$_setAlignment2[0];
      y = _this$_setAlignment2[1];
      ctx.textAlign = "left";
      x = x - this.size.width / 2; // Shift label 1/2-distance to the left

      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
        if (this.fontOptions.valign === "top") {
          y -= (this.size.height - this.size.labelHeight) / 2;
        }

        if (this.fontOptions.valign === "bottom") {
          y += (this.size.height - this.size.labelHeight) / 2;
        }
      } // draw the text


      for (var i = 0; i < this.lineCount; i++) {
        var line = this.lines[i];

        if (line && line.blocks) {
          var width = 0;

          if (this.isEdgeLabel || this.fontOptions.align === "center") {
            width += (this.size.width - line.width) / 2;
          } else if (this.fontOptions.align === "right") {
            width += this.size.width - line.width;
          }

          for (var j = 0; j < line.blocks.length; j++) {
            var block = line.blocks[j];
            ctx.font = block.font;

            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor),
                _this$_getColor2 = _slicedToArray(_this$_getColor, 2),
                fontColor = _this$_getColor2[0],
                strokeColor = _this$_getColor2[1];

            if (block.strokeWidth > 0) {
              ctx.lineWidth = block.strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = "round";
            }

            ctx.fillStyle = fontColor;

            if (block.strokeWidth > 0) {
              ctx.strokeText(block.text, x + width, y + block.vadjust);
            }

            ctx.fillText(block.text, x + width, y + block.vadjust);
            width += block.width;
          }

          y += line.height;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} baseline
     * @returns {Array.<number>}
     * @private
     */

  }, {
    key: "_setAlignment",
    value: function _setAlignment(ctx, x, y, baseline) {
      // check for label alignment (for edges)
      // TODO: make alignment for nodes
      if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
        x = 0;
        y = 0;
        var lineMargin = 2;

        if (this.fontOptions.align === "top") {
          ctx.textBaseline = "alphabetic";
          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
        } else if (this.fontOptions.align === "bottom") {
          ctx.textBaseline = "hanging";
          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
        } else {
          ctx.textBaseline = "middle";
        }
      } else {
        ctx.textBaseline = baseline;
      }

      return [x, y];
    }
    /**
     * fade in when relative scale is between threshold and threshold - 1.
     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
     *
     * @param {string} color  The font color to use
     * @param {number} viewFontSize
     * @param {string} initialStrokeColor
     * @returns {Array.<string>} An array containing the font color and stroke color
     * @private
     */

  }, {
    key: "_getColor",
    value: function _getColor(color, viewFontSize, initialStrokeColor) {
      var fontColor = color || "#000000";
      var strokeColor = initialStrokeColor || "#ffffff";

      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
        fontColor = overrideOpacity(fontColor, opacity);
        strokeColor = overrideOpacity(strokeColor, opacity);
      }

      return [fontColor, strokeColor];
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {{width: number, height: number}}
     */

  }, {
    key: "getTextSize",
    value: function getTextSize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._processLabel(ctx, selected, hover);

      return {
        width: this.size.width,
        height: this.size.height,
        lineCount: this.lineCount
      };
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      var lineMargin = 2;
      var x = this.size.left; // default values which might be overridden below

      var y = this.size.top - 0.5 * lineMargin; // idem

      if (this.isEdgeLabel) {
        var x2 = -this.size.width * 0.5;

        switch (this.fontOptions.align) {
          case "middle":
            x = x2;
            y = -this.size.height * 0.5;
            break;

          case "top":
            x = x2;
            y = -(this.size.height + lineMargin);
            break;

          case "bottom":
            x = x2;
            y = lineMargin;
            break;
        }
      }

      var ret = {
        left: x,
        top: y,
        width: this.size.width,
        height: this.size.height
      };
      return ret;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {'middle'|'hanging'} [baseline='middle']
     */

  }, {
    key: "calculateLabelSize",
    value: function calculateLabelSize(ctx, selected, hover) {
      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "middle";

      this._processLabel(ctx, selected, hover);

      this.size.left = x - this.size.width * 0.5;
      this.size.top = y - this.size.height * 0.5;
      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;

      if (baseline === "hanging") {
        this.size.top += 0.5 * this.fontOptions.size;
        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers

        this.size.yLine += 4; // distance from node
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} mod
     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
     */

  }, {
    key: "getFormattingValues",
    value: function getFormattingValues(ctx, selected, hover, mod) {
      var getValue = function getValue(fontOptions, mod, option) {
        if (mod === "normal") {
          if (option === "mod") return "";
          return fontOptions[option];
        }

        if (fontOptions[mod][option] !== undefined) {
          // Grumbl leaving out test on undefined equals false for ""
          return fontOptions[mod][option];
        } else {
          // Take from parent font option
          return fontOptions[option];
        }
      };

      var values = {
        color: getValue(this.fontOptions, mod, "color"),
        size: getValue(this.fontOptions, mod, "size"),
        face: getValue(this.fontOptions, mod, "face"),
        mod: getValue(this.fontOptions, mod, "mod"),
        vadjust: getValue(this.fontOptions, mod, "vadjust"),
        strokeWidth: this.fontOptions.strokeWidth,
        strokeColor: this.fontOptions.strokeColor
      };

      if (selected || hover) {
        if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
          values.mod = "bold";
        } else {
          if (typeof this.fontOptions.chooser === "function") {
            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);
          }
        }
      }

      var fontString = "";

      if (values.mod !== undefined && values.mod !== "") {
        // safeguard for undefined - this happened
        fontString += values.mod + " ";
      }

      fontString += values.size + "px " + values.face;
      ctx.font = fontString.replace(/"/g, "");
      values.font = ctx.font;
      values.height = values.size;
      return values;
    }
    /**
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     */

  }, {
    key: "differentState",
    value: function differentState(selected, hover) {
      return selected !== this.selectedState || hover !== this.hoverState;
    }
    /**
     * This explodes the passed text into lines and determines the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} inText  the text to explode
     * @returns {{width, height, lines}|*}
     * @private
     */

  }, {
    key: "_processLabelText",
    value: function _processLabelText(ctx, selected, hover, inText) {
      var splitter = new LabelSplitter(ctx, this, selected, hover);
      return splitter.process(inText);
    }
    /**
     * This explodes the label string into lines and sets the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_processLabel",
    value: function _processLabel(ctx, selected, hover) {
      if (this.labelDirty === false && !this.differentState(selected, hover)) return;

      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);

      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
        state.width = this.fontOptions.minWdt;
      }

      this.size.labelHeight = state.height;

      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
        state.height = this.fontOptions.minHgt;
      }

      this.lines = state.lines;
      this.lineCount = state.lines.length;
      this.size.width = state.width;
      this.size.height = state.height;
      this.selectedState = selected;
      this.hoverState = hover;
      this.labelDirty = false;
    }
    /**
     * Check if this label is visible
     *
     * @returns {boolean} true if this label will be show, false otherwise
     */

  }, {
    key: "visible",
    value: function visible() {
      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {
        return false; // nothing to display
      }

      var viewFontSize = this.fontOptions.size * this.body.view.scale;

      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
        return false; // Too small or too far away to show
      }

      return true;
    }
  }], [{
    key: "parseFontString",
    value: function parseFontString(outOptions, inOptions) {
      if (!inOptions || typeof inOptions !== "string") return false;
      var newOptionsArray = inOptions.split(" ");
      outOptions.size = +newOptionsArray[0].replace("px", "");
      outOptions.face = newOptionsArray[1];
      outOptions.color = newOptionsArray[2];
      return true;
    }
  }]);

  return Label;
}();

/**
 * The Base class for all Nodes.
 */
var NodeBase = /*#__PURE__*/function () {
  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function NodeBase(options, body, labelModule) {
    _classCallCheck(this, NodeBase);

    this.body = body;
    this.labelModule = labelModule;
    this.setOptions(options);
    this.top = undefined;
    this.left = undefined;
    this.height = undefined;
    this.width = undefined;
    this.radius = undefined;
    this.margin = undefined;
    this.refreshNeeded = true;
    this.boundingBox = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }
  /**
   *
   * @param {object} options
   */


  _createClass(NodeBase, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     *
     * @param {Label} labelModule
     * @private
     */

  }, {
    key: "_setMargins",
    value: function _setMargins(labelModule) {
      this.margin = {};

      if (this.options.margin) {
        if (_typeof(this.options.margin) == "object") {
          this.margin.top = this.options.margin.top;
          this.margin.right = this.options.margin.right;
          this.margin.bottom = this.options.margin.bottom;
          this.margin.left = this.options.margin.left;
        } else {
          this.margin.top = this.options.margin;
          this.margin.right = this.options.margin;
          this.margin.bottom = this.options.margin;
          this.margin.left = this.options.margin;
        }
      }

      labelModule.adjustSizes(this.margin);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     * @private
     */

  }, {
    key: "_distanceToBorder",
    value: function _distanceToBorder(ctx, angle) {
      var borderWidth = this.options.borderWidth;

      if (ctx) {
        this.resize(ctx);
      }

      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "enableBorderDashes",
    value: function enableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var dashes = values.borderDashes;

          if (dashes === true) {
            dashes = [5, 15];
          }

          ctx.setLineDash(dashes);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "disableBorderDashes",
    value: function disableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([0]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }
    /**
     * Determine if the shape of a node needs to be recalculated.
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     * @protected
     */

  }, {
    key: "needsRefresh",
    value: function needsRefresh(selected, hover) {
      if (this.refreshNeeded === true) {
        // This is probably not the best location to reset this member.
        // However, in the current logic, it is the most convenient one.
        this.refreshNeeded = false;
        return true;
      }

      return this.width === undefined || this.labelModule.differentState(selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "initContextForDraw",
    value: function initContextForDraw(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale;
      ctx.lineWidth = Math.min(this.width, borderWidth);
      ctx.strokeStyle = values.borderColor;
      ctx.fillStyle = values.color;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "performStroke",
    value: function performStroke(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale; //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.

      ctx.save(); // if borders are zero width, they will be drawn with width 1 by default. This prevents that

      if (borderWidth > 0) {
        this.enableBorderDashes(ctx, values); //draw the border

        ctx.stroke(); //disable dashed border for other elements

        this.disableBorderDashes(ctx, values);
      }

      ctx.restore();
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "performFill",
    value: function performFill(ctx, values) {
      ctx.save();
      ctx.fillStyle = values.color; // draw shadow if enabled

      this.enableShadow(ctx, values); // draw the background

      fill(ctx).call(ctx); // disable shadows for other elements.


      this.disableShadow(ctx, values);
      ctx.restore();
      this.performStroke(ctx, values);
    }
    /**
     *
     * @param {number} margin
     * @private
     */

  }, {
    key: "_addBoundingBoxMargin",
    value: function _addBoundingBoxMargin(margin) {
      this.boundingBox.left -= margin;
      this.boundingBox.top -= margin;
      this.boundingBox.bottom += margin;
      this.boundingBox.right += margin;
    }
    /**
     * Actual implementation of this method call.
     *
     * Doing it like this makes it easier to override
     * in the child classes.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_updateBoundingBox",
    value: function _updateBoundingBox(x, y, ctx, selected, hover) {
      if (ctx !== undefined) {
        this.resize(ctx, selected, hover);
      }

      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;
    }
    /**
     * Default implementation of this method call.
     * This acts as a stub which can be overridden.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);
    }
    /**
     * Determine the dimensions to use for nodes with an internal label
     *
     * Currently, these are: Circle, Ellipse, Database, Box
     * The other nodes have external labels, and will not call this method
     *
     * If there is no label, decent default values are supplied.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} [selected]
     * @param {boolean} [hover]
     * @returns {{width:number, height:number}}
     */

  }, {
    key: "getDimensionsFromLabel",
    value: function getDimensionsFromLabel(ctx, selected, hover) {
      // NOTE: previously 'textSize' was not put in 'this' for Ellipse
      // TODO: examine the consequences.
      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
      var width = this.textSize.width;
      var height = this.textSize.height;
      var DEFAULT_SIZE = 14;

      if (width === 0) {
        // This happens when there is no label text set
        width = DEFAULT_SIZE; // use a decent default

        height = DEFAULT_SIZE; // if width zero, then height also always zero
      }

      return {
        width: width,
        height: height
      };
    }
  }]);

  return NodeBase;
}();

function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Box Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Box$1 = /*#__PURE__*/function (_NodeBase) {
  _inherits(Box, _NodeBase);

  var _super = _createSuper$s(Box);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Box(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Box);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Box, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.width = dimensions.width + this.margin.right + this.margin.left;
        this.height = dimensions.height + this.margin.top + this.margin.bottom;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values.borderRadius);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);

      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box

      this._addBoundingBoxMargin(borderRadius);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }

      var borderWidth = this.options.borderWidth;
      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
  }]);

  return Box;
}(NodeBase);

function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * NOTE: This is a bad base class
 *
 * Child classes are:
 *
 *   Image       - uses *only* image methods
 *   Circle      - uses *only* _drawRawCircle
 *   CircleImage - uses all
 *
 * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase
 *       Rename this to ImageBase
 *       Consolidate common code in Image and CircleImage to base class
 *
 * @augments NodeBase
 */

var CircleImageBase = /*#__PURE__*/function (_NodeBase) {
  _inherits(CircleImageBase, _NodeBase);

  var _super = _createSuper$r(CircleImageBase);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function CircleImageBase(options, body, labelModule) {
    var _this;

    _classCallCheck(this, CircleImageBase);

    _this = _super.call(this, options, body, labelModule);
    _this.labelOffset = 0;
    _this.selected = false;
    return _this;
  }
  /**
   *
   * @param {object} options
   * @param {object} [imageObj]
   * @param {object} [imageObjAlt]
   */


  _createClass(CircleImageBase, [{
    key: "setOptions",
    value: function setOptions(options, imageObj, imageObjAlt) {
      this.options = options;

      if (!(imageObj === undefined && imageObjAlt === undefined)) {
        this.setImages(imageObj, imageObjAlt);
      }
    }
    /**
     * Set the images for this node.
     *
     * The images can be updated after the initial setting of options;
     * therefore, this method needs to be reentrant.
     *
     * For correct working in error cases, it is necessary to properly set
     * field 'nodes.brokenImage' in the options.
     *
     * @param {Image} imageObj  required; main image to show for this node
     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
     */

  }, {
    key: "setImages",
    value: function setImages(imageObj, imageObjAlt) {
      if (imageObjAlt && this.selected) {
        this.imageObj = imageObjAlt;
        this.imageObjAlt = imageObj;
      } else {
        this.imageObj = imageObj;
        this.imageObjAlt = imageObjAlt;
      }
    }
    /**
     * Set selection and switch between the base and the selected image.
     *
     * Do the switch only if imageObjAlt exists.
     *
     * @param {boolean} selected value of new selected state for current node
     */

  }, {
    key: "switchImages",
    value: function switchImages(selected) {
      var selection_changed = selected && !this.selected || !selected && this.selected;
      this.selected = selected; // Remember new selection

      if (this.imageObjAlt !== undefined && selection_changed) {
        var imageTmp = this.imageObj;
        this.imageObj = this.imageObjAlt;
        this.imageObjAlt = imageTmp;
      }
    }
    /**
     * Returns Image Padding from node options
     *
     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape
     * @private
     */

  }, {
    key: "_getImagePadding",
    value: function _getImagePadding() {
      var imgPadding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };

      if (this.options.imagePadding) {
        var optImgPadding = this.options.imagePadding;

        if (_typeof(optImgPadding) == "object") {
          imgPadding.top = optImgPadding.top;
          imgPadding.right = optImgPadding.right;
          imgPadding.bottom = optImgPadding.bottom;
          imgPadding.left = optImgPadding.left;
        } else {
          imgPadding.top = optImgPadding;
          imgPadding.right = optImgPadding;
          imgPadding.bottom = optImgPadding;
          imgPadding.left = optImgPadding;
        }
      }

      return imgPadding;
    }
    /**
     * Adjust the node dimensions for a loaded image.
     *
     * Pre: this.imageObj is valid
     */

  }, {
    key: "_resizeImage",
    value: function _resizeImage() {
      var width, height;

      if (this.options.shapeProperties.useImageSize === false) {
        // Use the size property
        var ratio_width = 1;
        var ratio_height = 1; // Only calculate the proper ratio if both width and height not zero

        if (this.imageObj.width && this.imageObj.height) {
          if (this.imageObj.width > this.imageObj.height) {
            ratio_width = this.imageObj.width / this.imageObj.height;
          } else {
            ratio_height = this.imageObj.height / this.imageObj.width;
          }
        }

        width = this.options.size * 2 * ratio_width;
        height = this.options.size * 2 * ratio_height;
      } else {
        // Use the image size with image padding
        var imgPadding = this._getImagePadding();

        width = this.imageObj.width + imgPadding.left + imgPadding.right;
        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;
      }

      this.width = width;
      this.height = height;
      this.radius = 0.5 * this.width;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: "_drawRawCircle",
    value: function _drawRawCircle(ctx, x, y, values) {
      this.initContextForDraw(ctx, values);
      drawCircle(ctx, x, y, values.size);
      this.performFill(ctx, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: "_drawImageAtPosition",
    value: function _drawImageAtPosition(ctx, values) {
      if (this.imageObj.width != 0) {
        // draw the image
        ctx.globalAlpha = values.opacity !== undefined ? values.opacity : 1; // draw shadow if enabled

        this.enableShadow(ctx, values);
        var factor = 1;

        if (this.options.shapeProperties.interpolation === true) {
          factor = this.imageObj.width / this.width / this.body.view.scale;
        }

        var imgPadding = this._getImagePadding();

        var imgPosLeft = this.left + imgPadding.left;
        var imgPosTop = this.top + imgPadding.top;
        var imgWidth = this.width - imgPadding.left - imgPadding.right;
        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;
        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_drawImageLabel",
    value: function _drawImageLabel(ctx, x, y, selected, hover) {
      var offset = 0;

      if (this.height !== undefined) {
        offset = this.height * 0.5;
        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);

        if (labelDimensions.lineCount >= 1) {
          offset += labelDimensions.height / 2;
        }
      }

      var yLabel = y + offset;

      if (this.options.label) {
        this.labelOffset = offset;
      }

      this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
    }
  }]);

  return CircleImageBase;
}(NodeBase);

function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Circle Node/Cluster shape.
 *
 * @augments CircleImageBase
 */

var Circle$1 = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(Circle, _CircleImageBase);

  var _super = _createSuper$q(Circle);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Circle(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Circle);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Circle, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box

        this.width = diameter;
        this.height = diameter;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._drawRawCircle(ctx, x, y, values);

      this.updateBoundingBox(x, y);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.width * 0.5;
    }
  }]);

  return Circle;
}(CircleImageBase);

function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A CircularImage Node/Cluster shape.
 *
 * @augments CircleImageBase
 */

var CircularImage = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(CircularImage, _CircleImageBase);

  var _super = _createSuper$p(CircularImage);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;

    _classCallCheck(this, CircularImage);

    _this = _super.call(this, options, body, labelModule);

    _this.setImages(imageObj, imageObjAlt);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(CircularImage, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var diameter = this.options.size * 2;
        this.width = diameter;
        this.height = diameter;
        this.radius = 0.5 * this.width;
        return;
      } // At this point, an image is present, i.e. this.imageObj is valid.


      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.switchImages(selected);
      this.resize();
      var labelX = x,
          labelY = y;

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      } // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.


      this._drawRawCircle(ctx, labelX, labelY, values); // now we draw in the circle, we save so we can revert the clip operation after drawing.


      ctx.save(); // clip is used to use the stroke in drawRawCircle as an area that we can draw in.

      ctx.clip(); // draw the image

      this._drawImageAtPosition(ctx, values); // restore so we can again draw on the full canvas


      ctx.restore();

      this._drawImageLabel(ctx, labelX, labelY, selected, hover);

      this.updateBoundingBox(x, y);
    } // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here

    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.boundingBox.top = y;
        this.boundingBox.left = x;
        this.boundingBox.right = x + this.options.size * 2;
        this.boundingBox.bottom = y + this.options.size * 2;
      } else {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
      } // TODO: compare with Image.updateBoundingBox(), consolidate?


      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.width * 0.5;
    }
  }]);

  return CircularImage;
}(CircleImageBase);

function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Base class for constructing Node/Cluster Shapes.
 *
 * @augments NodeBase
 */

var ShapeBase = /*#__PURE__*/function (_NodeBase) {
  _inherits(ShapeBase, _NodeBase);

  var _super = _createSuper$o(ShapeBase);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function ShapeBase(options, body, labelModule) {
    _classCallCheck(this, ShapeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   * @param {object} [values={size: this.options.size}]
   */


  _createClass(ShapeBase, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        size: this.options.size
      };

      if (this.needsRefresh(selected, hover)) {
        var _this$customSizeWidth, _this$customSizeHeigh;

        this.labelModule.getTextSize(ctx, selected, hover);
        var size = 2 * values.size;
        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;
        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} shape
     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "_drawShape",
    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {
      var _this = this;

      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      getShape(shape)(ctx, x, y, values.size);
      this.performFill(ctx, values);

      if (this.options.icon !== undefined) {
        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome");
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.options.icon.code, x, y);
        }
      }

      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this.options.label !== undefined) {
            // Need to call following here in order to ensure value for
            // `this.labelModule.size.height`.
            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, "hanging");

            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;

            _this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
          }

          _this.updateBoundingBox(x, y);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
      }
    }
  }]);

  return ShapeBase;
}(NodeBase);

function ownKeys$3(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context = ownKeys$3(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context2 = ownKeys$3(Object(source))).call(_context2, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A CustomShape Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var CustomShape = /*#__PURE__*/function (_ShapeBase) {
  _inherits(CustomShape, _ShapeBase);

  var _super = _createSuper$n(CustomShape);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Function} ctxRenderer
   */
  function CustomShape(options, body, labelModule, ctxRenderer) {
    var _this;

    _classCallCheck(this, CustomShape);

    _this = _super.call(this, options, body, labelModule, ctxRenderer);
    _this.ctxRenderer = ctxRenderer;
    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on different layers.
   */


  _createClass(CustomShape, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2; // Guard right away because someone may just draw in the function itself.

      ctx.save();
      var drawLater = this.ctxRenderer({
        ctx: ctx,
        id: this.options.id,
        x: x,
        y: y,
        state: {
          selected: selected,
          hover: hover
        },
        style: _objectSpread$3({}, values),
        label: this.options.label
      }); // Render the node shape bellow arrows.

      if (drawLater.drawNode != null) {
        drawLater.drawNode();
      }

      ctx.restore();

      if (drawLater.drawExternalLabel) {
        // Guard the external label (above arrows) drawing function.
        var drawExternalLabel = drawLater.drawExternalLabel;

        drawLater.drawExternalLabel = function () {
          ctx.save();
          drawExternalLabel();
          ctx.restore();
        };
      }

      if (drawLater.nodeDimensions) {
        this.customSizeWidth = drawLater.nodeDimensions.width;
        this.customSizeHeight = drawLater.nodeDimensions.height;
      }

      return drawLater;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return CustomShape;
}(ShapeBase);

function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Database Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Database = /*#__PURE__*/function (_NodeBase) {
  _inherits(Database, _NodeBase);

  var _super = _createSuper$m(Database);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Database(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Database);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  _createClass(Database, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var size = dimensions.width + this.margin.right + this.margin.left;
        this.width = size;
        this.height = size;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Database;
}(NodeBase);

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Diamond Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Diamond$1 = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Diamond, _ShapeBase);

  var _super = _createSuper$l(Diamond);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Diamond(options, body, labelModule) {
    _classCallCheck(this, Diamond);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Diamond, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "diamond", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Diamond;
}(ShapeBase);

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Dot Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Dot = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Dot, _ShapeBase);

  var _super = _createSuper$k(Dot);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Dot(options, body, labelModule) {
    _classCallCheck(this, Dot);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Dot, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "circle", 2, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.options.size;
    }
  }]);

  return Dot;
}(ShapeBase);

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Am Ellipse Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Ellipse = /*#__PURE__*/function (_NodeBase) {
  _inherits(Ellipse, _NodeBase);

  var _super = _createSuper$j(Ellipse);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Ellipse(options, body, labelModule) {
    _classCallCheck(this, Ellipse);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Ellipse, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.height = dimensions.height * 2;
        this.width = dimensions.width + dimensions.height;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width * 0.5;
      this.top = y - this.height * 0.5;
      this.initContextForDraw(ctx, values);
      drawEllipse(ctx, this.left, this.top, this.width, this.height);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, x, y, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }

      var a = this.width * 0.5;
      var b = this.height * 0.5;
      var w = Math.sin(angle) * a;
      var h = Math.cos(angle) * b;
      return a * b / Math.sqrt(w * w + h * h);
    }
  }]);

  return Ellipse;
}(NodeBase);

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An icon replacement for the default Node shape.
 *
 * @augments NodeBase
 */

var Icon = /*#__PURE__*/function (_NodeBase) {
  _inherits(Icon, _NodeBase);

  var _super = _createSuper$i(Icon);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Icon(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Icon);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Icon, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.iconSize = {
          width: Number(this.options.icon.size),
          height: Number(this.options.icon.size)
        };
        this.width = this.iconSize.width + this.margin.right + this.margin.left;
        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      var _this2 = this;

      this.resize(ctx, selected, hover);
      this.options.icon.size = this.options.icon.size || 50;
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._icon(ctx, x, y, selected, hover, values);

      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this2.options.label !== undefined) {
            var iconTextSpacing = 5;

            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);
          }

          _this2.updateBoundingBox(x, y);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.icon.size * 0.5;
      this.boundingBox.left = x - this.options.icon.size * 0.5;
      this.boundingBox.right = x + this.options.icon.size * 0.5;
      this.boundingBox.bottom = y + this.options.icon.size * 0.5;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        var iconTextSpacing = 5;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover - Unused
     * @param {ArrowOptions} values
     */

  }, {
    key: "_icon",
    value: function _icon(ctx, x, y, selected, hover, values) {
      var iconSize = Number(this.options.icon.size);

      if (this.options.icon.code !== undefined) {
        ctx.font = [this.options.icon.weight != null ? this.options.icon.weight : selected ? "bold" : "", // If the weight is forced (for example to make Font Awesome 5 work
        // properly) substitute slightly bigger size for bold font face.
        (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + "px", this.options.icon.face].join(" "); // draw icon

        ctx.fillStyle = this.options.icon.color || "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; // draw shadow if enabled

        this.enableShadow(ctx, values);
        ctx.fillText(this.options.icon.code, x, y); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      } else {
        console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Icon;
}(NodeBase);

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An image-based replacement for the default Node shape.
 *
 * @augments CircleImageBase
 */

var Image$2 = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(Image, _CircleImageBase);

  var _super = _createSuper$h(Image);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function Image(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;

    _classCallCheck(this, Image);

    _this = _super.call(this, options, body, labelModule);

    _this.setImages(imageObj, imageObjAlt);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Image, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var side = this.options.size * 2;
        this.width = side;
        this.height = side;
        return;
      }

      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      ctx.save();
      this.switchImages(selected);
      this.resize();
      var labelX = x,
          labelY = y;

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      }

      if (this.options.shapeProperties.useBorderWithImage === true) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);
        ctx.beginPath();
        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        if (values.opacity !== undefined) {
          strokeStyle = overrideOpacity(strokeStyle, values.opacity);
          fillStyle = overrideOpacity(fillStyle, values.opacity);
        } // setup the line properties.


        ctx.strokeStyle = strokeStyle; // set a fillstyle

        ctx.fillStyle = fillStyle; // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image

        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);

        fill(ctx).call(ctx);

        this.performStroke(ctx, values);
        ctx.closePath();
      }

      this._drawImageAtPosition(ctx, values);

      this._drawImageLabel(ctx, labelX, labelY, selected, hover);

      this.updateBoundingBox(x, y);
      ctx.restore();
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.resize();

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      }

      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Image;
}(CircleImageBase);

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Square Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Square = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Square, _ShapeBase);

  var _super = _createSuper$g(Square);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Square(options, body, labelModule) {
    _classCallCheck(this, Square);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Square, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "square", 2, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Square;
}(ShapeBase);

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Hexagon Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Hexagon = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Hexagon, _ShapeBase);

  var _super = _createSuper$f(Hexagon);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Hexagon(options, body, labelModule) {
    _classCallCheck(this, Hexagon);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Hexagon, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "hexagon", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Hexagon;
}(ShapeBase);

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Star Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Star = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Star, _ShapeBase);

  var _super = _createSuper$e(Star);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Star(options, body, labelModule) {
    _classCallCheck(this, Star);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Star, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "star", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Star;
}(ShapeBase);

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A text-based replacement for the default Node shape.
 *
 * @augments NodeBase
 */

var Text = /*#__PURE__*/function (_NodeBase) {
  _inherits(Text, _NodeBase);

  var _super = _createSuper$d(Text);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Text(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Text);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  _createClass(Text, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
        this.width = this.textSize.width + this.margin.right + this.margin.left;
        this.height = this.textSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2; // draw shadow if enabled

      this.enableShadow(ctx, values);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover); // disable shadows for other elements.

      this.disableShadow(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Text;
}(NodeBase);

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Triangle$1 = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Triangle, _ShapeBase);

  var _super = _createSuper$c(Triangle);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Triangle(options, body, labelModule) {
    _classCallCheck(this, Triangle);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Triangle, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "triangle", 3, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Triangle;
}(ShapeBase);

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A downward facing Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var TriangleDown = /*#__PURE__*/function (_ShapeBase) {
  _inherits(TriangleDown, _ShapeBase);

  var _super = _createSuper$b(TriangleDown);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function TriangleDown(options, body, labelModule) {
    _classCallCheck(this, TriangleDown);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(TriangleDown, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "triangleDown", 3, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return TriangleDown;
}(ShapeBase);

function ownKeys$2(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context5, _context6; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context5 = ownKeys$2(Object(source), !0)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context6 = ownKeys$2(Object(source))).call(_context6, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }
/**
 * A node. A node can be connected to other nodes via one or multiple edges.
 */

var Node = /*#__PURE__*/function () {
  /**
   *
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape
   *                              {string} image  An image url
   *                              {string} title  A title text, can be HTML
   *                              {anytype} group A group name or number
   * @param {object} body               Shared state of current network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image
   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options
   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance
   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype
   *                                    for parameter `globalOptions`.
   */
  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    _classCallCheck(this, Node);

    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;
    this.edges = []; // all edges connected to this node
    // set defaults for the options

    this.id = undefined;
    this.imagelist = imagelist;
    this.grouplist = grouplist; // state options

    this.x = undefined;
    this.y = undefined;
    this.baseSize = this.options.size;
    this.baseFontSize = this.options.font.size;
    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate

    this.selected = false;
    this.hover = false;
    this.labelModule = new Label(this.body, this.options, false
    /* Not edge label */
    );
    this.setOptions(options);
  }
  /**
   * Attach a edge to the node
   *
   * @param {Edge} edge
   */


  _createClass(Node, [{
    key: "attachEdge",
    value: function attachEdge(edge) {
      var _context;

      if (indexOf(_context = this.edges).call(_context, edge) === -1) {
        this.edges.push(edge);
      }
    }
    /**
     * Detach a edge from the node
     *
     * @param {Edge} edge
     */

  }, {
    key: "detachEdge",
    value: function detachEdge(edge) {
      var _context2;

      var index = indexOf(_context2 = this.edges).call(_context2, edge);

      if (index != -1) {
        var _context3;

        splice$1(_context3 = this.edges).call(_context3, index, 1);
      }
    }
    /**
     * Set or overwrite options for the node
     *
     * @param {object} options an object with options
     * @returns {null|boolean}
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var currentShape = this.options.shape;

      if (!options) {
        return; // Note that the return value will be 'undefined'! This is OK.
      } // Save the color for later.
      // This is necessary in order to prevent local color from being overwritten by group color.
      // TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.
      // This is not the only problem with current options handling.


      if (typeof options.color !== "undefined") {
        this._localColor = options.color;
      } // basic options


      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (this.id === undefined) {
        throw new Error("Node must have an id");
      }

      Node.checkMass(options, this.id); // set these options locally
      // clear x and y positions

      if (options.x !== undefined) {
        if (options.x === null) {
          this.x = undefined;
          this.predefinedPosition = false;
        } else {
          this.x = _parseInt(options.x);
          this.predefinedPosition = true;
        }
      }

      if (options.y !== undefined) {
        if (options.y === null) {
          this.y = undefined;
          this.predefinedPosition = false;
        } else {
          this.y = _parseInt(options.y);
          this.predefinedPosition = true;
        }
      }

      if (options.size !== undefined) {
        this.baseSize = options.size;
      }

      if (options.value !== undefined) {
        options.value = _parseFloat(options.value);
      } // this transforms all shorthands into fully defined options


      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);
      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("node", pile);

      this._load_images();

      this.updateLabelModule(options); // Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity

      if (options.opacity !== undefined && Node.checkOpacity(options.opacity)) {
        this.options.opacity = options.opacity;
      }

      this.updateShape(currentShape);
      return options.hidden !== undefined || options.physics !== undefined;
    }
    /**
     * Load the images from the options, for the nodes that need them.
     *
     * Images are always loaded, even if they are not used in the current shape.
     * The user may switch to an image shape later on.
     *
     * @private
     */

  }, {
    key: "_load_images",
    value: function _load_images() {
      if (this.options.shape === "circularImage" || this.options.shape === "image") {
        if (this.options.image === undefined) {
          throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
        }
      }

      if (this.options.image === undefined) {
        return;
      }

      if (this.imagelist === undefined) {
        throw new Error("Internal Error: No images provided");
      }

      if (typeof this.options.image === "string") {
        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
      } else {
        if (this.options.image.unselected === undefined) {
          throw new Error("No unselected image provided");
        }

        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);

        if (this.options.image.selected !== undefined) {
          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
        } else {
          this.imageObjAlt = undefined;
        }
      }
    }
    /**
     * Check that opacity is only between 0 and 1
     *
     * @param {number} opacity
     * @returns {boolean}
     */

  }, {
    key: "getFormattingValues",
    value:
    /**
     *
     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
     */
    function getFormattingValues() {
      var values = {
        color: this.options.color.background,
        opacity: this.options.opacity,
        borderWidth: this.options.borderWidth,
        borderColor: this.options.color.border,
        size: this.options.size,
        borderDashes: this.options.shapeProperties.borderDashes,
        borderRadius: this.options.shapeProperties.borderRadius,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y
      };

      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            if (this.options.borderWidthSelected != null) {
              values.borderWidth = this.options.borderWidthSelected;
            } else {
              values.borderWidth *= 2;
            }

            values.color = this.options.color.highlight.background;
            values.borderColor = this.options.color.highlight.border;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            values.color = this.options.color.hover.background;
            values.borderColor = this.options.color.hover.border;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === "function") {
          this.chooser(values, this.options.id, this.selected, this.hover);

          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
      }

      if (this.options.opacity !== undefined) {
        var opacity = this.options.opacity;
        values.borderColor = overrideOpacity(values.borderColor, opacity);
        values.color = overrideOpacity(values.color, opacity);
        values.shadowColor = overrideOpacity(values.shadowColor, opacity);
      }

      return values;
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      if (this.options.label === undefined || this.options.label === null) {
        this.options.label = "";
      }

      Node.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options), {}, {
        color: options && options.color || this._localColor || undefined
      }), this.grouplist); //
      // Note:The prototype chain for this.options is:
      //
      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions
      //                 (also: this.globalOptions)
      //
      // Note that the prototypes are mentioned explicitly in the pile list below;
      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.
      // This is a good indication that the prototype usage of options is deficient.
      //

      var currentGroup = this.grouplist.get(this.options.group, false);
      var pile = [options, // new options
      this.options, // current node options, see comment above for prototype
      currentGroup, // group options, if any
      this.globalOptions, // Currently set global node options
      this.defaultOptions // Default global node options
      ];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     *
     * @param {string} currentShape
     */

  }, {
    key: "updateShape",
    value: function updateShape(currentShape) {
      if (currentShape === this.options.shape && this.shape) {
        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
      } else {
        // choose draw method depending on the shape
        switch (this.options.shape) {
          case "box":
            this.shape = new Box$1(this.options, this.body, this.labelModule);
            break;

          case "circle":
            this.shape = new Circle$1(this.options, this.body, this.labelModule);
            break;

          case "circularImage":
            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;

          case "custom":
            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);
            break;

          case "database":
            this.shape = new Database(this.options, this.body, this.labelModule);
            break;

          case "diamond":
            this.shape = new Diamond$1(this.options, this.body, this.labelModule);
            break;

          case "dot":
            this.shape = new Dot(this.options, this.body, this.labelModule);
            break;

          case "ellipse":
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;

          case "icon":
            this.shape = new Icon(this.options, this.body, this.labelModule);
            break;

          case "image":
            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;

          case "square":
            this.shape = new Square(this.options, this.body, this.labelModule);
            break;

          case "hexagon":
            this.shape = new Hexagon(this.options, this.body, this.labelModule);
            break;

          case "star":
            this.shape = new Star(this.options, this.body, this.labelModule);
            break;

          case "text":
            this.shape = new Text(this.options, this.body, this.labelModule);
            break;

          case "triangle":
            this.shape = new Triangle$1(this.options, this.body, this.labelModule);
            break;

          case "triangleDown":
            this.shape = new TriangleDown(this.options, this.body, this.labelModule);
            break;

          default:
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
        }
      }

      this.needsRefresh();
    }
    /**
     * select this node
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
      this.needsRefresh();
    }
    /**
     * unselect this node
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
      this.needsRefresh();
    }
    /**
     * Reset the calculated size of the node, forces it to recalculate its size
     */

  }, {
    key: "needsRefresh",
    value: function needsRefresh() {
      this.shape.refreshNeeded = true;
    }
    /**
     * get the title of this node.
     *
     * @returns {string} title    The title of the node, or undefined when no title
     *                           has been set.
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.options.title;
    }
    /**
     * Calculate the distance to the border of the Node
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {number} angle        Angle in radians
     * @returns {number} distance   Distance to the border in pixels
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this.shape.distanceToBorder(ctx, angle);
    }
    /**
     * Check if this node has a fixed x and y position
     *
     * @returns {boolean}      true if fixed, false if not
     */

  }, {
    key: "isFixed",
    value: function isFixed() {
      return this.options.fixed.x && this.options.fixed.y;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the node. Can be undefined
     *
     * @returns {number} value
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */

  }, {
    key: "getLabelSize",
    value: function getLabelSize() {
      return this.labelModule.size();
    }
    /**
     * Adjust the value range of the node. The node will adjust it's size
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var sizeDiff = this.options.scaling.max - this.options.scaling.min;

        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }

        this.options.size = this.options.scaling.min + scale * sizeDiff;
      } else {
        this.options.size = this.baseSize;
        this.options.font.size = this.baseFontSize;
      }

      this.updateLabelModule();
    }
    /**
     * Draw this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var values = this.getFormattingValues();
      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values) || {};
    }
    /**
     * Update the bounding box of the shape
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(ctx) {
      this.shape.updateBoundingBox(this.x, this.y, ctx);
    }
    /**
     * Recalculate the size of this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "resize",
    value: function resize(ctx) {
      var values = this.getFormattingValues();
      this.shape.resize(ctx, this.selected, this.hover, values);
    }
    /**
     * Determine all visual elements of this node instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        if (pointInRect(this.labelModule.getSize(), point)) {
          ret.push({
            nodeId: this.id,
            labelId: 0
          });
        }
      }

      if (pointInRect(this.shape.boundingBox, point)) {
        ret.push({
          nodeId: this.id
        });
      }

      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */

  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */

  }, {
    key: "isBoundingBoxOverlappingWith",
    value: function isBoundingBoxOverlappingWith(obj) {
      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
    }
    /**
     * Check valid values for mass
     *
     * The mass may not be negative or zero. If it is, reset to 1
     *
     * @param {object} options
     * @param {Node.id} id
     * @static
     */

  }], [{
    key: "checkOpacity",
    value: function checkOpacity(opacity) {
      return 0 <= opacity && opacity <= 1;
    }
    /**
     * Check that origin is 'center' or 'top-left'
     *
     * @param {string} origin
     * @returns {boolean}
     */

  }, {
    key: "checkCoordinateOrigin",
    value: function checkCoordinateOrigin(origin) {
      return origin === undefined || origin === "center" || origin === "top-left";
    }
    /**
     * Copy group option values into the node options.
     *
     * The group options override the global node options, so the copy of group options
     *  must happen *after* the global node options have been set.
     *
     * This method must also be called also if the global node options have changed and the group options did not.
     *
     * @param {object} parentOptions
     * @param {object} newOptions  new values for the options, currently only passed in for check
     * @param {object} groupList
     */

  }, {
    key: "updateGroupOptions",
    value: function updateGroupOptions(parentOptions, newOptions, groupList) {
      var _context4;

      if (groupList === undefined) return; // No groups, nothing to do

      var group = parentOptions.group; // paranoia: the selected group is already merged into node options, check.

      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {
        throw new Error("updateGroupOptions: group values in options don't match.");
      }

      var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
      if (!hasGroup) return; // current node has no group, no need to merge

      var groupObj = groupList.get(group);

      if (groupObj.opacity !== undefined && newOptions.opacity === undefined) {
        if (!Node.checkOpacity(groupObj.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + groupObj.opacity);
          groupObj.opacity = undefined;
        }
      } // Skip any new option to avoid them being overridden by the group options.


      var skipProperties = filter(_context4 = getOwnPropertyNames(newOptions)).call(_context4, function (p) {
        return newOptions[p] != null;
      }); // Always skip merging group font options into parent; these are required to be distinct for labels


      skipProperties.push("font");
      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj); // the color object needs to be completely defined.
      // Since groups can partially overwrite the colors, we parse it again, just in case.

      parentOptions.color = parseColor(parentOptions.color);
    }
    /**
     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
     * Static so it can also be used by the handler.
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {object} [groupList]
     * @static
     */

  }, {
    key: "parseOptions",
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var groupList = arguments.length > 4 ? arguments[4] : undefined;
      var fields = ["color", "fixed", "shadow"];
      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
      Node.checkMass(newOptions);

      if (parentOptions.opacity !== undefined) {
        if (!Node.checkOpacity(parentOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + parentOptions.opacity);
          parentOptions.opacity = undefined;
        }
      }

      if (newOptions.opacity !== undefined) {
        if (!Node.checkOpacity(newOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + newOptions.opacity);
          newOptions.opacity = undefined;
        }
      }

      if (newOptions.shapeProperties && !Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {
        console.error("Invalid option for node coordinateOrigin, found: " + newOptions.shapeProperties.coordinateOrigin);
      } // merge the shadow options into the parent.


      mergeOptions(parentOptions, newOptions, "shadow", globalOptions); // individual shape newOptions

      if (newOptions.color !== undefined && newOptions.color !== null) {
        var parsedColor = parseColor(newOptions.color);
        fillIfDefined(parentOptions.color, parsedColor);
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options
      } // handle the fixed options


      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
        if (typeof newOptions.fixed === "boolean") {
          parentOptions.fixed.x = newOptions.fixed;
          parentOptions.fixed.y = newOptions.fixed;
        } else {
          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === "boolean") {
            parentOptions.fixed.x = newOptions.fixed.x;
          }

          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === "boolean") {
            parentOptions.fixed.y = newOptions.fixed.y;
          }
        }
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options
      }

      Node.updateGroupOptions(parentOptions, newOptions, groupList); // handle the scaling options, specifically the label part

      if (newOptions.scaling !== undefined) {
        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      }
    }
  }, {
    key: "checkMass",
    value: function checkMass(options, id) {
      if (options.mass !== undefined && options.mass <= 0) {
        var strId = "";

        if (id !== undefined) {
          strId = " in node id: " + id;
        }

        console.error("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", VALIDATOR_PRINT_STYLE);
        options.mass = 1;
      }
    }
  }]);

  return Node;
}();

function _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$6(o, minLen) { var _context4; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = slice(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Handler for Nodes
 */

var NodesHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Images} images
   * @param {Array.<Group>} groups
   * @param {LayoutEngine} layoutEngine
   */
  function NodesHandler(body, images, groups, layoutEngine) {
    var _context,
        _this = this;

    _classCallCheck(this, NodesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups;
    this.layoutEngine = layoutEngine; // create the node API in the body container

    this.body.functions.createNode = bind$6(_context = this.create).call(_context, this);
    this.nodesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items, params.data, params.oldData);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };
    this.defaultOptions = {
      borderWidth: 1,
      borderWidthSelected: undefined,
      brokenImage: undefined,
      color: {
        border: "#2B7CE9",
        background: "#97C2FC",
        highlight: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        },
        hover: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        }
      },
      opacity: undefined,
      // number between 0 and 1
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 0,
        // px
        strokeColor: "#ffffff",
        align: "center",
        vadjust: 0,
        multi: false,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "monospace",
          vadjust: 2
        }
      },
      group: undefined,
      hidden: false,
      icon: {
        face: "FontAwesome",
        //'FontAwesome',
        code: undefined,
        //'\uf007',
        size: 50,
        //50,
        color: "#2B7CE9" //'#aa00ff'

      },
      image: undefined,
      // --> URL
      imagePadding: {
        // only for image shape
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      label: undefined,
      labelHighlightBold: true,
      level: undefined,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      mass: 1,
      physics: true,
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: false,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      shape: "ellipse",
      shapeProperties: {
        borderDashes: false,
        // only for borders
        borderRadius: 6,
        // only for box shape
        interpolation: true,
        // only for image and circularImage shapes
        useImageSize: false,
        // only for image and circularImage shapes
        useBorderWithImage: false,
        // only for image shape
        coordinateOrigin: "center" // only for image and circularImage shapes

      },
      size: 25,
      title: undefined,
      value: undefined,
      x: undefined,
      y: undefined
    }; // Protect from idiocy

    if (this.defaultOptions.mass <= 0) {
      throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
    }

    this.options = bridgeObject(this.defaultOptions);
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(NodesHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _context2,
          _context3,
          _this2 = this;

      // refresh the nodes. Used when reverting from hierarchical layout
      this.body.emitter.on("refreshNodes", bind$6(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", bind$6(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function () {
        forEach$1(_this2.nodesListeners, function (callback, event) {
          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
        });
        delete _this2.body.functions.createNode;
        delete _this2.nodesListeners.add;
        delete _this2.nodesListeners.update;
        delete _this2.nodesListeners.remove;
        delete _this2.nodesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        Node.parseOptions(this.options, options); // Need to set opacity here because Node.parseOptions is also used for groups,
        // if you set opacity in Node.parseOptions it overwrites group opacity.

        if (options.opacity !== undefined) {
          if (isNan(options.opacity) || !_isFinite(options.opacity) || options.opacity < 0 || options.opacity > 1) {
            console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + options.opacity);
          } else {
            this.options.opacity = options.opacity;
          }
        } // update the shape in all nodes


        if (options.shape !== undefined) {
          for (var nodeId in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
              this.body.nodes[nodeId].updateShape();
            }
          }
        } // Update the labels of nodes if any relevant options changed.


        if (typeof options.font !== "undefined" || typeof options.widthConstraint !== "undefined" || typeof options.heightConstraint !== "undefined") {
          for (var _i = 0, _Object$keys = keys$4(this.body.nodes); _i < _Object$keys.length; _i++) {
            var _nodeId = _Object$keys[_i];

            this.body.nodes[_nodeId].updateLabelModule();

            this.body.nodes[_nodeId].needsRefresh();
          }
        } // update the shape size in all nodes


        if (options.size !== undefined) {
          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.body.nodes[_nodeId2].needsRefresh();
            }
          }
        } // update the state of the variables if needed


        if (options.hidden !== undefined || options.physics !== undefined) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Set a data set with nodes for the network
     *
     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */

  }, {
    key: "setData",
    value: function setData(nodes) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var oldNodesData = this.body.data.nodes;

      if (isDataViewLike("id", nodes)) {
        this.body.data.nodes = nodes;
      } else if (isArray$2(nodes)) {
        this.body.data.nodes = new DataSet();
        this.body.data.nodes.add(nodes);
      } else if (!nodes) {
        this.body.data.nodes = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      }

      if (oldNodesData) {
        // unsubscribe from old dataset
        forEach$1(this.nodesListeners, function (callback, event) {
          oldNodesData.off(event, callback);
        });
      } // remove drawn nodes


      this.body.nodes = {};

      if (this.body.data.nodes) {
        // subscribe to new dataset
        var me = this;
        forEach$1(this.nodesListeners, function (callback, event) {
          me.body.data.nodes.on(event, callback);
        }); // draw all new nodes

        var ids = this.body.data.nodes.getIds();
        this.add(ids, true);
      }

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add nodes
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: "add",
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var id;
      var newNodes = [];

      for (var i = 0; i < ids.length; i++) {
        id = ids[i];
        var properties = this.body.data.nodes.get(id);
        var node = this.create(properties);
        newNodes.push(node);
        this.body.nodes[id] = node; // note: this may replace an existing node
      }

      this.layoutEngine.positionInitially(newNodes);

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing nodes, or create them when not yet existing
     *
     * @param {number[] | string[]} ids id's of changed nodes
     * @param {Array} changedData array with changed data
     * @param {Array|undefined} oldData optional; array with previous data
     * @private
     */

  }, {
    key: "update",
    value: function update(ids, changedData, oldData) {
      var nodes = this.body.nodes;
      var dataChanged = false;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var node = nodes[id];
        var data = changedData[i];

        if (node !== undefined) {
          // update node
          if (node.setOptions(data)) {
            dataChanged = true;
          }
        } else {
          dataChanged = true; // create node

          node = this.create(data);
          nodes[id] = node;
        }
      }

      if (!dataChanged && oldData !== undefined) {
        // Check for any changes which should trigger a layout recalculation
        // For now, this is just 'level' for hierarchical layout
        // Assumption: old and new data arranged in same order; at time of writing, this holds.
        dataChanged = some(changedData).call(changedData, function (newValue, index) {
          var oldValue = oldData[index];
          return oldValue && oldValue.level !== newValue.level;
        });
      }

      if (dataChanged === true) {
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing nodes. If nodes do not exist, the method will just ignore it.
     *
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: "remove",
    value: function remove(ids) {
      var nodes = this.body.nodes;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        delete nodes[id];
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * create a node
     *
     * @param {object} properties
     * @param {class} [constructorClass=Node.default]
     * @returns {*}
     */

  }, {
    key: "create",
    value: function create(properties) {
      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;
      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
    }
    /**
     *
     * @param {boolean} [clearPositions=false]
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;

      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      forEach$1(this.body.nodes, function (node, nodeId) {
        var data = _this3.body.data.nodes.get(nodeId);

        if (data !== undefined) {
          if (clearPositions === true) {
            node.setOptions({
              x: null,
              y: null
            });
          }

          node.setOptions({
            fixed: false
          });
          node.setOptions(data);
        }
      });
    }
    /**
     * Returns the positions of the nodes.
     *
     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */

  }, {
    key: "getPositions",
    value: function getPositions(ids) {
      var dataArray = {};

      if (ids !== undefined) {
        if (isArray$2(ids) === true) {
          for (var i = 0; i < ids.length; i++) {
            if (this.body.nodes[ids[i]] !== undefined) {
              var node = this.body.nodes[ids[i]];
              dataArray[ids[i]] = {
                x: Math.round(node.x),
                y: Math.round(node.y)
              };
            }
          }
        } else {
          if (this.body.nodes[ids] !== undefined) {
            var _node = this.body.nodes[ids];
            dataArray[ids] = {
              x: Math.round(_node.x),
              y: Math.round(_node.y)
            };
          }
        }
      } else {
        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {
          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];
          dataArray[this.body.nodeIndices[_i2]] = {
            x: Math.round(_node2.x),
            y: Math.round(_node2.y)
          };
        }
      }

      return dataArray;
    }
    /**
     * Retrieves the x y position of a specific id.
     *
     * @param {string} id The id to retrieve.
     * @throws {TypeError} If no id is included.
     * @throws {ReferenceError} If an invalid id is provided.
     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.
     */

  }, {
    key: "getPosition",
    value: function getPosition(id) {
      if (id == undefined) {
        throw new TypeError("No id was specified for getPosition method.");
      } else if (this.body.nodes[id] == undefined) {
        throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(id));
      } else {
        return {
          x: Math.round(this.body.nodes[id].x),
          y: Math.round(this.body.nodes[id].y)
        };
      }
    }
    /**
     * Load the XY positions of the nodes into the dataset.
     */

  }, {
    key: "storePositions",
    value: function storePositions() {
      // todo: add support for clusters and hierarchical.
      var dataArray = [];
      var dataset = this.body.data.nodes.getDataSet();

      var _iterator = _createForOfIteratorHelper$6(dataset.get()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dsNode = _step.value;
          var id = dsNode.id;
          var bodyNode = this.body.nodes[id];
          var x = Math.round(bodyNode.x);
          var y = Math.round(bodyNode.y);

          if (dsNode.x !== x || dsNode.y !== y) {
            dataArray.push({
              id: id,
              x: x,
              y: y
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      dataset.update(dataArray);
    }
    /**
     * get the bounding box of a node.
     *
     * @param {Node.id} nodeId
     * @returns {j|*}
     */

  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].shape.boundingBox;
      }
    }
    /**
     * Get the Ids of nodes connected to this node.
     *
     * @param {Node.id} nodeId
     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
     *                                          Any other value returns both parent and child nodes.
     * @returns {Array}
     */

  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(nodeId, direction) {
      var nodeList = [];

      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];
        var nodeObj = {}; // used to quickly check if node already exists

        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];

          if (direction !== "to" && edge.toId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.fromId] === undefined) {
              nodeList.push(edge.fromId);
              nodeObj[edge.fromId] = true;
            }
          } else if (direction !== "from" && edge.fromId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.toId] === undefined) {
              nodeList.push(edge.toId);
              nodeObj[edge.toId] = true;
            }
          }
        }
      }

      return nodeList;
    }
    /**
     * Get the ids of the edges connected to this node.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: "getConnectedEdges",
    value: function getConnectedEdges(nodeId) {
      var edgeList = [];

      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];

        for (var i = 0; i < node.edges.length; i++) {
          edgeList.push(node.edges[i].id);
        }
      } else {
        console.error("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
      }

      return edgeList;
    }
    /**
     * Move a node.
     *
     * @param {Node.id} nodeId
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "moveNode",
    value: function moveNode(nodeId, x, y) {
      var _this4 = this;

      if (this.body.nodes[nodeId] !== undefined) {
        this.body.nodes[nodeId].x = Number(x);
        this.body.nodes[nodeId].y = Number(y);

        setTimeout$1(function () {
          _this4.body.emitter.emit("startSimulation");
        }, 0);
      } else {
        console.error("Node id supplied to moveNode does not exist. Provided: ", nodeId);
      }
    }
  }]);

  return NodesHandler;
}();

var hasOwn$1 = hasOwnProperty_1;

var isDataDescriptor$1 = function (descriptor) {
  return descriptor !== undefined && (hasOwn$1(descriptor, 'value') || hasOwn$1(descriptor, 'writable'));
};

var $$2 = _export;
var call = functionCall;
var isObject$2 = isObject$j;
var anObject$1 = anObject$d;
var isDataDescriptor = isDataDescriptor$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var getPrototypeOf = objectGetPrototypeOf; // `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get

function get$5(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject$1(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
  if (isObject$2(prototype = getPrototypeOf(target))) return get$5(prototype, propertyKey, receiver);
}

$$2({
  target: 'Reflect',
  stat: true
}, {
  get: get$5
});

var path$3 = path$y;
var get$4 = path$3.Reflect.get;

var parent$7 = get$4;
var get$3 = parent$7;

var parent$6 = get$3;
var get$2 = parent$6;

var parent$5 = get$2;
var get$1 = parent$5;

var get = get$1;

var parent$4 = getOwnPropertyDescriptor$4;
var getOwnPropertyDescriptor$2 = parent$4;

var parent$3 = getOwnPropertyDescriptor$2;
var getOwnPropertyDescriptor$1 = parent$3;

var getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && get) {
    _get = get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;

      var desc = getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

var $$1 = _export; // eslint-disable-next-line es/no-math-hypot -- required for testing

var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt; // Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546

var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot

$$1({
  target: 'Math',
  stat: true,
  forced: BUGGY
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});

var path$2 = path$y;
var hypot$2 = path$2.Math.hypot;

var parent$2 = hypot$2;
var hypot$1 = parent$2;

var hypot = hypot$1;

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Common methods for endpoints
 *
 * @class
 */

var EndPoint = /*#__PURE__*/function () {
  function EndPoint() {
    _classCallCheck(this, EndPoint);
  }

  _createClass(EndPoint, null, [{
    key: "transform",
    value:
    /**
     * Apply transformation on points for display.
     *
     * The following is done:
     * - rotate by the specified angle
     * - multiply the (normalized) coordinates by the passed length
     * - offset by the target coordinates
     *
     * @param points - The point(s) to be transformed.
     * @param arrowData - The data determining the result of the transformation.
     */
    function transform(points, arrowData) {
      if (!isArray$2(points)) {
        points = [points];
      }

      var x = arrowData.point.x;
      var y = arrowData.point.y;
      var angle = arrowData.angle;
      var length = arrowData.length;

      for (var i = 0; i < points.length; ++i) {
        var p = points[i];
        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);
        p.x = x + length * xt;
        p.y = y + length * yt;
      }
    }
    /**
     * Draw a closed path using the given real coordinates.
     *
     * @param ctx - The path will be rendered into this context.
     * @param points - The points of the path.
     */

  }, {
    key: "drawPath",
    value: function drawPath(ctx, points) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);

      for (var i = 1; i < points.length; ++i) {
        ctx.lineTo(points[i].x, points[i].y);
      }

      ctx.closePath();
    }
  }]);

  return EndPoint;
}();
/**
 * Drawing methods for the arrow endpoint.
 */


var Image$1 = /*#__PURE__*/function (_EndPoint) {
  _inherits(Image, _EndPoint);

  var _super = _createSuper$a(Image);

  function Image() {
    _classCallCheck(this, Image);

    return _super.apply(this, arguments);
  }

  _createClass(Image, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns False as there is no way to fill an image.
     */
    function draw(ctx, arrowData) {
      if (arrowData.image) {
        ctx.save();
        ctx.translate(arrowData.point.x, arrowData.point.y);
        ctx.rotate(Math.PI / 2 + arrowData.angle);
        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;
        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;
        arrowData.image.drawImageAtPosition(ctx, 1, // scale
        -width / 2, // x
        0, // y
        width, height);
        ctx.restore();
      }

      return false;
    }
  }]);

  return Image;
}(EndPoint);
/**
 * Drawing methods for the arrow endpoint.
 */


var Arrow = /*#__PURE__*/function (_EndPoint2) {
  _inherits(Arrow, _EndPoint2);

  var _super2 = _createSuper$a(Arrow);

  function Arrow() {
    _classCallCheck(this, Arrow);

    return _super2.apply(this, arguments);
  }

  _createClass(Arrow, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0,
        y: 0
      }, {
        x: -1,
        y: 0.3
      }, {
        x: -0.9,
        y: 0
      }, {
        x: -1,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Arrow;
}(EndPoint);
/**
 * Drawing methods for the crow endpoint.
 */


var Crow = /*#__PURE__*/function () {
  function Crow() {
    _classCallCheck(this, Crow);
  }

  _createClass(Crow, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: -1,
        y: 0
      }, {
        x: 0,
        y: 0.3
      }, {
        x: -0.4,
        y: 0
      }, {
        x: 0,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Crow;
}();
/**
 * Drawing methods for the curve endpoint.
 */


var Curve = /*#__PURE__*/function () {
  function Curve() {
    _classCallCheck(this, Curve);
  }

  _createClass(Curve, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = {
        x: -0.4,
        y: 0
      };
      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.

      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Define curve endpoint as semicircle.

      var pi = Math.PI;
      var startAngle = arrowData.angle - pi / 2;
      var endAngle = arrowData.angle + pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
      ctx.stroke();
      return true;
    }
  }]);

  return Curve;
}();
/**
 * Drawing methods for the inverted curve endpoint.
 */


var InvertedCurve = /*#__PURE__*/function () {
  function InvertedCurve() {
    _classCallCheck(this, InvertedCurve);
  }

  _createClass(InvertedCurve, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = {
        x: -0.3,
        y: 0
      };
      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.

      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Define inverted curve endpoint as semicircle.

      var pi = Math.PI;
      var startAngle = arrowData.angle + pi / 2;
      var endAngle = arrowData.angle + 3 * pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
      ctx.stroke();
      return true;
    }
  }]);

  return InvertedCurve;
}();
/**
 * Drawing methods for the trinagle endpoint.
 */


var Triangle = /*#__PURE__*/function () {
  function Triangle() {
    _classCallCheck(this, Triangle);
  }

  _createClass(Triangle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0.02,
        y: 0
      }, {
        x: -1,
        y: 0.3
      }, {
        x: -1,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Triangle;
}();
/**
 * Drawing methods for the inverted trinagle endpoint.
 */


var InvertedTriangle = /*#__PURE__*/function () {
  function InvertedTriangle() {
    _classCallCheck(this, InvertedTriangle);
  }

  _createClass(InvertedTriangle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0,
        y: 0.3
      }, {
        x: 0,
        y: -0.3
      }, {
        x: -1,
        y: 0
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return InvertedTriangle;
}();
/**
 * Drawing methods for the circle endpoint.
 */


var Circle = /*#__PURE__*/function () {
  function Circle() {
    _classCallCheck(this, Circle);
  }

  _createClass(Circle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var point = {
        x: -0.4,
        y: 0
      };
      EndPoint.transform(point, arrowData);
      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);
      return true;
    }
  }]);

  return Circle;
}();
/**
 * Drawing methods for the bar endpoint.
 */


var Bar = /*#__PURE__*/function () {
  function Bar() {
    _classCallCheck(this, Bar);
  }

  _createClass(Bar, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      /*
      var points = [
        {x:0, y:0.5},
        {x:0, y:-0.5}
      ];
           EndPoint.transform(points, arrowData);
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.stroke();
      */
      var points = [{
        x: 0,
        y: 0.5
      }, {
        x: 0,
        y: -0.5
      }, {
        x: -0.15,
        y: -0.5
      }, {
        x: -0.15,
        y: 0.5
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Bar;
}();
/**
 * Drawing methods for the box endpoint.
 */


var Box = /*#__PURE__*/function () {
  function Box() {
    _classCallCheck(this, Box);
  }

  _createClass(Box, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var points = [{
        x: 0,
        y: 0.3
      }, {
        x: 0,
        y: -0.3
      }, {
        x: -0.6,
        y: -0.3
      }, {
        x: -0.6,
        y: 0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Box;
}();
/**
 * Drawing methods for the diamond endpoint.
 */


var Diamond = /*#__PURE__*/function () {
  function Diamond() {
    _classCallCheck(this, Diamond);
  }

  _createClass(Diamond, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var points = [{
        x: 0,
        y: 0
      }, {
        x: -0.5,
        y: -0.3
      }, {
        x: -1,
        y: 0
      }, {
        x: -0.5,
        y: 0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Diamond;
}();
/**
 * Drawing methods for the vee endpoint.
 */


var Vee = /*#__PURE__*/function () {
  function Vee() {
    _classCallCheck(this, Vee);
  }

  _createClass(Vee, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: -1,
        y: 0.3
      }, {
        x: -0.5,
        y: 0
      }, {
        x: -1,
        y: -0.3
      }, {
        x: 0,
        y: 0
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Vee;
}();
/**
 * Drawing methods for the endpoints.
 */


var EndPoints = /*#__PURE__*/function () {
  function EndPoints() {
    _classCallCheck(this, EndPoints);
  }

  _createClass(EndPoints, null, [{
    key: "draw",
    value:
    /**
     * Draw an endpoint.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.
     */
    function draw(ctx, arrowData) {
      var type;

      if (arrowData.type) {
        type = arrowData.type.toLowerCase();
      }

      switch (type) {
        case "image":
          return Image$1.draw(ctx, arrowData);

        case "circle":
          return Circle.draw(ctx, arrowData);

        case "box":
          return Box.draw(ctx, arrowData);

        case "crow":
          return Crow.draw(ctx, arrowData);

        case "curve":
          return Curve.draw(ctx, arrowData);

        case "diamond":
          return Diamond.draw(ctx, arrowData);

        case "inv_curve":
          return InvertedCurve.draw(ctx, arrowData);

        case "triangle":
          return Triangle.draw(ctx, arrowData);

        case "inv_triangle":
          return InvertedTriangle.draw(ctx, arrowData);

        case "bar":
          return Bar.draw(ctx, arrowData);

        case "vee":
          return Vee.draw(ctx, arrowData);

        case "arrow": // fall-through

        default:
          return Arrow.draw(ctx, arrowData);
      }
    }
  }]);

  return EndPoints;
}();

function ownKeys$1(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context2 = ownKeys$1(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context3 = ownKeys$1(Object(source))).call(_context3, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }
/**
 * The Base Class for all edges.
 */

var EdgeBase = /*#__PURE__*/function () {
  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param _body - The body of the network.
   * @param _labelModule - Label module.
   */
  function EdgeBase(options, _body, _labelModule) {
    _classCallCheck(this, EdgeBase);

    this._body = _body;
    this._labelModule = _labelModule;
    this.color = {};
    this.colorDirty = true;
    this.hoverWidth = 1.5;
    this.selectionWidth = 2;
    this.setOptions(options);
    this.fromPoint = this.from;
    this.toPoint = this.to;
  }
  /** @inheritDoc */


  _createClass(EdgeBase, [{
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
    }
    /** @inheritDoc */

  }, {
    key: "cleanup",
    value: function cleanup() {
      return false;
    }
    /**
     * Set new edge options.
     *
     * @param options - The new edge options object.
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
      this.id = this.options.id;
    }
    /** @inheritDoc */

  }, {
    key: "drawLine",
    value: function drawLine(ctx, values, _selected, _hover) {
      var viaNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.getViaNode();
      // set style
      ctx.strokeStyle = this.getColor(ctx, values);
      ctx.lineWidth = values.width;

      if (values.dashes !== false) {
        this._drawDashedLine(ctx, values, viaNode);
      } else {
        this._drawLine(ctx, values, viaNode);
      }
    }
    /**
     * Draw a line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param fromPoint - TODO: Seems ignored, remove?
     * @param toPoint - TODO: Seems ignored, remove?
     */

  }, {
    key: "_drawLine",
    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {
      if (this.from != this.to) {
        // draw line
        this._line(ctx, values, viaNode, fromPoint, toPoint);
      } else {
        var _this$_getCircleData = this._getCircleData(ctx),
            _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),
            x = _this$_getCircleData2[0],
            y = _this$_getCircleData2[1],
            radius = _this$_getCircleData2[2];

        this._circle(ctx, values, x, y, radius);
      }
    }
    /**
     * Draw a dashed line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param _fromPoint - Ignored (TODO: remove in the future).
     * @param _toPoint - Ignored (TODO: remove in the future).
     */

  }, {
    key: "_drawDashedLine",
    value: function _drawDashedLine(ctx, values, viaNode, _fromPoint, _toPoint) {
      ctx.lineCap = "round";
      var pattern = isArray$2(values.dashes) ? values.dashes : [5, 5]; // only firefox and chrome support this method, else we use the legacy one.

      if (ctx.setLineDash !== undefined) {
        ctx.save(); // set dash settings for chrome or firefox

        ctx.setLineDash(pattern);
        ctx.lineDashOffset = 0; // draw the line

        if (this.from != this.to) {
          // draw line
          this._line(ctx, values, viaNode);
        } else {
          var _this$_getCircleData3 = this._getCircleData(ctx),
              _this$_getCircleData4 = _slicedToArray(_this$_getCircleData3, 3),
              x = _this$_getCircleData4[0],
              y = _this$_getCircleData4[1],
              radius = _this$_getCircleData4[2];

          this._circle(ctx, values, x, y, radius);
        } // restore the dash settings.


        ctx.setLineDash([0]);
        ctx.lineDashOffset = 0;
        ctx.restore();
      } else {
        // unsupporting smooth lines
        if (this.from != this.to) {
          // draw line
          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);
        } else {
          var _this$_getCircleData5 = this._getCircleData(ctx),
              _this$_getCircleData6 = _slicedToArray(_this$_getCircleData5, 3),
              _x = _this$_getCircleData6[0],
              _y = _this$_getCircleData6[1],
              _radius = _this$_getCircleData6[2];

          this._circle(ctx, values, _x, _y, _radius);
        } // draw shadow if enabled


        this.enableShadow(ctx, values);
        ctx.stroke(); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      }
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @param node - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */

  }, {
    key: "findBorderPosition",
    value: function findBorderPosition(node, ctx, options) {
      if (this.from != this.to) {
        return this._findBorderPosition(node, ctx, options);
      } else {
        return this._findBorderPositionCircle(node, ctx, options);
      }
    }
    /** @inheritDoc */

  }, {
    key: "findBorderPositions",
    value: function findBorderPositions(ctx) {
      if (this.from != this.to) {
        return {
          from: this._findBorderPosition(this.from, ctx),
          to: this._findBorderPosition(this.to, ctx)
        };
      } else {
        var _context;

        var _this$_getCircleData$ = slice(_context = this._getCircleData(ctx)).call(_context, 0, 2),
            _this$_getCircleData$2 = _slicedToArray(_this$_getCircleData$, 2),
            x = _this$_getCircleData$2[0],
            y = _this$_getCircleData$2[1];

        return {
          from: this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: 0.25,
            high: 0.6,
            direction: -1
          }),
          to: this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: 0.6,
            high: 0.8,
            direction: 1
          })
        };
      }
    }
    /**
     * Compute the center point and radius of an edge connected to the same node at both ends.
     *
     * @param ctx - The context that will be used for rendering.
     * @returns `[x, y, radius]`
     */

  }, {
    key: "_getCircleData",
    value: function _getCircleData(ctx) {
      var radius = this.options.selfReference.size;

      if (ctx !== undefined) {
        if (this.from.shape.width === undefined) {
          this.from.shape.resize(ctx);
        }
      } // get circle coordinates


      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);
      return [coordinates.x, coordinates.y, radius];
    }
    /**
     * Get a point on a circle.
     *
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     * @param position - Value between 0 (line start) and 1 (line end).
     * @returns Cartesian coordinates of requested point on the circle.
     */

  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x, y, radius, position) {
      var angle = position * 2 * Math.PI;
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @remarks
     * This function uses binary search to look for the point where the circle crosses the border of the node.
     * @param nearNode - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */

  }, {
    key: "_findBorderPositionCircle",
    value: function _findBorderPositionCircle(nearNode, ctx, options) {
      var x = options.x;
      var y = options.y;
      var low = options.low;
      var high = options.high;
      var direction = options.direction;
      var maxIterations = 10;
      var radius = this.options.selfReference.size;
      var threshold = 0.05;
      var pos;
      var middle = (low + high) * 0.5;
      var endPointOffset = 0;

      if (this.options.arrowStrikethrough === true) {
        if (direction === -1) {
          endPointOffset = this.options.endPointOffset.from;
        } else if (direction === 1) {
          endPointOffset = this.options.endPointOffset.to;
        }
      }

      var iteration = 0;

      do {
        middle = (low + high) * 0.5;
        pos = this._pointOnCircle(x, y, radius, middle);
        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);
        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));
        var difference = distanceToBorder - distanceToPoint;

        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference > 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (direction > 0) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (direction > 0) {
            high = middle;
          } else {
            low = middle;
          }
        }

        ++iteration;
      } while (low <= high && iteration < maxIterations);

      return _objectSpread$1(_objectSpread$1({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.
     *
     * @param selected - Determines wheter the line is selected.
     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.
     * @returns The width of the line.
     */

  }, {
    key: "getLineWidth",
    value: function getLineWidth(selected, hover) {
      if (selected === true) {
        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);
      } else if (hover === true) {
        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);
      } else {
        return Math.max(this.options.width, 0.3 / this._body.view.scale);
      }
    }
    /**
     * Compute the color or gradient for given edge.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param _selected - Ignored (TODO: remove in the future).
     * @param _hover - Ignored (TODO: remove in the future).
     * @returns Color string if single color is inherited or gradient if two.
     */

  }, {
    key: "getColor",
    value: function getColor(ctx, values) {
      if (values.inheritsColor !== false) {
        // when this is a loop edge, just use the 'from' method
        if (values.inheritsColor === "both" && this.from.id !== this.to.id) {
          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
          var fromColor = this.from.options.color.highlight.border;
          var toColor = this.to.options.color.highlight.border;

          if (this.from.selected === false && this.to.selected === false) {
            fromColor = overrideOpacity(this.from.options.color.border, values.opacity);
            toColor = overrideOpacity(this.to.options.color.border, values.opacity);
          } else if (this.from.selected === true && this.to.selected === false) {
            toColor = this.to.options.color.border;
          } else if (this.from.selected === false && this.to.selected === true) {
            fromColor = this.from.options.color.border;
          }

          grd.addColorStop(0, fromColor);
          grd.addColorStop(1, toColor); // -------------------- this returns -------------------- //

          return grd;
        }

        if (values.inheritsColor === "to") {
          return overrideOpacity(this.to.options.color.border, values.opacity);
        } else {
          // "from"
          return overrideOpacity(this.from.options.color.border, values.opacity);
        }
      } else {
        return overrideOpacity(values.color, values.opacity);
      }
    }
    /**
     * Draw a line from a node to itself, a circle.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     */

  }, {
    key: "_circle",
    value: function _circle(ctx, values, x, y, radius) {
      // draw shadow if enabled
      this.enableShadow(ctx, values); //full circle

      var angleFrom = 0;
      var angleTo = Math.PI * 2;

      if (!this.options.selfReference.renderBehindTheNode) {
        //render only parts which are not overlaping with parent node
        //need to find x,y of from point and x,y to point
        //calculating radians
        var low = this.options.selfReference.angle;
        var high = this.options.selfReference.angle + Math.PI;

        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: low,
          high: high,
          direction: -1
        });

        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: low,
          high: high,
          direction: 1
        });

        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);
        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);
      } // draw a circle


      ctx.beginPath();
      ctx.arc(x, y, radius, angleFrom, angleTo, false);
      ctx.stroke(); // disable shadows for other elements.

      this.disableShadow(ctx, values);
    }
    /**
     * @inheritDoc
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     */

  }, {
    key: "getDistanceToEdge",
    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      if (this.from != this.to) {
        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);
      } else {
        var _this$_getCircleData7 = this._getCircleData(undefined),
            _this$_getCircleData8 = _slicedToArray(_this$_getCircleData7, 3),
            x = _this$_getCircleData8[0],
            y = _this$_getCircleData8[1],
            radius = _this$_getCircleData8[2];

        var dx = x - x3;
        var dy = y - y3;
        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
      }
    }
    /**
     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).
     *
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @returns The distance between the line segment and the point.
     */

  }, {
    key: "_getDistanceToLine",
    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
      var px = x2 - x1;
      var py = y2 - y1;
      var something = px * px + py * py;
      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

      if (u > 1) {
        u = 1;
      } else if (u < 0) {
        u = 0;
      }

      var x = x1 + u * px;
      var y = y1 + u * py;
      var dx = x - x3;
      var dy = y - y3; //# Note: If the actual distance does not matter,
      //# if you only want to compare what this function
      //# returns to other results of this function, you
      //# can just return the squared distance instead
      //# (i.e. remove the sqrt) to gain a little performance

      return Math.sqrt(dx * dx + dy * dy);
    }
    /** @inheritDoc */

  }, {
    key: "getArrowData",
    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values) {
      // set lets
      var angle;
      var arrowPoint;
      var node1;
      var node2;
      var reversed;
      var scaleFactor;
      var type;
      var lineWidth = values.width;

      if (position === "from") {
        node1 = this.from;
        node2 = this.to;
        reversed = values.fromArrowScale < 0;
        scaleFactor = Math.abs(values.fromArrowScale);
        type = values.fromArrowType;
      } else if (position === "to") {
        node1 = this.to;
        node2 = this.from;
        reversed = values.toArrowScale < 0;
        scaleFactor = Math.abs(values.toArrowScale);
        type = values.toArrowType;
      } else {
        node1 = this.to;
        node2 = this.from;
        reversed = values.middleArrowScale < 0;
        scaleFactor = Math.abs(values.middleArrowScale);
        type = values.middleArrowType;
      }

      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.
      // if not connected to itself

      if (node1 != node2) {
        var approximateEdgeLength = hypot(node1.x - node2.x, node1.y - node2.y);

        var relativeLength = length / approximateEdgeLength;

        if (position !== "middle") {
          // draw arrow head
          if (this.options.smooth.enabled === true) {
            var pointT = this._findBorderPosition(node1, ctx, {
              via: viaNode
            });

            var guidePos = this.getPoint(pointT.t + relativeLength * (position === "from" ? 1 : -1), viaNode);
            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);
            arrowPoint = pointT;
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this._findBorderPosition(node1, ctx);
          }
        } else {
          // Negative half length reverses arrow direction.
          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;
          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);
          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);
          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);
          arrowPoint = this.getPoint(0.5, viaNode);
        }
      } else {
        // draw circle
        var _this$_getCircleData9 = this._getCircleData(ctx),
            _this$_getCircleData10 = _slicedToArray(_this$_getCircleData9, 3),
            x = _this$_getCircleData10[0],
            y = _this$_getCircleData10[1],
            radius = _this$_getCircleData10[2];

        if (position === "from") {
          var low = this.options.selfReference.angle;
          var high = this.options.selfReference.angle + Math.PI;

          var _pointT = this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: low,
            high: high,
            direction: -1
          });

          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
          arrowPoint = _pointT;
        } else if (position === "to") {
          var _low = this.options.selfReference.angle;

          var _high = this.options.selfReference.angle + Math.PI;

          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: _low,
            high: _high,
            direction: 1
          });

          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
          arrowPoint = _pointT2;
        } else {
          var pos = this.options.selfReference.angle / (2 * Math.PI);
          arrowPoint = this._pointOnCircle(x, y, radius, pos);
          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
        }
      }

      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
      var arrowCore = {
        x: xi,
        y: yi
      };
      return {
        point: arrowPoint,
        core: arrowCore,
        angle: angle,
        length: length,
        type: type
      };
    }
    /** @inheritDoc */

  }, {
    key: "drawArrowHead",
    value: function drawArrowHead(ctx, values, _selected, _hover, arrowData) {
      // set style
      ctx.strokeStyle = this.getColor(ctx, values);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = values.width;
      var canFill = EndPoints.draw(ctx, arrowData);

      if (canFill) {
        // draw shadow if enabled
        this.enableShadow(ctx, values);

        fill(ctx).call(ctx); // disable shadows for other elements.


        this.disableShadow(ctx, values);
      }
    }
    /**
     * Set the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */

  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }
    /**
     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */

  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     * Render the background according to the formatting values.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the background.
     */

  }, {
    key: "drawBackground",
    value: function drawBackground(ctx, values) {
      if (values.background !== false) {
        // save original line attrs
        var origCtxAttr = {
          strokeStyle: ctx.strokeStyle,
          lineWidth: ctx.lineWidth,
          dashes: ctx.dashes
        };
        ctx.strokeStyle = values.backgroundColor;
        ctx.lineWidth = values.backgroundSize;
        this.setStrokeDashed(ctx, values.backgroundDashes);
        ctx.stroke(); // restore original line attrs

        ctx.strokeStyle = origCtxAttr.strokeStyle;
        ctx.lineWidth = origCtxAttr.lineWidth;
        ctx.dashes = origCtxAttr.dashes;
        this.setStrokeDashed(ctx, values.dashes);
      }
    }
    /**
     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.
     *
     * @param ctx - The context that will be used for rendering.
     * @param dashes - The pattern [line, space, line…], true for default dashed line or false for normal line.
     */

  }, {
    key: "setStrokeDashed",
    value: function setStrokeDashed(ctx, dashes) {
      if (dashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var pattern = isArray$2(dashes) ? dashes : [5, 5];
          ctx.setLineDash(pattern);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      } else {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      }
    }
  }]);

  return EdgeBase;
}();

function ownKeys(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context2 = ownKeys(Object(source))).call(_context2, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * The Base Class for all Bezier edges.
 * Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var BezierEdgeBase = /*#__PURE__*/function (_EdgeBase) {
  _inherits(BezierEdgeBase, _EdgeBase);

  var _super = _createSuper$9(BezierEdgeBase);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeBase(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   * Find the intersection between the border of the node and the edge.
   *
   * @remarks
   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
   * @param nearNode - The node (either from or to node of the edge).
   * @param ctx - The context that will be used for rendering.
   * @param viaNode - Additional node(s) the edge passes through.
   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
   */


  _createClass(BezierEdgeBase, [{
    key: "_findBorderPositionBezier",
    value: function _findBorderPositionBezier(nearNode, ctx) {
      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();
      var maxIterations = 10;
      var threshold = 0.2;
      var from = false;
      var high = 1;
      var low = 0;
      var node = this.to;
      var pos;
      var middle;
      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;

      if (nearNode.id === this.from.id) {
        node = this.from;
        from = true;
        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;
      }

      if (this.options.arrowStrikethrough === false) {
        endPointOffset = 0;
      }

      var iteration = 0;

      do {
        middle = (low + high) * 0.5;
        pos = this.getPoint(middle, viaNode);
        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);
        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
        var difference = distanceToBorder - distanceToPoint;

        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference < 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (from === false) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (from === false) {
            high = middle;
          } else {
            low = middle;
          }
        }

        ++iteration;
      } while (low <= high && iteration < maxIterations);

      return _objectSpread(_objectSpread({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
     *
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @param via - The control point for the edge.
     * @returns The distance between the line segment and the point.
     */

  }, {
    key: "_getDistanceToBezierEdge",
    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var distance;
      var i, t, x, y;
      var lastX = x1;
      var lastY = y1;

      for (i = 1; i < 10; i++) {
        t = 0.1 * i;
        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;

        if (i > 0) {
          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }

        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
    /**
     * Render a bezier curve between two nodes.
     *
     * @remarks
     * The method accepts zero, one or two control points.
     * Passing zero control points just draws a straight line.
     * @param ctx - The context that will be used for rendering.
     * @param values - Style options for edge drawing.
     * @param viaNode1 - First control point for curve drawing.
     * @param viaNode2 - Second control point for curve drawing.
     */

  }, {
    key: "_bezierCurve",
    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

      if (viaNode1 != null && viaNode1.x != null) {
        if (viaNode2 != null && viaNode2.x != null) {
          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
        }
      } else {
        // fallback to normal straight edge
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
      } // draw a background


      this.drawBackground(ctx, values); // draw shadow if enabled

      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
  }]);

  return BezierEdgeBase;
}(EdgeBase);

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes. The Dynamic piece refers to how the curve
 * reacts to physics changes.
 *
 * @augments BezierEdgeBase
 */

var BezierEdgeDynamic = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(BezierEdgeDynamic, _BezierEdgeBase);

  var _super = _createSuper$8(BezierEdgeDynamic);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeDynamic(options, body, labelModule) {
    var _this;

    _classCallCheck(this, BezierEdgeDynamic);

    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.
    _this = _super.call(this, options, body, labelModule); // --> this calls the setOptions below

    _this.via = _this.via; // constructor → super → super → setOptions → setupSupportNode

    _this._boundFunction = function () {
      _this.positionBezierNode();
    };

    _this._body.emitter.on("_repositionBezierNodes", _this._boundFunction);

    return _this;
  }
  /** @inheritDoc */


  _createClass(BezierEdgeDynamic, [{
    key: "setOptions",
    value: function setOptions(options) {
      _get(_getPrototypeOf(BezierEdgeDynamic.prototype), "setOptions", this).call(this, options); // check if the physics has changed.


      var physicsChange = false;

      if (this.options.physics !== options.physics) {
        physicsChange = true;
      } // set the options and the to and from nodes


      this.options = options;
      this.id = this.options.id;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to]; // setup the support node and connect

      this.setupSupportNode();
      this.connect(); // when we change the physics state of the edge, we reposition the support node.

      if (physicsChange === true) {
        this.via.setOptions({
          physics: this.options.physics
        });
        this.positionBezierNode();
      }
    }
    /** @inheritDoc */

  }, {
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];

      if (this.from === undefined || this.to === undefined || this.options.physics === false) {
        this.via.setOptions({
          physics: false
        });
      } else {
        // fix weird behaviour where a self referencing node has physics enabled
        if (this.from.id === this.to.id) {
          this.via.setOptions({
            physics: false
          });
        } else {
          this.via.setOptions({
            physics: true
          });
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "cleanup",
    value: function cleanup() {
      this._body.emitter.off("_repositionBezierNodes", this._boundFunction);

      if (this.via !== undefined) {
        delete this._body.nodes[this.via.id];
        this.via = undefined;
        return true;
      }

      return false;
    }
    /**
     * Create and add a support node if not already present.
     *
     * @remarks
     * Bezier curves require an anchor point to calculate the smooth flow.
     * These points are nodes.
     * These nodes are invisible but are used for the force calculation.
     *
     * The changed data is not called, if needed, it is returned by the main edge constructor.
     */

  }, {
    key: "setupSupportNode",
    value: function setupSupportNode() {
      if (this.via === undefined) {
        var nodeId = "edgeId:" + this.id;

        var node = this._body.functions.createNode({
          id: nodeId,
          shape: "circle",
          physics: true,
          hidden: true
        });

        this._body.nodes[nodeId] = node;
        this.via = node;
        this.via.parentEdgeId = this.id;
        this.positionBezierNode();
      }
    }
    /**
     * Position bezier node.
     */

  }, {
    key: "positionBezierNode",
    value: function positionBezierNode() {
      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
        this.via.x = 0.5 * (this.from.x + this.to.x);
        this.via.y = 0.5 * (this.from.y + this.to.y);
      } else if (this.via !== undefined) {
        this.via.x = 0;
        this.via.y = 0;
      }
    }
    /** @inheritDoc */

  }, {
    key: "_line",
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      return this.via;
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this.via;
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;

      if (this.from === this.to) {
        var _this$_getCircleData = this._getCircleData(),
            _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),
            cx = _this$_getCircleData2[0],
            cy = _this$_getCircleData2[1],
            cr = _this$_getCircleData2[2];

        var a = 2 * Math.PI * (1 - position);
        return {
          x: cx + cr * Math.sin(a),
          y: cy + cr - cr * (1 - Math.cos(a))
        };
      } else {
        return {
          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,
          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y
        };
      }
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx, this.via);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
    }
  }]);

  return BezierEdgeDynamic;
}(BezierEdgeBase);

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var BezierEdgeStatic = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(BezierEdgeStatic, _BezierEdgeBase);

  var _super = _createSuper$7(BezierEdgeStatic);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeStatic(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeStatic);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(BezierEdgeStatic, [{
    key: "_line",
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /**
     * Compute the coordinates of the via node.
     *
     * @remarks
     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
     * @returns Cartesian coordinates of the via node.
     */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      // Assumption: x/y coordinates in from/to always defined
      var factor = this.options.smooth.roundness;
      var type = this.options.smooth.type;
      var dx = Math.abs(this.from.x - this.to.x);
      var dy = Math.abs(this.from.y - this.to.y);

      if (type === "discrete" || type === "diagonalCross") {
        var stepX;
        var stepY;

        if (dx <= dy) {
          stepX = stepY = factor * dy;
        } else {
          stepX = stepY = factor * dx;
        }

        if (this.from.x > this.to.x) {
          stepX = -stepX;
        }

        if (this.from.y >= this.to.y) {
          stepY = -stepY;
        }

        var xVia = this.from.x + stepX;
        var yVia = this.from.y + stepY;

        if (type === "discrete") {
          if (dx <= dy) {
            xVia = dx < factor * dy ? this.from.x : xVia;
          } else {
            yVia = dy < factor * dx ? this.from.y : yVia;
          }
        }

        return {
          x: xVia,
          y: yVia
        };
      } else if (type === "straightCross") {
        var _stepX = (1 - factor) * dx;

        var _stepY = (1 - factor) * dy;

        if (dx <= dy) {
          // up - down
          _stepX = 0;

          if (this.from.y < this.to.y) {
            _stepY = -_stepY;
          }
        } else {
          // left - right
          if (this.from.x < this.to.x) {
            _stepX = -_stepX;
          }

          _stepY = 0;
        }

        return {
          x: this.to.x + _stepX,
          y: this.to.y + _stepY
        };
      } else if (type === "horizontal") {
        var _stepX2 = (1 - factor) * dx;

        if (this.from.x < this.to.x) {
          _stepX2 = -_stepX2;
        }

        return {
          x: this.to.x + _stepX2,
          y: this.from.y
        };
      } else if (type === "vertical") {
        var _stepY2 = (1 - factor) * dy;

        if (this.from.y < this.to.y) {
          _stepY2 = -_stepY2;
        }

        return {
          x: this.from.x,
          y: this.to.y + _stepY2
        };
      } else if (type === "curvedCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var radius = Math.sqrt(dx * dx + dy * dy);
        var pi = Math.PI;
        var originalAngle = Math.atan2(dy, dx);
        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);
        return {
          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)
        };
      } else if (type === "curvedCCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;

        var _radius = Math.sqrt(dx * dx + dy * dy);

        var _pi = Math.PI;

        var _originalAngle = Math.atan2(dy, dx);

        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

        return {
          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)
        };
      } else {
        // continuous
        var _stepX3;

        var _stepY3;

        if (dx <= dy) {
          _stepX3 = _stepY3 = factor * dy;
        } else {
          _stepX3 = _stepY3 = factor * dx;
        }

        if (this.from.x > this.to.x) {
          _stepX3 = -_stepX3;
        }

        if (this.from.y >= this.to.y) {
          _stepY3 = -_stepY3;
        }

        var _xVia = this.from.x + _stepX3;

        var _yVia = this.from.y + _stepY3;

        if (dx <= dy) {
          if (this.from.x <= this.to.x) {
            _xVia = this.to.x < _xVia ? this.to.x : _xVia;
          } else {
            _xVia = this.to.x > _xVia ? this.to.x : _xVia;
          }
        } else {
          if (this.from.y >= this.to.y) {
            _yVia = this.to.y > _yVia ? this.to.y : _yVia;
          } else {
            _yVia = this.to.y < _yVia ? this.to.y : _yVia;
          }
        }

        return {
          x: _xVia,
          y: _yVia
        };
      }
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this._findBorderPositionBezier(nearNode, ctx, options.via);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();
      var t = position;
      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
      return {
        x: x,
        y: y
      };
    }
  }]);

  return BezierEdgeStatic;
}(BezierEdgeBase);

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model
 * smooth gradual curves in paths between nodes.
 *
 * @augments BezierEdgeBase
 */

var CubicBezierEdgeBase = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(CubicBezierEdgeBase, _BezierEdgeBase);

  var _super = _createSuper$6(CubicBezierEdgeBase);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function CubicBezierEdgeBase(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdgeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
   *
   * @remarks
   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
   * @param x1 - First end of the line segment on the x axis.
   * @param y1 - First end of the line segment on the y axis.
   * @param x2 - Second end of the line segment on the x axis.
   * @param y2 - Second end of the line segment on the y axis.
   * @param x3 - Position of the point on the x axis.
   * @param y3 - Position of the point on the y axis.
   * @param via1 - The first point this edge passes through.
   * @param via2 - The second point this edge passes through.
   * @returns The distance between the line segment and the point.
   */


  _createClass(CubicBezierEdgeBase, [{
    key: "_getDistanceToBezierEdge2",
    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var lastX = x1;
      var lastY = y1;
      var vec = [0, 0, 0, 0];

      for (var i = 1; i < 10; i++) {
        var t = 0.1 * i;
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;

        if (i > 0) {
          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);

          minDistance = distance < minDistance ? distance : minDistance;
        }

        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
  }]);

  return CubicBezierEdgeBase;
}(BezierEdgeBase);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var CubicBezierEdge = /*#__PURE__*/function (_CubicBezierEdgeBase) {
  _inherits(CubicBezierEdge, _CubicBezierEdgeBase);

  var _super = _createSuper$5(CubicBezierEdge);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function CubicBezierEdge(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdge);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(CubicBezierEdge, [{
    key: "_line",
    value: function _line(ctx, values, viaNodes) {
      // get the coordinates of the support points.
      var via1 = viaNodes[0];
      var via2 = viaNodes[1];

      this._bezierCurve(ctx, values, via1, via2);
    }
    /**
     * Compute the additional points the edge passes through.
     *
     * @returns Cartesian coordinates of the points the edge passes through.
     */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      var dx = this.from.x - this.to.x;
      var dy = this.from.y - this.to.y;
      var x1;
      var y1;
      var x2;
      var y2;
      var roundness = this.options.smooth.roundness; // horizontal if x > y or if direction is forced or if direction is horizontal

      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
        y1 = this.from.y;
        y2 = this.to.y;
        x1 = this.from.x - roundness * dx;
        x2 = this.to.x + roundness * dx;
      } else {
        y1 = this.from.y - roundness * dy;
        y2 = this.to.y + roundness * dy;
        x1 = this.from.x;
        x2 = this.to.x;
      }

      return [{
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      }];
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),
          _ref2 = _slicedToArray(_ref, 2),
          via1 = _ref2[0],
          via2 = _ref2[1];

      // x3,y3 is the point
      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),
          _ref4 = _slicedToArray(_ref3, 2),
          via1 = _ref4[0],
          via2 = _ref4[1];

      var t = position;
      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];
      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
      return {
        x: x,
        y: y
      };
    }
  }]);

  return CubicBezierEdge;
}(CubicBezierEdgeBase);

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Straight Edge.
 */

var StraightEdge = /*#__PURE__*/function (_EdgeBase) {
  _inherits(StraightEdge, _EdgeBase);

  var _super = _createSuper$4(StraightEdge);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function StraightEdge(options, body, labelModule) {
    _classCallCheck(this, StraightEdge);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(StraightEdge, [{
    key: "_line",
    value: function _line(ctx, values) {
      // draw a straight line
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
      ctx.lineTo(this.toPoint.x, this.toPoint.y); // draw shadow if enabled

      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return undefined;
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      return {
        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,
        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y
      };
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var node1 = this.to;
      var node2 = this.from;

      if (nearNode.id === this.from.id) {
        node1 = this.from;
        node2 = this.to;
      }

      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
      var toBorderDist = nearNode.distanceToBorder(ctx, angle);
      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
      return {
        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,
        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,
        t: 0
      };
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
    }
  }]);

  return StraightEdge;
}(EdgeBase);

/**
 * An edge connects two nodes and has a specific direction.
 */

var Edge = /*#__PURE__*/function () {
  /**
   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'
   * @param {object} body           shared state from Network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.
   * @param {object} globalOptions  options from the EdgesHandler instance
   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant
   */
  function Edge(options, body, imagelist, globalOptions, defaultOptions) {
    _classCallCheck(this, Edge);

    if (body === undefined) {
      throw new Error("No body provided");
    } // Since globalOptions is constant in values as well as reference,
    // Following needs to be done only once.


    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;
    this.imagelist = imagelist; // initialize variables

    this.id = undefined;
    this.fromId = undefined;
    this.toId = undefined;
    this.selected = false;
    this.hover = false;
    this.labelDirty = true;
    this.baseWidth = this.options.width;
    this.baseFontSize = this.options.font.size;
    this.from = undefined; // a node

    this.to = undefined; // a node

    this.edgeType = undefined;
    this.connected = false;
    this.labelModule = new Label(this.body, this.options, true
    /* It's an edge label */
    );
    this.setOptions(options);
  }
  /**
   * Set or overwrite options for the edge
   *
   * @param {object} options  an object with options
   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.
   */


  _createClass(Edge, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (!options) {
        return;
      } // Following options if changed affect the layout.


      var affectsLayout = typeof options.physics !== "undefined" && this.options.physics !== options.physics || typeof options.hidden !== "undefined" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== "undefined" && this.options.from !== options.from || typeof options.to !== "undefined" && this.options.to !== options.to;
      Edge.parseOptions(this.options, options, true, this.globalOptions);

      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (options.from !== undefined) {
        this.fromId = options.from;
      }

      if (options.to !== undefined) {
        this.toId = options.to;
      }

      if (options.title !== undefined) {
        this.title = options.title;
      }

      if (options.value !== undefined) {
        options.value = _parseFloat(options.value);
      }

      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("edge", pile); // update label Module

      this.updateLabelModule(options); // Update edge type, this if changed affects the layout.

      affectsLayout = this.updateEdgeType() || affectsLayout; // if anything has been updates, reset the selection width and the hover width

      this._setInteractionWidths(); // A node is connected when it has a from and to node that both exist in the network.body.nodes.


      this.connect();
      return affectsLayout;
    }
    /**
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {boolean} [copyFromGlobals=false]
     */

  }, {
    key: "getFormattingValues",
    value:
    /**
     *
     * @returns {ArrowOptions}
     */
    function getFormattingValues() {
      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
      var inheritsColor = this.options.color.inherit;
      var values = {
        toArrow: toArrow,
        toArrowScale: this.options.arrows.to.scaleFactor,
        toArrowType: this.options.arrows.to.type,
        toArrowSrc: this.options.arrows.to.src,
        toArrowImageWidth: this.options.arrows.to.imageWidth,
        toArrowImageHeight: this.options.arrows.to.imageHeight,
        middleArrow: middleArrow,
        middleArrowScale: this.options.arrows.middle.scaleFactor,
        middleArrowType: this.options.arrows.middle.type,
        middleArrowSrc: this.options.arrows.middle.src,
        middleArrowImageWidth: this.options.arrows.middle.imageWidth,
        middleArrowImageHeight: this.options.arrows.middle.imageHeight,
        fromArrow: fromArrow,
        fromArrowScale: this.options.arrows.from.scaleFactor,
        fromArrowType: this.options.arrows.from.type,
        fromArrowSrc: this.options.arrows.from.src,
        fromArrowImageWidth: this.options.arrows.from.imageWidth,
        fromArrowImageHeight: this.options.arrows.from.imageHeight,
        arrowStrikethrough: this.options.arrowStrikethrough,
        color: inheritsColor ? undefined : this.options.color.color,
        inheritsColor: inheritsColor,
        opacity: this.options.color.opacity,
        hidden: this.options.hidden,
        length: this.options.length,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y,
        dashes: this.options.dashes,
        width: this.options.width,
        background: this.options.background.enabled,
        backgroundColor: this.options.background.color,
        backgroundSize: this.options.background.size,
        backgroundDashes: this.options.background.dashes
      };

      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            var selectedWidth = this.options.selectionWidth;

            if (typeof selectedWidth === "function") {
              values.width = selectedWidth(values.width);
            } else if (typeof selectedWidth === "number") {
              values.width += selectedWidth;
            }

            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.highlight;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            var hoverWidth = this.options.hoverWidth;

            if (typeof hoverWidth === "function") {
              values.width = hoverWidth(values.width);
            } else if (typeof hoverWidth === "number") {
              values.width += hoverWidth;
            }

            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.hover;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === "function") {
          this.chooser(values, this.options.id, this.selected, this.hover);

          if (values.color !== undefined) {
            values.inheritsColor = false;
          }

          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
      }

      return values;
    }
    /**
     * update the options in the label module
     *
     * @param {object} options
     */

  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      var pile = [options, this.options, this.globalOptions, // Currently set global edge options
      this.defaultOptions];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     * update the edge type, set the options
     *
     * @returns {boolean}
     */

  }, {
    key: "updateEdgeType",
    value: function updateEdgeType() {
      var smooth = this.options.smooth;
      var dataChanged = false;
      var changeInType = true;

      if (this.edgeType !== undefined) {
        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
          changeInType = false;
        }

        if (changeInType === true) {
          dataChanged = this.cleanup();
        }
      }

      if (changeInType === true) {
        if (smooth.enabled === true) {
          if (smooth.type === "dynamic") {
            dataChanged = true;
            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
          } else if (smooth.type === "cubicBezier") {
            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
          } else {
            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
          }
        } else {
          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
        }
      } else {
        // if nothing changes, we just set the options.
        this.edgeType.setOptions(this.options);
      }

      return dataChanged;
    }
    /**
     * Connect an edge to its nodes
     */

  }, {
    key: "connect",
    value: function connect() {
      this.disconnect();
      this.from = this.body.nodes[this.fromId] || undefined;
      this.to = this.body.nodes[this.toId] || undefined;
      this.connected = this.from !== undefined && this.to !== undefined;

      if (this.connected === true) {
        this.from.attachEdge(this);
        this.to.attachEdge(this);
      } else {
        if (this.from) {
          this.from.detachEdge(this);
        }

        if (this.to) {
          this.to.detachEdge(this);
        }
      }

      this.edgeType.connect();
    }
    /**
     * Disconnect an edge from its nodes
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.from) {
        this.from.detachEdge(this);
        this.from = undefined;
      }

      if (this.to) {
        this.to.detachEdge(this);
        this.to = undefined;
      }

      this.connected = false;
    }
    /**
     * get the title of this edge.
     *
     * @returns {string} title    The title of the edge, or undefined when no title
     *                           has been set.
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.title;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the edge. Can be undefined
     *
     * @returns {number} value
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Adjust the value range of the edge. The edge will adjust it's width
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var widthDiff = this.options.scaling.max - this.options.scaling.min;

        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }

        this.options.width = this.options.scaling.min + scale * widthDiff;
      } else {
        this.options.width = this.baseWidth;
        this.options.font.size = this.baseFontSize;
      }

      this._setInteractionWidths();

      this.updateLabelModule();
    }
    /**
     *
     * @private
     */

  }, {
    key: "_setInteractionWidths",
    value: function _setInteractionWidths() {
      if (typeof this.options.hoverWidth === "function") {
        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
      } else {
        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
      }

      if (typeof this.options.selectionWidth === "function") {
        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
      } else {
        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
      }
    }
    /**
     * Redraw a edge
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var values = this.getFormattingValues();

      if (values.hidden) {
        return;
      } // get the via node from the edge type


      var viaNode = this.edgeType.getViaNode(); // draw line and label

      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);
      this.drawLabel(ctx, viaNode);
    }
    /**
     * Redraw arrows
     * Draw this arrows in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "drawArrows",
    value: function drawArrows(ctx) {
      var values = this.getFormattingValues();

      if (values.hidden) {
        return;
      } // get the via node from the edge type


      var viaNode = this.edgeType.getViaNode();
      var arrowData = {}; // restore edge targets to defaults

      this.edgeType.fromPoint = this.edgeType.from;
      this.edgeType.toPoint = this.edgeType.to; // from and to arrows give a different end point for edges. we set them here

      if (values.fromArrow) {
        arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;

        if (values.fromArrowSrc) {
          arrowData.from.image = this.imagelist.load(values.fromArrowSrc);
        }

        if (values.fromArrowImageWidth) {
          arrowData.from.imageWidth = values.fromArrowImageWidth;
        }

        if (values.fromArrowImageHeight) {
          arrowData.from.imageHeight = values.fromArrowImageHeight;
        }
      }

      if (values.toArrow) {
        arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;

        if (values.toArrowSrc) {
          arrowData.to.image = this.imagelist.load(values.toArrowSrc);
        }

        if (values.toArrowImageWidth) {
          arrowData.to.imageWidth = values.toArrowImageWidth;
        }

        if (values.toArrowImageHeight) {
          arrowData.to.imageHeight = values.toArrowImageHeight;
        }
      } // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.


      if (values.middleArrow) {
        arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values);

        if (values.middleArrowSrc) {
          arrowData.middle.image = this.imagelist.load(values.middleArrowSrc);
        }

        if (values.middleArrowImageWidth) {
          arrowData.middle.imageWidth = values.middleArrowImageWidth;
        }

        if (values.middleArrowImageHeight) {
          arrowData.middle.imageHeight = values.middleArrowImageHeight;
        }
      }

      if (values.fromArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);
      }

      if (values.middleArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);
      }

      if (values.toArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Node} viaNode
     */

  }, {
    key: "drawLabel",
    value: function drawLabel(ctx, viaNode) {
      if (this.options.label !== undefined) {
        // set style
        var node1 = this.from;
        var node2 = this.to;

        if (this.labelModule.differentState(this.selected, this.hover)) {
          this.labelModule.getTextSize(ctx, this.selected, this.hover);
        }

        var point;

        if (node1.id != node2.id) {
          this.labelModule.pointToSelf = false;
          point = this.edgeType.getPoint(0.5, viaNode);
          ctx.save();

          var rotationPoint = this._getRotation(ctx);

          if (rotationPoint.angle != 0) {
            ctx.translate(rotationPoint.x, rotationPoint.y);
            ctx.rotate(rotationPoint.angle);
          } // draw the label


          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
          /*
          // Useful debug code: draw a border around the label
          // This should **not** be enabled in production!
          var size = this.labelModule.getSize();; // ;; intentional so lint catches it
          ctx.strokeStyle = "#ff0000";
          ctx.strokeRect(size.left, size.top, size.width, size.height);
          // End  debug code
          */

          ctx.restore();
        } else {
          // Ignore the orientations.
          this.labelModule.pointToSelf = true; // get circle coordinates

          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);
          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
        }
      }
    }
    /**
     * Determine all visual elements of this edge instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        var rotationPoint = this._getRotation();

        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
          ret.push({
            edgeId: this.id,
            labelId: 0
          });
        }
      }

      var obj = {
        left: point.x,
        top: point.y
      };

      if (this.isOverlappingWith(obj)) {
        ret.push({
          edgeId: this.id
        });
      }

      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top
     * @returns {boolean}     True if location is located on the edge
     */

  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      if (this.connected) {
        var distMax = 10;
        var xFrom = this.from.x;
        var yFrom = this.from.y;
        var xTo = this.to.x;
        var yTo = this.to.y;
        var xObj = obj.left;
        var yObj = obj.top;
        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
        return dist < distMax;
      } else {
        return false;
      }
    }
    /**
     * Determine the rotation point, if any.
     *
     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
     * @private
     */

  }, {
    key: "_getRotation",
    value: function _getRotation(ctx) {
      var viaNode = this.edgeType.getViaNode();
      var point = this.edgeType.getPoint(0.5, viaNode);

      if (ctx !== undefined) {
        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
      }

      var ret = {
        x: point.x,
        y: this.labelModule.size.yLine,
        angle: 0
      };

      if (!this.labelModule.visible()) {
        return ret; // Don't even bother doing the atan2, there's nothing to draw
      }

      if (this.options.font.align === "horizontal") {
        return ret; // No need to calculate angle
      }

      var dy = this.from.y - this.to.y;
      var dx = this.from.x - this.to.x;
      var angle = Math.atan2(dy, dx); // radians
      // rotate so that label is readable

      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
        angle += Math.PI;
      }

      ret.angle = angle;
      return ret;
    }
    /**
     * Get a point on a circle
     *
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} angle
     * @returns {object} point
     * @private
     */

  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x, y, radius, angle) {
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }
    /**
     * Sets selected state to true
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
    }
    /**
     * Sets selected state to false
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
    }
    /**
     * cleans all required things on delete
     *
     * @returns {*}
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      return this.edgeType.cleanup();
    }
    /**
     * Remove edge from the list and perform necessary cleanup.
     */

  }, {
    key: "remove",
    value: function remove() {
      this.cleanup();
      this.disconnect();
      delete this.body.edges[this.id];
    }
    /**
     * Check if both connecting nodes exist
     *
     * @returns {boolean}
     */

  }, {
    key: "endPointsValid",
    value: function endPointsValid() {
      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;
    }
  }], [{
    key: "parseOptions",
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var fields = ["endPointOffset", "arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "selfReference", "to", "title", "value", "width", "font", "chosen", "widthConstraint"]; // only deep extend the items in the field array. These do not have shorthand.

      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion); // Only use endPointOffset values (from and to) if it's valid values

      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.from !== undefined) {
        if (_isFinite(newOptions.endPointOffset.from)) {
          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;
        } else {
          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== undefined ? globalOptions.endPointOffset.from : 0;
          console.error("endPointOffset.from is not a valid number");
        }
      }

      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.to !== undefined) {
        if (_isFinite(newOptions.endPointOffset.to)) {
          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;
        } else {
          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== undefined ? globalOptions.endPointOffset.to : 0;
          console.error("endPointOffset.to is not a valid number");
        }
      } // Only copy label if it's a legal value.


      if (isValidLabel(newOptions.label)) {
        parentOptions.label = newOptions.label;
      } else if (!isValidLabel(parentOptions.label)) {
        parentOptions.label = undefined;
      }

      mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
      mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
      mergeOptions(parentOptions, newOptions, "background", globalOptions);

      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
        parentOptions.dashes = newOptions.dashes;
      } else if (allowDeletion === true && newOptions.dashes === null) {
        parentOptions.dashes = create$5(globalOptions.dashes); // this sets the pointer of the option back to the global option.
      } // set the scaling newOptions


      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
        if (newOptions.scaling.min !== undefined) {
          parentOptions.scaling.min = newOptions.scaling.min;
        }

        if (newOptions.scaling.max !== undefined) {
          parentOptions.scaling.max = newOptions.scaling.max;
        }

        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      } else if (allowDeletion === true && newOptions.scaling === null) {
        parentOptions.scaling = create$5(globalOptions.scaling); // this sets the pointer of the option back to the global option.
      } // handle multiple input cases for arrows


      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
        if (typeof newOptions.arrows === "string") {
          var arrows = newOptions.arrows.toLowerCase();
          parentOptions.arrows.to.enabled = indexOf(arrows).call(arrows, "to") != -1;
          parentOptions.arrows.middle.enabled = indexOf(arrows).call(arrows, "middle") != -1;
          parentOptions.arrows.from.enabled = indexOf(arrows).call(arrows, "from") != -1;
        } else if (_typeof(newOptions.arrows) === "object") {
          mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
        } else {
          throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + stringify$1(newOptions.arrows));
        }
      } else if (allowDeletion === true && newOptions.arrows === null) {
        parentOptions.arrows = create$5(globalOptions.arrows); // this sets the pointer of the option back to the global option.
      } // handle multiple input cases for color


      if (newOptions.color !== undefined && newOptions.color !== null) {
        var fromColor = isString(newOptions.color) ? {
          color: newOptions.color,
          highlight: newOptions.color,
          hover: newOptions.color,
          inherit: false,
          opacity: 1
        } : newOptions.color;
        var toColor = parentOptions.color; // If passed, fill in values from default options - required in the case of no prototype bridging

        if (copyFromGlobals) {
          deepExtend(toColor, globalOptions.color, false, allowDeletion);
        } else {
          // Clear local properties - need to do it like this in order to retain prototype bridges
          for (var i in toColor) {
            if (Object.prototype.hasOwnProperty.call(toColor, i)) {
              delete toColor[i];
            }
          }
        }

        if (isString(toColor)) {
          toColor.color = toColor;
          toColor.highlight = toColor;
          toColor.hover = toColor;
          toColor.inherit = false;

          if (fromColor.opacity === undefined) {
            toColor.opacity = 1.0; // set default
          }
        } else {
          var colorsDefined = false;

          if (fromColor.color !== undefined) {
            toColor.color = fromColor.color;
            colorsDefined = true;
          }

          if (fromColor.highlight !== undefined) {
            toColor.highlight = fromColor.highlight;
            colorsDefined = true;
          }

          if (fromColor.hover !== undefined) {
            toColor.hover = fromColor.hover;
            colorsDefined = true;
          }

          if (fromColor.inherit !== undefined) {
            toColor.inherit = fromColor.inherit;
          }

          if (fromColor.opacity !== undefined) {
            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
          }

          if (colorsDefined === true) {
            toColor.inherit = false;
          } else {
            if (toColor.inherit === undefined) {
              toColor.inherit = "from"; // Set default
            }
          }
        }
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options
      }

      if (Object.prototype.hasOwnProperty.call(newOptions, "selfReferenceSize")) {
        console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}");
        parentOptions.selfReference.size = newOptions.selfReferenceSize;
      }
    }
  }]);

  return Edge;
}();

/**
 * Handler for Edges
 */

var EdgesHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Array.<Image>} images
   * @param {Array.<Group>} groups
   */
  function EdgesHandler(body, images, groups) {
    var _context,
        _this = this;

    _classCallCheck(this, EdgesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups; // create the edge API in the body container

    this.body.functions.createEdge = bind$6(_context = this.create).call(_context, this);
    this.edgesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };
    this.options = {};
    this.defaultOptions = {
      arrows: {
        to: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        from: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        }
      },
      endPointOffset: {
        from: 0,
        to: 0
      },
      arrowStrikethrough: true,
      color: {
        color: "#848484",
        highlight: "#848484",
        hover: "#848484",
        inherit: "from",
        opacity: 1.0
      },
      dashes: false,
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 2,
        // px
        strokeColor: "#ffffff",
        align: "horizontal",
        multi: false,
        vadjust: 0,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "courier new",
          vadjust: 2
        }
      },
      hidden: false,
      hoverWidth: 1.5,
      label: undefined,
      labelHighlightBold: true,
      length: undefined,
      physics: true,
      scaling: {
        min: 1,
        max: 15,
        label: {
          enabled: true,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      selectionWidth: 1.5,
      selfReference: {
        size: 20,
        angle: Math.PI / 4,
        renderBehindTheNode: true
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      background: {
        enabled: false,
        color: "rgba(111,111,111,1)",
        size: 10,
        dashes: false
      },
      smooth: {
        enabled: true,
        type: "dynamic",
        forceDirection: "none",
        roundness: 0.5
      },
      title: undefined,
      width: 1,
      value: undefined
    };
    deepExtend(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(EdgesHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this,
          _context2,
          _context3;

      // this allows external modules to force all dynamic curves to turn static.
      this.body.emitter.on("_forceDisableDynamicCurves", function (type) {
        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (type === "dynamic") {
          type = "continuous";
        }

        var dataChanged = false;

        for (var edgeId in _this2.body.edges) {
          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {
            var edge = _this2.body.edges[edgeId];

            var edgeData = _this2.body.data.edges.get(edgeId); // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
            // this is because a change in the global would not affect these curves.


            if (edgeData != null) {
              var smoothOptions = edgeData.smooth;

              if (smoothOptions !== undefined) {
                if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                  if (type === undefined) {
                    edge.setOptions({
                      smooth: false
                    });
                  } else {
                    edge.setOptions({
                      smooth: {
                        type: type
                      }
                    });
                  }

                  dataChanged = true;
                }
              }
            }
          }
        }

        if (emit === true && dataChanged === true) {
          _this2.body.emitter.emit("_dataChanged");
        }
      }); // this is called when options of EXISTING nodes or edges have changed.
      //
      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.
      //       See update() for logic.
      // TODO: Verify and examine the consequences of this. It might still trigger when
      //       non-option fields have changed, but then reconnecting edges is still useless.
      //       Alternatively, it might also be called when edges are removed.
      //

      this.body.emitter.on("_dataUpdated", function () {
        _this2.reconnectEdges();
      }); // refresh the edges. Used when reverting from hierarchical layout

      this.body.emitter.on("refreshEdges", bind$6(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", bind$6(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function () {
        forEach$1(_this2.edgesListeners, function (callback, event) {
          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
        });
        delete _this2.body.functions.createEdge;
        delete _this2.edgesListeners.add;
        delete _this2.edgesListeners.update;
        delete _this2.edgesListeners.remove;
        delete _this2.edgesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // use the parser from the Edge class to fill in all shorthand notations
        Edge.parseOptions(this.options, options, true, this.defaultOptions, true); // update smooth settings in all edges

        var dataChanged = false;

        if (options.smooth !== undefined) {
          for (var edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {
              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
            }
          }
        } // update fonts in all edges


        if (options.font !== undefined) {
          for (var _edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {
              this.body.edges[_edgeId].updateLabelModule();
            }
          }
        } // update the state of the variables if needed


        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Load edges by reading the data table
     *
     * @param {Array | DataSet | DataView} edges    The data containing the edges.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */

  }, {
    key: "setData",
    value: function setData(edges) {
      var _this3 = this;

      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var oldEdgesData = this.body.data.edges;

      if (isDataViewLike("id", edges)) {
        this.body.data.edges = edges;
      } else if (isArray$2(edges)) {
        this.body.data.edges = new DataSet();
        this.body.data.edges.add(edges);
      } else if (!edges) {
        this.body.data.edges = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      } // TODO: is this null or undefined or false?


      if (oldEdgesData) {
        // unsubscribe from old dataset
        forEach$1(this.edgesListeners, function (callback, event) {
          oldEdgesData.off(event, callback);
        });
      } // remove drawn edges


      this.body.edges = {}; // TODO: is this null or undefined or false?

      if (this.body.data.edges) {
        // subscribe to new dataset
        forEach$1(this.edgesListeners, function (callback, event) {
          _this3.body.data.edges.on(event, callback);
        }); // draw all new nodes

        var ids = this.body.data.edges.getIds();
        this.add(ids, true);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add edges
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: "add",
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var oldEdge = edges[id];

        if (oldEdge) {
          oldEdge.disconnect();
        }

        var data = edgesData.get(id, {
          showInternalIds: true
        });
        edges[id] = this.create(data);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing edges, or create them when not yet existing
     *
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: "update",
    value: function update(ids) {
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;
      var dataChanged = false;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = edgesData.get(id);
        var edge = edges[id];

        if (edge !== undefined) {
          // update edge
          edge.disconnect();
          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.

          edge.connect();
        } else {
          // create edge
          this.body.edges[id] = this.create(data);
          dataChanged = true;
        }
      }

      if (dataChanged === true) {
        this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing edges. Non existing ids will be ignored
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [emit=true]
     * @private
     */

  }, {
    key: "remove",
    value: function remove(ids) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (ids.length === 0) return; // early out

      var edges = this.body.edges;
      forEach$1(ids, function (id) {
        var edge = edges[id];

        if (edge !== undefined) {
          edge.remove();
        }
      });

      if (emit) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Refreshes Edge Handler
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this4 = this;

      forEach$1(this.body.edges, function (edge, edgeId) {
        var data = _this4.body.data.edges.get(edgeId);

        if (data !== undefined) {
          edge.setOptions(data);
        }
      });
    }
    /**
     *
     * @param {object} properties
     * @returns {Edge}
     */

  }, {
    key: "create",
    value: function create(properties) {
      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);
    }
    /**
     * Reconnect all edges
     *
     * @private
     */

  }, {
    key: "reconnectEdges",
    value: function reconnectEdges() {
      var id;
      var nodes = this.body.nodes;
      var edges = this.body.edges;

      for (id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          nodes[id].edges = [];
        }
      }

      for (id in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, id)) {
          var edge = edges[id];
          edge.from = null;
          edge.to = null;
          edge.connect();
        }
      }
    }
    /**
     *
     * @param {Edge.id} edgeId
     * @returns {Array}
     */

  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(edgeId) {
      var nodeList = [];

      if (this.body.edges[edgeId] !== undefined) {
        var edge = this.body.edges[edgeId];

        if (edge.fromId !== undefined) {
          nodeList.push(edge.fromId);
        }

        if (edge.toId !== undefined) {
          nodeList.push(edge.toId);
        }
      }

      return nodeList;
    }
    /**
     * There is no direct relation between the nodes and the edges DataSet,
     * so the right place to do call this is in the handler for event `_dataUpdated`.
     */

  }, {
    key: "_updateState",
    value: function _updateState() {
      this._addMissingEdges();

      this._removeInvalidEdges();
    }
    /**
     * Scan for missing nodes and remove corresponding edges, if any.
     *
     * @private
     */

  }, {
    key: "_removeInvalidEdges",
    value: function _removeInvalidEdges() {
      var _this5 = this;

      var edgesToDelete = [];
      forEach$1(this.body.edges, function (edge, id) {
        var toNode = _this5.body.nodes[edge.toId];
        var fromNode = _this5.body.nodes[edge.fromId]; // Skip clustering edges here, let the Clustering module handle those

        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {
          return;
        }

        if (toNode === undefined || fromNode === undefined) {
          edgesToDelete.push(id);
        }
      });
      this.remove(edgesToDelete, false);
    }
    /**
     * add all edges from dataset that are not in the cached state
     *
     * @private
     */

  }, {
    key: "_addMissingEdges",
    value: function _addMissingEdges() {
      var edgesData = this.body.data.edges;

      if (edgesData === undefined || edgesData === null) {
        return; // No edges DataSet yet; can happen on startup
      }

      var edges = this.body.edges;
      var addIds = [];

      forEach$2(edgesData).call(edgesData, function (edgeData, edgeId) {
        var edge = edges[edgeId];

        if (edge === undefined) {
          addIds.push(edgeId);
        }
      });

      this.add(addIds, true);
    }
  }]);

  return EdgesHandler;
}();

/**
 * Barnes Hut Solver
 */

var BarnesHutSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function BarnesHutSolver(body, physicsBody, options) {
    _classCallCheck(this, BarnesHutSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.barnesHutTree;
    this.setOptions(options);
    this._rng = Alea("BARNES HUT SOLVER"); // debug: show grid
    // this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
  }
  /**
   *
   * @param {object} options
   */


  _createClass(BarnesHutSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.thetaInversed = 1 / this.options.theta; // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius

      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
    }
    /**
     * This function calculates the forces the nodes apply on each other based on a gravitational model.
     * The Barnes Hut method is used to speed up this N-body simulation.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
        var node;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var nodeCount = nodeIndices.length; // create the tree

        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices); // for debugging


        this.barnesHutTree = barnesHutTree; // place the nodes one by one recursively

        for (var i = 0; i < nodeCount; i++) {
          node = nodes[nodeIndices[i]];

          if (node.options.mass > 0) {
            // starting with root is irrelevant, it never passes the BarnesHutSolver condition
            this._getForceContributions(barnesHutTree.root, node);
          }
        }
      }
    }
    /**
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_getForceContributions",
    value: function _getForceContributions(parentBranch, node) {
      this._getForceContribution(parentBranch.children.NW, node);

      this._getForceContribution(parentBranch.children.NE, node);

      this._getForceContribution(parentBranch.children.SW, node);

      this._getForceContribution(parentBranch.children.SE, node);
    }
    /**
     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
     * If a region contains a single node, we check if it is not itself, then we apply the force.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_getForceContribution",
    value: function _getForceContribution(parentBranch, node) {
      // we get no force contribution from an empty region
      if (parentBranch.childrenCount > 0) {
        // get the distance from the center of mass to the node.
        var dx = parentBranch.centerOfMass.x - node.x;
        var dy = parentBranch.centerOfMass.y - node.y;
        var distance = Math.sqrt(dx * dx + dy * dy); // BarnesHutSolver condition
        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
        // calcSize = 1/s --> d * 1/s > 1/theta = passed

        if (distance * parentBranch.calcSize > this.thetaInversed) {
          this._calculateForces(distance, dx, dy, node, parentBranch);
        } else {
          // Did not pass the condition, go into children if available
          if (parentBranch.childrenCount === 4) {
            this._getForceContributions(parentBranch, node);
          } else {
            // parentBranch must have only one node, if it was empty we wouldnt be here
            if (parentBranch.children.data.id != node.id) {
              // if it is not self
              this._calculateForces(distance, dx, dy, node, parentBranch);
            }
          }
        }
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Node} node
     * @param {object} parentBranch
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1;
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      } // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce


      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
    /**
     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
     *
     * @param {Array.<Node>} nodes
     * @param {Array.<number>} nodeIndices
     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
     * @private
     */

  }, {
    key: "_formBarnesHutTree",
    value: function _formBarnesHutTree(nodes, nodeIndices) {
      var node;
      var nodeCount = nodeIndices.length;
      var minX = nodes[nodeIndices[0]].x;
      var minY = nodes[nodeIndices[0]].y;
      var maxX = nodes[nodeIndices[0]].x;
      var maxY = nodes[nodeIndices[0]].y; // get the range of the nodes

      for (var i = 1; i < nodeCount; i++) {
        var _node = nodes[nodeIndices[i]];
        var x = _node.x;
        var y = _node.y;

        if (_node.options.mass > 0) {
          if (x < minX) {
            minX = x;
          }

          if (x > maxX) {
            maxX = x;
          }

          if (y < minY) {
            minY = y;
          }

          if (y > maxY) {
            maxY = y;
          }
        }
      } // make the range a square


      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y

      if (sizeDiff > 0) {
        minY -= 0.5 * sizeDiff;
        maxY += 0.5 * sizeDiff;
      } // xSize > ySize
      else {
        minX += 0.5 * sizeDiff;
        maxX -= 0.5 * sizeDiff;
      } // xSize < ySize


      var minimumTreeSize = 1e-5;
      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
      var halfRootSize = 0.5 * rootSize;
      var centerX = 0.5 * (minX + maxX),
          centerY = 0.5 * (minY + maxY); // construct the barnesHutTree

      var barnesHutTree = {
        root: {
          centerOfMass: {
            x: 0,
            y: 0
          },
          mass: 0,
          range: {
            minX: centerX - halfRootSize,
            maxX: centerX + halfRootSize,
            minY: centerY - halfRootSize,
            maxY: centerY + halfRootSize
          },
          size: rootSize,
          calcSize: 1 / rootSize,
          children: {
            data: null
          },
          maxWidth: 0,
          level: 0,
          childrenCount: 4
        }
      };

      this._splitBranch(barnesHutTree.root); // place the nodes one by one recursively


      for (var _i = 0; _i < nodeCount; _i++) {
        node = nodes[nodeIndices[_i]];

        if (node.options.mass > 0) {
          this._placeInTree(barnesHutTree.root, node);
        }
      } // make global


      return barnesHutTree;
    }
    /**
     * this updates the mass of a branch. this is increased by adding a node.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_updateBranchMass",
    value: function _updateBranchMass(parentBranch, node) {
      var centerOfMass = parentBranch.centerOfMass;
      var totalMass = parentBranch.mass + node.options.mass;
      var totalMassInv = 1 / totalMass;
      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
      centerOfMass.x *= totalMassInv;
      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
      centerOfMass.y *= totalMassInv;
      parentBranch.mass = totalMass;
      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
    }
    /**
     * determine in which branch the node will be placed.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {boolean} skipMassUpdate
     * @private
     */

  }, {
    key: "_placeInTree",
    value: function _placeInTree(parentBranch, node, skipMassUpdate) {
      if (skipMassUpdate != true || skipMassUpdate === undefined) {
        // update the mass of the branch.
        this._updateBranchMass(parentBranch, node);
      }

      var range = parentBranch.children.NW.range;
      var region;

      if (range.maxX > node.x) {
        // in NW or SW
        if (range.maxY > node.y) {
          region = "NW";
        } else {
          region = "SW";
        }
      } else {
        // in NE or SE
        if (range.maxY > node.y) {
          region = "NE";
        } else {
          region = "SE";
        }
      }

      this._placeInRegion(parentBranch, node, region);
    }
    /**
     * actually place the node in a region (or branch)
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: "_placeInRegion",
    value: function _placeInRegion(parentBranch, node, region) {
      var children = parentBranch.children[region];

      switch (children.childrenCount) {
        case 0:
          // place node here
          children.children.data = node;
          children.childrenCount = 1;

          this._updateBranchMass(children, node);

          break;

        case 1:
          // convert into children
          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
          // we move one node a little bit and we do not put it in the tree.
          if (children.children.data.x === node.x && children.children.data.y === node.y) {
            node.x += this._rng();
            node.y += this._rng();
          } else {
            this._splitBranch(children);

            this._placeInTree(children, node);
          }

          break;

        case 4:
          // place in branch
          this._placeInTree(children, node);

          break;
      }
    }
    /**
     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
     * after the split is complete.
     *
     * @param {object} parentBranch
     * @private
     */

  }, {
    key: "_splitBranch",
    value: function _splitBranch(parentBranch) {
      // if the branch is shaded with a node, replace the node in the new subset.
      var containedNode = null;

      if (parentBranch.childrenCount === 1) {
        containedNode = parentBranch.children.data;
        parentBranch.mass = 0;
        parentBranch.centerOfMass.x = 0;
        parentBranch.centerOfMass.y = 0;
      }

      parentBranch.childrenCount = 4;
      parentBranch.children.data = null;

      this._insertRegion(parentBranch, "NW");

      this._insertRegion(parentBranch, "NE");

      this._insertRegion(parentBranch, "SW");

      this._insertRegion(parentBranch, "SE");

      if (containedNode != null) {
        this._placeInTree(parentBranch, containedNode);
      }
    }
    /**
     * This function subdivides the region into four new segments.
     * Specifically, this inserts a single new segment.
     * It fills the children section of the parentBranch
     *
     * @param {object} parentBranch
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: "_insertRegion",
    value: function _insertRegion(parentBranch, region) {
      var minX, maxX, minY, maxY;
      var childSize = 0.5 * parentBranch.size;

      switch (region) {
        case "NW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;

        case "NE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;

        case "SW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;

        case "SE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
      }

      parentBranch.children[region] = {
        centerOfMass: {
          x: 0,
          y: 0
        },
        mass: 0,
        range: {
          minX: minX,
          maxX: maxX,
          minY: minY,
          maxY: maxY
        },
        size: 0.5 * parentBranch.size,
        calcSize: 2 * parentBranch.calcSize,
        children: {
          data: null
        },
        maxWidth: 0,
        level: parentBranch.level + 1,
        childrenCount: 0
      };
    } //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * This function is for debugging purposed, it draws the tree.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: "_debug",
    value: function _debug(ctx, color) {
      if (this.barnesHutTree !== undefined) {
        ctx.lineWidth = 1;

        this._drawBranch(this.barnesHutTree.root, ctx, color);
      }
    }
    /**
     * This function is for debugging purposes. It draws the branches recursively.
     *
     * @param {object} branch
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: "_drawBranch",
    value: function _drawBranch(branch, ctx, color) {
      if (color === undefined) {
        color = "#FF0000";
      }

      if (branch.childrenCount === 4) {
        this._drawBranch(branch.children.NW, ctx);

        this._drawBranch(branch.children.NE, ctx);

        this._drawBranch(branch.children.SE, ctx);

        this._drawBranch(branch.children.SW, ctx);
      }

      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.minY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.minY);
      ctx.stroke();
      /*
       if (branch.mass > 0) {
       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
       ctx.stroke();
       }
       */
    }
  }]);

  return BarnesHutSolver;
}();

/**
 * Repulsion Solver
 */

var RepulsionSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function RepulsionSolver(body, physicsBody, options) {
    _classCallCheck(this, RepulsionSolver);

    this._rng = Alea("REPULSION SOLVER");
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(RepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // repulsing forces between nodes

      var nodeDistance = this.options.nodeDistance; // approximation constants

      var a = -2 / 3 / nodeDistance;
      var b = 4 / 3; // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j

      for (var i = 0; i < nodeIndices.length - 1; i++) {
        node1 = nodes[nodeIndices[i]];

        for (var j = i + 1; j < nodeIndices.length; j++) {
          node2 = nodes[nodeIndices[j]];
          dx = node2.x - node1.x;
          dy = node2.y - node1.y;
          distance = Math.sqrt(dx * dx + dy * dy); // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.

          if (distance === 0) {
            distance = 0.1 * this._rng();
            dx = distance;
          }

          if (distance < 2 * nodeDistance) {
            if (distance < 0.5 * nodeDistance) {
              repulsingForce = 1.0;
            } else {
              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
            }

            repulsingForce = repulsingForce / distance;
            fx = dx * repulsingForce;
            fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);

  return RepulsionSolver;
}();

/**
 * Hierarchical Repulsion Solver
 */
var HierarchicalRepulsionSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function HierarchicalRepulsionSolver(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalRepulsionSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(HierarchicalRepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // repulsing forces between nodes

      var nodeDistance = this.options.nodeDistance; // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j

      for (var i = 0; i < nodeIndices.length - 1; i++) {
        var node1 = nodes[nodeIndices[i]];

        for (var j = i + 1; j < nodeIndices.length; j++) {
          var node2 = nodes[nodeIndices[j]]; // nodes only affect nodes on their level

          if (node1.level === node2.level) {
            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);
            var dx = node2.x - node1.x;
            var dy = node2.y - node1.y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            var steepness = 0.05;
            var repulsingForce = void 0;

            if (distance < theseNodesDistance) {
              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);
            } else {
              repulsingForce = 0;
            } // normalize force with


            if (distance !== 0) {
              repulsingForce = repulsingForce / distance;
            }

            var fx = dx * repulsingForce;
            var fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);

  return HierarchicalRepulsionSolver;
}();

/**
 * Spring Solver
 */
var SpringSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function SpringSolver(body, physicsBody, options) {
    _classCallCheck(this, SpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(SpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var edges = this.body.edges;
      var node1, node2, node3; // forces caused by the edges, modelled as springs

      for (var i = 0; i < edgeIndices.length; i++) {
        edge = edges[edgeIndices[i]];

        if (edge.connected === true && edge.toId !== edge.fromId) {
          // only calculate forces if nodes are in the same sector
          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
            if (edge.edgeType.via !== undefined) {
              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
              node1 = edge.to;
              node2 = edge.edgeType.via;
              node3 = edge.from;

              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);

              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
            } else {
              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;

              this._calculateSpringForce(edge.from, edge.to, edgeLength);
            }
          }
        }
      }
    }
    /**
     * This is the code actually performing the calculation for the function above.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @param {number} edgeLength
     * @private
     */

  }, {
    key: "_calculateSpringForce",
    value: function _calculateSpringForce(node1, node2, edgeLength) {
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01); // the 1/distance is so the fx and fy can be calculated without sine or cosine.

      var springForce = this.options.springConstant * (edgeLength - distance) / distance;
      var fx = dx * springForce;
      var fy = dy * springForce; // handle the case where one node is not part of the physcis

      if (this.physicsBody.forces[node1.id] !== undefined) {
        this.physicsBody.forces[node1.id].x += fx;
        this.physicsBody.forces[node1.id].y += fy;
      }

      if (this.physicsBody.forces[node2.id] !== undefined) {
        this.physicsBody.forces[node2.id].x -= fx;
        this.physicsBody.forces[node2.id].y -= fy;
      }
    }
  }]);

  return SpringSolver;
}();

/**
 * Hierarchical Spring Solver
 */
var HierarchicalSpringSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function HierarchicalSpringSolver(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalSpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(HierarchicalSpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var dx, dy, fx, fy, springForce, distance;
      var edges = this.body.edges;
      var factor = 0.5;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // initialize the spring force counters

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        forces[nodeId].springFx = 0;
        forces[nodeId].springFy = 0;
      } // forces caused by the edges, modelled as springs


      for (var _i = 0; _i < edgeIndices.length; _i++) {
        edge = edges[edgeIndices[_i]];

        if (edge.connected === true) {
          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
          dx = edge.from.x - edge.to.x;
          dy = edge.from.y - edge.to.y;
          distance = Math.sqrt(dx * dx + dy * dy);
          distance = distance === 0 ? 0.01 : distance; // the 1/distance is so the fx and fy can be calculated without sine or cosine.

          springForce = this.options.springConstant * (edgeLength - distance) / distance;
          fx = dx * springForce;
          fy = dy * springForce;

          if (edge.to.level != edge.from.level) {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].springFx -= fx;
              forces[edge.toId].springFy -= fy;
            }

            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].springFx += fx;
              forces[edge.fromId].springFy += fy;
            }
          } else {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].x -= factor * fx;
              forces[edge.toId].y -= factor * fy;
            }

            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].x += factor * fx;
              forces[edge.fromId].y += factor * fy;
            }
          }
        }
      } // normalize spring forces


      springForce = 1;
      var springFx, springFy;

      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
        var _nodeId = nodeIndices[_i2];
        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
        forces[_nodeId].x += springFx;
        forces[_nodeId].y += springFy;
      } // retain energy balance


      var totalFx = 0;
      var totalFy = 0;

      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
        var _nodeId2 = nodeIndices[_i3];
        totalFx += forces[_nodeId2].x;
        totalFy += forces[_nodeId2].y;
      }

      var correctionFx = totalFx / nodeIndices.length;
      var correctionFy = totalFy / nodeIndices.length;

      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
        var _nodeId3 = nodeIndices[_i4];
        forces[_nodeId3].x -= correctionFx;
        forces[_nodeId3].y -= correctionFy;
      }
    }
  }]);

  return HierarchicalSpringSolver;
}();

/**
 * Central Gravity Solver
 */
var CentralGravitySolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function CentralGravitySolver(body, physicsBody, options) {
    _classCallCheck(this, CentralGravitySolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(CentralGravitySolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculates forces for each node
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, node;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        node = nodes[nodeId];
        dx = -node.x;
        dy = -node.y;
        distance = Math.sqrt(dx * dx + dy * dy);

        this._calculateForces(distance, dx, dy, forces, node);
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {object<Node.id, vis.Node>} forces
     * @param {Node} node
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
      forces[node.id].x = dx * gravityForce;
      forces[node.id].y = dy * gravityForce;
    }
  }]);

  return CentralGravitySolver;
}();

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @augments BarnesHutSolver
 */

var ForceAtlas2BasedRepulsionSolver = /*#__PURE__*/function (_BarnesHutSolver) {
  _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver);

  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
    var _this;

    _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);

    _this = _super.call(this, body, physicsBody, options);
    _this._rng = Alea("FORCE ATLAS 2 BASED REPULSION SOLVER");
    return _this;
  }
  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {Node} node
   * @param {object} parentBranch
   * @private
   */


  _createClass(ForceAtlas2BasedRepulsionSolver, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1 * this._rng();
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      }

      var degree = node.edges.length + 1; // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce

      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
  }]);

  return ForceAtlas2BasedRepulsionSolver;
}(BarnesHutSolver);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @augments CentralGravitySolver
 */

var ForceAtlas2BasedCentralGravitySolver = /*#__PURE__*/function (_CentralGravitySolver) {
  _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver);

  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
    _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);

    return _super.call(this, body, physicsBody, options);
  }
  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {object<Node.id, Node>} forces
   * @param {Node} node
   * @private
   */


  _createClass(ForceAtlas2BasedCentralGravitySolver, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      if (distance > 0) {
        var degree = node.edges.length + 1;
        var gravityForce = this.options.centralGravity * degree * node.options.mass;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }
  }]);

  return ForceAtlas2BasedCentralGravitySolver;
}(CentralGravitySolver);

/**
 * The physics engine
 */

var PhysicsEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function PhysicsEngine(body) {
    _classCallCheck(this, PhysicsEngine);

    this.body = body;
    this.physicsBody = {
      physicsNodeIndices: [],
      physicsEdgeIndices: [],
      forces: {},
      velocities: {}
    };
    this.physicsEnabled = true;
    this.simulationInterval = 1000 / 60;
    this.requiresTimeout = true;
    this.previousStates = {};
    this.referenceState = {};
    this.freezeCache = {};
    this.renderTimer = undefined; // parameters for the adaptive timestep

    this.adaptiveTimestep = false;
    this.adaptiveTimestepEnabled = false;
    this.adaptiveCounter = 0;
    this.adaptiveInterval = 3;
    this.stabilized = false;
    this.startedStabilization = false;
    this.stabilizationIterations = 0;
    this.ready = false; // will be set to true if the stabilize
    // default options

    this.options = {};
    this.defaultOptions = {
      enabled: true,
      barnesHut: {
        theta: 0.5,
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 95,
        springConstant: 0.04,
        damping: 0.09,
        avoidOverlap: 0
      },
      forceAtlas2Based: {
        theta: 0.5,
        gravitationalConstant: -50,
        centralGravity: 0.01,
        springConstant: 0.08,
        springLength: 100,
        damping: 0.4,
        avoidOverlap: 0
      },
      repulsion: {
        centralGravity: 0.2,
        springLength: 200,
        springConstant: 0.05,
        nodeDistance: 100,
        damping: 0.09,
        avoidOverlap: 0
      },
      hierarchicalRepulsion: {
        centralGravity: 0.0,
        springLength: 100,
        springConstant: 0.01,
        nodeDistance: 120,
        damping: 0.09
      },
      maxVelocity: 50,
      minVelocity: 0.75,
      // px/s
      solver: "barnesHut",
      stabilization: {
        enabled: true,
        iterations: 1000,
        // maximum number of iteration to stabilize
        updateInterval: 50,
        onlyDynamicEdges: false,
        fit: true
      },
      timestep: 0.5,
      adaptiveTimestep: true,
      wind: {
        x: 0,
        y: 0
      }
    };

    assign$2(this.options, this.defaultOptions);

    this.timestep = 0.5;
    this.layoutFailed = false;
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(PhysicsEngine, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on("initPhysics", function () {
        _this.initPhysics();
      });
      this.body.emitter.on("_layoutFailed", function () {
        _this.layoutFailed = true;
      });
      this.body.emitter.on("resetPhysics", function () {
        _this.stopSimulation();

        _this.ready = false;
      });
      this.body.emitter.on("disablePhysics", function () {
        _this.physicsEnabled = false;

        _this.stopSimulation();
      });
      this.body.emitter.on("restorePhysics", function () {
        _this.setOptions(_this.options);

        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("startSimulation", function () {
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("stopSimulation", function () {
        _this.stopSimulation();
      });
      this.body.emitter.on("destroy", function () {
        _this.stopSimulation(false);

        _this.body.emitter.off();
      });
      this.body.emitter.on("_dataChanged", function () {
        // Nodes and/or edges have been added or removed, update shortcut lists.
        _this.updatePhysicsData();
      }); // debug: show forces
      // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
    }
    /**
     * set the physics options
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        if (options === false) {
          this.options.enabled = false;
          this.physicsEnabled = false;
          this.stopSimulation();
        } else if (options === true) {
          this.options.enabled = true;
          this.physicsEnabled = true;
          this.startSimulation();
        } else {
          this.physicsEnabled = true;
          selectiveNotDeepExtend(["stabilization"], this.options, options);
          mergeOptions(this.options, options, "stabilization");

          if (options.enabled === undefined) {
            this.options.enabled = true;
          }

          if (this.options.enabled === false) {
            this.physicsEnabled = false;
            this.stopSimulation();
          }

          var wind = this.options.wind;

          if (wind) {
            if (typeof wind.x !== "number" || isNan(wind.x)) {
              wind.x = 0;
            }

            if (typeof wind.y !== "number" || isNan(wind.y)) {
              wind.y = 0;
            }
          } // set the timestep


          this.timestep = this.options.timestep;
        }
      }

      this.init();
    }
    /**
     * configure the engine.
     */

  }, {
    key: "init",
    value: function init() {
      var options;

      if (this.options.solver === "forceAtlas2Based") {
        options = this.options.forceAtlas2Based;
        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "repulsion") {
        options = this.options.repulsion;
        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "hierarchicalRepulsion") {
        options = this.options.hierarchicalRepulsion;
        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else {
        // barnesHut
        options = this.options.barnesHut;
        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      }

      this.modelOptions = options;
    }
    /**
     * initialize the engine
     */

  }, {
    key: "initPhysics",
    value: function initPhysics() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        if (this.options.stabilization.enabled === true) {
          this.stabilize();
        } else {
          this.stabilized = false;
          this.ready = true;
          this.body.emitter.emit("fit", {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom

          this.startSimulation();
        }
      } else {
        this.ready = true;
        this.body.emitter.emit("fit");
      }
    }
    /**
     * Start the simulation
     */

  }, {
    key: "startSimulation",
    value: function startSimulation() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        this.stabilized = false; // when visible, adaptivity is disabled.

        this.adaptiveTimestep = false; // this sets the width of all nodes initially which could be required for the avoidOverlap

        this.body.emitter.emit("_resizeNodes");

        if (this.viewFunction === undefined) {
          var _context;

          this.viewFunction = bind$6(_context = this.simulationStep).call(_context, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      } else {
        this.body.emitter.emit("_redraw");
      }
    }
    /**
     * Stop the simulation, force stabilization.
     *
     * @param {boolean} [emit=true]
     */

  }, {
    key: "stopSimulation",
    value: function stopSimulation() {
      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.stabilized = true;

      if (emit === true) {
        this._emitStabilized();
      }

      if (this.viewFunction !== undefined) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.viewFunction = undefined;

        if (emit === true) {
          this.body.emitter.emit("_stopRendering");
        }
      }
    }
    /**
     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
     *
     */

  }, {
    key: "simulationStep",
    value: function simulationStep() {
      // check if the physics have settled
      var startTime = now$1();

      this.physicsTick();
      var physicsTime = now$1() - startTime; // run double speed if it is a little graph

      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
        this.physicsTick(); // this makes sure there is no jitter. The decision is taken once to run it at double speed.

        this.runDoubleSpeed = true;
      }

      if (this.stabilized === true) {
        this.stopSimulation();
      }
    }
    /**
     * trigger the stabilized event.
     *
     * @param {number} [amountOfIterations=this.stabilizationIterations]
     * @private
     */

  }, {
    key: "_emitStabilized",
    value: function _emitStabilized() {
      var _this2 = this;

      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;

      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
        setTimeout$1(function () {
          _this2.body.emitter.emit("stabilized", {
            iterations: amountOfIterations
          });

          _this2.startedStabilization = false;
          _this2.stabilizationIterations = 0;
        }, 0);
      }
    }
    /**
     * Calculate the forces for one physics iteration and move the nodes.
     *
     * @private
     */

  }, {
    key: "physicsStep",
    value: function physicsStep() {
      this.gravitySolver.solve();
      this.nodesSolver.solve();
      this.edgesSolver.solve();
      this.moveNodes();
    }
    /**
     * Make dynamic adjustments to the timestep, based on current state.
     *
     * Helper function for physicsTick().
     *
     * @private
     */

  }, {
    key: "adjustTimeStep",
    value: function adjustTimeStep() {
      var factor = 1.2; // Factor for increasing the timestep on success.
      // we compare the two steps. if it is acceptable we double the step.

      if (this._evaluateStepQuality() === true) {
        this.timestep = factor * this.timestep;
      } else {
        // if not, we decrease the step to a minimum of the options timestep.
        // if the decreased timestep is smaller than the options step, we do not reset the counter
        // we assume that the options timestep is stable enough.
        if (this.timestep / factor < this.options.timestep) {
          this.timestep = this.options.timestep;
        } else {
          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
          // that large instabilities do not form.
          this.adaptiveCounter = -1; // check again next iteration

          this.timestep = Math.max(this.options.timestep, this.timestep / factor);
        }
      }
    }
    /**
     * A single simulation step (or 'tick') in the physics simulation
     *
     * @private
     */

  }, {
    key: "physicsTick",
    value: function physicsTick() {
      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.


      if (this.stabilized === true) return; // adaptivity means the timestep adapts to the situation, only applicable for stabilization

      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
        // timestep remains stable for "interval" iterations.
        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;

        if (doAdaptive) {
          // first the big step and revert.
          this.timestep = 2 * this.timestep;
          this.physicsStep();
          this.revert(); // saves the reference state
          // now the normal step. Since this is the last step, it is the more stable one and we will take this.

          this.timestep = 0.5 * this.timestep; // since it's half the step, we do it twice.

          this.physicsStep();
          this.physicsStep();
          this.adjustTimeStep();
        } else {
          this.physicsStep(); // normal step, keeping timestep constant
        }

        this.adaptiveCounter += 1;
      } else {
        // case for the static timestep, we reset it to the one in options and take a normal step.
        this.timestep = this.options.timestep;
        this.physicsStep();
      }

      if (this.stabilized === true) this.revert();
      this.stabilizationIterations++;
    }
    /**
     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
     *
     * @private
     */

  }, {
    key: "updatePhysicsData",
    value: function updatePhysicsData() {
      this.physicsBody.forces = {};
      this.physicsBody.physicsNodeIndices = [];
      this.physicsBody.physicsEdgeIndices = [];
      var nodes = this.body.nodes;
      var edges = this.body.edges; // get node indices for physics

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (nodes[nodeId].options.physics === true) {
            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
          }
        }
      } // get edge indices for physics


      for (var edgeId in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
          if (edges[edgeId].options.physics === true) {
            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
          }
        }
      } // get the velocity and the forces vector


      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var _nodeId = this.physicsBody.physicsNodeIndices[i];
        this.physicsBody.forces[_nodeId] = {
          x: 0,
          y: 0
        }; // forces can be reset because they are recalculated. Velocities have to persist.

        if (this.physicsBody.velocities[_nodeId] === undefined) {
          this.physicsBody.velocities[_nodeId] = {
            x: 0,
            y: 0
          };
        }
      } // clean deleted nodes from the velocity vector


      for (var _nodeId2 in this.physicsBody.velocities) {
        if (nodes[_nodeId2] === undefined) {
          delete this.physicsBody.velocities[_nodeId2];
        }
      }
    }
    /**
     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
     */

  }, {
    key: "revert",
    value: function revert() {
      var nodeIds = keys$4(this.previousStates);

      var nodes = this.body.nodes;
      var velocities = this.physicsBody.velocities;
      this.referenceState = {};

      for (var i = 0; i < nodeIds.length; i++) {
        var nodeId = nodeIds[i];

        if (nodes[nodeId] !== undefined) {
          if (nodes[nodeId].options.physics === true) {
            this.referenceState[nodeId] = {
              positions: {
                x: nodes[nodeId].x,
                y: nodes[nodeId].y
              }
            };
            velocities[nodeId].x = this.previousStates[nodeId].vx;
            velocities[nodeId].y = this.previousStates[nodeId].vy;
            nodes[nodeId].x = this.previousStates[nodeId].x;
            nodes[nodeId].y = this.previousStates[nodeId].y;
          }
        } else {
          delete this.previousStates[nodeId];
        }
      }
    }
    /**
     * This compares the reference state to the current state
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_evaluateStepQuality",
    value: function _evaluateStepQuality() {
      var dx, dy, dpos;
      var nodes = this.body.nodes;
      var reference = this.referenceState;
      var posThreshold = 0.3;

      for (var nodeId in this.referenceState) {
        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== undefined) {
          dx = nodes[nodeId].x - reference[nodeId].positions.x;
          dy = nodes[nodeId].y - reference[nodeId].positions.y;
          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

          if (dpos > posThreshold) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * move the nodes one timestep and check if they are stabilized
     */

  }, {
    key: "moveNodes",
    value: function moveNodes() {
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var maxNodeVelocity = 0;
      var averageNodeVelocity = 0; // the velocity threshold (energy in the system) for the adaptivity toggle

      var velocityAdaptiveThreshold = 5;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];

        var nodeVelocity = this._performStep(nodeId); // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized


        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
        averageNodeVelocity += nodeVelocity;
      } // evaluating the stabilized and adaptiveTimestepEnabled conditions


      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
      this.stabilized = maxNodeVelocity < this.options.minVelocity;
    }
    /**
     * Calculate new velocity for a coordinate direction
     *
     * @param {number} v  velocity for current coordinate
     * @param {number} f  regular force for current coordinate
     * @param {number} m  mass of current node
     * @returns {number} new velocity for current coordinate
     * @private
     */

  }, {
    key: "calculateComponentVelocity",
    value: function calculateComponentVelocity(v, f, m) {
      var df = this.modelOptions.damping * v; // damping force

      var a = (f - df) / m; // acceleration

      v += a * this.timestep; // Put a limit on the velocities if it is really high

      var maxV = this.options.maxVelocity || 1e9;

      if (Math.abs(v) > maxV) {
        v = v > 0 ? maxV : -maxV;
      }

      return v;
    }
    /**
     * Perform the actual step
     *
     * @param {Node.id} nodeId
     * @returns {number} the new velocity of given node
     * @private
     */

  }, {
    key: "_performStep",
    value: function _performStep(nodeId) {
      var node = this.body.nodes[nodeId];
      var force = this.physicsBody.forces[nodeId];

      if (this.options.wind) {
        force.x += this.options.wind.x;
        force.y += this.options.wind.y;
      }

      var velocity = this.physicsBody.velocities[nodeId]; // store the state so we can revert

      this.previousStates[nodeId] = {
        x: node.x,
        y: node.y,
        vx: velocity.x,
        vy: velocity.y
      };

      if (node.options.fixed.x === false) {
        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
        node.x += velocity.x * this.timestep;
      } else {
        force.x = 0;
        velocity.x = 0;
      }

      if (node.options.fixed.y === false) {
        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
        node.y += velocity.y * this.timestep;
      } else {
        force.y = 0;
        velocity.y = 0;
      }

      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
      return totalVelocity;
    }
    /**
     * When initializing and stabilizing, we can freeze nodes with a predefined position.
     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
     *
     * @private
     */

  }, {
    key: "_freezeNodes",
    value: function _freezeNodes() {
      var nodes = this.body.nodes;

      for (var id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          if (nodes[id].x && nodes[id].y) {
            var fixed = nodes[id].options.fixed;
            this.freezeCache[id] = {
              x: fixed.x,
              y: fixed.y
            };
            fixed.x = true;
            fixed.y = true;
          }
        }
      }
    }
    /**
     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
     *
     * @private
     */

  }, {
    key: "_restoreFrozenNodes",
    value: function _restoreFrozenNodes() {
      var nodes = this.body.nodes;

      for (var id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          if (this.freezeCache[id] !== undefined) {
            nodes[id].options.fixed.x = this.freezeCache[id].x;
            nodes[id].options.fixed.y = this.freezeCache[id].y;
          }
        }
      }

      this.freezeCache = {};
    }
    /**
     * Find a stable position for all nodes
     *
     * @param {number} [iterations=this.options.stabilization.iterations]
     */

  }, {
    key: "stabilize",
    value: function stabilize() {
      var _this3 = this;

      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;

      if (typeof iterations !== "number") {
        iterations = this.options.stabilization.iterations;
        console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
      }

      if (this.physicsBody.physicsNodeIndices.length === 0) {
        this.ready = true;
        return;
      } // enable adaptive timesteps


      this.adaptiveTimestep = this.options.adaptiveTimestep; // this sets the width of all nodes initially which could be required for the avoidOverlap

      this.body.emitter.emit("_resizeNodes");
      this.stopSimulation(); // stop the render loop

      this.stabilized = false; // block redraw requests

      this.body.emitter.emit("_blockRedraw");
      this.targetIterations = iterations; // start the stabilization

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._freezeNodes();
      }

      this.stabilizationIterations = 0;

      setTimeout$1(function () {
        return _this3._stabilizationBatch();
      }, 0);
    }
    /**
     * If not already stabilizing, start it and emit a start event.
     *
     * @returns {boolean} true if stabilization started with this call
     * @private
     */

  }, {
    key: "_startStabilizing",
    value: function _startStabilizing() {
      if (this.startedStabilization === true) return false;
      this.body.emitter.emit("startStabilizing");
      this.startedStabilization = true;
      return true;
    }
    /**
     * One batch of stabilization
     *
     * @private
     */

  }, {
    key: "_stabilizationBatch",
    value: function _stabilizationBatch() {
      var _this4 = this;

      var running = function running() {
        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
      };

      var sendProgress = function sendProgress() {
        _this4.body.emitter.emit("stabilizationProgress", {
          iterations: _this4.stabilizationIterations,
          total: _this4.targetIterations
        });
      };

      if (this._startStabilizing()) {
        sendProgress(); // Ensure that there is at least one start event.
      }

      var count = 0;

      while (running() && count < this.options.stabilization.updateInterval) {
        this.physicsTick();
        count++;
      }

      sendProgress();

      if (running()) {
        var _context2;

        setTimeout$1(bind$6(_context2 = this._stabilizationBatch).call(_context2, this), 0);
      } else {
        this._finalizeStabilization();
      }
    }
    /**
     * Wrap up the stabilization, fit and emit the events.
     *
     * @private
     */

  }, {
    key: "_finalizeStabilization",
    value: function _finalizeStabilization() {
      this.body.emitter.emit("_allowRedraw");

      if (this.options.stabilization.fit === true) {
        this.body.emitter.emit("fit");
      }

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._restoreFrozenNodes();
      }

      this.body.emitter.emit("stabilizationIterationsDone");
      this.body.emitter.emit("_requestRedraw");

      if (this.stabilized === true) {
        this._emitStabilized();
      } else {
        this.startSimulation();
      }

      this.ready = true;
    } //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * Debug function that display arrows for the forces currently active in the network.
     *
     * Use this when debugging only.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: "_drawForces",
    value: function _drawForces(ctx) {
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var index = this.physicsBody.physicsNodeIndices[i];
        var node = this.body.nodes[index];
        var force = this.physicsBody.forces[index];
        var factor = 20;
        var colorFactor = 0.03;
        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
        var size = Math.min(Math.max(5, forceSize), 15);
        var arrowSize = 3 * size;
        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
        var point = {
          x: node.x + factor * force.x,
          y: node.y + factor * force.y
        };
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
        var angle = Math.atan2(force.y, force.x);
        ctx.fillStyle = color;
        EndPoints.draw(ctx, {
          type: "arrow",
          point: point,
          angle: angle,
          length: arrowSize
        });

        fill(ctx).call(ctx);
      }
    }
  }]);

  return PhysicsEngine;
}();

/**
 * Utility Class
 */

var NetworkUtil = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function NetworkUtil() {
    _classCallCheck(this, NetworkUtil);
  }
  /**
   * Find the center position of the network considering the bounding boxes
   *
   * @param {Array.<Node>} allNodes
   * @param {Array.<Node>} [specificNodes=[]]
   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
   * @static
   */


  _createClass(NetworkUtil, null, [{
    key: "getRange",
    value: function getRange(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;

      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];

          if (minX > node.shape.boundingBox.left) {
            minX = node.shape.boundingBox.left;
          }

          if (maxX < node.shape.boundingBox.right) {
            maxX = node.shape.boundingBox.right;
          }

          if (minY > node.shape.boundingBox.top) {
            minY = node.shape.boundingBox.top;
          } // top is negative, bottom is positive


          if (maxY < node.shape.boundingBox.bottom) {
            maxY = node.shape.boundingBox.bottom;
          } // top is negative, bottom is positive

        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }

      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    }
    /**
     * Find the center position of the network
     *
     * @param {Array.<Node>} allNodes
     * @param {Array.<Node>} [specificNodes=[]]
     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
     * @static
     */

  }, {
    key: "getRangeCore",
    value: function getRangeCore(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;

      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];

          if (minX > node.x) {
            minX = node.x;
          }

          if (maxX < node.x) {
            maxX = node.x;
          }

          if (minY > node.y) {
            minY = node.y;
          } // top is negative, bottom is positive


          if (maxY < node.y) {
            maxY = node.y;
          } // top is negative, bottom is positive

        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }

      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    }
    /**
     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
     * @returns {{x: number, y: number}}
     * @static
     */

  }, {
    key: "findCenter",
    value: function findCenter(range) {
      return {
        x: 0.5 * (range.maxX + range.minX),
        y: 0.5 * (range.maxY + range.minY)
      };
    }
    /**
     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
     *
     * @param {vis.Item} item
     * @param {'node'|undefined} type
     * @returns {{}}
     * @static
     */

  }, {
    key: "cloneOptions",
    value: function cloneOptions(item, type) {
      var clonedOptions = {};

      if (type === undefined || type === "node") {
        deepExtend(clonedOptions, item.options, true);
        clonedOptions.x = item.x;
        clonedOptions.y = item.y;
        clonedOptions.amountOfConnections = item.edges.length;
      } else {
        deepExtend(clonedOptions, item.options, true);
      }

      return clonedOptions;
    }
  }]);

  return NetworkUtil;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Cluster is a special Node that allows a group of Nodes positioned closely together
 * to be represented by a single Cluster Node.
 *
 * @augments Node
 */

var Cluster = /*#__PURE__*/function (_Node) {
  _inherits(Cluster, _Node);

  var _super = _createSuper$1(Cluster);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Array.<HTMLImageElement>}imagelist
   * @param {Array} grouplist
   * @param {object} globalOptions
   * @param {object} defaultOptions     Global default options for nodes
   */
  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    var _this;

    _classCallCheck(this, Cluster);

    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions);
    _this.isCluster = true;
    _this.containedNodes = {};
    _this.containedEdges = {};
    return _this;
  }
  /**
   * Transfer child cluster data to current and disconnect the child cluster.
   *
   * Please consult the header comment in 'Clustering.js' for the fields set here.
   *
   * @param {string|number} childClusterId  id of child cluster to open
   */


  _createClass(Cluster, [{
    key: "_openChildCluster",
    value: function _openChildCluster(childClusterId) {
      var _this2 = this;

      var childCluster = this.body.nodes[childClusterId];

      if (this.containedNodes[childClusterId] === undefined) {
        throw new Error("node with id: " + childClusterId + " not in current cluster");
      }

      if (!childCluster.isCluster) {
        throw new Error("node with id: " + childClusterId + " is not a cluster");
      } // Disconnect child cluster from current cluster


      delete this.containedNodes[childClusterId];
      forEach$1(childCluster.edges, function (edge) {
        delete _this2.containedEdges[edge.id];
      }); // Transfer nodes and edges

      forEach$1(childCluster.containedNodes, function (node, nodeId) {
        _this2.containedNodes[nodeId] = node;
      });
      childCluster.containedNodes = {};
      forEach$1(childCluster.containedEdges, function (edge, edgeId) {
        _this2.containedEdges[edgeId] = edge;
      });
      childCluster.containedEdges = {}; // Transfer edges within cluster edges which are clustered

      forEach$1(childCluster.edges, function (clusterEdge) {
        forEach$1(_this2.edges, function (parentClusterEdge) {
          var _context, _context2;

          // Assumption: a clustered edge can only be present in a single clustering edge
          // Not tested here
          var index = indexOf(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);

          if (index === -1) return;
          forEach$1(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {
            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId); // Maintain correct bookkeeping for transferred edge

            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
          }); // Remove cluster edge from parent cluster edge

          splice$1(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index, 1);
        });
      });
      childCluster.edges = [];
    }
  }]);

  return Cluster;
}(Node);

/**
 * The clustering engine
 */

var ClusterEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function ClusterEngine(body) {
    var _this = this;

    _classCallCheck(this, ClusterEngine);

    this.body = body;
    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}

    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge

    this.options = {};
    this.defaultOptions = {};

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("_resetData", function () {
      _this.clusteredNodes = {};
      _this.clusteredEdges = {};
    });
  }
  /**
   *
   * @param {number} hubsize
   * @param {object} options
   */


  _createClass(ClusterEngine, [{
    key: "clusterByHubsize",
    value: function clusterByHubsize(hubsize, options) {
      if (hubsize === undefined) {
        hubsize = this._getHubSize();
      } else if (_typeof(hubsize) === "object") {
        options = this._checkOptions(hubsize);
        hubsize = this._getHubSize();
      }

      var nodesToCluster = [];

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];

        if (node.edges.length >= hubsize) {
          nodesToCluster.push(node.id);
        }
      }

      for (var _i = 0; _i < nodesToCluster.length; _i++) {
        this.clusterByConnection(nodesToCluster[_i], options, true);
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * loop over all nodes, check if they adhere to the condition and cluster if needed.
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "cluster",
    value: function cluster() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (options.joinCondition === undefined) {
        throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
      } // check if the options object is fine, append if needed


      options = this._checkOptions(options);
      var childNodesObj = {};
      var childEdgesObj = {}; // collect the nodes that will be in the cluster

      forEach$1(this.body.nodes, function (node, nodeId) {
        if (node.options && options.joinCondition(node.options) === true) {
          childNodesObj[nodeId] = node; // collect the edges that will be in the cluster

          forEach$1(node.edges, function (edge) {
            if (_this2.clusteredEdges[edge.id] === undefined) {
              childEdgesObj[edge.id] = edge;
            }
          });
        }
      });

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only X edges
     *
     * @param {number} edgeCount
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterByEdgeCount",
    value: function clusterByEdgeCount(edgeCount, options) {
      var _this3 = this;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      options = this._checkOptions(options);
      var clusters = [];
      var usedNodes = {};
      var edge, edges, relevantEdgeCount; // collect the nodes that will be in the cluster

      var _loop = function _loop(i) {
        var childNodesObj = {};
        var childEdgesObj = {};
        var nodeId = _this3.body.nodeIndices[i];
        var node = _this3.body.nodes[nodeId]; // if this node is already used in another cluster this session, we do not have to re-evaluate it.

        if (usedNodes[nodeId] === undefined) {
          relevantEdgeCount = 0;
          edges = [];

          for (var j = 0; j < node.edges.length; j++) {
            edge = node.edges[j];

            if (_this3.clusteredEdges[edge.id] === undefined) {
              if (edge.toId !== edge.fromId) {
                relevantEdgeCount++;
              }

              edges.push(edge);
            }
          } // this node qualifies, we collect its neighbours to start the clustering process.


          if (relevantEdgeCount === edgeCount) {
            var checkJoinCondition = function checkJoinCondition(node) {
              if (options.joinCondition === undefined || options.joinCondition === null) {
                return true;
              }

              var clonedOptions = NetworkUtil.cloneOptions(node);
              return options.joinCondition(clonedOptions);
            };

            var gatheringSuccessful = true;

            for (var _j = 0; _j < edges.length; _j++) {
              edge = edges[_j];

              var childNodeId = _this3._getConnectedId(edge, nodeId); // add the nodes to the list by the join condition.


              if (checkJoinCondition(node)) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[nodeId] = node;
                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                usedNodes[nodeId] = true;
              } else {
                // this node does not qualify after all.
                gatheringSuccessful = false;
                break;
              }
            } // add to the cluster queue


            if (keys$4(childNodesObj).length > 0 && keys$4(childEdgesObj).length > 0 && gatheringSuccessful === true) {
              /**
               * Search for cluster data that contains any of the node id's
               *
               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition
               */
              var findClusterData = function findClusterData() {
                for (var n = 0; n < clusters.length; ++n) {
                  // Search for a cluster containing any of the node id's
                  for (var m in childNodesObj) {
                    if (clusters[n].nodes[m] !== undefined) {
                      return clusters[n];
                    }
                  }
                }

                return undefined;
              }; // If any of the found nodes is part of a cluster found in this method,
              // add the current values to that cluster


              var foundCluster = findClusterData();

              if (foundCluster !== undefined) {
                // Add nodes to found cluster if not present
                for (var m in childNodesObj) {
                  if (foundCluster.nodes[m] === undefined) {
                    foundCluster.nodes[m] = childNodesObj[m];
                  }
                } // Add edges to found cluster, if not present


                for (var _m in childEdgesObj) {
                  if (foundCluster.edges[_m] === undefined) {
                    foundCluster.edges[_m] = childEdgesObj[_m];
                  }
                }
              } else {
                // Create a new cluster group
                clusters.push({
                  nodes: childNodesObj,
                  edges: childEdgesObj
                });
              }
            }
          }
        }
      };

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        _loop(i);
      }

      for (var _i2 = 0; _i2 < clusters.length; _i2++) {
        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);
      }

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Cluster all nodes in the network that have only 1 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterOutliers",
    value: function clusterOutliers(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.clusterByEdgeCount(1, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only 2 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterBridges",
    value: function clusterBridges(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.clusterByEdgeCount(2, options, refreshData);
    }
    /**
     * suck all connected nodes of a node into the node.
     *
     * @param {Node.id} nodeId
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterByConnection",
    value: function clusterByConnection(nodeId, options) {
      var _context;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (nodeId === undefined) {
        throw new Error("No nodeId supplied to clusterByConnection!");
      }

      if (this.body.nodes[nodeId] === undefined) {
        throw new Error("The nodeId given to clusterByConnection does not exist!");
      }

      var node = this.body.nodes[nodeId];
      options = this._checkOptions(options, node);

      if (options.clusterNodeProperties.x === undefined) {
        options.clusterNodeProperties.x = node.x;
      }

      if (options.clusterNodeProperties.y === undefined) {
        options.clusterNodeProperties.y = node.y;
      }

      if (options.clusterNodeProperties.fixed === undefined) {
        options.clusterNodeProperties.fixed = {};
        options.clusterNodeProperties.fixed.x = node.options.fixed.x;
        options.clusterNodeProperties.fixed.y = node.options.fixed.y;
      }

      var childNodesObj = {};
      var childEdgesObj = {};
      var parentNodeId = node.id;
      var parentClonedOptions = NetworkUtil.cloneOptions(node);
      childNodesObj[parentNodeId] = node; // collect the nodes that will be in the cluster

      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];

        if (this.clusteredEdges[edge.id] === undefined) {
          var childNodeId = this._getConnectedId(edge, parentNodeId); // if the child node is not in a cluster


          if (this.clusteredNodes[childNodeId] === undefined) {
            if (childNodeId !== parentNodeId) {
              if (options.joinCondition === undefined) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[childNodeId] = this.body.nodes[childNodeId];
              } else {
                // clone the options and insert some additional parameters that could be interesting.
                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);

                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                }
              }
            } else {
              // swallow the edge if it is self-referencing.
              childEdgesObj[edge.id] = edge;
            }
          }
        }
      }

      var childNodeIDs = map$3(_context = keys$4(childNodesObj)).call(_context, function (childNode) {
        return childNodesObj[childNode].id;
      });

      for (var childNodeKey in childNodesObj) {
        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;
        var childNode = childNodesObj[childNodeKey];

        for (var y = 0; y < childNode.edges.length; y++) {
          var childEdge = childNode.edges[y];

          if (indexOf(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {
            childEdgesObj[childEdge.id] = childEdge;
          }
        }
      }

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * This function creates the edges that will be attached to the cluster
     * It looks for edges that are connected to the nodes from the "outside' of the cluster.
     *
     * @param {{Node.id: vis.Node}} childNodesObj
     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
     * @param {object} clusterNodeProperties
     * @param {object} clusterEdgeProperties
     * @private
     */

  }, {
    key: "_createClusterEdges",
    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
      var edge, childNodeId, childNode, toId, fromId, otherNodeId; // loop over all child nodes and their edges to find edges going out of the cluster
      // these edges will be replaced by clusterEdges.

      var childKeys = keys$4(childNodesObj);

      var createEdges = [];

      for (var i = 0; i < childKeys.length; i++) {
        childNodeId = childKeys[i];
        childNode = childNodesObj[childNodeId]; // construct new edges from the cluster to others

        for (var j = 0; j < childNode.edges.length; j++) {
          edge = childNode.edges[j]; // we only handle edges that are visible to the system, not the disabled ones from the clustering process.

          if (this.clusteredEdges[edge.id] === undefined) {
            // self-referencing edges will be added to the "hidden" list
            if (edge.toId == edge.fromId) {
              childEdgesObj[edge.id] = edge;
            } else {
              // set up the from and to.
              if (edge.toId == childNodeId) {
                // this is a double equals because ints and strings can be interchanged here.
                toId = clusterNodeProperties.id;
                fromId = edge.fromId;
                otherNodeId = fromId;
              } else {
                toId = edge.toId;
                fromId = clusterNodeProperties.id;
                otherNodeId = toId;
              }
            } // Only edges from the cluster outwards are being replaced.


            if (childNodesObj[otherNodeId] === undefined) {
              createEdges.push({
                edge: edge,
                fromId: fromId,
                toId: toId
              });
            }
          }
        }
      } //
      // Here we actually create the replacement edges.
      //
      // We could not do this in the loop above as the creation process
      // would add an edge to the edges array we are iterating over.
      //
      // NOTE: a clustered edge can have multiple base edges!
      //


      var newEdges = [];
      /**
       * Find a cluster edge which matches the given created edge.
       *
       * @param {vis.Edge} createdEdge
       * @returns {vis.Edge}
       */

      var getNewEdge = function getNewEdge(createdEdge) {
        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
          var newEdge = newEdges[_j2]; // We replace both to and from edges with a single cluster edge

          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;
          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;

          if (matchToDirection || matchFromDirection) {
            return newEdge;
          }
        }

        return null;
      };

      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
        var createdEdge = createEdges[_j3];
        var _edge = createdEdge.edge;
        var newEdge = getNewEdge(createdEdge);

        if (newEdge === null) {
          // Create a clustered edge for this connection
          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
          newEdges.push(newEdge);
        } else {
          newEdge.clusteringEdgeReplacingIds.push(_edge.id);
        } // also reference the new edge in the old edge


        this.body.edges[_edge.id].edgeReplacedById = newEdge.id; // hide the replaced edge

        this._backupEdgeOptions(_edge);

        _edge.setOptions({
          physics: false
        });
      }
    }
    /**
     * This function checks the options that can be supplied to the different cluster functions
     * for certain fields and inserts defaults if needed
     *
     * @param {object} options
     * @returns {*}
     * @private
     */

  }, {
    key: "_checkOptions",
    value: function _checkOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.clusterEdgeProperties === undefined) {
        options.clusterEdgeProperties = {};
      }

      if (options.clusterNodeProperties === undefined) {
        options.clusterNodeProperties = {};
      }

      return options;
    }
    /**
     *
     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
     * @param {object}    childEdgesObj         | object with edge objects, id as keys
     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
     * @param {boolean}   refreshData | when true, do not wrap up
     * @private
     */

  }, {
    key: "_cluster",
    value: function _cluster(childNodesObj, childEdgesObj, options) {
      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      // Remove nodes which are already clustered
      var tmpNodesToRemove = [];

      for (var nodeId in childNodesObj) {
        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {
          if (this.clusteredNodes[nodeId] !== undefined) {
            tmpNodesToRemove.push(nodeId);
          }
        }
      }

      for (var n = 0; n < tmpNodesToRemove.length; ++n) {
        delete childNodesObj[tmpNodesToRemove[n]];
      } // kill condition: no nodes don't bother


      if (keys$4(childNodesObj).length == 0) {
        return;
      } // allow clusters of 1 if options allow


      if (keys$4(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
        return;
      }

      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties); // construct the clusterNodeProperties

      if (options.processProperties !== undefined) {
        // get the childNode options
        var childNodesOptions = [];

        for (var _nodeId in childNodesObj) {
          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {
            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);
            childNodesOptions.push(clonedOptions);
          }
        } // get cluster properties based on childNodes


        var childEdgesOptions = [];

        for (var edgeId in childEdgesObj) {
          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {
            // these cluster edges will be removed on creation of the cluster.
            if (edgeId.substr(0, 12) !== "clusterEdge:") {
              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");

              childEdgesOptions.push(_clonedOptions);
            }
          }
        }

        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);

        if (!clusterNodeProperties) {
          throw new Error("The processProperties function does not return properties!");
        }
      } // check if we have an unique id;


      if (clusterNodeProperties.id === undefined) {
        clusterNodeProperties.id = "cluster:" + v4();
      }

      var clusterId = clusterNodeProperties.id;

      if (clusterNodeProperties.label === undefined) {
        clusterNodeProperties.label = "cluster";
      } // give the clusterNode a position if it does not have one.


      var pos = undefined;

      if (clusterNodeProperties.x === undefined) {
        pos = this._getClusterPosition(childNodesObj);
        clusterNodeProperties.x = pos.x;
      }

      if (clusterNodeProperties.y === undefined) {
        if (pos === undefined) {
          pos = this._getClusterPosition(childNodesObj);
        }

        clusterNodeProperties.y = pos.y;
      } // force the ID to remain the same


      clusterNodeProperties.id = clusterId; // create the cluster Node
      // Note that allowSingleNodeCluster, if present, is stored in the options as well

      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
      clusterNode.containedNodes = childNodesObj;
      clusterNode.containedEdges = childEdgesObj; // cache a copy from the cluster edge properties if we have to reconnect others later on

      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties; // finally put the cluster node into global

      this.body.nodes[clusterNodeProperties.id] = clusterNode;

      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties); // set ID to undefined so no duplicates arise


      clusterNodeProperties.id = undefined; // wrap up

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: "_backupEdgeOptions",
    value: function _backupEdgeOptions(edge) {
      if (this.clusteredEdges[edge.id] === undefined) {
        this.clusteredEdges[edge.id] = {
          physics: edge.options.physics
        };
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: "_restoreEdge",
    value: function _restoreEdge(edge) {
      var originalOptions = this.clusteredEdges[edge.id];

      if (originalOptions !== undefined) {
        edge.setOptions({
          physics: originalOptions.physics
        });
        delete this.clusteredEdges[edge.id];
      }
    }
    /**
     * Check if a node is a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: "isCluster",
    value: function isCluster(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].isCluster === true;
      } else {
        console.error("Node does not exist.");
        return false;
      }
    }
    /**
     * get the position of the cluster node based on what's inside
     *
     * @param {object} childNodesObj    | object with node objects, id as keys
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: "_getClusterPosition",
    value: function _getClusterPosition(childNodesObj) {
      var childKeys = keys$4(childNodesObj);

      var minX = childNodesObj[childKeys[0]].x;
      var maxX = childNodesObj[childKeys[0]].x;
      var minY = childNodesObj[childKeys[0]].y;
      var maxY = childNodesObj[childKeys[0]].y;
      var node;

      for (var i = 1; i < childKeys.length; i++) {
        node = childNodesObj[childKeys[i]];
        minX = node.x < minX ? node.x : minX;
        maxX = node.x > maxX ? node.x : maxX;
        minY = node.y < minY ? node.y : minY;
        maxY = node.y > maxY ? node.y : maxY;
      }

      return {
        x: 0.5 * (minX + maxX),
        y: 0.5 * (minY + maxY)
      };
    }
    /**
     * Open a cluster by calling this function.
     *
     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
     * @param {object} options
     * @param {boolean} refreshData | wrap up afterwards if not true
     */

  }, {
    key: "openCluster",
    value: function openCluster(clusterNodeId, options) {
      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (clusterNodeId === undefined) {
        throw new Error("No clusterNodeId supplied to openCluster.");
      }

      var clusterNode = this.body.nodes[clusterNodeId];

      if (clusterNode === undefined) {
        throw new Error("The clusterNodeId supplied to openCluster does not exist.");
      }

      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {
        throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
      } // Check if current cluster is clustered itself


      var stack = this.findNode(clusterNodeId);
      var parentIndex = indexOf(stack).call(stack, clusterNodeId) - 1;

      if (parentIndex >= 0) {
        // Current cluster is clustered; transfer contained nodes and edges to parent
        var parentClusterNodeId = stack[parentIndex];
        var parentClusterNode = this.body.nodes[parentClusterNodeId]; // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged

        parentClusterNode._openChildCluster(clusterNodeId); // All components of child cluster node have been transferred. It can die now.


        delete this.body.nodes[clusterNodeId];

        if (refreshData === true) {
          this.body.emitter.emit("_dataChanged");
        }

        return;
      } // main body


      var containedNodes = clusterNode.containedNodes;
      var containedEdges = clusterNode.containedEdges; // allow the user to position the nodes after release.

      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === "function") {
        var positions = {};
        var clusterPosition = {
          x: clusterNode.x,
          y: clusterNode.y
        };

        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            var containedNode = this.body.nodes[nodeId];
            positions[nodeId] = {
              x: containedNode.x,
              y: containedNode.y
            };
          }
        }

        var newPositions = options.releaseFunction(clusterPosition, positions);

        for (var _nodeId2 in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {
            var _containedNode = this.body.nodes[_nodeId2];

            if (newPositions[_nodeId2] !== undefined) {
              _containedNode.x = newPositions[_nodeId2].x === undefined ? clusterNode.x : newPositions[_nodeId2].x;
              _containedNode.y = newPositions[_nodeId2].y === undefined ? clusterNode.y : newPositions[_nodeId2].y;
            }
          }
        }
      } else {
        // copy the position from the cluster
        forEach$1(containedNodes, function (containedNode) {
          // inherit position
          if (containedNode.options.fixed.x === false) {
            containedNode.x = clusterNode.x;
          }

          if (containedNode.options.fixed.y === false) {
            containedNode.y = clusterNode.y;
          }
        });
      } // release nodes


      for (var _nodeId3 in containedNodes) {
        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {
          var _containedNode2 = this.body.nodes[_nodeId3]; // inherit speed

          _containedNode2.vx = clusterNode.vx;
          _containedNode2.vy = clusterNode.vy;

          _containedNode2.setOptions({
            physics: true
          });

          delete this.clusteredNodes[_nodeId3];
        }
      } // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.


      var edgesToBeDeleted = [];

      for (var i = 0; i < clusterNode.edges.length; i++) {
        edgesToBeDeleted.push(clusterNode.edges[i]);
      } // actually handling the deleting.


      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {
        var edge = edgesToBeDeleted[_i3];

        var otherNodeId = this._getConnectedId(edge, clusterNodeId);

        var otherNode = this.clusteredNodes[otherNodeId];

        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
          var transferId = edge.clusteringEdgeReplacingIds[j];
          var transferEdge = this.body.edges[transferId];
          if (transferEdge === undefined) continue; // if the other node is in another cluster, we transfer ownership of this edge to the other cluster

          if (otherNode !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[otherNode.clusterId];
            otherCluster.containedEdges[transferEdge.id] = transferEdge; // delete local reference

            delete containedEdges[transferEdge.id]; // get to and from

            var fromId = transferEdge.fromId;
            var toId = transferEdge.toId;

            if (transferEdge.toId == otherNodeId) {
              toId = otherNode.clusterId;
            } else {
              fromId = otherNode.clusterId;
            } // create new cluster edge from the otherCluster


            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {
              hidden: false,
              physics: true
            });
          } else {
            this._restoreEdge(transferEdge);
          }
        }

        edge.remove();
      } // handle the releasing of the edges


      for (var edgeId in containedEdges) {
        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {
          this._restoreEdge(containedEdges[edgeId]);
        }
      } // remove clusterNode


      delete this.body.nodes[clusterNodeId];

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Cluster.id} clusterId
     * @returns {Array.<Node.id>}
     */

  }, {
    key: "getNodesInCluster",
    value: function getNodesInCluster(clusterId) {
      var nodesArray = [];

      if (this.isCluster(clusterId) === true) {
        var containedNodes = this.body.nodes[clusterId].containedNodes;

        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            nodesArray.push(this.body.nodes[nodeId].id);
          }
        }
      }

      return nodesArray;
    }
    /**
     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
     *
     * If a node can't be found in the chain, return an empty array.
     *
     * @param {string|number} nodeId
     * @returns {Array}
     */

  }, {
    key: "findNode",
    value: function findNode(nodeId) {
      var stack = [];
      var max = 100;
      var counter = 0;
      var node;

      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
        node = this.body.nodes[nodeId];
        if (node === undefined) return [];
        stack.push(node.id);
        nodeId = this.clusteredNodes[nodeId].clusterId;
        counter++;
      }

      node = this.body.nodes[nodeId];
      if (node === undefined) return [];
      stack.push(node.id);

      reverse(stack).call(stack);

      return stack;
    }
    /**
     * Using a clustered nodeId, update with the new options
     *
     * @param {Node.id} clusteredNodeId
     * @param {object} newOptions
     */

  }, {
    key: "updateClusteredNode",
    value: function updateClusteredNode(clusteredNodeId, newOptions) {
      if (clusteredNodeId === undefined) {
        throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
      }

      if (newOptions === undefined) {
        throw new Error("No newOptions supplied to updateClusteredNode.");
      }

      if (this.body.nodes[clusteredNodeId] === undefined) {
        throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
      }

      this.body.nodes[clusteredNodeId].setOptions(newOptions);
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Using a base edgeId, update all related clustered edges with the new options
     *
     * @param {vis.Edge.id} startEdgeId
     * @param {object} newOptions
     */

  }, {
    key: "updateEdge",
    value: function updateEdge(startEdgeId, newOptions) {
      if (startEdgeId === undefined) {
        throw new Error("No startEdgeId supplied to updateEdge.");
      }

      if (newOptions === undefined) {
        throw new Error("No newOptions supplied to updateEdge.");
      }

      if (this.body.edges[startEdgeId] === undefined) {
        throw new Error("The startEdgeId supplied to updateEdge does not exist.");
      }

      var allEdgeIds = this.getClusteredEdges(startEdgeId);

      for (var i = 0; i < allEdgeIds.length; i++) {
        var edge = this.body.edges[allEdgeIds[i]];
        edge.setOptions(newOptions);
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
     *
     * @param {vis.Edge.id} edgeId
     * @returns {Array.<vis.Edge.id>}
     */

  }, {
    key: "getClusteredEdges",
    value: function getClusteredEdges(edgeId) {
      var stack = [];
      var max = 100;
      var counter = 0;

      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {
        stack.push(this.body.edges[edgeId].id);
        edgeId = this.body.edges[edgeId].edgeReplacedById;
        counter++;
      }

      reverse(stack).call(stack);

      return stack;
    }
    /**
     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {vis.Edge.id} baseEdgeId
     *
     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
     */

  }, {
    key: "getBaseEdge",
    value: function getBaseEdge(clusteredEdgeId) {
      // Just kludge this by returning the first base edge id found
      return this.getBaseEdges(clusteredEdgeId)[0];
    }
    /**
     * Get all regular edges for this clustered edge id.
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
     */

  }, {
    key: "getBaseEdges",
    value: function getBaseEdges(clusteredEdgeId) {
      var IdsToHandle = [clusteredEdgeId];
      var doneIds = [];
      var foundIds = [];
      var max = 100;
      var counter = 0;

      while (IdsToHandle.length > 0 && counter < max) {
        var nextId = IdsToHandle.pop();
        if (nextId === undefined) continue; // Paranoia here and onwards

        var nextEdge = this.body.edges[nextId];
        if (nextEdge === undefined) continue;
        counter++;
        var replacingIds = nextEdge.clusteringEdgeReplacingIds;

        if (replacingIds === undefined) {
          // nextId is a base id
          foundIds.push(nextId);
        } else {
          // Another cluster edge, unravel this one as well
          for (var i = 0; i < replacingIds.length; ++i) {
            var replacingId = replacingIds[i]; // Don't add if already handled
            // TODO: never triggers; find a test-case which does

            if (indexOf(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || indexOf(doneIds).call(doneIds, replacingIds) !== -1) {
              continue;
            }

            IdsToHandle.push(replacingId);
          }
        }

        doneIds.push(nextId);
      }

      return foundIds;
    }
    /**
     * Get the Id the node is connected to
     *
     * @param {vis.Edge} edge
     * @param {Node.id} nodeId
     * @returns {*}
     * @private
     */

  }, {
    key: "_getConnectedId",
    value: function _getConnectedId(edge, nodeId) {
      if (edge.toId != nodeId) {
        return edge.toId;
      } else if (edge.fromId != nodeId) {
        return edge.fromId;
      } else {
        return edge.fromId;
      }
    }
    /**
     * We determine how many connections denote an important hub.
     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_getHubSize",
    value: function _getHubSize() {
      var average = 0;
      var averageSquared = 0;
      var hubCounter = 0;
      var largestHub = 0;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];

        if (node.edges.length > largestHub) {
          largestHub = node.edges.length;
        }

        average += node.edges.length;
        averageSquared += Math.pow(node.edges.length, 2);
        hubCounter += 1;
      }

      average = average / hubCounter;
      averageSquared = averageSquared / hubCounter;
      var variance = averageSquared - Math.pow(average, 2);
      var standardDeviation = Math.sqrt(variance);
      var hubThreshold = Math.floor(average + 2 * standardDeviation); // always have at least one to cluster

      if (hubThreshold > largestHub) {
        hubThreshold = largestHub;
      }

      return hubThreshold;
    }
    /**
     * Create an edge for the cluster representation.
     *
     * @param {Node.id} fromId
     * @param {Node.id} toId
     * @param {vis.Edge} baseEdge
     * @param {object} clusterEdgeProperties
     * @param {object} extraOptions
     * @returns {Edge} newly created clustered edge
     * @private
     */

  }, {
    key: "_createClusteredEdge",
    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
      // copy the options of the edge we will replace
      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge"); // make sure the properties of clusterEdges are superimposed on it

      deepExtend(clonedOptions, clusterEdgeProperties); // set up the edge

      clonedOptions.from = fromId;
      clonedOptions.to = toId;
      clonedOptions.id = "clusterEdge:" + v4(); // apply the edge specific options to it if specified

      if (extraOptions !== undefined) {
        deepExtend(clonedOptions, extraOptions);
      }

      var newEdge = this.body.functions.createEdge(clonedOptions);
      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
      newEdge.connect(); // Register the new edge

      this.body.edges[newEdge.id] = newEdge;
      return newEdge;
    }
    /**
     * Add the passed child nodes and edges to the given cluster node.
     *
     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster
     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering
     * @param {Node} clusterNode  cluster node to add nodes and edges to
     * @param {object} [clusterEdgeProperties]
     * @private
     */

  }, {
    key: "_clusterEdges",
    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
      if (childEdges instanceof Edge) {
        var edge = childEdges;
        var obj = {};
        obj[edge.id] = edge;
        childEdges = obj;
      }

      if (childNodes instanceof Node) {
        var node = childNodes;
        var _obj = {};
        _obj[node.id] = node;
        childNodes = _obj;
      }

      if (clusterNode === undefined || clusterNode === null) {
        throw new Error("_clusterEdges: parameter clusterNode required");
      }

      if (clusterEdgeProperties === undefined) {
        // Take the required properties from the cluster node
        clusterEdgeProperties = clusterNode.clusterEdgeProperties;
      } // create the new edges that will connect to the cluster.
      // All self-referencing edges will be added to childEdges here.


      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties); // disable the childEdges


      for (var edgeId in childEdges) {
        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {
          if (this.body.edges[edgeId] !== undefined) {
            var _edge2 = this.body.edges[edgeId]; // cache the options before changing

            this._backupEdgeOptions(_edge2); // disable physics and hide the edge


            _edge2.setOptions({
              physics: false
            });
          }
        }
      } // disable the childNodes


      for (var nodeId in childNodes) {
        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {
          this.clusteredNodes[nodeId] = {
            clusterId: clusterNode.id,
            node: this.body.nodes[nodeId]
          };
          this.body.nodes[nodeId].setOptions({
            physics: false
          });
        }
      }
    }
    /**
     * Determine in which cluster given nodeId resides.
     *
     * If not in cluster, return undefined.
     *
     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
     *
     * @param {Node.id} nodeId
     * @returns {Node|undefined} Node instance for cluster, if present
     * @private
     */

  }, {
    key: "_getClusterNodeForNode",
    value: function _getClusterNodeForNode(nodeId) {
      if (nodeId === undefined) return undefined;
      var clusteredNode = this.clusteredNodes[nodeId]; // NOTE: If no cluster info found, it should actually be an error

      if (clusteredNode === undefined) return undefined;
      var clusterId = clusteredNode.clusterId;
      if (clusterId === undefined) return undefined;
      return this.body.nodes[clusterId];
    }
    /**
     * Internal helper function for conditionally removing items in array
     *
     * Done like this because Array.filter() is not fully supported by all IE's.
     *
     * @param {Array} arr
     * @param {Function} callback
     * @returns {Array}
     * @private
     */

  }, {
    key: "_filter",
    value: function _filter(arr, callback) {
      var ret = [];
      forEach$1(arr, function (item) {
        if (callback(item)) {
          ret.push(item);
        }
      });
      return ret;
    }
    /**
     * Scan all edges for changes in clustering and adjust this if necessary.
     *
     * Call this (internally) after there has been a change in node or edge data.
     *
     * Pre: States of this.body.nodes and this.body.edges consistent
     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
     *      of cluster nodes.
     */

  }, {
    key: "_updateState",
    value: function _updateState() {
      var _this4 = this;

      var nodeId;
      var deletedNodeIds = [];
      var deletedEdgeIds = {};
      /**
       * Utility function to iterate over clustering nodes only
       *
       * @param {Function} callback  function to call for each cluster node
       */

      var eachClusterNode = function eachClusterNode(callback) {
        forEach$1(_this4.body.nodes, function (node) {
          if (node.isCluster === true) {
            callback(node);
          }
        });
      }; //
      // Remove deleted regular nodes from clustering
      //
      // Determine the deleted nodes


      for (nodeId in this.clusteredNodes) {
        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;
        var node = this.body.nodes[nodeId];

        if (node === undefined) {
          deletedNodeIds.push(nodeId);
        }
      } // Remove nodes from cluster nodes


      eachClusterNode(function (clusterNode) {
        for (var n = 0; n < deletedNodeIds.length; n++) {
          delete clusterNode.containedNodes[deletedNodeIds[n]];
        }
      }); // Remove nodes from cluster list

      for (var n = 0; n < deletedNodeIds.length; n++) {
        delete this.clusteredNodes[deletedNodeIds[n]];
      } //
      // Remove deleted edges from clustering
      //
      // Add the deleted clustered edges to the list


      forEach$1(this.clusteredEdges, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        if (edge === undefined || !edge.endPointsValid()) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      }); // Cluster nodes can also contain edges which are not clustered,
      // i.e. nodes 1-2 within cluster with an edge in between.
      // So the cluster nodes also need to be scanned for invalid edges

      eachClusterNode(function (clusterNode) {
        forEach$1(clusterNode.containedEdges, function (edge, edgeId) {
          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
            deletedEdgeIds[edgeId] = edgeId;
          }
        });
      }); // Also scan for cluster edges which need to be removed in the active list.
      // Regular edges have been removed beforehand, so this only picks up the cluster edges.

      forEach$1(this.body.edges, function (edge, edgeId) {
        // Explicitly scan the contained edges for validity
        var isValid = true;
        var replacedIds = edge.clusteringEdgeReplacingIds;

        if (replacedIds !== undefined) {
          var numValid = 0;
          forEach$1(replacedIds, function (containedEdgeId) {
            var containedEdge = _this4.body.edges[containedEdgeId];

            if (containedEdge !== undefined && containedEdge.endPointsValid()) {
              numValid += 1;
            }
          });
          isValid = numValid > 0;
        }

        if (!edge.endPointsValid() || !isValid) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      }); // Remove edges from cluster nodes

      eachClusterNode(function (clusterNode) {
        forEach$1(deletedEdgeIds, function (deletedEdgeId) {
          delete clusterNode.containedEdges[deletedEdgeId];
          forEach$1(clusterNode.edges, function (edge, m) {
            if (edge.id === deletedEdgeId) {
              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop

              return;
            }

            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {
              return !deletedEdgeIds[id];
            });
          }); // Clean up the nulls

          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {
            return item !== null;
          });
        });
      }); // Remove from cluster list

      forEach$1(deletedEdgeIds, function (edgeId) {
        delete _this4.clusteredEdges[edgeId];
      }); // Remove cluster edges from active list (this.body.edges).
      // deletedEdgeIds still contains id of regular edges, but these should all
      // be gone when you reach here.

      forEach$1(deletedEdgeIds, function (edgeId) {
        delete _this4.body.edges[edgeId];
      }); //
      // Check changed cluster state of edges
      //
      // Iterating over keys here, because edges may be removed in the loop

      var ids = keys$4(this.body.edges);

      forEach$1(ids, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);

        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
          return; // all is well
        }

        if (shouldBeClustered) {
          // add edge to clustering
          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);

          if (clusterFrom !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
          }

          var clusterTo = _this4._getClusterNodeForNode(edge.toId);

          if (clusterTo !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
          } // TODO: check that it works for both edges clustered
          //       (This might be paranoia)

        } else {
          delete _this4._clusterEdges[edgeId];

          _this4._restoreEdge(edge); // This should not be happening, the state should
          // be properly updated at this point.
          //
          // If it *is* reached during normal operation, then we have to implement
          // undo clustering for this edge here.
          // throw new Error('remove edge from clustering not implemented!')

        }
      }); // Clusters may be nested to any level. Keep on opening until nothing to open

      var changed = false;
      var continueLoop = true;

      var _loop2 = function _loop2() {
        var clustersToOpen = []; // Determine the id's of clusters that need opening

        eachClusterNode(function (clusterNode) {
          var numNodes = keys$4(clusterNode.containedNodes).length;

          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;

          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
            clustersToOpen.push(clusterNode.id);
          }
        }); // Open them

        for (var _n = 0; _n < clustersToOpen.length; ++_n) {
          _this4.openCluster(clustersToOpen[_n], {}, false
          /* Don't refresh, we're in an refresh/update already */
          );
        }

        continueLoop = clustersToOpen.length > 0;
        changed = changed || continueLoop;
      };

      while (continueLoop) {
        _loop2();
      }

      if (changed) {
        this._updateState(); // Redo this method (recursion possible! should be safe)

      }
    }
    /**
     * Determine if node with given id is part of a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {boolean} true if part of a cluster.
     */

  }, {
    key: "_isClusteredNode",
    value: function _isClusteredNode(nodeId) {
      return this.clusteredNodes[nodeId] !== undefined;
    }
    /**
     * Determine if edge with given id is not visible due to clustering.
     *
     * An edge is considered clustered if:
     * - it is directly replaced by a clustering edge
     * - any of its connecting nodes is in a cluster
     *
     * @param {vis.Edge.id} edgeId
     * @returns {boolean} true if part of a cluster.
     */

  }, {
    key: "_isClusteredEdge",
    value: function _isClusteredEdge(edgeId) {
      return this.clusteredEdges[edgeId] !== undefined;
    }
  }]);

  return ClusterEngine;
}();

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$5(o, minLen) { var _context4; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = slice(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Initializes window.requestAnimationFrame() to a usable form.
 *
 * Specifically, set up this method for the case of running on node.js with jsdom enabled.
 *
 * NOTES:
 *
 * On node.js, when calling this directly outside of this class, `window` is not defined.
 *   This happens even if jsdom is used.
 * For node.js + jsdom, `window` is available at the moment the constructor is called.
 *   For this reason, the called is placed within the constructor.
 * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.
 * During unit testing, it happens that the window object is reset during execution, causing
 *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,
 *   see `_requestNextFrame()`.
 * Since this is a global object, it may affect other modules besides `Network`. With normal
 *   usage, this does not cause any problems. During unit testing, errors may occur. These have
 *   been compensated for, see comment block in _requestNextFrame().
 *
 * @private
 */

function _initRequestAnimationFrame() {
  var func;

  if (window !== undefined) {
    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  if (func === undefined) {
    // window or method not present, setting mock requestAnimationFrame
    window.requestAnimationFrame = function (callback) {
      //console.log("Called mock requestAnimationFrame");
      callback();
    };
  } else {
    window.requestAnimationFrame = func;
  }
}
/**
 * The canvas renderer
 */


var CanvasRenderer = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function CanvasRenderer(body, canvas) {
    _classCallCheck(this, CanvasRenderer);

    _initRequestAnimationFrame();

    this.body = body;
    this.canvas = canvas;
    this.redrawRequested = false;
    this.renderTimer = undefined;
    this.requiresTimeout = true;
    this.renderingActive = false;
    this.renderRequests = 0;
    this.allowRedraw = true;
    this.dragging = false;
    this.zooming = false;
    this.options = {};
    this.defaultOptions = {
      hideEdgesOnDrag: false,
      hideEdgesOnZoom: false,
      hideNodesOnDrag: false
    };

    assign$2(this.options, this.defaultOptions);

    this._determineBrowserMethod();

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(CanvasRenderer, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this,
          _context2;

      this.body.emitter.on("dragStart", function () {
        _this.dragging = true;
      });
      this.body.emitter.on("dragEnd", function () {
        _this.dragging = false;
      });
      this.body.emitter.on("zoom", function () {
        _this.zooming = true;
        window.clearTimeout(_this.zoomTimeoutId);
        _this.zoomTimeoutId = setTimeout$1(function () {
          var _context;

          _this.zooming = false;

          bind$6(_context = _this._requestRedraw).call(_context, _this)();
        }, 250);
      });
      this.body.emitter.on("_resizeNodes", function () {
        _this._resizeNodes();
      });
      this.body.emitter.on("_redraw", function () {
        if (_this.renderingActive === false) {
          _this._redraw();
        }
      });
      this.body.emitter.on("_blockRedraw", function () {
        _this.allowRedraw = false;
      });
      this.body.emitter.on("_allowRedraw", function () {
        _this.allowRedraw = true;
        _this.redrawRequested = false;
      });
      this.body.emitter.on("_requestRedraw", bind$6(_context2 = this._requestRedraw).call(_context2, this));
      this.body.emitter.on("_startRendering", function () {
        _this.renderRequests += 1;
        _this.renderingActive = true;

        _this._startRendering();
      });
      this.body.emitter.on("_stopRendering", function () {
        _this.renderRequests -= 1;
        _this.renderingActive = _this.renderRequests > 0;
        _this.renderTimer = undefined;
      });
      this.body.emitter.on("destroy", function () {
        _this.renderRequests = 0;
        _this.allowRedraw = false;
        _this.renderingActive = false;

        if (_this.requiresTimeout === true) {
          clearTimeout(_this.renderTimer);
        } else {
          window.cancelAnimationFrame(_this.renderTimer);
        }

        _this.body.emitter.off();
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * Prepare the drawing of the next frame.
     *
     * Calls the callback when the next frame can or will be drawn.
     *
     * @param {Function} callback
     * @param {number} delay - timeout case only, wait this number of milliseconds
     * @returns {Function | undefined}
     * @private
     */

  }, {
    key: "_requestNextFrame",
    value: function _requestNextFrame(callback, delay) {
      // During unit testing, it happens that the mock window object is reset while
      // the next frame is still pending. Then, either 'window' is not present, or
      // 'requestAnimationFrame()' is not present because it is not defined on the
      // mock window object.
      //
      // As a consequence, unrelated unit tests may appear to fail, even if the problem
      // described happens in the current unit test.
      //
      // This is not something that will happen in normal operation, but we still need
      // to take it into account.
      //
      if (typeof window === "undefined") return; // Doing `if (window === undefined)` does not work here!

      var timer;
      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset
      // while running this method.

      if (this.requiresTimeout === true) {
        // wait given number of milliseconds and perform the animation step function
        timer = setTimeout$1(callback, delay);
      } else {
        if (myWindow.requestAnimationFrame) {
          timer = myWindow.requestAnimationFrame(callback);
        }
      }

      return timer;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_startRendering",
    value: function _startRendering() {
      if (this.renderingActive === true) {
        if (this.renderTimer === undefined) {
          var _context3;

          this.renderTimer = this._requestNextFrame(bind$6(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);
        }
      }
    }
    /**
     *
     * @private
     */

  }, {
    key: "_renderStep",
    value: function _renderStep() {
      if (this.renderingActive === true) {
        // reset the renderTimer so a new scheduled animation step can be set
        this.renderTimer = undefined;

        if (this.requiresTimeout === true) {
          // this schedules a new simulation step
          this._startRendering();
        }

        this._redraw();

        if (this.requiresTimeout === false) {
          // this schedules a new simulation step
          this._startRendering();
        }
      }
    }
    /**
     * Redraw the network with the current data
     * chart will be resized too.
     */

  }, {
    key: "redraw",
    value: function redraw() {
      this.body.emitter.emit("setSize");

      this._redraw();
    }
    /**
     * Redraw the network with the current data
     *
     * @private
     */

  }, {
    key: "_requestRedraw",
    value: function _requestRedraw() {
      var _this2 = this;

      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
        this.redrawRequested = true;

        this._requestNextFrame(function () {
          _this2._redraw(false);
        }, 0);
      }
    }
    /**
     * Redraw the network with the current data
     *
     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
     *                                   Only the nodes are drawn after which they are quickly drawn over.
     * @private
     */

  }, {
    key: "_redraw",
    value: function _redraw() {
      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.allowRedraw === true) {
        this.body.emitter.emit("initRedraw");
        this.redrawRequested = false;
        var drawLater = {
          drawExternalLabels: null
        }; // when the container div was hidden, this fixes it back up!

        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
          this.canvas.setSize();
        }

        this.canvas.setTransform();
        var ctx = this.canvas.getContext(); // clear the canvas

        var w = this.canvas.frame.canvas.clientWidth;
        var h = this.canvas.frame.canvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // if the div is hidden, we stop the redraw here for performance.

        if (this.canvas.frame.clientWidth === 0) {
          return;
        } // set scaling and translation


        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);
        ctx.beginPath();
        this.body.emitter.emit("beforeDrawing", ctx);
        ctx.closePath();

        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawEdges(ctx);
          }
        }

        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
          var _this$_drawNodes = this._drawNodes(ctx, hidden),
              drawExternalLabels = _this$_drawNodes.drawExternalLabels;

          drawLater.drawExternalLabels = drawExternalLabels;
        } // draw the arrows last so they will be at the top


        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawArrows(ctx);
          }
        }

        if (drawLater.drawExternalLabels != null) {
          drawLater.drawExternalLabels();
        }

        if (hidden === false) {
          this._drawSelectionBox(ctx);
        }

        ctx.beginPath();
        this.body.emitter.emit("afterDrawing", ctx);
        ctx.closePath(); // restore original scaling and translation

        ctx.restore();

        if (hidden === true) {
          ctx.clearRect(0, 0, w, h);
        }
      }
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {boolean} [alwaysShow]
     * @private
     */

  }, {
    key: "_resizeNodes",
    value: function _resizeNodes() {
      this.canvas.setTransform();
      var ctx = this.canvas.getContext();
      ctx.save();
      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
      ctx.scale(this.body.view.scale, this.body.view.scale);
      var nodes = this.body.nodes;
      var node; // resize all nodes

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          node = nodes[nodeId];
          node.resize(ctx);
          node.updateBoundingBox(ctx, node.selected);
        }
      } // restore original scaling and translation


      ctx.restore();
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @param {boolean} [alwaysShow]
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "_drawNodes",
    value: function _drawNodes(ctx) {
      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var nodes = this.body.nodes;
      var nodeIndices = this.body.nodeIndices;
      var node;
      var selected = [];
      var hovered = [];
      var margin = 20;
      var topLeft = this.canvas.DOMtoCanvas({
        x: -margin,
        y: -margin
      });
      var bottomRight = this.canvas.DOMtoCanvas({
        x: this.canvas.frame.canvas.clientWidth + margin,
        y: this.canvas.frame.canvas.clientHeight + margin
      });
      var viewableArea = {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
      var _drawExternalLabels = []; // draw unselected nodes;

      for (var _i = 0; _i < nodeIndices.length; _i++) {
        node = nodes[nodeIndices[_i]]; // set selected and hovered nodes aside

        if (node.hover) {
          hovered.push(nodeIndices[_i]);
        } else if (node.isSelected()) {
          selected.push(nodeIndices[_i]);
        } else {
          if (alwaysShow === true) {
            var drawLater = node.draw(ctx);

            if (drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(drawLater.drawExternalLabel);
            }
          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
            var _drawLater = node.draw(ctx);

            if (_drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(_drawLater.drawExternalLabel);
            }
          } else {
            node.updateBoundingBox(ctx, node.selected);
          }
        }
      }

      var i;
      var selectedLength = selected.length;
      var hoveredLength = hovered.length; // draw the selected nodes on top

      for (i = 0; i < selectedLength; i++) {
        node = nodes[selected[i]];

        var _drawLater2 = node.draw(ctx);

        if (_drawLater2.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater2.drawExternalLabel);
        }
      } // draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226


      for (i = 0; i < hoveredLength; i++) {
        node = nodes[hovered[i]];

        var _drawLater3 = node.draw(ctx);

        if (_drawLater3.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater3.drawExternalLabel);
        }
      }

      return {
        drawExternalLabels: function drawExternalLabels() {
          var _iterator = _createForOfIteratorHelper$5(_drawExternalLabels),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var draw = _step.value;
              draw();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      };
    }
    /**
     * Redraw all edges
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawEdges",
    value: function _drawEdges(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;

      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];

        if (edge.connected === true) {
          edge.draw(ctx);
        }
      }
    }
    /**
     * Redraw all arrows
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawArrows",
    value: function _drawArrows(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;

      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];

        if (edge.connected === true) {
          edge.drawArrows(ctx);
        }
      }
    }
    /**
     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
     * some implementations (safari and IE9) did not support requestAnimationFrame
     *
     * @private
     */

  }, {
    key: "_determineBrowserMethod",
    value: function _determineBrowserMethod() {
      if (typeof window !== "undefined") {
        var browserType = navigator.userAgent.toLowerCase();
        this.requiresTimeout = false;

        if (indexOf(browserType).call(browserType, "msie 9.0") != -1) {
          // IE 9
          this.requiresTimeout = true;
        } else if (indexOf(browserType).call(browserType, "safari") != -1) {
          // safari
          if (indexOf(browserType).call(browserType, "chrome") <= -1) {
            this.requiresTimeout = true;
          }
        }
      } else {
        this.requiresTimeout = true;
      }
    }
    /**
     * Redraw selection box
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawSelectionBox",
    value: function _drawSelectionBox(ctx) {
      if (this.body.selectionBox.show) {
        ctx.beginPath();
        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;
        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;
        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.fillStyle = "rgba(151, 194, 252, 0.2)";
        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.strokeStyle = "rgba(151, 194, 252, 1)";
        ctx.stroke();
      } else {
        ctx.closePath();
      }
    }
  }]);

  return CanvasRenderer;
}();

var path$1 = path$y;
var setInterval$1 = path$1.setInterval;

var setInterval = setInterval$1;

/**
 * Register a touch event, taking place before a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 */
function onTouch(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst) {
      callback(event);
    }
  };

  hammer.on("hammer.input", callback.inputHandler);
}
/**
 * Register a release event, taking place after a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 * @returns {*}
 */

function onRelease(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal) {
      callback(event);
    }
  };

  return hammer.on("hammer.input", callback.inputHandler);
}

/**
 * Create the main frame for the Network.
 * This function is executed once when a Network object is created. The frame
 * contains a canvas, and this canvas contains all objects like the axis and
 * nodes.
 */

var Canvas = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function Canvas(body) {
    _classCallCheck(this, Canvas);

    this.body = body;
    this.pixelRatio = 1;
    this.cameraState = {};
    this.initialized = false;
    this.canvasViewCenter = {};
    this._cleanupCallbacks = [];
    this.options = {};
    this.defaultOptions = {
      autoResize: true,
      height: "100%",
      width: "100%"
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(Canvas, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this,
          _context;

      // bind the events
      this.body.emitter.once("resize", function (obj) {
        if (obj.width !== 0) {
          _this.body.view.translation.x = obj.width * 0.5;
        }

        if (obj.height !== 0) {
          _this.body.view.translation.y = obj.height * 0.5;
        }
      });
      this.body.emitter.on("setSize", bind$6(_context = this.setSize).call(_context, this));
      this.body.emitter.on("destroy", function () {
        _this.hammerFrame.destroy();

        _this.hammer.destroy();

        _this._cleanUp();
      });
    }
    /**
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this2 = this;

      if (options !== undefined) {
        var fields = ["width", "height", "autoResize"];
        selectiveDeepExtend(fields, this.options, options);
      } // Automatically adapt to changing size of the container element.


      this._cleanUp();

      if (this.options.autoResize === true) {
        var _context2;

        if (window.ResizeObserver) {
          // decent browsers, immediate reactions
          var observer = new ResizeObserver(function () {
            var changed = _this2.setSize();

            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          });
          var frame = this.frame;
          observer.observe(frame);

          this._cleanupCallbacks.push(function () {
            observer.unobserve(frame);
          });
        } else {
          // IE11, continous polling
          var resizeTimer = setInterval(function () {
            var changed = _this2.setSize();

            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1000);

          this._cleanupCallbacks.push(function () {
            clearInterval(resizeTimer);
          });
        } // Automatically adapt to changing size of the browser.


        var resizeFunction = bind$6(_context2 = this._onResize).call(_context2, this);

        addEventListener(window, "resize", resizeFunction);

        this._cleanupCallbacks.push(function () {
          removeEventListener(window, "resize", resizeFunction);
        });
      }
    }
    /**
     * @private
     */

  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      var _context3, _context4, _context5;

      forEach$2(_context3 = reverse(_context4 = splice$1(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function (callback) {
        try {
          callback();
        } catch (error) {
          console.error(error);
        }
      });
    }
    /**
     * @private
     */

  }, {
    key: "_onResize",
    value: function _onResize() {
      this.setSize();
      this.body.emitter.emit("_redraw");
    }
    /**
     * Get and store the cameraState
     *
     * @param {number} [pixelRatio=this.pixelRatio]
     * @private
     */

  }, {
    key: "_getCameraState",
    value: function _getCameraState() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;

      if (this.initialized === true) {
        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
        this.cameraState.scale = this.body.view.scale;
        this.cameraState.position = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.width / pixelRatio,
          y: 0.5 * this.frame.canvas.height / pixelRatio
        });
      }
    }
    /**
     * Set the cameraState
     *
     * @private
     */

  }, {
    key: "_setCameraState",
    value: function _setCameraState() {
      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {
        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
        var newScale = this.cameraState.scale;

        if (widthRatio != 1 && heightRatio != 1) {
          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
        } else if (widthRatio != 1) {
          newScale = this.cameraState.scale * widthRatio;
        } else if (heightRatio != 1) {
          newScale = this.cameraState.scale * heightRatio;
        }

        this.body.view.scale = newScale; // this comes from the view module.

        var currentViewCenter = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.clientWidth,
          y: 0.5 * this.frame.canvas.clientHeight
        });
        var distanceFromCenter = {
          // offset from view, distance view has to change by these x and y to center the node
          x: currentViewCenter.x - this.cameraState.position.x,
          y: currentViewCenter.y - this.cameraState.position.y
        };
        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
      }
    }
    /**
     *
     * @param {number|string} value
     * @returns {string}
     * @private
     */

  }, {
    key: "_prepareValue",
    value: function _prepareValue(value) {
      if (typeof value === "number") {
        return value + "px";
      } else if (typeof value === "string") {
        if (indexOf(value).call(value, "%") !== -1 || indexOf(value).call(value, "px") !== -1) {
          return value;
        } else if (indexOf(value).call(value, "%") === -1) {
          return value + "px";
        }
      }

      throw new Error("Could not use the value supplied for width or height:" + value);
    }
    /**
     * Create the HTML
     */

  }, {
    key: "_create",
    value: function _create() {
      // remove all elements from the container element.
      while (this.body.container.hasChildNodes()) {
        this.body.container.removeChild(this.body.container.firstChild);
      }

      this.frame = document.createElement("div");
      this.frame.className = "vis-network";
      this.frame.style.position = "relative";
      this.frame.style.overflow = "hidden";
      this.frame.tabIndex = 0; // tab index is required for keycharm to bind keystrokes to the div instead of the window
      //////////////////////////////////////////////////////////////////

      this.frame.canvas = document.createElement("canvas");
      this.frame.canvas.style.position = "relative";
      this.frame.appendChild(this.frame.canvas);

      if (!this.frame.canvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.frame.canvas.appendChild(noCanvas);
      } else {
        this._setPixelRatio();

        this.setTransform();
      } // add the frame to the container element


      this.body.container.appendChild(this.frame);
      this.body.view.scale = 1;
      this.body.view.translation = {
        x: 0.5 * this.frame.canvas.clientWidth,
        y: 0.5 * this.frame.canvas.clientHeight
      };

      this._bindHammer();
    }
    /**
     * This function binds hammer, it can be repeated over and over due to the uniqueness check.
     *
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;

      if (this.hammer !== undefined) {
        this.hammer.destroy();
      }

      this.drag = {};
      this.pinch = {}; // init hammer

      this.hammer = new Hammer(this.frame.canvas);
      this.hammer.get("pinch").set({
        enable: true
      }); // enable to get better response, todo: test on mobile.

      this.hammer.get("pan").set({
        threshold: 5,
        direction: Hammer.DIRECTION_ALL
      });
      onTouch(this.hammer, function (event) {
        _this3.body.eventListeners.onTouch(event);
      });
      this.hammer.on("tap", function (event) {
        _this3.body.eventListeners.onTap(event);
      });
      this.hammer.on("doubletap", function (event) {
        _this3.body.eventListeners.onDoubleTap(event);
      });
      this.hammer.on("press", function (event) {
        _this3.body.eventListeners.onHold(event);
      });
      this.hammer.on("panstart", function (event) {
        _this3.body.eventListeners.onDragStart(event);
      });
      this.hammer.on("panmove", function (event) {
        _this3.body.eventListeners.onDrag(event);
      });
      this.hammer.on("panend", function (event) {
        _this3.body.eventListeners.onDragEnd(event);
      });
      this.hammer.on("pinch", function (event) {
        _this3.body.eventListeners.onPinch(event);
      }); // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?

      this.frame.canvas.addEventListener("wheel", function (event) {
        _this3.body.eventListeners.onMouseWheel(event);
      });
      this.frame.canvas.addEventListener("mousemove", function (event) {
        _this3.body.eventListeners.onMouseMove(event);
      });
      this.frame.canvas.addEventListener("contextmenu", function (event) {
        _this3.body.eventListeners.onContext(event);
      });
      this.hammerFrame = new Hammer(this.frame);
      onRelease(this.hammerFrame, function (event) {
        _this3.body.eventListeners.onRelease(event);
      });
    }
    /**
     * Set a new size for the network
     *
     * @param {string} width   Width in pixels or percentage (for example '800px'
     *                         or '50%')
     * @param {string} height  Height in pixels or percentage  (for example '400px'
     *                         or '30%')
     * @returns {boolean}
     */

  }, {
    key: "setSize",
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;
      width = this._prepareValue(width);
      height = this._prepareValue(height);
      var emitEvent = false;
      var oldWidth = this.frame.canvas.width;
      var oldHeight = this.frame.canvas.height; // update the pixel ratio
      //
      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code
      //       where it is assumed that the pixel ratio could change at runtime.
      //       The only way I can think of this happening is a rotating screen or tablet; but then
      //       there should be a mechanism for reloading the data (TODO: check if this is present).
      //
      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage
      //       of pixel ratio must be overhauled for this.
      //
      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is
      //       constant.

      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value

      this._setPixelRatio();

      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
        this._getCameraState(previousRatio);

        this.frame.style.width = width;
        this.frame.style.height = height;
        this.frame.canvas.style.width = "100%";
        this.frame.canvas.style.height = "100%";
        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
        this.options.width = width;
        this.options.height = height;
        this.canvasViewCenter = {
          x: 0.5 * this.frame.clientWidth,
          y: 0.5 * this.frame.clientHeight
        };
        emitEvent = true;
      } else {
        // this would adapt the width of the canvas to the width from 100% if and only if
        // there is a change.
        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio); // store the camera if there is a change in size.

        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
          this._getCameraState(previousRatio);
        }

        if (this.frame.canvas.width !== newWidth) {
          this.frame.canvas.width = newWidth;
          emitEvent = true;
        }

        if (this.frame.canvas.height !== newHeight) {
          this.frame.canvas.height = newHeight;
          emitEvent = true;
        }
      }

      if (emitEvent === true) {
        this.body.emitter.emit("resize", {
          width: Math.round(this.frame.canvas.width / this.pixelRatio),
          height: Math.round(this.frame.canvas.height / this.pixelRatio),
          oldWidth: Math.round(oldWidth / this.pixelRatio),
          oldHeight: Math.round(oldHeight / this.pixelRatio)
        }); // restore the camera on change.

        this._setCameraState();
      } // set initialized so the get and set camera will work from now on.


      this.initialized = true;
      return emitEvent;
    }
    /**
     *
     * @returns {CanvasRenderingContext2D}
     */

  }, {
    key: "getContext",
    value: function getContext() {
      return this.frame.canvas.getContext("2d");
    }
    /**
     * Determine the pixel ratio for various browsers.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_determinePixelRatio",
    value: function _determinePixelRatio() {
      var ctx = this.getContext();

      if (ctx === undefined) {
        throw new Error("Could not get canvax context");
      }

      var numerator = 1;

      if (typeof window !== "undefined") {
        // (window !== undefined) doesn't work here!
        // Protection during unit tests, where 'window' can be missing
        numerator = window.devicePixelRatio || 1;
      }

      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
      return numerator / denominator;
    }
    /**
     * Lazy determination of pixel ratio.
     *
     * @private
     */

  }, {
    key: "_setPixelRatio",
    value: function _setPixelRatio() {
      this.pixelRatio = this._determinePixelRatio();
    }
    /**
     * Set the transform in the contained context, based on its pixelRatio
     */

  }, {
    key: "setTransform",
    value: function setTransform() {
      var ctx = this.getContext();

      if (ctx === undefined) {
        throw new Error("Could not get canvax context");
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
    /**
     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: "_XconvertDOMtoCanvas",
    value: function _XconvertDOMtoCanvas(x) {
      return (x - this.body.view.translation.x) / this.body.view.scale;
    }
    /**
     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: "_XconvertCanvasToDOM",
    value: function _XconvertCanvasToDOM(x) {
      return x * this.body.view.scale + this.body.view.translation.x;
    }
    /**
     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: "_YconvertDOMtoCanvas",
    value: function _YconvertDOMtoCanvas(y) {
      return (y - this.body.view.translation.y) / this.body.view.scale;
    }
    /**
     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: "_YconvertCanvasToDOM",
    value: function _YconvertCanvasToDOM(y) {
      return y * this.body.view.scale + this.body.view.translation.y;
    }
    /**
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: "canvasToDOM",
    value: function canvasToDOM(pos) {
      return {
        x: this._XconvertCanvasToDOM(pos.x),
        y: this._YconvertCanvasToDOM(pos.y)
      };
    }
    /**
     *
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: "DOMtoCanvas",
    value: function DOMtoCanvas(pos) {
      return {
        x: this._XconvertDOMtoCanvas(pos.x),
        y: this._YconvertDOMtoCanvas(pos.y)
      };
    }
  }]);

  return Canvas;
}();

/**
 * Validate the fit options, replace missing optional values by defaults etc.
 *
 * @param rawOptions - The raw options.
 * @param allNodeIds - All node ids that will be used if nodes are omitted in
 * the raw options.
 * @returns Options with everything filled in and validated.
 */
function normalizeFitOptions(rawOptions, allNodeIds) {
  var options = assign$2({
    nodes: allNodeIds,
    minZoomLevel: Number.MIN_VALUE,
    maxZoomLevel: 1
  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});

  if (!isArray$2(options.nodes)) {
    throw new TypeError("Nodes has to be an array of ids.");
  }

  if (options.nodes.length === 0) {
    options.nodes = allNodeIds;
  }

  if (!(typeof options.minZoomLevel === "number" && options.minZoomLevel > 0)) {
    throw new TypeError("Min zoom level has to be a number higher than zero.");
  }

  if (!(typeof options.maxZoomLevel === "number" && options.minZoomLevel <= options.maxZoomLevel)) {
    throw new TypeError("Max zoom level has to be a number higher than min zoom level.");
  }

  return options;
}

/**
 * The view
 */

var View = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function View(body, canvas) {
    var _context,
        _this = this,
        _context2;

    _classCallCheck(this, View);

    this.body = body;
    this.canvas = canvas;
    this.animationSpeed = 1 / this.renderRefreshRate;
    this.animationEasingFunction = "easeInOutQuint";
    this.easingTime = 0;
    this.sourceScale = 0;
    this.targetScale = 0;
    this.sourceTranslation = 0;
    this.targetTranslation = 0;
    this.lockedOnNodeId = undefined;
    this.lockedOnNodeOffset = undefined;
    this.touchTime = 0;
    this.viewFunction = undefined;
    this.body.emitter.on("fit", bind$6(_context = this.fit).call(_context, this));
    this.body.emitter.on("animationFinished", function () {
      _this.body.emitter.emit("_stopRendering");
    });
    this.body.emitter.on("unlockNode", bind$6(_context2 = this.releaseNode).call(_context2, this));
  }
  /**
   *
   * @param {object} [options={}]
   */


  _createClass(View, [{
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = options;
    }
    /**
     * This function zooms out to fit all data on screen based on amount of nodes
     *
     * @param {object} [options={{nodes=Array}}]
     * @param options
     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
     */

  }, {
    key: "fit",
    value: function fit(options) {
      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      options = normalizeFitOptions(options, this.body.nodeIndices);
      var canvasWidth = this.canvas.frame.canvas.clientWidth;
      var canvasHeight = this.canvas.frame.canvas.clientHeight;
      var range;
      var zoomLevel;

      if (canvasWidth === 0 || canvasHeight === 0) {
        // There's no point in trying to fit into zero sized canvas. This could
        // potentially even result in invalid values being computed. For example
        // for network without nodes and zero sized canvas the zoom level would
        // end up being computed as 0/0 which results in NaN. In any other case
        // this would be 0/something which is again pointless to compute.
        zoomLevel = 1;
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
      } else if (initialZoom === true) {
        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
        var positionDefined = 0;

        for (var nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            var node = this.body.nodes[nodeId];

            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }
        }

        if (positionDefined > 0.5 * this.body.nodeIndices.length) {
          this.fit(options, false);
          return;
        }

        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var numberOfNodes = this.body.nodeIndices.length;
        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.
        // correct for larger canvasses.

        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);
        zoomLevel *= factor;
      } else {
        this.body.emitter.emit("_resizeNodes");
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
        var xZoomLevel = canvasWidth / xDistance;
        var yZoomLevel = canvasHeight / yDistance;
        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
      }

      if (zoomLevel > options.maxZoomLevel) {
        zoomLevel = options.maxZoomLevel;
      } else if (zoomLevel < options.minZoomLevel) {
        zoomLevel = options.minZoomLevel;
      }

      var center = NetworkUtil.findCenter(range);
      var animationOptions = {
        position: center,
        scale: zoomLevel,
        animation: options.animation
      };
      this.moveTo(animationOptions);
    } // animation

    /**
     * Center a node in view.
     *
     * @param {number} nodeId
     * @param {number} [options]
     */

  }, {
    key: "focus",
    value: function focus(nodeId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.body.nodes[nodeId] !== undefined) {
        var nodePosition = {
          x: this.body.nodes[nodeId].x,
          y: this.body.nodes[nodeId].y
        };
        options.position = nodePosition;
        options.lockedOnNode = nodeId;
        this.moveTo(options);
      } else {
        console.error("Node: " + nodeId + " cannot be found.");
      }
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.scale    = number                 // scale to move to
     *                          |  options.position = {x:number, y:number}   // position to move to
     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
     */

  }, {
    key: "moveTo",
    value: function moveTo(options) {
      if (options === undefined) {
        options = {};
        return;
      }

      if (options.offset != null) {
        if (options.offset.x != null) {
          // Coerce and verify that x is valid.
          options.offset.x = +options.offset.x;

          if (!_isFinite(options.offset.x)) {
            throw new TypeError('The option "offset.x" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }

        if (options.offset.y != null) {
          // Coerce and verify that y is valid.
          options.offset.y = +options.offset.y;

          if (!_isFinite(options.offset.y)) {
            throw new TypeError('The option "offset.y" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }
      } else {
        options.offset = {
          x: 0,
          y: 0
        };
      }

      if (options.position != null) {
        if (options.position.x != null) {
          // Coerce and verify that x is valid.
          options.position.x = +options.position.x;

          if (!_isFinite(options.position.x)) {
            throw new TypeError('The option "position.x" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }

        if (options.position.y != null) {
          // Coerce and verify that y is valid.
          options.position.y = +options.position.y;

          if (!_isFinite(options.position.y)) {
            throw new TypeError('The option "position.y" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }
      } else {
        options.position = this.getViewPosition();
      }

      if (options.scale != null) {
        // Coerce and verify that the scale is valid.
        options.scale = +options.scale;

        if (!(options.scale > 0)) {
          throw new TypeError('The option "scale" has to be a number greater than zero.');
        }
      } else {
        options.scale = this.body.view.scale;
      }

      if (options.animation === undefined) {
        options.animation = {
          duration: 0
        };
      }

      if (options.animation === false) {
        options.animation = {
          duration: 0
        };
      }

      if (options.animation === true) {
        options.animation = {};
      }

      if (options.animation.duration === undefined) {
        options.animation.duration = 1000;
      } // default duration


      if (options.animation.easingFunction === undefined) {
        options.animation.easingFunction = "easeInOutQuad";
      } // default easing function


      this.animateView(options);
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.time     = number                 // animation time in milliseconds
     *                          |  options.scale    = number                 // scale to animate to
     *                          |  options.position = {x:number, y:number}   // position to animate to
     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
     */

  }, {
    key: "animateView",
    value: function animateView(options) {
      if (options === undefined) {
        return;
      }

      this.animationEasingFunction = options.animation.easingFunction; // release if something focussed on the node

      this.releaseNode();

      if (options.locked === true) {
        this.lockedOnNodeId = options.lockedOnNode;
        this.lockedOnNodeOffset = options.offset;
      } // forcefully complete the old animation if it was still running


      if (this.easingTime != 0) {
        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.

      }

      this.sourceScale = this.body.view.scale;
      this.sourceTranslation = this.body.view.translation;
      this.targetScale = options.scale; // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
      // but at least then we'll have the target transition

      this.body.view.scale = this.targetScale;
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - options.position.x,
        y: viewCenter.y - options.position.y
      };
      this.targetTranslation = {
        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
      }; // if the time is set to 0, don't do an animation

      if (options.animation.duration === 0) {
        if (this.lockedOnNodeId != undefined) {
          var _context3;

          this.viewFunction = bind$6(_context3 = this._lockedRedraw).call(_context3, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        } else {
          this.body.view.scale = this.targetScale;
          this.body.view.translation = this.targetTranslation;
          this.body.emitter.emit("_requestRedraw");
        }
      } else {
        var _context4;

        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's

        this.animationEasingFunction = options.animation.easingFunction;
        this.viewFunction = bind$6(_context4 = this._transitionRedraw).call(_context4, this);
        this.body.emitter.on("initRedraw", this.viewFunction);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     * used to animate smoothly by hijacking the redraw function.
     *
     * @private
     */

  }, {
    key: "_lockedRedraw",
    value: function _lockedRedraw() {
      var nodePosition = {
        x: this.body.nodes[this.lockedOnNodeId].x,
        y: this.body.nodes[this.lockedOnNodeId].y
      };
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - nodePosition.x,
        y: viewCenter.y - nodePosition.y
      };
      var sourceTranslation = this.body.view.translation;
      var targetTranslation = {
        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
      };
      this.body.view.translation = targetTranslation;
    }
    /**
     * Resets state of a locked on Node
     */

  }, {
    key: "releaseNode",
    value: function releaseNode() {
      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.lockedOnNodeId = undefined;
        this.lockedOnNodeOffset = undefined;
      }
    }
    /**
     * @param {boolean} [finished=false]
     * @private
     */

  }, {
    key: "_transitionRedraw",
    value: function _transitionRedraw() {
      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.easingTime += this.animationSpeed;
      this.easingTime = finished === true ? 1.0 : this.easingTime;
      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);
      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
      this.body.view.translation = {
        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
      }; // cleanup

      if (this.easingTime >= 1.0) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.easingTime = 0;

        if (this.lockedOnNodeId != undefined) {
          var _context5;

          this.viewFunction = bind$6(_context5 = this._lockedRedraw).call(_context5, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        }

        this.body.emitter.emit("animationFinished");
      }
    }
    /**
     *
     * @returns {number}
     */

  }, {
    key: "getScale",
    value: function getScale() {
      return this.body.view.scale;
    }
    /**
     *
     * @returns {{x: number, y: number}}
     */

  }, {
    key: "getViewPosition",
    value: function getViewPosition() {
      return this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
    }
  }]);

  return View;
}();

var css_248z$1 = "div.vis-network div.vis-navigation div.vis-button {\n  width: 34px;\n  height: 34px;\n  -moz-border-radius: 17px;\n  border-radius: 17px;\n  position: absolute;\n  display: inline-block;\n  background-position: 2px 2px;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:hover {\n  box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.3);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:active {\n  box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button.vis-up {\n  background-image: url('data:image/png;base64,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');\n  bottom: 50px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-down {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-left {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-right {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 95px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomIn {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  right: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomOut {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  right: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {\n  background-image: url('data:image/png;base64,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');\n  bottom: 50px;\n  right: 15px;\n}\n";
styleInject(css_248z$1);

/**
 * Created by Alex on 11/6/2014.
 */
function keycharm(options) {
  var preventDefault = options && options.preventDefault || false;
  var container = options && options.container || window;
  var _exportFunctions = {};
  var _bound = {
    keydown: {},
    keyup: {}
  };
  var _keys = {};
  var i; // a - z

  for (i = 97; i <= 122; i++) {
    _keys[String.fromCharCode(i)] = {
      code: 65 + (i - 97),
      shift: false
    };
  } // A - Z


  for (i = 65; i <= 90; i++) {
    _keys[String.fromCharCode(i)] = {
      code: i,
      shift: true
    };
  } // 0 - 9


  for (i = 0; i <= 9; i++) {
    _keys['' + i] = {
      code: 48 + i,
      shift: false
    };
  } // F1 - F12


  for (i = 1; i <= 12; i++) {
    _keys['F' + i] = {
      code: 111 + i,
      shift: false
    };
  } // num0 - num9


  for (i = 0; i <= 9; i++) {
    _keys['num' + i] = {
      code: 96 + i,
      shift: false
    };
  } // numpad misc


  _keys['num*'] = {
    code: 106,
    shift: false
  };
  _keys['num+'] = {
    code: 107,
    shift: false
  };
  _keys['num-'] = {
    code: 109,
    shift: false
  };
  _keys['num/'] = {
    code: 111,
    shift: false
  };
  _keys['num.'] = {
    code: 110,
    shift: false
  }; // arrows

  _keys['left'] = {
    code: 37,
    shift: false
  };
  _keys['up'] = {
    code: 38,
    shift: false
  };
  _keys['right'] = {
    code: 39,
    shift: false
  };
  _keys['down'] = {
    code: 40,
    shift: false
  }; // extra keys

  _keys['space'] = {
    code: 32,
    shift: false
  };
  _keys['enter'] = {
    code: 13,
    shift: false
  };
  _keys['shift'] = {
    code: 16,
    shift: undefined
  };
  _keys['esc'] = {
    code: 27,
    shift: false
  };
  _keys['backspace'] = {
    code: 8,
    shift: false
  };
  _keys['tab'] = {
    code: 9,
    shift: false
  };
  _keys['ctrl'] = {
    code: 17,
    shift: false
  };
  _keys['alt'] = {
    code: 18,
    shift: false
  };
  _keys['delete'] = {
    code: 46,
    shift: false
  };
  _keys['pageup'] = {
    code: 33,
    shift: false
  };
  _keys['pagedown'] = {
    code: 34,
    shift: false
  }; // symbols

  _keys['='] = {
    code: 187,
    shift: false
  };
  _keys['-'] = {
    code: 189,
    shift: false
  };
  _keys[']'] = {
    code: 221,
    shift: false
  };
  _keys['['] = {
    code: 219,
    shift: false
  };

  var down = function (event) {
    handleEvent(event, 'keydown');
  };

  var up = function (event) {
    handleEvent(event, 'keyup');
  }; // handle the actualy bound key with the event


  var handleEvent = function (event, type) {
    if (_bound[type][event.keyCode] !== undefined) {
      var bound = _bound[type][event.keyCode];

      for (var i = 0; i < bound.length; i++) {
        if (bound[i].shift === undefined) {
          bound[i].fn(event);
        } else if (bound[i].shift == true && event.shiftKey == true) {
          bound[i].fn(event);
        } else if (bound[i].shift == false && event.shiftKey == false) {
          bound[i].fn(event);
        }
      }

      if (preventDefault == true) {
        event.preventDefault();
      }
    }
  }; // bind a key to a callback


  _exportFunctions.bind = function (key, callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    if (_keys[key] === undefined) {
      throw new Error("unsupported key: " + key);
    }

    if (_bound[type][_keys[key].code] === undefined) {
      _bound[type][_keys[key].code] = [];
    }

    _bound[type][_keys[key].code].push({
      fn: callback,
      shift: _keys[key].shift
    });
  }; // bind all keys to a call back (demo purposes)


  _exportFunctions.bindAll = function (callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        _exportFunctions.bind(key, callback, type);
      }
    }
  }; // get the key label from an event


  _exportFunctions.getKey = function (event) {
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.keyCode == _keys[key].code && key == 'shift') {
          return key;
        }
      }
    }

    return "unknown key, currently not supported";
  }; // unbind either a specific callback from a key or all of them (by leaving callback undefined)


  _exportFunctions.unbind = function (key, callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    if (_keys[key] === undefined) {
      throw new Error("unsupported key: " + key);
    }

    if (callback !== undefined) {
      var newBindings = [];
      var bound = _bound[type][_keys[key].code];

      if (bound !== undefined) {
        for (var i = 0; i < bound.length; i++) {
          if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
            newBindings.push(_bound[type][_keys[key].code][i]);
          }
        }
      }

      _bound[type][_keys[key].code] = newBindings;
    } else {
      _bound[type][_keys[key].code] = [];
    }
  }; // reset all bound variables.


  _exportFunctions.reset = function () {
    _bound = {
      keydown: {},
      keyup: {}
    };
  }; // unbind all listeners and reset all variables.


  _exportFunctions.destroy = function () {
    _bound = {
      keydown: {},
      keyup: {}
    };
    container.removeEventListener('keydown', down, true);
    container.removeEventListener('keyup', up, true);
  }; // create listeners.


  container.addEventListener('keydown', down, true);
  container.addEventListener('keyup', up, true); // return the public functions.

  return _exportFunctions;
}

/**
 * Navigation Handler
 */

var NavigationHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function NavigationHandler(body, canvas) {
    var _this = this;

    _classCallCheck(this, NavigationHandler);

    this.body = body;
    this.canvas = canvas;
    this.iconsCreated = false;
    this.navigationHammers = [];
    this.boundFunctions = {};
    this.touchTime = 0;
    this.activated = false;
    this.body.emitter.on("activate", function () {
      _this.activated = true;

      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("deactivate", function () {
      _this.activated = false;

      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("destroy", function () {
      if (_this.keycharm !== undefined) {
        _this.keycharm.destroy();
      }
    });
    this.options = {};
  }
  /**
   *
   * @param {object} options
   */


  _createClass(NavigationHandler, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        this.options = options;
        this.create();
      }
    }
    /**
     * Creates or refreshes navigation and sets key bindings
     */

  }, {
    key: "create",
    value: function create() {
      if (this.options.navigationButtons === true) {
        if (this.iconsCreated === false) {
          this.loadNavigationElements();
        }
      } else if (this.iconsCreated === true) {
        this.cleanNavigation();
      }

      this.configureKeyboardBindings();
    }
    /**
     * Cleans up previous navigation items
     */

  }, {
    key: "cleanNavigation",
    value: function cleanNavigation() {
      // clean hammer bindings
      if (this.navigationHammers.length != 0) {
        for (var i = 0; i < this.navigationHammers.length; i++) {
          this.navigationHammers[i].destroy();
        }

        this.navigationHammers = [];
      } // clean up previous navigation items


      if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
        this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
      }

      this.iconsCreated = false;
    }
    /**
     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
     *
     * @private
     */

  }, {
    key: "loadNavigationElements",
    value: function loadNavigationElements() {
      var _this2 = this;

      this.cleanNavigation();
      this.navigationDOM = {};
      var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
      var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
      this.navigationDOM["wrapper"] = document.createElement("div");
      this.navigationDOM["wrapper"].className = "vis-navigation";
      this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);

      for (var i = 0; i < navigationDivs.length; i++) {
        this.navigationDOM[navigationDivs[i]] = document.createElement("div");
        this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
        this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);

        if (navigationDivActions[i] === "_fit") {
          var _context;

          onTouch(hammer, bind$6(_context = this._fit).call(_context, this));
        } else {
          var _context2;

          onTouch(hammer, bind$6(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));
        }

        this.navigationHammers.push(hammer);
      } // use a hammer for the release so we do not require the one used in the rest of the network
      // the one the rest uses can be overloaded by the manipulation system.


      var hammerFrame = new Hammer(this.canvas.frame);
      onRelease(hammerFrame, function () {
        _this2._stopMovement();
      });
      this.navigationHammers.push(hammerFrame);
      this.iconsCreated = true;
    }
    /**
     *
     * @param {string} action
     */

  }, {
    key: "bindToRedraw",
    value: function bindToRedraw(action) {
      if (this.boundFunctions[action] === undefined) {
        var _context3;

        this.boundFunctions[action] = bind$6(_context3 = this[action]).call(_context3, this);
        this.body.emitter.on("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     *
     * @param {string} action
     */

  }, {
    key: "unbindFromRedraw",
    value: function unbindFromRedraw(action) {
      if (this.boundFunctions[action] !== undefined) {
        this.body.emitter.off("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_stopRendering");
        delete this.boundFunctions[action];
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: "_fit",
    value: function _fit() {
      if (new Date().valueOf() - this.touchTime > 700) {
        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
        this.body.emitter.emit("fit", {
          duration: 700
        });
        this.touchTime = new Date().valueOf();
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: "_stopMovement",
    value: function _stopMovement() {
      for (var boundAction in this.boundFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {
          this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
          this.body.emitter.emit("_stopRendering");
        }
      }

      this.boundFunctions = {};
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveUp",
    value: function _moveUp() {
      this.body.view.translation.y += this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveDown",
    value: function _moveDown() {
      this.body.view.translation.y -= this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveLeft",
    value: function _moveLeft() {
      this.body.view.translation.x += this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveRight",
    value: function _moveRight() {
      this.body.view.translation.x -= this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_zoomIn",
    value: function _zoomIn() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "+",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     *
     * @private
     */

  }, {
    key: "_zoomOut",
    value: function _zoomOut() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "-",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     * bind all keys using keycharm.
     */

  }, {
    key: "configureKeyboardBindings",
    value: function configureKeyboardBindings() {
      var _this3 = this;

      if (this.keycharm !== undefined) {
        this.keycharm.destroy();
      }

      if (this.options.keyboard.enabled === true) {
        if (this.options.keyboard.bindToWindow === true) {
          this.keycharm = keycharm({
            container: window,
            preventDefault: true
          });
        } else {
          this.keycharm = keycharm({
            container: this.canvas.frame,
            preventDefault: true
          });
        }

        this.keycharm.reset();

        if (this.activated === true) {
          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;

          bind$6(_context4 = this.keycharm).call(_context4, "up", function () {
            _this3.bindToRedraw("_moveUp");
          }, "keydown");

          bind$6(_context5 = this.keycharm).call(_context5, "down", function () {
            _this3.bindToRedraw("_moveDown");
          }, "keydown");

          bind$6(_context6 = this.keycharm).call(_context6, "left", function () {
            _this3.bindToRedraw("_moveLeft");
          }, "keydown");

          bind$6(_context7 = this.keycharm).call(_context7, "right", function () {
            _this3.bindToRedraw("_moveRight");
          }, "keydown");

          bind$6(_context8 = this.keycharm).call(_context8, "=", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context9 = this.keycharm).call(_context9, "num+", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context10 = this.keycharm).call(_context10, "num-", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context11 = this.keycharm).call(_context11, "-", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context12 = this.keycharm).call(_context12, "[", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context13 = this.keycharm).call(_context13, "]", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context14 = this.keycharm).call(_context14, "pageup", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context15 = this.keycharm).call(_context15, "pagedown", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context16 = this.keycharm).call(_context16, "up", function () {
            _this3.unbindFromRedraw("_moveUp");
          }, "keyup");

          bind$6(_context17 = this.keycharm).call(_context17, "down", function () {
            _this3.unbindFromRedraw("_moveDown");
          }, "keyup");

          bind$6(_context18 = this.keycharm).call(_context18, "left", function () {
            _this3.unbindFromRedraw("_moveLeft");
          }, "keyup");

          bind$6(_context19 = this.keycharm).call(_context19, "right", function () {
            _this3.unbindFromRedraw("_moveRight");
          }, "keyup");

          bind$6(_context20 = this.keycharm).call(_context20, "=", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context21 = this.keycharm).call(_context21, "num+", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context22 = this.keycharm).call(_context22, "num-", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context23 = this.keycharm).call(_context23, "-", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context24 = this.keycharm).call(_context24, "[", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context25 = this.keycharm).call(_context25, "]", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context26 = this.keycharm).call(_context26, "pageup", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context27 = this.keycharm).call(_context27, "pagedown", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
        }
      }
    }
  }]);

  return NavigationHandler;
}();

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$4(o, minLen) { var _context15; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = slice(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Handler for interactions
 */

var InteractionHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   */
  function InteractionHandler(body, canvas, selectionHandler) {
    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;

    _classCallCheck(this, InteractionHandler);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.navigationHandler = new NavigationHandler(body, canvas); // bind the events from hammer to functions in this object

    this.body.eventListeners.onTap = bind$6(_context = this.onTap).call(_context, this);
    this.body.eventListeners.onTouch = bind$6(_context2 = this.onTouch).call(_context2, this);
    this.body.eventListeners.onDoubleTap = bind$6(_context3 = this.onDoubleTap).call(_context3, this);
    this.body.eventListeners.onHold = bind$6(_context4 = this.onHold).call(_context4, this);
    this.body.eventListeners.onDragStart = bind$6(_context5 = this.onDragStart).call(_context5, this);
    this.body.eventListeners.onDrag = bind$6(_context6 = this.onDrag).call(_context6, this);
    this.body.eventListeners.onDragEnd = bind$6(_context7 = this.onDragEnd).call(_context7, this);
    this.body.eventListeners.onMouseWheel = bind$6(_context8 = this.onMouseWheel).call(_context8, this);
    this.body.eventListeners.onPinch = bind$6(_context9 = this.onPinch).call(_context9, this);
    this.body.eventListeners.onMouseMove = bind$6(_context10 = this.onMouseMove).call(_context10, this);
    this.body.eventListeners.onRelease = bind$6(_context11 = this.onRelease).call(_context11, this);
    this.body.eventListeners.onContext = bind$6(_context12 = this.onContext).call(_context12, this);
    this.touchTime = 0;
    this.drag = {};
    this.pinch = {};
    this.popup = undefined;
    this.popupObj = undefined;
    this.popupTimer = undefined;
    this.body.functions.getPointer = bind$6(_context13 = this.getPointer).call(_context13, this);
    this.options = {};
    this.defaultOptions = {
      dragNodes: true,
      dragView: true,
      hover: false,
      keyboard: {
        enabled: false,
        speed: {
          x: 10,
          y: 10,
          zoom: 0.02
        },
        bindToWindow: true,
        autoFocus: true
      },
      navigationButtons: false,
      tooltipDelay: 300,
      zoomView: true,
      zoomSpeed: 1
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(InteractionHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on("destroy", function () {
        clearTimeout(_this.popupTimer);
        delete _this.body.functions.getPointer;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // extend all but the values in fields
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
        selectiveNotDeepExtend(fields, this.options, options); // merge the keyboard options in.

        mergeOptions(this.options, options, "keyboard");

        if (options.tooltip) {
          assign$2(this.options.tooltip, options.tooltip);

          if (options.tooltip.color) {
            this.options.tooltip.color = parseColor(options.tooltip.color);
          }
        }
      }

      this.navigationHandler.setOptions(this.options);
    }
    /**
     * Get the pointer location from a touch location
     *
     * @param {{x: number, y: number}} touch
     * @returns {{x: number, y: number}} pointer
     * @private
     */

  }, {
    key: "getPointer",
    value: function getPointer(touch) {
      return {
        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),
        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)
      };
    }
    /**
     * On start of a touch gesture, store the pointer
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "onTouch",
    value: function onTouch(event) {
      if (new Date().valueOf() - this.touchTime > 50) {
        this.drag.pointer = this.getPointer(event.center);
        this.drag.pinched = false;
        this.pinch.scale = this.body.view.scale; // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     * handle tap/click event: select/unselect a node
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onTap",
    value: function onTap(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
      this.checkSelectionChanges(pointer, multiselect);
      this.selectionHandler.commitAndEmit(pointer, event);
      this.selectionHandler.generateClickEvent("click", event, pointer);
    }
    /**
     * handle doubletap event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDoubleTap",
    value: function onDoubleTap(event) {
      var pointer = this.getPointer(event.center);
      this.selectionHandler.generateClickEvent("doubleClick", event, pointer);
    }
    /**
     * handle long tap event: multi select nodes
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onHold",
    value: function onHold(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect;
      this.checkSelectionChanges(pointer, multiselect);
      this.selectionHandler.commitAndEmit(pointer, event);
      this.selectionHandler.generateClickEvent("click", event, pointer);
      this.selectionHandler.generateClickEvent("hold", event, pointer);
    }
    /**
     * handle the release of the screen
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onRelease",
    value: function onRelease(event) {
      if (new Date().valueOf() - this.touchTime > 10) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler.generateClickEvent("release", event, pointer); // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     */

  }, {
    key: "onContext",
    value: function onContext(event) {
      var pointer = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      this.selectionHandler.generateClickEvent("oncontext", event, pointer);
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [add=false]
     */

  }, {
    key: "checkSelectionChanges",
    value: function checkSelectionChanges(pointer) {
      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (add === true) {
        this.selectionHandler.selectAdditionalOnPoint(pointer);
      } else {
        this.selectionHandler.selectOnPoint(pointer);
      }
    }
    /**
     * Remove all node and edge id's from the first set that are present in the second one.
     *
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
     * @private
     */

  }, {
    key: "_determineDifference",
    value: function _determineDifference(firstSet, secondSet) {
      var arrayDiff = function arrayDiff(firstArr, secondArr) {
        var result = [];

        for (var i = 0; i < firstArr.length; i++) {
          var value = firstArr[i];

          if (indexOf(secondArr).call(secondArr, value) === -1) {
            result.push(value);
          }
        }

        return result;
      };

      return {
        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
        edges: arrayDiff(firstSet.edges, secondSet.edges)
      };
    }
    /**
     * This function is called by onDragStart.
     * It is separated out because we can then overload it for the datamanipulation system.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      // if already dragging, do not start
      // this can happen on touch screens with multiple fingers
      if (this.drag.dragging) {
        return;
      } //in case the touch event was triggered on an external div, do the initial touch now.


      if (this.drag.pointer === undefined) {
        this.onTouch(event);
      } // note: drag.pointer is set in onTouch to get the initial touch location


      var node = this.selectionHandler.getNodeAt(this.drag.pointer);
      this.drag.dragging = true;
      this.drag.selection = [];
      this.drag.translation = assign$2({}, this.body.view.translation); // copy the object

      this.drag.nodeId = undefined;

      if (event.srcEvent.shiftKey) {
        this.body.selectionBox.show = true;
        var pointer = this.getPointer(event.center);
        this.body.selectionBox.position.start = {
          x: this.canvas._XconvertDOMtoCanvas(pointer.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer.y)
        };
        this.body.selectionBox.position.end = {
          x: this.canvas._XconvertDOMtoCanvas(pointer.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer.y)
        };
      }

      if (node !== undefined && this.options.dragNodes === true) {
        this.drag.nodeId = node.id; // select the clicked node if not yet selected

        if (node.isSelected() === false) {
          this.selectionHandler.setSelection({
            nodes: [node.id]
          });
        } // after select to contain the node


        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer); // create an array with the selected nodes and their original location and status

        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _node = _step.value;
            var s = {
              id: _node.id,
              node: _node,
              // store original x, y, xFixed and yFixed, make the node temporarily Fixed
              x: _node.x,
              y: _node.y,
              xFixed: _node.options.fixed.x,
              yFixed: _node.options.fixed.y
            };
            _node.options.fixed.x = true;
            _node.options.fixed.y = true;
            this.drag.selection.push(s);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        // fallback if no node is selected and thus the view is dragged.
        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer, undefined, true);
      }
    }
    /**
     * handle drag event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDrag",
    value: function onDrag(event) {
      var _this2 = this;

      if (this.drag.pinched === true) {
        return;
      } // remove the focus on node if it is focussed on by the focusOnNode


      this.body.emitter.emit("unlockNode");
      var pointer = this.getPointer(event.center);
      var selection = this.drag.selection;

      if (selection && selection.length && this.options.dragNodes === true) {
        this.selectionHandler.generateClickEvent("dragging", event, pointer); // calculate delta's and new location

        var deltaX = pointer.x - this.drag.pointer.x;
        var deltaY = pointer.y - this.drag.pointer.y; // update position of all selected nodes

        forEach$2(selection).call(selection, function (selection) {
          var node = selection.node; // only move the node if it was not fixed initially

          if (selection.xFixed === false) {
            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
          } // only move the node if it was not fixed initially


          if (selection.yFixed === false) {
            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
          }
        }); // start the simulation of the physics


        this.body.emitter.emit("startSimulation");
      } else {
        // create selection box
        if (event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.

          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }

          this.body.selectionBox.position.end = {
            x: this.canvas._XconvertDOMtoCanvas(pointer.x),
            y: this.canvas._YconvertDOMtoCanvas(pointer.y)
          };
          this.body.emitter.emit("_requestRedraw");
        } // move the network


        if (this.options.dragView === true && !event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.

          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }

          var diffX = pointer.x - this.drag.pointer.x;
          var diffY = pointer.y - this.drag.pointer.y;
          this.body.view.translation = {
            x: this.drag.translation.x + diffX,
            y: this.drag.translation.y + diffY
          };
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * handle drag start event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      var _this3 = this;

      this.drag.dragging = false;

      if (this.body.selectionBox.show) {
        var _context14;

        this.body.selectionBox.show = false;
        var selectionBoxPosition = this.body.selectionBox.position;
        var selectionBoxPositionMinMax = {
          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),
          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)
        };

        var toBeSelectedNodes = filter(_context14 = this.body.nodeIndices).call(_context14, function (nodeId) {
          var node = _this3.body.nodes[nodeId];
          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;
        });

        forEach$2(toBeSelectedNodes).call(toBeSelectedNodes, function (nodeId) {
          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);
        });

        var pointer = this.getPointer(event.center);
        this.selectionHandler.commitAndEmit(pointer, event);
        this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), undefined, true);
        this.body.emitter.emit("_requestRedraw");
      } else {
        var selection = this.drag.selection;

        if (selection && selection.length) {
          forEach$2(selection).call(selection, function (s) {
            // restore original xFixed and yFixed
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });

          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center));
          this.body.emitter.emit("startSimulation");
        } else {
          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), undefined, true);
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * Handle pinch event
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "onPinch",
    value: function onPinch(event) {
      var pointer = this.getPointer(event.center);
      this.drag.pinched = true;

      if (this.pinch["scale"] === undefined) {
        this.pinch.scale = 1;
      } // TODO: enabled moving while pinching?


      var scale = this.pinch.scale * event.scale;
      this.zoom(scale, pointer);
    }
    /**
     * Zoom the network in or out
     *
     * @param {number} scale a number around 1, and between 0.01 and 10
     * @param {{x: number, y: number}} pointer    Position on screen
     * @private
     */

  }, {
    key: "zoom",
    value: function zoom(scale, pointer) {
      if (this.options.zoomView === true) {
        var scaleOld = this.body.view.scale;

        if (scale < 0.00001) {
          scale = 0.00001;
        }

        if (scale > 10) {
          scale = 10;
        }

        var preScaleDragPointer = undefined;

        if (this.drag !== undefined) {
          if (this.drag.dragging === true) {
            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
          }
        } // + this.canvas.frame.canvas.clientHeight / 2


        var translation = this.body.view.translation;
        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;
        this.body.view.scale = scale;
        this.body.view.translation = {
          x: tx,
          y: ty
        };

        if (preScaleDragPointer != undefined) {
          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
          this.drag.pointer.x = postScaleDragPointer.x;
          this.drag.pointer.y = postScaleDragPointer.y;
        }

        this.body.emitter.emit("_requestRedraw");

        if (scaleOld < scale) {
          this.body.emitter.emit("zoom", {
            direction: "+",
            scale: this.body.view.scale,
            pointer: pointer
          });
        } else {
          this.body.emitter.emit("zoom", {
            direction: "-",
            scale: this.body.view.scale,
            pointer: pointer
          });
        }
      }
    }
    /**
     * Event handler for mouse wheel event, used to zoom the timeline
     * See http://adomas.org/javascript-mouse-wheel/
     *     https://github.com/EightMedia/hammer.js/issues/256
     *
     * @param {MouseEvent}  event
     * @private
     */

  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(event) {
      if (this.options.zoomView === true) {
        // If delta is nonzero, handle it.
        // Basically, delta is now positive if wheel was scrolled up,
        // and negative, if wheel was scrolled down.
        if (event.deltaY !== 0) {
          // calculate the new scale
          var scale = this.body.view.scale;
          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1); // calculate the pointer location

          var pointer = this.getPointer({
            x: event.clientX,
            y: event.clientY
          }); // apply the new scale

          this.zoom(scale, pointer);
        } // Prevent default actions caused by mouse wheel.


        event.preventDefault();
      }
    }
    /**
     * Mouse move handler for checking whether the title moves over a node with a title.
     *
     * @param  {Event} event
     * @private
     */

  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _this4 = this;

      var pointer = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      var popupVisible = false; // check if the previously selected node is still selected

      if (this.popup !== undefined) {
        if (this.popup.hidden === false) {
          this._checkHidePopup(pointer);
        } // if the popup was not hidden above


        if (this.popup.hidden === false) {
          popupVisible = true;
          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.show();
        }
      } // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.


      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
        this.canvas.frame.focus();
      } // start a timeout that will check if the mouse is positioned above an element


      if (popupVisible === false) {
        if (this.popupTimer !== undefined) {
          clearInterval(this.popupTimer); // stop any running calculationTimer

          this.popupTimer = undefined;
        }

        if (!this.drag.dragging) {
          this.popupTimer = setTimeout$1(function () {
            return _this4._checkShowPopup(pointer);
          }, this.options.tooltipDelay);
        }
      } // adding hover highlights


      if (this.options.hover === true) {
        this.selectionHandler.hoverObject(event, pointer);
      }
    }
    /**
     * Check if there is an element on the given position in the network
     * (a node or edge). If so, and if this element has a title,
     * show a popup window with its title.
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: "_checkShowPopup",
    value: function _checkShowPopup(pointer) {
      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);

      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);

      var pointerObj = {
        left: x,
        top: y,
        right: x,
        bottom: y
      };
      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
      var nodeUnderCursor = false;
      var popupType = "node"; // check if a node is under the cursor.

      if (this.popupObj === undefined) {
        // search the nodes for overlap, select the top one in case of multiple nodes
        var nodeIndices = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var node;
        var overlappingNodes = [];

        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];

          if (node.isOverlappingWith(pointerObj) === true) {
            nodeUnderCursor = true;

            if (node.getTitle() !== undefined) {
              overlappingNodes.push(nodeIndices[i]);
            }
          }
        }

        if (overlappingNodes.length > 0) {
          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]]; // if you hover over a node, the title of the edge is not supposed to be shown.

          nodeUnderCursor = true;
        }
      }

      if (this.popupObj === undefined && nodeUnderCursor === false) {
        // search the edges for overlap
        var edgeIndices = this.body.edgeIndices;
        var edges = this.body.edges;
        var edge;
        var overlappingEdges = [];

        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];

          if (edge.isOverlappingWith(pointerObj) === true) {
            if (edge.connected === true && edge.getTitle() !== undefined) {
              overlappingEdges.push(edgeIndices[_i]);
            }
          }
        }

        if (overlappingEdges.length > 0) {
          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
          popupType = "edge";
        }
      }

      if (this.popupObj !== undefined) {
        // show popup message window
        if (this.popupObj.id !== previousPopupObjId) {
          if (this.popup === undefined) {
            this.popup = new Popup(this.canvas.frame);
          }

          this.popup.popupTargetType = popupType;
          this.popup.popupTargetId = this.popupObj.id; // adjust a small offset such that the mouse cursor is located in the
          // bottom left location of the popup, and you can easily move over the
          // popup area

          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.setText(this.popupObj.getTitle());
          this.popup.show();
          this.body.emitter.emit("showPopup", this.popupObj.id);
        }
      } else {
        if (this.popup !== undefined) {
          this.popup.hide();
          this.body.emitter.emit("hidePopup");
        }
      }
    }
    /**
     * Check if the popup must be hidden, which is the case when the mouse is no
     * longer hovering on the object
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: "_checkHidePopup",
    value: function _checkHidePopup(pointer) {
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var stillOnObj = false;

      if (this.popup.popupTargetType === "node") {
        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj); // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
          // we initially only check stillOnObj because this is much faster.

          if (stillOnObj === true) {
            var overNode = this.selectionHandler.getNodeAt(pointer);
            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;
          }
        }
      } else {
        if (this.selectionHandler.getNodeAt(pointer) === undefined) {
          if (this.body.edges[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
          }
        }
      }

      if (stillOnObj === false) {
        this.popupObj = undefined;
        this.popup.hide();
        this.body.emitter.emit("hidePopup");
      }
    }
  }]);

  return InteractionHandler;
}();

var uncurryThis$1 = functionUncurryThis;
var redefineAll$1 = redefineAll$3;
var getWeakData = internalMetadata.exports.getWeakData;
var anObject = anObject$d;
var isObject$1 = isObject$j;
var anInstance = anInstance$3;
var iterate = iterate$3;
var ArrayIterationModule = arrayIteration;
var hasOwn = hasOwnProperty_1;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis$1([].splice);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$1 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
      return that;
    };

    redefineAll$1(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject$1(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject$1(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });
    redefineAll$1(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);

        if (isObject$1(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return Constructor;
  }
};

var global$1 = global$P;
var uncurryThis = functionUncurryThis;
var redefineAll = redefineAll$3;
var InternalMetadataModule = internalMetadata.exports;
var collection = collection$3;
var collectionWeak = collectionWeak$1;
var isObject = isObject$j;
var isExtensible = objectIsExtensible;
var enforceInternalState = internalState.enforce;
var NATIVE_WEAK_MAP = nativeWeakMap;
var IS_IE11 = !global$1.ActiveXObject && 'ActiveXObject' in global$1;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}; // `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor


var $WeakMap = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485

if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  var nativeSet = uncurryThis(WeakMapPrototype.set);
  redefineAll(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      }

      return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      }

      return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      }

      return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);

      return this;
    }
  });
}

var path = path$y;
var weakMap$2 = path.WeakMap;

var parent$1 = weakMap$2;
var weakMap$1 = parent$1;

var weakMap = weakMap$1;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { var _context2; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = slice(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _SingleTypeSelectionAccumulator_previousSelection, _SingleTypeSelectionAccumulator_selection, _SelectionAccumulator_nodes, _SelectionAccumulator_edges, _SelectionAccumulator_commitHandler;
/**
 * @param prev
 * @param next
 */

function diffSets(prev, next) {
  var diff = new set();

  var _iterator = _createForOfIteratorHelper$3(next),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      if (!prev.has(item)) {
        diff.add(item);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return diff;
}

var SingleTypeSelectionAccumulator = /*#__PURE__*/function () {
  function SingleTypeSelectionAccumulator() {
    _classCallCheck(this, SingleTypeSelectionAccumulator);

    _SingleTypeSelectionAccumulator_previousSelection.set(this, new set());

    _SingleTypeSelectionAccumulator_selection.set(this, new set());
  }

  _createClass(SingleTypeSelectionAccumulator, [{
    key: "size",
    get: function get() {
      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").size;
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      for (var _i = 0, _items = items; _i < _items.length; _i++) {
        var item = _items[_i];

        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").add(item);
      }
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {
        var item = _items2[_i2];

        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").delete(item);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").clear();
    }
  }, {
    key: "getSelection",
    value: function getSelection() {
      return _toConsumableArray(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"));
    }
  }, {
    key: "getChanges",
    value: function getChanges() {
      return {
        added: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"))),
        deleted: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        previous: _toConsumableArray(new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        current: _toConsumableArray(new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f")))
      };
    }
  }, {
    key: "commit",
    value: function commit() {
      var changes = this.getChanges();

      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), "f");

      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f")), "f");

      var _iterator2 = _createForOfIteratorHelper$3(changes.added),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;
          item.select();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper$3(changes.deleted),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _item = _step3.value;

          _item.unselect();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return changes;
    }
  }]);

  return SingleTypeSelectionAccumulator;
}();

_SingleTypeSelectionAccumulator_previousSelection = new weakMap(), _SingleTypeSelectionAccumulator_selection = new weakMap();
var SelectionAccumulator = /*#__PURE__*/function () {
  function SelectionAccumulator() {
    var commitHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

    _classCallCheck(this, SelectionAccumulator);

    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());

    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());

    _SelectionAccumulator_commitHandler.set(this, void 0);

    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, "f");
  }

  _createClass(SelectionAccumulator, [{
    key: "sizeNodes",
    get: function get() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").size;
    }
  }, {
    key: "sizeEdges",
    get: function get() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").size;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").getSelection();
    }
  }, {
    key: "getEdges",
    value: function getEdges() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").getSelection();
    }
  }, {
    key: "addNodes",
    value: function addNodes() {
      var _classPrivateFieldGe;

      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f")).add.apply(_classPrivateFieldGe, arguments);
    }
  }, {
    key: "addEdges",
    value: function addEdges() {
      var _classPrivateFieldGe2;

      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f")).add.apply(_classPrivateFieldGe2, arguments);
    }
  }, {
    key: "deleteNodes",
    value: function deleteNodes(node) {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").delete(node);
    }
  }, {
    key: "deleteEdges",
    value: function deleteEdges(edge) {
      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").delete(edge);
    }
  }, {
    key: "clear",
    value: function clear() {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").clear();

      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").clear();
    }
  }, {
    key: "commit",
    value: function commit() {
      var _classPrivateFieldGe3, _context;

      var summary = {
        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").commit(),
        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").commit()
      };

      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        rest[_key3] = arguments[_key3];
      }

      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, "f")).call.apply(_classPrivateFieldGe3, concat(_context = [this, summary]).call(_context, rest));

      return summary;
    }
  }]);

  return SelectionAccumulator;
}();
_SelectionAccumulator_nodes = new weakMap(), _SelectionAccumulator_edges = new weakMap(), _SelectionAccumulator_commitHandler = new weakMap();

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { var _context3; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = slice(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * The handler for selections
 */

var SelectionHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function SelectionHandler(body, canvas) {
    var _this = this;

    _classCallCheck(this, SelectionHandler);

    this.body = body;
    this.canvas = canvas; // TODO: Consider firing an event on any change to the selection, not
    // only those caused by clicks and taps. It would be easy to implement
    // now and (at least to me) it seems like something that could be
    // quite useful.

    this._selectionAccumulator = new SelectionAccumulator();
    this.hoverObj = {
      nodes: {},
      edges: {}
    };
    this.options = {};
    this.defaultOptions = {
      multiselect: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true
    };

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("_dataChanged", function () {
      _this.updateSelection();
    });
  }
  /**
   *
   * @param {object} [options]
   */


  _createClass(SelectionHandler, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * handles the selection part of the tap;
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: "selectOnPoint",
    value: function selectOnPoint(pointer) {
      var selected = false;

      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer); // unselect after getting the objects in order to restore width and height.

        this.unselectAll();

        if (obj !== undefined) {
          selected = this.selectObject(obj);
        }

        this.body.emitter.emit("_requestRedraw");
      }

      return selected;
    }
    /**
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: "selectAdditionalOnPoint",
    value: function selectAdditionalOnPoint(pointer) {
      var selectionChanged = false;

      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

        if (obj !== undefined) {
          selectionChanged = true;

          if (obj.isSelected() === true) {
            this.deselectObject(obj);
          } else {
            this.selectObject(obj);
          }

          this.body.emitter.emit("_requestRedraw");
        }
      }

      return selectionChanged;
    }
    /**
     * Create an object containing the standard fields for an event.
     *
     * @param {Event} event
     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
     * @returns {{}}
     * @private
     */

  }, {
    key: "_initBaseEvent",
    value: function _initBaseEvent(event, pointer) {
      var properties = {};
      properties["pointer"] = {
        DOM: {
          x: pointer.x,
          y: pointer.y
        },
        canvas: this.canvas.DOMtoCanvas(pointer)
      };
      properties["event"] = event;
      return properties;
    }
    /**
     * Generate an event which the user can catch.
     *
     * This adds some extra data to the event with respect to cursor position and
     * selected nodes and edges.
     *
     * @param {string} eventType                          Name of event to send
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
     * @param {object | undefined} oldSelection             If present, selection state before event occured
     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
     */

  }, {
    key: "generateClickEvent",
    value: function generateClickEvent(eventType, event, pointer, oldSelection) {
      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      var properties = this._initBaseEvent(event, pointer);

      if (emptySelection === true) {
        properties.nodes = [];
        properties.edges = [];
      } else {
        var tmp = this.getSelection();
        properties.nodes = tmp.nodes;
        properties.edges = tmp.edges;
      }

      if (oldSelection !== undefined) {
        properties["previousSelection"] = oldSelection;
      }

      if (eventType == "click") {
        // For the time being, restrict this functionality to
        // just the click event.
        properties.items = this.getClickedItems(pointer);
      }

      if (event.controlEdge !== undefined) {
        properties.controlEdge = event.controlEdge;
      }

      this.body.emitter.emit(eventType, properties);
    }
    /**
     *
     * @param {object} obj
     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
     * @returns {boolean}
     */

  }, {
    key: "selectObject",
    value: function selectObject(obj) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;

      if (obj !== undefined) {
        if (obj instanceof Node) {
          if (highlightEdges === true) {
            var _this$_selectionAccum;

            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray(obj.edges));
          }

          this._selectionAccumulator.addNodes(obj);
        } else {
          this._selectionAccumulator.addEdges(obj);
        }

        return true;
      }

      return false;
    }
    /**
     *
     * @param {object} obj
     */

  }, {
    key: "deselectObject",
    value: function deselectObject(obj) {
      if (obj.isSelected() === true) {
        obj.selected = false;

        this._removeFromSelection(obj);
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getAllNodesOverlappingWith",
    value: function _getAllNodesOverlappingWith(object) {
      var overlappingNodes = [];
      var nodes = this.body.nodes;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var nodeId = this.body.nodeIndices[i];

        if (nodes[nodeId].isOverlappingWith(object)) {
          overlappingNodes.push(nodeId);
        }
      }

      return overlappingNodes;
    }
    /**
     * Return a position object in canvasspace from a single point in screenspace
     *
     * @param {{x: number, y: number}} pointer
     * @returns {{left: number, top: number, right: number, bottom: number}}
     * @private
     */

  }, {
    key: "_pointerToPositionObject",
    value: function _pointerToPositionObject(pointer) {
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      return {
        left: canvasPos.x - 1,
        top: canvasPos.y + 1,
        right: canvasPos.x + 1,
        bottom: canvasPos.y - 1
      };
    }
    /**
     * Get the top node at the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnNode=true]
     * @returns {Node | undefined} node
     */

  }, {
    key: "getNodeAt",
    value: function getNodeAt(pointer) {
      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // we first check if this is an navigation controls element
      var positionObject = this._pointerToPositionObject(pointer);

      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject); // if there are overlapping nodes, select the last one, this is the
      // one which is drawn on top of the others


      if (overlappingNodes.length > 0) {
        if (returnNode === true) {
          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
        } else {
          return overlappingNodes[overlappingNodes.length - 1];
        }
      } else {
        return undefined;
      }
    }
    /**
     * retrieve all edges overlapping with given object, selector is around center
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getEdgesOverlappingWith",
    value: function _getEdgesOverlappingWith(object, overlappingEdges) {
      var edges = this.body.edges;

      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];

        if (edges[edgeId].isOverlappingWith(object)) {
          overlappingEdges.push(edgeId);
        }
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getAllEdgesOverlappingWith",
    value: function _getAllEdgesOverlappingWith(object) {
      var overlappingEdges = [];

      this._getEdgesOverlappingWith(object, overlappingEdges);

      return overlappingEdges;
    }
    /**
     * Get the edges nearest to the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnEdge=true]
     * @returns {Edge | undefined} node
     */

  }, {
    key: "getEdgeAt",
    value: function getEdgeAt(pointer) {
      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Iterate over edges, pick closest within 10
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      var mindist = 10;
      var overlappingEdge = null;
      var edges = this.body.edges;

      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        var edge = edges[edgeId];

        if (edge.connected) {
          var xFrom = edge.from.x;
          var yFrom = edge.from.y;
          var xTo = edge.to.x;
          var yTo = edge.to.y;
          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);

          if (dist < mindist) {
            overlappingEdge = edgeId;
            mindist = dist;
          }
        }
      }

      if (overlappingEdge !== null) {
        if (returnEdge === true) {
          return this.body.edges[overlappingEdge];
        } else {
          return overlappingEdge;
        }
      } else {
        return undefined;
      }
    }
    /**
     * Add object to the selection array.
     *
     * @param {object} obj
     * @private
     */

  }, {
    key: "_addToHover",
    value: function _addToHover(obj) {
      if (obj instanceof Node) {
        this.hoverObj.nodes[obj.id] = obj;
      } else {
        this.hoverObj.edges[obj.id] = obj;
      }
    }
    /**
     * Remove a single option from selection.
     *
     * @param {object} obj
     * @private
     */

  }, {
    key: "_removeFromSelection",
    value: function _removeFromSelection(obj) {
      if (obj instanceof Node) {
        var _this$_selectionAccum2;

        this._selectionAccumulator.deleteNodes(obj);

        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray(obj.edges));
      } else {
        this._selectionAccumulator.deleteEdges(obj);
      }
    }
    /**
     * Unselect all nodes and edges.
     */

  }, {
    key: "unselectAll",
    value: function unselectAll() {
      this._selectionAccumulator.clear();
    }
    /**
     * return the number of selected nodes
     *
     * @returns {number}
     */

  }, {
    key: "getSelectedNodeCount",
    value: function getSelectedNodeCount() {
      return this._selectionAccumulator.sizeNodes;
    }
    /**
     * return the number of selected edges
     *
     * @returns {number}
     */

  }, {
    key: "getSelectedEdgeCount",
    value: function getSelectedEdgeCount() {
      return this._selectionAccumulator.sizeEdges;
    }
    /**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: "_hoverConnectedEdges",
    value: function _hoverConnectedEdges(node) {
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        edge.hover = true;

        this._addToHover(edge);
      }
    }
    /**
     * Remove the highlight from a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @private
     */

  }, {
    key: "emitBlurEvent",
    value: function emitBlurEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      if (object.hover === true) {
        object.hover = false;

        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit("blurNode", properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit("blurEdge", properties);
        }
      }
    }
    /**
     * Create the highlight for a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @returns {boolean} hoverChanged
     * @private
     */

  }, {
    key: "emitHoverEvent",
    value: function emitHoverEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      var hoverChanged = false;

      if (object.hover === false) {
        object.hover = true;

        this._addToHover(object);

        hoverChanged = true;

        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit("hoverNode", properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit("hoverEdge", properties);
        }
      }

      return hoverChanged;
    }
    /**
     * Perform actions in response to a mouse movement.
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
     */

  }, {
    key: "hoverObject",
    value: function hoverObject(event, pointer) {
      var object = this.getNodeAt(pointer);

      if (object === undefined) {
        object = this.getEdgeAt(pointer);
      }

      var hoverChanged = false; // remove all node hover highlights

      for (var nodeId in this.hoverObj.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {
          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {
            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
            delete this.hoverObj.nodes[nodeId];
            hoverChanged = true;
          }
        }
      } // removing all edge hover highlights


      for (var edgeId in this.hoverObj.edges) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {
          // if the hover has been changed here it means that the node has been hovered over or off
          // we then do not use the emitBlurEvent method here.
          if (hoverChanged === true) {
            this.hoverObj.edges[edgeId].hover = false;
            delete this.hoverObj.edges[edgeId];
          } // if the blur remains the same and the object is undefined (mouse off) or another
          // edge has been hovered, or another node has been hovered we blur the edge.
          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {
            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
            delete this.hoverObj.edges[edgeId];
            hoverChanged = true;
          }
        }
      }

      if (object !== undefined) {
        var hoveredEdgesCount = keys$4(this.hoverObj.edges).length;

        var hoveredNodesCount = keys$4(this.hoverObj.nodes).length;

        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
        var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;

        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {
          hoverChanged = this.emitHoverEvent(event, pointer, object);
        }

        if (object instanceof Node && this.options.hoverConnectedEdges === true) {
          this._hoverConnectedEdges(object);
        }
      }

      if (hoverChanged === true) {
        this.body.emitter.emit("_requestRedraw");
      }
    }
    /**
     * Commit the selection changes but don't emit any events.
     */

  }, {
    key: "commitWithoutEmitting",
    value: function commitWithoutEmitting() {
      this._selectionAccumulator.commit();
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * For changing nodes, select/deselect events are fired.
     *
     * NOTE: For a given edge, if one connecting node is deselected and with the
     * same click the other node is selected, no events for the edge will fire. It
     * was selected and it will remain selected.
     *
     * @param {{x: number, y: number}} pointer - The x and y coordinates of the
     * click, tap, dragend… that triggered this.
     * @param {UIEvent} event - The event that triggered this.
     */

  }, {
    key: "commitAndEmit",
    value: function commitAndEmit(pointer, event) {
      var selected = false;

      var selectionChanges = this._selectionAccumulator.commit();

      var previousSelection = {
        nodes: selectionChanges.nodes.previous,
        edges: selectionChanges.edges.previous
      };

      if (selectionChanges.edges.deleted.length > 0) {
        this.generateClickEvent("deselectEdge", event, pointer, previousSelection);
        selected = true;
      }

      if (selectionChanges.nodes.deleted.length > 0) {
        this.generateClickEvent("deselectNode", event, pointer, previousSelection);
        selected = true;
      }

      if (selectionChanges.nodes.added.length > 0) {
        this.generateClickEvent("selectNode", event, pointer);
        selected = true;
      }

      if (selectionChanges.edges.added.length > 0) {
        this.generateClickEvent("selectEdge", event, pointer);
        selected = true;
      } // fire the select event if anything has been selected or deselected


      if (selected === true) {
        // select or unselect
        this.generateClickEvent("select", event, pointer);
      }
    }
    /**
     * Retrieve the currently selected node and edge ids.
     *
     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the
     * ids of the selected nodes and edges.
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return {
        nodes: this.getSelectedNodeIds(),
        edges: this.getSelectedEdgeIds()
      };
    }
    /**
     * Retrieve the currently selected nodes.
     *
     * @returns {Array} An array with selected nodes.
     */

  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      return this._selectionAccumulator.getNodes();
    }
    /**
     * Retrieve the currently selected edges.
     *
     * @returns {Array} An array with selected edges.
     */

  }, {
    key: "getSelectedEdges",
    value: function getSelectedEdges() {
      return this._selectionAccumulator.getEdges();
    }
    /**
     * Retrieve the currently selected node ids.
     *
     * @returns {Array} An array with the ids of the selected nodes.
     */

  }, {
    key: "getSelectedNodeIds",
    value: function getSelectedNodeIds() {
      var _context;

      return map$3(_context = this._selectionAccumulator.getNodes()).call(_context, function (node) {
        return node.id;
      });
    }
    /**
     * Retrieve the currently selected edge ids.
     *
     * @returns {Array} An array with the ids of the selected edges.
     */

  }, {
    key: "getSelectedEdgeIds",
    value: function getSelectedEdgeIds() {
      var _context2;

      return map$3(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function (edge) {
        return edge.id;
      });
    }
    /**
     * Updates the current selection
     *
     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
     * @param {object} options                                 Options
     */

  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!selection || !selection.nodes && !selection.edges) {
        throw new TypeError("Selection must be an object with nodes and/or edges properties");
      } // first unselect any selected node, if option is true or undefined


      if (options.unselectAll || options.unselectAll === undefined) {
        this.unselectAll();
      }

      if (selection.nodes) {
        var _iterator = _createForOfIteratorHelper$2(selection.nodes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var id = _step.value;
            var node = this.body.nodes[id];

            if (!node) {
              throw new RangeError('Node with id "' + id + '" not found');
            } // don't select edges with it


            this.selectObject(node, options.highlightEdges);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (selection.edges) {
        var _iterator2 = _createForOfIteratorHelper$2(selection.edges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _id = _step2.value;
            var edge = this.body.edges[_id];

            if (!edge) {
              throw new RangeError('Edge with id "' + _id + '" not found');
            }

            this.selectObject(edge);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      this.body.emitter.emit("_requestRedraw");

      this._selectionAccumulator.commit();
    }
    /**
     * select zero or more nodes with the option to highlight edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     * @param {boolean} [highlightEdges]
     */

  }, {
    key: "selectNodes",
    value: function selectNodes(selection) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!selection || selection.length === undefined) throw "Selection must be an array with ids";
      this.setSelection({
        nodes: selection
      }, {
        highlightEdges: highlightEdges
      });
    }
    /**
     * select zero or more edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     */

  }, {
    key: "selectEdges",
    value: function selectEdges(selection) {
      if (!selection || selection.length === undefined) throw "Selection must be an array with ids";
      this.setSelection({
        edges: selection
      });
    }
    /**
     * Validate the selection: remove ids of nodes which no longer exist
     *
     * @private
     */

  }, {
    key: "updateSelection",
    value: function updateSelection() {
      for (var node in this._selectionAccumulator.getNodes()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {
          this._selectionAccumulator.deleteNodes(node);
        }
      }

      for (var edge in this._selectionAccumulator.getEdges()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {
          this._selectionAccumulator.deleteEdges(edge);
        }
      }
    }
    /**
     * Determine all the visual elements clicked which are on the given point.
     *
     * All elements are returned; this includes nodes, edges and their labels.
     * The order returned is from highest to lowest, i.e. element 0 of the return
     * value is the topmost item clicked on.
     *
     * The return value consists of an array of the following possible elements:
     *
     * - `{nodeId:number}`             - node with given id clicked on
     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
     * - `{edgeId:number}`             - edge with given id clicked on
     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
     *
     * ## NOTES
     *
     * - Currently, there is only one label associated with a node or an edge,
     *   but this is expected to change somewhere in the future.
     * - Since there is no z-indexing yet, it is not really possible to set the nodes and
     *   edges in the correct order. For the time being, nodes come first.
     *
     * @param {point} pointer  mouse position in screen coordinates
     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
     * @private
     */

  }, {
    key: "getClickedItems",
    value: function getClickedItems(pointer) {
      var point = this.canvas.DOMtoCanvas(pointer);
      var items = []; // Note reverse order; we want the topmost clicked items to be first in the array
      // Also note that selected nodes are disregarded here; these normally display on top

      var nodeIndices = this.body.nodeIndices;
      var nodes = this.body.nodes;

      for (var i = nodeIndices.length - 1; i >= 0; i--) {
        var node = nodes[nodeIndices[i]];
        var ret = node.getItemsOnPoint(point);
        items.push.apply(items, ret); // Append the return value to the running list.
      }

      var edgeIndices = this.body.edgeIndices;
      var edges = this.body.edges;

      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
        var edge = edges[edgeIndices[_i]];

        var _ret = edge.getItemsOnPoint(point);

        items.push.apply(items, _ret); // Append the return value to the running list.
      }

      return items;
    }
  }]);

  return SelectionHandler;
}();

var timsort$1 = {};

/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/

(function (exports) {
  (function (global, factory) {
    {
      factory(exports);
    }
  })(commonjsGlobal, function (exports) {

    exports.__esModule = true;
    exports.sort = sort;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

    function log10(x) {
      if (x < 1e5) {
        if (x < 1e2) {
          return x < 1e1 ? 0 : 1;
        }

        if (x < 1e4) {
          return x < 1e3 ? 2 : 3;
        }

        return 4;
      }

      if (x < 1e7) {
        return x < 1e6 ? 5 : 6;
      }

      if (x < 1e9) {
        return x < 1e8 ? 7 : 8;
      }

      return 9;
    }

    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }

      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }

        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }

          if (a >= 0) {
            return 1;
          }

          a = -a;
          b = -b;
        }

        var al = log10(a);
        var bl = log10(b);
        var t = 0;

        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }

        if (a === b) {
          return t;
        }

        return a < b ? -1 : 1;
      }

      var aStr = String(a);
      var bStr = String(b);

      if (aStr === bStr) {
        return 0;
      }

      return aStr < bStr ? -1 : 1;
    }

    function minRunLength(n) {
      var r = 0;

      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }

      return n + r;
    }

    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;

      if (runHi === hi) {
        return 1;
      }

      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }

        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }

      return runHi - lo;
    }

    function reverseRun(array, lo, hi) {
      hi--;

      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }

    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }

      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;

        while (left < right) {
          var mid = left + right >>> 1;

          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }

        var n = start - left;

        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];

          case 2:
            array[left + 2] = array[left + 1];

          case 1:
            array[left + 1] = array[left];
            break;

          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }

        }

        array[left] = pivot;
      }
    }

    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }

      return offset;
    }

    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }

      return offset;
    }

    var TimSort = function () {
      function TimSort(array, compare) {
        _classCallCheck(this, TimSort);

        this.array = null;
        this.compare = null;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.length = 0;
        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
        this.stackLength = 0;
        this.runStart = null;
        this.runLength = null;
        this.stackSize = 0;
        this.array = array;
        this.compare = compare;
        this.length = array.length;

        if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
          this.tmpStorageLength = this.length >>> 1;
        }

        this.tmp = new Array(this.tmpStorageLength);
        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
      }

      TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      };

      TimSort.prototype.mergeRuns = function mergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;

          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }

          this.mergeAt(n);
        }
      };

      TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;

          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }

          this.mergeAt(n);
        }
      };

      TimSort.prototype.mergeAt = function mergeAt(i) {
        var compare = this.compare;
        var array = this.array;
        var start1 = this.runStart[i];
        var length1 = this.runLength[i];
        var start2 = this.runStart[i + 1];
        var length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;

        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }

        this.stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
          return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
          return;
        }

        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      };

      TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;

        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          return;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
          return;
        }

        var minGallop = this.minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;

              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;

              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }

              dest += count1;
              cursor1 += count1;
              length1 -= count1;

              if (length1 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest++] = array[cursor2++];

            if (--length2 === 0) {
              exit = true;
              break;
            }

            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }

              dest += count2;
              cursor2 += count2;
              length2 -= count2;

              if (length2 === 0) {
                exit = true;
                break;
              }
            }

            array[dest++] = tmp[cursor1++];

            if (--length1 === 1) {
              exit = true;
              break;
            }

            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (minGallop < 0) {
            minGallop = 0;
          }

          minGallop += 2;
        }

        this.minGallop = minGallop;

        if (minGallop < 1) {
          this.minGallop = 1;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error('mergeLow preconditions were not respected');
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      };

      TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;

        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }

          return;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
          return;
        }

        var minGallop = this.minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;

              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;

              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;

              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }

              if (length1 === 0) {
                exit = true;
                break;
              }
            }

            array[dest--] = tmp[cursor2--];

            if (--length2 === 1) {
              exit = true;
              break;
            }

            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;

              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }

              if (length2 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest--] = array[cursor1--];

            if (--length1 === 0) {
              exit = true;
              break;
            }

            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (minGallop < 0) {
            minGallop = 0;
          }

          minGallop += 2;
        }

        this.minGallop = minGallop;

        if (minGallop < 1) {
          this.minGallop = 1;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error('mergeHigh preconditions were not respected');
        } else {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      };

      return TimSort;
    }();

    function sort(array, compare, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError('Can only sort arrays');
      }

      if (!compare) {
        compare = alphabeticalCompare;
      } else if (typeof compare !== 'function') {
        hi = lo;
        lo = compare;
        compare = alphabeticalCompare;
      }

      if (!lo) {
        lo = 0;
      }

      if (!hi) {
        hi = array.length;
      }

      var remaining = hi - lo;

      if (remaining < 2) {
        return;
      }

      var runLength = 0;

      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }

      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);

      do {
        runLength = makeAscendingRun(array, lo, hi, compare);

        if (runLength < minRun) {
          var force = remaining;

          if (force > minRun) {
            force = minRun;
          }

          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);

      ts.forceMergeRuns();
    }
  });
})(timsort$1);

var timsort = timsort$1;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Interface definition for direction strategy classes.
 *
 * This class describes the interface for the Strategy
 * pattern classes used to differentiate horizontal and vertical
 * direction of hierarchical results.
 *
 * For a given direction, one coordinate will be 'fixed', meaning that it is
 * determined by level.
 * The other coordinate is 'unfixed', meaning that the nodes on a given level
 * can still move along that coordinate. So:
 *
 * - `vertical` layout: `x` unfixed, `y` fixed per level
 * - `horizontal` layout: `x` fixed per level, `y` unfixed
 *
 * The local methods are stubs and should be regarded as abstract.
 * Derived classes **must** implement all the methods themselves.
 *
 * @private
 */

var DirectionInterface = /*#__PURE__*/function () {
  function DirectionInterface() {
    _classCallCheck(this, DirectionInterface);
  }

  _createClass(DirectionInterface, [{
    key: "abstract",
    value:
    /**
     * @ignore
     */
    function abstract() {
      throw new Error("Can't instantiate abstract class!");
    }
    /**
     * This is a dummy call which is used to suppress the jsdoc errors of type:
     *
     *   "'param' is assigned a value but never used"
     *
     * @ignore
     */

  }, {
    key: "fake_use",
    value: function fake_use() {// Do nothing special
    }
    /**
     * Type to use to translate dynamic curves to, in the case of hierarchical layout.
     * Dynamic curves do not work for these.
     *
     * The value should be perpendicular to the actual direction of the layout.
     *
     * @returns {string} Direction, either 'vertical' or 'horizontal'
     */

  }, {
    key: "curveType",
    value: function curveType() {
      return this.abstract();
    }
    /**
     * Return the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to read
     * @returns {number} Value of the unfixed coordinate
     */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      this.fake_use(node);
      return this.abstract();
    }
    /**
     * Set the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to adjust
     * @param {number} position
     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
     */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      this.fake_use(node, position, level);
      this.abstract();
    }
    /**
     * Get the width of a tree.
     *
     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
     * only among themselves. In essence, it is a sub-network.
     *
     * @param {number} index The index number of a tree
     * @returns {number} the width of a tree in the view coordinates
     */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      this.fake_use(index);
      return this.abstract();
    }
    /**
     * Sort array of nodes on the unfixed coordinates.
     *
     * Note:** chrome has non-stable sorting implementation, which
     * has a tendency to change the order of the array items,
     * even if the custom sort function returns 0.
     *
     * For this reason, an external sort implementation is used,
     * which has the added benefit of being faster than the standard
     * platforms implementation. This has been verified on `node.js`,
     * `firefox` and `chrome` (all linux).
     *
     * @param {Array.<Node>} nodeArray array of nodes to sort
     */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      this.fake_use(nodeArray);
      this.abstract();
    }
    /**
     * Assign the fixed coordinate of the node to the given level
     *
     * @param {Node} node The node to adjust
     * @param {number} level The level to fix to
     */

  }, {
    key: "fix",
    value: function fix(node, level) {
      this.fake_use(node, level);
      this.abstract();
    }
    /**
     * Add an offset to the unfixed coordinate of the given node.
     *
     * @param {NodeId} nodeId Id of the node to adjust
     * @param {number} diff Offset to add to the unfixed coordinate
     */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.fake_use(nodeId, diff);
      this.abstract();
    }
  }]);

  return DirectionInterface;
}();
/**
 * Vertical Strategy
 *
 * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */


var VerticalStrategy = /*#__PURE__*/function (_DirectionInterface) {
  _inherits(VerticalStrategy, _DirectionInterface);

  var _super = _createSuper(VerticalStrategy);

  /**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */
  function VerticalStrategy(layout) {
    var _this;

    _classCallCheck(this, VerticalStrategy);

    _this = _super.call(this);
    _this.layout = layout;
    return _this;
  }
  /** @inheritDoc */


  _createClass(VerticalStrategy, [{
    key: "curveType",
    value: function curveType() {
      return "horizontal";
    }
    /** @inheritDoc */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      return node.x;
    }
    /** @inheritDoc */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }

      node.x = position;
    }
    /** @inheritDoc */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return {
        min: res.min_x,
        max: res.max_x
      };
    }
    /** @inheritDoc */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      timsort.sort(nodeArray, function (a, b) {
        return a.x - b.x;
      });
    }
    /** @inheritDoc */

  }, {
    key: "fix",
    value: function fix(node, level) {
      node.y = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.y = true;
    }
    /** @inheritDoc */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].x += diff;
    }
  }]);

  return VerticalStrategy;
}(DirectionInterface);
/**
 * Horizontal Strategy
 *
 * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */


var HorizontalStrategy = /*#__PURE__*/function (_DirectionInterface2) {
  _inherits(HorizontalStrategy, _DirectionInterface2);

  var _super2 = _createSuper(HorizontalStrategy);

  /**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */
  function HorizontalStrategy(layout) {
    var _this2;

    _classCallCheck(this, HorizontalStrategy);

    _this2 = _super2.call(this);
    _this2.layout = layout;
    return _this2;
  }
  /** @inheritDoc */


  _createClass(HorizontalStrategy, [{
    key: "curveType",
    value: function curveType() {
      return "vertical";
    }
    /** @inheritDoc */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      return node.y;
    }
    /** @inheritDoc */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }

      node.y = position;
    }
    /** @inheritDoc */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return {
        min: res.min_y,
        max: res.max_y
      };
    }
    /** @inheritDoc */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      timsort.sort(nodeArray, function (a, b) {
        return a.y - b.y;
      });
    }
    /** @inheritDoc */

  }, {
    key: "fix",
    value: function fix(node, level) {
      node.x = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.x = true;
    }
    /** @inheritDoc */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].y += diff;
    }
  }]);

  return HorizontalStrategy;
}(DirectionInterface);

var $ = _export;
var $every = arrayIteration.every;
var arrayMethodIsStrict = arrayMethodIsStrict$6;
var STRICT_METHOD = arrayMethodIsStrict('every'); // `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD
}, {
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual = entryVirtual$l;
var every$3 = entryVirtual('Array').every;

var isPrototypeOf = objectIsPrototypeOf;
var method = every$3;
var ArrayPrototype = Array.prototype;

var every$2 = function (it) {
  var own = it.every;
  return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.every ? method : own;
};

var parent = every$2;
var every$1 = parent;

var every = every$1;

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = slice(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Try to assign levels to nodes according to their positions in the cyclic “hierarchy”.
 *
 * @param nodes - Visible nodes of the graph.
 * @param levels - If present levels will be added to it, if not a new object will be created.
 * @returns Populated node levels.
 */
function fillLevelsByDirectionCyclic(nodes, levels) {
  var edges = new set();

  forEach$2(nodes).call(nodes, function (node) {
    var _context;

    forEach$2(_context = node.edges).call(_context, function (edge) {
      if (edge.connected) {
        edges.add(edge);
      }
    });
  });

  forEach$2(edges).call(edges, function (edge) {
    var fromId = edge.from.id;
    var toId = edge.to.id;

    if (levels[fromId] == null) {
      levels[fromId] = 0;
    }

    if (levels[toId] == null || levels[fromId] >= levels[toId]) {
      levels[toId] = levels[fromId] + 1;
    }
  });

  return levels;
}
/**
 * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.
 *
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */


function fillLevelsByDirectionLeaves(nodes) {
  return fillLevelsByDirection( // Pick only leaves (nodes without children).
  function (node) {
    var _context2, _context3;

    return every(_context2 = filter(_context3 = node.edges // Take only visible nodes into account.
    ).call(_context3, function (edge) {
      return nodes.has(edge.toId);
    }) // Check that all edges lead to this node (leaf).
    ).call(_context2, function (edge) {
      return edge.to === node;
    });
  }, // Use the lowest level.
  function (newLevel, oldLevel) {
    return oldLevel > newLevel;
  }, // Go against the direction of the edges.
  "from", nodes);
}
/**
 * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.
 *
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */

function fillLevelsByDirectionRoots(nodes) {
  return fillLevelsByDirection( // Pick only roots (nodes without parents).
  function (node) {
    var _context4, _context5;

    return every(_context4 = filter(_context5 = node.edges // Take only visible nodes into account.
    ).call(_context5, function (edge) {
      return nodes.has(edge.toId);
    }) // Check that all edges lead from this node (root).
    ).call(_context4, function (edge) {
      return edge.from === node;
    });
  }, // Use the highest level.
  function (newLevel, oldLevel) {
    return oldLevel < newLevel;
  }, // Go in the direction of the edges.
  "to", nodes);
}
/**
 * Assign levels to nodes according to their positions in the hierarchy.
 *
 * @param isEntryNode - Checks and return true if the graph should be traversed from this node.
 * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.
 * @param direction - Wheter the graph should be traversed in the direction of the edges `"to"` or in the other way `"from"`.
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */

function fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {
  var _context6;

  var levels = create$5(null); // If acyclic, the graph can be walked through with (most likely way) fewer
  // steps than the number bellow. The exact value isn't too important as long
  // as it's quick to compute (doesn't impact acyclic graphs too much), is
  // higher than the number of steps actually needed (doesn't cut off before
  // acyclic graph is walked through) and prevents infinite loops (cuts off for
  // cyclic graphs).


  var limit = reduce(_context6 = _toConsumableArray(values(nodes).call(nodes))).call(_context6, function (acc, node) {
    return acc + 1 + node.edges.length;
  }, 0);

  var edgeIdProp = direction + "Id";
  var newLevelDiff = direction === "to" ? 1 : -1;

  var _iterator = _createForOfIteratorHelper$1(nodes),
      _step;

  try {
    var _loop = function _loop() {
      var _step$value = _slicedToArray(_step.value, 2),
          entryNodeId = _step$value[0],
          entryNode = _step$value[1];

      if ( // Skip if the node is not visible.
      !nodes.has(entryNodeId) || // Skip if the node is not an entry node.
      !isEntryNode(entryNode)) {
        return "continue";
      } // Line up all the entry nodes on level 0.


      levels[entryNodeId] = 0;
      var stack = [entryNode];
      var done = 0;
      var node = void 0;

      var _loop2 = function _loop2() {
        var _context7, _context8;

        if (!nodes.has(entryNodeId)) {
          // Skip if the node is not visible.
          return "continue";
        }

        var newLevel = levels[node.id] + newLevelDiff;

        forEach$2(_context7 = filter(_context8 = node.edges).call(_context8, function (edge) {
          return (// Ignore disconnected edges.
            edge.connected && // Ignore circular edges.
            edge.to !== edge.from && // Ignore edges leading to the node that's currently being processed.
            edge[direction] !== node && // Ignore edges connecting to an invisible node.
            nodes.has(edge.toId) && // Ignore edges connecting from an invisible node.
            nodes.has(edge.fromId)
          );
        })).call(_context7, function (edge) {
          var targetNodeId = edge[edgeIdProp];
          var oldLevel = levels[targetNodeId];

          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {
            levels[targetNodeId] = newLevel;
            stack.push(edge[direction]);
          }
        });

        if (done > limit) {
          // This would run forever on a cyclic graph.
          return {
            v: {
              v: fillLevelsByDirectionCyclic(nodes, levels)
            }
          };
        } else {
          ++done;
        }
      };

      while (node = stack.pop()) {
        var _ret2 = _loop2();

        if (_ret2 === "continue") continue;
        if (_typeof(_ret2) === "object") return _ret2.v;
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return levels;
}

/**
 * There's a mix-up with terms in the code. Following are the formal definitions:
 *
 *   tree   - a strict hierarchical network, i.e. every node has at most one parent
 *   forest - a collection of trees. These distinct trees are thus not connected.
 *
 * So:
 * - in a network that is not a tree, there exist nodes with multiple parents.
 * - a network consisting of unconnected sub-networks, of which at least one
 *   is not a tree, is not a forest.
 *
 * In the code, the definitions are:
 *
 *   tree   - any disconnected sub-network, strict hierarchical or not.
 *   forest - a bunch of these sub-networks
 *
 * The difference between tree and not-tree is important in the code, notably within
 * to the block-shifting algorithm. The algorithm assumes formal trees and fails
 * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).
 *
 * In order to distinguish the definitions in the following code, the adjective 'formal' is
 * used. If 'formal' is absent, you must assume the non-formal definition.
 *
 * ----------------------------------------------------------------------------------
 * NOTES
 * =====
 *
 * A hierarchical layout is a different thing from a hierarchical network.
 * The layout is a way to arrange the nodes in the view; this can be done
 * on non-hierarchical networks as well. The converse is also possible.
 */
/**
 * Container for derived data on current network, relating to hierarchy.
 *
 * @private
 */

var HierarchicalStatus = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function HierarchicalStatus() {
    _classCallCheck(this, HierarchicalStatus);

    this.childrenReference = {}; // child id's per node id

    this.parentReference = {}; // parent id's per node id

    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong

    this.distributionOrdering = {}; // The nodes per level, in the display order

    this.levels = {}; // hierarchy level per node id

    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.

    this.isTree = false; // True if current network is a formal tree

    this.treeIndex = -1; // Highest tree id in current network.
  }
  /**
   * Add the relation between given nodes to the current state.
   *
   * @param {Node.id} parentNodeId
   * @param {Node.id} childNodeId
   */


  _createClass(HierarchicalStatus, [{
    key: "addRelation",
    value: function addRelation(parentNodeId, childNodeId) {
      if (this.childrenReference[parentNodeId] === undefined) {
        this.childrenReference[parentNodeId] = [];
      }

      this.childrenReference[parentNodeId].push(childNodeId);

      if (this.parentReference[childNodeId] === undefined) {
        this.parentReference[childNodeId] = [];
      }

      this.parentReference[childNodeId].push(parentNodeId);
    }
    /**
     * Check if the current state is for a formal tree or formal forest.
     *
     * This is the case if every node has at most one parent.
     *
     * Pre: parentReference init'ed properly for current network
     */

  }, {
    key: "checkIfTree",
    value: function checkIfTree() {
      for (var i in this.parentReference) {
        if (this.parentReference[i].length > 1) {
          this.isTree = false;
          return;
        }
      }

      this.isTree = true;
    }
    /**
     * Return the number of separate trees in the current network.
     *
     * @returns {number}
     */

  }, {
    key: "numTrees",
    value: function numTrees() {
      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively
    }
    /**
     * Assign a tree id to a node
     *
     * @param {Node} node
     * @param {string|number} treeId
     */

  }, {
    key: "setTreeIndex",
    value: function setTreeIndex(node, treeId) {
      if (treeId === undefined) return; // Don't bother

      if (this.trees[node.id] === undefined) {
        this.trees[node.id] = treeId;
        this.treeIndex = Math.max(treeId, this.treeIndex);
      }
    }
    /**
     * Ensure level for given id is defined.
     *
     * Sets level to zero for given node id if not already present
     *
     * @param {Node.id} nodeId
     */

  }, {
    key: "ensureLevel",
    value: function ensureLevel(nodeId) {
      if (this.levels[nodeId] === undefined) {
        this.levels[nodeId] = 0;
      }
    }
    /**
     * get the maximum level of a branch.
     *
     * TODO: Never entered; find a test case to test this!
     *
     * @param {Node.id} nodeId
     * @returns {number}
     */

  }, {
    key: "getMaxLevel",
    value: function getMaxLevel(nodeId) {
      var _this = this;

      var accumulator = {};

      var _getMaxLevel = function _getMaxLevel(nodeId) {
        if (accumulator[nodeId] !== undefined) {
          return accumulator[nodeId];
        }

        var level = _this.levels[nodeId];

        if (_this.childrenReference[nodeId]) {
          var children = _this.childrenReference[nodeId];

          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              level = Math.max(level, _getMaxLevel(children[i]));
            }
          }
        }

        accumulator[nodeId] = level;
        return level;
      };

      return _getMaxLevel(nodeId);
    }
    /**
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */

  }, {
    key: "levelDownstream",
    value: function levelDownstream(nodeA, nodeB) {
      if (this.levels[nodeB.id] === undefined) {
        // set initial level
        if (this.levels[nodeA.id] === undefined) {
          this.levels[nodeA.id] = 0;
        } // set level


        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
      }
    }
    /**
     * Small util method to set the minimum levels of the nodes to zero.
     *
     * @param {Array.<Node>} nodes
     */

  }, {
    key: "setMinLevelToZero",
    value: function setMinLevelToZero(nodes) {
      var minLevel = 1e9; // get the minimum level

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (this.levels[nodeId] !== undefined) {
            minLevel = Math.min(this.levels[nodeId], minLevel);
          }
        }
      } // subtract the minimum from the set so we have a range starting from 0


      for (var _nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {
          if (this.levels[_nodeId] !== undefined) {
            this.levels[_nodeId] -= minLevel;
          }
        }
      }
    }
    /**
     * Get the min and max xy-coordinates of a given tree
     *
     * @param {Array.<Node>} nodes
     * @param {number} index
     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
     */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(nodes, index) {
      var min_x = 1e9;
      var max_x = -1e9;
      var min_y = 1e9;
      var max_y = -1e9;

      for (var nodeId in this.trees) {
        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {
          if (this.trees[nodeId] === index) {
            var node = nodes[nodeId];
            min_x = Math.min(node.x, min_x);
            max_x = Math.max(node.x, max_x);
            min_y = Math.min(node.y, min_y);
            max_y = Math.max(node.y, max_y);
          }
        }
      }

      return {
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y
      };
    }
    /**
     * Check if two nodes have the same parent(s)
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise
     */

  }, {
    key: "hasSameParent",
    value: function hasSameParent(node1, node2) {
      var parents1 = this.parentReference[node1.id];
      var parents2 = this.parentReference[node2.id];

      if (parents1 === undefined || parents2 === undefined) {
        return false;
      }

      for (var i = 0; i < parents1.length; i++) {
        for (var j = 0; j < parents2.length; j++) {
          if (parents1[i] == parents2[j]) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * Check if two nodes are in the same tree.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if this is so, false otherwise
     */

  }, {
    key: "inSameSubNetwork",
    value: function inSameSubNetwork(node1, node2) {
      return this.trees[node1.id] === this.trees[node2.id];
    }
    /**
     * Get a list of the distinct levels in the current network
     *
     * @returns {Array}
     */

  }, {
    key: "getLevels",
    value: function getLevels() {
      return keys$4(this.distributionOrdering);
    }
    /**
     * Add a node to the ordering per level
     *
     * @param {Node} node
     * @param {number} level
     */

  }, {
    key: "addToOrdering",
    value: function addToOrdering(node, level) {
      if (this.distributionOrdering[level] === undefined) {
        this.distributionOrdering[level] = [];
      }

      var isPresent = false;
      var curLevel = this.distributionOrdering[level];

      for (var n in curLevel) {
        //if (curLevel[n].id === node.id) {
        if (curLevel[n] === node) {
          isPresent = true;
          break;
        }
      }

      if (!isPresent) {
        this.distributionOrdering[level].push(node);
        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
      }
    }
  }]);

  return HierarchicalStatus;
}();
/**
 * The Layout Engine
 */


var LayoutEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function LayoutEngine(body) {
    _classCallCheck(this, LayoutEngine);

    this.body = body; // Make sure there always is some RNG because the setOptions method won't
    // set it unless there's a seed for it.

    this._resetRNG(Math.random() + ":" + now$1());

    this.setPhysics = false;
    this.options = {};
    this.optionsBackup = {
      physics: {}
    };
    this.defaultOptions = {
      randomSeed: undefined,
      improvedLayout: true,
      clusterThreshold: 150,
      hierarchical: {
        enabled: false,
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: "UD",
        // UD, DU, LR, RL
        sortMethod: "hubsize" // hubsize, directed

      }
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(LayoutEngine, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this;

      this.body.emitter.on("_dataChanged", function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_dataLoaded", function () {
        _this2.layoutNetwork();
      });
      this.body.emitter.on("_resetHierarchicalLayout", function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function () {
        if (_this2.options.hierarchical.enabled !== true) {
          return;
        } // get the type of static smooth curve in case it is required


        var type = _this2.direction.curveType(); // force all edges into static smooth curves.


        _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
      });
    }
    /**
     *
     * @param {object} options
     * @param {object} allOptions
     * @returns {object}
     */

  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions) {
      if (options !== undefined) {
        var hierarchical = this.options.hierarchical;
        var prevHierarchicalState = hierarchical.enabled;
        selectiveDeepExtend(["randomSeed", "improvedLayout", "clusterThreshold"], this.options, options);
        mergeOptions(this.options, options, "hierarchical");

        if (options.randomSeed !== undefined) {
          this._resetRNG(options.randomSeed);
        }

        if (hierarchical.enabled === true) {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit("refresh", true);
          } // make sure the level separation is the right way up


          if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
            if (hierarchical.levelSeparation > 0) {
              hierarchical.levelSeparation *= -1;
            }
          } else {
            if (hierarchical.levelSeparation < 0) {
              hierarchical.levelSeparation *= -1;
            }
          }

          this.setDirectionStrategy();
          this.body.emitter.emit("_resetHierarchicalLayout"); // because the hierarchical system needs it's own physics and smooth curve settings,
          // we adapt the other options if needed.

          return this.adaptAllOptionsForHierarchicalLayout(allOptions);
        } else {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit("refresh");
            return deepExtend(allOptions, this.optionsBackup);
          }
        }
      }

      return allOptions;
    }
    /**
     * Reset the random number generator with given seed.
     *
     * @param {any} seed - The seed that will be forwarded the the RNG.
     */

  }, {
    key: "_resetRNG",
    value: function _resetRNG(seed) {
      this.initialRandomSeed = seed;
      this._rng = Alea(this.initialRandomSeed);
    }
    /**
     *
     * @param {object} allOptions
     * @returns {object}
     */

  }, {
    key: "adaptAllOptionsForHierarchicalLayout",
    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
      if (this.options.hierarchical.enabled === true) {
        var backupPhysics = this.optionsBackup.physics; // set the physics

        if (allOptions.physics === undefined || allOptions.physics === true) {
          allOptions.physics = {
            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,
            solver: "hierarchicalRepulsion"
          };
          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;
          backupPhysics.solver = backupPhysics.solver || "barnesHut";
        } else if (_typeof(allOptions.physics) === "object") {
          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
          backupPhysics.solver = allOptions.physics.solver || "barnesHut";
          allOptions.physics.solver = "hierarchicalRepulsion";
        } else if (allOptions.physics !== false) {
          backupPhysics.solver = "barnesHut";
          allOptions.physics = {
            solver: "hierarchicalRepulsion"
          };
        } // get the type of static smooth curve in case it is required


        var type = this.direction.curveType(); // disable smooth curves if nothing is defined. If smooth curves have been turned on,
        // turn them into static smooth curves.

        if (allOptions.edges === undefined) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions.edges = {
            smooth: false
          };
        } else if (allOptions.edges.smooth === undefined) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions.edges.smooth = false;
        } else {
          if (typeof allOptions.edges.smooth === "boolean") {
            this.optionsBackup.edges = {
              smooth: allOptions.edges.smooth
            };
            allOptions.edges.smooth = {
              enabled: allOptions.edges.smooth,
              type: type
            };
          } else {
            var smooth = allOptions.edges.smooth; // allow custom types except for dynamic

            if (smooth.type !== undefined && smooth.type !== "dynamic") {
              type = smooth.type;
            } // TODO: this is options merging; see if the standard routines can be used here.


            this.optionsBackup.edges = {
              smooth: {
                enabled: smooth.enabled === undefined ? true : smooth.enabled,
                type: smooth.type === undefined ? "dynamic" : smooth.type,
                roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
                forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
              }
            }; // NOTE: Copying an object to self; this is basically setting defaults for undefined variables

            allOptions.edges.smooth = {
              enabled: smooth.enabled === undefined ? true : smooth.enabled,
              type: type,
              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
            };
          }
        } // Force all edges into static smooth curves.
        // Only applies to edges that do not use the global options for smooth.


        this.body.emitter.emit("_forceDisableDynamicCurves", type);
      }

      return allOptions;
    }
    /**
     *
     * @param {Array.<Node>} nodesArray
     */

  }, {
    key: "positionInitially",
    value: function positionInitially(nodesArray) {
      if (this.options.hierarchical.enabled !== true) {
        this._resetRNG(this.initialRandomSeed);

        var radius = nodesArray.length + 50;

        for (var i = 0; i < nodesArray.length; i++) {
          var node = nodesArray[i];

          var angle = 2 * Math.PI * this._rng();

          if (node.x === undefined) {
            node.x = radius * Math.cos(angle);
          }

          if (node.y === undefined) {
            node.y = radius * Math.sin(angle);
          }
        }
      }
    }
    /**
     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
     * cluster them first to reduce the amount.
     */

  }, {
    key: "layoutNetwork",
    value: function layoutNetwork() {
      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
        var indices = this.body.nodeIndices; // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
        // nodes have predefined positions we use this.

        var positionDefined = 0;

        for (var i = 0; i < indices.length; i++) {
          var node = this.body.nodes[indices[i]];

          if (node.predefinedPosition === true) {
            positionDefined += 1;
          }
        } // if less than half of the nodes have a predefined position we continue


        if (positionDefined < 0.5 * indices.length) {
          var MAX_LEVELS = 10;
          var level = 0;
          var clusterThreshold = this.options.clusterThreshold; //
          // Define the options for the hidden cluster nodes
          // These options don't propagate outside the clustering phase.
          //
          // Some options are explicitly disabled, because they may be set in group or default node options.
          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.
          //
          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden
          // cluster nodes, leading to an exception on creation.
          //
          // All settings here are performance related, except when noted otherwise.
          //

          var clusterOptions = {
            clusterNodeProperties: {
              shape: "ellipse",
              // Bugfix: avoid type 'image', no images supplied
              label: "",
              // avoid label handling
              group: "",
              // avoid group handling
              font: {
                multi: false
              } // avoid font propagation

            },
            clusterEdgeProperties: {
              label: "",
              // avoid label handling
              font: {
                multi: false
              },
              // avoid font propagation
              smooth: {
                enabled: false // avoid drawing penalty for complex edges

              }
            }
          }; // if there are a lot of nodes, we cluster before we run the algorithm.
          // NOTE: this part fails to find clusters for large scale-free networks, which should
          //       be easily clusterable.
          // TODO: examine why this is so

          if (indices.length > clusterThreshold) {
            var startLength = indices.length;

            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
              //console.time("clustering")
              level += 1;
              var before = indices.length; // if there are many nodes we do a hubsize cluster

              if (level % 3 === 0) {
                this.body.modules.clustering.clusterBridges(clusterOptions);
              } else {
                this.body.modules.clustering.clusterOutliers(clusterOptions);
              }

              var after = indices.length;

              if (before == after && level % 3 !== 0) {
                this._declusterAll();

                this.body.emitter.emit("_layoutFailed");
                console.info("This network could not be positioned by this version of the improved layout algorithm." + " Please disable improvedLayout for better performance.");
                return;
              } //console.timeEnd("clustering")
              //console.log(before,level,after);

            } // increase the size of the edges


            this.body.modules.kamadaKawai.setOptions({
              springLength: Math.max(150, 2 * startLength)
            });
          }

          if (level > MAX_LEVELS) {
            console.info("The clustering didn't succeed within the amount of interations allowed," + " progressing with partial result.");
          } // position the system for these nodes and edges


          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true); // shift to center point

          this._shiftToCenter(); // perturb the nodes a little bit to force the physics to kick in


          var offset = 70;

          for (var _i = 0; _i < indices.length; _i++) {
            // Only perturb the nodes that aren't fixed
            var _node = this.body.nodes[indices[_i]];

            if (_node.predefinedPosition === false) {
              _node.x += (0.5 - this._rng()) * offset;
              _node.y += (0.5 - this._rng()) * offset;
            }
          } // uncluster all clusters


          this._declusterAll(); // reposition all bezier nodes.


          this.body.emitter.emit("_repositionBezierNodes");
        }
      }
    }
    /**
     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
     *
     * @private
     */

  }, {
    key: "_shiftToCenter",
    value: function _shiftToCenter() {
      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
      var center = NetworkUtil.findCenter(range);

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];
        node.x -= center.x;
        node.y -= center.y;
      }
    }
    /**
     * Expands all clusters
     *
     * @private
     */

  }, {
    key: "_declusterAll",
    value: function _declusterAll() {
      var clustersPresent = true;

      while (clustersPresent === true) {
        clustersPresent = false;

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
            clustersPresent = true;
            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
          }
        }

        if (clustersPresent === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     *
     * @returns {number|*}
     */

  }, {
    key: "getSeed",
    value: function getSeed() {
      return this.initialRandomSeed;
    }
    /**
     * This is the main function to layout the nodes in a hierarchical way.
     * It checks if the node details are supplied correctly
     *
     * @private
     */

  }, {
    key: "setupHierarchicalLayout",
    value: function setupHierarchicalLayout() {
      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
        // get the size of the largest hubs and check if the user has defined a level for a node.
        var node, nodeId;
        var definedLevel = false;
        var undefinedLevel = false;
        this.lastNodeOnLevel = {};
        this.hierarchical = new HierarchicalStatus();

        for (nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            node = this.body.nodes[nodeId];

            if (node.options.level !== undefined) {
              definedLevel = true;
              this.hierarchical.levels[nodeId] = node.options.level;
            } else {
              undefinedLevel = true;
            }
          }
        } // if the user defined some levels but not all, alert and run without hierarchical layout


        if (undefinedLevel === true && definedLevel === true) {
          throw new Error("To use the hierarchical layout, nodes require either no predefined levels" + " or levels have to be defined for all nodes.");
        } else {
          // define levels if undefined by the users. Based on hubsize.
          if (undefinedLevel === true) {
            var sortMethod = this.options.hierarchical.sortMethod;

            if (sortMethod === "hubsize") {
              this._determineLevelsByHubsize();
            } else if (sortMethod === "directed") {
              this._determineLevelsDirected();
            } else if (sortMethod === "custom") {
              this._determineLevelsCustomCallback();
            }
          } // fallback for cases where there are nodes but no edges


          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.hierarchical.ensureLevel(_nodeId2);
            }
          } // check the distribution of the nodes per level.


          var distribution = this._getDistribution(); // get the parent children relations.


          this._generateMap(); // place the nodes on the canvas.


          this._placeNodesByHierarchy(distribution); // condense the whitespace.


          this._condenseHierarchy(); // shift to center so gravity does not have to do much


          this._shiftToCenter();
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_condenseHierarchy",
    value: function _condenseHierarchy() {
      var _this3 = this;

      // Global var in this scope to define when the movement has stopped.
      var stillShifting = false;
      var branches = {}; // first we have some methods to help shifting trees around.
      // the main method to shift the trees

      var shiftTrees = function shiftTrees() {
        var treeSizes = getTreeSizes();
        var shiftBy = 0;

        for (var i = 0; i < treeSizes.length - 1; i++) {
          var diff = treeSizes[i].max - treeSizes[i + 1].min;
          shiftBy += diff + _this3.options.hierarchical.treeSpacing;
          shiftTree(i + 1, shiftBy);
        }
      }; // shift a single tree by an offset


      var shiftTree = function shiftTree(index, offset) {
        var trees = _this3.hierarchical.trees;

        for (var nodeId in trees) {
          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {
            if (trees[nodeId] === index) {
              _this3.direction.shift(nodeId, offset);
            }
          }
        }
      }; // get the width of all trees


      var getTreeSizes = function getTreeSizes() {
        var treeWidths = [];

        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
          treeWidths.push(_this3.direction.getTreeSize(i));
        }

        return treeWidths;
      }; // get a map of all nodes in this branch


      var getBranchNodes = function getBranchNodes(source, map) {
        if (map[source.id]) {
          return;
        }

        map[source.id] = true;

        if (_this3.hierarchical.childrenReference[source.id]) {
          var children = _this3.hierarchical.childrenReference[source.id];

          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              getBranchNodes(_this3.body.nodes[children[i]], map);
            }
          }
        }
      }; // get a min max width as well as the maximum movement space it has on either sides
      // we use min max terminology because width and height can interchange depending on the direction of the layout


      var getBranchBoundary = function getBranchBoundary(branchMap) {
        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;
        var minSpace = 1e9;
        var maxSpace = 1e9;
        var min = 1e9;
        var max = -1e9;

        for (var branchNode in branchMap) {
          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {
            var node = _this3.body.nodes[branchNode];
            var level = _this3.hierarchical.levels[node.id];

            var position = _this3.direction.getPosition(node); // get the space around the node.


            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap),
                _this3$_getSpaceAroun2 = _slicedToArray(_this3$_getSpaceAroun, 2),
                minSpaceNode = _this3$_getSpaceAroun2[0],
                maxSpaceNode = _this3$_getSpaceAroun2[1];

            minSpace = Math.min(minSpaceNode, minSpace);
            maxSpace = Math.min(maxSpaceNode, maxSpace); // the width is only relevant for the levels two nodes have in common. This is why we filter on this.

            if (level <= maxLevel) {
              min = Math.min(position, min);
              max = Math.max(position, max);
            }
          }
        }

        return [min, max, minSpace, maxSpace];
      }; // check what the maximum level is these nodes have in common.


      var getCollisionLevel = function getCollisionLevel(node1, node2) {
        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);

        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);

        return Math.min(maxLevel1, maxLevel2);
      };
      /**
       * Condense elements. These can be nodes or branches depending on the callback.
       *
       * @param {Function} callback
       * @param {Array.<number>} levels
       * @param {*} centerParents
       */


      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
        var hier = _this3.hierarchical;

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = hier.distributionOrdering[level];

          if (levelNodes.length > 1) {
            for (var j = 0; j < levelNodes.length - 1; j++) {
              var node1 = levelNodes[j];
              var node2 = levelNodes[j + 1]; // NOTE: logic maintained as it was; if nodes have same ancestor,
              //       then of course they are in the same sub-network.

              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                callback(node1, node2, centerParents);
              }
            }
          }
        }
      }; // callback for shifting branches


      var branchShiftCallback = function branchShiftCallback(node1, node2) {
        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        //window.CALLBACKS.push(() => {
        var pos1 = _this3.direction.getPosition(node1);

        var pos2 = _this3.direction.getPosition(node2);

        var diffAbs = Math.abs(pos2 - pos1);
        var nodeSpacing = _this3.options.hierarchical.nodeSpacing; //console.log("NOW CHECKING:", node1.id, node2.id, diffAbs);

        if (diffAbs > nodeSpacing) {
          var branchNodes1 = {};
          var branchNodes2 = {};
          getBranchNodes(node1, branchNodes1);
          getBranchNodes(node2, branchNodes2); // check the largest distance between the branches

          var maxLevel = getCollisionLevel(node1, node2);
          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
          var max1 = branchNodeBoundary1[1];
          var min2 = branchNodeBoundary2[0];
          var minSpace2 = branchNodeBoundary2[2]; //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,
          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);

          var diffBranch = Math.abs(max1 - min2);

          if (diffBranch > nodeSpacing) {
            var offset = max1 - min2 + nodeSpacing;

            if (offset < -minSpace2 + nodeSpacing) {
              offset = -minSpace2 + nodeSpacing; //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
            }

            if (offset < 0) {
              //console.log("SHIFTING", node2.id, offset);
              _this3._shiftBlock(node2.id, offset);

              stillShifting = true;
              if (centerParent === true) _this3._centerParent(node2);
            }
          }
        } //this.body.emitter.emit("_redraw");})

      };

      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
        //window.CALLBACKS.push(() => {
        //  console.log("ts",node.id);
        var nodeId = node.id;
        var allEdges = node.edges;
        var nodeLevel = _this3.hierarchical.levels[node.id]; // gather constants

        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
        var referenceNodes = {};
        var aboveEdges = [];

        for (var i = 0; i < allEdges.length; i++) {
          var edge = allEdges[i];

          if (edge.toId != edge.fromId) {
            var otherNode = edge.toId == nodeId ? edge.from : edge.to;
            referenceNodes[allEdges[i].id] = otherNode;

            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
              aboveEdges.push(edge);
            }
          }
        } // differentiated sum of lengths based on only moving one node over one axis


        var getFx = function getFx(point, edges) {
          var sum = 0;

          for (var _i2 = 0; _i2 < edges.length; _i2++) {
            if (referenceNodes[edges[_i2].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
              sum += a / Math.sqrt(a * a + C2);
            }
          }

          return sum;
        }; // doubly differentiated sum of lengths based on only moving one node over one axis


        var getDFx = function getDFx(point, edges) {
          var sum = 0;

          for (var _i3 = 0; _i3 < edges.length; _i3++) {
            if (referenceNodes[edges[_i3].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
              sum -= C2 * Math.pow(a * a + C2, -1.5);
            }
          }

          return sum;
        };

        var getGuess = function getGuess(iterations, edges) {
          var guess = _this3.direction.getPosition(node); // Newton's method for optimization


          var guessMap = {};

          for (var _i4 = 0; _i4 < iterations; _i4++) {
            var fx = getFx(guess, edges);
            var dfx = getDFx(guess, edges); // we limit the movement to avoid instability.

            var limit = 40;
            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
            guess = guess - ratio; // reduce duplicates

            if (guessMap[guess] !== undefined) {
              break;
            }

            guessMap[guess] = _i4;
          }

          return guess;
        };

        var moveBranch = function moveBranch(guess) {
          // position node if there is space
          var nodePosition = _this3.direction.getPosition(node); // check movable area of the branch


          if (branches[node.id] === undefined) {
            var branchNodes = {};
            getBranchNodes(node, branchNodes);
            branches[node.id] = branchNodes;
          }

          var branchBoundary = getBranchBoundary(branches[node.id]);
          var minSpaceBranch = branchBoundary[2];
          var maxSpaceBranch = branchBoundary[3];
          var diff = guess - nodePosition; // check if we are allowed to move the node:

          var branchOffset = 0;

          if (diff > 0) {
            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          } else if (diff < 0) {
            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          }

          if (branchOffset != 0) {
            //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
            _this3._shiftBlock(node.id, branchOffset); //this.body.emitter.emit("_redraw");


            stillShifting = true;
          }
        };

        var moveNode = function moveNode(guess) {
          var nodePosition = _this3.direction.getPosition(node); // position node if there is space


          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node),
              _this3$_getSpaceAroun4 = _slicedToArray(_this3$_getSpaceAroun3, 2),
              minSpace = _this3$_getSpaceAroun4[0],
              maxSpace = _this3$_getSpaceAroun4[1];

          var diff = guess - nodePosition; // check if we are allowed to move the node:

          var newPosition = nodePosition;

          if (diff > 0) {
            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);
          } else if (diff < 0) {
            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);
          }

          if (newPosition !== nodePosition) {
            //console.log("moving Node:",diff, minSpace, maxSpace);
            _this3.direction.setPosition(node, newPosition); //this.body.emitter.emit("_redraw");


            stillShifting = true;
          }
        };

        var guess = getGuess(iterations, aboveEdges);
        moveBranch(guess);
        guess = getGuess(iterations, allEdges);
        moveNode(guess); //})
      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.


      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < iterations; i++) {
          stillShifting = false;

          for (var j = 0; j < levels.length; j++) {
            var level = levels[j];
            var levelNodes = _this3.hierarchical.distributionOrdering[level];

            for (var k = 0; k < levelNodes.length; k++) {
              minimizeEdgeLength(1000, levelNodes[k]);
            }
          }

          if (stillShifting !== true) {
            //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
            break;
          }
        }
      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.


      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          shiftElementsCloser(branchShiftCallback, levels, true);

          if (stillShifting !== true) {
            //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
            break;
          }
        }
      }; // center all parents


      var centerAllParents = function centerAllParents() {
        for (var nodeId in _this3.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);
        }
      }; // center all parents


      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = _this3.hierarchical.distributionOrdering[level];

          for (var j = 0; j < levelNodes.length; j++) {
            _this3._centerParent(levelNodes[j]);
          }
        }
      }; // the actual work is done here.


      if (this.options.hierarchical.blockShifting === true) {
        shiftBranchesCloserBottomUp(5);
        centerAllParents();
      } // minimize edge length


      if (this.options.hierarchical.edgeMinimization === true) {
        minimizeEdgeLengthBottomUp(20);
      }

      if (this.options.hierarchical.parentCentralization === true) {
        centerAllParentsBottomUp();
      }

      shiftTrees();
    }
    /**
     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
     * This is used to only get the distances to nodes outside of a branch.
     *
     * @param {Node} node
     * @param {{Node.id: vis.Node}} map
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getSpaceAroundNode",
    value: function _getSpaceAroundNode(node, map) {
      var useMap = true;

      if (map === undefined) {
        useMap = false;
      }

      var level = this.hierarchical.levels[node.id];

      if (level !== undefined) {
        var index = this.hierarchical.distributionIndex[node.id];
        var position = this.direction.getPosition(node);
        var ordering = this.hierarchical.distributionOrdering[level];
        var minSpace = 1e9;
        var maxSpace = 1e9;

        if (index !== 0) {
          var prevNode = ordering[index - 1];

          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
            var prevPos = this.direction.getPosition(prevNode);
            minSpace = position - prevPos;
          }
        }

        if (index != ordering.length - 1) {
          var nextNode = ordering[index + 1];

          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
            var nextPos = this.direction.getPosition(nextNode);
            maxSpace = Math.min(maxSpace, nextPos - position);
          }
        }

        return [minSpace, maxSpace];
      } else {
        return [0, 0];
      }
    }
    /**
     * We use this method to center a parent node and check if it does not cross other nodes when it does.
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: "_centerParent",
    value: function _centerParent(node) {
      if (this.hierarchical.parentReference[node.id]) {
        var parents = this.hierarchical.parentReference[node.id];

        for (var i = 0; i < parents.length; i++) {
          var parentId = parents[i];
          var parentNode = this.body.nodes[parentId];
          var children = this.hierarchical.childrenReference[parentId];

          if (children !== undefined) {
            // get the range of the children
            var newPosition = this._getCenterPosition(children);

            var position = this.direction.getPosition(parentNode);

            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode),
                _this$_getSpaceAround2 = _slicedToArray(_this$_getSpaceAround, 2),
                minSpace = _this$_getSpaceAround2[0],
                maxSpace = _this$_getSpaceAround2[1];

            var diff = position - newPosition;

            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
              this.direction.setPosition(parentNode, newPosition);
            }
          }
        }
      }
    }
    /**
     * This function places the nodes on the canvas based on the hierarchial distribution.
     *
     * @param {object} distribution | obtained by the function this._getDistribution()
     * @private
     */

  }, {
    key: "_placeNodesByHierarchy",
    value: function _placeNodesByHierarchy(distribution) {
      this.positionedNodes = {}; // start placing all the level 0 nodes first. Then recursively position their branches.

      for (var level in distribution) {
        if (Object.prototype.hasOwnProperty.call(distribution, level)) {
          var _context;

          // sort nodes in level by position:
          var nodeArray = keys$4(distribution[level]);

          nodeArray = this._indexArrayToNodes(nodeArray);

          sort(_context = this.direction).call(_context, nodeArray);

          var handledNodeCount = 0;

          for (var i = 0; i < nodeArray.length; i++) {
            var node = nodeArray[i];

            if (this.positionedNodes[node.id] === undefined) {
              var spacing = this.options.hierarchical.nodeSpacing;
              var pos = spacing * handledNodeCount; // We get the X or Y values we need and store them in pos and previousPos.
              // The get and set make sure we get X or Y

              if (handledNodeCount > 0) {
                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
              }

              this.direction.setPosition(node, pos, level);

              this._validatePositionAndContinue(node, level, pos);

              handledNodeCount++;
            }
          }
        }
      }
    }
    /**
     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
     * on a X position that ensures there will be no overlap.
     *
     * @param {Node.id} parentId
     * @param {number} parentLevel
     * @private
     */

  }, {
    key: "_placeBranchNodes",
    value: function _placeBranchNodes(parentId, parentLevel) {
      var _context2;

      var childRef = this.hierarchical.childrenReference[parentId]; // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.

      if (childRef === undefined) {
        return;
      } // get a list of childNodes


      var childNodes = [];

      for (var i = 0; i < childRef.length; i++) {
        childNodes.push(this.body.nodes[childRef[i]]);
      } // use the positions to order the nodes.


      sort(_context2 = this.direction).call(_context2, childNodes); // position the childNodes


      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
        var childNode = childNodes[_i5];
        var childNodeLevel = this.hierarchical.levels[childNode.id]; // check if the child node is below the parent node and if it has already been positioned.

        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
          // get the amount of space required for this node. If parent the width is based on the amount of children.
          var spacing = this.options.hierarchical.nodeSpacing;
          var pos = void 0; // we get the X or Y values we need and store them in pos and previousPos.
          // The get and set make sure we get X or Y

          if (_i5 === 0) {
            pos = this.direction.getPosition(this.body.nodes[parentId]);
          } else {
            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
          }

          this.direction.setPosition(childNode, pos, childNodeLevel);

          this._validatePositionAndContinue(childNode, childNodeLevel, pos);
        } else {
          return;
        }
      } // center the parent nodes.


      var center = this._getCenterPosition(childNodes);

      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
    }
    /**
     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
     * Finally it will call _placeBranchNodes to place the branch nodes.
     *
     * @param {Node} node
     * @param {number} level
     * @param {number} pos
     * @private
     */

  }, {
    key: "_validatePositionAndContinue",
    value: function _validatePositionAndContinue(node, level, pos) {
      // This method only works for formal trees and formal forests
      // Early exit if this is not the case
      if (!this.hierarchical.isTree) return; // if overlap has been detected, we shift the branch

      if (this.lastNodeOnLevel[level] !== undefined) {
        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);

        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;

          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);

          this._shiftBlock(sharedParent.withChild, diff);
        }
      }

      this.lastNodeOnLevel[level] = node.id; // store change in position.

      this.positionedNodes[node.id] = true;

      this._placeBranchNodes(node.id, level);
    }
    /**
     * Receives an array with node indices and returns an array with the actual node references.
     * Used for sorting based on node properties.
     *
     * @param {Array.<Node.id>} idArray
     * @returns {Array.<Node>}
     */

  }, {
    key: "_indexArrayToNodes",
    value: function _indexArrayToNodes(idArray) {
      var array = [];

      for (var i = 0; i < idArray.length; i++) {
        array.push(this.body.nodes[idArray[i]]);
      }

      return array;
    }
    /**
     * This function get the distribution of levels based on hubsize
     *
     * @returns {object}
     * @private
     */

  }, {
    key: "_getDistribution",
    value: function _getDistribution() {
      var distribution = {};
      var nodeId, node; // we fix Y because the hierarchy is vertical,
      // we fix X so we do not give a node an x position for a second time.
      // the fix of X is removed after the x value has been set.

      for (nodeId in this.body.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
          node = this.body.nodes[nodeId];
          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];
          this.direction.fix(node, level);

          if (distribution[level] === undefined) {
            distribution[level] = {};
          }

          distribution[level][nodeId] = node;
        }
      }

      return distribution;
    }
    /**
     * Return the active (i.e. visible) edges for this node
     *
     * @param {Node} node
     * @returns {Array.<vis.Edge>} Array of edge instances
     * @private
     */

  }, {
    key: "_getActiveEdges",
    value: function _getActiveEdges(node) {
      var _this4 = this;

      var result = [];
      forEach$1(node.edges, function (edge) {
        var _context3;

        if (indexOf(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {
          result.push(edge);
        }
      });
      return result;
    }
    /**
     * Get the hubsizes for all active nodes.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_getHubSizes",
    value: function _getHubSizes() {
      var _this5 = this;

      var hubSizes = {};
      var nodeIds = this.body.nodeIndices;
      forEach$1(nodeIds, function (nodeId) {
        var node = _this5.body.nodes[nodeId];

        var hubSize = _this5._getActiveEdges(node).length;

        hubSizes[hubSize] = true;
      }); // Make an array of the size sorted descending

      var result = [];
      forEach$1(hubSizes, function (size) {
        result.push(Number(size));
      });

      sort(timsort).call(timsort, result, function (a, b) {
        return b - a;
      });

      return result;
    }
    /**
     * this function allocates nodes in levels based on the recursive branching from the largest hubs.
     *
     * @private
     */

  }, {
    key: "_determineLevelsByHubsize",
    value: function _determineLevelsByHubsize() {
      var _this6 = this;

      var levelDownstream = function levelDownstream(nodeA, nodeB) {
        _this6.hierarchical.levelDownstream(nodeA, nodeB);
      };

      var hubSizes = this._getHubSizes();

      var _loop = function _loop(i) {
        var hubSize = hubSizes[i];
        if (hubSize === 0) return "break";
        forEach$1(_this6.body.nodeIndices, function (nodeId) {
          var node = _this6.body.nodes[nodeId];

          if (hubSize === _this6._getActiveEdges(node).length) {
            _this6._crawlNetwork(levelDownstream, nodeId);
          }
        });
      };

      for (var i = 0; i < hubSizes.length; ++i) {
        var _ret = _loop(i);

        if (_ret === "break") break;
      }
    }
    /**
     * TODO: release feature
     * TODO: Determine if this feature is needed at all
     *
     * @private
     */

  }, {
    key: "_determineLevelsCustomCallback",
    value: function _determineLevelsCustomCallback() {
      var _this7 = this;

      var minLevel = 100000; // TODO: this should come from options.
      // eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.

      var customCallback = function customCallback(nodeA, nodeB, edge) {}; // TODO: perhaps move to HierarchicalStatus.
      //       But I currently don't see the point, this method is not used.


      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
        var levelA = _this7.hierarchical.levels[nodeA.id]; // set initial level

        if (levelA === undefined) {
          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
        }

        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
        _this7.hierarchical.levels[nodeB.id] = levelA + diff;
      };

      this._crawlNetwork(levelByDirection);

      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Allocate nodes in levels based on the direction of the edges.
     *
     * @private
     */

  }, {
    key: "_determineLevelsDirected",
    value: function _determineLevelsDirected() {
      var _context4,
          _this8 = this;

      var nodes = reduce(_context4 = this.body.nodeIndices).call(_context4, function (acc, id) {
        acc.set(id, _this8.body.nodes[id]);
        return acc;
      }, new map());

      if (this.options.hierarchical.shakeTowards === "roots") {
        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);
      } else {
        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);
      }

      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Update the bookkeeping of parent and child.
     *
     * @private
     */

  }, {
    key: "_generateMap",
    value: function _generateMap() {
      var _this9 = this;

      var fillInRelations = function fillInRelations(parentNode, childNode) {
        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
          _this9.hierarchical.addRelation(parentNode.id, childNode.id);
        }
      };

      this._crawlNetwork(fillInRelations);

      this.hierarchical.checkIfTree();
    }
    /**
     * Crawl over the entire network and use a callback on each node couple that is connected to each other.
     *
     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
     * @param {Node.id} startingNodeId
     * @private
     */

  }, {
    key: "_crawlNetwork",
    value: function _crawlNetwork() {
      var _this10 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var startingNodeId = arguments.length > 1 ? arguments[1] : undefined;
      var progress = {};

      var crawler = function crawler(node, tree) {
        if (progress[node.id] === undefined) {
          _this10.hierarchical.setTreeIndex(node, tree);

          progress[node.id] = true;
          var childNode;

          var edges = _this10._getActiveEdges(node);

          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];

            if (edge.connected === true) {
              if (edge.toId == node.id) {
                // Not '===' because id's can be string and numeric
                childNode = edge.from;
              } else {
                childNode = edge.to;
              }

              if (node.id != childNode.id) {
                // Not '!==' because id's can be string and numeric
                callback(node, childNode, edge);
                crawler(childNode, tree);
              }
            }
          }
        }
      };

      if (startingNodeId === undefined) {
        // Crawl over all nodes
        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];

          if (progress[nodeId] === undefined) {
            var node = this.body.nodes[nodeId];
            crawler(node, treeIndex);
            treeIndex += 1;
          }
        }
      } else {
        // Crawl from the given starting node
        var _node2 = this.body.nodes[startingNodeId];

        if (_node2 === undefined) {
          console.error("Node not found:", startingNodeId);
          return;
        }

        crawler(_node2);
      }
    }
    /**
     * Shift a branch a certain distance
     *
     * @param {Node.id} parentId
     * @param {number} diff
     * @private
     */

  }, {
    key: "_shiftBlock",
    value: function _shiftBlock(parentId, diff) {
      var _this11 = this;

      var progress = {};

      var shifter = function shifter(parentId) {
        if (progress[parentId]) {
          return;
        }

        progress[parentId] = true;

        _this11.direction.shift(parentId, diff);

        var childRef = _this11.hierarchical.childrenReference[parentId];

        if (childRef !== undefined) {
          for (var i = 0; i < childRef.length; i++) {
            shifter(childRef[i]);
          }
        }
      };

      shifter(parentId);
    }
    /**
     * Find a common parent between branches.
     *
     * @param {Node.id} childA
     * @param {Node.id} childB
     * @returns {{foundParent, withChild}}
     * @private
     */

  }, {
    key: "_findCommonParent",
    value: function _findCommonParent(childA, childB) {
      var _this12 = this;

      var parents = {};

      var iterateParents = function iterateParents(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];

        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];
            parents[parent] = true;
            iterateParents(parents, parent);
          }
        }
      };

      var findParent = function findParent(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];

        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];

            if (parents[parent] !== undefined) {
              return {
                foundParent: parent,
                withChild: child
              };
            }

            var branch = findParent(parents, parent);

            if (branch.foundParent !== null) {
              return branch;
            }
          }
        }

        return {
          foundParent: null,
          withChild: child
        };
      };

      iterateParents(parents, childA);
      return findParent(parents, childB);
    }
    /**
     * Set the strategy pattern for handling the coordinates given the current direction.
     *
     * The individual instances contain all the operations and data specific to a layout direction.
     *
     * @param {Node} node
     * @param {{x: number, y: number}} position
     * @param {number} level
     * @param {boolean} [doNotUpdate=false]
     * @private
     */

  }, {
    key: "setDirectionStrategy",
    value: function setDirectionStrategy() {
      var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";

      if (isVertical) {
        this.direction = new VerticalStrategy(this);
      } else {
        this.direction = new HorizontalStrategy(this);
      }
    }
    /**
     * Determine the center position of a branch from the passed list of child nodes
     *
     * This takes into account the positions of all the child nodes.
     *
     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
     * @returns {number}
     * @private
     */

  }, {
    key: "_getCenterPosition",
    value: function _getCenterPosition(childNodes) {
      var minPos = 1e9;
      var maxPos = -1e9;

      for (var i = 0; i < childNodes.length; i++) {
        var childNode = void 0;

        if (childNodes[i].id !== undefined) {
          childNode = childNodes[i];
        } else {
          var childNodeId = childNodes[i];
          childNode = this.body.nodes[childNodeId];
        }

        var position = this.direction.getPosition(childNode);
        minPos = Math.min(minPos, position);
        maxPos = Math.max(maxPos, position);
      }

      return 0.5 * (minPos + maxPos);
    }
  }]);

  return LayoutEngine;
}();

var css_248z = "div.vis-network div.vis-manipulation {\n  box-sizing: content-box;\n\n  border-width: 0;\n  border-bottom: 1px;\n  border-style: solid;\n  border-color: #d6d9d8;\n  background: #ffffff; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #ffffff),\n    color-stop(48%, #fcfcfc),\n    color-stop(50%, #fafafa),\n    color-stop(100%, #fcfcfc)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#fcfcfc',GradientType=0 ); /* IE6-9 */\n\n  padding-top: 4px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 28px;\n}\n\ndiv.vis-network div.vis-edit-mode,\ndiv.vis-network button.vis-edit-mode {\n  position: absolute;\n  left: 0;\n  top: 5px;\n  height: 30px;\n}\n\n/* FIXME: shouldn't the vis-close button be a child of the vis-manipulation div? */\n\ndiv.vis-network button.vis-close {\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 30px;\n  height: 30px;\n\n  background-color: transparent;\n  background-position: 20px 3px;\n  background-repeat: no-repeat;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC');\n  border: none;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network button.vis-close:hover {\n  opacity: 0.6;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button,\ndiv.vis-network div.vis-edit-mode button.vis-button {\n  float: left;\n  font-family: verdana;\n  font-size: 12px;\n  border: none;\n  box-sizing: content-box;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  background-color: transparent;\n  background-position: 0px 0px;\n  background-repeat: no-repeat;\n  height: 24px;\n  margin-left: 10px;\n  cursor: pointer;\n  padding: 0px 8px 0px 8px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.2);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.5);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-back {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-none:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n  cursor: default;\n}\ndiv.vis-network div.vis-manipulation div.vis-none:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n}\ndiv.vis-network div.vis-manipulation div.vis-none {\n  padding: 0px;\n  line-height: 23px;\n}\ndiv.vis-network div.vis-manipulation div.notification {\n  margin: 2px;\n  font-weight: bold;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-add {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-edit,\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode {\n  background-color: #fcfcfc;\n  border: 1px solid #cccccc;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-connect {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-delete {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=');\n}\n/* top right bottom left */\ndiv.vis-network div.vis-manipulation div.vis-label,\ndiv.vis-network div.vis-edit-mode div.vis-label {\n  margin: 0 0 0 23px;\n  line-height: 25px;\n}\ndiv.vis-network div.vis-manipulation div.vis-separator-line {\n  float: left;\n  display: inline-block;\n  width: 1px;\n  height: 21px;\n  background-color: #bdbdbd;\n  margin: 0px 7px 0 15px; /*top right bottom left*/\n}\n\n/* TODO: is this redundant?\ndiv.network-navigation_wrapper {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n*/\n";
styleInject(css_248z);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { var _context32; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = slice(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Clears the toolbar div element of children
 *
 * @private
 */

var ManipulationSystem = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   * @param {InteractionHandler} interactionHandler
   */
  function ManipulationSystem(body, canvas, selectionHandler, interactionHandler) {
    var _this = this,
        _context,
        _context2;

    _classCallCheck(this, ManipulationSystem);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.interactionHandler = interactionHandler;
    this.editMode = false;
    this.manipulationDiv = undefined;
    this.editModeDiv = undefined;
    this.closeDiv = undefined;
    this._domEventListenerCleanupQueue = [];
    this.temporaryUIFunctions = {};
    this.temporaryEventFunctions = [];
    this.touchTime = 0;
    this.temporaryIds = {
      nodes: [],
      edges: []
    };
    this.guiEnabled = false;
    this.inMode = false;
    this.selectedControlNode = undefined;
    this.options = {};
    this.defaultOptions = {
      enabled: false,
      initiallyActive: false,
      addNode: true,
      addEdge: true,
      editNode: undefined,
      editEdge: true,
      deleteNode: true,
      deleteEdge: true,
      controlNodeStyle: {
        shape: "dot",
        size: 6,
        color: {
          background: "#ff0000",
          border: "#3c3c3c",
          highlight: {
            background: "#07f968",
            border: "#3c3c3c"
          }
        },
        borderWidth: 2,
        borderWidthSelected: 2
      }
    };

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("destroy", function () {
      _this._clean();
    });
    this.body.emitter.on("_dataChanged", bind$6(_context = this._restore).call(_context, this));
    this.body.emitter.on("_resetData", bind$6(_context2 = this._restore).call(_context2, this));
  }
  /**
   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
   *
   * @private
   */


  _createClass(ManipulationSystem, [{
    key: "_restore",
    value: function _restore() {
      if (this.inMode !== false) {
        if (this.options.initiallyActive === true) {
          this.enableEditMode();
        } else {
          this.disableEditMode();
        }
      }
    }
    /**
     * Set the Options
     *
     * @param {object} options
     * @param {object} allOptions
     * @param {object} globalOptions
     */

  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions, globalOptions) {
      if (allOptions !== undefined) {
        if (allOptions.locale !== undefined) {
          this.options.locale = allOptions.locale;
        } else {
          this.options.locale = globalOptions.locale;
        }

        if (allOptions.locales !== undefined) {
          this.options.locales = allOptions.locales;
        } else {
          this.options.locales = globalOptions.locales;
        }
      }

      if (options !== undefined) {
        if (typeof options === "boolean") {
          this.options.enabled = options;
        } else {
          this.options.enabled = true;
          deepExtend(this.options, options);
        }

        if (this.options.initiallyActive === true) {
          this.editMode = true;
        }

        this._setup();
      }
    }
    /**
     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
     *
     * @private
     */

  }, {
    key: "toggleEditMode",
    value: function toggleEditMode() {
      if (this.editMode === true) {
        this.disableEditMode();
      } else {
        this.enableEditMode();
      }
    }
    /**
     * Enables Edit Mode
     */

  }, {
    key: "enableEditMode",
    value: function enableEditMode() {
      this.editMode = true;

      this._clean();

      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        this.editModeDiv.style.display = "none";
        this.showManipulatorToolbar();
      }
    }
    /**
     * Disables Edit Mode
     */

  }, {
    key: "disableEditMode",
    value: function disableEditMode() {
      this.editMode = false;

      this._clean();

      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "none";
        this.closeDiv.style.display = "none";
        this.editModeDiv.style.display = "block";

        this._createEditButton();
      }
    }
    /**
     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
     *
     * @private
     */

  }, {
    key: "showManipulatorToolbar",
    value: function showManipulatorToolbar() {
      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean(); // reset global variables


      this.manipulationDOM = {}; // if the gui is enabled, draw all elements.

      if (this.guiEnabled === true) {
        var _context3, _context4;

        // a _restore will hide these menus
        this.editMode = true;
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();
        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();
        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
        var locale = this.options.locales[this.options.locale];
        var needSeperator = false;

        if (this.options.addNode !== false) {
          this._createAddNodeButton(locale);

          needSeperator = true;
        }

        if (this.options.addEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(1);
          } else {
            needSeperator = true;
          }

          this._createAddEdgeButton(locale);
        }

        if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
          if (needSeperator === true) {
            this._createSeperator(2);
          } else {
            needSeperator = true;
          }

          this._createEditNodeButton(locale);
        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(3);
          } else {
            needSeperator = true;
          }

          this._createEditEdgeButton(locale);
        } // remove buttons


        if (selectedTotalCount !== 0) {
          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }

            this._createDeleteButton(locale);
          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }

            this._createDeleteButton(locale);
          }
        } // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context3 = this.toggleEditMode).call(_context3, this)); // refresh this bar based on what has been selected


        this._temporaryBindEvent("select", bind$6(_context4 = this.showManipulatorToolbar).call(_context4, this));
      } // redraw to show any possible changes


      this.body.emitter.emit("_redraw");
    }
    /**
     * Create the toolbar for adding Nodes
     */

  }, {
    key: "addNodeMode",
    value: function addNodeMode() {
      var _context6;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "addNode";

      if (this.guiEnabled === true) {
        var _context5;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context5 = this.toggleEditMode).call(_context5, this));
      }

      this._temporaryBindEvent("click", bind$6(_context6 = this._performAddNode).call(_context6, this));
    }
    /**
     * call the bound function to handle the editing of the node. The node has to be selected.
     */

  }, {
    key: "editNode",
    value: function editNode() {
      var _this2 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      var node = this.selectionHandler.getSelectedNodes()[0];

      if (node !== undefined) {
        this.inMode = "editNode";

        if (typeof this.options.editNode === "function") {
          if (node.isCluster !== true) {
            var data = deepExtend({}, node.options, false);
            data.x = node.x;
            data.y = node.y;

            if (this.options.editNode.length === 2) {
              this.options.editNode(data, function (finalizedData) {
                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === "editNode") {
                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                  _this2.body.data.nodes.getDataSet().update(finalizedData);
                }

                _this2.showManipulatorToolbar();
              });
            } else {
              throw new Error("The function for edit does not support two arguments (data, callback)");
            }
          } else {
            alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
          }
        } else {
          throw new Error("No function has been configured to handle the editing of nodes.");
        }
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * create the toolbar to connect nodes
     */

  }, {
    key: "addEdgeMode",
    value: function addEdgeMode() {
      var _context8, _context9, _context10, _context11, _context12;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "addEdge";

      if (this.guiEnabled === true) {
        var _context7;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context7 = this.toggleEditMode).call(_context7, this));
      } // temporarily overload functions


      this._temporaryBindUI("onTouch", bind$6(_context8 = this._handleConnect).call(_context8, this));

      this._temporaryBindUI("onDragEnd", bind$6(_context9 = this._finishConnect).call(_context9, this));

      this._temporaryBindUI("onDrag", bind$6(_context10 = this._dragControlNode).call(_context10, this));

      this._temporaryBindUI("onRelease", bind$6(_context11 = this._finishConnect).call(_context11, this));

      this._temporaryBindUI("onDragStart", bind$6(_context12 = this._dragStartEdge).call(_context12, this));

      this._temporaryBindUI("onHold", function () {});
    }
    /**
     * create the toolbar to edit edges
     */

  }, {
    key: "editEdgeMode",
    value: function editEdgeMode() {
      // when using the gui, enable edit mode if it wasn't already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "editEdge";

      if (_typeof(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];

        if (this.edgeBeingEditedId !== undefined) {
          var edge = this.body.edges[this.edgeBeingEditedId];

          this._performEditEdge(edge.from.id, edge.to.id);

          return;
        }
      }

      if (this.guiEnabled === true) {
        var _context13;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context13 = this.toggleEditMode).call(_context13, this));
      }

      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];

      if (this.edgeBeingEditedId !== undefined) {
        var _context14, _context15, _context16, _context17;

        var _edge = this.body.edges[this.edgeBeingEditedId]; // create control nodes

        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);

        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);

        this.temporaryIds.nodes.push(controlNodeFrom.id);
        this.temporaryIds.nodes.push(controlNodeTo.id);
        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
        this.body.nodeIndices.push(controlNodeFrom.id);
        this.body.nodes[controlNodeTo.id] = controlNodeTo;
        this.body.nodeIndices.push(controlNodeTo.id); // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI

        this._temporaryBindUI("onTouch", bind$6(_context14 = this._controlNodeTouch).call(_context14, this)); // used to get the position


        this._temporaryBindUI("onTap", function () {}); // disabled


        this._temporaryBindUI("onHold", function () {}); // disabled


        this._temporaryBindUI("onDragStart", bind$6(_context15 = this._controlNodeDragStart).call(_context15, this)); // used to select control node


        this._temporaryBindUI("onDrag", bind$6(_context16 = this._controlNodeDrag).call(_context16, this)); // used to drag control node


        this._temporaryBindUI("onDragEnd", bind$6(_context17 = this._controlNodeDragEnd).call(_context17, this)); // used to connect or revert control nodes


        this._temporaryBindUI("onMouseMove", function () {}); // disabled
        // create function to position control nodes correctly on movement
        // automatically cleaned up because we use the temporary bind


        this._temporaryBindEvent("beforeDrawing", function (ctx) {
          var positions = _edge.edgeType.findBorderPositions(ctx);

          if (controlNodeFrom.selected === false) {
            controlNodeFrom.x = positions.from.x;
            controlNodeFrom.y = positions.from.y;
          }

          if (controlNodeTo.selected === false) {
            controlNodeTo.x = positions.to.x;
            controlNodeTo.y = positions.to.y;
          }
        });

        this.body.emitter.emit("_redraw");
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * delete everything in the selection
     */

  }, {
    key: "deleteSelected",
    value: function deleteSelected() {
      var _this3 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "delete";
      var selectedNodes = this.selectionHandler.getSelectedNodeIds();
      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();
      var deleteFunction = undefined;

      if (selectedNodes.length > 0) {
        for (var i = 0; i < selectedNodes.length; i++) {
          if (this.body.nodes[selectedNodes[i]].isCluster === true) {
            alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
            return;
          }
        }

        if (typeof this.options.deleteNode === "function") {
          deleteFunction = this.options.deleteNode;
        }
      } else if (selectedEdges.length > 0) {
        if (typeof this.options.deleteEdge === "function") {
          deleteFunction = this.options.deleteEdge;
        }
      }

      if (typeof deleteFunction === "function") {
        var data = {
          nodes: selectedNodes,
          edges: selectedEdges
        };

        if (deleteFunction.length === 2) {
          deleteFunction(data, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === "delete") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);

              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);

              _this3.body.emitter.emit("startSimulation");

              _this3.showManipulatorToolbar();
            } else {
              _this3.body.emitter.emit("startSimulation");

              _this3.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for delete does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().remove(selectedEdges);
        this.body.data.nodes.getDataSet().remove(selectedNodes);
        this.body.emitter.emit("startSimulation");
        this.showManipulatorToolbar();
      }
    } //********************************************** PRIVATE ***************************************//

    /**
     * draw or remove the DOM
     *
     * @private
     */

  }, {
    key: "_setup",
    value: function _setup() {
      if (this.options.enabled === true) {
        // Enable the GUI
        this.guiEnabled = true;

        this._createWrappers();

        if (this.editMode === false) {
          this._createEditButton();
        } else {
          this.showManipulatorToolbar();
        }
      } else {
        this._removeManipulationDOM(); // disable the gui


        this.guiEnabled = false;
      }
    }
    /**
     * create the div overlays that contain the DOM
     *
     * @private
     */

  }, {
    key: "_createWrappers",
    value: function _createWrappers() {
      // load the manipulator HTML elements. All styling done in css.
      if (this.manipulationDiv === undefined) {
        this.manipulationDiv = document.createElement("div");
        this.manipulationDiv.className = "vis-manipulation";

        if (this.editMode === true) {
          this.manipulationDiv.style.display = "block";
        } else {
          this.manipulationDiv.style.display = "none";
        }

        this.canvas.frame.appendChild(this.manipulationDiv);
      } // container for the edit button.


      if (this.editModeDiv === undefined) {
        this.editModeDiv = document.createElement("div");
        this.editModeDiv.className = "vis-edit-mode";

        if (this.editMode === true) {
          this.editModeDiv.style.display = "none";
        } else {
          this.editModeDiv.style.display = "block";
        }

        this.canvas.frame.appendChild(this.editModeDiv);
      } // container for the close div button


      if (this.closeDiv === undefined) {
        var _this$options$locales, _this$options$locales2;

        this.closeDiv = document.createElement("button");
        this.closeDiv.className = "vis-close";
        this.closeDiv.setAttribute("aria-label", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2["close"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales["en"]["close"]);
        this.closeDiv.style.display = this.manipulationDiv.style.display;
        this.canvas.frame.appendChild(this.closeDiv);
      }
    }
    /**
     * generate a new target node. Used for creating new edges and editing edges
     *
     * @param {number} x
     * @param {number} y
     * @returns {Node}
     * @private
     */

  }, {
    key: "_getNewTargetNode",
    value: function _getNewTargetNode(x, y) {
      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);
      controlNodeStyle.id = "targetNode" + v4();
      controlNodeStyle.hidden = false;
      controlNodeStyle.physics = false;
      controlNodeStyle.x = x;
      controlNodeStyle.y = y; // we have to define the bounding box in order for the nodes to be drawn immediately

      var node = this.body.functions.createNode(controlNodeStyle);
      node.shape.boundingBox = {
        left: x,
        right: x,
        top: y,
        bottom: y
      };
      return node;
    }
    /**
     * Create the edit button
     */

  }, {
    key: "_createEditButton",
    value: function _createEditButton() {
      var _context18;

      // restore everything to it's original state (if applicable)
      this._clean(); // reset the manipulationDOM


      this.manipulationDOM = {}; // empty the editModeDiv

      recursiveDOMDelete(this.editModeDiv); // create the contents for the editMode button

      var locale = this.options.locales[this.options.locale];

      var button = this._createButton("editMode", "vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);

      this.editModeDiv.appendChild(button); // bind a hammer listener to the button, calling the function toggleEditMode.

      this._bindElementEvents(button, bind$6(_context18 = this.toggleEditMode).call(_context18, this));
    }
    /**
     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
     *
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      // not in mode
      this.inMode = false; // _clean the divs

      if (this.guiEnabled === true) {
        recursiveDOMDelete(this.editModeDiv);
        recursiveDOMDelete(this.manipulationDiv); // removes all the bindings and overloads

        this._cleanupDOMEventListeners();
      } // remove temporary nodes and edges


      this._cleanupTemporaryNodesAndEdges(); // restore overloaded UI functions


      this._unbindTemporaryUIs(); // remove the temporaryEventFunctions


      this._unbindTemporaryEvents(); // restore the physics if required


      this.body.emitter.emit("restorePhysics");
    }
    /**
     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
     *
     * @private
     */

  }, {
    key: "_cleanupDOMEventListeners",
    value: function _cleanupDOMEventListeners() {
      var _context19;

      // _clean DOM event listener bindings
      var _iterator = _createForOfIteratorHelper(splice$1(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var callback = _step.value;
          callback();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Remove all DOM elements created by this module.
     *
     * @private
     */

  }, {
    key: "_removeManipulationDOM",
    value: function _removeManipulationDOM() {
      // removes all the bindings and overloads
      this._clean(); // empty the manipulation divs


      recursiveDOMDelete(this.manipulationDiv);
      recursiveDOMDelete(this.editModeDiv);
      recursiveDOMDelete(this.closeDiv); // remove the manipulation divs

      if (this.manipulationDiv) {
        this.canvas.frame.removeChild(this.manipulationDiv);
      }

      if (this.editModeDiv) {
        this.canvas.frame.removeChild(this.editModeDiv);
      }

      if (this.closeDiv) {
        this.canvas.frame.removeChild(this.closeDiv);
      } // set the references to undefined


      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;
    }
    /**
     * create a seperator line. the index is to differentiate in the manipulation dom
     *
     * @param {number} [index=1]
     * @private
     */

  }, {
    key: "_createSeperator",
    value: function _createSeperator() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.manipulationDOM["seperatorLineDiv" + index] = document.createElement("div");
      this.manipulationDOM["seperatorLineDiv" + index].className = "vis-separator-line";
      this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index]);
    } // ----------------------    DOM functions for buttons    --------------------------//

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createAddNodeButton",
    value: function _createAddNodeButton(locale) {
      var _context20;

      var button = this._createButton("addNode", "vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context20 = this.addNodeMode).call(_context20, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createAddEdgeButton",
    value: function _createAddEdgeButton(locale) {
      var _context21;

      var button = this._createButton("addEdge", "vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context21 = this.addEdgeMode).call(_context21, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createEditNodeButton",
    value: function _createEditNodeButton(locale) {
      var _context22;

      var button = this._createButton("editNode", "vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context22 = this.editNode).call(_context22, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createEditEdgeButton",
    value: function _createEditEdgeButton(locale) {
      var _context23;

      var button = this._createButton("editEdge", "vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context23 = this.editEdgeMode).call(_context23, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createDeleteButton",
    value: function _createDeleteButton(locale) {
      var _context24;

      var deleteBtnClass;

      if (this.options.rtl) {
        deleteBtnClass = "vis-delete-rtl";
      } else {
        deleteBtnClass = "vis-delete";
      }

      var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context24 = this.deleteSelected).call(_context24, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createBackButton",
    value: function _createBackButton(locale) {
      var _context25;

      var button = this._createButton("back", "vis-back", locale["back"] || this.options.locales["en"]["back"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context25 = this.showManipulatorToolbar).call(_context25, this));
    }
    /**
     *
     * @param {number|string} id
     * @param {string} className
     * @param {label} label
     * @param {string} labelClassName
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_createButton",
    value: function _createButton(id, className, label) {
      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "vis-label";
      this.manipulationDOM[id + "Div"] = document.createElement("button");
      this.manipulationDOM[id + "Div"].className = "vis-button " + className;
      this.manipulationDOM[id + "Label"] = document.createElement("div");
      this.manipulationDOM[id + "Label"].className = labelClassName;
      this.manipulationDOM[id + "Label"].innerText = label;
      this.manipulationDOM[id + "Div"].appendChild(this.manipulationDOM[id + "Label"]);
      return this.manipulationDOM[id + "Div"];
    }
    /**
     *
     * @param {Label} label
     * @private
     */

  }, {
    key: "_createDescription",
    value: function _createDescription(label) {
      this.manipulationDOM["descriptionLabel"] = document.createElement("div");
      this.manipulationDOM["descriptionLabel"].className = "vis-none";
      this.manipulationDOM["descriptionLabel"].innerText = label;
      this.manipulationDiv.appendChild(this.manipulationDOM["descriptionLabel"]);
    } // -------------------------- End of DOM functions for buttons ------------------------------//

    /**
     * this binds an event until cleanup by the clean functions.
     *
     * @param {Event}  event   The event
     * @param {Function} newFunction
     * @private
     */

  }, {
    key: "_temporaryBindEvent",
    value: function _temporaryBindEvent(event, newFunction) {
      this.temporaryEventFunctions.push({
        event: event,
        boundFunction: newFunction
      });
      this.body.emitter.on(event, newFunction);
    }
    /**
     * this overrides an UI function until cleanup by the clean function
     *
     * @param {string} UIfunctionName
     * @param {Function} newFunction
     * @private
     */

  }, {
    key: "_temporaryBindUI",
    value: function _temporaryBindUI(UIfunctionName, newFunction) {
      if (this.body.eventListeners[UIfunctionName] !== undefined) {
        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
        this.body.eventListeners[UIfunctionName] = newFunction;
      } else {
        throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + stringify$1(keys$4(this.body.eventListeners)));
      }
    }
    /**
     * Restore the overridden UI functions to their original state.
     *
     * @private
     */

  }, {
    key: "_unbindTemporaryUIs",
    value: function _unbindTemporaryUIs() {
      for (var functionName in this.temporaryUIFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {
          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
          delete this.temporaryUIFunctions[functionName];
        }
      }

      this.temporaryUIFunctions = {};
    }
    /**
     * Unbind the events created by _temporaryBindEvent
     *
     * @private
     */

  }, {
    key: "_unbindTemporaryEvents",
    value: function _unbindTemporaryEvents() {
      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
        var eventName = this.temporaryEventFunctions[i].event;
        var boundFunction = this.temporaryEventFunctions[i].boundFunction;
        this.body.emitter.off(eventName, boundFunction);
      }

      this.temporaryEventFunctions = [];
    }
    /**
     * Bind an hammer instance to a DOM element.
     *
     * @param {Element} domElement
     * @param {Function} boundFunction
     */

  }, {
    key: "_bindElementEvents",
    value: function _bindElementEvents(domElement, boundFunction) {
      // Bind touch events.
      var hammer = new Hammer(domElement, {});
      onTouch(hammer, boundFunction);

      this._domEventListenerCleanupQueue.push(function () {
        hammer.destroy();
      }); // Bind keyboard events.


      var keyupListener = function keyupListener(_ref) {
        var keyCode = _ref.keyCode,
            key = _ref.key;

        if (key === "Enter" || key === " " || keyCode === 13 || keyCode === 32) {
          boundFunction();
        }
      };

      domElement.addEventListener("keyup", keyupListener, false);

      this._domEventListenerCleanupQueue.push(function () {
        domElement.removeEventListener("keyup", keyupListener, false);
      });
    }
    /**
     * Neatly clean up temporary edges and nodes
     *
     * @private
     */

  }, {
    key: "_cleanupTemporaryNodesAndEdges",
    value: function _cleanupTemporaryNodesAndEdges() {
      // _clean temporary edges
      for (var i = 0; i < this.temporaryIds.edges.length; i++) {
        var _context26;

        this.body.edges[this.temporaryIds.edges[i]].disconnect();
        delete this.body.edges[this.temporaryIds.edges[i]];

        var indexTempEdge = indexOf(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);

        if (indexTempEdge !== -1) {
          var _context27;

          splice$1(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);
        }
      } // _clean temporary nodes


      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
        var _context28;

        delete this.body.nodes[this.temporaryIds.nodes[_i]];

        var indexTempNode = indexOf(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);

        if (indexTempNode !== -1) {
          var _context29;

          splice$1(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);
        }
      }

      this.temporaryIds = {
        nodes: [],
        edges: []
      };
    } // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

    /**
     * the touch is used to get the position of the initial click
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeTouch",
    value: function _controlNodeTouch(event) {
      this.selectionHandler.unselectAll();
      this.lastTouch = this.body.functions.getPointer(event.center);
      this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object
    }
    /**
     * the drag start is used to mark one of the control nodes as selected.
     *
     * @private
     */

  }, {
    key: "_controlNodeDragStart",
    value: function _controlNodeDragStart() {
      var pointer = this.lastTouch;

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var from = this.body.nodes[this.temporaryIds.nodes[0]];
      var to = this.body.nodes[this.temporaryIds.nodes[1]];
      var edge = this.body.edges[this.edgeBeingEditedId];
      this.selectedControlNode = undefined;
      var fromSelect = from.isOverlappingWith(pointerObj);
      var toSelect = to.isOverlappingWith(pointerObj);

      if (fromSelect === true) {
        this.selectedControlNode = from;
        edge.edgeType.from = from;
      } else if (toSelect === true) {
        this.selectedControlNode = to;
        edge.edgeType.to = to;
      } // we use the selection to find the node that is being dragged. We explicitly select it here.


      if (this.selectedControlNode !== undefined) {
        this.selectionHandler.selectObject(this.selectedControlNode);
      }

      this.body.emitter.emit("_redraw");
    }
    /**
     * dragging the control nodes or the canvas
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeDrag",
    value: function _controlNodeDrag(event) {
      this.body.emitter.emit("disablePhysics");
      var pointer = this.body.functions.getPointer(event.center);
      var pos = this.canvas.DOMtoCanvas(pointer);

      if (this.selectedControlNode !== undefined) {
        this.selectedControlNode.x = pos.x;
        this.selectedControlNode.y = pos.y;
      } else {
        this.interactionHandler.onDrag(event);
      }

      this.body.emitter.emit("_redraw");
    }
    /**
     * connecting or restoring the control nodes.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeDragEnd",
    value: function _controlNodeDragEnd(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var edge = this.body.edges[this.edgeBeingEditedId]; // if the node that was dragged is not a control node, return

      if (this.selectedControlNode === undefined) {
        return;
      } // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.


      this.selectionHandler.unselectAll();

      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      } // perform the connection


      if (node !== undefined && this.selectedControlNode !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          var from = this.body.nodes[this.temporaryIds.nodes[0]];

          if (this.selectedControlNode.id === from.id) {
            this._performEditEdge(node.id, edge.to.id);
          } else {
            this._performEditEdge(edge.from.id, node.id);
          }
        }
      } else {
        edge.updateEdgeType();
        this.body.emitter.emit("restorePhysics");
      }

      this.body.emitter.emit("_redraw");
    } // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//

    /**
     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
     * to walk the user through the process.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_handleConnect",
    value: function _handleConnect(event) {
      // check to avoid double fireing of this function.
      if (new Date().valueOf() - this.touchTime > 100) {
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object

        this.interactionHandler.drag.pointer = this.lastTouch; // Drag pointer is not updated when adding edges

        this.interactionHandler.drag.translation = this.lastTouch.translation;
        var pointer = this.lastTouch;
        var node = this.selectionHandler.getNodeAt(pointer);

        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
          } else {
            // create a node the temporary line can look at
            var targetNode = this._getNewTargetNode(node.x, node.y);

            this.body.nodes[targetNode.id] = targetNode;
            this.body.nodeIndices.push(targetNode.id); // create a temporary edge

            var connectionEdge = this.body.functions.createEdge({
              id: "connectionEdge" + v4(),
              from: node.id,
              to: targetNode.id,
              physics: false,
              smooth: {
                enabled: true,
                type: "continuous",
                roundness: 0.5
              }
            });
            this.body.edges[connectionEdge.id] = connectionEdge;
            this.body.edgeIndices.push(connectionEdge.id);
            this.temporaryIds.nodes.push(targetNode.id);
            this.temporaryIds.edges.push(connectionEdge.id);
          }
        }

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_dragControlNode",
    value: function _dragControlNode(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id


      var connectFromId = undefined;

      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      } // get the overlapping node but NOT the temporary node;


      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context30;

        // if the node id is NOT a temporary node, accept the node.
        if (indexOf(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }

      event.controlEdge = {
        from: connectFromId,
        to: node ? node.id : undefined
      };
      this.selectionHandler.generateClickEvent("controlNodeDragging", event, pointer);

      if (this.temporaryIds.nodes[0] !== undefined) {
        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.

        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        this.body.emitter.emit("_redraw");
      } else {
        this.interactionHandler.onDrag(event);
      }
    }
    /**
     * Connect the new edge to the target if one exists, otherwise remove temp line
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_finishConnect",
    value: function _finishConnect(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id


      var connectFromId = undefined;

      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      } // get the overlapping node but NOT the temporary node;


      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context31;

        // if the node id is NOT a temporary node, accept the node.
        if (indexOf(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      } // clean temporary nodes and edges.


      this._cleanupTemporaryNodesAndEdges(); // perform the connection


      if (node !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
            this._performAddEdge(connectFromId, node.id);
          }
        }
      }

      event.controlEdge = {
        from: connectFromId,
        to: node ? node.id : undefined
      };
      this.selectionHandler.generateClickEvent("controlNodeDragEnd", event, pointer); // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.

      this.body.emitter.emit("_redraw");
    }
    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_dragStartEdge",
    value: function _dragStartEdge(event) {
      var pointer = this.lastTouch;
      this.selectionHandler.generateClickEvent("dragStart", event, pointer, undefined, true);
    } // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
    // ------------------------------ Performing all the actual data manipulation ------------------------//

    /**
     * Adds a node on the specified location
     *
     * @param {object} clickData
     * @private
     */

  }, {
    key: "_performAddNode",
    value: function _performAddNode(clickData) {
      var _this4 = this;

      var defaultData = {
        id: v4(),
        x: clickData.pointer.canvas.x,
        y: clickData.pointer.canvas.y,
        label: "new"
      };

      if (typeof this.options.addNode === "function") {
        if (this.options.addNode.length === 2) {
          this.options.addNode(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === "addNode") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this4.body.data.nodes.getDataSet().add(finalizedData);
            }

            _this4.showManipulatorToolbar();
          });
        } else {
          this.showManipulatorToolbar();
          throw new Error("The function for add does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.nodes.getDataSet().add(defaultData);
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: "_performAddEdge",
    value: function _performAddEdge(sourceNodeId, targetNodeId) {
      var _this5 = this;

      var defaultData = {
        from: sourceNodeId,
        to: targetNodeId
      };

      if (typeof this.options.addEdge === "function") {
        if (this.options.addEdge.length === 2) {
          this.options.addEdge(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === "addEdge") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this5.body.data.edges.getDataSet().add(finalizedData);

              _this5.selectionHandler.unselectAll();

              _this5.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for connect does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.edges.getDataSet().add(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: "_performEditEdge",
    value: function _performEditEdge(sourceNodeId, targetNodeId) {
      var _this6 = this;

      var defaultData = {
        id: this.edgeBeingEditedId,
        from: sourceNodeId,
        to: targetNodeId,
        label: this.body.data.edges.get(this.edgeBeingEditedId).label
      };
      var eeFunct = this.options.editEdge;

      if (_typeof(eeFunct) === "object") {
        eeFunct = eeFunct.editWithoutDrag;
      }

      if (typeof eeFunct === "function") {
        if (eeFunct.length === 2) {
          eeFunct(defaultData, function (finalizedData) {
            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== "editEdge") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this6.body.edges[defaultData.id].updateEdgeType();

              _this6.body.emitter.emit("_redraw");

              _this6.showManipulatorToolbar();
            } else {
              _this6.body.data.edges.getDataSet().update(finalizedData);

              _this6.selectionHandler.unselectAll();

              _this6.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for edit does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().update(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
  }]);

  return ManipulationSystem;
}();

/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
var string = "string";
var bool = "boolean";
var number = "number";
var array = "array";
var object = "object"; // should only be in a __type__ property

var dom = "dom";
var any = "any"; // List of endpoints

var endPoints = ["arrow", "bar", "box", "circle", "crow", "curve", "diamond", "image", "inv_curve", "inv_triangle", "triangle", "vee"];
/* eslint-disable @typescript-eslint/naming-convention -- The __*__ format is used to prevent collisions with actual option names. */

var nodeOptions = {
  borderWidth: {
    number: number
  },
  borderWidthSelected: {
    number: number,
    undefined: "undefined"
  },
  brokenImage: {
    string: string,
    undefined: "undefined"
  },
  chosen: {
    label: {
      boolean: bool,
      function: "function"
    },
    node: {
      boolean: bool,
      function: "function"
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  color: {
    border: {
      string: string
    },
    background: {
      string: string
    },
    highlight: {
      border: {
        string: string
      },
      background: {
        string: string
      },
      __type__: {
        object: object,
        string: string
      }
    },
    hover: {
      border: {
        string: string
      },
      background: {
        string: string
      },
      __type__: {
        object: object,
        string: string
      }
    },
    __type__: {
      object: object,
      string: string
    }
  },
  opacity: {
    number: number,
    undefined: "undefined"
  },
  fixed: {
    x: {
      boolean: bool
    },
    y: {
      boolean: bool
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  font: {
    align: {
      string: string
    },
    color: {
      string: string
    },
    size: {
      number: number
    },
    face: {
      string: string
    },
    background: {
      string: string
    },
    strokeWidth: {
      number: number
    },
    strokeColor: {
      string: string
    },
    vadjust: {
      number: number
    },
    multi: {
      boolean: bool,
      string: string
    },
    bold: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    boldital: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    ital: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    mono: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    __type__: {
      object: object,
      string: string
    }
  },
  group: {
    string: string,
    number: number,
    undefined: "undefined"
  },
  heightConstraint: {
    minimum: {
      number: number
    },
    valign: {
      string: string
    },
    __type__: {
      object: object,
      boolean: bool,
      number: number
    }
  },
  hidden: {
    boolean: bool
  },
  icon: {
    face: {
      string: string
    },
    code: {
      string: string
    },
    size: {
      number: number
    },
    color: {
      string: string
    },
    weight: {
      string: string,
      number: number
    },
    __type__: {
      object: object
    }
  },
  id: {
    string: string,
    number: number
  },
  image: {
    selected: {
      string: string,
      undefined: "undefined"
    },
    unselected: {
      string: string,
      undefined: "undefined"
    },
    __type__: {
      object: object,
      string: string
    }
  },
  imagePadding: {
    top: {
      number: number
    },
    right: {
      number: number
    },
    bottom: {
      number: number
    },
    left: {
      number: number
    },
    __type__: {
      object: object,
      number: number
    }
  },
  label: {
    string: string,
    undefined: "undefined"
  },
  labelHighlightBold: {
    boolean: bool
  },
  level: {
    number: number,
    undefined: "undefined"
  },
  margin: {
    top: {
      number: number
    },
    right: {
      number: number
    },
    bottom: {
      number: number
    },
    left: {
      number: number
    },
    __type__: {
      object: object,
      number: number
    }
  },
  mass: {
    number: number
  },
  physics: {
    boolean: bool
  },
  scaling: {
    min: {
      number: number
    },
    max: {
      number: number
    },
    label: {
      enabled: {
        boolean: bool
      },
      min: {
        number: number
      },
      max: {
        number: number
      },
      maxVisible: {
        number: number
      },
      drawThreshold: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    customScalingFunction: {
      function: "function"
    },
    __type__: {
      object: object
    }
  },
  shadow: {
    enabled: {
      boolean: bool
    },
    color: {
      string: string
    },
    size: {
      number: number
    },
    x: {
      number: number
    },
    y: {
      number: number
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  shape: {
    string: ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
  },
  ctxRenderer: {
    function: "function"
  },
  shapeProperties: {
    borderDashes: {
      boolean: bool,
      array: array
    },
    borderRadius: {
      number: number
    },
    interpolation: {
      boolean: bool
    },
    useImageSize: {
      boolean: bool
    },
    useBorderWithImage: {
      boolean: bool
    },
    coordinateOrigin: {
      string: ["center", "top-left"]
    },
    __type__: {
      object: object
    }
  },
  size: {
    number: number
  },
  title: {
    string: string,
    dom: dom,
    undefined: "undefined"
  },
  value: {
    number: number,
    undefined: "undefined"
  },
  widthConstraint: {
    minimum: {
      number: number
    },
    maximum: {
      number: number
    },
    __type__: {
      object: object,
      boolean: bool,
      number: number
    }
  },
  x: {
    number: number
  },
  y: {
    number: number
  },
  __type__: {
    object: object
  }
};
var allOptions = {
  configure: {
    enabled: {
      boolean: bool
    },
    filter: {
      boolean: bool,
      string: string,
      array: array,
      function: "function"
    },
    container: {
      dom: dom
    },
    showButton: {
      boolean: bool
    },
    __type__: {
      object: object,
      boolean: bool,
      string: string,
      array: array,
      function: "function"
    }
  },
  edges: {
    arrows: {
      to: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageHeight: {
          number: number
        },
        imageWidth: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      middle: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number: number
        },
        imageHeight: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      from: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number: number
        },
        imageHeight: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      __type__: {
        string: ["from", "to", "middle"],
        object: object
      }
    },
    endPointOffset: {
      from: {
        number: number
      },
      to: {
        number: number
      },
      __type__: {
        object: object,
        number: number
      }
    },
    arrowStrikethrough: {
      boolean: bool
    },
    background: {
      enabled: {
        boolean: bool
      },
      color: {
        string: string
      },
      size: {
        number: number
      },
      dashes: {
        boolean: bool,
        array: array
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    chosen: {
      label: {
        boolean: bool,
        function: "function"
      },
      edge: {
        boolean: bool,
        function: "function"
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    color: {
      color: {
        string: string
      },
      highlight: {
        string: string
      },
      hover: {
        string: string
      },
      inherit: {
        string: ["from", "to", "both"],
        boolean: bool
      },
      opacity: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    dashes: {
      boolean: bool,
      array: array
    },
    font: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      background: {
        string: string
      },
      strokeWidth: {
        number: number
      },
      strokeColor: {
        string: string
      },
      align: {
        string: ["horizontal", "top", "middle", "bottom"]
      },
      vadjust: {
        number: number
      },
      multi: {
        boolean: bool,
        string: string
      },
      bold: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      boldital: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      ital: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      mono: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      __type__: {
        object: object,
        string: string
      }
    },
    hidden: {
      boolean: bool
    },
    hoverWidth: {
      function: "function",
      number: number
    },
    label: {
      string: string,
      undefined: "undefined"
    },
    labelHighlightBold: {
      boolean: bool
    },
    length: {
      number: number,
      undefined: "undefined"
    },
    physics: {
      boolean: bool
    },
    scaling: {
      min: {
        number: number
      },
      max: {
        number: number
      },
      label: {
        enabled: {
          boolean: bool
        },
        min: {
          number: number
        },
        max: {
          number: number
        },
        maxVisible: {
          number: number
        },
        drawThreshold: {
          number: number
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      customScalingFunction: {
        function: "function"
      },
      __type__: {
        object: object
      }
    },
    selectionWidth: {
      function: "function",
      number: number
    },
    selfReferenceSize: {
      number: number
    },
    selfReference: {
      size: {
        number: number
      },
      angle: {
        number: number
      },
      renderBehindTheNode: {
        boolean: bool
      },
      __type__: {
        object: object
      }
    },
    shadow: {
      enabled: {
        boolean: bool
      },
      color: {
        string: string
      },
      size: {
        number: number
      },
      x: {
        number: number
      },
      y: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    smooth: {
      enabled: {
        boolean: bool
      },
      type: {
        string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
      },
      roundness: {
        number: number
      },
      forceDirection: {
        string: ["horizontal", "vertical", "none"],
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    title: {
      string: string,
      undefined: "undefined"
    },
    width: {
      number: number
    },
    widthConstraint: {
      maximum: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool,
        number: number
      }
    },
    value: {
      number: number,
      undefined: "undefined"
    },
    __type__: {
      object: object
    }
  },
  groups: {
    useDefaultGroups: {
      boolean: bool
    },
    __any__: nodeOptions,
    __type__: {
      object: object
    }
  },
  interaction: {
    dragNodes: {
      boolean: bool
    },
    dragView: {
      boolean: bool
    },
    hideEdgesOnDrag: {
      boolean: bool
    },
    hideEdgesOnZoom: {
      boolean: bool
    },
    hideNodesOnDrag: {
      boolean: bool
    },
    hover: {
      boolean: bool
    },
    keyboard: {
      enabled: {
        boolean: bool
      },
      speed: {
        x: {
          number: number
        },
        y: {
          number: number
        },
        zoom: {
          number: number
        },
        __type__: {
          object: object
        }
      },
      bindToWindow: {
        boolean: bool
      },
      autoFocus: {
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    multiselect: {
      boolean: bool
    },
    navigationButtons: {
      boolean: bool
    },
    selectable: {
      boolean: bool
    },
    selectConnectedEdges: {
      boolean: bool
    },
    hoverConnectedEdges: {
      boolean: bool
    },
    tooltipDelay: {
      number: number
    },
    zoomView: {
      boolean: bool
    },
    zoomSpeed: {
      number: number
    },
    __type__: {
      object: object
    }
  },
  layout: {
    randomSeed: {
      undefined: "undefined",
      number: number,
      string: string
    },
    improvedLayout: {
      boolean: bool
    },
    clusterThreshold: {
      number: number
    },
    hierarchical: {
      enabled: {
        boolean: bool
      },
      levelSeparation: {
        number: number
      },
      nodeSpacing: {
        number: number
      },
      treeSpacing: {
        number: number
      },
      blockShifting: {
        boolean: bool
      },
      edgeMinimization: {
        boolean: bool
      },
      parentCentralization: {
        boolean: bool
      },
      direction: {
        string: ["UD", "DU", "LR", "RL"]
      },
      sortMethod: {
        string: ["hubsize", "directed"]
      },
      shakeTowards: {
        string: ["leaves", "roots"]
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    __type__: {
      object: object
    }
  },
  manipulation: {
    enabled: {
      boolean: bool
    },
    initiallyActive: {
      boolean: bool
    },
    addNode: {
      boolean: bool,
      function: "function"
    },
    addEdge: {
      boolean: bool,
      function: "function"
    },
    editNode: {
      function: "function"
    },
    editEdge: {
      editWithoutDrag: {
        function: "function"
      },
      __type__: {
        object: object,
        boolean: bool,
        function: "function"
      }
    },
    deleteNode: {
      boolean: bool,
      function: "function"
    },
    deleteEdge: {
      boolean: bool,
      function: "function"
    },
    controlNodeStyle: nodeOptions,
    __type__: {
      object: object,
      boolean: bool
    }
  },
  nodes: nodeOptions,
  physics: {
    enabled: {
      boolean: bool
    },
    barnesHut: {
      theta: {
        number: number
      },
      gravitationalConstant: {
        number: number
      },
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    forceAtlas2Based: {
      theta: {
        number: number
      },
      gravitationalConstant: {
        number: number
      },
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    repulsion: {
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      nodeDistance: {
        number: number
      },
      damping: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    hierarchicalRepulsion: {
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      nodeDistance: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    maxVelocity: {
      number: number
    },
    minVelocity: {
      number: number
    },
    solver: {
      string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
    },
    stabilization: {
      enabled: {
        boolean: bool
      },
      iterations: {
        number: number
      },
      updateInterval: {
        number: number
      },
      onlyDynamicEdges: {
        boolean: bool
      },
      fit: {
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    timestep: {
      number: number
    },
    adaptiveTimestep: {
      boolean: bool
    },
    wind: {
      x: {
        number: number
      },
      y: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  //globals :
  autoResize: {
    boolean: bool
  },
  clickToUse: {
    boolean: bool
  },
  locale: {
    string: string
  },
  locales: {
    __any__: {
      any: any
    },
    __type__: {
      object: object
    }
  },
  height: {
    string: string
  },
  width: {
    string: string
  },
  __type__: {
    object: object
  }
};
/* eslint-enable @typescript-eslint/naming-convention */

/**
 * This provides ranges, initial values, steps and dropdown menu choices for the
 * configuration.
 *
 * @remarks
 * Checkbox: `boolean`
 *   The value supllied will be used as the initial value.
 *
 * Text field: `string`
 *   The passed text will be used as the initial value. Any text will be
 *   accepted afterwards.
 *
 * Number range: `[number, number, number, number]`
 *   The meanings are `[initial value, min, max, step]`.
 *
 * Dropdown: `[Exclude<string, "color">, ...(string | number | boolean)[]]`
 *   Translations for people with poor understanding of TypeScript: the first
 *   value always has to be a string but never `"color"`, the rest can be any
 *   combination of strings, numbers and booleans.
 *
 * Color picker: `["color", string]`
 *   The first value says this will be a color picker not a dropdown menu. The
 *   next value is the initial color.
 */

var configureOptions = {
  nodes: {
    borderWidth: [1, 0, 10, 1],
    borderWidthSelected: [2, 0, 10, 1],
    color: {
      border: ["color", "#2B7CE9"],
      background: ["color", "#97C2FC"],
      highlight: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      },
      hover: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      }
    },
    opacity: [0, 0, 1, 0.1],
    fixed: {
      x: false,
      y: false
    },
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [0, 0, 50, 1],
      strokeColor: ["color", "#ffffff"]
    },
    //group: 'string',
    hidden: false,
    labelHighlightBold: true,
    //icon: {
    //  face: 'string',  //'FontAwesome',
    //  code: 'string',  //'\uf007',
    //  size: [50, 0, 200, 1],  //50,
    //  color: ['color','#2B7CE9']   //'#aa00ff'
    //},
    //image: 'string', // --> URL
    physics: true,
    scaling: {
      min: [10, 0, 200, 1],
      max: [30, 0, 200, 1],
      label: {
        enabled: false,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
    shapeProperties: {
      borderDashes: false,
      borderRadius: [6, 0, 20, 1],
      interpolation: true,
      useImageSize: false
    },
    size: [25, 0, 200, 1]
  },
  edges: {
    arrows: {
      to: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      middle: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      from: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      }
    },
    endPointOffset: {
      from: [0, -10, 10, 1],
      to: [0, -10, 10, 1]
    },
    arrowStrikethrough: true,
    color: {
      color: ["color", "#848484"],
      highlight: ["color", "#848484"],
      hover: ["color", "#848484"],
      inherit: ["from", "to", "both", true, false],
      opacity: [1, 0, 1, 0.05]
    },
    dashes: false,
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [2, 0, 50, 1],
      strokeColor: ["color", "#ffffff"],
      align: ["horizontal", "top", "middle", "bottom"]
    },
    hidden: false,
    hoverWidth: [1.5, 0, 5, 0.1],
    labelHighlightBold: true,
    physics: true,
    scaling: {
      min: [1, 0, 100, 1],
      max: [15, 0, 100, 1],
      label: {
        enabled: true,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    selectionWidth: [1.5, 0, 5, 0.1],
    selfReferenceSize: [20, 0, 200, 1],
    selfReference: {
      size: [20, 0, 200, 1],
      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],
      renderBehindTheNode: true
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    smooth: {
      enabled: true,
      type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
      forceDirection: ["horizontal", "vertical", "none"],
      roundness: [0.5, 0, 1, 0.05]
    },
    width: [1, 0, 30, 1]
  },
  layout: {
    //randomSeed: [0, 0, 500, 1],
    //improvedLayout: true,
    hierarchical: {
      enabled: false,
      levelSeparation: [150, 20, 500, 5],
      nodeSpacing: [100, 20, 500, 5],
      treeSpacing: [200, 20, 500, 5],
      blockShifting: true,
      edgeMinimization: true,
      parentCentralization: true,
      direction: ["UD", "DU", "LR", "RL"],
      sortMethod: ["hubsize", "directed"],
      shakeTowards: ["leaves", "roots"] // leaves, roots

    }
  },
  interaction: {
    dragNodes: true,
    dragView: true,
    hideEdgesOnDrag: false,
    hideEdgesOnZoom: false,
    hideNodesOnDrag: false,
    hover: false,
    keyboard: {
      enabled: false,
      speed: {
        x: [10, 0, 40, 1],
        y: [10, 0, 40, 1],
        zoom: [0.02, 0, 0.1, 0.005]
      },
      bindToWindow: true,
      autoFocus: true
    },
    multiselect: false,
    navigationButtons: false,
    selectable: true,
    selectConnectedEdges: true,
    hoverConnectedEdges: true,
    tooltipDelay: [300, 0, 1000, 25],
    zoomView: true,
    zoomSpeed: [1, 0.1, 2, 0.1]
  },
  manipulation: {
    enabled: false,
    initiallyActive: false
  },
  physics: {
    enabled: true,
    barnesHut: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-2000, -30000, 0, 50],
      centralGravity: [0.3, 0, 10, 0.05],
      springLength: [95, 0, 500, 5],
      springConstant: [0.04, 0, 1.2, 0.005],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    forceAtlas2Based: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-50, -500, 0, 1],
      centralGravity: [0.01, 0, 1, 0.005],
      springLength: [95, 0, 500, 5],
      springConstant: [0.08, 0, 1.2, 0.005],
      damping: [0.4, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    repulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [200, 0, 500, 5],
      springConstant: [0.05, 0, 1.2, 0.005],
      nodeDistance: [100, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01]
    },
    hierarchicalRepulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [100, 0, 500, 5],
      springConstant: [0.01, 0, 1.2, 0.005],
      nodeDistance: [120, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    maxVelocity: [50, 0, 150, 1],
    minVelocity: [0.1, 0.01, 0.5, 0.01],
    solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
    timestep: [0.5, 0.01, 1, 0.01],
    wind: {
      x: [0, -10, 10, 0.1],
      y: [0, -10, 10, 0.1]
    } //adaptiveTimestep: true

  }
};
var configuratorHideOption = function configuratorHideOption(parentPath, optionName, options) {
  var _context;

  if (includes(parentPath).call(parentPath, "physics") && includes(_context = configureOptions.physics.solver).call(_context, optionName) && options.physics.solver !== optionName && optionName !== "wind") {
    return true;
  }

  return false;
};

var options = /*#__PURE__*/Object.freeze({
	__proto__: null,
	configuratorHideOption: configuratorHideOption,
	allOptions: allOptions,
	configureOptions: configureOptions
});

/**
 *  The Floyd–Warshall algorithm is an algorithm for finding shortest paths in
 *  a weighted graph with positive or negative edge weights (but with no negative
 *  cycles). - https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm
 */
var FloydWarshall = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function FloydWarshall() {
    _classCallCheck(this, FloydWarshall);
  }
  /**
   *
   * @param {object} body
   * @param {Array.<Node>} nodesArray
   * @param {Array.<Edge>} edgesArray
   * @returns {{}}
   */


  _createClass(FloydWarshall, [{
    key: "getDistances",
    value: function getDistances(body, nodesArray, edgesArray) {
      var D_matrix = {};
      var edges = body.edges; // prepare matrix with large numbers

      for (var i = 0; i < nodesArray.length; i++) {
        var node = nodesArray[i];
        var cell = {};
        D_matrix[node] = cell;

        for (var j = 0; j < nodesArray.length; j++) {
          cell[nodesArray[j]] = i == j ? 0 : 1e9;
        }
      } // put the weights for the edges in. This assumes unidirectionality.


      for (var _i = 0; _i < edgesArray.length; _i++) {
        var edge = edges[edgesArray[_i]]; // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix

        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
          D_matrix[edge.fromId][edge.toId] = 1;
          D_matrix[edge.toId][edge.fromId] = 1;
        }
      }

      var nodeCount = nodesArray.length; // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.

      for (var k = 0; k < nodeCount; k++) {
        var knode = nodesArray[k];
        var kcolm = D_matrix[knode];

        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
          var inode = nodesArray[_i2];
          var icolm = D_matrix[inode];

          for (var _j = _i2 + 1; _j < nodeCount; _j++) {
            var jnode = nodesArray[_j];
            var jcolm = D_matrix[jnode];
            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
            icolm[jnode] = val;
            jcolm[inode] = val;
          }
        }
      }

      return D_matrix;
    }
  }]);

  return FloydWarshall;
}();

/**
 * KamadaKawai positions the nodes initially based on
 *
 * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
 * -- Tomihisa KAMADA and Satoru KAWAI in 1989
 *
 * Possible optimizations in the distance calculation can be implemented.
 */

var KamadaKawai = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {number} edgeLength
   * @param {number} edgeStrength
   */
  function KamadaKawai(body, edgeLength, edgeStrength) {
    _classCallCheck(this, KamadaKawai);

    this.body = body;
    this.springLength = edgeLength;
    this.springConstant = edgeStrength;
    this.distanceSolver = new FloydWarshall();
  }
  /**
   * Not sure if needed but can be used to update the spring length and spring constant
   *
   * @param {object} options
   */


  _createClass(KamadaKawai, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        if (options.springLength) {
          this.springLength = options.springLength;
        }

        if (options.springConstant) {
          this.springConstant = options.springConstant;
        }
      }
    }
    /**
     * Position the system
     *
     * @param {Array.<Node>} nodesArray
     * @param {Array.<vis.Edge>} edgesArray
     * @param {boolean} [ignoreClusters=false]
     */

  }, {
    key: "solve",
    value: function solve(nodesArray, edgesArray) {
      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // get distance matrix
      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix
      // get the L Matrix

      this._createL_matrix(D_matrix); // get the K Matrix


      this._createK_matrix(D_matrix); // initial E Matrix


      this._createE_matrix(); // calculate positions


      var threshold = 0.01;
      var innerThreshold = 1;
      var iterations = 0;
      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
      var maxInnerIterations = 5;
      var maxEnergy = 1e9;
      var highE_nodeId = 0,
          dE_dx = 0,
          dE_dy = 0,
          delta_m = 0,
          subIterations = 0;

      while (maxEnergy > threshold && iterations < maxIterations) {
        iterations += 1;

        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);

        var _this$_getHighestEner2 = _slicedToArray(_this$_getHighestEner, 4);

        highE_nodeId = _this$_getHighestEner2[0];
        maxEnergy = _this$_getHighestEner2[1];
        dE_dx = _this$_getHighestEner2[2];
        dE_dy = _this$_getHighestEner2[3];
        delta_m = maxEnergy;
        subIterations = 0;

        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
          subIterations += 1;

          this._moveNode(highE_nodeId, dE_dx, dE_dy);

          var _this$_getEnergy = this._getEnergy(highE_nodeId);

          var _this$_getEnergy2 = _slicedToArray(_this$_getEnergy, 3);

          delta_m = _this$_getEnergy2[0];
          dE_dx = _this$_getEnergy2[1];
          dE_dy = _this$_getEnergy2[2];
        }
      }
    }
    /**
     * get the node with the highest energy
     *
     * @param {boolean} ignoreClusters
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getHighestEnergyNode",
    value: function _getHighestEnergyNode(ignoreClusters) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var maxEnergy = 0;
      var maxEnergyNodeId = nodesArray[0];
      var dE_dx_max = 0,
          dE_dy_max = 0;

      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
        var m = nodesArray[nodeIdx]; // by not evaluating nodes with predefined positions we should only move nodes that have no positions.

        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {
          var _this$_getEnergy3 = this._getEnergy(m),
              _this$_getEnergy4 = _slicedToArray(_this$_getEnergy3, 3),
              delta_m = _this$_getEnergy4[0],
              dE_dx = _this$_getEnergy4[1],
              dE_dy = _this$_getEnergy4[2];

          if (maxEnergy < delta_m) {
            maxEnergy = delta_m;
            maxEnergyNodeId = m;
            dE_dx_max = dE_dx;
            dE_dy_max = dE_dy;
          }
        }
      }

      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
    }
    /**
     * calculate the energy of a single node
     *
     * @param {Node.id} m
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getEnergy",
    value: function _getEnergy(m) {
      var _this$E_sums$m = _slicedToArray(this.E_sums[m], 2),
          dE_dx = _this$E_sums$m[0],
          dE_dy = _this$E_sums$m[1];

      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
      return [delta_m, dE_dx, dE_dy];
    }
    /**
     * move the node based on it's energy
     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
     *
     * @param {number} m
     * @param {number} dE_dx
     * @param {number} dE_dy
     * @private
     */

  }, {
    key: "_moveNode",
    value: function _moveNode(m, dE_dx, dE_dy) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var d2E_dx2 = 0;
      var d2E_dxdy = 0;
      var d2E_dy2 = 0;
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var km = this.K_matrix[m];
      var lm = this.L_matrix[m];

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];

        if (i !== m) {
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var kmat = km[i];
          var lmat = lm[i];
          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
        }
      } // make the variable names easier to make the solving of the linear system easier to read


      var A = d2E_dx2,
          B = d2E_dxdy,
          C = dE_dx,
          D = d2E_dy2,
          E = dE_dy; // solve the linear system for dx and dy

      var dy = (C / A + E / B) / (B / A - D / B);
      var dx = -(B * dy + C) / A; // move the node

      nodes[m].x += dx;
      nodes[m].y += dy; // Recalculate E_matrix (should be incremental)

      this._updateE_matrix(m);
    }
    /**
     * Create the L matrix: edge length times shortest path
     *
     * @param {object} D_matrix
     * @private
     */

  }, {
    key: "_createL_matrix",
    value: function _createL_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeLength = this.springLength;
      this.L_matrix = [];

      for (var i = 0; i < nodesArray.length; i++) {
        this.L_matrix[nodesArray[i]] = {};

        for (var j = 0; j < nodesArray.length; j++) {
          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
        }
      }
    }
    /**
     * Create the K matrix: spring constants times shortest path
     *
     * @param {object} D_matrix
     * @private
     */

  }, {
    key: "_createK_matrix",
    value: function _createK_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeStrength = this.springConstant;
      this.K_matrix = [];

      for (var i = 0; i < nodesArray.length; i++) {
        this.K_matrix[nodesArray[i]] = {};

        for (var j = 0; j < nodesArray.length; j++) {
          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
        }
      }
    }
    /**
     *  Create matrix with all energies between nodes
     *
     *  @private
     */

  }, {
    key: "_createE_matrix",
    value: function _createE_matrix() {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      this.E_matrix = {};
      this.E_sums = {};

      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
        this.E_matrix[nodesArray[mIdx]] = [];
      }

      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
        var m = nodesArray[_mIdx];
        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;

        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];

          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
            dE_dx += this.E_matrix[m][iIdx][0];
            dE_dy += this.E_matrix[m][iIdx][1];
          }
        } //Store sum


        this.E_sums[m] = [dE_dx, dE_dy];
      }
    }
    /**
     * Update method, just doing single column (rows are auto-updated) (update all sums)
     *
     * @param {number} m
     * @private
     */

  }, {
    key: "_updateE_matrix",
    value: function _updateE_matrix(m) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var colm = this.E_matrix[m];
      var kcolm = this.K_matrix[m];
      var lcolm = this.L_matrix[m];
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var dE_dx = 0;
      var dE_dy = 0;

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];

        if (i !== m) {
          //Keep old energy value for sum modification below
          var cell = colm[iIdx];
          var oldDx = cell[0];
          var oldDy = cell[1]; //Calc new energy:

          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
          colm[iIdx] = [dx, dy];
          dE_dx += dx;
          dE_dy += dy; //add new energy to sum of each column

          var sum = this.E_sums[i];
          sum[0] += dx - oldDx;
          sum[1] += dy - oldDy;
        }
      } //Store sum at -1 index


      this.E_sums[m] = [dE_dx, dE_dy];
    }
  }]);

  return KamadaKawai;
}();

/**
 * Create a network visualization, displaying nodes and edges.
 *
 * @param {Element} container   The DOM element in which the Network will
 *                                  be created. Normally a div element.
 * @param {object} data         An object containing parameters
 *                              {Array} nodes
 *                              {Array} edges
 * @param {object} options      Options
 * @class Network
 */

function Network(container, data, options) {
  var _context,
      _context2,
      _context3,
      _context4,
      _this = this;

  if (!(this instanceof Network)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  } // set constant values


  this.options = {};
  this.defaultOptions = {
    locale: "en",
    locales: locales,
    clickToUse: false
  };

  assign$2(this.options, this.defaultOptions);
  /**
   * Containers for nodes and edges.
   *
   * 'edges' and 'nodes' contain the full definitions of all the network elements.
   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.
   *
   * The distinction is important, because a defined node need not be active, i.e.
   * visible on the canvas. This happens in particular when clusters are defined, in
   * that case there will be nodes and edges not displayed.
   * The bottom line is that all code with actions related to visibility, *must* use
   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.
   */


  this.body = {
    container: container,
    // See comment above for following fields
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],
    emitter: {
      on: bind$6(_context = this.on).call(_context, this),
      off: bind$6(_context2 = this.off).call(_context2, this),
      emit: bind$6(_context3 = this.emit).call(_context3, this),
      once: bind$6(_context4 = this.once).call(_context4, this)
    },
    eventListeners: {
      onTap: function onTap() {},
      onTouch: function onTouch() {},
      onDoubleTap: function onDoubleTap() {},
      onHold: function onHold() {},
      onDragStart: function onDragStart() {},
      onDrag: function onDrag() {},
      onDragEnd: function onDragEnd() {},
      onMouseWheel: function onMouseWheel() {},
      onPinch: function onPinch() {},
      onMouseMove: function onMouseMove() {},
      onRelease: function onRelease() {},
      onContext: function onContext() {}
    },
    data: {
      nodes: null,
      // A DataSet or DataView
      edges: null // A DataSet or DataView

    },
    functions: {
      createNode: function createNode() {},
      createEdge: function createEdge() {},
      getPointer: function getPointer() {}
    },
    modules: {},
    view: {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      }
    },
    selectionBox: {
      show: false,
      position: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      }
    }
  }; // bind the event listeners

  this.bindEventListeners(); // setting up all modules

  this.images = new Images(function () {
    return _this.body.emitter.emit("_requestRedraw");
  }); // object with images

  this.groups = new Groups(); // object with groups

  this.canvas = new Canvas(this.body); // DOM handler

  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler

  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key

  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms

  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into

  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations

  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout

  this.clustering = new ClusterEngine(this.body); // clustering api

  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler); // data manipulation system

  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options

  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

  this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.

  this.body.modules["clustering"] = this.clustering; // create the DOM elements

  this.canvas._create(); // apply options


  this.setOptions(options); // load data (the disable start variable will be the same as the enabled clustering)

  this.setData(data);
} // Extend Network with an Emitter mixin

Emitter(Network.prototype);
/**
 * Set options
 *
 * @param {object} options
 */

Network.prototype.setOptions = function (options) {
  var _this2 = this;

  if (options === null) {
    options = undefined; // This ensures that options handling doesn't crash in the handling
  }

  if (options !== undefined) {
    var errorFound = Validator.validate(options, allOptions);

    if (errorFound === true) {
      console.error("%cErrors have been found in the supplied options object.", VALIDATOR_PRINT_STYLE);
    } // copy the global fields over


    var fields = ["locale", "locales", "clickToUse"];
    selectiveDeepExtend(fields, this.options, options); // normalize the locale or use English

    if (options.locale !== undefined) {
      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);
    } // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.


    options = this.layoutEngine.setOptions(options.layout, options);
    this.canvas.setOptions(options); // options for canvas are in globals
    // pass the options to the modules

    this.groups.setOptions(options.groups);
    this.nodesHandler.setOptions(options.nodes);
    this.edgesHandler.setOptions(options.edges);
    this.physics.setOptions(options.physics);
    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

    this.interactionHandler.setOptions(options.interaction);
    this.renderer.setOptions(options.interaction); // options for rendering are in interaction

    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction
    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.

    if (options.groups !== undefined) {
      this.body.emitter.emit("refreshNodes");
    } // these two do not have options at the moment, here for completeness
    //this.view.setOptions(options.view);
    //this.clustering.setOptions(options.clustering);


    if ("configure" in options) {
      if (!this.configurator) {
        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);
      }

      this.configurator.setOptions(options.configure);
    } // if the configuration system is enabled, copy all options and put them into the config system


    if (this.configurator && this.configurator.options.enabled === true) {
      var networkOptions = {
        nodes: {},
        edges: {},
        layout: {},
        interaction: {},
        manipulation: {},
        physics: {},
        global: {}
      };
      deepExtend(networkOptions.nodes, this.nodesHandler.options);
      deepExtend(networkOptions.edges, this.edgesHandler.options);
      deepExtend(networkOptions.layout, this.layoutEngine.options); // load the selectionHandler and render default options in to the interaction group

      deepExtend(networkOptions.interaction, this.selectionHandler.options);
      deepExtend(networkOptions.interaction, this.renderer.options);
      deepExtend(networkOptions.interaction, this.interactionHandler.options);
      deepExtend(networkOptions.manipulation, this.manipulation.options);
      deepExtend(networkOptions.physics, this.physics.options); // load globals into the global object

      deepExtend(networkOptions.global, this.canvas.options);
      deepExtend(networkOptions.global, this.options);
      this.configurator.setModuleOptions(networkOptions);
    } // handle network global options


    if (options.clickToUse !== undefined) {
      if (options.clickToUse === true) {
        if (this.activator === undefined) {
          this.activator = new Activator(this.canvas.frame);
          this.activator.on("change", function () {
            _this2.body.emitter.emit("activate");
          });
        }
      } else {
        if (this.activator !== undefined) {
          this.activator.destroy();
          delete this.activator;
        }

        this.body.emitter.emit("activate");
      }
    } else {
      this.body.emitter.emit("activate");
    }

    this.canvas.setSize(); // start the physics simulation. Can be safely called multiple times.

    this.body.emitter.emit("startSimulation");
  }
};
/**
 * Update the visible nodes and edges list with the most recent node state.
 *
 * Visible nodes are stored in this.body.nodeIndices.
 * Visible edges are stored in this.body.edgeIndices.
 * A node or edges is visible if it is not hidden or clustered.
 *
 * @private
 */


Network.prototype._updateVisibleIndices = function () {
  var nodes = this.body.nodes;
  var edges = this.body.edges;
  this.body.nodeIndices = [];
  this.body.edgeIndices = [];

  for (var nodeId in nodes) {
    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
        this.body.nodeIndices.push(nodes[nodeId].id);
      }
    }
  }

  for (var edgeId in edges) {
    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
      var edge = edges[edgeId]; // It can happen that this is executed *after* a node edge has been removed,
      // but *before* the edge itself has been removed. Taking this into account.

      var fromNode = nodes[edge.fromId];
      var toNode = nodes[edge.toId];
      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;
      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden
      toNode.options.hidden === false; // idem

      if (isVisible) {
        this.body.edgeIndices.push(edge.id);
      }
    }
  }
};
/**
 * Bind all events
 */


Network.prototype.bindEventListeners = function () {
  var _this3 = this;

  // This event will trigger a rebuilding of the cache everything.
  // Used when nodes or edges have been added or removed.
  this.body.emitter.on("_dataChanged", function () {
    _this3.edgesHandler._updateState();

    _this3.body.emitter.emit("_dataUpdated");
  }); // this is called when options of EXISTING nodes or edges have changed.

  this.body.emitter.on("_dataUpdated", function () {
    // Order important in following block
    _this3.clustering._updateState();

    _this3._updateVisibleIndices();

    _this3._updateValueRange(_this3.body.nodes);

    _this3._updateValueRange(_this3.body.edges); // start simulation (can be called safely, even if already running)


    _this3.body.emitter.emit("startSimulation");

    _this3.body.emitter.emit("_requestRedraw");
  });
};
/**
 * Set nodes and edges, and optionally options as well.
 *
 * @param {object} data              Object containing parameters:
 *                                   {Array | DataSet | DataView} [nodes] Array with nodes
 *                                   {Array | DataSet | DataView} [edges] Array with edges
 *                                   {String} [dot] String containing data in DOT format
 *                                   {String} [gephi] String containing data in gephi JSON format
 *                                   {Options} [options] Object with options
 */


Network.prototype.setData = function (data) {
  // reset the physics engine.
  this.body.emitter.emit("resetPhysics");
  this.body.emitter.emit("_resetData"); // unselect all to ensure no selections from old data are carried over.

  this.selectionHandler.unselectAll();

  if (data && data.dot && (data.nodes || data.edges)) {
    throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
  } // set options


  this.setOptions(data && data.options); // set all data

  if (data && data.dot) {
    console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);"); // parse DOT file

    var dotData = DOTToGraph(data.dot);
    this.setData(dotData);
    return;
  } else if (data && data.gephi) {
    // parse DOT file
    console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
    var gephiData = parseGephi(data.gephi);
    this.setData(gephiData);
    return;
  } else {
    this.nodesHandler.setData(data && data.nodes, true);
    this.edgesHandler.setData(data && data.edges, true);
  } // emit change in data


  this.body.emitter.emit("_dataChanged"); // emit data loaded

  this.body.emitter.emit("_dataLoaded"); // find a stable position or start animating to a stable position

  this.body.emitter.emit("initPhysics");
};
/**
 * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
 * var network = new vis.Network(..);
 * network.destroy();
 * network = null;
 */


Network.prototype.destroy = function () {
  this.body.emitter.emit("destroy"); // clear events

  this.body.emitter.off();
  this.off(); // delete modules

  delete this.groups;
  delete this.canvas;
  delete this.selectionHandler;
  delete this.interactionHandler;
  delete this.view;
  delete this.renderer;
  delete this.physics;
  delete this.layoutEngine;
  delete this.clustering;
  delete this.manipulation;
  delete this.nodesHandler;
  delete this.edgesHandler;
  delete this.configurator;
  delete this.images;

  for (var nodeId in this.body.nodes) {
    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;
    delete this.body.nodes[nodeId];
  }

  for (var edgeId in this.body.edges) {
    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;
    delete this.body.edges[edgeId];
  } // remove the container and everything inside it recursively


  recursiveDOMDelete(this.body.container);
};
/**
 * Update the values of all object in the given array according to the current
 * value range of the objects in the array.
 *
 * @param {object} obj    An object containing a set of Edges or Nodes
 *                        The objects must have a method getValue() and
 *                        setValueRange(min, max).
 * @private
 */


Network.prototype._updateValueRange = function (obj) {
  var id; // determine the range of the objects

  var valueMin = undefined;
  var valueMax = undefined;
  var valueTotal = 0;

  for (id in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, id)) {
      var value = obj[id].getValue();

      if (value !== undefined) {
        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
        valueTotal += value;
      }
    }
  } // adjust the range of all objects


  if (valueMin !== undefined && valueMax !== undefined) {
    for (id in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, id)) {
        obj[id].setValueRange(valueMin, valueMax, valueTotal);
      }
    }
  }
};
/**
 * Returns true when the Network is active.
 *
 * @returns {boolean}
 */


Network.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

Network.prototype.setSize = function () {
  return this.canvas.setSize.apply(this.canvas, arguments);
};

Network.prototype.canvasToDOM = function () {
  return this.canvas.canvasToDOM.apply(this.canvas, arguments);
};

Network.prototype.DOMtoCanvas = function () {
  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
};
/**
 * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of
 * nodeIds showing where the node is.
 *
 * If any nodeId in the chain, especially the first passed in as a parameter, is not present in
 * the current nodes list, an empty array is returned.
 *
 * Example:
 * cluster 'A' contains cluster 'B',
 * cluster 'B' contains cluster 'C',
 * cluster 'C' contains node 'fred'.
 * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.
 *
 * @param {string|number} nodeId
 * @returns {Array}
 */


Network.prototype.findNode = function () {
  return this.clustering.findNode.apply(this.clustering, arguments);
};

Network.prototype.isCluster = function () {
  return this.clustering.isCluster.apply(this.clustering, arguments);
};

Network.prototype.openCluster = function () {
  return this.clustering.openCluster.apply(this.clustering, arguments);
};

Network.prototype.cluster = function () {
  return this.clustering.cluster.apply(this.clustering, arguments);
};

Network.prototype.getNodesInCluster = function () {
  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
};

Network.prototype.clusterByConnection = function () {
  return this.clustering.clusterByConnection.apply(this.clustering, arguments);
};

Network.prototype.clusterByHubsize = function () {
  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
};

Network.prototype.updateClusteredNode = function () {
  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);
};

Network.prototype.getClusteredEdges = function () {
  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);
};

Network.prototype.getBaseEdge = function () {
  return this.clustering.getBaseEdge.apply(this.clustering, arguments);
};

Network.prototype.getBaseEdges = function () {
  return this.clustering.getBaseEdges.apply(this.clustering, arguments);
};

Network.prototype.updateEdge = function () {
  return this.clustering.updateEdge.apply(this.clustering, arguments);
};
/**
 * This method will cluster all nodes with 1 edge with their respective connected node.
 * The options object is explained in full <a data-scroll="" data-options="{ &quot;easing&quot;: &quot;easeInCubic&quot; }" href="#optionsObject">below</a>.
 *
 * @param {object} [options]
 * @returns {undefined}
 */


Network.prototype.clusterOutliers = function () {
  return this.clustering.clusterOutliers.apply(this.clustering, arguments);
};

Network.prototype.getSeed = function () {
  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
};

Network.prototype.enableEditMode = function () {
  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
};

Network.prototype.disableEditMode = function () {
  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
};

Network.prototype.addNodeMode = function () {
  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
};

Network.prototype.editNode = function () {
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};

Network.prototype.editNodeMode = function () {
  console.warn("Deprecated: Please use editNode instead of editNodeMode.");
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};

Network.prototype.addEdgeMode = function () {
  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
};

Network.prototype.editEdgeMode = function () {
  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
};

Network.prototype.deleteSelected = function () {
  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
};

Network.prototype.getPositions = function () {
  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
};

Network.prototype.getPosition = function () {
  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);
};

Network.prototype.storePositions = function () {
  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
};

Network.prototype.moveNode = function () {
  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
};

Network.prototype.getBoundingBox = function () {
  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
};

Network.prototype.getConnectedNodes = function (objectId) {
  if (this.body.nodes[objectId] !== undefined) {
    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
  } else {
    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
  }
};

Network.prototype.getConnectedEdges = function () {
  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
};

Network.prototype.startSimulation = function () {
  return this.physics.startSimulation.apply(this.physics, arguments);
};

Network.prototype.stopSimulation = function () {
  return this.physics.stopSimulation.apply(this.physics, arguments);
};

Network.prototype.stabilize = function () {
  return this.physics.stabilize.apply(this.physics, arguments);
};

Network.prototype.getSelection = function () {
  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
};

Network.prototype.setSelection = function () {
  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
};

Network.prototype.getSelectedNodes = function () {
  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);
};

Network.prototype.getSelectedEdges = function () {
  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);
};

Network.prototype.getNodeAt = function () {
  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);

  if (node !== undefined && node.id !== undefined) {
    return node.id;
  }

  return node;
};

Network.prototype.getEdgeAt = function () {
  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);

  if (edge !== undefined && edge.id !== undefined) {
    return edge.id;
  }

  return edge;
};

Network.prototype.selectNodes = function () {
  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
};

Network.prototype.selectEdges = function () {
  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
};

Network.prototype.unselectAll = function () {
  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);
  this.redraw();
};

Network.prototype.redraw = function () {
  return this.renderer.redraw.apply(this.renderer, arguments);
};

Network.prototype.getScale = function () {
  return this.view.getScale.apply(this.view, arguments);
};

Network.prototype.getViewPosition = function () {
  return this.view.getViewPosition.apply(this.view, arguments);
};

Network.prototype.fit = function () {
  return this.view.fit.apply(this.view, arguments);
};

Network.prototype.moveTo = function () {
  return this.view.moveTo.apply(this.view, arguments);
};

Network.prototype.focus = function () {
  return this.view.focus.apply(this.view, arguments);
};

Network.prototype.releaseNode = function () {
  return this.view.releaseNode.apply(this.view, arguments);
};

Network.prototype.getOptionsFromConfigurator = function () {
  var options = {};

  if (this.configurator) {
    options = this.configurator.getOptions.apply(this.configurator);
  }

  return options;
};

var parseDOTNetwork = DOTToGraph;
// overflow in UMD builds. They all export vis namespace therefore reexporting
// leads to loading vis to load vis to load vis…


//# sourceMappingURL=vis-network.js.map


/***/ }),

/***/ "./node_modules/vis-network/standalone/index.js":
/*!******************************************************!*\
  !*** ./node_modules/vis-network/standalone/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.DataSet),
/* harmony export */   "DataView": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.DataView),
/* harmony export */   "Network": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.Network),
/* harmony export */   "NetworkImages": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.NetworkImages),
/* harmony export */   "Queue": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.Queue),
/* harmony export */   "data": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.data),
/* harmony export */   "networkDOTParser": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkDOTParser),
/* harmony export */   "networkGephiParser": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkGephiParser),
/* harmony export */   "networkOptions": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkOptions),
/* harmony export */   "parseDOTNetwork": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.parseGephiNetwork)
/* harmony export */ });
/* harmony import */ var _esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esm */ "./node_modules/vis-network/standalone/esm/index.js");



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/vis_lstrie.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyx5QkFBeUI7O0FBRTVCO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQiw0Q0FBNEM7QUFDL0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFB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QTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUcsR0FBRztBQUNOO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQyx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0Isa0VBQWtFOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDLG1GQUFtRjs7QUFFbkY7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxRQUFRO0FBQ2IsMENBQTBDO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOzs7QUFHQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEYsRUFBRTs7QUFFRjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBLG9CQUFvQiwyQ0FBMkM7QUFDL0QsTUFBTTtBQUNOLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxhQUFhLGlCQUFpQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCLCtDQUErQzs7QUFFMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrREFBK0QsT0FBTzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixhQUFhLFFBQVE7QUFDckI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxrQkFBa0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFlBQVksU0FBUztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsSUFBSTtBQUN2QixXQUFXLFFBQVEsSUFBSTtBQUN2QixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsU0FBUyx1QkFBdUIsZ0JBQWdCLG1CQUFtQjtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0EsK0JBQStCOztBQUUvQixvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBELGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLE1BQU0sS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQzNDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDbEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7O0FBR0E7QUFDQSxZQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDs7O0FBR0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLFlBQVk7QUFDM0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLFlBQVk7QUFDM0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGVBQWUsWUFBWTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGVBQWUsWUFBWTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxVQUFVO0FBQ3pCOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxHQUFHO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOzs7QUFHQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxjQUFjO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxjQUFjO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlJQUF5SSxVQUFVO0FBQ25KOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLElBQUk7QUFDTDs7QUFFQSwyREFBMkQscUZBQXFGLFdBQVcsc0hBQXNILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSwyREFBMkQsVUFBVTs7QUFFMzhCLG9EQUFvRCxnQkFBZ0IsZ0JBQWdCLGtFQUFrRSx1RkFBdUYsNkRBQTZELGtEQUFrRDs7QUFFNVYseUNBQXlDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjtBQUMzSztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSw0RkFBNEYsYUFBYTtBQUN6RztBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osc0NBQXNDO0FBQ3RDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDZDQUE2QywwQkFBMEI7QUFDdkU7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0dBQWtHO0FBQ25IO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRyxHQUFHOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxHQUFHOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRiw2QkFBNkIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ3ZEO0FBQ0EsMkJBQTJCLElBQUksNkJBQTZCLElBQUksNkJBQTZCLElBQUk7QUFDakcsNkJBQTZCLElBQUksNkJBQTZCLElBQUksNkJBQTZCLElBQUk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRCxVQUFVO0FBQ1YscURBQXFEO0FBQ3JELFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwwQkFBMEIsRUFBRSxlQUFlLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQyx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFF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QUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTs7QUFFakUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFD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Q0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQSw2REFBNkQ7O0FBRTdELCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLGlFQUFpRTtBQUNqRSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQyxtQ0FBbUM7QUFDbkM7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQSxTQUFTOzs7QUFHVCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qyw2QkFBNkI7O0FBRTdCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUMsK0JBQStCOztBQUUvQixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtGQUFrRjs7QUFFbEY7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBELGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEMsT0FBTztBQUNQLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0EsT0FBTztBQUNQLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0EsT0FBTztBQUNQLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE1BQU0sVUFBVSxhQUFhLG1DQUFtQztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qiw2REFBNkQ7OztBQUc3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaURBQWlELE1BQU0sVUFBVTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixvQkFBb0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9COztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCw2Q0FBNkMsMkJBQTJCLDZCQUE2Qiw2Q0FBNkMsNEVBQTRFLDREQUE0RCxzQ0FBc0M7O0FBRWhVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sMEJBQTBCLHVEQUF1RCw4RkFBOEYsNENBQTRDLGdMQUFnTCx5RUFBeUUsS0FBSztBQUN6aUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVIsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOzs7QUFHN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUIsMkRBQTJEOztBQUUzRCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7O0FBR2xHOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjs7QUFFdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHOztBQUVaO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFH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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEOztBQUVBOztBQUVBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyREFBMkQscUZBQXFGLFdBQVcsc0hBQXNILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0Isa0JBQWtCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSwyREFBMkQsVUFBVTs7QUFFMzhCLG9EQUFvRCxlQUFlLGdCQUFnQixrRUFBa0UscUZBQXFGLDZEQUE2RCxrREFBa0Q7O0FBRXpWLHlDQUF5Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRTNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsOEJBQThCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7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QSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb087QUFDcE87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMXEzQ3NCOzs7Ozs7O1VDQXRCO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQzVCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztVRUpBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlzZHMvLi9zcmMvbHN0cmllLnRzIiwid2VicGFjazovL3Zpc2RzLy4vc3JjL3Zpc19sc3RyaWUudHMiLCJ3ZWJwYWNrOi8vdmlzZHMvLi9zcmMvdmlzanNfZGVmYXVsdF9vcHRpb25zLnRzIiwid2VicGFjazovL3Zpc2RzLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3N0YW5kYWxvbmUvZXNtL2luZGV4LmpzIiwid2VicGFjazovL3Zpc2RzLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3N0YW5kYWxvbmUvZXNtL3Zpcy1uZXR3b3JrLmpzIiwid2VicGFjazovL3Zpc2RzLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3N0YW5kYWxvbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly92aXNkcy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly92aXNkcy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExpbmVhciBTaXplIFN1ZmZpeCBUcmllXG5cbmNvbnN0IGxjcCA9ICh4OiBzdHJpbmcsIHk6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gIGNvbnN0IG4gPSBNYXRoLm1pbih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKHhbaV0gIT09IHlbaV0pIGJyZWFrO1xuICB9XG4gIHJldHVybiBpO1xufTtcblxuY2xhc3MgTm9kZSB7XG4gIGJpcnRoX3RpbWU6IG51bWJlcjtcbiAgaW5fZWRnZV9sYWJlbDogc3RyaW5nO1xuICBjaGlsZHJlbjogTWFwPHN0cmluZywgTm9kZT47XG4gIHZhbHVlOiBudW1iZXI7XG4gIGlzX2V4cGxpY2l0OiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGJpcnRoX3RpbWU6IG51bWJlcixcbiAgICBpbl9lZGdlX2xhYmVsOiBzdHJpbmcsXG4gICAgdmFsdWU6IG51bWJlcixcbiAgICBleHBsaWNpdDogYm9vbGVhblxuICApIHtcbiAgICB0aGlzLmJpcnRoX3RpbWUgPSBiaXJ0aF90aW1lO1xuICAgIHRoaXMuaW5fZWRnZV9sYWJlbCA9IGluX2VkZ2VfbGFiZWw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXA8c3RyaW5nLCBOb2RlPigpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmlzX2V4cGxpY2l0ID0gZXhwbGljaXQ7XG4gIH1cblxuICBnZXQgaXNfbGVhZigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zaXplID09PSAwO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xuICAgIGxldCBtYXggPSAtMTtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGNoaWxkLmhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiAxICsgbWF4O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdHJUcmVlIHtcbiAgcm9vdDogTm9kZTtcbiAgbm9kZXM6IEFycmF5PE5vZGU+O1xuICBzbGlua3M6IE1hcDxOb2RlLCBOb2RlPjtcbiAgZWxpbmtzOiBNYXA8Tm9kZSwgTm9kZT47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuY3JlYXRlX25vZGUoXCJcIiwgLTEsIHRydWUpO1xuICAgIHRoaXMuc2xpbmtzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZWxpbmtzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgY3JlYXRlX25vZGUoXG4gICAgaW5fZWRnZV9sYWJlbDogc3RyaW5nLFxuICAgIHZhbHVlOiBudW1iZXIsXG4gICAgaXNfZXhwbGljaXQ6IGJvb2xlYW5cbiAgKTogTm9kZSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKHRoaXMubm9kZXMubGVuZ3RoLCBpbl9lZGdlX2xhYmVsLCB2YWx1ZSwgaXNfZXhwbGljaXQpO1xuICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZpbmRfYnJhbmNoKFxuICAgIHBhcmVudDogTm9kZSxcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgbWF0Y2hfbGVuX2FsbDogbnVtYmVyID0gMFxuICApOiBbTm9kZSwgTm9kZSwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDAgfHwgIXBhcmVudC5jaGlsZHJlbi5oYXModGV4dFswXSkpIHtcbiAgICAgIHJldHVybiBbcGFyZW50LCBwYXJlbnQsIDAsIG1hdGNoX2xlbl9hbGxdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbi5nZXQodGV4dFswXSkgYXMgTm9kZTtcbiAgICBjb25zdCBtYXRjaF9sZW4gPSBsY3AoY2hpbGQuaW5fZWRnZV9sYWJlbCwgdGV4dCk7XG4gICAgaWYgKG1hdGNoX2xlbiA8IGNoaWxkLmluX2VkZ2VfbGFiZWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW3BhcmVudCwgY2hpbGQsIG1hdGNoX2xlbiwgbWF0Y2hfbGVuX2FsbCArIG1hdGNoX2xlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRfYnJhbmNoKFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgdGV4dC5zdWJzdHIobWF0Y2hfbGVuKSxcbiAgICAgICAgbWF0Y2hfbGVuX2FsbCArIG1hdGNoX2xlblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzcGxpdChcbiAgICBwYXJlbnQ6IE5vZGUsXG4gICAgY2hpbGQ6IE5vZGUsXG4gICAgbWF0Y2hfbGVuOiBudW1iZXIsXG4gICAgaXNfZXhwbGljaXQ6IGJvb2xlYW5cbiAgKTogTm9kZSB7XG4gICAgaWYgKG1hdGNoX2xlbiA9PT0gMCkgcmV0dXJuIGNoaWxkO1xuXG4gICAgY29uc3QgYnJhbmNoX25vZGUgPSB0aGlzLmNyZWF0ZV9ub2RlKFxuICAgICAgY2hpbGQuaW5fZWRnZV9sYWJlbC5zdWJzdHIoMCwgbWF0Y2hfbGVuKSxcbiAgICAgIC0xLFxuICAgICAgaXNfZXhwbGljaXRcbiAgICApO1xuICAgIHBhcmVudC5jaGlsZHJlbi5zZXQoYnJhbmNoX25vZGUuaW5fZWRnZV9sYWJlbFswXSwgYnJhbmNoX25vZGUpO1xuICAgIGNoaWxkLmluX2VkZ2VfbGFiZWwgPSBjaGlsZC5pbl9lZGdlX2xhYmVsLnN1YnN0cihtYXRjaF9sZW4pO1xuICAgIGJyYW5jaF9ub2RlLmNoaWxkcmVuLnNldChjaGlsZC5pbl9lZGdlX2xhYmVsWzBdLCBjaGlsZCk7XG4gICAgcmV0dXJuIGJyYW5jaF9ub2RlO1xuICB9XG5cbiAgaW5zZXJ0KHRleHQ6IHN0cmluZywgaTogbnVtYmVyLCBjcmVhdGVfaW1wbGljaXRfbm9kZTogYm9vbGVhbikge1xuICAgIGNvbnN0IFtwYXJlbnQsIGNoaWxkLCBtYXRjaF9sZW5fZWRnZSwgbWF0Y2hfbGVuX2FsbF0gPSB0aGlzLmZpbmRfYnJhbmNoKFxuICAgICAgdGhpcy5yb290LFxuICAgICAgdGV4dFxuICAgICk7XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiaW5zZXJ0IFtcIixcbiAgICAgIHRleHQsXG4gICAgICBcIl0gbWF0Y2hfbGVuPVwiLFxuICAgICAgbWF0Y2hfbGVuX2VkZ2UsXG4gICAgICBcIiBtYXRjaF9sZW5fYWxsPVwiLFxuICAgICAgbWF0Y2hfbGVuX2FsbFxuICAgICk7XG4gICAgLy8gY2hlY2sgd2hldGhlciBvciBub3QgdGhlIHBvaW50IGlzIGltcGxpY2l0IG5vZGUuXG4gICAgaWYgKG1hdGNoX2xlbl9hbGwgPT09IHRleHQubGVuZ3RoICYmICFjcmVhdGVfaW1wbGljaXRfbm9kZSkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKFwiY3JlYXRlX2ltcGxpY2l0X25vZGVcIiwgY3JlYXRlX2ltcGxpY2l0X25vZGUpO1xuICAgIGlmIChtYXRjaF9sZW5fZWRnZSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBicmFuY2hfbm9kZSA9XG4gICAgICAgIGNoaWxkID09PSBwYXJlbnRcbiAgICAgICAgICA/IHBhcmVudFxuICAgICAgICAgIDogdGhpcy5zcGxpdChwYXJlbnQsIGNoaWxkLCBtYXRjaF9sZW5fZWRnZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBsZWFmID0gdGhpcy5jcmVhdGVfbm9kZSh0ZXh0LnN1YnN0cihtYXRjaF9sZW5fYWxsKSwgaSwgdHJ1ZSk7XG4gICAgICBicmFuY2hfbm9kZS5jaGlsZHJlbi5zZXQobGVhZi5pbl9lZGdlX2xhYmVsWzBdLCBsZWFmKTtcbiAgICB9XG4gIH1cblxuICBidWlsZF9zdWZmaXhfbGlua3MoKSB7XG4gICAgY29uc3QgcmVjID0gKG5vZGU6IE5vZGUsIG5vZGVfbGFiZWw6IHN0cmluZywgcmV2ZXJzZTogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKG5vZGUgIT09IHRoaXMucm9vdCkge1xuICAgICAgICBjb25zdCBbcGFyZW50LCBjaGlsZF0gPSB0aGlzLmZpbmRfYnJhbmNoKFxuICAgICAgICAgIHRoaXMucm9vdCxcbiAgICAgICAgICBub2RlX2xhYmVsLnN1YnN0cigxKVxuICAgICAgICApO1xuICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkge1xuICAgICAgICAgIGlmIChyZXZlcnNlKSB0aGlzLnNsaW5rcy5zZXQocGFyZW50LCBub2RlKTtcbiAgICAgICAgICBlbHNlIHRoaXMuc2xpbmtzLnNldChub2RlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICByZWMoY2hpbGQsIG5vZGVfbGFiZWwgKyBjaGlsZC5pbl9lZGdlX2xhYmVsLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYyh0aGlzLnJvb3QsIFwiXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGNocm9jaGVtb3JlIGV0IGFsLidzIGxpbmtcbiAgYnVpbGRfZXh0ZW5kX3N1ZmZpeF9saW5rcygpIHtcbiAgICAvLyB0cmF2ZXJzZSBhbGwgaW1wbGljaXQgbm9kZXNcbiAgICAvLyBpZiB0aGVyZSBpcyBhIHN1ZmZpeCBsaW5rIHRvIGEgZXhwbGljaXQgbm9kZVxuICAgIC8vIGNyZWF0ZSBhbiBpbXBsaWNpdCBub2RlIGFuZCBpdHMgc3VmZml4IGxpbmtcbiAgICBjb25zdCByZWMgPSAocGFyZW50OiBOb2RlLCBjaGlsZDogTm9kZSwgbGFiZWw6IHN0cmluZykgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjaGlsZC5pbl9lZGdlX2xhYmVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVkZ2VfbGFiZWwgPSBsYWJlbCArIGNoaWxkLmluX2VkZ2VfbGFiZWwuc3Vic3RyKDAsIGkpO1xuICAgICAgICBjb25zdCBlZGdlX2xhYmVsX3N1ZiA9IGVkZ2VfbGFiZWwuc3Vic3RyKDEpO1xuICAgICAgICBjb25zdCBbdG9fcGFyZW50LCB0b19jaGlsZCwgbWF0Y2hfbGVuX2VkZ2UsIG1hdGNoX2xlbl9hbGxdID1cbiAgICAgICAgICB0aGlzLmZpbmRfYnJhbmNoKHRoaXMucm9vdCwgZWRnZV9sYWJlbF9zdWYpO1xuICAgICAgICBpZiAodG9fY2hpbGQgPT09IHRvX3BhcmVudCAmJiB0b19wYXJlbnQuaXNfZXhwbGljaXQpIHtcbiAgICAgICAgICAvLyBjcmVhdGUgYSBub2RlIGFuZCBpdHMgc3VmZml4IGxpbmtcbiAgICAgICAgICBjb25zdCBicmFuY2hfbm9kZSA9IHRoaXMuc3BsaXQocGFyZW50LCBjaGlsZCwgaSwgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuZWxpbmtzLnNldChicmFuY2hfbm9kZSwgdG9fcGFyZW50KTtcbiAgICAgICAgICByZWMoYnJhbmNoX25vZGUsIGNoaWxkLCBlZGdlX2xhYmVsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGNoaWxkX2NoaWxkIG9mIGNoaWxkLmNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgIHJlYyhjaGlsZCwgY2hpbGRfY2hpbGQsIGxhYmVsICsgY2hpbGQuaW5fZWRnZV9sYWJlbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWModGhpcy5yb290LCB0aGlzLnJvb3QsIFwiXCIpO1xuICB9XG5cbiAgZ2V0IGpzb24oKSB7XG4gICAgY29uc3Qgbm9kZXM6IGFueSA9IFtdO1xuICAgIGNvbnN0IGVkZ2VzOiBhbnkgPSBbXTtcbiAgICBjb25zdCBuaWQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5yb290LmhlaWdodDtcbiAgICAvLyBpZiB0cnVlLCB1c2UgYSBub2RlIGRlcHRoIGFzIGxldmVsIG9mIHZpc25ldHdvcmtcbiAgICAvLyBvdGhlcndpc2UsIHVzZSBhIGhlaWdodCwgbWF4aW11bSBkaXN0YW5jZSB0byBpdHMgbGVhZnNcbiAgICBjb25zdCB1c2VfZGVwdGggPSBmYWxzZTtcblxuICAgIGNvbnN0IGNyZWF0ZV9qc29uX25vZGUgPSAobm9kZTogTm9kZSwgZGVwdGg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKCFuaWQuaGFzKG5vZGUpKSB7XG4gICAgICAgIG5pZC5zZXQobm9kZSwgbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbmRpYyA9IHtcbiAgICAgICAgICBsYWJlbDogbm9kZS52YWx1ZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IFwiXCIgKyBub2RlLnZhbHVlLFxuICAgICAgICAgIGlkOiBuaWQuZ2V0KG5vZGUpLFxuICAgICAgICAgIGxldmVsOiB1c2VfZGVwdGggPyBkZXB0aCA6IGhlaWdodCAtIG5vZGUuaGVpZ2h0LFxuICAgICAgICAgIHNoYXBlOiBub2RlLmlzX2xlYWYgPyBcImJveFwiIDogXCJjaXJjbGVcIixcbiAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgYm9yZGVyOiBub2RlLmlzX2V4cGxpY2l0ID8gXCIjMkI3Q0U5XCIgOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IG5vZGUuaXNfZXhwbGljaXQgPyBcIiNEMkU1RkZcIiA6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIG5vZGVzLnB1c2gobmRpYyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWMgPSAocGFyZW50OiBOb2RlLCBkZXB0aDogbnVtYmVyKSA9PiB7XG4gICAgICBjcmVhdGVfanNvbl9ub2RlKHBhcmVudCwgZGVwdGgpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbi5lbnRyaWVzKCkpO1xuICAgICAgY2hpbGRyZW4uc29ydCgpO1xuICAgICAgY29uc29sZS5sb2coXCJjaGlsZHJlblwiLCBjaGlsZHJlbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKChba2V5LCBjaGlsZF0pID0+IHtcbiAgICAgICAgY3JlYXRlX2pzb25fbm9kZShjaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgY29uc3QgZWRnZSA9IHtcbiAgICAgICAgICBmcm9tOiBuaWQuZ2V0KHBhcmVudCksXG4gICAgICAgICAgdG86IG5pZC5nZXQoY2hpbGQpLFxuICAgICAgICAgIGlkOiBuaWQuZ2V0KHBhcmVudCkgKyBcIi1cIiArIG5pZC5nZXQoY2hpbGQpLFxuICAgICAgICAgIGxhYmVsOiBjaGlsZC5pbl9lZGdlX2xhYmVsLFxuICAgICAgICAgIGZvbnQ6IHsgYWxpZ246IFwidG9wXCIgfSxcbiAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgY29sb3I6IFwiIzJCN0NFOVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIHJlYyhjaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmVjKHRoaXMucm9vdCwgMCk7XG5cbiAgICAvLyBzdWZmaXggbGlua1xuICAgIGNvbnN0IHNsaW5rcyA9IFtdO1xuICAgIGNvbnNvbGUubG9nKEFycmF5LmZyb20odGhpcy5zbGlua3MuZW50cmllcygpKSk7XG4gICAgZm9yIChjb25zdCBbZnJvbV9ub2RlLCB0b19ub2RlXSBvZiBBcnJheS5mcm9tKHRoaXMuc2xpbmtzLmVudHJpZXMoKSkuY29uY2F0KFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLmVsaW5rcy5lbnRyaWVzKCkpXG4gICAgKSkge1xuICAgICAgY29uc3Qgc2xpbmsgPSB7XG4gICAgICAgIGZyb206IG5pZC5nZXQoZnJvbV9ub2RlKSxcbiAgICAgICAgdG86IG5pZC5nZXQodG9fbm9kZSksXG4gICAgICAgIGlkOiBcInNcIiArIG5pZC5nZXQoZnJvbV9ub2RlKSArIFwiLVwiICsgbmlkLmdldCh0b19ub2RlKSxcbiAgICAgICAgZGFzaGVzOiB0cnVlLFxuICAgICAgICBjb2xvcjogeyBjb2xvcjogZnJvbV9ub2RlLmlzX2V4cGxpY2l0ID8gXCIjODQ4NDg0XCIgOiBcIiNmZjAwMDBcIiB9LFxuICAgICAgICBzbW9vdGg6IHsgdHlwZTogXCJjdXJ2ZWRDV1wiLCByb3VuZG5lc3M6IDAuNCB9LFxuICAgICAgfTtcbiAgICAgIHNsaW5rcy5wdXNoKHNsaW5rKTtcbiAgICB9XG4gICAgY29uc3QgZWRnZXNfYWxsID0gZWRnZXMuY29uY2F0KHNsaW5rcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5pZC5nZXQodGhpcy5yb290KSxcbiAgICAgIG5vZGVzLFxuICAgICAgZWRnZXM6IGVkZ2VzX2FsbCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBidWlsZF9sc3RyaWUgPSAoXG4gIHRleHQ6IHN0cmluZyxcbiAgc2hvd19zdWZmaXhfbGlua3M6IGJvb2xlYW4sXG4gIHNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzOiBib29sZWFuLFxuICBjcmVhdGVfaW1wbGljaXRfbm9kZTogYm9vbGVhblxuKSA9PiB7XG4gIGNvbnN0IGxzdHJpZSA9IG5ldyBTdHJUcmVlKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbHN0cmllLmluc2VydCh0ZXh0LnN1YnN0cmluZyhpKSwgaSwgY3JlYXRlX2ltcGxpY2l0X25vZGUpO1xuICB9XG4gIGlmIChzaG93X3N1ZmZpeF9saW5rcykgbHN0cmllLmJ1aWxkX3N1ZmZpeF9saW5rcygpO1xuICBpZiAoc2hvd19leHRlbmRlZF9zdWZmaXhfbGlua3MpIGxzdHJpZS5idWlsZF9leHRlbmRfc3VmZml4X2xpbmtzKCk7XG4gIGNvbnNvbGUubG9nKFwiZXNsaW5rc1wiKTtcbiAgZm9yIChjb25zdCBbZnJvbSwgdG9dIG9mIGxzdHJpZS5lbGlua3MuZW50cmllcygpKSB7XG4gICAgY29uc29sZS5sb2coXCJlc2xpbmtbXCIgKyBmcm9tLmJpcnRoX3RpbWUgKyBcIiwgXCIgKyB0by5iaXJ0aF90aW1lICsgXCJdXCIpO1xuICB9XG4gIHJldHVybiBsc3RyaWU7XG59O1xuXG5jb25zdCBtYWluID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICBjb25zdCBsc3RyaWUgPSBidWlsZF9sc3RyaWUodGV4dCwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gIGNvbnNvbGUubG9nKGxzdHJpZS5qc29uKTtcbn07XG5cbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBtYWluKHByb2Nlc3MuYXJndi5sZW5ndGggPT09IDMgPyBwcm9jZXNzLmFyZ3ZbMl0gOiBcImFiYWFiYWNcIik7XG59XG4iLCJpbXBvcnQgeyBEYXRhU2V0LCBOZXR3b3JrIH0gZnJvbSBcInZpcy1uZXR3b3JrL3N0YW5kYWxvbmVcIjtcbmltcG9ydCB7IGJ1aWxkX2xzdHJpZSB9IGZyb20gXCIuL2xzdHJpZVwiO1xuaW1wb3J0ICogYXMgdmlzanNfZGVmYXVsdF9vcHRpb25zIGZyb20gXCIuL3Zpc2pzX2RlZmF1bHRfb3B0aW9uc1wiO1xuXG5jb25zdCBvcHRpb25zID0gdmlzanNfZGVmYXVsdF9vcHRpb25zLm9wdGlvbnM7XG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5ldHdvcmtcIikgYXMgSFRNTEVsZW1lbnQ7XG5jb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsoY29udGFpbmVyLCB7fSwgb3B0aW9ucyk7XG5sZXQgbmV0d29ya0RhdGEgPSB7fTtcblxuaW50ZXJmYWNlIFBhcmFtcyB7XG4gIGlucHV0X3RleHQ6IHN0cmluZztcbiAgc2hvd19zdWZmaXhfbGlua3M6IGJvb2xlYW47XG4gIHNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzOiBib29sZWFuO1xuICBjcmVhdGVfaW1wbGljaXRfbm9kZTogYm9vbGVhbjtcbn1cblxuY29uc3QgbG9hZF9wYXJhbXNfZnJvbV91cmwgPSAoKSA9PiB7XG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcbiAgLy8gY29uc29sZS5sb2coJ3F1ZXJ5c3RyaW5nJywgcXVlcnlTdHJpbmcpXG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocXVlcnlTdHJpbmcpO1xuICBsZXQgcGFyYW1zOiBQYXJhbXMgPSB7XG4gICAgaW5wdXRfdGV4dDogXCJjb2NvYVwiLFxuICAgIHNob3dfc3VmZml4X2xpbmtzOiB0cnVlLFxuICAgIHNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzOiB0cnVlLFxuICAgIGNyZWF0ZV9pbXBsaWNpdF9ub2RlOiBmYWxzZSxcbiAgfTtcbiAgY29uc3Qga2V5cyA9IFtcImlucHV0X3RleHRcIiwgXCJzaG93X3N1ZmZpeF9saW5rc1wiLCBcImltcGxpY2l0X2NkYXdnXCJdO1xuICBjb25zdCB1bmRlZmluZWRfdmFsdWVzID0gW1wiXCIsIFwidHJ1ZVwiLCBcInRydWVcIl07XG4gIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgdXJsa2V5ID0gdXJsUGFyYW1zLmdldChrZXkpO1xuICB9XG5cbiAgY29uc3QgdXJsa2V5ID0gdXJsUGFyYW1zLmdldChcImlucHV0X3RleHRcIik7XG4gIGlmICh1cmxrZXkgIT09IG51bGwpIHBhcmFtcy5pbnB1dF90ZXh0ID0gdXJsa2V5O1xuICBwYXJhbXMuc2hvd19zdWZmaXhfbGlua3MgPSB1cmxQYXJhbXMuZ2V0KFwic2hvd19zdWZmaXhfbGlua3NcIikgPT09IFwidHJ1ZVwiO1xuICBwYXJhbXMuc2hvd19leHRlbmRlZF9zdWZmaXhfbGlua3MgPVxuICAgIHVybFBhcmFtcy5nZXQoXCJzaG93X2V4dGVuZGVkX3N1ZmZpeF9saW5rc1wiKSA9PT0gXCJ0cnVlXCI7XG4gIHBhcmFtcy5jcmVhdGVfaW1wbGljaXRfbm9kZSA9XG4gICAgdXJsUGFyYW1zLmdldChcImNyZWF0ZV9pbXBsaWNpdF9ub2RlXCIpID09PSBcInRydWVcIjtcbiAgcGFyYW1zLmNyZWF0ZV9pbXBsaWNpdF9ub2RlID0gdHJ1ZTtcbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbmNvbnN0IGxvYWRfcGFyYW1zX2Zyb21faHRtbCA9ICgpID0+IHtcbiAgY29uc3QgaW5wdXRfdGV4dCA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0X3RleHRcIikgYXMgSFRNTElucHV0RWxlbWVudClcbiAgICAudmFsdWU7XG4gIGNvbnN0IHNob3dfc3VmZml4X2xpbmtzID0gKFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2hvd19zdWZmaXhfbGlua3NcIikgYXMgSFRNTElucHV0RWxlbWVudFxuICApLmNoZWNrZWQ7XG4gIGNvbnN0IHNob3dfZXh0ZW5kX3N1ZmZpeF9saW5rcyA9IChcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgKS5jaGVja2VkO1xuICBjb25zdCBjcmVhdGVfaW1wbGljaXRfbm9kZSA9IChcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNyZWF0ZV9pbXBsaWNpdF9ub2RlXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgKS5jaGVja2VkO1xuICBjb25zdCBwYXJhbXM6IFBhcmFtcyA9IHtcbiAgICBpbnB1dF90ZXh0OiBpbnB1dF90ZXh0LFxuICAgIHNob3dfc3VmZml4X2xpbmtzOiBzaG93X3N1ZmZpeF9saW5rcyxcbiAgICBzaG93X2V4dGVuZGVkX3N1ZmZpeF9saW5rczogc2hvd19leHRlbmRfc3VmZml4X2xpbmtzLFxuICAgIGNyZWF0ZV9pbXBsaWNpdF9ub2RlOiBjcmVhdGVfaW1wbGljaXRfbm9kZSxcbiAgfTtcbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbmNvbnN0IHNldF9wYXJhbXNfdG9fdXJsID0gKHBhcmFtczogUGFyYW1zKSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1zKSkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1zW2tleSBhcyBrZXlvZiBQYXJhbXNdLnRvU3RyaW5nKCkpO1xuICB9XG4gIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBcIlwiLCB1cmwudG9TdHJpbmcoKSk7XG59O1xuXG5jb25zdCBzZXRfcGFyYW1zX3RvX2h0bWwgPSAocGFyYW1zOiBQYXJhbXMpID0+IHtcbiAgY29uc3QgaW5wdXRfdGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXRfdGV4dFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBzaG93X3N1ZmZpeF9saW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgIFwic2hvd19zdWZmaXhfbGlua3NcIlxuICApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIGNvbnN0IHNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgXCJzaG93X2V4dGVuZGVkX3N1ZmZpeF9saW5rc1wiXG4gICkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgY29uc3QgY3JlYXRlX2ltcGxpY2l0X25vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICBcImNyZWF0ZV9pbXBsaWNpdF9ub2RlXCJcbiAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBpbnB1dF90ZXh0LnZhbHVlID0gcGFyYW1zLmlucHV0X3RleHQ7XG4gIHNob3dfc3VmZml4X2xpbmtzLmNoZWNrZWQgPSBwYXJhbXMuc2hvd19zdWZmaXhfbGlua3M7XG4gIHNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzLmNoZWNrZWQgPSBwYXJhbXMuc2hvd19leHRlbmRlZF9zdWZmaXhfbGlua3M7XG4gIGNyZWF0ZV9pbXBsaWNpdF9ub2RlLmNoZWNrZWQgPSBwYXJhbXMuY3JlYXRlX2ltcGxpY2l0X25vZGU7XG59O1xuXG5jb25zdCByZWRyYXcgPSAoKSA9PiB7XG4gIC8vIGxvYWQgYW5kIHNldCBwYXJhbWV0ZXJzXG4gIGNvbnN0IHBhcmFtcyA9IGxvYWRfcGFyYW1zX2Zyb21faHRtbCgpO1xuICBzZXRfcGFyYW1zX3RvX3VybChwYXJhbXMpO1xuICBjb25zb2xlLmxvZyhcInBhcmFtc1wiLCBwYXJhbXMpO1xuXG4gIGNvbnN0IGxzdHJpZSA9IGJ1aWxkX2xzdHJpZShcbiAgICBwYXJhbXMuaW5wdXRfdGV4dCxcbiAgICBwYXJhbXMuc2hvd19zdWZmaXhfbGlua3MsXG4gICAgcGFyYW1zLnNob3dfZXh0ZW5kZWRfc3VmZml4X2xpbmtzLFxuICAgIHBhcmFtcy5jcmVhdGVfaW1wbGljaXRfbm9kZVxuICApO1xuICBjb25zb2xlLmxvZyhsc3RyaWUpO1xuICBjb25zdCBqc29uID0gbHN0cmllLmpzb247XG4gIGNvbnNvbGUubG9nKGpzb24pO1xuICBuZXR3b3JrRGF0YSA9IHtcbiAgICBub2RlczogbmV3IERhdGFTZXQoanNvbi5ub2RlcyksXG4gICAgZWRnZXM6IG5ldyBEYXRhU2V0KGpzb24uZWRnZXMpLFxuICB9O1xuICBuZXR3b3JrLnNldERhdGEobmV0d29ya0RhdGEpO1xufTtcblxuY29uc3QgbWFpbiA9ICgpID0+IHtcbiAgLy8gc2V0IGV2ZW50IGxpc3RlbmVyXG4gIGNvbnN0IGlucHV0X3RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0X3RleHRcIikgYXMgSFRNTEVsZW1lbnQ7XG4gIGlucHV0X3RleHQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlZHJhdyk7XG4gIGlucHV0X3RleHQuYWRkRXZlbnRMaXN0ZW5lcihcInByb3BlcnR5Y2hhbmdlXCIsIHJlZHJhdyk7XG4gIGNvbnN0IHNob3dfc2xfYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgXCJzaG93X3N1ZmZpeF9saW5rc1wiXG4gICkgYXMgSFRNTEVsZW1lbnQ7XG4gIHNob3dfc2xfYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcmVkcmF3KTtcbiAgY29uc3Qgc2hvd19lc2xfYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgXCJzaG93X2V4dGVuZGVkX3N1ZmZpeF9saW5rc1wiXG4gICkgYXMgSFRNTEVsZW1lbnQ7XG4gIHNob3dfZXNsX2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHJlZHJhdyk7XG4gIGNvbnN0IGNyZWF0ZV9pbm9kZV9idG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICBcImNyZWF0ZV9pbXBsaWNpdF9ub2RlXCJcbiAgKSBhcyBIVE1MRWxlbWVudDtcbiAgY3JlYXRlX2lub2RlX2J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHJlZHJhdyk7XG5cbiAgbmV0d29yay5vbihcImhvdmVyRWRnZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGNvbnNvbGUubG9nKFwiaG92ZXJFZGdlXCIsIGUpO1xuICAgIC8vIGNvbnNvbGUubG9nKCduZXR3b3JrRGF0YS5lZGdlcycsIG5ldHdvcmtEYXRhLmVkZ2VzLmdldChlLmVkZ2UpKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBuZXR3b3JrRGF0YS5lZGdlcy51cGRhdGUoeyBpZDogZS5lZGdlLCBmb250OiB7IHNpemU6IDM0IH0gfSk7XG4gIH0pO1xuICBuZXR3b3JrLm9uKFwiYmx1ckVkZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zb2xlLmxvZyhcImJsdXJFZGdlXCIsIGUpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBuZXR3b3JrRGF0YS5lZGdlcy51cGRhdGUoeyBpZDogZS5lZGdlLCBmb250OiB7IHNpemU6IDE0IH0gfSk7XG4gIH0pO1xuXG4gIC8vIGxvYWQgYW5kIHNldCBwYXJhbWV0ZXJzXG4gIGNvbnN0IHBhcmFtcyA9IGxvYWRfcGFyYW1zX2Zyb21fdXJsKCk7XG4gIHNldF9wYXJhbXNfdG9faHRtbChwYXJhbXMpO1xuXG4gIHJlZHJhdygpO1xufTtcbm1haW4oKTtcbiIsImV4cG9ydCBjb25zdCBvcHRpb25zID0ge1xuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBsYXlvdXQ6IHtcbiAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgIC8vIGVuYWJsZWQ6IHRydWVcbiAgICAgIC8vIGRpcmVjdGlvbjogJ1VEJyxcbiAgICAgIGRpcmVjdGlvbjogXCJMUlwiLFxuICAgICAgLy8gc29ydE1ldGhvZDogJ2RpcmVjdGVkJyxcbiAgICAgIHRyZWVTcGFjaW5nOiAxODUsXG4gICAgICBsZXZlbFNlcGFyYXRpb246IDk1LFxuICAgICAgbm9kZVNwYWNpbmc6IDQwLFxuICAgIH0sXG4gIH0sXG4gIG5vZGVzOiB7XG4gICAgc2l6ZTogMTAsXG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzY2FsZUZhY3RvcjogMC41LFxuICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGVkZ2UgbGFiZWwgaXMgbm90IGRpc3BsYXllZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBlZGdlXG4gICAgLy8gaWYgYHNtb290aGAgaXMgc3BlY2lmaWVkXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgLy8gdHlwZTogJ2R5bmFtaWMnLFxuICAgICAgdHlwZTogXCJ2ZXJ0aWNhbFwiLCAvLyBUaGlzIGlzIGJldHRlciBmb3IgTFJcbiAgICAgIC8vIHR5cGU6ICdob3Jpem9udGFsJywgLy8gVGhpcyBpcyBiZXR0ZXIgZm9yIFVEXG4gICAgICAvLyB0eXBlOiAnY29udGludW91cycsXG4gICAgICAvLyB0eXBlOiAnY3VydmVkQ0NXJyxcbiAgICAgIC8vIHR5cGU6ICdzdHJhaWdodENyb3NzJyxcbiAgICAgIHJvdW5kbmVzczogMS4wLFxuICAgIH0sXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgaG92ZXI6IHRydWUsXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IHRydWUsXG4gIH0sXG4gIHBoeXNpY3M6IGZhbHNlLFxufTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL3Zpcy1uZXR3b3JrXCI7XG4iLCIvKipcbiAqIHZpcy1uZXR3b3JrXG4gKiBodHRwczovL3Zpc2pzLmdpdGh1Yi5pby92aXMtbmV0d29yay9cbiAqXG4gKiBBIGR5bmFtaWMsIGJyb3dzZXItYmFzZWQgdmlzdWFsaXphdGlvbiBsaWJyYXJ5LlxuICpcbiAqIEB2ZXJzaW9uIDkuMS4yXG4gKiBAZGF0ZSAgICAyMDIyLTAzLTI4VDIwOjEzOjUxLjA0NlpcbiAqXG4gKiBAY29weXJpZ2h0IChjKSAyMDExLTIwMTcgQWxtZW5kZSBCLlYsIGh0dHA6Ly9hbG1lbmRlLmNvbVxuICogQGNvcHlyaWdodCAoYykgMjAxNy0yMDE5IHZpc2pzIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzXG4gKlxuICogQGxpY2Vuc2VcbiAqIHZpcy5qcyBpcyBkdWFsIGxpY2Vuc2VkIHVuZGVyIGJvdGhcbiAqXG4gKiAgIDEuIFRoZSBBcGFjaGUgMi4wIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogICBhbmRcbiAqXG4gKiAgIDIuIFRoZSBNSVQgTGljZW5zZVxuICogICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogdmlzLmpzIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBlaXRoZXIgbGljZW5zZS5cbiAqL1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59OyAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuXG5cbnZhciBnbG9iYWwkUCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG5jaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fCBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG5jaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fCBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0oKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgZmFpbHMkdCA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkcyA9IGZhaWxzJHQ7XG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9LmJpbmQoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG5cblxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkNCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSQzID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGFwcGx5JDYgPSBGdW5jdGlvblByb3RvdHlwZSQzLmFwcGx5O1xudmFyIGNhbGwkZCA9IEZ1bmN0aW9uUHJvdG90eXBlJDMuY2FsbDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXJlZmxlY3QgLS0gc2FmZVxuXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDQgPyBjYWxsJGQuYmluZChhcHBseSQ2KSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZC5hcHBseShhcHBseSQ2LCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQzID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCRkID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xudmFyIGNhbGwkYyA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyR3ID0gTkFUSVZFX0JJTkQkMyAmJiBiaW5kJGQuYmluZChjYWxsJGMsIGNhbGwkYyk7XG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EJDMgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJHcoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGMuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcblxudmFyIGlzQ2FsbGFibGUkaCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRyID0gZmFpbHMkdDsgLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJHIoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMiA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbnZhciBjYWxsJGIgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQyID8gY2FsbCRiLmJpbmQoY2FsbCRiKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkYi5hcHBseShjYWxsJGIsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQyID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ4ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgLy8gTmFzaG9ybiB+IEpESzggYnVnXG5cbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ4ICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUkMi5jYWxsKHtcbiAgMTogMlxufSwgMSk7IC8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDgodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQyO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDUgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJHYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJGEgPSB1bmN1cnJ5VGhpcyR2KHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkdignJy5zbGljZSk7XG5cbnZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlJDEodG9TdHJpbmckYShpdCksIDgsIC0xKTtcbn07XG5cbnZhciBnbG9iYWwkTyA9IGdsb2JhbCRQO1xudmFyIHVuY3VycnlUaGlzJHUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJHEgPSBmYWlscyR0O1xudmFyIGNsYXNzb2YkZiA9IGNsYXNzb2ZSYXckMTtcbnZhciBPYmplY3QkYSA9IGdsb2JhbCRPLk9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJHUoJycuc3BsaXQpOyAvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJHEoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gIU9iamVjdCRhKCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiRmKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiBPYmplY3QkYShpdCk7XG59IDogT2JqZWN0JGE7XG5cbnZhciBnbG9iYWwkTiA9IGdsb2JhbCRQO1xudmFyIFR5cGVFcnJvciRqID0gZ2xvYmFsJE4uVHlwZUVycm9yOyAvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkNSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IkaihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgSW5kZXhlZE9iamVjdCQzID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkYiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChpdCkpO1xufTtcblxudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkaDtcblxudmFyIGlzT2JqZWN0JGogPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRnKGl0KTtcbn07XG5cbnZhciBwYXRoJHkgPSB7fTtcblxudmFyIHBhdGgkeCA9IHBhdGgkeTtcbnZhciBnbG9iYWwkTSA9IGdsb2JhbCRQO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkaDtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRmKHZhcmlhYmxlKSA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEJ1aWx0SW4kOSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aCR4W25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWwkTVtuYW1lc3BhY2VdKSA6IHBhdGgkeFtuYW1lc3BhY2VdICYmIHBhdGgkeFtuYW1lc3BhY2VdW21ldGhvZF0gfHwgZ2xvYmFsJE1bbmFtZXNwYWNlXSAmJiBnbG9iYWwkTVtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkdCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJHQoe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBnZXRCdWlsdEluJDggPSBnZXRCdWlsdEluJDk7XG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ4KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkTCA9IGdsb2JhbCRQO1xudmFyIHVzZXJBZ2VudCQzID0gZW5naW5lVXNlckFnZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwkTC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwkTC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7IC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcblxuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufSAvLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuXG5cbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkMykge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDMubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgVjhfVkVSU0lPTiQyID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJHAgPSBmYWlscyR0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG52YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyRwKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpOyAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG5cbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fCAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQyICYmIFY4X1ZFUlNJT04kMiA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wkMiA9IG5hdGl2ZVN5bWJvbDtcbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMiAmJiAhU3ltYm9sLnNoYW0gJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdsb2JhbCRLID0gZ2xvYmFsJFA7XG52YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkaDtcbnZhciBpc1Byb3RvdHlwZU9mJG0gPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcbnZhciBPYmplY3QkOSA9IGdsb2JhbCRLLk9iamVjdDtcbnZhciBpc1N5bWJvbCQzID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kNygnU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiRtKCRTeW1ib2wucHJvdG90eXBlLCBPYmplY3QkOShpdCkpO1xufTtcblxudmFyIGdsb2JhbCRKID0gZ2xvYmFsJFA7XG52YXIgU3RyaW5nJDQgPSBnbG9iYWwkSi5TdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFN0cmluZyQ0KGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBnbG9iYWwkSSA9IGdsb2JhbCRQO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkaDtcbnZhciB0cnlUb1N0cmluZyQzID0gdHJ5VG9TdHJpbmckNDtcbnZhciBUeXBlRXJyb3IkaSA9IGdsb2JhbCRJLlR5cGVFcnJvcjsgLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcblxudmFyIGFDYWxsYWJsZSQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlJGQoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IFR5cGVFcnJvciRpKHRyeVRvU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDc7IC8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcblxudmFyIGdldE1ldGhvZCQzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDYoZnVuYyk7XG59O1xuXG52YXIgZ2xvYmFsJEggPSBnbG9iYWwkUDtcbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRoO1xudmFyIGlzT2JqZWN0JGkgPSBpc09iamVjdCRqO1xudmFyIFR5cGVFcnJvciRoID0gZ2xvYmFsJEguVHlwZUVycm9yOyAvLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcblxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkYyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkaSh2YWwgPSBjYWxsJGEoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGMoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkaSh2YWwgPSBjYWxsJGEoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGMoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JGkodmFsID0gY2FsbCRhKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IkaChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkRyA9IGdsb2JhbCRQOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxudmFyIGRlZmluZVByb3BlcnR5JGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBzZXRHbG9iYWwkMSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkkZShnbG9iYWwkRywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRHW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnbG9iYWwkRiA9IGdsb2JhbCRQO1xudmFyIHNldEdsb2JhbCA9IHNldEdsb2JhbCQxO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkRltTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG4oc2hhcmVkJDQuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjEuMScsXG4gIG1vZGU6ICdwdXJlJyAsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIxLjEvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciBnbG9iYWwkRSA9IGdsb2JhbCRQO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciBPYmplY3QkOCA9IGdsb2JhbCRFLk9iamVjdDsgLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3RcblxudmFyIHRvT2JqZWN0JGUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdCQ4KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyhhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJHMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JGQgPSB0b09iamVjdCRlO1xudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkcyh7fS5oYXNPd25Qcm9wZXJ0eSk7IC8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG5cbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkZChpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkciA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaWQkMiA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckOSA9IHVuY3VycnlUaGlzJHIoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQ0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDkoKytpZCQyICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCREID0gZ2xvYmFsJFA7XG52YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGhhc093biRoID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMyA9IHVpZCQ0O1xudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxID0gc2hhcmVkJDMoJ3drcycpO1xudmFyIFN5bWJvbCQzID0gZ2xvYmFsJEQuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQzICYmIFN5bWJvbCQzWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCQzIDogU3ltYm9sJDMgJiYgU3ltYm9sJDMud2l0aG91dFNldHRlciB8fCB1aWQkMztcblxudmFyIHdlbGxLbm93blN5bWJvbCRqID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kaChXZWxsS25vd25TeW1ib2xzU3RvcmUkMSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MJDEgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG5cbiAgICBpZiAoTkFUSVZFX1NZTUJPTCQxICYmIGhhc093biRoKFN5bWJvbCQzLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPSBTeW1ib2wkM1tuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdO1xufTtcblxudmFyIGdsb2JhbCRDID0gZ2xvYmFsJFA7XG52YXIgY2FsbCQ5ID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JGggPSBpc09iamVjdCRqO1xudmFyIGlzU3ltYm9sJDIgPSBpc1N5bWJvbCQzO1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDM7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFR5cGVFcnJvciRnID0gZ2xvYmFsJEMuVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSQxID0gd2VsbEtub3duU3ltYm9sJGkoJ3RvUHJpbWl0aXZlJyk7IC8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5cbnZhciB0b1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QkaChpbnB1dCkgfHwgaXNTeW1ib2wkMihpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZCQyKGlucHV0LCBUT19QUklNSVRJVkUkMSk7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCQ5KGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkaChyZXN1bHQpIHx8IGlzU3ltYm9sJDIocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IkZyhcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuXG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkMzsgLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5cbnZhciB0b1Byb3BlcnR5S2V5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbCQxKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBnbG9iYWwkQiA9IGdsb2JhbCRQO1xudmFyIGlzT2JqZWN0JGcgPSBpc09iamVjdCRqO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkQi5kb2N1bWVudDsgLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JGcoZG9jdW1lbnQkMSkgJiYgaXNPYmplY3QkZyhkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJGggPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRvID0gZmFpbHMkdDtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDE7IC8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxuXG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGggJiYgIWZhaWxzJG8oZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIERFU0NSSVBUT1JTJGcgPSBkZXNjcmlwdG9ycztcbnZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMiA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0ID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgdG9JbmRleGVkT2JqZWN0JGEgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciB0b1Byb3BlcnR5S2V5JDMgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgaGFzT3duJGcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIElFOF9ET01fREVGSU5FJDEgPSBpZThEb21EZWZpbmU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJGcgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JGEoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDMoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuICBpZiAoaGFzT3duJGcoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCghY2FsbCQ4KHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDIuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIGZhaWxzJG4gPSBmYWlscyR0O1xudmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkaDtcbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQxID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWUgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZSA6IGlzQ2FsbGFibGUkYihkZXRlY3Rpb24pID8gZmFpbHMkbihkZXRlY3Rpb24pIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkJDEuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkJDEuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMS5QT0xZRklMTCA9ICdQJztcbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMTtcblxudmFyIHVuY3VycnlUaGlzJHEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ1ID0gYUNhbGxhYmxlJDc7XG52YXIgTkFUSVZFX0JJTkQkMSA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbnZhciBiaW5kJGMgPSB1bmN1cnJ5VGhpcyRxKHVuY3VycnlUaGlzJHEuYmluZCk7IC8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xuXG52YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUkNShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EJDEgPyBiaW5kJGMoZm4sIHRoYXQpIDogZnVuY3Rpb25cbiAgICAvKiAuLi5hcmdzICovXG4gICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkZiA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJG0gPSBmYWlscyR0OyAvLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcblxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkZiAmJiBmYWlscyRtKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBnbG9iYWwkQSA9IGdsb2JhbCRQO1xudmFyIGlzT2JqZWN0JGYgPSBpc09iamVjdCRqO1xudmFyIFN0cmluZyQzID0gZ2xvYmFsJEEuU3RyaW5nO1xudmFyIFR5cGVFcnJvciRmID0gZ2xvYmFsJEEuVHlwZUVycm9yOyAvLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5cbnZhciBhbk9iamVjdCRkID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCRmKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IkZihTdHJpbmckMyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cbnZhciBnbG9iYWwkeiA9IGdsb2JhbCRQO1xudmFyIERFU0NSSVBUT1JTJGUgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkYyA9IGFuT2JqZWN0JGQ7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIFR5cGVFcnJvciRlID0gZ2xvYmFsJHouVHlwZUVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxudmFyICRkZWZpbmVQcm9wZXJ0eSQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcblxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJGUgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRjKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRjKEF0dHJpYnV0ZXMpO1xuXG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcblxuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eSQxKE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSQxIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRjKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRjKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eSQxKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yJGUoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBERVNDUklQVE9SUyRkID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYgPSBERVNDUklQVE9SUyRkID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkNC5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBnbG9iYWwkeSA9IGdsb2JhbCRQO1xudmFyIGFwcGx5JDUgPSBmdW5jdGlvbkFwcGx5O1xudmFyIHVuY3VycnlUaGlzJHAgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkaDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNyA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBwYXRoJHcgPSBwYXRoJHk7XG52YXIgYmluZCRiID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biRmID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIHdyYXBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChOYXRpdmVDb25zdHJ1Y3Rvcikge1xuICB2YXIgV3JhcHBlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhKTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhLCBiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhLCBiLCBjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHkkNShOYXRpdmVDb25zdHJ1Y3RvciwgdGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgcmV0dXJuIFdyYXBwZXI7XG59O1xuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cblxuXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBQUk9UTyA9IG9wdGlvbnMucHJvdG87XG4gIHZhciBuYXRpdmVTb3VyY2UgPSBHTE9CQUwgPyBnbG9iYWwkeSA6IFNUQVRJQyA/IGdsb2JhbCR5W1RBUkdFVF0gOiAoZ2xvYmFsJHlbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB2YXIgdGFyZ2V0ID0gR0xPQkFMID8gcGF0aCR3IDogcGF0aCR3W1RBUkdFVF0gfHwgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocGF0aCR3LCBUQVJHRVQsIHt9KVtUQVJHRVRdO1xuICB2YXIgdGFyZ2V0UHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgdmFyIEZPUkNFRCwgVVNFX05BVElWRSwgVklSVFVBTF9QUk9UT1RZUEU7XG4gIHZhciBrZXksIHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSwgbmF0aXZlUHJvcGVydHksIHJlc3VsdFByb3BlcnR5LCBkZXNjcmlwdG9yO1xuXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7IC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuXG4gICAgVVNFX05BVElWRSA9ICFGT1JDRUQgJiYgbmF0aXZlU291cmNlICYmIGhhc093biRmKG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChVU0VfTkFUSVZFKSBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ3KG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICAgIG5hdGl2ZVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSBuYXRpdmVQcm9wZXJ0eSA9IG5hdGl2ZVNvdXJjZVtrZXldOyAvLyBleHBvcnQgbmF0aXZlIG9yIGltcGxlbWVudGF0aW9uXG5cbiAgICBzb3VyY2VQcm9wZXJ0eSA9IFVTRV9OQVRJVkUgJiYgbmF0aXZlUHJvcGVydHkgPyBuYXRpdmVQcm9wZXJ0eSA6IHNvdXJjZVtrZXldO1xuICAgIGlmIChVU0VfTkFUSVZFICYmIHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSA9PSB0eXBlb2Ygc291cmNlUHJvcGVydHkpIGNvbnRpbnVlOyAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuXG4gICAgaWYgKG9wdGlvbnMuYmluZCAmJiBVU0VfTkFUSVZFKSByZXN1bHRQcm9wZXJ0eSA9IGJpbmQkYihzb3VyY2VQcm9wZXJ0eSwgZ2xvYmFsJHkpOyAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdzIGluIHRoaXMgdmVyc2lvblxuICAgIGVsc2UgaWYgKG9wdGlvbnMud3JhcCAmJiBVU0VfTkFUSVZFKSByZXN1bHRQcm9wZXJ0eSA9IHdyYXBDb25zdHJ1Y3Rvcihzb3VyY2VQcm9wZXJ0eSk7IC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIGVsc2UgaWYgKFBST1RPICYmIGlzQ2FsbGFibGUkYShzb3VyY2VQcm9wZXJ0eSkpIHJlc3VsdFByb3BlcnR5ID0gdW5jdXJyeVRoaXMkcChzb3VyY2VQcm9wZXJ0eSk7IC8vIGRlZmF1bHQgY2FzZVxuICAgIGVsc2UgcmVzdWx0UHJvcGVydHkgPSBzb3VyY2VQcm9wZXJ0eTsgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCBzb3VyY2VQcm9wZXJ0eSAmJiBzb3VyY2VQcm9wZXJ0eS5zaGFtIHx8IHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHJlc3VsdFByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cblxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHRhcmdldCwga2V5LCByZXN1bHRQcm9wZXJ0eSk7XG5cbiAgICBpZiAoUFJPVE8pIHtcbiAgICAgIFZJUlRVQUxfUFJPVE9UWVBFID0gVEFSR0VUICsgJ1Byb3RvdHlwZSc7XG5cbiAgICAgIGlmICghaGFzT3duJGYocGF0aCR3LCBWSVJUVUFMX1BST1RPVFlQRSkpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocGF0aCR3LCBWSVJUVUFMX1BST1RPVFlQRSwge30pO1xuICAgICAgfSAvLyBleHBvcnQgdmlydHVhbCBwcm90b3R5cGUgbWV0aG9kc1xuXG5cbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkd1tWSVJUVUFMX1BST1RPVFlQRV0sIGtleSwgc291cmNlUHJvcGVydHkpOyAvLyBleHBvcnQgcmVhbCBwcm90b3R5cGUgbWV0aG9kc1xuXG4gICAgICBpZiAob3B0aW9ucy5yZWFsICYmIHRhcmdldFByb3RvdHlwZSAmJiAhdGFyZ2V0UHJvdG90eXBlW2tleV0pIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUodGFyZ2V0UHJvdG90eXBlLCBrZXksIHNvdXJjZVByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yJDEgPSBNYXRoLmZsb29yOyAvLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIHNhZmVcblxuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IChudW1iZXIgPiAwID8gZmxvb3IkMSA6IGNlaWwpKG51bWJlcik7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQzID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIG1heCQzID0gTWF0aC5tYXg7XG52YXIgbWluJDIgPSBNYXRoLm1pbjsgLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDUgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMyhpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heCQzKGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDIoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG52YXIgbWluJDEgPSBNYXRoLm1pbjsgLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcblxudmFyIHRvTGVuZ3RoJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbiQxKHRvSW50ZWdlck9ySW5maW5pdHkkMihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIHRvTGVuZ3RoID0gdG9MZW5ndGgkMTsgLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcblxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJGQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkOSA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIHRvQWJzb2x1dGVJbmRleCQ0ID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYyA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7IC8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbnZhciBjcmVhdGVNZXRob2QkNSA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkOSgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJGMoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDQoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTsgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG5cbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlOyAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDUodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDUoZmFsc2UpXG59O1xuXG52YXIgaGlkZGVuS2V5cyQ2ID0ge307XG5cbnZhciB1bmN1cnJ5VGhpcyRvID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kZSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDggPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciBpbmRleE9mJDQgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyQ1ID0gaGlkZGVuS2V5cyQ2O1xudmFyIHB1c2gkNSA9IHVuY3VycnlUaGlzJG8oW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ4KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kZShoaWRkZW5LZXlzJDUsIGtleSkgJiYgaGFzT3duJGUoTywga2V5KSAmJiBwdXNoJDUocmVzdWx0LCBrZXkpOyAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG5cblxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biRlKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkNChyZXN1bHQsIGtleSkgfHwgcHVzaCQ1KHJlc3VsdCwga2V5KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZW51bUJ1Z0tleXMkMyA9IFsnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJ107XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMzsgLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5cbnZhciBvYmplY3RLZXlzJDQgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGVudW1CdWdLZXlzJDIpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMkbiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCQ3ID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJGwgPSBmYWlscyR0O1xudmFyIG9iamVjdEtleXMkMyA9IG9iamVjdEtleXMkNDtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgdG9PYmplY3QkYyA9IHRvT2JqZWN0JGU7XG52YXIgSW5kZXhlZE9iamVjdCQyID0gaW5kZXhlZE9iamVjdDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxuXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxudmFyIGRlZmluZVByb3BlcnR5JGQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0JDYgPSB1bmN1cnJ5VGhpcyRuKFtdLmNvbmNhdCk7IC8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuXG52YXIgb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgZmFpbHMkbChmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyRjICYmICRhc3NpZ24oe1xuICAgIGI6IDFcbiAgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSRkKHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkZCh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7XG4gICAgYjogMlxuICB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7IC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zeW1ib2wgLS0gc2FmZVxuXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikge1xuICAgIEJbY2hyXSA9IGNocjtcbiAgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyQzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0JGModGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMi5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmY7XG5cbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0JDIoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQ2KG9iamVjdEtleXMkMyhTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMkMyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyRjIHx8IGNhbGwkNyhwcm9wZXJ0eUlzRW51bWVyYWJsZSwgUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkJEogPSBfZXhwb3J0O1xudmFyIGFzc2lnbiQ1ID0gb2JqZWN0QXNzaWduOyAvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbiQkSih7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduJDVcbn0sIHtcbiAgYXNzaWduOiBhc3NpZ24kNVxufSk7XG5cbnZhciBwYXRoJHYgPSBwYXRoJHk7XG52YXIgYXNzaWduJDQgPSBwYXRoJHYuT2JqZWN0LmFzc2lnbjtcblxudmFyIHBhcmVudCQxYSA9IGFzc2lnbiQ0O1xudmFyIGFzc2lnbiQzID0gcGFyZW50JDFhO1xuXG52YXIgYXNzaWduJDIgPSBhc3NpZ24kMztcblxudmFyIHVuY3VycnlUaGlzJG0gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFycmF5U2xpY2UkNSA9IHVuY3VycnlUaGlzJG0oW10uc2xpY2UpO1xuXG52YXIgZ2xvYmFsJHggPSBnbG9iYWwkUDtcbnZhciB1bmN1cnJ5VGhpcyRsID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNCA9IGFDYWxsYWJsZSQ3O1xudmFyIGlzT2JqZWN0JGUgPSBpc09iamVjdCRqO1xudmFyIGhhc093biRkID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBhcnJheVNsaWNlJDQgPSBhcnJheVNsaWNlJDU7XG52YXIgTkFUSVZFX0JJTkQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgRnVuY3Rpb24kMiA9IGdsb2JhbCR4LkZ1bmN0aW9uO1xudmFyIGNvbmNhdCQ1ID0gdW5jdXJyeVRoaXMkbChbXS5jb25jYXQpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyRsKFtdLmpvaW4pO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0JDQgPSBmdW5jdGlvbiAoQywgYXJnc0xlbmd0aCwgYXJncykge1xuICBpZiAoIWhhc093biRkKGZhY3RvcmllcywgYXJnc0xlbmd0aCkpIHtcbiAgICBmb3IgKHZhciBsaXN0ID0gW10sIGkgPSAwOyBpIDwgYXJnc0xlbmd0aDsgaSsrKSBsaXN0W2ldID0gJ2FbJyArIGkgKyAnXSc7XG5cbiAgICBmYWN0b3JpZXNbYXJnc0xlbmd0aF0gPSBGdW5jdGlvbiQyKCdDLGEnLCAncmV0dXJuIG5ldyBDKCcgKyBqb2luKGxpc3QsICcsJykgKyAnKScpO1xuICB9XG5cbiAgcmV0dXJuIGZhY3Rvcmllc1thcmdzTGVuZ3RoXShDLCBhcmdzKTtcbn07IC8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5cblxudmFyIGZ1bmN0aW9uQmluZCA9IE5BVElWRV9CSU5EID8gRnVuY3Rpb24kMi5iaW5kIDogZnVuY3Rpb24gYmluZCh0aGF0XG4vKiAsIC4uLmFyZ3MgKi9cbikge1xuICB2YXIgRiA9IGFDYWxsYWJsZSQ0KHRoaXMpO1xuICB2YXIgUHJvdG90eXBlID0gRi5wcm90b3R5cGU7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UkNChhcmd1bWVudHMsIDEpO1xuXG4gIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb25cbiAgICAvKiBhcmdzLi4uICovXG4gIGJvdW5kKCkge1xuICAgIHZhciBhcmdzID0gY29uY2F0JDUocGFydEFyZ3MsIGFycmF5U2xpY2UkNChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kRnVuY3Rpb24gPyBjb25zdHJ1Y3QkNChGLCBhcmdzLmxlbmd0aCwgYXJncykgOiBGLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9O1xuXG4gIGlmIChpc09iamVjdCRlKFByb3RvdHlwZSkpIGJvdW5kRnVuY3Rpb24ucHJvdG90eXBlID0gUHJvdG90eXBlO1xuICByZXR1cm4gYm91bmRGdW5jdGlvbjtcbn07XG5cbnZhciAkJEkgPSBfZXhwb3J0O1xudmFyIGJpbmQkYSA9IGZ1bmN0aW9uQmluZDsgLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblxuJCRJKHtcbiAgdGFyZ2V0OiAnRnVuY3Rpb24nLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBGdW5jdGlvbi5iaW5kICE9PSBiaW5kJGFcbn0sIHtcbiAgYmluZDogYmluZCRhXG59KTtcblxudmFyIHBhdGgkdSA9IHBhdGgkeTtcblxudmFyIGVudHJ5VmlydHVhbCRsID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SKSB7XG4gIHJldHVybiBwYXRoJHVbQ09OU1RSVUNUT1IgKyAnUHJvdG90eXBlJ107XG59O1xuXG52YXIgZW50cnlWaXJ0dWFsJGsgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBiaW5kJDkgPSBlbnRyeVZpcnR1YWwkaygnRnVuY3Rpb24nKS5iaW5kO1xuXG52YXIgaXNQcm90b3R5cGVPZiRsID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkaCA9IGJpbmQkOTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG52YXIgYmluZCQ4ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5iaW5kO1xuICByZXR1cm4gaXQgPT09IEZ1bmN0aW9uUHJvdG90eXBlJDEgfHwgaXNQcm90b3R5cGVPZiRsKEZ1bmN0aW9uUHJvdG90eXBlJDEsIGl0KSAmJiBvd24gPT09IEZ1bmN0aW9uUHJvdG90eXBlJDEuYmluZCA/IG1ldGhvZCRoIDogb3duO1xufTtcblxudmFyIHBhcmVudCQxOSA9IGJpbmQkODtcbnZhciBiaW5kJDcgPSBwYXJlbnQkMTk7XG5cbnZhciBiaW5kJDYgPSBiaW5kJDc7XG5cbi8qKlxyXG4gKiBEcmF3IGEgY2lyY2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAqL1xuZnVuY3Rpb24gZHJhd0NpcmNsZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgc3F1YXJlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzcXVhcmUuXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3U3F1YXJlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KHggLSByLCB5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUgc3RhbmRpbmcgb24gYSBzaWRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VxdWlsYXRlcmFsX3RyaWFuZ2xlXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTsgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG5cbiAgciAqPSAxLjE1O1xuICB5ICs9IDAuMjc1ICogcjtcbiAgdmFyIHMgPSByICogMjtcbiAgdmFyIHMyID0gcyAvIDI7XG4gIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG5cbiAgdmFyIGggPSBNYXRoLnNxcnQocyAqIHMgLSBzMiAqIHMyKTsgLy8gaGVpZ2h0XG5cbiAgY3R4Lm1vdmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICBjdHgubGluZVRvKHggKyBzMiwgeSArIGlyKTtcbiAgY3R4LmxpbmVUbyh4IC0gczIsIHkgKyBpcik7XG4gIGN0eC5saW5lVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUgc3RhbmRpbmcgb24gYSB2ZXJ0ZXguXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIGxlbmd0aCBvZiB0aGUgc2lkZXMuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZURvd24oY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTsgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG5cbiAgciAqPSAxLjE1O1xuICB5IC09IDAuMjc1ICogcjtcbiAgdmFyIHMgPSByICogMjtcbiAgdmFyIHMyID0gcyAvIDI7XG4gIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG5cbiAgdmFyIGggPSBNYXRoLnNxcnQocyAqIHMgLSBzMiAqIHMyKTsgLy8gaGVpZ2h0XG5cbiAgY3R4Lm1vdmVUbyh4LCB5ICsgKGggLSBpcikpO1xuICBjdHgubGluZVRvKHggKyBzMiwgeSAtIGlyKTtcbiAgY3R4LmxpbmVUbyh4IC0gczIsIHkgLSBpcik7XG4gIGN0eC5saW5lVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBzdGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyLlxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd1N0YXIoY3R4LCB4LCB5LCByKSB7XG4gIC8vIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2xhYnMvaHRtbDUtY2FudmFzLXN0YXItc3Bpbm5lci9cbiAgY3R4LmJlZ2luUGF0aCgpOyAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcblxuICByICo9IDAuODI7XG4gIHkgKz0gMC4xICogcjtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDEwOyBuKyspIHtcbiAgICB2YXIgcmFkaXVzID0gbiAlIDIgPT09IDAgPyByICogMS4zIDogciAqIDAuNTtcbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMgKiBNYXRoLnNpbihuICogMiAqIE1hdGguUEkgLyAxMCksIHkgLSByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyAxMCkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBkaWFtb25kLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBkaWFtb25kLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3RGlhbW9uZChjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubGluZVRvKHgsIHkgKyByKTtcbiAgY3R4LmxpbmVUbyh4ICsgciwgeSk7XG4gIGN0eC5saW5lVG8oeCwgeSAtIHIpO1xuICBjdHgubGluZVRvKHggLSByLCB5KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cclxuICogQHBhcmFtIHIgLSBUaGUgcmFkaXVzIG9mIHRoZSBjb3JuZXJzLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNTU1MTIvaG93LXRvLWRyYXctYS1yb3VuZGVkLXJlY3RhbmdsZS1vbi1odG1sLWNhbnZhc1xyXG4gKi9cblxuZnVuY3Rpb24gZHJhd1JvdW5kUmVjdChjdHgsIHgsIHksIHcsIGgsIHIpIHtcbiAgdmFyIHIyZCA9IE1hdGguUEkgLyAxODA7XG5cbiAgaWYgKHcgLSAyICogciA8IDApIHtcbiAgICByID0gdyAvIDI7XG4gIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeFxuXG5cbiAgaWYgKGggLSAyICogciA8IDApIHtcbiAgICByID0gaCAvIDI7XG4gIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeVxuXG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHggKyByLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuICBjdHguYXJjKHggKyB3IC0gciwgeSArIHIsIHIsIHIyZCAqIDI3MCwgcjJkICogMzYwLCBmYWxzZSk7XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gIGN0eC5hcmMoeCArIHcgLSByLCB5ICsgaCAtIHIsIHIsIDAsIHIyZCAqIDkwLCBmYWxzZSk7XG4gIGN0eC5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgY3R4LmFyYyh4ICsgciwgeSArIGggLSByLCByLCByMmQgKiA5MCwgcjJkICogMTgwLCBmYWxzZSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICBjdHguYXJjKHggKyByLCB5ICsgciwgciwgcjJkICogMTgwLCByMmQgKiAyNzAsIGZhbHNlKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gZWxsaXBzZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSBlbGxpcHNlLlxyXG4gKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2UuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xyXG4gKlxyXG4gKiBQb3N0Zml4ICdfdmlzJyBhZGRlZCB0byBkaXNjZXJuIGl0IGZyb20gc3RhbmRhcmQgbWV0aG9kIGVsbGlwc2UoKS5cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdFbGxpcHNlKGN0eCwgeCwgeSwgdywgaCkge1xuICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICBveCA9IHcgLyAyICoga2FwcGEsXG4gICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gIG95ID0gaCAvIDIgKiBrYXBwYSxcbiAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gIHhlID0geCArIHcsXG4gICAgICAvLyB4LWVuZFxuICB5ZSA9IHkgKyBoLFxuICAgICAgLy8geS1lbmRcbiAgeG0gPSB4ICsgdyAvIDIsXG4gICAgICAvLyB4LW1pZGRsZVxuICB5bSA9IHkgKyBoIC8gMjsgLy8geS1taWRkbGVcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCwgeW0pO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGlzb21ldHJpYyBjeWxpbmRlci5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSBkYXRhYmFzZS5cclxuICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSBkYXRhYmFzZS5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3RGF0YWJhc2UoY3R4LCB4LCB5LCB3LCBoKSB7XG4gIHZhciBmID0gMSAvIDM7XG4gIHZhciB3RWxsaXBzZSA9IHc7XG4gIHZhciBoRWxsaXBzZSA9IGggKiBmO1xuICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICBveCA9IHdFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICBveSA9IGhFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgeGUgPSB4ICsgd0VsbGlwc2UsXG4gICAgICAvLyB4LWVuZFxuICB5ZSA9IHkgKyBoRWxsaXBzZSxcbiAgICAgIC8vIHktZW5kXG4gIHhtID0geCArIHdFbGxpcHNlIC8gMixcbiAgICAgIC8vIHgtbWlkZGxlXG4gIHltID0geSArIGhFbGxpcHNlIC8gMixcbiAgICAgIC8vIHktbWlkZGxlXG4gIHltYiA9IHkgKyAoaCAtIGhFbGxpcHNlIC8gMiksXG4gICAgICAvLyB5LW1pZGxsZSwgYm90dG9tIGVsbGlwc2VcbiAgeWViID0geSArIGg7IC8vIHktZW5kLCBib3R0b20gZWxsaXBzZVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ZSwgeW0pO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gIGN0eC5saW5lVG8oeGUsIHltYik7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bWIgKyBveSwgeG0gKyBveCwgeWViLCB4bSwgeWViKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWViLCB4LCB5bWIgKyBveSwgeCwgeW1iKTtcbiAgY3R4LmxpbmVUbyh4LCB5bSk7XG59XG4vKipcclxuICogRHJhdyBhIGRhc2hlZCBsaW5lLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBzdGFydCBwb3NpdGlvbiBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBzdGFydCBwb3NpdGlvbiBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0geDIgLSBUaGUgZW5kIHBvc2l0aW9uIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5MiAtIFRoZSBlbmQgcG9zaXRpb24gb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHBhdHRlcm4gLSBMaXN0IG9mIGxlbmd0aHMgc3RhcnRpbmcgd2l0aCBsaW5lIGFuZCB0aGVuIGFsdGVybmF0aW5nIGJldHdlZW4gc3BhY2UgYW5kIGxpbmUuXHJcbiAqIEBhdXRob3IgRGF2aWQgSm9yZGFuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGRhdGUgMjAxMi0wOC0wOFxyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ1NzY3MjQvZG90dGVkLXN0cm9rZS1pbi1jYW52YXNcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeDIsIHkyLCBwYXR0ZXJuKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgdmFyIGR4ID0geDIgLSB4O1xuICB2YXIgZHkgPSB5MiAtIHk7XG4gIHZhciBzbG9wZSA9IGR5IC8gZHg7XG4gIHZhciBkaXN0UmVtYWluaW5nID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHBhdHRlcm5JbmRleCA9IDA7XG4gIHZhciBkcmF3ID0gdHJ1ZTtcbiAgdmFyIHhTdGVwID0gMDtcbiAgdmFyIGRhc2hMZW5ndGggPSArcGF0dGVyblswXTtcblxuICB3aGlsZSAoZGlzdFJlbWFpbmluZyA+PSAwLjEpIHtcbiAgICBkYXNoTGVuZ3RoID0gK3BhdHRlcm5bcGF0dGVybkluZGV4KysgJSBwYXR0ZXJuTGVuZ3RoXTtcblxuICAgIGlmIChkYXNoTGVuZ3RoID4gZGlzdFJlbWFpbmluZykge1xuICAgICAgZGFzaExlbmd0aCA9IGRpc3RSZW1haW5pbmc7XG4gICAgfVxuXG4gICAgeFN0ZXAgPSBNYXRoLnNxcnQoZGFzaExlbmd0aCAqIGRhc2hMZW5ndGggLyAoMSArIHNsb3BlICogc2xvcGUpKTtcbiAgICB4U3RlcCA9IGR4IDwgMCA/IC14U3RlcCA6IHhTdGVwO1xuICAgIHggKz0geFN0ZXA7XG4gICAgeSArPSBzbG9wZSAqIHhTdGVwO1xuXG4gICAgaWYgKGRyYXcgPT09IHRydWUpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuXG4gICAgZGlzdFJlbWFpbmluZyAtPSBkYXNoTGVuZ3RoO1xuICAgIGRyYXcgPSAhZHJhdztcbiAgfVxufVxuLyoqXHJcbiAqIERyYXcgYSBoZXhhZ29uLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBUaGUgcmFkaXVzIG9mIHRoZSBoZXhhZ29uLlxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0hleGFnb24oY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgdmFyIHNpZGVzID0gNjtcbiAgdmFyIGEgPSBNYXRoLlBJICogMiAvIHNpZGVzO1xuICBjdHgubW92ZVRvKHggKyByLCB5KTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICBjdHgubGluZVRvKHggKyByICogTWF0aC5jb3MoYSAqIGkpLCB5ICsgciAqIE1hdGguc2luKGEgKiBpKSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG52YXIgc2hhcGVNYXAgPSB7XG4gIGNpcmNsZTogZHJhd0NpcmNsZSxcbiAgZGFzaGVkTGluZTogZHJhd0Rhc2hlZExpbmUsXG4gIGRhdGFiYXNlOiBkcmF3RGF0YWJhc2UsXG4gIGRpYW1vbmQ6IGRyYXdEaWFtb25kLFxuICBlbGxpcHNlOiBkcmF3RWxsaXBzZSxcbiAgZWxsaXBzZV92aXM6IGRyYXdFbGxpcHNlLFxuICBoZXhhZ29uOiBkcmF3SGV4YWdvbixcbiAgcm91bmRSZWN0OiBkcmF3Um91bmRSZWN0LFxuICBzcXVhcmU6IGRyYXdTcXVhcmUsXG4gIHN0YXI6IGRyYXdTdGFyLFxuICB0cmlhbmdsZTogZHJhd1RyaWFuZ2xlLFxuICB0cmlhbmdsZURvd246IGRyYXdUcmlhbmdsZURvd25cbn07XG4vKipcclxuICogUmV0dXJucyBlaXRoZXIgY3VzdG9tIG9yIG5hdGl2ZSBkcmF3aW5nIGZ1bmN0aW9uIGJhc2Ugb24gc3VwcGxpZWQgbmFtZS5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uIEVpdGhlciB0aGUgbmFtZSBvZiBhXHJcbiAqIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBwcm9wZXJ0eSBvciBhbiBleHBvcnQgZnJvbSBzaGFwZXMudHMgd2l0aG91dCB0aGVcclxuICogZHJhdyBwcmVmaXguXHJcbiAqIEByZXR1cm5zIFRoZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciByZW5kZXJpbmcuIEluIGNhc2Ugb2YgbmF0aXZlXHJcbiAqIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBmdW5jdGlvbiB0aGUgQVBJIGlzIG5vcm1hbGl6ZWQgdG9cclxuICogYChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgLi4ub3JpZ2luYWxBcmdzKSA9PiB2b2lkYC5cclxuICovXG5cbmZ1bmN0aW9uIGdldFNoYXBlKG5hbWUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzaGFwZU1hcCwgbmFtZSkpIHtcbiAgICByZXR1cm4gc2hhcGVNYXBbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVbbmFtZV0uY2FsbChjdHgsIGFyZ3MpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKHJlZiA9PT0gdm9pZCAwKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgY3NzXzI0OHokNiA9IFwiLnZpcy1vdmVybGF5IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMHB4O1xcbiAgcmlnaHQ6IDBweDtcXG4gIGJvdHRvbTogMHB4O1xcbiAgbGVmdDogMHB4O1xcblxcbiAgLyogTXVzdCBiZSBkaXNwbGF5ZWQgYWJvdmUgZm9yIGV4YW1wbGUgc2VsZWN0ZWQgVGltZWxpbmUgaXRlbXMgKi9cXG4gIHotaW5kZXg6IDEwO1xcbn1cXG5cXG4udmlzLWFjdGl2ZSB7XFxuICBib3gtc2hhZG93OiAwIDAgMTBweCAjODZkNWY4O1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDYpO1xuXG52YXIgY3NzXzI0OHokNSA9IFwiLyogb3ZlcnJpZGUgc29tZSBib290c3RyYXAgc3R5bGVzIHNjcmV3aW5nIHVwIHRoZSB0aW1lbGluZXMgY3NzICovXFxuXFxuLnZpcyBbY2xhc3MqPVxcXCJzcGFuXFxcIl0ge1xcbiAgbWluLWhlaWdodDogMDtcXG4gIHdpZHRoOiBhdXRvO1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDUpO1xuXG52YXIgY3NzXzI0OHokNCA9IFwiZGl2LnZpcy1jb2xvci1waWNrZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwcHg7XFxuICBsZWZ0OiAzMHB4O1xcbiAgbWFyZ2luLXRvcDogLTE0MHB4O1xcbiAgbWFyZ2luLWxlZnQ6IDMwcHg7XFxuICB3aWR0aDogMzEwcHg7XFxuICBoZWlnaHQ6IDQ0NHB4O1xcbiAgei1pbmRleDogMTtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuNSkgMHB4IDBweCAxMHB4IDBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1hcnJvdyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDE0N3B4O1xcbiAgbGVmdDogNXB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWFycm93OjphZnRlcixcXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWFycm93OjpiZWZvcmUge1xcbiAgcmlnaHQ6IDEwMCU7XFxuICB0b3A6IDUwJTtcXG4gIGJvcmRlcjogc29saWQgdHJhbnNwYXJlbnQ7XFxuICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICBoZWlnaHQ6IDA7XFxuICB3aWR0aDogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWFycm93OmFmdGVyIHtcXG4gIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwKTtcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogI2ZmZmZmZjtcXG4gIGJvcmRlci13aWR0aDogMzBweDtcXG4gIG1hcmdpbi10b3A6IC0zMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWNvbG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAyODlweDtcXG4gIGhlaWdodDogMjg5cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYnJpZ2h0bmVzcyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDMxM3B4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLW9wYWNpdHkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzNTBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1zZWxlY3RvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEzN3B4O1xcbiAgbGVmdDogMTM3cHg7XFxuICB3aWR0aDogMTVweDtcXG4gIGhlaWdodDogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZmZmZmZmO1xcbiAgYmFja2dyb3VuZDogIzRjNGM0YzsgLyogT2xkIGJyb3dzZXJzICovXFxuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjNGM0YzRjIDAlLFxcbiAgICAjNTk1OTU5IDEyJSxcXG4gICAgIzY2NjY2NiAyNSUsXFxuICAgICM0NzQ3NDcgMzklLFxcbiAgICAjMmMyYzJjIDUwJSxcXG4gICAgIzAwMDAwMCA1MSUsXFxuICAgICMxMTExMTEgNjAlLFxcbiAgICAjMmIyYjJiIDc2JSxcXG4gICAgIzFjMWMxYyA5MSUsXFxuICAgICMxMzEzMTMgMTAwJVxcbiAgKTsgLyogRkYzLjYrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcbiAgICBsaW5lYXIsXFxuICAgIGxlZnQgdG9wLFxcbiAgICBsZWZ0IGJvdHRvbSxcXG4gICAgY29sb3Itc3RvcCgwJSwgIzRjNGM0YyksXFxuICAgIGNvbG9yLXN0b3AoMTIlLCAjNTk1OTU5KSxcXG4gICAgY29sb3Itc3RvcCgyNSUsICM2NjY2NjYpLFxcbiAgICBjb2xvci1zdG9wKDM5JSwgIzQ3NDc0NyksXFxuICAgIGNvbG9yLXN0b3AoNTAlLCAjMmMyYzJjKSxcXG4gICAgY29sb3Itc3RvcCg1MSUsICMwMDAwMDApLFxcbiAgICBjb2xvci1zdG9wKDYwJSwgIzExMTExMSksXFxuICAgIGNvbG9yLXN0b3AoNzYlLCAjMmIyYjJiKSxcXG4gICAgY29sb3Itc3RvcCg5MSUsICMxYzFjMWMpLFxcbiAgICBjb2xvci1zdG9wKDEwMCUsICMxMzEzMTMpXFxuICApOyAvKiBDaHJvbWUsU2FmYXJpNCsgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICM0YzRjNGMgMCUsXFxuICAgICM1OTU5NTkgMTIlLFxcbiAgICAjNjY2NjY2IDI1JSxcXG4gICAgIzQ3NDc0NyAzOSUsXFxuICAgICMyYzJjMmMgNTAlLFxcbiAgICAjMDAwMDAwIDUxJSxcXG4gICAgIzExMTExMSA2MCUsXFxuICAgICMyYjJiMmIgNzYlLFxcbiAgICAjMWMxYzFjIDkxJSxcXG4gICAgIzEzMTMxMyAxMDAlXFxuICApOyAvKiBDaHJvbWUxMCssU2FmYXJpNS4xKyAqL1xcbiAgYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICM0YzRjNGMgMCUsXFxuICAgICM1OTU5NTkgMTIlLFxcbiAgICAjNjY2NjY2IDI1JSxcXG4gICAgIzQ3NDc0NyAzOSUsXFxuICAgICMyYzJjMmMgNTAlLFxcbiAgICAjMDAwMDAwIDUxJSxcXG4gICAgIzExMTExMSA2MCUsXFxuICAgICMyYjJiMmIgNzYlLFxcbiAgICAjMWMxYzFjIDkxJSxcXG4gICAgIzEzMTMxMyAxMDAlXFxuICApOyAvKiBPcGVyYSAxMS4xMCsgKi9cXG4gIGJhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzRjNGM0YyAwJSxcXG4gICAgIzU5NTk1OSAxMiUsXFxuICAgICM2NjY2NjYgMjUlLFxcbiAgICAjNDc0NzQ3IDM5JSxcXG4gICAgIzJjMmMyYyA1MCUsXFxuICAgICMwMDAwMDAgNTElLFxcbiAgICAjMTExMTExIDYwJSxcXG4gICAgIzJiMmIyYiA3NiUsXFxuICAgICMxYzFjMWMgOTElLFxcbiAgICAjMTMxMzEzIDEwMCVcXG4gICk7IC8qIElFMTArICovXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxuICAgIHRvIGJvdHRvbSxcXG4gICAgIzRjNGM0YyAwJSxcXG4gICAgIzU5NTk1OSAxMiUsXFxuICAgICM2NjY2NjYgMjUlLFxcbiAgICAjNDc0NzQ3IDM5JSxcXG4gICAgIzJjMmMyYyA1MCUsXFxuICAgICMwMDAwMDAgNTElLFxcbiAgICAjMTExMTExIDYwJSxcXG4gICAgIzJiMmIyYiA3NiUsXFxuICAgICMxYzFjMWMgOTElLFxcbiAgICAjMTMxMzEzIDEwMCVcXG4gICk7IC8qIFczQyAqL1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoIHN0YXJ0Q29sb3JzdHI9JyM0YzRjNGMnLCBlbmRDb2xvcnN0cj0nIzEzMTMxMycsR3JhZGllbnRUeXBlPTAgKTsgLyogSUU2LTkgKi9cXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1uZXctY29sb3Ige1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDE0MHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgdG9wOiAzODBweDtcXG4gIGxlZnQ6IDE1OXB4O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBwYWRkaW5nLXJpZ2h0OiAycHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWluaXRpYWwtY29sb3Ige1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDE0MHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgdG9wOiAzODBweDtcXG4gIGxlZnQ6IDEwcHg7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWxhYmVsIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIGxlZnQ6IDEwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtbGFiZWwudmlzLWJyaWdodG5lc3Mge1xcbiAgdG9wOiAzMDBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1sYWJlbC52aXMtb3BhY2l0eSB7XFxuICB0b3A6IDMzOHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWJ1dHRvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogNjhweDtcXG4gIGhlaWdodDogMjVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxuICB0b3A6IDQxMHB4O1xcbiAgYm9yZGVyOiAycHggc29saWQgI2Q5ZDlkOTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjc7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYnV0dG9uLnZpcy1jYW5jZWwge1xcbiAgLypib3JkZXI6MnB4IHNvbGlkICNmZjRlMzM7Ki9cXG4gIC8qYmFja2dyb3VuZC1jb2xvcjogI2ZmNzc2MTsqL1xcbiAgbGVmdDogNXB4O1xcbn1cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWJ1dHRvbi52aXMtbG9hZCB7XFxuICAvKmJvcmRlcjoycHggc29saWQgI2ExNTNlNjsqL1xcbiAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjY2I4ZGZmOyovXFxuICBsZWZ0OiA4MnB4O1xcbn1cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWJ1dHRvbi52aXMtYXBwbHkge1xcbiAgLypib3JkZXI6MnB4IHNvbGlkICM0NTg4ZTY7Ki9cXG4gIC8qYmFja2dyb3VuZC1jb2xvcjogIzgyYjZmZjsqL1xcbiAgbGVmdDogMTU5cHg7XFxufVxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYnV0dG9uLnZpcy1zYXZlIHtcXG4gIC8qYm9yZGVyOjJweCBzb2xpZCAjNDVlNjU1OyovXFxuICAvKmJhY2tncm91bmQtY29sb3I6ICM2ZGZmN2M7Ki9cXG4gIGxlZnQ6IDIzNnB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBpbnB1dC52aXMtcmFuZ2Uge1xcbiAgd2lkdGg6IDI5MHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbn1cXG5cXG4vKiBUT0RPOiBpcyB0aGlzIHJlZHVuZGFudD9cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBpbnB1dC52aXMtcmFuZ2UtYnJpZ2h0bmVzcyB7XFxuICB3aWR0aDogMjg5cHggIWltcG9ydGFudDtcXG59XFxuXFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgaW5wdXQudmlzLXNhdHVyYXRpb24tcmFuZ2Uge1xcbiAgd2lkdGg6IDI4OXB4ICFpbXBvcnRhbnQ7XFxufSovXFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eiQ0KTtcblxudmFyIGNzc18yNDh6JDMgPSBcImRpdi52aXMtY29uZmlndXJhdGlvbiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiA3MDBweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLXdyYXBwZXI6OmFmdGVyIHtcXG4gIGNsZWFyOiBib3RoO1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiA0OTVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjZjdmOGZhO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgbWFyZ2luLXRvcDogMjBweDtcXG4gIGxlZnQ6IDEwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctYnV0dG9uIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDQ5NXB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjhmYTtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICNjZWNlZDA7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcbiAgbGVmdDogMTBweDtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogMzBweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctYnV0dG9uLmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0NTg4ZTY7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjMjE0MzczO1xcbiAgY29sb3I6ICNmZmZmZmY7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWl0ZW0ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA0OTVweDtcXG4gIGhlaWdodDogMjVweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctaXRlbS52aXMtY29uZmlnLXMyIHtcXG4gIGxlZnQ6IDEwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmOGZhO1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWl0ZW0udmlzLWNvbmZpZy1zMyB7XFxuICBsZWZ0OiAyMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U0ZTlmMDtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1pdGVtLnZpcy1jb25maWctczQge1xcbiAgbGVmdDogMzBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjZmQ4ZTY7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctaGVhZGVyIHtcXG4gIGZvbnQtc2l6ZTogMThweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1sYWJlbCB7XFxuICB3aWR0aDogMTIwcHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctbGFiZWwudmlzLWNvbmZpZy1zMyB7XFxuICB3aWR0aDogMTEwcHg7XFxufVxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWxhYmVsLnZpcy1jb25maWctczQge1xcbiAgd2lkdGg6IDEwMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1jb2xvckJsb2NrIHtcXG4gIHRvcDogMXB4O1xcbiAgd2lkdGg6IDMwcHg7XFxuICBoZWlnaHQ6IDE5cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjNDQ0NDQ0O1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgcGFkZGluZzogMHB4O1xcbiAgbWFyZ2luOiAwcHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctY2hlY2tib3gge1xcbiAgbGVmdDogLTVweDtcXG59XFxuXFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZWlucHV0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogLTVweDtcXG4gIHdpZHRoOiA2MHB4O1xcbiAgLypoZWlnaHQ6MTNweDsqL1xcbiAgcGFkZGluZzogMXB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2Uge1xcbiAgLypyZW1vdmVzIGRlZmF1bHQgd2Via2l0IHN0eWxlcyovXFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuXFxuICAvKmZpeCBmb3IgRkYgdW5hYmxlIHRvIGFwcGx5IGZvY3VzIHN0eWxlIGJ1ZyAqL1xcbiAgYm9yZGVyOiAwcHggc29saWQgd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcblxcbiAgLypyZXF1aXJlZCBmb3IgcHJvcGVyIHRyYWNrIHNpemluZyBpbiBGRiovXFxuICB3aWR0aDogMzAwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi13ZWJraXQtc2xpZGVyLXJ1bm5hYmxlLXRyYWNrIHtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIGhlaWdodDogNXB4O1xcbiAgYmFja2dyb3VuZDogI2RlZGVkZTsgLyogT2xkIGJyb3dzZXJzICovXFxuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICNkZWRlZGUgMCUsICNjOGM4YzggOTklKTsgLyogRkYzLjYrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcbiAgICBsaW5lYXIsXFxuICAgIGxlZnQgdG9wLFxcbiAgICBsZWZ0IGJvdHRvbSxcXG4gICAgY29sb3Itc3RvcCgwJSwgI2RlZGVkZSksXFxuICAgIGNvbG9yLXN0b3AoOTklLCAjYzhjOGM4KVxcbiAgKTsgLyogQ2hyb21lLFNhZmFyaTQrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZGVkZWRlIDAlLFxcbiAgICAjYzhjOGM4IDk5JVxcbiAgKTsgLyogQ2hyb21lMTArLFNhZmFyaTUuMSsgKi9cXG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZGVkZWRlIDAlLFxcbiAgICAjYzhjOGM4IDk5JVxcbiAgKTsgLyogT3BlcmEgMTEuMTArICovXFxuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgI2RlZGVkZSAwJSwgI2M4YzhjOCA5OSUpOyAvKiBJRTEwKyAqL1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgI2RlZGVkZSAwJSwgI2M4YzhjOCA5OSUpOyAvKiBXM0MgKi9cXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KCBzdGFydENvbG9yc3RyPScjZGVkZWRlJywgZW5kQ29sb3JzdHI9JyNjOGM4YzgnLEdyYWRpZW50VHlwZT0wICk7IC8qIElFNi05ICovXFxuXFxuICBib3JkZXI6IDFweCBzb2xpZCAjOTk5OTk5O1xcbiAgYm94LXNoYWRvdzogI2FhYWFhYSAwcHggMHB4IDNweCAwcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi13ZWJraXQtc2xpZGVyLXRodW1iIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMxNDMzNGI7XFxuICBoZWlnaHQ6IDE3cHg7XFxuICB3aWR0aDogMTdweDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGJhY2tncm91bmQ6ICMzODc2YzI7IC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjMzg3NmMyIDAlLCAjMzg1MzgwIDEwMCUpOyAvKiBGRjMuNisgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxuICAgIGxpbmVhcixcXG4gICAgbGVmdCB0b3AsXFxuICAgIGxlZnQgYm90dG9tLFxcbiAgICBjb2xvci1zdG9wKDAlLCAjMzg3NmMyKSxcXG4gICAgY29sb3Itc3RvcCgxMDAlLCAjMzg1MzgwKVxcbiAgKTsgLyogQ2hyb21lLFNhZmFyaTQrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjMzg3NmMyIDAlLFxcbiAgICAjMzg1MzgwIDEwMCVcXG4gICk7IC8qIENocm9tZTEwKyxTYWZhcmk1LjErICovXFxuICBiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzM4NzZjMiAwJSxcXG4gICAgIzM4NTM4MCAxMDAlXFxuICApOyAvKiBPcGVyYSAxMS4xMCsgKi9cXG4gIGJhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjMzg3NmMyIDAlLCAjMzg1MzgwIDEwMCUpOyAvKiBJRTEwKyAqL1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgIzM4NzZjMiAwJSwgIzM4NTM4MCAxMDAlKTsgLyogVzNDICovXFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj0nIzM4NzZjMicsIGVuZENvbG9yc3RyPScjMzg1MzgwJyxHcmFkaWVudFR5cGU9MCApOyAvKiBJRTYtOSAqL1xcbiAgYm94LXNoYWRvdzogIzExMTkyNyAwcHggMHB4IDFweCAwcHg7XFxuICBtYXJnaW4tdG9wOiAtN3B4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Zm9jdXM6Oi13ZWJraXQtc2xpZGVyLXJ1bm5hYmxlLXRyYWNrIHtcXG4gIGJhY2tncm91bmQ6ICM5ZDlkOWQ7IC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjOWQ5ZDlkIDAlLCAjYzhjOGM4IDk5JSk7IC8qIEZGMy42KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXG4gICAgbGluZWFyLFxcbiAgICBsZWZ0IHRvcCxcXG4gICAgbGVmdCBib3R0b20sXFxuICAgIGNvbG9yLXN0b3AoMCUsICM5ZDlkOWQpLFxcbiAgICBjb2xvci1zdG9wKDk5JSwgI2M4YzhjOClcXG4gICk7IC8qIENocm9tZSxTYWZhcmk0KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzlkOWQ5ZCAwJSxcXG4gICAgI2M4YzhjOCA5OSVcXG4gICk7IC8qIENocm9tZTEwKyxTYWZhcmk1LjErICovXFxuICBiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzlkOWQ5ZCAwJSxcXG4gICAgI2M4YzhjOCA5OSVcXG4gICk7IC8qIE9wZXJhIDExLjEwKyAqL1xcbiAgYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICM5ZDlkOWQgMCUsICNjOGM4YzggOTklKTsgLyogSUUxMCsgKi9cXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICM5ZDlkOWQgMCUsICNjOGM4YzggOTklKTsgLyogVzNDICovXFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj0nIzlkOWQ5ZCcsIGVuZENvbG9yc3RyPScjYzhjOGM4JyxHcmFkaWVudFR5cGU9MCApOyAvKiBJRTYtOSAqL1xcbn1cXG5cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotbW96LXJhbmdlLXRyYWNrIHtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIGhlaWdodDogMTBweDtcXG4gIGJhY2tncm91bmQ6ICNkZWRlZGU7IC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjZGVkZWRlIDAlLCAjYzhjOGM4IDk5JSk7IC8qIEZGMy42KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXG4gICAgbGluZWFyLFxcbiAgICBsZWZ0IHRvcCxcXG4gICAgbGVmdCBib3R0b20sXFxuICAgIGNvbG9yLXN0b3AoMCUsICNkZWRlZGUpLFxcbiAgICBjb2xvci1zdG9wKDk5JSwgI2M4YzhjOClcXG4gICk7IC8qIENocm9tZSxTYWZhcmk0KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2RlZGVkZSAwJSxcXG4gICAgI2M4YzhjOCA5OSVcXG4gICk7IC8qIENocm9tZTEwKyxTYWZhcmk1LjErICovXFxuICBiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2RlZGVkZSAwJSxcXG4gICAgI2M4YzhjOCA5OSVcXG4gICk7IC8qIE9wZXJhIDExLjEwKyAqL1xcbiAgYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICNkZWRlZGUgMCUsICNjOGM4YzggOTklKTsgLyogSUUxMCsgKi9cXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICNkZWRlZGUgMCUsICNjOGM4YzggOTklKTsgLyogVzNDICovXFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj0nI2RlZGVkZScsIGVuZENvbG9yc3RyPScjYzhjOGM4JyxHcmFkaWVudFR5cGU9MCApOyAvKiBJRTYtOSAqL1xcblxcbiAgYm9yZGVyOiAxcHggc29saWQgIzk5OTk5OTtcXG4gIGJveC1zaGFkb3c6ICNhYWFhYWEgMHB4IDBweCAzcHggMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotbW96LXJhbmdlLXRodW1iIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGhlaWdodDogMTZweDtcXG4gIHdpZHRoOiAxNnB4O1xcblxcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZDogIzM4NTM4MDtcXG59XFxuXFxuLypoaWRlIHRoZSBvdXRsaW5lIGJlaGluZCB0aGUgYm9yZGVyKi9cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IDFweCBzb2xpZCB3aGl0ZTtcXG4gIG91dGxpbmUtb2Zmc2V0OiAtMXB4O1xcbn1cXG5cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotbXMtdHJhY2sge1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuXFxuICAvKnJlbW92ZSBiZyBjb2xvdXIgZnJvbSB0aGUgdHJhY2ssIHdlJ2xsIHVzZSBtcy1maWxsLWxvd2VyIGFuZCBtcy1maWxsLXVwcGVyIGluc3RlYWQgKi9cXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcblxcbiAgLypsZWF2ZSByb29tIGZvciB0aGUgbGFyZ2VyIHRodW1iIHRvIG92ZXJmbG93IHdpdGggYSB0cmFuc3BhcmVudCBib3JkZXIgKi9cXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItd2lkdGg6IDZweCAwO1xcblxcbiAgLypyZW1vdmUgZGVmYXVsdCB0aWNrIG1hcmtzKi9cXG4gIGNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LW1zLWZpbGwtbG93ZXIge1xcbiAgYmFja2dyb3VuZDogIzc3NztcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi1tcy1maWxsLXVwcGVyIHtcXG4gIGJhY2tncm91bmQ6ICNkZGQ7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotbXMtdGh1bWIge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgd2lkdGg6IDE2cHg7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kOiAjMzg1MzgwO1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOmZvY3VzOjotbXMtZmlsbC1sb3dlciB7XFxuICBiYWNrZ3JvdW5kOiAjODg4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOmZvY3VzOjotbXMtZmlsbC11cHBlciB7XFxuICBiYWNrZ3JvdW5kOiAjY2NjO1xcbn1cXG5cXG4udmlzLWNvbmZpZ3VyYXRpb24tcG9wdXAge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogcmdiYSg1NywgNzYsIDg5LCAwLjg1KTtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICNmMmZhZmY7XFxuICBsaW5lLWhlaWdodDogMzBweDtcXG4gIGhlaWdodDogMzBweDtcXG4gIHdpZHRoOiAxNTBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZS1pbi1vdXQ7XFxuICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlLWluLW91dDtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlLWluLW91dDtcXG59XFxuLnZpcy1jb25maWd1cmF0aW9uLXBvcHVwOmFmdGVyLFxcbi52aXMtY29uZmlndXJhdGlvbi1wb3B1cDpiZWZvcmUge1xcbiAgbGVmdDogMTAwJTtcXG4gIHRvcDogNTAlO1xcbiAgYm9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG4gIGhlaWdodDogMDtcXG4gIHdpZHRoOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi52aXMtY29uZmlndXJhdGlvbi1wb3B1cDphZnRlciB7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMTM2LCAxODMsIDIxMywgMCk7XFxuICBib3JkZXItbGVmdC1jb2xvcjogcmdiYSg1NywgNzYsIDg5LCAwLjg1KTtcXG4gIGJvcmRlci13aWR0aDogOHB4O1xcbiAgbWFyZ2luLXRvcDogLThweDtcXG59XFxuLnZpcy1jb25maWd1cmF0aW9uLXBvcHVwOmJlZm9yZSB7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMTk0LCAyMjUsIDI0NSwgMCk7XFxuICBib3JkZXItbGVmdC1jb2xvcjogI2YyZmFmZjtcXG4gIGJvcmRlci13aWR0aDogMTJweDtcXG4gIG1hcmdpbi10b3A6IC0xMnB4O1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDMpO1xuXG52YXIgY3NzXzI0OHokMiA9IFwiZGl2LnZpcy10b29sdGlwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuXFxuICBmb250LWZhbWlseTogdmVyZGFuYTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiAjMDAwMDAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjRlZDtcXG5cXG4gIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDc0O1xcblxcbiAgYm94LXNoYWRvdzogM3B4IDNweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcblxcbiAgei1pbmRleDogNTtcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eiQyKTtcblxudmFyIGNvbXBvbmVudEVtaXR0ZXIgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvKipcclxuICAgKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gICAqL1xuICB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gICAqXHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gICAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG4gIH1cbiAgLyoqXHJcbiAgICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogQGFwaSBwcml2YXRlXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICAvKipcclxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSkucHVzaChmbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUub2ZmID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTsgLy8gYWxsXG5cbiAgICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gc3BlY2lmaWMgZXZlbnRcblxuXG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzOyAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG5cbiAgICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcblxuXG4gICAgdmFyIGNiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuXG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cbiAgICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXG5cblxuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXG4gICAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAhIXRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG4gIH07XG59KShjb21wb25lbnRFbWl0dGVyKTtcblxudmFyIEVtaXR0ZXIgPSBjb21wb25lbnRFbWl0dGVyLmV4cG9ydHM7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QkMiA9IHt9O1xudGVzdCQyW1RPX1NUUklOR19UQUckM10gPSAneic7XG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QkMikgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIGdsb2JhbCR3ID0gZ2xvYmFsJFA7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUJDIgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRoO1xudmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGcgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkZygndG9TdHJpbmdUYWcnKTtcbnZhciBPYmplY3QkNyA9IGdsb2JhbCR3Lk9iamVjdDsgLy8gRVMzIHdyb25nIGhlcmVcblxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhcmd1bWVudHM7XG59KCkpID09ICdBcmd1bWVudHMnOyAvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG59OyAvLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5cblxudmFyIGNsYXNzb2YkZSA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCQyID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJyAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0JDcoaXQpLCBUT19TVFJJTkdfVEFHJDIpKSA9PSAnc3RyaW5nJyA/IHRhZyAvLyBidWlsdGluVGFnIGNhc2VcbiAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTykgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJDkoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgZ2xvYmFsJHYgPSBnbG9iYWwkUDtcbnZhciBjbGFzc29mJGQgPSBjbGFzc29mJGU7XG52YXIgU3RyaW5nJDIgPSBnbG9iYWwkdi5TdHJpbmc7XG5cbnZhciB0b1N0cmluZyQ4ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mJGQoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gU3RyaW5nJDIoYXJndW1lbnQpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGsgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciB0b1N0cmluZyQ3ID0gdG9TdHJpbmckODtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG52YXIgY2hhckF0JDMgPSB1bmN1cnJ5VGhpcyRrKCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCQxID0gdW5jdXJyeVRoaXMkaygnJy5jaGFyQ29kZUF0KTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzJGsoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kJDQgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyQ3KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMigkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShwb3MpO1xuICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBmaXJzdCA9IGNoYXJDb2RlQXQkMShTLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZSB8fCAoc2Vjb25kID0gY2hhckNvZGVBdCQxKFMsIHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRiA/IENPTlZFUlRfVE9fU1RSSU5HID8gY2hhckF0JDMoUywgcG9zaXRpb24pIDogZmlyc3QgOiBDT05WRVJUX1RPX1NUUklORyA/IHN0cmluZ1NsaWNlKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kJDQoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QkNCh0cnVlKVxufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkaDtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGooRnVuY3Rpb24udG9TdHJpbmcpOyAvLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5cbmlmICghaXNDYWxsYWJsZSQ4KHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQyID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJHUgPSBnbG9iYWwkUDtcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQyO1xudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCR1LldlYWtNYXA7XG52YXIgbmF0aXZlV2Vha01hcCA9IGlzQ2FsbGFibGUkNyhXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlJDEoV2Vha01hcCQxKSk7XG5cbnZhciBzaGFyZWQkMiA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgdWlkJDIgPSB1aWQkNDtcbnZhciBrZXlzJDcgPSBzaGFyZWQkMigna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzJDdba2V5XSB8fCAoa2V5cyQ3W2tleV0gPSB1aWQkMihrZXkpKTtcbn07XG5cbnZhciBOQVRJVkVfV0VBS19NQVAkMSA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJHQgPSBnbG9iYWwkUDtcbnZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCRkID0gaXNPYmplY3QkajtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biRjID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQzID0gc2hhcmVkS2V5JDQ7XG52YXIgaGlkZGVuS2V5cyQ0ID0gaGlkZGVuS2V5cyQ2O1xudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IkZCA9IGdsb2JhbCR0LlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsJHQuV2Vha01hcDtcbnZhciBzZXQkMywgZ2V0JDYsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQkNihpdCkgOiBzZXQkMyhpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICBpZiAoIWlzT2JqZWN0JGQoaXQpIHx8IChzdGF0ZSA9IGdldCQ2KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJGQoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCQxIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGkoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkaShzdG9yZS5zZXQpO1xuXG4gIHNldCQzID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yJGQoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0KHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcblxuICBnZXQkNiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuXG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDMoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkNFtTVEFURV0gPSB0cnVlO1xuXG4gIHNldCQzID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24kYyhpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yJGQoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcblxuICBnZXQkNiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kYyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG5cbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biRjKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQzLFxuICBnZXQ6IGdldCQ2LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgaGFzT3duJGIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkYiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVYSVNUUyA9IGhhc093biRiKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpOyAvLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG5cbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgZnVuY3Rpb24gc29tZXRoaW5nKCkge1xuICAvKiBlbXB0eSAqL1xufS5uYW1lID09PSAnc29tZXRoaW5nJztcblxudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJGIgfHwgREVTQ1JJUFRPUlMkYiAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSk7XG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRkO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ3ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgb2JqZWN0S2V5cyQyID0gb2JqZWN0S2V5cyQ0OyAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcblxub2JqZWN0RGVmaW5lUHJvcGVydGllcy5mID0gREVTQ1JJUFRPUlMkYSAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCRiKE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QkNyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzJDIoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcblxuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcblxuICByZXR1cm4gTztcbn07XG5cbnZhciBnZXRCdWlsdEluJDYgPSBnZXRCdWlsdEluJDk7XG52YXIgaHRtbCQxID0gZ2V0QnVpbHRJbiQ2KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cbnZhciBhbk9iamVjdCRhID0gYW5PYmplY3QkZDtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNjtcbnZhciBodG1sID0gaHRtbCQxO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDQ7XG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFJDEgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDIoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAvKiBlbXB0eSAqL1xufTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59OyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXG5cbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuXG4gIHJldHVybiB0ZW1wO1xufTsgLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXG5cbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuXG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTsgLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG5cblxudmFyIGFjdGl2ZVhEb2N1bWVudDtcblxudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBpZ25vcmUgKi9cbiAgfVxuXG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKCkgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cyQxLmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFJDFdW2VudW1CdWdLZXlzJDFbbGVuZ3RoXV07XG5cbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5cyQzW0lFX1BST1RPJDFdID0gdHJ1ZTsgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IGFuT2JqZWN0JGEoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IG51bGw7IC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcblxuICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcblxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZSQxLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBmYWlscyRrID0gZmFpbHMkdDtcbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJGsoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgZ2xvYmFsJHMgPSBnbG9iYWwkUDtcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRoO1xudmFyIHRvT2JqZWN0JGIgPSB0b09iamVjdCRlO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDQ7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSJDEgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5JDEoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0JDYgPSBnbG9iYWwkcy5PYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlJDIgPSBPYmplY3QkNi5wcm90b3R5cGU7IC8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcblxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSJDEgPyBPYmplY3QkNi5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdCRiKE8pO1xuICBpZiAoaGFzT3duJGEob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG5cbiAgaWYgKGlzQ2FsbGFibGUkNihjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdCQ2ID8gT2JqZWN0UHJvdG90eXBlJDIgOiBudWxsO1xufTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG5cbnZhciByZWRlZmluZSQ0ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVudW1lcmFibGUpIHRhcmdldFtrZXldID0gdmFsdWU7ZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyh0YXJnZXQsIGtleSwgdmFsdWUpO1xufTtcblxudmFyIGZhaWxzJGogPSBmYWlscyR0O1xudmFyIGlzQ2FsbGFibGUkNSA9IGlzQ2FsbGFibGUkaDtcbnZhciBjcmVhdGUkYSA9IG9iamVjdENyZWF0ZTtcbnZhciBnZXRQcm90b3R5cGVPZiQ4ID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgcmVkZWZpbmUkMyA9IHJlZGVmaW5lJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJGYgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJVEVSQVRPUiQ2ID0gd2VsbEtub3duU3ltYm9sJGYoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7IC8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDEsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cblxuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTsgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG5cbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO2Vsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDgoZ2V0UHJvdG90eXBlT2YkOChhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUkMSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9IEl0ZXJhdG9yUHJvdG90eXBlJDEgPT0gdW5kZWZpbmVkIHx8IGZhaWxzJGooZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9OyAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcblxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGUkMVtJVEVSQVRPUiQ2XS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMSA9IHt9O2Vsc2UgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGNyZWF0ZSRhKEl0ZXJhdG9yUHJvdG90eXBlJDEpOyAvLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5cbmlmICghaXNDYWxsYWJsZSQ1KEl0ZXJhdG9yUHJvdG90eXBlJDFbSVRFUkFUT1IkNl0pKSB7XG4gIHJlZGVmaW5lJDMoSXRlcmF0b3JQcm90b3R5cGUkMSwgSVRFUkFUT1IkNiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxudmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSQxLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbn07XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMSA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBjbGFzc29mJGMgPSBjbGFzc29mJGU7IC8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMSA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZiRjKHRoaXMpICsgJ10nO1xufTtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBkZWZpbmVQcm9wZXJ0eSRjID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB0b1N0cmluZyQ2ID0gb2JqZWN0VG9TdHJpbmc7XG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkZSgndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDUgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDLCBTRVRfTUVUSE9EKSB7XG4gIGlmIChpdCkge1xuICAgIHZhciB0YXJnZXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZTtcblxuICAgIGlmICghaGFzT3duJDkodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSRjKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFRBR1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFNFVF9NRVRIT0QgJiYgIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIodGFyZ2V0LCAndG9TdHJpbmcnLCB0b1N0cmluZyQ2KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUkOSA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHNldFRvU3RyaW5nVGFnJDQgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIEl0ZXJhdG9ycyQ1ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSQ5KEl0ZXJhdG9yUHJvdG90eXBlLCB7XG4gICAgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpXG4gIH0pO1xuICBzZXRUb1N0cmluZ1RhZyQ0KEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzJDVbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxudmFyIGdsb2JhbCRyID0gZ2xvYmFsJFA7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRoO1xudmFyIFN0cmluZyQxID0gZ2xvYmFsJHIuU3RyaW5nO1xudmFyIFR5cGVFcnJvciRjID0gZ2xvYmFsJHIuVHlwZUVycm9yO1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IFR5cGVFcnJvciRjKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nJDEoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xudmFyIHVuY3VycnlUaGlzJGggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JDkgPSBhbk9iamVjdCRkO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxOyAvLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxuXG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcblxuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyRoKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkOShPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgJCRIID0gX2V4cG9ydDtcbnZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDE7XG52YXIgZ2V0UHJvdG90eXBlT2YkNyA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIHJlZGVmaW5lJDIgPSByZWRlZmluZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSXRlcmF0b3JzJDQgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiQ1ID0gd2VsbEtub3duU3ltYm9sJGQoJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcblxuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7XG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgVkFMVUVTOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBFTlRSSUVTOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNV0gfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXSB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTsgLy8gZml4IG5hdGl2ZVxuXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDcoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuXG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuXG5cbiAgICAgIHNldFRvU3RyaW5nVGFnJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIEl0ZXJhdG9ycyQ0W1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH0gLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuXG5cbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAge1xuICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcblxuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gY2FsbCQ2KG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcblxuXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgcmVkZWZpbmUkMihJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkJEgoe1xuICAgICAgdGFyZ2V0OiBOQU1FLFxuICAgICAgcHJvdG86IHRydWUsXG4gICAgICBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FXG4gICAgfSwgbWV0aG9kcyk7XG4gIH0gLy8gZGVmaW5lIGl0ZXJhdG9yXG5cblxuICBpZiAoKEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNV0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIHJlZGVmaW5lJDIoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDUsIGRlZmF1bHRJdGVyYXRvciwge1xuICAgICAgbmFtZTogREVGQVVMVFxuICAgIH0pO1xuICB9XG5cbiAgSXRlcmF0b3JzJDRbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxudmFyIGNoYXJBdCQyID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcbnZhciB0b1N0cmluZyQ1ID0gdG9TdHJpbmckODtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZUl0ZXJhdG9yJDIgPSBkZWZpbmVJdGVyYXRvciQzO1xudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkNSA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpOyAvLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuXG5kZWZpbmVJdGVyYXRvciQyKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IHRvU3RyaW5nJDUoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pOyAvLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMih0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkb25lOiB0cnVlXG4gIH07XG4gIHBvaW50ID0gY2hhckF0JDIoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogcG9pbnQsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbn0pO1xuXG52YXIgY2FsbCQ1ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDggPSBhbk9iamVjdCRkO1xudmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDM7XG5cbnZhciBpdGVyYXRvckNsb3NlJDIgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QkOChpdGVyYXRvcik7XG5cbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG5cbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsJDUoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuICB9XG5cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDgoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGQ7XG52YXIgaXRlcmF0b3JDbG9zZSQxID0gaXRlcmF0b3JDbG9zZSQyOyAvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5cbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QkNyh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlJDEoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCRjKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlJGkgPSBBcnJheS5wcm90b3R5cGU7IC8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcblxudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMkMy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGUkaVtJVEVSQVRPUiQ0XSA9PT0gaXQpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGkgPSBmYWlscyR0O1xudmFyIGlzQ2FsbGFibGUkMyA9IGlzQ2FsbGFibGUkaDtcbnZhciBjbGFzc29mJGIgPSBjbGFzc29mJGU7XG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDI7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge1xuICAvKiBlbXB0eSAqL1xufTtcblxudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0JDMgPSBnZXRCdWlsdEluJDUoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMkMiA9IHVuY3VycnlUaGlzJGcoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDMoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3QkMyhub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQzKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAoY2xhc3NvZiRiKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyQyKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7IC8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxuXG52YXIgaXNDb25zdHJ1Y3RvciQ0ID0gIWNvbnN0cnVjdCQzIHx8IGZhaWxzJGkoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkge1xuICAgIGNhbGxlZCA9IHRydWU7XG4gIH0pIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciB0b1Byb3BlcnR5S2V5JDEgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSQ2ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDEoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxKDAsIHZhbHVlKSk7ZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG52YXIgY2xhc3NvZiRhID0gY2xhc3NvZiRlO1xudmFyIGdldE1ldGhvZCA9IGdldE1ldGhvZCQzO1xudmFyIEl0ZXJhdG9ycyQyID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCRiID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkOCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kKGl0LCBJVEVSQVRPUiQzKSB8fCBnZXRNZXRob2QoaXQsICdAQGl0ZXJhdG9yJykgfHwgSXRlcmF0b3JzJDJbY2xhc3NvZiRhKGl0KV07XG59O1xuXG52YXIgZ2xvYmFsJHEgPSBnbG9iYWwkUDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkNztcbnZhciBhbk9iamVjdCQ2ID0gYW5PYmplY3QkZDtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNDtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ3ID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbnZhciBUeXBlRXJyb3IkYiA9IGdsb2JhbCRxLlR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQ3KGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMyhpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ2KGNhbGwkNChpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgVHlwZUVycm9yJGIodHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxudmFyIGdsb2JhbCRwID0gZ2xvYmFsJFA7XG52YXIgYmluZCQ1ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgdG9PYmplY3QkYSA9IHRvT2JqZWN0JGU7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmckMTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGlzQ29uc3RydWN0b3IkMyA9IGlzQ29uc3RydWN0b3IkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSRiID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBjcmVhdGVQcm9wZXJ0eSQ1ID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBnZXRJdGVyYXRvciQ2ID0gZ2V0SXRlcmF0b3IkNztcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ2ID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbnZhciBBcnJheSQ1ID0gZ2xvYmFsJHAuQXJyYXk7IC8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuXG52YXIgYXJyYXlGcm9tID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2Vcbi8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi9cbikge1xuICB2YXIgTyA9IHRvT2JqZWN0JGEoYXJyYXlMaWtlKTtcbiAgdmFyIElTX0NPTlNUUlVDVE9SID0gaXNDb25zdHJ1Y3RvciQzKHRoaXMpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kJDUobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ2KE8pO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0LCB2YWx1ZTsgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcblxuICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgISh0aGlzID09IEFycmF5JDUgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkNihPLCBpdGVyYXRvck1ldGhvZCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcygpIDogW107XG5cbiAgICBmb3IgKDsgIShzdGVwID0gY2FsbCQzKG5leHQsIGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5JDUocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSRiKE8pO1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMobGVuZ3RoKSA6IEFycmF5JDUobGVuZ3RoKTtcblxuICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgY3JlYXRlUHJvcGVydHkkNShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCRhKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiAhIWNhbGxlZCsrXG4gICAgICB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxuXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgMjtcbiAgfSk7XG59IGNhdGNoIChlcnJvcikge1xuICAvKiBlbXB0eSAqL1xufVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG5cbiAgICBvYmplY3RbSVRFUkFUT1IkMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyICQkRyA9IF9leHBvcnQ7XG52YXIgZnJvbSQ2ID0gYXJyYXlGcm9tO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxO1xudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcbn0pOyAvLyBgQXJyYXkuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cblxuJCRHKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IElOQ09SUkVDVF9JVEVSQVRJT05cbn0sIHtcbiAgZnJvbTogZnJvbSQ2XG59KTtcblxudmFyIHBhdGgkdCA9IHBhdGgkeTtcbnZhciBmcm9tJDUgPSBwYXRoJHQuQXJyYXkuZnJvbTtcblxudmFyIHBhcmVudCQxOCA9IGZyb20kNTtcbnZhciBmcm9tJDQgPSBwYXJlbnQkMTg7XG5cbnZhciBmcm9tJDMgPSBmcm9tJDQ7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNiA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIEl0ZXJhdG9ycyQxID0gaXRlcmF0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNCA9IGludGVybmFsU3RhdGU7XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBkZWZpbmVJdGVyYXRvciQzO1xudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpOyAvLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcblxuZGVmaW5lSXRlcmF0b3IkMShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUkNCh0aGlzLCB7XG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG4gICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QkNihpdGVyYXRlZCksXG4gICAgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsXG4gICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgLy8ga2luZFxuXG4gIH0pOyAvLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuXG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHtcbiAgICB2YWx1ZTogaW5kZXgsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7XG4gICAgdmFsdWU6IHRhcmdldFtpbmRleF0sXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufSwgJ3ZhbHVlcycpOyAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG5cbkl0ZXJhdG9ycyQxLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQxLkFycmF5OyAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ1ID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbnZhciBnZXRJdGVyYXRvck1ldGhvZF8xID0gZ2V0SXRlcmF0b3JNZXRob2QkNTtcblxuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xuXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxudmFyIERPTUl0ZXJhYmxlcyQ0ID0gZG9tSXRlcmFibGVzO1xudmFyIGdsb2JhbCRvID0gZ2xvYmFsJFA7XG52YXIgY2xhc3NvZiQ5ID0gY2xhc3NvZiRlO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQ5KCd0b1N0cmluZ1RhZycpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzJDQpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWwkb1tDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5cbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgY2xhc3NvZiQ5KENvbGxlY3Rpb25Qcm90b3R5cGUpICE9PSBUT19TVFJJTkdfVEFHKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgfVxuXG4gIEl0ZXJhdG9yc1tDT0xMRUNUSU9OX05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG52YXIgcGFyZW50JDE3ID0gZ2V0SXRlcmF0b3JNZXRob2RfMTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ0ID0gcGFyZW50JDE3O1xuXG52YXIgcGFyZW50JDE2ID0gZ2V0SXRlcmF0b3JNZXRob2QkNDtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQzID0gcGFyZW50JDE2O1xuXG52YXIgcGFyZW50JDE1ID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gcGFyZW50JDE1O1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG5cbnZhciBjbGFzc29mJDggPSBjbGFzc29mUmF3JDE7IC8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxuXG52YXIgaXNBcnJheSRkID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mJDgoYXJndW1lbnQpID09ICdBcnJheSc7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDIgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5cbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMkMik7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0ge307XG5cbnZhciBnbG9iYWwkbiA9IGdsb2JhbCRQO1xudmFyIHRvQWJzb2x1dGVJbmRleCQzID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgY3JlYXRlUHJvcGVydHkkNCA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgQXJyYXkkNCA9IGdsb2JhbCRuLkFycmF5O1xudmFyIG1heCQyID0gTWF0aC5tYXg7XG5cbnZhciBhcnJheVNsaWNlU2ltcGxlID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJGEoTyk7XG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDMoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgkMyhlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9IEFycmF5JDQobWF4JDIoZmluIC0gaywgMCkpO1xuXG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkkNChyZXN1bHQsIG4sIE9ba10pO1xuXG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIGNsYXNzb2YkNyA9IGNsYXNzb2ZSYXckMTtcbnZhciB0b0luZGV4ZWRPYmplY3QkNSA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmY7XG52YXIgYXJyYXlTbGljZSQzID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5TmFtZXMkMShpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGFycmF5U2xpY2UkMyh3aW5kb3dOYW1lcyk7XG4gIH1cbn07IC8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcblxuXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIGNsYXNzb2YkNyhpdCkgPT0gJ1dpbmRvdycgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiAkZ2V0T3duUHJvcGVydHlOYW1lcyQxKHRvSW5kZXhlZE9iamVjdCQ1KGl0KSk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sV3JhcHBlZCA9IHt9O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkajtcbndlbGxLbm93blN5bWJvbFdyYXBwZWQuZiA9IHdlbGxLbm93blN5bWJvbCQ4O1xuXG52YXIgcGF0aCRzID0gcGF0aCR5O1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlJDEgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xudmFyIGRlZmluZVByb3BlcnR5JGIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGwgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aCRzLlN5bWJvbCB8fCAocGF0aCRzLlN5bWJvbCA9IHt9KTtcbiAgaWYgKCFoYXNPd24kOChTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eSRiKFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlJDEuZihOQU1FKVxuICB9KTtcbn07XG5cbnZhciBnbG9iYWwkbSA9IGdsb2JhbCRQO1xudmFyIGlzQXJyYXkkYyA9IGlzQXJyYXkkZDtcbnZhciBpc0NvbnN0cnVjdG9yJDIgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgaXNPYmplY3QkYyA9IGlzT2JqZWN0JGo7XG52YXIgd2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkNygnc3BlY2llcycpO1xudmFyIEFycmF5JDMgPSBnbG9iYWwkbS5BcnJheTsgLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcblxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcblxuICBpZiAoaXNBcnJheSRjKG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7IC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cbiAgICBpZiAoaXNDb25zdHJ1Y3RvciQyKEMpICYmIChDID09PSBBcnJheSQzIHx8IGlzQXJyYXkkYyhDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO2Vsc2UgaWYgKGlzT2JqZWN0JGMoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVMkM107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkkMyA6IEM7XG59O1xuXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxOyAvLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkNCA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxudmFyIGJpbmQkNCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciB0b09iamVjdCQ5ID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ5ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMyA9IGFycmF5U3BlY2llc0NyZWF0ZSQ0O1xudmFyIHB1c2gkNCA9IHVuY3VycnlUaGlzJGYoW10ucHVzaCk7IC8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxudmFyIGNyZWF0ZU1ldGhvZCQzID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDkoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdCQxKE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZCQ0KGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ5KHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZSQzO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG5cbiAgICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuXG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyBzb21lXG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgLy8gZmluZFxuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIC8vIGZpbmRJbmRleFxuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcHVzaCQ0KHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIC8vIGV2ZXJ5XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwdXNoJDQodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgLy8gZmlsdGVyUmVqZWN0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxudmFyIGFycmF5SXRlcmF0aW9uID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQzKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCQzKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCQzKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCQzKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCQzKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCQzKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQzKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCQzKDcpXG59O1xuXG52YXIgJCRGID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkbCA9IGdsb2JhbCRQO1xudmFyIGdldEJ1aWx0SW4kNCA9IGdldEJ1aWx0SW4kOTtcbnZhciBhcHBseSQ0ID0gZnVuY3Rpb25BcHBseTtcbnZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgZmFpbHMkaCA9IGZhaWxzJHQ7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQXJyYXkkYiA9IGlzQXJyYXkkZDtcbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGg7XG52YXIgaXNPYmplY3QkYiA9IGlzT2JqZWN0JGo7XG52YXIgaXNQcm90b3R5cGVPZiRrID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDM7XG52YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGQ7XG52YXIgdG9PYmplY3QkOCA9IHRvT2JqZWN0JGU7XG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nJDg7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIG9iamVjdEtleXMkMSA9IG9iamVjdEtleXMkNDtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbDtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBhcnJheVNsaWNlJDIgPSBhcnJheVNsaWNlJDU7XG52YXIgcmVkZWZpbmUkMSA9IHJlZGVmaW5lJDQ7XG52YXIgc2hhcmVkID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkNDtcbnZhciBoaWRkZW5LZXlzJDEgPSBoaWRkZW5LZXlzJDY7XG52YXIgdWlkJDEgPSB1aWQkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRrID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQzID0gaW50ZXJuYWxTdGF0ZTtcbnZhciAkZm9yRWFjaCQxID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbnZhciBISURERU4gPSBzaGFyZWRLZXkoJ2hpZGRlbicpO1xudmFyIFNZTUJPTCA9ICdTeW1ib2wnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCQ2KCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUkMyA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUkMSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyICRTeW1ib2wgPSBnbG9iYWwkbC5TeW1ib2w7XG52YXIgU3ltYm9sUHJvdG90eXBlID0gJFN5bWJvbCAmJiAkU3ltYm9sW1BST1RPVFlQRV07XG52YXIgVHlwZUVycm9yJGEgPSBnbG9iYWwkbC5UeXBlRXJyb3I7XG52YXIgUU9iamVjdCA9IGdsb2JhbCRsLlFPYmplY3Q7XG52YXIgJHN0cmluZ2lmeSQxID0gZ2V0QnVpbHRJbiQ0KCdKU09OJywgJ3N0cmluZ2lmeScpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDIuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xudmFyIHB1c2gkMyA9IHVuY3VycnlUaGlzJGUoW10ucHVzaCk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7IC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7IC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDkgJiYgZmFpbHMkaChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywge1xuICAgICAgICB2YWx1ZTogN1xuICAgICAgfSkuYTtcbiAgICB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoT2JqZWN0UHJvdG90eXBlJDEsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZSQxW1BdO1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcblxuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUkMSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSQxLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufSA6IG5hdGl2ZURlZmluZVByb3BlcnR5O1xuXG52YXIgd3JhcCQxID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZShTeW1ib2xQcm90b3R5cGUpO1xuICBzZXRJbnRlcm5hbFN0YXRlJDMoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUyQ5KSBzeW1ib2wuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGlmIChPID09PSBPYmplY3RQcm90b3R5cGUkMSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICBhbk9iamVjdCQ1KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QkNShBdHRyaWJ1dGVzKTtcblxuICBpZiAoaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhc093biQ3KE8sIEhJRERFTikpIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICBPW0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXNPd24kNyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKE8sIGtleSwgQXR0cmlidXRlcyk7XG4gIH1cblxuICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywga2V5LCBBdHRyaWJ1dGVzKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCQ1KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdCQ0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMkMShwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG4gICRmb3JFYWNoJDEoa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMkOSB8fCBjYWxsJDIoJHByb3BlcnR5SXNFbnVtZXJhYmxlJDEsIHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZU9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9Qcm9wZXJ0eUtleShWKTtcbiAgdmFyIGVudW1lcmFibGUgPSBjYWxsJDIobmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUsIHRoaXMsIFApO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlJDEgJiYgaGFzT3duJDcoQWxsU3ltYm9scywgUCkgJiYgIWhhc093biQ3KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbnVtZXJhYmxlIHx8ICFoYXNPd24kNyh0aGlzLCBQKSB8fCAhaGFzT3duJDcoQWxsU3ltYm9scywgUCkgfHwgaGFzT3duJDcodGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1bUF0gPyBlbnVtZXJhYmxlIDogdHJ1ZTtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgdmFyIGl0ID0gdG9JbmRleGVkT2JqZWN0JDQoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSQxICYmIGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhc093biQ3KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShpdCwga2V5KTtcblxuICBpZiAoZGVzY3JpcHRvciAmJiBoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzT3duJDcoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdCQ0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaCQxKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24kNyhoaWRkZW5LZXlzJDEsIGtleSkpIHB1c2gkMyhyZXN1bHQsIGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykge1xuICB2YXIgSVNfT0JKRUNUX1BST1RPVFlQRSA9IE8gPT09IE9iamVjdFByb3RvdHlwZSQxO1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0JDQoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoJDEobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzT3duJDcoT2JqZWN0UHJvdG90eXBlJDEsIGtleSkpKSB7XG4gICAgICBwdXNoJDMocmVzdWx0LCBBbGxTeW1ib2xzW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcblxuXG5pZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAoaXNQcm90b3R5cGVPZiRrKFN5bWJvbFByb3RvdHlwZSwgdGhpcykpIHRocm93IFR5cGVFcnJvciRhKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICR0b1N0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQkMShkZXNjcmlwdGlvbik7XG5cbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlJDEpIGNhbGwkMihzZXR0ZXIsIE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXNPd24kNyh0aGlzLCBISURERU4pICYmIGhhc093biQ3KHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuXG4gICAgaWYgKERFU0NSSVBUT1JTJDkgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUkMSwgdGFnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwJDEodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgU3ltYm9sUHJvdG90eXBlID0gJFN5bWJvbFtQUk9UT1RZUEVdO1xuICByZWRlZmluZSQxKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcbiAgcmVkZWZpbmUkMSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwJDEodWlkJDEoZGVzY3JpcHRpb24pLCBkZXNjcmlwdGlvbik7XG4gIH0pO1xuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlJDE7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZGVmaW5lUHJvcGVydGllc01vZHVsZS5mID0gJGRlZmluZVByb3BlcnRpZXM7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQyLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDIuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAkMSh3ZWxsS25vd25TeW1ib2wkNihuYW1lKSwgbmFtZSk7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTJDkpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1TeW1ib2wtZGVzY3JpcHRpb25cbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbiQkRih7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgd3JhcDogdHJ1ZSxcbiAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCxcbiAgc2hhbTogIU5BVElWRV9TWU1CT0xcbn0sIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcbiRmb3JFYWNoJDEob2JqZWN0S2V5cyQxKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRrKG5hbWUpO1xufSk7XG4kJEYoe1xuICB0YXJnZXQ6IFNZTUJPTCxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTFxufSwge1xuICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSAkdG9TdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzT3duJDcoU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSkgcmV0dXJuIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXTtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbChzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfSxcbiAgLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5rZXlmb3JcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3IkYShzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXNPd24kNyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBVU0VfU0VUVEVSID0gdHJ1ZTtcbiAgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgVVNFX1NFVFRFUiA9IGZhbHNlO1xuICB9XG59KTtcbiQkRih7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsXG4gIHNoYW06ICFERVNDUklQVE9SUyQ5XG59LCB7XG4gIC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuJCRGKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTFxufSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5c3ltYm9sc1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pOyAvLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG5cbiQkRih7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogZmFpbHMkaChmdW5jdGlvbiAoKSB7XG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZigxKTtcbiAgfSlcbn0sIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZih0b09iamVjdCQ4KGl0KSk7XG4gIH1cbn0pOyAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZCBiZWhhdmlvciB3aXRoIHN5bWJvbHNcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnlcblxuaWYgKCRzdHJpbmdpZnkkMSkge1xuICB2YXIgRk9SQ0VEX0pTT05fU1RSSU5HSUZZID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMkaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woKTsgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblxuICAgIHJldHVybiAkc3RyaW5naWZ5JDEoW3N5bWJvbF0pICE9ICdbbnVsbF0nIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkkMSh7XG4gICAgICBhOiBzeW1ib2xcbiAgICB9KSAhPSAne30nIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gICAgfHwgJHN0cmluZ2lmeSQxKE9iamVjdChzeW1ib2wpKSAhPSAne30nO1xuICB9KTtcbiAgJCRGKHtcbiAgICB0YXJnZXQ6ICdKU09OJyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogRk9SQ0VEX0pTT05fU1RSSU5HSUZZXG4gIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZSQyKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICBpZiAoIWlzT2JqZWN0JGIocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcblxuICAgICAgaWYgKCFpc0FycmF5JGIocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlJDIoJHJlcGxhY2VyKSkgdmFsdWUgPSBjYWxsJDIoJHJlcGxhY2VyLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgICByZXR1cm4gYXBwbHkkNCgkc3RyaW5naWZ5JDEsIG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG59IC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5cblxuaWYgKCFTeW1ib2xQcm90b3R5cGVbVE9fUFJJTUlUSVZFXSkge1xuICB2YXIgdmFsdWVPZiA9IFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIC5sZW5ndGhcblxuICByZWRlZmluZSQxKFN5bWJvbFByb3RvdHlwZSwgVE9fUFJJTUlUSVZFLCBmdW5jdGlvbiAoaGludCkge1xuICAgIC8vIFRPRE86IGltcHJvdmUgaGludCBsb2dpY1xuICAgIHJldHVybiBjYWxsJDIodmFsdWVPZiwgdGhpcyk7XG4gIH0pO1xufSAvLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5cblxuc2V0VG9TdHJpbmdUYWckMigkU3ltYm9sLCBTWU1CT0wpO1xuaGlkZGVuS2V5cyQxW0hJRERFTl0gPSB0cnVlO1xuXG52YXIgcGF0aCRyID0gcGF0aCR5O1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyQyID0gcGF0aCRyLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBwYXJlbnQkMTQgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMSA9IHBhcmVudCQxNDtcblxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyQxO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDYgPSB7ZXhwb3J0czoge319O1xuXG52YXIgJCRFID0gX2V4cG9ydDtcbnZhciBmYWlscyRnID0gZmFpbHMkdDtcbnZhciB0b0luZGV4ZWRPYmplY3QkMyA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDQgPSBmYWlscyRnKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKDEpO1xufSk7XG52YXIgRk9SQ0VEJDYgPSAhREVTQ1JJUFRPUlMkOCB8fCBGQUlMU19PTl9QUklNSVRJVkVTJDQ7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuXG4kJEUoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZPUkNFRCQ2LFxuICBzaGFtOiAhREVTQ1JJUFRPUlMkOFxufSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0luZGV4ZWRPYmplY3QkMyhpdCksIGtleSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRxID0gcGF0aCR5O1xudmFyIE9iamVjdCQ1ID0gcGF0aCRxLk9iamVjdDtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDYuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIHJldHVybiBPYmplY3QkNS5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuXG5pZiAoT2JqZWN0JDUuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0pIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1LnNoYW0gPSB0cnVlO1xuXG52YXIgcGFyZW50JDEzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDYuZXhwb3J0cztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNCA9IHBhcmVudCQxMztcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG5cbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDk7XG52YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGQ7XG52YXIgY29uY2F0JDQgPSB1bmN1cnJ5VGhpcyRkKFtdLmNvbmNhdCk7IC8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcblxudmFyIG93bktleXMkYSA9IGdldEJ1aWx0SW4kMygnUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMS5mKGFuT2JqZWN0JDQoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0JDQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxudmFyICQkRCA9IF9leHBvcnQ7XG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIG93bktleXMkOSA9IG93bktleXMkYTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGNyZWF0ZVByb3BlcnR5JDMgPSBjcmVhdGVQcm9wZXJ0eSQ2OyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuXG4kJEQoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBzaGFtOiAhREVTQ1JJUFRPUlMkN1xufSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDIob2JqZWN0KTtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMkOShPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIga2V5LCBkZXNjcmlwdG9yO1xuXG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5ID0ga2V5c1tpbmRleCsrXSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eSQzKHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIHBhdGgkcCA9IHBhdGgkeTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDIgPSBwYXRoJHAuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBwYXJlbnQkMTIgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDI7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQxID0gcGFyZW50JDEyO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciAkJEMgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzLmY7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxuXG4kJEMoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICE9PSBkZWZpbmVQcm9wZXJ0aWVzJDMsXG4gIHNoYW06ICFERVNDUklQVE9SUyQ2XG59LCB7XG4gIGRlZmluZVByb3BlcnRpZXM6IGRlZmluZVByb3BlcnRpZXMkM1xufSk7XG5cbnZhciBwYXRoJG8gPSBwYXRoJHk7XG52YXIgT2JqZWN0JDQgPSBwYXRoJG8uT2JqZWN0O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyQyID0gZGVmaW5lUHJvcGVydGllcyQ0LmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKFQsIEQpIHtcbiAgcmV0dXJuIE9iamVjdCQ0LmRlZmluZVByb3BlcnRpZXMoVCwgRCk7XG59O1xuXG5pZiAoT2JqZWN0JDQuZGVmaW5lUHJvcGVydGllcy5zaGFtKSBkZWZpbmVQcm9wZXJ0aWVzJDIuc2hhbSA9IHRydWU7XG5cbnZhciBwYXJlbnQkMTEgPSBkZWZpbmVQcm9wZXJ0aWVzJDQuZXhwb3J0cztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDEgPSBwYXJlbnQkMTE7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcyQxO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkYSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciAkJEIgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eSQ5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbiQkQih7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSBkZWZpbmVQcm9wZXJ0eSQ5LFxuICBzaGFtOiAhREVTQ1JJUFRPUlMkNVxufSwge1xuICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHkkOVxufSk7XG5cbnZhciBwYXRoJG4gPSBwYXRoJHk7XG52YXIgT2JqZWN0JDMgPSBwYXRoJG4uT2JqZWN0O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkOCA9IGRlZmluZVByb3BlcnR5JGEuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuIE9iamVjdCQzLmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuaWYgKE9iamVjdCQzLmRlZmluZVByb3BlcnR5LnNoYW0pIGRlZmluZVByb3BlcnR5JDguc2hhbSA9IHRydWU7XG5cbnZhciBwYXJlbnQkMTAgPSBkZWZpbmVQcm9wZXJ0eSRhLmV4cG9ydHM7XG52YXIgZGVmaW5lUHJvcGVydHkkNyA9IHBhcmVudCQxMDtcblxudmFyIGRlZmluZVByb3BlcnR5JDYgPSBkZWZpbmVQcm9wZXJ0eSQ3O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG52YXIgcGFyZW50JCQgPSBkZWZpbmVQcm9wZXJ0eSQ3O1xudmFyIGRlZmluZVByb3BlcnR5JDUgPSBwYXJlbnQkJDtcblxudmFyIHBhcmVudCRfID0gZGVmaW5lUHJvcGVydHkkNTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gcGFyZW50JF87XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQzID0gZGVmaW5lUHJvcGVydHkkNDtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cbiAgICBkZWZpbmVQcm9wZXJ0eSQzKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcblxuICBkZWZpbmVQcm9wZXJ0eSQzKENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIGRlZmluZVByb3BlcnR5JDMob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgJCRBID0gX2V4cG9ydDtcbnZhciBpc0FycmF5JGEgPSBpc0FycmF5JGQ7IC8vIGBBcnJheS5pc0FycmF5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuaXNhcnJheVxuXG4kJEEoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgaXNBcnJheTogaXNBcnJheSRhXG59KTtcblxudmFyIHBhdGgkbSA9IHBhdGgkeTtcbnZhciBpc0FycmF5JDkgPSBwYXRoJG0uQXJyYXkuaXNBcnJheTtcblxudmFyIHBhcmVudCRaID0gaXNBcnJheSQ5O1xudmFyIGlzQXJyYXkkOCA9IHBhcmVudCRaO1xuXG52YXIgcGFyZW50JFkgPSBpc0FycmF5JDg7XG52YXIgaXNBcnJheSQ3ID0gcGFyZW50JFk7XG5cbnZhciBwYXJlbnQkWCA9IGlzQXJyYXkkNztcbnZhciBpc0FycmF5JDYgPSBwYXJlbnQkWDtcblxudmFyIGlzQXJyYXkkNSA9IGlzQXJyYXkkNjtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoaXNBcnJheSQ1KGFycikpIHJldHVybiBhcnI7XG59XG5cbnZhciBmYWlscyRmID0gZmFpbHMkdDtcbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBTUEVDSUVTJDIgPSB3ZWxsS25vd25TeW1ib2wkNSgnc3BlY2llcycpO1xuXG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1ID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OJDEgPj0gNTEgfHwgIWZhaWxzJGYoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG5cbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9vOiAxXG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcbiAgfSk7XG59O1xuXG52YXIgJCR6ID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkayA9IGdsb2JhbCRQO1xudmFyIGZhaWxzJGUgPSBmYWlscyR0O1xudmFyIGlzQXJyYXkkNCA9IGlzQXJyYXkkZDtcbnZhciBpc09iamVjdCRhID0gaXNPYmplY3QkajtcbnZhciB0b09iamVjdCQ3ID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ4ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBjcmVhdGVQcm9wZXJ0eSQyID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMiA9IGFycmF5U3BlY2llc0NyZWF0ZSQ0O1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2wkNCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJztcbnZhciBUeXBlRXJyb3IkOSA9IGdsb2JhbCRrLlR5cGVFcnJvcjsgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcbnZhciBTUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDQoJ2NvbmNhdCcpO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdCRhKE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5JDQoTyk7XG59O1xuXG52YXIgRk9SQ0VEJDUgPSAhSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCB8fCAhU1BFQ0lFU19TVVBQT1JUOyAvLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuXG4kJHooe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IEZPUkNFRCQ1XG59LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykge1xuICAgIHZhciBPID0gdG9PYmplY3QkNyh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZSQyKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG5cbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuXG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDgoRSk7XG4gICAgICAgIGlmIChuICsgbGVuID4gTUFYX1NBRkVfSU5URUdFUiQxKSB0aHJvdyBUeXBlRXJyb3IkOShNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eSQyKEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUiQxKSB0aHJvdyBUeXBlRXJyb3IkOShNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eSQyKEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRqID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmFzeW5jaXRlcmF0b3JcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGooJ2FzeW5jSXRlcmF0b3InKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRpID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuaGFzSW5zdGFuY2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5oYXNpbnN0YW5jZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkaSgnaGFzSW5zdGFuY2UnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRoID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXNjb25jYXRzcHJlYWRhYmxlXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRoKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRnID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkZygnaXRlcmF0b3InKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRmID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wubWF0Y2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5tYXRjaFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkZignbWF0Y2gnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRlID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wubWF0Y2hBbGxgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5tYXRjaGFsbFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkZSgnbWF0Y2hBbGwnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRkID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wucmVwbGFjZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnJlcGxhY2VcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGQoJ3JlcGxhY2UnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRjID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuc2VhcmNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuc2VhcmNoXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRjKCdzZWFyY2gnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRiID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuc3BlY2llc2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNwZWNpZXNcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGIoJ3NwZWNpZXMnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRhID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wuc3BsaXRgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGxpdFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkYSgnc3BsaXQnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ5ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wudG9QcmltaXRpdmVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3ByaW1pdGl2ZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkOSgndG9QcmltaXRpdmUnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ4ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wudG9TdHJpbmdUYWdgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3N0cmluZ3RhZ1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkOCgndG9TdHJpbmdUYWcnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ3ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wudW5zY29wYWJsZXNgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC51bnNjb3BhYmxlc1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNygndW5zY29wYWJsZXMnKTtcblxudmFyIGdsb2JhbCRqID0gZ2xvYmFsJFA7XG52YXIgc2V0VG9TdHJpbmdUYWckMSA9IHNldFRvU3RyaW5nVGFnJDU7IC8vIEpTT05bQEB0b1N0cmluZ1RhZ10gcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi1AQHRvc3RyaW5ndGFnXG5cbnNldFRvU3RyaW5nVGFnJDEoZ2xvYmFsJGouSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxudmFyIHBhdGgkbCA9IHBhdGgkeTtcbnZhciBzeW1ib2wkNSA9IHBhdGgkbC5TeW1ib2w7XG5cbnZhciBwYXJlbnQkVyA9IHN5bWJvbCQ1O1xudmFyIHN5bWJvbCQ0ID0gcGFyZW50JFc7XG5cbnZhciBwYXJlbnQkViA9IHN5bWJvbCQ0O1xudmFyIHN5bWJvbCQzID0gcGFyZW50JFY7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNiA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLmFzeW5jRGlzcG9zZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXVzaW5nLXN0YXRlbWVudFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNignYXN5bmNEaXNwb3NlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLmRpc3Bvc2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC11c2luZy1zdGF0ZW1lbnRcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDUoJ2Rpc3Bvc2UnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ0ID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wubWF0Y2hlcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDQoJ21hdGNoZXInKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQzID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wubWV0YWRhdGFgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1kZWNvcmF0b3JzXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQzKCdtZXRhZGF0YScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDIgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5vYnNlcnZhYmxlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkMignb2JzZXJ2YWJsZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDEgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5wYXR0ZXJuTWF0Y2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQxKCdwYXR0ZXJuTWF0Y2gnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsO1xuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdyZXBsYWNlQWxsJyk7XG5cbnZhciBwYXJlbnQkVSA9IHN5bWJvbCQzOyAvLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcblxudmFyIHN5bWJvbCQyID0gcGFyZW50JFU7XG5cbnZhciBzeW1ib2wkMSA9IHN5bWJvbCQyO1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBzeW1ib2wkMSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKGFycikgfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbnZhciAkJHkgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRpID0gZ2xvYmFsJFA7XG52YXIgaXNBcnJheSQzID0gaXNBcnJheSRkO1xudmFyIGlzQ29uc3RydWN0b3IkMSA9IGlzQ29uc3RydWN0b3IkNDtcbnZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkajtcbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDcgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgd2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDMgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG52YXIgdW4kU2xpY2UgPSBhcnJheVNsaWNlJDU7XG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCQzID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQzKCdzbGljZScpO1xudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG52YXIgQXJyYXkkMiA9IGdsb2JhbCRpLkFycmF5O1xudmFyIG1heCQxID0gTWF0aC5tYXg7IC8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcblxuJCR5KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQzXG59LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMSh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNyhPKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleCQyKHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgkMihlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTsgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXG5cbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcblxuICAgIGlmIChpc0FycmF5JDMoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjsgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblxuICAgICAgaWYgKGlzQ29uc3RydWN0b3IkMShDb25zdHJ1Y3RvcikgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSQyIHx8IGlzQXJyYXkkMyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QkOShDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTJDFdO1xuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEFycmF5JDIgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW4kU2xpY2UoTywgaywgZmluKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSQyIDogQ29uc3RydWN0b3IpKG1heCQxKGZpbiAtIGssIDApKTtcblxuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eSQxKHJlc3VsdCwgbiwgT1trXSk7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRqID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgc2xpY2UkNiA9IGVudHJ5VmlydHVhbCRqKCdBcnJheScpLnNsaWNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiRqID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkZyA9IHNsaWNlJDY7XG52YXIgQXJyYXlQcm90b3R5cGUkaCA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNsaWNlJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNsaWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGggfHwgaXNQcm90b3R5cGVPZiRqKEFycmF5UHJvdG90eXBlJGgsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGguc2xpY2UgPyBtZXRob2QkZyA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkVCA9IHNsaWNlJDU7XG52YXIgc2xpY2UkNCA9IHBhcmVudCRUO1xuXG52YXIgcGFyZW50JFMgPSBzbGljZSQ0O1xudmFyIHNsaWNlJDMgPSBwYXJlbnQkUztcblxudmFyIHBhcmVudCRSID0gc2xpY2UkMztcbnZhciBzbGljZSQyID0gcGFyZW50JFI7XG5cbnZhciBzbGljZSQxID0gc2xpY2UkMjtcblxudmFyIHBhcmVudCRRID0gZnJvbSQ0O1xudmFyIGZyb20kMiA9IHBhcmVudCRRO1xuXG52YXIgcGFyZW50JFAgPSBmcm9tJDI7XG52YXIgZnJvbSQxID0gcGFyZW50JFA7XG5cbnZhciBmcm9tID0gZnJvbSQxO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDkobywgbWluTGVuKSB7XG4gIHZhciBfY29udGV4dDtcblxuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOShvLCBtaW5MZW4pO1xuXG4gIHZhciBuID0gc2xpY2UkMShfY29udGV4dCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dCwgOCwgLTEpO1xuXG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxudmFyIFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xudmFyIGl0ZXJhdG9yJDUgPSBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoJ2l0ZXJhdG9yJyk7XG5cbnZhciBwYXJlbnQkTyA9IGl0ZXJhdG9yJDU7XG52YXIgaXRlcmF0b3IkNCA9IHBhcmVudCRPO1xuXG52YXIgcGFyZW50JE4gPSBpdGVyYXRvciQ0O1xudmFyIGl0ZXJhdG9yJDMgPSBwYXJlbnQkTjtcblxudmFyIHBhcmVudCRNID0gaXRlcmF0b3IkMztcbnZhciBpdGVyYXRvciQyID0gcGFyZW50JE07XG5cbnZhciBpdGVyYXRvciQxID0gaXRlcmF0b3IkMjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBzeW1ib2wkMSAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBpdGVyYXRvciQxID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBzeW1ib2wkMSAmJiBvYmouY29uc3RydWN0b3IgPT09IHN5bWJvbCQxICYmIG9iaiAhPT0gc3ltYm9sJDEucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoaXNBcnJheSQ1KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIHN5bWJvbCQxICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEoaXRlcikgIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbnZhciBzeW1ib2wgPSBzeW1ib2wkNDtcblxudmFyIGVudHJ5VmlydHVhbCRpID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgY29uY2F0JDMgPSBlbnRyeVZpcnR1YWwkaSgnQXJyYXknKS5jb25jYXQ7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGkgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRmID0gY29uY2F0JDM7XG52YXIgQXJyYXlQcm90b3R5cGUkZyA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGNvbmNhdCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5jb25jYXQ7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZyB8fCBpc1Byb3RvdHlwZU9mJGkoQXJyYXlQcm90b3R5cGUkZywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZy5jb25jYXQgPyBtZXRob2QkZiA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkTCA9IGNvbmNhdCQyO1xudmFyIGNvbmNhdCQxID0gcGFyZW50JEw7XG5cbnZhciBjb25jYXQgPSBjb25jYXQkMTtcblxudmFyIHNsaWNlID0gc2xpY2UkNDtcblxudmFyICQkeCA9IF9leHBvcnQ7XG52YXIgb3duS2V5cyQ4ID0gb3duS2V5cyRhOyAvLyBgUmVmbGVjdC5vd25LZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5vd25rZXlzXG5cbiQkeCh7XG4gIHRhcmdldDogJ1JlZmxlY3QnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIG93bktleXM6IG93bktleXMkOFxufSk7XG5cbnZhciBwYXRoJGsgPSBwYXRoJHk7XG52YXIgb3duS2V5cyQ3ID0gcGF0aCRrLlJlZmxlY3Qub3duS2V5cztcblxudmFyIHBhcmVudCRLID0gb3duS2V5cyQ3O1xudmFyIG93bktleXMkNiA9IHBhcmVudCRLO1xuXG52YXIgb3duS2V5cyQ1ID0gb3duS2V5cyQ2O1xuXG52YXIgaXNBcnJheSQyID0gaXNBcnJheSQ4O1xuXG52YXIgJCR3ID0gX2V4cG9ydDtcbnZhciAkbWFwID0gYXJyYXlJdGVyYXRpb24ubWFwO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDIgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDIoJ21hcCcpOyAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbiQkdyh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMlxufSwge1xuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGggPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBtYXAkNiA9IGVudHJ5VmlydHVhbCRoKCdBcnJheScpLm1hcDtcblxudmFyIGlzUHJvdG90eXBlT2YkaCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGUgPSBtYXAkNjtcbnZhciBBcnJheVByb3RvdHlwZSRmID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgbWFwJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0Lm1hcDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRmIHx8IGlzUHJvdG90eXBlT2YkaChBcnJheVByb3RvdHlwZSRmLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRmLm1hcCA/IG1ldGhvZCRlIDogb3duO1xufTtcblxudmFyIHBhcmVudCRKID0gbWFwJDU7XG52YXIgbWFwJDQgPSBwYXJlbnQkSjtcblxudmFyIG1hcCQzID0gbWFwJDQ7XG5cbnZhciAkJHYgPSBfZXhwb3J0O1xudmFyIHRvT2JqZWN0JDYgPSB0b09iamVjdCRlO1xudmFyIG5hdGl2ZUtleXMgPSBvYmplY3RLZXlzJDQ7XG52YXIgZmFpbHMkZCA9IGZhaWxzJHQ7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQzID0gZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUtleXMoMSk7XG59KTsgLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcblxuJCR2KHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTJDNcbn0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0JDYoaXQpKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGogPSBwYXRoJHk7XG52YXIga2V5cyQ2ID0gcGF0aCRqLk9iamVjdC5rZXlzO1xuXG52YXIgcGFyZW50JEkgPSBrZXlzJDY7XG52YXIga2V5cyQ1ID0gcGFyZW50JEk7XG5cbnZhciBrZXlzJDQgPSBrZXlzJDU7XG5cbnZhciAkJHUgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRoID0gZ2xvYmFsJFA7XG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgRGF0ZSQxID0gZ2xvYmFsJGguRGF0ZTtcbnZhciBnZXRUaW1lID0gdW5jdXJyeVRoaXMkYyhEYXRlJDEucHJvdG90eXBlLmdldFRpbWUpOyAvLyBgRGF0ZS5ub3dgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1kYXRlLm5vd1xuXG4kJHUoe1xuICB0YXJnZXQ6ICdEYXRlJyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gZ2V0VGltZShuZXcgRGF0ZSQxKCkpO1xuICB9XG59KTtcblxudmFyIHBhdGgkaSA9IHBhdGgkeTtcbnZhciBub3ckMyA9IHBhdGgkaS5EYXRlLm5vdztcblxudmFyIHBhcmVudCRIID0gbm93JDM7XG52YXIgbm93JDIgPSBwYXJlbnQkSDtcblxudmFyIG5vdyQxID0gbm93JDI7XG5cbnZhciBmYWlscyRjID0gZmFpbHMkdDtcblxudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkNiA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzJGMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LCAxKTtcbiAgfSk7XG59O1xuXG52YXIgJGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkNSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciBTVFJJQ1RfTUVUSE9EJDUgPSBhcnJheU1ldGhvZElzU3RyaWN0JDUoJ2ZvckVhY2gnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcblxudmFyIGFycmF5Rm9yRWFjaCA9ICFTVFJJQ1RfTUVUSE9EJDUgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbi8qICwgdGhpc0FyZyAqL1xuKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG59IDogW10uZm9yRWFjaDtcblxudmFyICQkdCA9IF9leHBvcnQ7XG52YXIgZm9yRWFjaCQ2ID0gYXJyYXlGb3JFYWNoOyAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1mb3JlYWNoIC0tIHNhZmVcblxuJCR0KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBbXS5mb3JFYWNoICE9IGZvckVhY2gkNlxufSwge1xuICBmb3JFYWNoOiBmb3JFYWNoJDZcbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGcgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBmb3JFYWNoJDUgPSBlbnRyeVZpcnR1YWwkZygnQXJyYXknKS5mb3JFYWNoO1xuXG52YXIgcGFyZW50JEcgPSBmb3JFYWNoJDU7XG52YXIgZm9yRWFjaCQ0ID0gcGFyZW50JEc7XG5cbnZhciBjbGFzc29mJDYgPSBjbGFzc29mJGU7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkZyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGQgPSBmb3JFYWNoJDQ7XG52YXIgQXJyYXlQcm90b3R5cGUkZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBET01JdGVyYWJsZXMkMyA9IHtcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBOb2RlTGlzdDogdHJ1ZVxufTtcblxudmFyIGZvckVhY2gkMyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZm9yRWFjaDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRlIHx8IGlzUHJvdG90eXBlT2YkZyhBcnJheVByb3RvdHlwZSRlLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRlLmZvckVhY2ggfHwgaGFzT3duJDYoRE9NSXRlcmFibGVzJDMsIGNsYXNzb2YkNihpdCkpID8gbWV0aG9kJGQgOiBvd247XG59O1xuXG52YXIgZm9yRWFjaCQyID0gZm9yRWFjaCQzO1xuXG52YXIgJCRzID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0FycmF5JDEgPSBpc0FycmF5JGQ7XG52YXIgdW4kUmV2ZXJzZSA9IHVuY3VycnlUaGlzJGIoW10ucmV2ZXJzZSk7XG52YXIgdGVzdCQxID0gWzEsIDJdOyAvLyBgQXJyYXkucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmV2ZXJzZVxuLy8gZml4IGZvciBTYWZhcmkgMTIuMCBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODg3OTRcblxuJCRzKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBTdHJpbmcodGVzdCQxKSA9PT0gU3RyaW5nKHRlc3QkMS5yZXZlcnNlKCkpXG59LCB7XG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduIC0tIGRpcnR5IGhhY2tcbiAgICBpZiAoaXNBcnJheSQxKHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiB1biRSZXZlcnNlKHRoaXMpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRmID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgcmV2ZXJzZSQzID0gZW50cnlWaXJ0dWFsJGYoJ0FycmF5JykucmV2ZXJzZTtcblxudmFyIGlzUHJvdG90eXBlT2YkZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGMgPSByZXZlcnNlJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkZCA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHJldmVyc2UkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQucmV2ZXJzZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRkIHx8IGlzUHJvdG90eXBlT2YkZihBcnJheVByb3RvdHlwZSRkLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRkLnJldmVyc2UgPyBtZXRob2QkYyA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkRiA9IHJldmVyc2UkMjtcbnZhciByZXZlcnNlJDEgPSBwYXJlbnQkRjtcblxudmFyIHJldmVyc2UgPSByZXZlcnNlJDE7XG5cbnZhciAkJHIgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRnID0gZ2xvYmFsJFA7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDYgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCRlO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQxID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMSA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDEoJ3NwbGljZScpO1xudmFyIFR5cGVFcnJvciQ4ID0gZ2xvYmFsJGcuVHlwZUVycm9yO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGxlbmd0aCBleGNlZWRlZCc7IC8vIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblxuJCRyKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQxXG59LCB7XG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudFxuICAvKiAsIC4uLml0ZW1zICovXG4gICkge1xuICAgIHZhciBPID0gdG9PYmplY3QkNSh0aGlzKTtcbiAgICB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkNihPKTtcbiAgICB2YXIgYWN0dWFsU3RhcnQgPSB0b0Fic29sdXRlSW5kZXgkMShzdGFydCwgbGVuKTtcbiAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5zZXJ0Q291bnQsIGFjdHVhbERlbGV0ZUNvdW50LCBBLCBrLCBmcm9tLCB0bztcblxuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IDA7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFyZ3VtZW50c0xlbmd0aCAtIDI7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyT3JJbmZpbml0eShkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQgPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IkOChNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEKTtcbiAgICB9XG5cbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDEoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuXG4gICAgZm9yIChrID0gMDsgayA8IGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgIGZyb20gPSBhY3R1YWxTdGFydCArIGs7XG4gICAgICBpZiAoZnJvbSBpbiBPKSBjcmVhdGVQcm9wZXJ0eShBLCBrLCBPW2Zyb21dKTtcbiAgICB9XG5cbiAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xuXG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO2Vsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGsgPSBsZW47IGsgPiBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50OyBrLS0pIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrID4gYWN0dWFsU3RhcnQ7IGstLSkge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50IC0gMTtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07ZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IGluc2VydENvdW50OyBrKyspIHtcbiAgICAgIE9bayArIGFjdHVhbFN0YXJ0XSA9IGFyZ3VtZW50c1trICsgMl07XG4gICAgfVxuXG4gICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50O1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRlID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgc3BsaWNlJDQgPSBlbnRyeVZpcnR1YWwkZSgnQXJyYXknKS5zcGxpY2U7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGUgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRiID0gc3BsaWNlJDQ7XG52YXIgQXJyYXlQcm90b3R5cGUkYyA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNwbGljZSQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zcGxpY2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkYyB8fCBpc1Byb3RvdHlwZU9mJGUoQXJyYXlQcm90b3R5cGUkYywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkYy5zcGxpY2UgPyBtZXRob2QkYiA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkRSA9IHNwbGljZSQzO1xudmFyIHNwbGljZSQyID0gcGFyZW50JEU7XG5cbnZhciBzcGxpY2UkMSA9IHNwbGljZSQyO1xuXG52YXIgJCRxID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcblxuJCRxKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZVxufSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWxcbiAgLyogLCBmcm9tSW5kZXggPSAwICovXG4gICkge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7IC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxudmFyIGVudHJ5VmlydHVhbCRkID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgaW5jbHVkZXMkNCA9IGVudHJ5VmlydHVhbCRkKCdBcnJheScpLmluY2x1ZGVzO1xuXG52YXIgaXNPYmplY3QkOCA9IGlzT2JqZWN0JGo7XG52YXIgY2xhc3NvZiQ1ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgTUFUQ0gkMSA9IHdlbGxLbm93blN5bWJvbCQyKCdtYXRjaCcpOyAvLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxuXG52YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QkOChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkNShpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJFA7XG52YXIgaXNSZWdFeHAgPSBpc1JlZ2V4cDtcbnZhciBUeXBlRXJyb3IkNyA9IGdsb2JhbCRmLlR5cGVFcnJvcjtcblxudmFyIG5vdEFSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvciQ3KFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9XG5cbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2wkMSgnbWF0Y2gnKTtcblxudmFyIGNvcnJlY3RJc1JlZ2V4cExvZ2ljID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG5cbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyICQkcCA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgbm90QVJlZ0V4cCA9IG5vdEFSZWdleHA7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xudmFyIHRvU3RyaW5nJDQgPSB0b1N0cmluZyQ4O1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gY29ycmVjdElzUmVnZXhwTG9naWM7XG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzJGEoJycuaW5kZXhPZik7IC8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuXG4kJHAoe1xuICB0YXJnZXQ6ICdTdHJpbmcnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJylcbn0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZ1xuICAvKiAsIHBvc2l0aW9uID0gMCAqL1xuICApIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZih0b1N0cmluZyQ0KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSh0aGlzKSksIHRvU3RyaW5nJDQobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpKSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRjID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgaW5jbHVkZXMkMyA9IGVudHJ5VmlydHVhbCRjKCdTdHJpbmcnKS5pbmNsdWRlcztcblxudmFyIGlzUHJvdG90eXBlT2YkZCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgYXJyYXlNZXRob2QgPSBpbmNsdWRlcyQ0O1xudmFyIHN0cmluZ01ldGhvZCA9IGluY2x1ZGVzJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkYiA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xuXG52YXIgaW5jbHVkZXMkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuaW5jbHVkZXM7XG4gIGlmIChpdCA9PT0gQXJyYXlQcm90b3R5cGUkYiB8fCBpc1Byb3RvdHlwZU9mJGQoQXJyYXlQcm90b3R5cGUkYiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkYi5pbmNsdWRlcykgcmV0dXJuIGFycmF5TWV0aG9kO1xuXG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgfHwgaXQgPT09IFN0cmluZ1Byb3RvdHlwZSB8fCBpc1Byb3RvdHlwZU9mJGQoU3RyaW5nUHJvdG90eXBlLCBpdCkgJiYgb3duID09PSBTdHJpbmdQcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgICByZXR1cm4gc3RyaW5nTWV0aG9kO1xuICB9XG5cbiAgcmV0dXJuIG93bjtcbn07XG5cbnZhciBwYXJlbnQkRCA9IGluY2x1ZGVzJDI7XG52YXIgaW5jbHVkZXMkMSA9IHBhcmVudCREO1xuXG52YXIgaW5jbHVkZXMgPSBpbmNsdWRlcyQxO1xuXG52YXIgJCRvID0gX2V4cG9ydDtcbnZhciBmYWlscyRiID0gZmFpbHMkdDtcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkZTtcbnZhciBuYXRpdmVHZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQyID0gZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUdldFByb3RvdHlwZU9mKDEpO1xufSk7IC8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcblxuJCRvKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTJDIsXG4gIHNoYW06ICFDT1JSRUNUX1BST1RPVFlQRV9HRVRURVJcbn0sIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZU9mKHRvT2JqZWN0JDQoaXQpKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGggPSBwYXRoJHk7XG52YXIgZ2V0UHJvdG90eXBlT2YkNiA9IHBhdGgkaC5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBwYXJlbnQkQyA9IGdldFByb3RvdHlwZU9mJDY7XG52YXIgZ2V0UHJvdG90eXBlT2YkNSA9IHBhcmVudCRDO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkNCA9IGdldFByb3RvdHlwZU9mJDU7XG5cbnZhciAkJG4gPSBfZXhwb3J0O1xudmFyICRmaWx0ZXIgPSBhcnJheUl0ZXJhdGlvbi5maWx0ZXI7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblxuJCRuKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVFxufSwge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGIgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBmaWx0ZXIkMyA9IGVudHJ5VmlydHVhbCRiKCdBcnJheScpLmZpbHRlcjtcblxudmFyIGlzUHJvdG90eXBlT2YkYyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGEgPSBmaWx0ZXIkMztcbnZhciBBcnJheVByb3RvdHlwZSRhID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZmlsdGVyJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZpbHRlcjtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRhIHx8IGlzUHJvdG90eXBlT2YkYyhBcnJheVByb3RvdHlwZSRhLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRhLmZpbHRlciA/IG1ldGhvZCRhIDogb3duO1xufTtcblxudmFyIHBhcmVudCRCID0gZmlsdGVyJDI7XG52YXIgZmlsdGVyJDEgPSBwYXJlbnQkQjtcblxudmFyIGZpbHRlciA9IGZpbHRlciQxO1xuXG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDQ7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzJDkoJHByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBwdXNoJDIgPSB1bmN1cnJ5VGhpcyQ5KFtdLnB1c2gpOyAvLyBgT2JqZWN0LnsgZW50cmllcywgdmFsdWVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxudmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICBrZXkgPSBrZXlzW2krK107XG5cbiAgICAgIGlmICghREVTQ1JJUFRPUlMkNCB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZShPLCBrZXkpKSB7XG4gICAgICAgIHB1c2gkMihyZXN1bHQsIFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxudmFyIG9iamVjdFRvQXJyYXkgPSB7XG4gIC8vIGBPYmplY3QuZW50cmllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbiAgZW50cmllczogY3JlYXRlTWV0aG9kJDIodHJ1ZSksXG4gIC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG4gIHZhbHVlczogY3JlYXRlTWV0aG9kJDIoZmFsc2UpXG59O1xuXG52YXIgJCRtID0gX2V4cG9ydDtcbnZhciAkdmFsdWVzID0gb2JqZWN0VG9BcnJheS52YWx1ZXM7IC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuXG4kJG0oe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKE8pIHtcbiAgICByZXR1cm4gJHZhbHVlcyhPKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGcgPSBwYXRoJHk7XG5wYXRoJGcuT2JqZWN0LnZhbHVlcztcblxudmFyIHdoaXRlc3BhY2VzJDQgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICsgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG52YXIgdG9TdHJpbmckMyA9IHRvU3RyaW5nJDg7XG52YXIgd2hpdGVzcGFjZXMkMyA9IHdoaXRlc3BhY2VzJDQ7XG52YXIgcmVwbGFjZSQxID0gdW5jdXJyeVRoaXMkOCgnJy5yZXBsYWNlKTtcbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMkMyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTsgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gcmVwbGFjZSQxKHN0cmluZywgbHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHJlcGxhY2UkMShzdHJpbmcsIHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdUcmltID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QkMSgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCQxKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kJDEoMylcbn07XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCRQO1xudmFyIGZhaWxzJGEgPSBmYWlscyR0O1xudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ4O1xudmFyIHRyaW0kMSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciB3aGl0ZXNwYWNlcyQyID0gd2hpdGVzcGFjZXMkNDtcbnZhciAkcGFyc2VJbnQkMSA9IGdsb2JhbCRlLnBhcnNlSW50O1xudmFyIFN5bWJvbCQyID0gZ2xvYmFsJGUuU3ltYm9sO1xudmFyIElURVJBVE9SJDEgPSBTeW1ib2wkMiAmJiBTeW1ib2wkMi5pdGVyYXRvcjtcbnZhciBoZXggPSAvXlsrLV0/MHgvaTtcbnZhciBleGVjJDEgPSB1bmN1cnJ5VGhpcyQ3KGhleC5leGVjKTtcbnZhciBGT1JDRUQkNCA9ICRwYXJzZUludCQxKHdoaXRlc3BhY2VzJDIgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQkMSh3aGl0ZXNwYWNlcyQyICsgJzB4MTYnKSAhPT0gMjIgLy8gTVMgRWRnZSAxOC0gYnJva2VuIHdpdGggYm94ZWQgc3ltYm9sc1xufHwgSVRFUkFUT1IkMSAmJiAhZmFpbHMkYShmdW5jdGlvbiAoKSB7XG4gICRwYXJzZUludCQxKE9iamVjdChJVEVSQVRPUiQxKSk7XG59KTsgLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG5cbnZhciBudW1iZXJQYXJzZUludCA9IEZPUkNFRCQ0ID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkge1xuICB2YXIgUyA9IHRyaW0kMSh0b1N0cmluZyQyKHN0cmluZykpO1xuICByZXR1cm4gJHBhcnNlSW50JDEoUywgcmFkaXggPj4+IDAgfHwgKGV4ZWMkMShoZXgsIFMpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludCQxO1xuXG52YXIgJCRsID0gX2V4cG9ydDtcbnZhciAkcGFyc2VJbnQgPSBudW1iZXJQYXJzZUludDsgLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG5cbiQkbCh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgZm9yY2VkOiBwYXJzZUludCAhPSAkcGFyc2VJbnRcbn0sIHtcbiAgcGFyc2VJbnQ6ICRwYXJzZUludFxufSk7XG5cbnZhciBwYXRoJGYgPSBwYXRoJHk7XG52YXIgX3BhcnNlSW50JDIgPSBwYXRoJGYucGFyc2VJbnQ7XG5cbnZhciBwYXJlbnQkQSA9IF9wYXJzZUludCQyO1xudmFyIF9wYXJzZUludCQxID0gcGFyZW50JEE7XG5cbnZhciBfcGFyc2VJbnQgPSBfcGFyc2VJbnQkMTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWluZGV4b2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxuXG52YXIgJCRrID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciAkSW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDQgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgdW4kSW5kZXhPZiA9IHVuY3VycnlUaGlzJDYoW10uaW5kZXhPZik7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhdW4kSW5kZXhPZiAmJiAxIC8gdW4kSW5kZXhPZihbMV0sIDEsIC0wKSA8IDA7XG52YXIgU1RSSUNUX01FVEhPRCQ0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ0KCdpbmRleE9mJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG5cbiQkayh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogTkVHQVRJVkVfWkVSTyB8fCAhU1RSSUNUX01FVEhPRCQ0XG59LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgKSB7XG4gICAgdmFyIGZyb21JbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICA/IHVuJEluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB8fCAwIDogJEluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkYSA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGluZGV4T2YkMyA9IGVudHJ5VmlydHVhbCRhKCdBcnJheScpLmluZGV4T2Y7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ5ID0gaW5kZXhPZiQzO1xudmFyIEFycmF5UHJvdG90eXBlJDkgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBpbmRleE9mJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmluZGV4T2Y7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkOSB8fCBpc1Byb3RvdHlwZU9mJGIoQXJyYXlQcm90b3R5cGUkOSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOS5pbmRleE9mID8gbWV0aG9kJDkgOiBvd247XG59O1xuXG52YXIgcGFyZW50JHogPSBpbmRleE9mJDI7XG52YXIgaW5kZXhPZiQxID0gcGFyZW50JHo7XG5cbnZhciBpbmRleE9mID0gaW5kZXhPZiQxO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGZhaWxzJDkgPSBmYWlscyR0O1xudmFyIHdoaXRlc3BhY2VzJDEgPSB3aGl0ZXNwYWNlcyQ0O1xudmFyIG5vbiA9ICdcXHUyMDBCXFx1MDA4NVxcdTE4MEUnOyAvLyBjaGVjayB0aGF0IGEgbWV0aG9kIHdvcmtzIHdpdGggdGhlIGNvcnJlY3QgbGlzdFxuLy8gb2Ygd2hpdGVzcGFjZXMgYW5kIGhhcyBhIGNvcnJlY3QgbmFtZVxuXG52YXIgc3RyaW5nVHJpbUZvcmNlZCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhd2hpdGVzcGFjZXMkMVtNRVRIT0RfTkFNRV0oKSB8fCBub25bTUVUSE9EX05BTUVdKCkgIT09IG5vbiB8fCBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiB3aGl0ZXNwYWNlcyQxW01FVEhPRF9OQU1FXS5uYW1lICE9PSBNRVRIT0RfTkFNRTtcbiAgfSk7XG59O1xuXG52YXIgJCRqID0gX2V4cG9ydDtcbnZhciAkdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gc3RyaW5nVHJpbUZvcmNlZDsgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuXG4kJGooe1xuICB0YXJnZXQ6ICdTdHJpbmcnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJylcbn0sIHtcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDkgPSBlbnRyeVZpcnR1YWwkbDtcbmVudHJ5VmlydHVhbCQ5KCdTdHJpbmcnKS50cmltO1xuXG52YXIgJCRpID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG52YXIgY3JlYXRlJDggPSBvYmplY3RDcmVhdGU7IC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuXG4kJGkoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBzaGFtOiAhREVTQ1JJUFRPUlMkM1xufSwge1xuICBjcmVhdGU6IGNyZWF0ZSQ4XG59KTtcblxudmFyIHBhdGgkZSA9IHBhdGgkeTtcbnZhciBPYmplY3QkMiA9IHBhdGgkZS5PYmplY3Q7XG5cbnZhciBjcmVhdGUkNyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiBPYmplY3QkMi5jcmVhdGUoUCwgRCk7XG59O1xuXG52YXIgcGFyZW50JHkgPSBjcmVhdGUkNztcbnZhciBjcmVhdGUkNiA9IHBhcmVudCR5O1xuXG52YXIgY3JlYXRlJDUgPSBjcmVhdGUkNjtcblxudmFyICQkaCA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkUDtcbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDk7XG52YXIgYXBwbHkkMyA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkOCA9IGZhaWxzJHQ7XG52YXIgQXJyYXkkMSA9IGdsb2JhbCRkLkFycmF5O1xudmFyICRzdHJpbmdpZnkgPSBnZXRCdWlsdEluJDIoJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzJDUoLy4vLmV4ZWMpO1xudmFyIGNoYXJBdCQxID0gdW5jdXJyeVRoaXMkNSgnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcyQ1KCcnLmNoYXJDb2RlQXQpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyQ1KCcnLnJlcGxhY2UpO1xudmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMkNSgxLjAudG9TdHJpbmcpO1xudmFyIHRlc3RlciA9IC9bXFx1RDgwMC1cXHVERkZGXS9nO1xudmFyIGxvdyA9IC9eW1xcdUQ4MDAtXFx1REJGRl0kLztcbnZhciBoaSA9IC9eW1xcdURDMDAtXFx1REZGRl0kLztcblxudmFyIGZpeCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQkMShzdHJpbmcsIG9mZnNldCAtIDEpO1xuICB2YXIgbmV4dCA9IGNoYXJBdCQxKHN0cmluZywgb2Zmc2V0ICsgMSk7XG5cbiAgaWYgKGV4ZWMobG93LCBtYXRjaCkgJiYgIWV4ZWMoaGksIG5leHQpIHx8IGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSB7XG4gICAgcmV0dXJuICdcXFxcdScgKyBudW1iZXJUb1N0cmluZyhjaGFyQ29kZUF0KG1hdGNoLCAwKSwgMTYpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufTtcblxudmFyIEZPUkNFRCQzID0gZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkc3RyaW5naWZ5KCdcXHVERjA2XFx1RDgzNCcpICE9PSAnXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIicgfHwgJHN0cmluZ2lmeSgnXFx1REVBRCcpICE9PSAnXCJcXFxcdWRlYWRcIic7XG59KTtcblxuaWYgKCRzdHJpbmdpZnkpIHtcbiAgLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC13ZWxsLWZvcm1lZC1zdHJpbmdpZnlcbiAgJCRoKHtcbiAgICB0YXJnZXQ6ICdKU09OJyxcbiAgICBzdGF0OiB0cnVlLFxuICAgIGZvcmNlZDogRk9SQ0VEJDNcbiAgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkkMShsKTsgaSA8IGw7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5JDMoJHN0cmluZ2lmeSwgbnVsbCwgYXJncyk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAnc3RyaW5nJyA/IHJlcGxhY2UocmVzdWx0LCB0ZXN0ZXIsIGZpeCkgOiByZXN1bHQ7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHBhdGgkZCA9IHBhdGgkeTtcbnZhciBhcHBseSQyID0gZnVuY3Rpb25BcHBseTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWpzb24gLS0gc2FmZVxuXG5pZiAoIXBhdGgkZC5KU09OKSBwYXRoJGQuSlNPTiA9IHtcbiAgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeVxufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcblxudmFyIHN0cmluZ2lmeSQzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgcmV0dXJuIGFwcGx5JDIocGF0aCRkLkpTT04uc3RyaW5naWZ5LCBudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIHBhcmVudCR4ID0gc3RyaW5naWZ5JDM7XG52YXIgc3RyaW5naWZ5JDIgPSBwYXJlbnQkeDtcblxudmFyIHN0cmluZ2lmeSQxID0gc3RyaW5naWZ5JDI7XG5cbnZhciBnbG9iYWwkYyA9IGdsb2JhbCRQO1xudmFyIFR5cGVFcnJvciQ2ID0gZ2xvYmFsJGMuVHlwZUVycm9yO1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMSA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgVHlwZUVycm9yJDYoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgJCRnID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRQO1xudmFyIGFwcGx5JDEgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkaDtcbnZhciB1c2VyQWdlbnQkMiA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBhcnJheVNsaWNlJDEgPSBhcnJheVNsaWNlJDU7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCQyKTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xuXG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCRiLkZ1bmN0aW9uO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0XG4gIC8qICwgLi4uYXJndW1lbnRzICovXG4gICkge1xuICAgIHZhciBib3VuZEFyZ3MgPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKSA+IDI7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQxKGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBhcnJheVNsaWNlJDEoYXJndW1lbnRzLCAyKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2NoZWR1bGVyKGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5JDEoZm4sIHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBmbiwgdGltZW91dCk7XG4gIH07XG59OyAvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI3RpbWVyc1xuXG5cbiQkZyh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgYmluZDogdHJ1ZSxcbiAgZm9yY2VkOiBNU0lFXG59LCB7XG4gIC8vIGBzZXRUaW1lb3V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0dGltZW91dFxuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbCRiLnNldFRpbWVvdXQpLFxuICAvLyBgc2V0SW50ZXJ2YWxgIG1ldGhvZFxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1zZXRpbnRlcnZhbFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwkYi5zZXRJbnRlcnZhbClcbn0pO1xuXG52YXIgcGF0aCRjID0gcGF0aCR5O1xudmFyIHNldFRpbWVvdXQkMiA9IHBhdGgkYy5zZXRUaW1lb3V0O1xuXG52YXIgc2V0VGltZW91dCQxID0gc2V0VGltZW91dCQyO1xuXG52YXIgdG9PYmplY3QkMyA9IHRvT2JqZWN0JGU7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7IC8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5cbnZhciBhcnJheUZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlXG4vKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqL1xuKSB7XG4gIHZhciBPID0gdG9PYmplY3QkMyh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDUoTyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG5cbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG5cbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJCRmID0gX2V4cG9ydDtcbnZhciBmaWxsJDQgPSBhcnJheUZpbGw7XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5cbiQkZih7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWVcbn0sIHtcbiAgZmlsbDogZmlsbCQ0XG59KTsgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXG52YXIgZW50cnlWaXJ0dWFsJDggPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBmaWxsJDMgPSBlbnRyeVZpcnR1YWwkOCgnQXJyYXknKS5maWxsO1xuXG52YXIgaXNQcm90b3R5cGVPZiRhID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkOCA9IGZpbGwkMztcbnZhciBBcnJheVByb3RvdHlwZSQ4ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZmlsbCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5maWxsO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDggfHwgaXNQcm90b3R5cGVPZiRhKEFycmF5UHJvdG90eXBlJDgsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDguZmlsbCA/IG1ldGhvZCQ4IDogb3duO1xufTtcblxudmFyIHBhcmVudCR3ID0gZmlsbCQyO1xudmFyIGZpbGwkMSA9IHBhcmVudCR3O1xuXG52YXIgZmlsbCA9IGZpbGwkMTtcblxuLyohIEhhbW1lci5KUyAtIHYyLjAuMTctcmMgLSAyMDE5LTEyLTE2XG4gKiBodHRwOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanNcbiAqXG4gKiBGb3JrZWQgQnkgTmF2ZXIgZWdqc1xuICogQ29weXJpZ2h0IChjKSBoYW1tZXJqc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cblxuXG52YXIgYXNzaWduO1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufSBlbHNlIHtcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxudmFyIGFzc2lnbiQxID0gYXNzaWduO1xudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHtcbiAgc3R5bGU6IHt9XG59IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIGFicyQxID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeDtcbiAgdmFyIHByb3A7XG4gIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgcHJvcCA9IHByZWZpeCA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5cblxudmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgLy8gd2luZG93IGlzIHVuZGVmaW5lZCBpbiBub2RlLmpzXG4gIHdpbiA9IHt9O1xufSBlbHNlIHtcbiAgd2luID0gd2luZG93O1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0b3VjaE1hcCA9IHt9O1xuICB2YXIgY3NzU3VwcG9ydHMgPSB3aW4uQ1NTICYmIHdpbi5DU1Muc3VwcG9ydHM7XG4gIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICByZXR1cm4gdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luLkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gIH0pO1xuICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxuXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xudmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luKTtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luLCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG52YXIgSU5QVVRfU1RBUlQgPSAxO1xudmFyIElOUFVUX01PVkUgPSAyO1xudmFyIElOUFVUX0VORCA9IDQ7XG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICB2YXIgaTtcblxuICBpZiAoIW9iaikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICBpKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5cblxuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cblxuXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gIC8vIG5vbmVcbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfVxuXG4gIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpOyAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuXG4gIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gIH0gLy8gcGFuLXggT1IgcGFuLXlcblxuXG4gIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgfSAvLyBtYW5pcHVsYXRpb25cblxuXG4gIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICB9XG5cbiAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRvdWNoQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBUb3VjaEFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKHZhbHVlID09PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICB9XG5cbiAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAqL1xuXG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICovXG5cblxuICBfcHJvdG8uY29tcHV0ZSA9IGZ1bmN0aW9uIGNvbXB1dGUoKSB7XG4gICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24gKHJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgX3Byb3RvLnByZXZlbnREZWZhdWx0cyA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0cyhpbnB1dCkge1xuICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247IC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuXG4gICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgLy8gZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG4gICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNOb25lIHx8IGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwgfHwgaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICovXG5cblxuICBfcHJvdG8ucHJldmVudFNyYyA9IGZ1bmN0aW9uIHByZXZlbnRTcmMoc3JjRXZlbnQpIHtcbiAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgcmV0dXJuIFRvdWNoQWN0aW9uO1xufSgpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG5cbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgdmFyIHBvaW50ZXJzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgIH07XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG5cbiAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cblxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gIH1cblxuICBpZiAoYWJzJDEoeCkgPj0gYWJzJDEoeSkpIHtcbiAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgfVxuXG4gIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyOyAvLyBsZXQgeyBvZmZzZXREZWx0YTpvZmZzZXQgPSB7fSwgcHJldkRlbHRhID0ge30sIHByZXZJbnB1dCA9IHt9IH0gPSBzZXNzaW9uO1xuICAvLyBqc2NzIHRocm93aW5nIGVycm9yIG9uIGRlZmFsdXQgZGVzdHJ1Y3R1cmVkIHZhbHVlcyBhbmQgd2l0aG91dCBkZWZhdWx0cyB0ZXN0cyBmYWlsXG5cbiAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgfTtcbiAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueVxuICAgIH07XG4gIH1cblxuICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQ7XG4gIHZhciBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcDtcbiAgdmFyIHZlbG9jaXR5O1xuICB2YXIgdmVsb2NpdHlYO1xuICB2YXIgdmVsb2NpdHlZO1xuICB2YXIgZGlyZWN0aW9uO1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcbiAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgdmVsb2NpdHkgPSBhYnMkMSh2LngpID4gYWJzJDEodi55KSA/IHYueCA6IHYueTtcbiAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgfVxuXG4gIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG4vKipcbiogQHByaXZhdGVcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cblxuICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG5cblxuICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0LFxuICAgICAgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gYWJzJDEob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzJDEob3ZlcmFsbFZlbG9jaXR5LnkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcbiAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBpbnB1dC5wb2ludGVycy5sZW5ndGggPiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzO1xuICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpOyAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuXG4gIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICB2YXIgc3JjRXZlbnRUYXJnZXQ7XG5cbiAgaWYgKHNyY0V2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH0gZWxzZSBpZiAoc3JjRXZlbnQucGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQucGF0aFswXTtcbiAgfSBlbHNlIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnRhcmdldDtcbiAgfVxuXG4gIGlmIChoYXNQYXJlbnQoc3JjRXZlbnRUYXJnZXQsIHRhcmdldCkpIHtcbiAgICB0YXJnZXQgPSBzcmNFdmVudFRhcmdldDtcbiAgfVxuXG4gIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgaXNGaXJzdCA9IGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gIGlmIChpc0ZpcnN0KSB7XG4gICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gIH0gLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG5cblxuICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7IC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuXG4gIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpOyAvLyBlbWl0IHNlY3JldCBldmVudFxuXG4gIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cblxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0OyAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgKi9cblxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dDtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICBpZiAoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQgfHwgIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgLy8gZG8gbm90IHVzZSA9PT0gaGVyZSwgdGVzdCBmYWlsc1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTsgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cblxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gIDM6IElOUFVUX1RZUEVfUEVOLFxuICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcblxufTtcbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnOyAvLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcblxuaWYgKHdpbi5NU1BvaW50ZXJFdmVudCAmJiAhd2luLlBvaW50ZXJFdmVudCkge1xuICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG5cbnZhciBQb2ludGVyRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvaW50ZXJFdmVudElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RvcmUgPSBfdGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcbiAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG4gICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDsgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7IC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgIH0gLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG5cblxuICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuXG4gICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcblxuICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50ZXJFdmVudElucHV0O1xufShJbnB1dCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5cblxuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuXG4gICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgfVxuXG4gICAgdmFsdWVzW2ldID0gdmFsO1xuICAgIGkrKztcbiAgfVxuXG4gIGlmIChzb3J0KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBUb3VjaElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIFRvdWNoSW5wdXQucHJvdG90eXBlLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudGFyZ2V0SWRzID0ge307IC8vIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkczsgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcblxuICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gIH1cblxuICB2YXIgaTtcbiAgdmFyIHRhcmdldFRvdWNoZXM7XG4gIHZhciBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICB2YXIgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXTtcbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0OyAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG5cbiAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICB9KTsgLy8gY29sbGVjdCB0b3VjaGVzXG5cbiAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICBpKys7XG4gICAgfVxuICB9IC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcblxuXG4gIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgfSAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIFsvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG59XG5cbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKE1vdXNlSW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICB9IC8vIG1vdXNlIG11c3QgYmUgZG93blxuXG5cbiAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW91c2VJbnB1dDtcbn0oSW5wdXQpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgdmFyIF9ldmVudERhdGEkY2hhbmdlZFBvaSA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnMsXG4gICAgICB0b3VjaCA9IF9ldmVudERhdGEkY2hhbmdlZFBvaVswXTtcblxuICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICB2YXIgbGFzdFRvdWNoID0ge1xuICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgIHk6IHRvdWNoLmNsaWVudFlcbiAgICB9O1xuICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuXG4gICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uIHJlbW92ZUxhc3RUb3VjaCgpIHtcbiAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYO1xuICB2YXIgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KTtcbiAgICB2YXIgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcblxuICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgVG91Y2hNb3VzZUlucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIFRvdWNoTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVG91Y2hNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gICAgZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KF9tYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIF9tYW5hZ2VyLCBjYWxsYmFjaykgfHwgdGhpcztcblxuICAgICAgX3RoaXMuaGFuZGxlciA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7XG4gICAgICAgIHZhciBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX01PVVNFO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG5cblxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF90aGlzKSksIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfdGhpcykpLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQoX3RoaXMubWFuYWdlciwgX3RoaXMuaGFuZGxlcik7XG4gICAgICBfdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgX3RoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICAgIF90aGlzLmxhc3RUb3VjaGVzID0gW107XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuXG5cbiAgICB2YXIgX3Byb3RvID0gVG91Y2hNb3VzZUlucHV0LnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG5cbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG91Y2hNb3VzZUlucHV0O1xuICB9KElucHV0KTtcblxuICByZXR1cm4gVG91Y2hNb3VzZUlucHV0O1xufSgpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICB2YXIgVHlwZTsgLy8gbGV0IGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gIGlmIChpbnB1dENsYXNzKSB7XG4gICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICB9IGVsc2Uge1xuICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gIH1cblxuICByZXR1cm4gbmV3IFR5cGUobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG5cbnZhciBfdW5pcXVlSWQgPSAxO1xuXG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG5cbiAgaWYgKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgfVxuXG4gIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgcmV0dXJuICdjYW5jZWwnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgcmV0dXJuICdtb3ZlJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5cbnZhciBSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgIGVuYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuICAgIHRoaXMubWFuYWdlciA9IG51bGw7IC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduJDEodGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcblxuICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIHJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8uZHJvcFJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBkcm9wUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlcXVpcmVGYWlsdXJlID0gZnVuY3Rpb24gcmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyb3BSZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIGRyb3BSZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uaGFzUmVxdWlyZUZhaWx1cmVzID0gZnVuY3Rpb24gaGFzUmVxdWlyZUZhaWx1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhblJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBjYW5SZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgIH0gLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG5cblxuICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuXG4gICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7XG4gICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICB9IC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG5cblxuICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by50cnlFbWl0ID0gZnVuY3Rpb24gdHJ5RW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgfSAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG5cblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYW4gd2UgZW1pdD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhbkVtaXQgPSBmdW5jdGlvbiBjYW5FbWl0KCkge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduJDEoe30sIGlucHV0RGF0YSk7IC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuXG4gICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG5cblxuICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7IC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcblxuICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgKiBAdmlydHVhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqIEByZXR1cm5zIHtjb25zdGFudH0gU1RBVEVcbiAgICovXG5cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0RGF0YSkge307XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgKiBAdmlydHVhbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICogQHZpcnR1YWxcbiAgICovXG5cblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xuXG4gIHJldHVybiBSZWNvZ25pemVyO1xufSgpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQSB0YXAgaXMgcmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgVGFwUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGFwUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFRhcFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0YXBzOiAxLFxuICAgICAgaW50ZXJ2YWw6IDMwMCxcbiAgICAgIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICB0aW1lOiAyNTAsXG4gICAgICAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgdGhyZXNob2xkOiA5LFxuICAgICAgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIHBvc1RocmVzaG9sZDogMTBcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpczsgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuXG4gICAgX3RoaXMucFRpbWUgPSBmYWxzZTtcbiAgICBfdGhpcy5wQ2VudGVyID0gZmFsc2U7XG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFwUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgfTtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG4gICAgdGhpcy5yZXNldCgpO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgfSAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuXG4gICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsIDogdHJ1ZTtcbiAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcbiAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cblxuICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcblxuICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuXG4gICAgICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgX3Byb3RvLmZhaWxUaW1lb3V0ID0gZnVuY3Rpb24gZmFpbFRpbWVvdXQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUYXBSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5cblxudmFyIEF0dHJSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShBdHRyUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgKi9cblxuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcbiAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpOyAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG5cbiAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICByZXR1cm4gQXR0clJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge2NvbnN0YW50fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgcmV0dXJuICdkb3duJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9VUCkge1xuICAgIHJldHVybiAndXAnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgcmV0dXJuICdyaWdodCc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgUGFuUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBhblJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUGFuUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgX3RoaXMucFggPSBudWxsO1xuICAgIF90aGlzLnBZID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFuUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbnM7XG4gIH07XG5cbiAgX3Byb3RvLmRpcmVjdGlvblRlc3QgPSBmdW5jdGlvbiBkaXJlY3Rpb25UZXN0KGlucHV0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZOyAvLyBsb2NrIHRvIGF4aXM/XG5cbiAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHggPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgIGhhc01vdmVkID0geCAhPT0gdGhpcy5wWDtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlyZWN0aW9uID0geSA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgaGFzTW92ZWQgPSB5ICE9PSB0aGlzLnBZO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoIC8vIHJlcGxhY2Ugd2l0aCBhIHN1cGVyIGNhbGxcbiAgICB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcbiAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBQYW5SZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBTd2lwZVJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShTd2lwZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTd2lwZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJiBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiYgaW5wdXQubWF4UG9pbnRlcnMgPT09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJiBhYnMkMSh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBTd2lwZVJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgUGluY2hSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGluY2hSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgfVxuXG4gICAgX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBQaW5jaFJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBSb3RhdGVSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm90YXRlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUm90YXRlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICB9O1xuXG4gIHJldHVybiBSb3RhdGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBQcmVzc1JlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFByZXNzUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgdGltZTogMjUxLFxuICAgICAgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgIHRocmVzaG9sZDogOVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIF90aGlzLl90aW1lciA9IG51bGw7XG4gICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUHJlc3NSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgfTtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuXG4gICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuXG4gICAgICAgIF90aGlzMi50cnlFbWl0KCk7XG4gICAgICB9LCBvcHRpb25zLnRpbWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBcInVwXCIsIGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFByZXNzUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAqL1xuICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBlbmFibGU6IHRydWUsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgY3NzUHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIHRvdWNoU2VsZWN0OiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdG91Y2hDYWxsb3V0OiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICBjb250ZW50Wm9vbWluZzogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIHVzZXJEcmFnOiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgKi9cbiAgICB0YXBIaWdobGlnaHRDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCJcbiAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAqIFRoaXMgaXMgc2VwYXJhdGVkIHdpdGggb3RoZXIgZGVmYXVsdHMgYmVjYXVzZSBvZiB0cmVlLXNoYWtpbmcuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxudmFyIHByZXNldCA9IFtbUm90YXRlUmVjb2duaXplciwge1xuICBlbmFibGU6IGZhbHNlXG59XSwgW1BpbmNoUmVjb2duaXplciwge1xuICBlbmFibGU6IGZhbHNlXG59LCBbJ3JvdGF0ZSddXSwgW1N3aXBlUmVjb2duaXplciwge1xuICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG59XSwgW1BhblJlY29nbml6ZXIsIHtcbiAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTFxufSwgWydzd2lwZSddXSwgW1RhcFJlY29nbml6ZXJdLCBbVGFwUmVjb2duaXplciwge1xuICBldmVudDogJ2RvdWJsZXRhcCcsXG4gIHRhcHM6IDJcbn0sIFsndGFwJ11dLCBbUHJlc3NSZWNvZ25pemVyXV07XG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG5cbiAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByb3A7XG4gIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG5cbiAgICBpZiAoYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgXCJcIjtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghYWRkKSB7XG4gICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5cblxuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG4vKipcbiogQHByaXZhdGVcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZWNvZ25pemVyID0gX3RoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcblxuICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24kMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICovXG5cblxuICBfcHJvdG8uc3RvcCA9IGZ1bmN0aW9uIHN0b3AoZm9yY2UpIHtcbiAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuICAgIHZhciByZWNvZ25pemVyO1xuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG5cbiAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cblxuICAgIGlmICghY3VyUmVjb2duaXplciB8fCBjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTsgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cblxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHtcbiAgICAgICAgLy8gM1xuICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgfSAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG5cblxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIGN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgKi9cblxuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09PSByZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICovXG5cblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJhZGRcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVtb3ZlIGV4aXN0aW5nXG5cblxuICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiByZWNvZ25pemVyO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwicmVtb3ZlXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0UmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCB0YXJnZXRSZWNvZ25pemVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgIH0gLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG5cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICovXG5cblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gTWFuYWdlcjtcbn0oKTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFNpbmdsZVRvdWNoSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShTaW5nbGVUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTsgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpOyAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFNpbmdsZVRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gXCJERVBSRUNBVEVEIE1FVEhPRDogXCIgKyBuYW1lICsgXCJcXG5cIiArIG1lc3NhZ2UgKyBcIiBBVCBcXG5cIjtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKS5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcbiAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcblxuICAgIGlmIChsb2cpIHtcbiAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cblxuXG52YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICBpZiAoIW1lcmdlIHx8IG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5cbnZhciBtZXJnZSQyID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlO1xuICB2YXIgY2hpbGRQO1xuICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICBpZiAocHJvcGVydGllcykge1xuICAgIGFzc2lnbiQxKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBIYW1tZXIkMiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBIYW1tZXIgPVxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICAqL1xuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgX2V4dGVuZHMoe1xuICAgICAgcmVjb2duaXplcnM6IHByZXNldC5jb25jYXQoKVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICBIYW1tZXIuVkVSU0lPTiA9IFwiMi4wLjE3LXJjXCI7XG4gIEhhbW1lci5ESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0FMTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIEhhbW1lci5ESVJFQ1RJT05fTEVGVCA9IERJUkVDVElPTl9MRUZUO1xuICBIYW1tZXIuRElSRUNUSU9OX1JJR0hUID0gRElSRUNUSU9OX1JJR0hUO1xuICBIYW1tZXIuRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuICBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9WRVJUSUNBTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9OT05FID0gRElSRUNUSU9OX05PTkU7XG4gIEhhbW1lci5ESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuICBIYW1tZXIuSU5QVVRfU1RBUlQgPSBJTlBVVF9TVEFSVDtcbiAgSGFtbWVyLklOUFVUX01PVkUgPSBJTlBVVF9NT1ZFO1xuICBIYW1tZXIuSU5QVVRfRU5EID0gSU5QVVRfRU5EO1xuICBIYW1tZXIuSU5QVVRfQ0FOQ0VMID0gSU5QVVRfQ0FOQ0VMO1xuICBIYW1tZXIuU1RBVEVfUE9TU0lCTEUgPSBTVEFURV9QT1NTSUJMRTtcbiAgSGFtbWVyLlNUQVRFX0JFR0FOID0gU1RBVEVfQkVHQU47XG4gIEhhbW1lci5TVEFURV9DSEFOR0VEID0gU1RBVEVfQ0hBTkdFRDtcbiAgSGFtbWVyLlNUQVRFX0VOREVEID0gU1RBVEVfRU5ERUQ7XG4gIEhhbW1lci5TVEFURV9SRUNPR05JWkVEID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgSGFtbWVyLlNUQVRFX0NBTkNFTExFRCA9IFNUQVRFX0NBTkNFTExFRDtcbiAgSGFtbWVyLlNUQVRFX0ZBSUxFRCA9IFNUQVRFX0ZBSUxFRDtcbiAgSGFtbWVyLk1hbmFnZXIgPSBNYW5hZ2VyO1xuICBIYW1tZXIuSW5wdXQgPSBJbnB1dDtcbiAgSGFtbWVyLlRvdWNoQWN0aW9uID0gVG91Y2hBY3Rpb247XG4gIEhhbW1lci5Ub3VjaElucHV0ID0gVG91Y2hJbnB1dDtcbiAgSGFtbWVyLk1vdXNlSW5wdXQgPSBNb3VzZUlucHV0O1xuICBIYW1tZXIuUG9pbnRlckV2ZW50SW5wdXQgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgSGFtbWVyLlRvdWNoTW91c2VJbnB1dCA9IFRvdWNoTW91c2VJbnB1dDtcbiAgSGFtbWVyLlNpbmdsZVRvdWNoSW5wdXQgPSBTaW5nbGVUb3VjaElucHV0O1xuICBIYW1tZXIuUmVjb2duaXplciA9IFJlY29nbml6ZXI7XG4gIEhhbW1lci5BdHRyUmVjb2duaXplciA9IEF0dHJSZWNvZ25pemVyO1xuICBIYW1tZXIuVGFwID0gVGFwUmVjb2duaXplcjtcbiAgSGFtbWVyLlBhbiA9IFBhblJlY29nbml6ZXI7XG4gIEhhbW1lci5Td2lwZSA9IFN3aXBlUmVjb2duaXplcjtcbiAgSGFtbWVyLlBpbmNoID0gUGluY2hSZWNvZ25pemVyO1xuICBIYW1tZXIuUm90YXRlID0gUm90YXRlUmVjb2duaXplcjtcbiAgSGFtbWVyLlByZXNzID0gUHJlc3NSZWNvZ25pemVyO1xuICBIYW1tZXIub24gPSBhZGRFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLm9mZiA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIuZWFjaCA9IGVhY2g7XG4gIEhhbW1lci5tZXJnZSA9IG1lcmdlJDI7XG4gIEhhbW1lci5leHRlbmQgPSBleHRlbmQ7XG4gIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gIEhhbW1lci5hc3NpZ24gPSBhc3NpZ24kMTtcbiAgSGFtbWVyLmluaGVyaXQgPSBpbmhlcml0O1xuICBIYW1tZXIuYmluZEZuID0gYmluZEZuO1xuICBIYW1tZXIucHJlZml4ZWQgPSBwcmVmaXhlZDtcbiAgSGFtbWVyLnRvQXJyYXkgPSB0b0FycmF5O1xuICBIYW1tZXIuaW5BcnJheSA9IGluQXJyYXk7XG4gIEhhbW1lci51bmlxdWVBcnJheSA9IHVuaXF1ZUFycmF5O1xuICBIYW1tZXIuc3BsaXRTdHIgPSBzcGxpdFN0cjtcbiAgSGFtbWVyLmJvb2xPckZuID0gYm9vbE9yRm47XG4gIEhhbW1lci5oYXNQYXJlbnQgPSBoYXNQYXJlbnQ7XG4gIEhhbW1lci5hZGRFdmVudExpc3RlbmVycyA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSByZW1vdmVFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLmRlZmF1bHRzID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCB7XG4gICAgcHJlc2V0OiBwcmVzZXRcbiAgfSk7XG4gIHJldHVybiBIYW1tZXI7XG59KCk7IC8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxudmFyIFJlYWxIYW1tZXIgPSBIYW1tZXIkMjtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ4KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQyMTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDgobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDIxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MjEsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ4KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkOChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxyXG4gKiBVc2UgdGhpcyBzeW1ib2wgdG8gZGVsZXRlIHByb3BlcmllcyBpbiBkZWVwT2JqZWN0QXNzaWduLlxyXG4gKi9cblxudmFyIERFTEVURSA9IHN5bWJvbChcIkRFTEVURVwiKTtcbi8qKlxyXG4gKiBQdXJlIHZlcnNpb24gb2YgZGVlcE9iamVjdEFzc2lnbiwgaXQgZG9lc24ndCBtb2RpZnkgYW55IG9mIGl0J3MgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFzZSAtIFRoZSBiYXNlIG9iamVjdCB0aGF0IGZ1bGxmaWxzIHRoZSB3aG9sZSBpbnRlcmZhY2UgVC5cclxuICogQHBhcmFtIHVwZGF0ZXMgLSBVcGRhdGVzIHRoYXQgbWF5IGNoYW5nZSBvciBkZWxldGUgcHJvcHMuXHJcbiAqIEByZXR1cm5zIEEgYnJhbmQgbmV3IGluc3RhbmNlIHdpdGggYWxsIHRoZSBzdXBwbGllZCBvYmplY3RzIGRlZXBseSBtZXJnZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHB1cmVEZWVwT2JqZWN0QXNzaWduKGJhc2UpIHtcbiAgdmFyIF9jb250ZXh0O1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB1cGRhdGVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB1cGRhdGVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBkZWVwT2JqZWN0QXNzaWduLmFwcGx5KHZvaWQgMCwgY29uY2F0KF9jb250ZXh0ID0gW3t9LCBiYXNlXSkuY2FsbChfY29udGV4dCwgdXBkYXRlcykpO1xufVxuLyoqXHJcbiAqIERlZXAgdmVyc2lvbiBvZiBvYmplY3QgYXNzaWduIHdpdGggYWRkaXRpb25hbCBkZWxldGluZyBieSB0aGUgREVMRVRFIHN5bWJvbC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdHMgdG8gYmUgZGVlcGx5IG1lcmdlZC5cclxuICogQHJldHVybnMgVGhlIGZpcnN0IG9iamVjdCBmcm9tIHZhbHVlcy5cclxuICovXG5cblxuZnVuY3Rpb24gZGVlcE9iamVjdEFzc2lnbigpIHtcbiAgdmFyIG1lcmdlZCA9IGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIHN0cmlwRGVsZXRlKG1lcmdlZCk7XG4gIHJldHVybiBtZXJnZWQ7XG59XG4vKipcclxuICogRGVlcCB2ZXJzaW9uIG9mIG9iamVjdCBhc3NpZ24gd2l0aCBhZGRpdGlvbmFsIGRlbGV0aW5nIGJ5IHRoZSBERUxFVEUgc3ltYm9sLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIGRvZXNuJ3Qgc3RyaXAgdGhlIERFTEVURSBzeW1ib2xzIHNvIHRoZXkgbWF5IGVuZCB1cCBpbiB0aGUgZmluYWwgb2JqZWN0LlxyXG4gKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0cyB0byBiZSBkZWVwbHkgbWVyZ2VkLlxyXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgb2JqZWN0IGZyb20gdmFsdWVzLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgdmFsdWVzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBpZiAodmFsdWVzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9IGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPiAyKSB7XG4gICAgdmFyIF9jb250ZXh0MjtcblxuICAgIHJldHVybiBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkuYXBwbHkodm9pZCAwLCBjb25jYXQoX2NvbnRleHQyID0gW2RlZXBPYmplY3RBc3NpZ24odmFsdWVzWzBdLCB2YWx1ZXNbMV0pXSkuY2FsbChfY29udGV4dDIsIF90b0NvbnN1bWFibGVBcnJheShzbGljZSh2YWx1ZXMpLmNhbGwodmFsdWVzLCAyKSkpKTtcbiAgfVxuXG4gIHZhciBhID0gdmFsdWVzWzBdO1xuICB2YXIgYiA9IHZhbHVlc1sxXTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChvd25LZXlzJDUoYikpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGIsIHByb3ApKSA7ZWxzZSBpZiAoYltwcm9wXSA9PT0gREVMRVRFKSB7XG4gICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgfSBlbHNlIGlmIChhW3Byb3BdICE9PSBudWxsICYmIGJbcHJvcF0gIT09IG51bGwgJiYgX3R5cGVvZihhW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBfdHlwZW9mKGJbcHJvcF0pID09PSBcIm9iamVjdFwiICYmICFpc0FycmF5JDIoYVtwcm9wXSkgJiYgIWlzQXJyYXkkMihiW3Byb3BdKSkge1xuICAgICAgICBhW3Byb3BdID0gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KGFbcHJvcF0sIGJbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtwcm9wXSA9IGNsb25lKGJbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogRGVlcCBjbG9uZSBnaXZlbiBvYmplY3Qgb3IgYXJyYXkuIEluIGNhc2Ugb2YgcHJpbWl0aXZlIHNpbXBseSByZXR1cm4uXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gQW55dGhpbmcuXHJcbiAqIEByZXR1cm5zIERlZXAgY2xvbmVkIG9iamVjdC9hcnJheSBvciB1bmNoYW5nZWQgYS5cclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICBpZiAoaXNBcnJheSQyKGEpKSB7XG4gICAgcmV0dXJuIG1hcCQzKGEpLmNhbGwoYSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY2xvbmUodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKF90eXBlb2YoYSkgPT09IFwib2JqZWN0XCIgJiYgYSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkoe30sIGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhO1xuICB9XG59XG4vKipcclxuICogU3RyaXAgREVMRVRFIGZyb20gZ2l2ZW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIE9iamVjdCB3aGljaCBtYXkgY29udGFpbiBERUxFVEUgYnV0IHdvbid0IGFmdGVyIHRoaXMgaXMgZXhlY3V0ZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmlwRGVsZXRlKGEpIHtcbiAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBrZXlzJDQoYSk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBwcm9wID0gX09iamVjdCRrZXlzW19pXTtcblxuICAgIGlmIChhW3Byb3BdID09PSBERUxFVEUpIHtcbiAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBhW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICBzdHJpcERlbGV0ZShhW3Byb3BdKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBTZWVkYWJsZSwgZmFzdCBhbmQgcmVhc29uYWJseSBnb29kIChub3QgY3J5cHRvIGJ1dCBtb3JlIHRoYW4gb2theSBmb3Igb3VyXHJcbiAqIG5lZWRzKSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQWRhcHRlZCBmcm9tIHtAbGluayBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMTA0MjkxMDA3MzYvaHR0cDovL2JhYWdvZS5jb206ODAvZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0fS5cclxuICogT3JpZ2luYWwgYWxnb3JpdGhtIGNyZWF0ZWQgYnkgSm9oYW5uZXMgQmFhZ8O4ZSBcXDxiYWFnb2VcXEBiYWFnb2UuY29tXFw+IGluIDIwMTAuXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlIGEgc2VlZGVkIHBzZXVkbyByYW5kb20gZ2VuZXJhdG9yIGJhc2VkIG9uIEFsZWEgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cclxuICpcclxuICogQHBhcmFtIHNlZWQgLSBBbGwgc3VwcGxpZWQgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyBhIHNlZWQuIEluIGNhc2Ugbm90aGluZ1xyXG4gKiBpcyBzdXBwbGllZCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZCB0byBzZWVkIHRoZSBnZW5lcmF0b3IuXHJcbiAqIEByZXR1cm5zIEEgcmVhZHkgdG8gdXNlIHNlZWRlZCBnZW5lcmF0b3IuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIEFsZWEoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc2VlZCA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHNlZWRbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiBBbGVhSW1wbGVtZW50YXRpb24oc2VlZC5sZW5ndGggPyBzZWVkIDogW25vdyQxKCldKTtcbn1cbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBbW0FsZWFdXSB3aXRob3V0IHVzZXIgaW5wdXQgdmFsaWRhdGlvbi5cclxuICpcclxuICogQHBhcmFtIHNlZWQgLSBUaGUgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCB0byBzZWVkIHRoZSBnZW5lcmF0b3IuXHJcbiAqIEByZXR1cm5zIEEgcmVhZHkgdG8gdXNlIHNlZWRlZCBnZW5lcmF0b3IuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIEFsZWFJbXBsZW1lbnRhdGlvbihzZWVkKSB7XG4gIHZhciBfbWFzaFNlZWQgPSBtYXNoU2VlZChzZWVkKSxcbiAgICAgIF9tYXNoU2VlZDIgPSBfc2xpY2VkVG9BcnJheShfbWFzaFNlZWQsIDMpLFxuICAgICAgczAgPSBfbWFzaFNlZWQyWzBdLFxuICAgICAgczEgPSBfbWFzaFNlZWQyWzFdLFxuICAgICAgczIgPSBfbWFzaFNlZWQyWzJdO1xuXG4gIHZhciBjID0gMTtcblxuICB2YXIgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG5cbiAgICBzMCA9IHMxO1xuICAgIHMxID0gczI7XG4gICAgcmV0dXJuIHMyID0gdCAtIChjID0gdCB8IDApO1xuICB9O1xuXG4gIHJhbmRvbS51aW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gIH07IC8vIDJeMzJcblxuXG4gIHJhbmRvbS5mcmFjdDUzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYW5kb20oKSArIChyYW5kb20oKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2O1xuICB9OyAvLyAyXi01M1xuXG5cbiAgcmFuZG9tLmFsZ29yaXRobSA9IFwiQWxlYVwiO1xuICByYW5kb20uc2VlZCA9IHNlZWQ7XG4gIHJhbmRvbS52ZXJzaW9uID0gXCIwLjlcIjtcbiAgcmV0dXJuIHJhbmRvbTtcbn1cbi8qKlxyXG4gKiBUdXJuIGFyYml0cmFyeSBkYXRhIGludG8gdmFsdWVzIFtbQWxlYUltcGxlbWVudGF0aW9uXV0gY2FuIHVzZSB0byBnZW5lcmF0ZVxyXG4gKiByYW5kb20gbnVtYmVycy5cclxuICpcclxuICogQHBhcmFtIHNlZWQgLSBBcmJpdHJhcnkgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgc2VlZC5cclxuICogQHJldHVybnMgVGhyZWUgbnVtYmVycyB0byB1c2UgYXMgaW5pdGlhbCB2YWx1ZXMgZm9yIFtbQWxlYUltcGxlbWVudGF0aW9uXV0uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1hc2hTZWVkKCkge1xuICB2YXIgbWFzaCA9IE1hc2goKTtcbiAgdmFyIHMwID0gbWFzaChcIiBcIik7XG4gIHZhciBzMSA9IG1hc2goXCIgXCIpO1xuICB2YXIgczIgPSBtYXNoKFwiIFwiKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHMwIC09IG1hc2goaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldKTtcblxuICAgIGlmIChzMCA8IDApIHtcbiAgICAgIHMwICs9IDE7XG4gICAgfVxuXG4gICAgczEgLT0gbWFzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pO1xuXG4gICAgaWYgKHMxIDwgMCkge1xuICAgICAgczEgKz0gMTtcbiAgICB9XG5cbiAgICBzMiAtPSBtYXNoKGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG5cbiAgICBpZiAoczIgPCAwKSB7XG4gICAgICBzMiArPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbczAsIHMxLCBzMl07XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hc2ggZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgbm9ucHVyZSBmdW5jdGlvbiB0aGF0IHRha2VzIGFyYml0cmFyeSBbW01hc2hhYmxlXV0gZGF0YSBhbmQgdHVybnNcclxuICogdGhlbSBpbnRvIG51bWJlcnMuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHN0cmluZyA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cblxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xufVxuLyoqXG4gKiBTZXR1cCBhIG1vY2sgaGFtbWVyLmpzIG9iamVjdCwgZm9yIHVuaXQgdGVzdGluZy5cbiAqXG4gKiBJbnNwaXJhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9wdWxsLzY1OFxuICpcbiAqIEByZXR1cm5zIHt7b246IG5vb3AsIG9mZjogbm9vcCwgZGVzdHJveTogbm9vcCwgZW1pdDogbm9vcCwgZ2V0OiBnZXR9fVxuICovXG5cblxuZnVuY3Rpb24gaGFtbWVyTW9jaygpIHtcbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbiAgcmV0dXJuIHtcbiAgICBvbjogbm9vcCxcbiAgICBvZmY6IG5vb3AsXG4gICAgZGVzdHJveTogbm9vcCxcbiAgICBlbWl0OiBub29wLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0OiBub29wXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIEhhbW1lciQxID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5IYW1tZXIgfHwgUmVhbEhhbW1lciA6IGZ1bmN0aW9uICgpIHtcbiAgLy8gaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuIFJlcGxhY2luZyBpdCB3aXRoIGEgbW9jayBvYmplY3QuXG4gIHJldHVybiBoYW1tZXJNb2NrKCk7XG59O1xuLyoqXG4gKiBUdXJuIGFuIGVsZW1lbnQgaW50byBhbiBjbGlja1RvVXNlIGVsZW1lbnQuXG4gKiBXaGVuIG5vdCBhY3RpdmUsIHRoZSBlbGVtZW50IGhhcyBhIHRyYW5zcGFyZW50IG92ZXJsYXkuIFdoZW4gdGhlIG92ZXJsYXkgaXNcbiAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICogV2hlbiBhY3RpdmUsIHRoZSBlbGVtZW50IGlzIGRpc3BsYXllZCB3aXRoIGEgYmx1ZSBib3JkZXIgYXJvdW5kIGl0LCBhbmRcbiAqIHRoZSBpbnRlcmFjdGl2ZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjYW4gYmUgdXNlZC4gV2hlbiBjbGlja2VkIG91dHNpZGVcbiAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gKiBAY2xhc3MgQWN0aXZhdG9yXG4gKi9cblxuZnVuY3Rpb24gQWN0aXZhdG9yJDEoY29udGFpbmVyKSB7XG4gIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICBfY29udGV4dDM7XG5cbiAgdGhpcy5fY2xlYW51cFF1ZXVlID0gW107XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2RvbSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBvdmVybGF5OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gIH07XG5cbiAgdGhpcy5fZG9tLm92ZXJsYXkuY2xhc3NMaXN0LmFkZChcInZpcy1vdmVybGF5XCIpO1xuXG4gIHRoaXMuX2RvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZG9tLm92ZXJsYXkpO1xuXG4gIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5fZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpcy5fZG9tLm92ZXJsYXkpO1xuICB9KTtcblxuICB2YXIgaGFtbWVyID0gSGFtbWVyJDEodGhpcy5fZG9tLm92ZXJsYXkpO1xuICBoYW1tZXIub24oXCJ0YXBcIiwgYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMuX29uVGFwT3ZlcmxheSkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcblxuICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaGFtbWVyLmRlc3Ryb3koKTsgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZFxuICAgIC8vIGZyb20gbWVtb3J5KVxuICB9KTsgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcblxuXG4gIHZhciBldmVudHMgPSBbXCJ0YXBcIiwgXCJkb3VibGV0YXBcIiwgXCJwcmVzc1wiLCBcInBpbmNoXCIsIFwicGFuXCIsIFwicGFuc3RhcnRcIiwgXCJwYW5tb3ZlXCIsIFwicGFuZW5kXCJdO1xuXG4gIGZvckVhY2gkMihldmVudHMpLmNhbGwoZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBoYW1tZXIub24oZXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0pOyAvLyBhdHRhY2ggYSBjbGljayBldmVudCB0byB0aGUgd2luZG93LCBpbiBvcmRlciB0byBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgdGltZWxpbmVcblxuXG4gIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgdGhpcy5fb25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2spO1xuXG4gICAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX3RoaXMuX29uQ2xpY2spO1xuICAgIH0pO1xuICB9IC8vIHByZXBhcmUgZXNjYXBlIGtleSBsaXN0ZW5lciBmb3IgZGVhY3RpdmF0aW5nIHdoZW4gYWN0aXZlXG5cblxuICB0aGlzLl9lc2NMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChcImtleVwiIGluIGV2ZW50ID8gZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiIDogZXZlbnQua2V5Q29kZSA9PT0gMjdcbiAgICAvKiB0aGUga2V5Q29kZSBpcyBmb3IgSUUxMSAqL1xuICAgICkge1xuICAgICAgX3RoaXMuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfTtcbn0gLy8gdHVybiBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcblxuXG5FbWl0dGVyKEFjdGl2YXRvciQxLnByb3RvdHlwZSk7IC8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuXG5BY3RpdmF0b3IkMS5jdXJyZW50ID0gbnVsbDtcbi8qKlxuICogRGVzdHJveSB0aGUgYWN0aXZhdG9yLiBDbGVhbnMgdXAgYWxsIGNyZWF0ZWQgRE9NIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAqL1xuXG5BY3RpdmF0b3IkMS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9jb250ZXh0NCwgX2NvbnRleHQ1O1xuXG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChyZXZlcnNlKF9jb250ZXh0NCA9IHNwbGljZSQxKF9jb250ZXh0NSA9IHRoaXMuX2NsZWFudXBRdWV1ZSkuY2FsbChfY29udGV4dDUsIDApKS5jYWxsKF9jb250ZXh0NCkpLFxuICAgICAgX3N0ZXAyO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxufTtcbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cblxuXG5BY3RpdmF0b3IkMS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gIGlmIChBY3RpdmF0b3IkMS5jdXJyZW50KSB7XG4gICAgQWN0aXZhdG9yJDEuY3VycmVudC5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICBBY3RpdmF0b3IkMS5jdXJyZW50ID0gdGhpcztcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzLWFjdGl2ZVwiKTtcblxuICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIHRoaXMuZW1pdChcImFjdGl2YXRlXCIpOyAvLyB1Z2x5IGhhY2s6IGJpbmQgRVNDIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudHMsIGFzIHRoZSBOZXR3b3JrIHJlYmluZHMgYWxsXG4gIC8vIGtleWJvYXJkIGV2ZW50cyBvbiBhICdjaGFuZ2UnIGV2ZW50XG5cbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9lc2NMaXN0ZW5lcik7XG59O1xuLyoqXG4gKiBEZWFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAqL1xuXG5cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIHRoaXMuX2RvbS5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcInZpcy1hY3RpdmVcIik7XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9lc2NMaXN0ZW5lcik7XG4gIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgdGhpcy5lbWl0KFwiZGVhY3RpdmF0ZVwiKTtcbn07XG4vKipcbiAqIEhhbmRsZSBhIHRhcCBldmVudDogYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICpcbiAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuXG5cbkFjdGl2YXRvciQxLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgdGhpcy5hY3RpdmF0ZSgpO1xuICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBwYXJlbnQgZWxlbWVudCBzb21ld2hlcmUgaW5cbiAqIGl0cyBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIGZ1bGxIZXhSRSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XG52YXIgc2hvcnRIZXhSRSA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG52YXIgcmdiUkUgPSAvXnJnYlxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqXFwpJC9pO1xudmFyIHJnYmFSRSA9IC9ecmdiYVxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKFswMV18MD9cXC5cXGQrKSAqXFwpJC9pO1xuLyoqXHJcbiAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gRE9Nb2JqZWN0IC0gTm9kZSB3aG9zZSBjaGlsZCBub2RlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGRlbGV0ZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZURPTURlbGV0ZShET01vYmplY3QpIHtcbiAgaWYgKERPTW9iamVjdCkge1xuICAgIHdoaWxlIChET01vYmplY3QuaGFzQ2hpbGROb2RlcygpID09PSB0cnVlKSB7XG4gICAgICB2YXIgY2hpbGQgPSBET01vYmplY3QuZmlyc3RDaGlsZDtcblxuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZShjaGlsZCk7XG4gICAgICAgIERPTW9iamVjdC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXHJcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBvYmplY3QgKG5vdCBwcmltaXRpdmUgb3IgbnVsbCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICogQHJldHVybnMgVHJ1ZSBpZiBub3QgbnVsbCBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QkNyh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcclxuICogQ29weSBwcm9wZXJ0eSBmcm9tIGIgdG8gYSBpZiBwcm9wZXJ0eSBwcmVzZW50IGluIGEuXHJcbiAqIElmIHByb3BlcnR5IGluIGIgZXhwbGljaXRseSBzZXQgdG8gbnVsbCwgZGVsZXRlIGl0IGlmIGBhbGxvd0RlbGV0aW9uYCBzZXQuXHJcbiAqXHJcbiAqIEludGVybmFsIGhlbHBlciByb3V0aW5lLCBzaG91bGQgbm90IGJlIGV4cG9ydGVkLiBOb3QgYWRkZWQgdG8gYGV4cG9ydHNgIGZvciB0aGF0IHJlYXNvbi5cclxuICpcclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcm9wIC0gTmFtZSBvZiBwcm9wZXJ0eSB0byBjb3B5IGZyb20gYiB0byBhLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0eSBpbiBhIGlmIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICovXG5cblxuZnVuY3Rpb24gY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pIHtcbiAgdmFyIGRvRGVsZXRpb24gPSBmYWxzZTtcblxuICBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgIGRvRGVsZXRpb24gPSBiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChkb0RlbGV0aW9uKSB7XG4gICAgZGVsZXRlIGFbcHJvcF07XG4gIH0gZWxzZSB7XG4gICAgYVtwcm9wXSA9IGJbcHJvcF07IC8vIFJlbWVtYmVyLCB0aGlzIGlzIGEgcmVmZXJlbmNlIGNvcHkhXG4gIH1cbn1cbi8qKlxyXG4gKiBGaWxsIGFuIG9iamVjdCB3aXRoIGEgcG9zc2libHkgcGFydGlhbGx5IGRlZmluZWQgb3RoZXIgb2JqZWN0LlxyXG4gKlxyXG4gKiBPbmx5IGNvcGllcyB2YWx1ZXMgZm9yIHRoZSBwcm9wZXJ0aWVzIGFscmVhZHkgcHJlc2VudCBpbiBhLlxyXG4gKiBUaGF0IG1lYW5zIGFuIG9iamVjdCBpcyBub3QgY3JlYXRlZCBvbiBhIHByb3BlcnR5IGlmIG9ubHkgdGhlIGIgb2JqZWN0IGhhcyBpdC5cclxuICpcclxuICogQHBhcmFtIGEgLSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0J3MgcHJvcGVydGllcyB1cGRhdGVkLlxyXG4gKiBAcGFyYW0gYiAtIFRoZSBvYmplY3Qgd2l0aCBwcm9wZXJ0eSB1cGRhdGVzLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0aWVzIGluIGEgdGhhdCBhcmUgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBmaWxsSWZEZWZpbmVkKGEsIGIpIHtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IGl0ZXJhdGlvbiBvZiBwcm9wZXJ0aWVzIG9mIGFcbiAgLy8gTk9URTogcHJvdG90eXBlIHByb3BlcnRpZXMgaXRlcmF0ZWQgb3ZlciBhcyB3ZWxsXG4gIGZvciAodmFyIHByb3AgaW4gYSkge1xuICAgIGlmIChiW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChiW3Byb3BdID09PSBudWxsIHx8IF90eXBlb2YoYltwcm9wXSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gTm90ZTogdHlwZW9mIG51bGwgPT09ICdvYmplY3QnXG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhUHJvcCA9IGFbcHJvcF07XG4gICAgICAgIHZhciBiUHJvcCA9IGJbcHJvcF07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0JDcoYVByb3ApICYmIGlzT2JqZWN0JDcoYlByb3ApKSB7XG4gICAgICAgICAgZmlsbElmRGVmaW5lZChhUHJvcCwgYlByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogUHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIHJvdXRpbmUgaW1wbGllZCB0aGF0IG11bHRpcGxlIHNvdXJjZSBvYmplY3RzIGNvdWxkXHJcbiAqIGJlIHVzZWQ7IGhvd2V2ZXIsIHRoZSBpbXBsZW1lbnRhdGlvbiB3YXMgKip3cm9uZyoqLiBTaW5jZSBtdWx0aXBsZSAoXFw+MSlcclxuICogc291cmNlcyB3ZXJlbid0IHVzZWQgYW55d2hlcmUgaW4gdGhlIGB2aXMuanNgIGNvZGUsIHRoaXMgaGFzIGJlZW4gcmVtb3ZlZFxyXG4gKiBAcGFyYW0gcHJvcHMgLSBOYW1lcyBvZiBmaXJzdC1sZXZlbCBwcm9wZXJ0aWVzIHRvIGNvcHkgb3Zlci5cclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZWxlY3RpdmVEZWVwRXh0ZW5kKHByb3BzLCBhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKGlzQXJyYXkkMihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtcbiAgfVxuXG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSkge1xuICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogRXh0ZW5kIG9iamVjdCBgYWAgd2l0aCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBgYmAsIGlnbm9yaW5nIHByb3BlcnRpZXMgd2hpY2hcclxuICogYXJlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHRvIGJlIGV4Y2x1ZGVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgcHJvcGVydGllcyBvZiBgYmAgYXJlIGNvbnNpZGVyZWQgZm9yIGNvcHlpbmcuIFByb3BlcnRpZXMgd2hpY2ggYXJlXHJcbiAqIHRoZW1zZWx2ZXMgb2JqZWN0cyBhcmUgYXJlIGFsc28gZXh0ZW5kZWQuIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWRcclxuICogdmFsdWVzIGFyZSBjb3BpZWQuXHJcbiAqIEBwYXJhbSBwcm9wc1RvRXhjbHVkZSAtIE5hbWVzIG9mIHByb3BlcnRpZXMgd2hpY2ggc2hvdWxkICpub3QqIGJlIGNvcGllZC5cclxuICogQHBhcmFtIGEgLSBPYmplY3QgdG8gZXh0ZW5kLlxyXG4gKiBAcGFyYW0gYiAtIE9iamVjdCB0byB0YWtlIHByb3BlcnRpZXMgZnJvbSBmb3IgZXh0ZW5zaW9uLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0aWVzIGluIGEgdGhhdCBhcmUgZXhwbGljaXRseVxyXG4gKiBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKHByb3BzVG9FeGNsdWRlLCBhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgLy8gTk9URTogYXJyYXkgcHJvcGVydGllcyBoYXZlIGFuIGVsc2UtYmVsb3c7IGFwcGFyZW50bHksIHRoZXJlIGlzIGEgcHJvYmxlbSBoZXJlLlxuICBpZiAoaXNBcnJheSQyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSGFuZGxlIGxvY2FsIHByb3BlcnRpZXMgb25seVxuXG5cbiAgICBpZiAoaW5jbHVkZXMocHJvcHNUb0V4Y2x1ZGUpLmNhbGwocHJvcHNUb0V4Y2x1ZGUsIHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEluIGV4Y2x1c2lvbiBsaXN0LCBza2lwXG5cblxuICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihiW3Byb3BdKSkge1xuICAgICAgYVtwcm9wXSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICpcclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcm90b0V4dGVuZCAtIElmIHRydWUsIHRoZSBwcm90b3R5cGUgdmFsdWVzIHdpbGwgYWxzbyBiZSBleHRlbmRlZC5cclxuICogKFRoYXQgaXMgdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGVcclxuICogaW5oZXJpdGVkIG9wdGlvbnMpLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBiZSBkZWxldGVkLlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKGEsIGIpIHtcbiAgdmFyIHByb3RvRXh0ZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkgfHwgcHJvdG9FeHRlbmQgPT09IHRydWUpIHtcbiAgICAgIGlmIChfdHlwZW9mKGJbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIGJbcHJvcF0gIT09IG51bGwgJiYgZ2V0UHJvdG90eXBlT2YkNChiW3Byb3BdKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGRlZXBFeHRlbmQoe30sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIGFbcHJvcF0gIT09IG51bGwgJiYgZ2V0UHJvdG90eXBlT2YkNChhW3Byb3BdKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgcHJvdG9FeHRlbmQpOyAvLyBOT1RFOiBhbGxvd0RlbGV0aW9uIG5vdCBwcm9wYWdhdGVkIVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIoYltwcm9wXSkpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NjtcblxuICAgICAgICBhW3Byb3BdID0gc2xpY2UoX2NvbnRleHQ2ID0gYltwcm9wXSkuY2FsbChfY29udGV4dDYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyIC0gRmlyc3QgcGFydC5cclxuICogQHBhcmFtIG5ld1ZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIGFhZGRlZCBpbnRvIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgQSBuZXcgYXJyYXkgd2l0aCBhbGwgaXRlbXMgZnJvbSBhcnIgYW5kIG5ld1ZhbHVlICh3aGljaCBpcyBsYXN0KS5cclxuICovXG5cblxuZnVuY3Rpb24gY29weUFuZEV4dGVuZEFycmF5KGFyciwgbmV3VmFsdWUpIHtcbiAgdmFyIF9jb250ZXh0NztcblxuICByZXR1cm4gY29uY2F0KF9jb250ZXh0NyA9IFtdKS5jYWxsKF9jb250ZXh0NywgX3RvQ29uc3VtYWJsZUFycmF5KGFyciksIFtuZXdWYWx1ZV0pO1xufVxuLyoqXHJcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyIC0gVGhlIGFycmF5IHRvIGJlIGNvcGllZC5cclxuICogQHJldHVybnMgU2hhbGxvdyBjb3B5IG9mIGFyci5cclxuICovXG5cblxuZnVuY3Rpb24gY29weUFycmF5KGFycikge1xuICByZXR1cm4gc2xpY2UoYXJyKS5jYWxsKGFycik7XG59XG4vKipcclxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW0gLSBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdi5cclxuICogQHJldHVybnMgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IGluIHRoZSBicm93c2VyIHBhZ2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEFic29sdXRlTGVmdChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG59XG4vKipcclxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVRvcChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbn1cbi8qKlxyXG4gKiBGb3IgZWFjaCBtZXRob2QgZm9yIGJvdGggYXJyYXlzIGFuZCBvYmplY3RzLlxyXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQgKCoqTm8sIGl0J3Mgbm90ISoqKS5cclxuICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IC0gQW4gT2JqZWN0IG9yIEFycmF5IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEFycmF5LmZvckVhY2gtbGlrZSBjYWxsYmFjay5cclxuICovXG5cblxuZnVuY3Rpb24gZm9yRWFjaCQxKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgaWYgKGlzQXJyYXkkMihvYmplY3QpKSB7XG4gICAgLy8gYXJyYXlcbiAgICB2YXIgbGVuID0gb2JqZWN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrKG9iamVjdFtpXSwgaSwgb2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gb2JqZWN0XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBBZGQgYW5kIGV2ZW50IGxpc3RlbmVyLiBXb3JrcyBmb3IgYWxsIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGJpbmQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvLlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gU2FtZSBhcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLCDigJQsIOKAlCkuXHJcbiAqIEBwYXJhbSBsaXN0ZW5lciAtIFNhbWUgYXMgRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKOKAlCwgbGlzdGVuZXIsIOKAlCkuXHJcbiAqIEBwYXJhbSB1c2VDYXB0dXJlIC0gU2FtZSBhcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIo4oCULCDigJQsIHVzZUNhcHR1cmUpLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHZhciBfY29udGV4dDg7XG5cbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgaW5jbHVkZXMoX2NvbnRleHQ4ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkuY2FsbChfY29udGV4dDgsIFwiRmlyZWZveFwiKSkge1xuICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBAVE9ETzogSUUgdHlwZXM/IERvZXMgYW55b25lIGNhcmU/XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTsgLy8gSUUgYnJvd3NlcnNcbiAgfVxufVxuLyoqXHJcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8uXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBTYW1lIGFzIEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIOKAlCwg4oCUKS5cclxuICogQHBhcmFtIGxpc3RlbmVyIC0gU2FtZSBhcyBFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIo4oCULCBsaXN0ZW5lciwg4oCUKS5cclxuICogQHBhcmFtIHVzZUNhcHR1cmUgLSBTYW1lIGFzIEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcijigJQsIOKAlCwgdXNlQ2FwdHVyZSkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIF9jb250ZXh0OTtcblxuICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBpbmNsdWRlcyhfY29udGV4dDkgPSBuYXZpZ2F0b3IudXNlckFnZW50KS5jYWxsKF9jb250ZXh0OSwgXCJGaXJlZm94XCIpKSB7XG4gICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7IC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEBUT0RPOiBJRSB0eXBlcz8gRG9lcyBhbnlvbmUgY2FyZT9cbiAgICBlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpOyAvLyBJRSBicm93c2Vyc1xuICB9XG59XG4vKipcclxuICogQ29udmVydCBoZXggY29sb3Igc3RyaW5nIGludG8gUkdCIGNvbG9yIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdifVxyXG4gKiBAcGFyYW0gaGV4IC0gSGV4IGNvbG9yIHN0cmluZyAoMyBvciA2IGRpZ2l0cywgd2l0aCBvciB3aXRob3V0ICMpLlxyXG4gKiBAcmV0dXJucyBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gaGV4VG9SR0IoaGV4KSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgc3dpdGNoIChoZXgubGVuZ3RoKSB7XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICAgIHJlc3VsdCA9IHNob3J0SGV4UkUuZXhlYyhoZXgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgcjogX3BhcnNlSW50KHJlc3VsdFsxXSArIHJlc3VsdFsxXSwgMTYpLFxuICAgICAgICBnOiBfcGFyc2VJbnQocmVzdWx0WzJdICsgcmVzdWx0WzJdLCAxNiksXG4gICAgICAgIGI6IF9wYXJzZUludChyZXN1bHRbM10gKyByZXN1bHRbM10sIDE2KVxuICAgICAgfSA6IG51bGw7XG5cbiAgICBjYXNlIDY6XG4gICAgY2FzZSA3OlxuICAgICAgcmVzdWx0ID0gZnVsbEhleFJFLmV4ZWMoaGV4KTtcbiAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgIHI6IF9wYXJzZUludChyZXN1bHRbMV0sIDE2KSxcbiAgICAgICAgZzogX3BhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICBiOiBfcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBzdHJpbmcgY29sb3IgaW4gaGV4IG9yIFJHQiBmb3JtYXQgYW5kIGFkZHMgdGhlIG9wYWNpdHksIFJHQkEgaXMgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sb3IgLSBUaGUgY29sb3Igc3RyaW5nIChoZXgsIFJHQiwgUkdCQSkuXHJcbiAqIEBwYXJhbSBvcGFjaXR5IC0gVGhlIG5ldyBvcGFjaXR5LlxyXG4gKiBAcmV0dXJucyBSR0JBIHN0cmluZywgZm9yIGV4YW1wbGUgJ3JnYmEoMjU1LCAwLCAxMjcsIDAuMyknLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBvdmVycmlkZU9wYWNpdHkoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKGluY2x1ZGVzKGNvbG9yKS5jYWxsKGNvbG9yLCBcInJnYmFcIikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSBpZiAoaW5jbHVkZXMoY29sb3IpLmNhbGwoY29sb3IsIFwicmdiXCIpKSB7XG4gICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cihpbmRleE9mKGNvbG9yKS5jYWxsKGNvbG9yLCBcIihcIikgKyAxKS5yZXBsYWNlKFwiKVwiLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIFwicmdiYShcIiArIHJnYlswXSArIFwiLFwiICsgcmdiWzFdICsgXCIsXCIgKyByZ2JbMl0gKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JnYiA9IGhleFRvUkdCKGNvbG9yKTtcblxuICAgIGlmIChfcmdiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIF9yZ2IuciArIFwiLFwiICsgX3JnYi5nICsgXCIsXCIgKyBfcmdiLmIgKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBDb252ZXJ0IFJHQiBcXDwwLCAyNTVcXD4gaW50byBoZXggY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVkIC0gUmVkIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBncmVlbiAtIEdyZWVuIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBibHVlIC0gQmx1ZSBjaGFubmVsLlxyXG4gKiBAcmV0dXJucyBIZXggY29sb3Igc3RyaW5nIChmb3IgZXhhbXBsZTogJyMwYWNkYzAnKS5cclxuICovXG5cblxuZnVuY3Rpb24gUkdCVG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICB2YXIgX2NvbnRleHQxMDtcblxuICByZXR1cm4gXCIjXCIgKyBzbGljZShfY29udGV4dDEwID0gKCgxIDw8IDI0KSArIChyZWQgPDwgMTYpICsgKGdyZWVuIDw8IDgpICsgYmx1ZSkudG9TdHJpbmcoMTYpKS5jYWxsKF9jb250ZXh0MTAsIDEpO1xufVxuLyoqXHJcbiAqIFBhcnNlIGEgY29sb3IgcHJvcGVydHkgaW50byBhbiBvYmplY3Qgd2l0aCBib3JkZXIsIGJhY2tncm91bmQsIGFuZCBoaWdobGlnaHQgY29sb3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRDb2xvciAtIFNob3J0aGFuZCBjb2xvciBzdHJpbmcgb3IgaW5wdXQgY29sb3Igb2JqZWN0LlxyXG4gKiBAcGFyYW0gZGVmYXVsdENvbG9yIC0gRnVsbCBjb2xvciBvYmplY3QgdG8gZmlsbCBpbiBtaXNzaW5nIHZhbHVlcyBpbiBpbnB1dENvbG9yLlxyXG4gKiBAcmV0dXJucyBDb2xvciBvYmplY3QuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXRDb2xvciwgZGVmYXVsdENvbG9yKSB7XG4gIGlmIChpc1N0cmluZyhpbnB1dENvbG9yKSkge1xuICAgIHZhciBjb2xvclN0ciA9IGlucHV0Q29sb3I7XG5cbiAgICBpZiAoaXNWYWxpZFJHQihjb2xvclN0cikpIHtcbiAgICAgIHZhciBfY29udGV4dDExO1xuXG4gICAgICB2YXIgcmdiID0gbWFwJDMoX2NvbnRleHQxMSA9IGNvbG9yU3RyLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3JTdHIubGVuZ3RoIC0gNSkuc3BsaXQoXCIsXCIpKS5jYWxsKF9jb250ZXh0MTEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3BhcnNlSW50KHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb2xvclN0ciA9IFJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgIH1cblxuICAgIGlmIChpc1ZhbGlkSGV4KGNvbG9yU3RyKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGhzdiA9IGhleFRvSFNWKGNvbG9yU3RyKTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiBoc3YucyAqIDAuOCxcbiAgICAgICAgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKVxuICAgICAgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksXG4gICAgICAgIHY6IGhzdi52ICogMC44XG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gSFNWVG9IZXgoZGFya2VyQ29sb3JIU1YuaCwgZGFya2VyQ29sb3JIU1YucywgZGFya2VyQ29sb3JIU1Yudik7XG4gICAgICB2YXIgbGlnaHRlckNvbG9ySGV4ID0gSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgYm9yZGVyOiBjb2xvclN0cixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclN0clxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JTdHJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlZmF1bHRDb2xvcikge1xuICAgICAgdmFyIGNvbG9yID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmJhY2tncm91bmQsXG4gICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmJvcmRlcixcbiAgICAgICAgaGlnaGxpZ2h0OiBpc1N0cmluZyhpbnB1dENvbG9yLmhpZ2hsaWdodCkgPyB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodFxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kLFxuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYm9yZGVyIHx8IGRlZmF1bHRDb2xvci5oaWdobGlnaHQuYm9yZGVyXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiBpc1N0cmluZyhpbnB1dENvbG9yLmhvdmVyKSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlclxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlciB8fCBkZWZhdWx0Q29sb3IuaG92ZXIuYm9yZGVyLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaG92ZXIgJiYgaW5wdXRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IGRlZmF1bHRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY29sb3IgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICBoaWdobGlnaHQ6IGlzU3RyaW5nKGlucHV0Q29sb3IuaGlnaGxpZ2h0KSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiBpc1N0cmluZyhpbnB1dENvbG9yLmhvdmVyKSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlclxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX2NvbG9yO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgUkdCIFxcPDAsIDI1NVxcPiBpbnRvIEhTViBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtfVxyXG4gKiBAcGFyYW0gcmVkIC0gUmVkIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBncmVlbiAtIEdyZWVuIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBibHVlIC0gQmx1ZSBjaGFubmVsLlxyXG4gKiBAcmV0dXJucyBIU1YgY29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBSR0JUb0hTVihyZWQsIGdyZWVuLCBibHVlKSB7XG4gIHJlZCA9IHJlZCAvIDI1NTtcbiAgZ3JlZW4gPSBncmVlbiAvIDI1NTtcbiAgYmx1ZSA9IGJsdWUgLyAyNTU7XG4gIHZhciBtaW5SR0IgPSBNYXRoLm1pbihyZWQsIE1hdGgubWluKGdyZWVuLCBibHVlKSk7XG4gIHZhciBtYXhSR0IgPSBNYXRoLm1heChyZWQsIE1hdGgubWF4KGdyZWVuLCBibHVlKSk7IC8vIEJsYWNrLWdyYXktd2hpdGVcblxuICBpZiAobWluUkdCID09PSBtYXhSR0IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogMCxcbiAgICAgIHM6IDAsXG4gICAgICB2OiBtaW5SR0JcbiAgICB9O1xuICB9IC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG5cblxuICB2YXIgZCA9IHJlZCA9PT0gbWluUkdCID8gZ3JlZW4gLSBibHVlIDogYmx1ZSA9PT0gbWluUkdCID8gcmVkIC0gZ3JlZW4gOiBibHVlIC0gcmVkO1xuICB2YXIgaCA9IHJlZCA9PT0gbWluUkdCID8gMyA6IGJsdWUgPT09IG1pblJHQiA/IDEgOiA1O1xuICB2YXIgaHVlID0gNjAgKiAoaCAtIGQgLyAobWF4UkdCIC0gbWluUkdCKSkgLyAzNjA7XG4gIHZhciBzYXR1cmF0aW9uID0gKG1heFJHQiAtIG1pblJHQikgLyBtYXhSR0I7XG4gIHZhciB2YWx1ZSA9IG1heFJHQjtcbiAgcmV0dXJuIHtcbiAgICBoOiBodWUsXG4gICAgczogc2F0dXJhdGlvbixcbiAgICB2OiB2YWx1ZVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgSFNWIFxcPDAsIDFcXD4gaW50byBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWppamFja3Nvbi81MzExMjU2fVxyXG4gKiBAcGFyYW0gaCAtIEh1ZS5cclxuICogQHBhcmFtIHMgLSBTYXR1cmF0aW9uLlxyXG4gKiBAcGFyYW0gdiAtIFZhbHVlLlxyXG4gKiBAcmV0dXJucyBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBIU1ZUb1JHQihoLCBzLCB2KSB7XG4gIHZhciByO1xuICB2YXIgZztcbiAgdmFyIGI7XG4gIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIHZhciBmID0gaCAqIDYgLSBpO1xuICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDpcbiAgICAgIHIgPSB2LCBnID0gdCwgYiA9IHA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHIgPSBxLCBnID0gdiwgYiA9IHA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHIgPSBwLCBnID0gdiwgYiA9IHQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMzpcbiAgICAgIHIgPSBwLCBnID0gcSwgYiA9IHY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgNDpcbiAgICAgIHIgPSB0LCBnID0gcCwgYiA9IHY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgNTpcbiAgICAgIHIgPSB2LCBnID0gcCwgYiA9IHE7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5mbG9vcihyICogMjU1KSxcbiAgICBnOiBNYXRoLmZsb29yKGcgKiAyNTUpLFxuICAgIGI6IE1hdGguZmxvb3IoYiAqIDI1NSlcbiAgfTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IEhTViBcXDwwLCAxXFw+IGludG8gaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGggLSBIdWUuXHJcbiAqIEBwYXJhbSBzIC0gU2F0dXJhdGlvbi5cclxuICogQHBhcmFtIHYgLSBWYWx1ZS5cclxuICogQHJldHVybnMgSGV4IGNvbG9yIHN0cmluZy5cclxuICovXG5cblxuZnVuY3Rpb24gSFNWVG9IZXgoaCwgcywgdikge1xuICB2YXIgcmdiID0gSFNWVG9SR0IoaCwgcywgdik7XG4gIHJldHVybiBSR0JUb0hleChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGhleCBjb2xvciBzdHJpbmcgaW50byBIU1YgXFw8MCwgMVxcPi5cclxuICpcclxuICogQHBhcmFtIGhleCAtIEhleCBjb2xvciBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIEhTViBjb2xvciBvYmplY3QuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGhleFRvSFNWKGhleCkge1xuICB2YXIgcmdiID0gaGV4VG9SR0IoaGV4KTtcblxuICBpZiAoIXJnYikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInXCIuY29uY2F0KGhleCwgXCInIGlzIG5vdCBhIHZhbGlkIGNvbG9yLlwiKSk7XG4gIH1cblxuICByZXR1cm4gUkdCVG9IU1YocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG4vKipcclxuICogVmFsaWRhdGUgaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGhleCAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59XG4vKipcclxuICogVmFsaWRhdGUgUkdCIGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJnYiAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRSR0IocmdiKSB7XG4gIHJldHVybiByZ2JSRS50ZXN0KHJnYik7XG59XG4vKipcclxuICogVmFsaWRhdGUgUkdCQSBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZ2JhIC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZFJHQkEocmdiYSkge1xuICByZXR1cm4gcmdiYVJFLnRlc3QocmdiYSk7XG59XG4vKipcclxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdC5cclxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3QgLSBUaGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gKiBAcmV0dXJucyBUaGUgRWxlbWVudCBpZiB0aGUgcmVmZXJlbmNlT2JqZWN0IGlzIGFuIEVsZW1lbnQsIG9yIGEgbmV3IG9iamVjdCBpbmhlcml0aW5nIGZyb20gdGhlIHJlZmVyZW5jZU9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ID09PSBudWxsIHx8IF90eXBlb2YocmVmZXJlbmNlT2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJlZmVyZW5jZU9iamVjdCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAvLyBBdm9pZCBicmlkZ2luZyBET00gb2JqZWN0c1xuICAgIHJldHVybiByZWZlcmVuY2VPYmplY3Q7XG4gIH1cblxuICB2YXIgb2JqZWN0VG8gPSBjcmVhdGUkNShyZWZlcmVuY2VPYmplY3QpO1xuXG4gIGZvciAodmFyIGkgaW4gcmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWZlcmVuY2VPYmplY3QsIGkpKSB7XG4gICAgICBpZiAoX3R5cGVvZihyZWZlcmVuY2VPYmplY3RbaV0pID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb2JqZWN0VG9baV0gPSBicmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0VG87XG59XG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgb3B0aW9ucyBvZiBzdWJvYmplY3RzIGluIHRoZSBvcHRpb25zIG9iamVjdC5cclxuICpcclxuICogQSByZXF1aXJlbWVudCBvZiB0aGVzZSBzdWJvYmplY3RzIGlzIHRoYXQgdGhleSBoYXZlIGFuICdlbmFibGVkJyBlbGVtZW50XHJcbiAqIHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cclxuICpcclxuICogVGhlIGFkZGVkIHZhbHVlIGhlcmUgb2YgdGhlIG1lcmdlIGlzIHRoYXQgb3B0aW9uICdlbmFibGVkJyBpcyBzZXQgYXMgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXJnZVRhcmdldCAtIEVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxyXG4gKiBAcGFyYW0gb3B0aW9uIC0gT3B0aW9uIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudC5cclxuICogQHBhcmFtIGdsb2JhbE9wdGlvbnMgLSBHbG9iYWwgb3B0aW9ucywgcGFzc2VkIGluIHRvIGRldGVybWluZSB2YWx1ZSBvZiBvcHRpb24gJ2VuYWJsZWQnLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgLy8gTG9jYWwgaGVscGVyc1xuICB2YXIgaXNQcmVzZW50ID0gZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IFwib2JqZWN0XCI7XG4gIH07IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4Ny8xMjIzNTMxXG5cblxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgeCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCB4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIEd1YXJkc1xuXG5cbiAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbWVyZ2VUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICBpZiAoIWlzUHJlc2VudChvcHRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbiBtdXN0IGhhdmUgYSB2YWx1ZVwiKTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZ2xvYmFsT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfSAvL1xuICAvLyBBY3R1YWwgbWVyZ2Ugcm91dGluZSwgc2VwYXJhdGVkIGZyb20gbWFpbiBsb2dpY1xuICAvLyBPbmx5IGEgc2luZ2xlIGxldmVsIG9mIG9wdGlvbnMgaXMgbWVyZ2VkLiBEZWVwZXIgbGV2ZWxzIGFyZSByZWYnZC4gVGhpcyBtYXkgYWN0dWFsbHkgYmUgYW4gaXNzdWUuXG4gIC8vXG5cblxuICB2YXIgZG9NZXJnZSA9IGZ1bmN0aW9uIGRvTWVyZ2UodGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFtvcHRpb25dKSkge1xuICAgICAgdGFyZ2V0W29wdGlvbl0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc3JjID0gb3B0aW9uc1tvcHRpb25dO1xuICAgIHZhciBkc3QgPSB0YXJnZXRbb3B0aW9uXTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3JjKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgcHJvcCkpIHtcbiAgICAgICAgZHN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gTG9jYWwgaW5pdGlhbGl6YXRpb25cblxuXG4gIHZhciBzcmNPcHRpb24gPSBvcHRpb25zW29wdGlvbl07XG4gIHZhciBnbG9iYWxQYXNzZWQgPSBpc09iamVjdChnbG9iYWxPcHRpb25zKSAmJiAhaXNFbXB0eShnbG9iYWxPcHRpb25zKTtcbiAgdmFyIGdsb2JhbE9wdGlvbiA9IGdsb2JhbFBhc3NlZCA/IGdsb2JhbE9wdGlvbnNbb3B0aW9uXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGdsb2JhbEVuYWJsZWQgPSBnbG9iYWxPcHRpb24gPyBnbG9iYWxPcHRpb24uZW5hYmxlZCA6IHVuZGVmaW5lZDsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiByb3V0aW5lXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgaWYgKHNyY09wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG4gIH1cblxuICBpZiAodHlwZW9mIHNyY09wdGlvbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBpZiAoIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0ge307XG4gICAgfVxuXG4gICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gc3JjT3B0aW9uO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzcmNPcHRpb24gPT09IG51bGwgJiYgIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIGV4cGxpY2l0IGNvcHkgZnJvbSBnbG9iYWxzXG4gICAgaWYgKGlzUHJlc2VudChnbG9iYWxPcHRpb24pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gY3JlYXRlJDUoZ2xvYmFsT3B0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc09iamVjdChzcmNPcHRpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vXG4gIC8vIEVuc3VyZSB0aGF0ICdlbmFibGVkJyBpcyBwcm9wZXJseSBzZXQuIEl0IGlzIHJlcXVpcmVkIGludGVybmFsbHlcbiAgLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBmcm9tIG9wdGlvbnMgd2lsbCBhbHdheXMgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAvL1xuXG5cbiAgdmFyIGVuYWJsZWQgPSB0cnVlOyAvLyBkZWZhdWx0IHZhbHVlXG5cbiAgaWYgKHNyY09wdGlvbi5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmFibGVkID0gc3JjT3B0aW9uLmVuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGFrZSBmcm9tIGdsb2JhbHMsIGlmIHByZXNlbnRcbiAgICBpZiAoZ2xvYmFsRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmFibGVkID0gZ2xvYmFsT3B0aW9uLmVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgZG9NZXJnZShtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKTtcbiAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gZW5hYmxlZDtcbn1cbi8qXHJcbiAqIEVhc2luZyBGdW5jdGlvbnMuXHJcbiAqIE9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdLlxyXG4gKlxyXG4gKiBJbnNwaXJhdGlvbjogZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cclxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcclxuICovXG5cblxudmFyIGVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgLyoqXHJcbiAgICogUHJvdmlkZXMgbm8gZWFzaW5nIGFuZCBubyBhY2NlbGVyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBsaW5lYXI6IGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uIGVhc2VJbkN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5RdWFydDogZnVuY3Rpb24gZWFzZUluUXVhcnQodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCkge1xuICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWludCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogLS10ICogdCAqIHQgKiB0ICogdDtcbiAgfVxufTtcbi8vIEl0IHdvcmtzIG9ubHkgZm9yIHNpbmdsZSBwcm9wZXJ0eSBvYmplY3RzLFxuLy8gb3RoZXJ3aXNlIGl0IGNvbWJpbmVzIGFsbCBvZiB0aGUgdHlwZXMgaW4gYSB1bmlvbi5cbi8vIGV4cG9ydCBmdW5jdGlvbiB0b3BNb3N0PEsxIGV4dGVuZHMgc3RyaW5nLCBWMT4gKFxuLy8gICBwaWxlOiBSZWNvcmQ8SzEsIHVuZGVmaW5lZCB8IFYxPltdLFxuLy8gICBhY2Nlc3NvcnM6IEsxIHwgW0sxXVxuLy8gKTogdW5kZWZpbmVkIHwgVjFcbi8vIGV4cG9ydCBmdW5jdGlvbiB0b3BNb3N0PEsxIGV4dGVuZHMgc3RyaW5nLCBLMiBleHRlbmRzIHN0cmluZywgVjEsIFYyPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjEgfCBSZWNvcmQ8SzIsIHVuZGVmaW5lZCB8IFYyPj5bXSxcbi8vICAgYWNjZXNzb3JzOiBbSzEsIEsyXVxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMlxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIEsyIGV4dGVuZHMgc3RyaW5nLCBLMyBleHRlbmRzIHN0cmluZywgVjEsIFYyLCBWMz4gKFxuLy8gICBwaWxlOiBSZWNvcmQ8SzEsIHVuZGVmaW5lZCB8IFYxIHwgUmVjb3JkPEsyLCB1bmRlZmluZWQgfCBWMiB8IFJlY29yZDxLMywgdW5kZWZpbmVkIHwgVjM+Pj5bXSxcbi8vICAgYWNjZXNzb3JzOiBbSzEsIEsyLCBLM11cbi8vICk6IHVuZGVmaW5lZCB8IFYxIHwgVjIgfCBWM1xuXG4vKipcclxuICogR2V0IHRoZSB0b3AgbW9zdCBwcm9wZXJ0eSB2YWx1ZSBmcm9tIGEgcGlsZSBvZiBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGlsZSAtIEFycmF5IG9mIG9iamVjdHMsIG5vIHJlcXVpcmVkIGZvcm1hdC5cclxuICogQHBhcmFtIGFjY2Vzc29ycyAtIEFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBGb3IgZXhhbXBsZSBgb2JqZWN0Wydmb28nXVsnYmFyJ11gIOKGkiBgWydmb28nLCAnYmFyJ11gLlxyXG4gKiBAcmV0dXJucyBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aCBnaXZlbiBhY2Nlc3NvcnMgcGF0aCBmcm9tIHRoZSBmaXJzdCBwaWxlIGl0ZW0gd2hlcmUgaXQncyBub3QgdW5kZWZpbmVkLlxyXG4gKi9cblxuXG5mdW5jdGlvbiB0b3BNb3N0KHBpbGUsIGFjY2Vzc29ycykge1xuICB2YXIgY2FuZGlkYXRlO1xuXG4gIGlmICghaXNBcnJheSQyKGFjY2Vzc29ycykpIHtcbiAgICBhY2Nlc3NvcnMgPSBbYWNjZXNzb3JzXTtcbiAgfVxuXG4gIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChwaWxlKSxcbiAgICAgIF9zdGVwMztcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbWVtYmVyID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IG1lbWJlclthY2Nlc3NvcnNbMF1dO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYWNjZXNzb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlW2FjY2Vzc29yc1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMy5mKCk7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlO1xufVxuXG52YXIgaHRtbENvbG9ycyA9IHtcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICBuYXZ5OiBcIiMwMDAwODBcIixcbiAgZGFya2JsdWU6IFwiIzAwMDA4QlwiLFxuICBtZWRpdW1ibHVlOiBcIiMwMDAwQ0RcIixcbiAgYmx1ZTogXCIjMDAwMEZGXCIsXG4gIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsXG4gIGdyZWVuOiBcIiMwMDgwMDBcIixcbiAgdGVhbDogXCIjMDA4MDgwXCIsXG4gIGRhcmtjeWFuOiBcIiMwMDhCOEJcIixcbiAgZGVlcHNreWJsdWU6IFwiIzAwQkZGRlwiLFxuICBkYXJrdHVycXVvaXNlOiBcIiMwMENFRDFcIixcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiIzAwRkE5QVwiLFxuICBsaW1lOiBcIiMwMEZGMDBcIixcbiAgc3ByaW5nZ3JlZW46IFwiIzAwRkY3RlwiLFxuICBhcXVhOiBcIiMwMEZGRkZcIixcbiAgY3lhbjogXCIjMDBGRkZGXCIsXG4gIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsXG4gIGRvZGdlcmJsdWU6IFwiIzFFOTBGRlwiLFxuICBsaWdodHNlYWdyZWVuOiBcIiMyMEIyQUFcIixcbiAgZm9yZXN0Z3JlZW46IFwiIzIyOEIyMlwiLFxuICBzZWFncmVlbjogXCIjMkU4QjU3XCIsXG4gIGRhcmtzbGF0ZWdyYXk6IFwiIzJGNEY0RlwiLFxuICBsaW1lZ3JlZW46IFwiIzMyQ0QzMlwiLFxuICBtZWRpdW1zZWFncmVlbjogXCIjM0NCMzcxXCIsXG4gIHR1cnF1b2lzZTogXCIjNDBFMEQwXCIsXG4gIHJveWFsYmx1ZTogXCIjNDE2OUUxXCIsXG4gIHN0ZWVsYmx1ZTogXCIjNDY4MkI0XCIsXG4gIGRhcmtzbGF0ZWJsdWU6IFwiIzQ4M0Q4QlwiLFxuICBtZWRpdW10dXJxdW9pc2U6IFwiIzQ4RDFDQ1wiLFxuICBpbmRpZ286IFwiIzRCMDA4MlwiLFxuICBkYXJrb2xpdmVncmVlbjogXCIjNTU2QjJGXCIsXG4gIGNhZGV0Ymx1ZTogXCIjNUY5RUEwXCIsXG4gIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1RURcIixcbiAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZDREFBXCIsXG4gIGRpbWdyYXk6IFwiIzY5Njk2OVwiLFxuICBzbGF0ZWJsdWU6IFwiIzZBNUFDRFwiLFxuICBvbGl2ZWRyYWI6IFwiIzZCOEUyM1wiLFxuICBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLFxuICBsaWdodHNsYXRlZ3JheTogXCIjNzc4ODk5XCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCIjN0I2OEVFXCIsXG4gIGxhd25ncmVlbjogXCIjN0NGQzAwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiIzdGRkYwMFwiLFxuICBhcXVhbWFyaW5lOiBcIiM3RkZGRDRcIixcbiAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICBncmF5OiBcIiM4MDgwODBcIixcbiAgc2t5Ymx1ZTogXCIjODdDRUVCXCIsXG4gIGxpZ2h0c2t5Ymx1ZTogXCIjODdDRUZBXCIsXG4gIGJsdWV2aW9sZXQ6IFwiIzhBMkJFMlwiLFxuICBkYXJrcmVkOiBcIiM4QjAwMDBcIixcbiAgZGFya21hZ2VudGE6IFwiIzhCMDA4QlwiLFxuICBzYWRkbGVicm93bjogXCIjOEI0NTEzXCIsXG4gIGRhcmtzZWFncmVlbjogXCIjOEZCQzhGXCIsXG4gIGxpZ2h0Z3JlZW46IFwiIzkwRUU5MFwiLFxuICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBEOFwiLFxuICBkYXJrdmlvbGV0OiBcIiM5NDAwRDNcIixcbiAgcGFsZWdyZWVuOiBcIiM5OEZCOThcIixcbiAgZGFya29yY2hpZDogXCIjOTkzMkNDXCIsXG4gIHllbGxvd2dyZWVuOiBcIiM5QUNEMzJcIixcbiAgc2llbm5hOiBcIiNBMDUyMkRcIixcbiAgYnJvd246IFwiI0E1MkEyQVwiLFxuICBkYXJrZ3JheTogXCIjQTlBOUE5XCIsXG4gIGxpZ2h0Ymx1ZTogXCIjQUREOEU2XCIsXG4gIGdyZWVueWVsbG93OiBcIiNBREZGMkZcIixcbiAgcGFsZXR1cnF1b2lzZTogXCIjQUZFRUVFXCIsXG4gIGxpZ2h0c3RlZWxibHVlOiBcIiNCMEM0REVcIixcbiAgcG93ZGVyYmx1ZTogXCIjQjBFMEU2XCIsXG4gIGZpcmVicmljazogXCIjQjIyMjIyXCIsXG4gIGRhcmtnb2xkZW5yb2Q6IFwiI0I4ODYwQlwiLFxuICBtZWRpdW1vcmNoaWQ6IFwiI0JBNTVEM1wiLFxuICByb3N5YnJvd246IFwiI0JDOEY4RlwiLFxuICBkYXJra2hha2k6IFwiI0JEQjc2QlwiLFxuICBzaWx2ZXI6IFwiI0MwQzBDMFwiLFxuICBtZWRpdW12aW9sZXRyZWQ6IFwiI0M3MTU4NVwiLFxuICBpbmRpYW5yZWQ6IFwiI0NENUM1Q1wiLFxuICBwZXJ1OiBcIiNDRDg1M0ZcIixcbiAgY2hvY29sYXRlOiBcIiNEMjY5MUVcIixcbiAgdGFuOiBcIiNEMkI0OENcIixcbiAgbGlnaHRncmV5OiBcIiNEM0QzRDNcIixcbiAgcGFsZXZpb2xldHJlZDogXCIjRDg3MDkzXCIsXG4gIHRoaXN0bGU6IFwiI0Q4QkZEOFwiLFxuICBvcmNoaWQ6IFwiI0RBNzBENlwiLFxuICBnb2xkZW5yb2Q6IFwiI0RBQTUyMFwiLFxuICBjcmltc29uOiBcIiNEQzE0M0NcIixcbiAgZ2FpbnNib3JvOiBcIiNEQ0RDRENcIixcbiAgcGx1bTogXCIjRERBMEREXCIsXG4gIGJ1cmx5d29vZDogXCIjREVCODg3XCIsXG4gIGxpZ2h0Y3lhbjogXCIjRTBGRkZGXCIsXG4gIGxhdmVuZGVyOiBcIiNFNkU2RkFcIixcbiAgZGFya3NhbG1vbjogXCIjRTk5NjdBXCIsXG4gIHZpb2xldDogXCIjRUU4MkVFXCIsXG4gIHBhbGVnb2xkZW5yb2Q6IFwiI0VFRThBQVwiLFxuICBsaWdodGNvcmFsOiBcIiNGMDgwODBcIixcbiAga2hha2k6IFwiI0YwRTY4Q1wiLFxuICBhbGljZWJsdWU6IFwiI0YwRjhGRlwiLFxuICBob25leWRldzogXCIjRjBGRkYwXCIsXG4gIGF6dXJlOiBcIiNGMEZGRkZcIixcbiAgc2FuZHlicm93bjogXCIjRjRBNDYwXCIsXG4gIHdoZWF0OiBcIiNGNURFQjNcIixcbiAgYmVpZ2U6IFwiI0Y1RjVEQ1wiLFxuICB3aGl0ZXNtb2tlOiBcIiNGNUY1RjVcIixcbiAgbWludGNyZWFtOiBcIiNGNUZGRkFcIixcbiAgZ2hvc3R3aGl0ZTogXCIjRjhGOEZGXCIsXG4gIHNhbG1vbjogXCIjRkE4MDcyXCIsXG4gIGFudGlxdWV3aGl0ZTogXCIjRkFFQkQ3XCIsXG4gIGxpbmVuOiBcIiNGQUYwRTZcIixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiI0ZBRkFEMlwiLFxuICBvbGRsYWNlOiBcIiNGREY1RTZcIixcbiAgcmVkOiBcIiNGRjAwMDBcIixcbiAgZnVjaHNpYTogXCIjRkYwMEZGXCIsXG4gIG1hZ2VudGE6IFwiI0ZGMDBGRlwiLFxuICBkZWVwcGluazogXCIjRkYxNDkzXCIsXG4gIG9yYW5nZXJlZDogXCIjRkY0NTAwXCIsXG4gIHRvbWF0bzogXCIjRkY2MzQ3XCIsXG4gIGhvdHBpbms6IFwiI0ZGNjlCNFwiLFxuICBjb3JhbDogXCIjRkY3RjUwXCIsXG4gIGRhcmtvcmFuZ2U6IFwiI0ZGOEMwMFwiLFxuICBsaWdodHNhbG1vbjogXCIjRkZBMDdBXCIsXG4gIG9yYW5nZTogXCIjRkZBNTAwXCIsXG4gIGxpZ2h0cGluazogXCIjRkZCNkMxXCIsXG4gIHBpbms6IFwiI0ZGQzBDQlwiLFxuICBnb2xkOiBcIiNGRkQ3MDBcIixcbiAgcGVhY2hwdWZmOiBcIiNGRkRBQjlcIixcbiAgbmF2YWpvd2hpdGU6IFwiI0ZGREVBRFwiLFxuICBtb2NjYXNpbjogXCIjRkZFNEI1XCIsXG4gIGJpc3F1ZTogXCIjRkZFNEM0XCIsXG4gIG1pc3R5cm9zZTogXCIjRkZFNEUxXCIsXG4gIGJsYW5jaGVkYWxtb25kOiBcIiNGRkVCQ0RcIixcbiAgcGFwYXlhd2hpcDogXCIjRkZFRkQ1XCIsXG4gIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLFxuICBzZWFzaGVsbDogXCIjRkZGNUVFXCIsXG4gIGNvcm5zaWxrOiBcIiNGRkY4RENcIixcbiAgbGVtb25jaGlmZm9uOiBcIiNGRkZBQ0RcIixcbiAgZmxvcmFsd2hpdGU6IFwiI0ZGRkFGMFwiLFxuICBzbm93OiBcIiNGRkZBRkFcIixcbiAgeWVsbG93OiBcIiNGRkZGMDBcIixcbiAgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLFxuICBpdm9yeTogXCIjRkZGRkYwXCIsXG4gIHdoaXRlOiBcIiNGRkZGRkZcIlxufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IFtwaXhlbFJhdGlvPTFdXG4gKi9cblxudmFyIENvbG9yUGlja2VyJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXhlbFJhdGlvPTFdXG4gICAqL1xuICBmdW5jdGlvbiBDb2xvclBpY2tlciQxKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yUGlja2VyJDEpO1xuXG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7XG4gICAgICB4OiAyODkgLyAyLFxuICAgICAgeTogMjg5IC8gMlxuICAgIH07XG4gICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICB0aGlzLmNvbG9yID0ge1xuICAgICAgcjogMjU1LFxuICAgICAgZzogMjU1LFxuICAgICAgYjogMjU1LFxuICAgICAgYTogMS4wXG4gICAgfTtcbiAgICB0aGlzLmh1ZUNpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxDb2xvciA9IHtcbiAgICAgIHI6IDI1NSxcbiAgICAgIGc6IDI1NSxcbiAgICAgIGI6IDI1NSxcbiAgICAgIGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlOyAvLyBib3VuZCBieVxuXG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307IC8vIGNyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG5cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiB0aGlzIGluc2VydHMgdGhlIGNvbG9yUGlja2VyIGludG8gYSBkaXYgZnJvbSB0aGUgRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yUGlja2VyJDEsIFt7XG4gICAga2V5OiBcImluc2VydFRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcblxuICAgICAgdGhpcy5fYmluZEhhbW1lcigpO1xuXG4gICAgICB0aGlzLl9zZXRTaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRVcGRhdGVDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcGRhdGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldENsb3NlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2xvc2VDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjbG9zaW5nIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNDb2xvclN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDb2xvclN0cmluZyhjb2xvcikge1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29sb3Igb2YgdGhlIGNvbG9yUGlja2VyXG4gICAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAgICogJ3JlZCcgICAgICAgICAgICAgICAgICAgLS0+IEhUTUwgY29sb3Igc3RyaW5nXG4gICAgICogJyNmZmZmZmYnICAgICAgICAgICAgICAgLS0+IGhleCBzdHJpbmdcbiAgICAgKiAncmdiKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgICAqICdyZ2JhKDI1NSwyNTUsMjU1LDEuMCknIC0tPiByZ2JhIHN0cmluZ1xuICAgICAqIHtyOjI1NSxnOjI1NSxiOjI1NX0gICAgIC0tPiByZ2Igb2JqZWN0XG4gICAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgb2JqZWN0fSBjb2xvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEluaXRpYWw9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbG9yKGNvbG9yKSB7XG4gICAgICB2YXIgc2V0SW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgaWYgKGNvbG9yID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZ2JhOyAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG5cbiAgICAgIHZhciBodG1sQ29sb3IgPSB0aGlzLl9pc0NvbG9yU3RyaW5nKGNvbG9yKTtcblxuICAgICAgaWYgKGh0bWxDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgICAgfSAvLyBjaGVjayBmb3JtYXRcblxuXG4gICAgICBpZiAoaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogcmdiYUFycmF5WzBdLFxuICAgICAgICAgICAgZzogcmdiYUFycmF5WzFdLFxuICAgICAgICAgICAgYjogcmdiYUFycmF5WzJdLFxuICAgICAgICAgICAgYTogMS4wXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkUkdCQShjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3JnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig1KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNikuc3BsaXQoXCIsXCIpO1xuXG4gICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IF9yZ2JhQXJyYXlbMF0sXG4gICAgICAgICAgICBnOiBfcmdiYUFycmF5WzFdLFxuICAgICAgICAgICAgYjogX3JnYmFBcnJheVsyXSxcbiAgICAgICAgICAgIGE6IF9yZ2JhQXJyYXlbM11cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYk9iaiA9IGhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogcmdiT2JqLnIsXG4gICAgICAgICAgICBnOiByZ2JPYmouZyxcbiAgICAgICAgICAgIGI6IHJnYk9iai5iLFxuICAgICAgICAgICAgYTogMS4wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNvbG9yLnIgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5nICE9PSB1bmRlZmluZWQgJiYgY29sb3IuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogXCIxLjBcIjtcbiAgICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGFscGhhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBzZXQgY29sb3JcblxuXG4gICAgICBpZiAocmdiYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogXCIgKyBzdHJpbmdpZnkkMShjb2xvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgc2hvd3MgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKiBUaGUgaHVlIGNpcmNsZSBpcyBjb25zdHJ1Y3RlZCBvbmNlIGFuZCBzdG9yZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICAgIHRoaXMuX2dlbmVyYXRlSHVlQ2lyY2xlKCk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RvcmVQcmV2aW91cz10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RvcmVQcmV2aW91cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgLy8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBuZXh0IHRpbWU7XG4gICAgICBpZiAoc3RvcmVQcmV2aW91cyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSBhc3NpZ24kMih7fSwgdGhpcy5jb2xvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFwcGxpZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmluaXRpYWxDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyAvLyBjYWxsIHRoZSBjbG9zaW5nIGNhbGxiYWNrLCByZXN0b3JpbmcgdGhlIG9uY2xpY2sgbWV0aG9kLlxuICAgICAgLy8gdGhpcyBpcyBpbiBhIHNldFRpbWVvdXQgYmVjYXVzZSBpdCB3aWxsIHRyaWdnZXIgdGhlIHNob3cgYWdhaW4gYmVmb3JlIHRoZSBjbGljayBpcyBkb25lLlxuXG4gICAgICBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLmNsb3NlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMi5jbG9zZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgICBfdGhpczIuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJvdW5kIHRvIHRoZSBzYXZlIGJ1dHRvbi4gU2F2ZXMgYW5kIGhpZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlKCkge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9oaWRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvdW5kIHRvIGFwcGx5IGJ1dHRvbi4gU2F2ZXMgYnV0IGRvZXMgbm90IGNsb3NlLiBJcyB1bmRvbmUgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseSgpIHtcbiAgICAgIHRoaXMuYXBwbGllZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGxvYWQgdGhlIGNvbG9yIGZyb20gdGhlIHByZXZpb3VzIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRMYXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkTGFzdCgpIHtcbiAgICAgIGlmICh0aGlzLnByZXZpb3VzQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldENvbG9yKHRoaXMucHJldmlvdXNDb2xvciwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgY29sb3IsIHBsYWNlIHRoZSBwaWNrZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZ2JhXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0SW5pdGlhbD10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENvbG9yKHJnYmEpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBjb2xvclxuICAgICAgaWYgKHNldEluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSBhc3NpZ24kMih7fSwgcmdiYSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuciAqIGhzdi5zO1xuICAgICAgdmFyIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG4gICAgICB2YXIgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0geCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArIFwicHhcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSB5IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArIFwicHhcIjtcblxuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHJnYmEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byBvcGFjaXR5IGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0T3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0T3BhY2l0eSh2YWx1ZSkge1xuICAgICAgdGhpcy5jb2xvci5hID0gdmFsdWUgLyAxMDA7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gYnJpZ2h0bmVzcyBjb250cm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEJyaWdodG5lc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyaWdodG5lc3ModmFsdWUpIHtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi52ID0gdmFsdWUgLyAxMDA7XG4gICAgICB2YXIgcmdiYSA9IEhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgcmdiYVtcImFcIl0gPSB0aGlzLmNvbG9yLmE7XG4gICAgICB0aGlzLmNvbG9yID0gcmdiYTtcblxuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgY29sb3IgcGlja2VyLiBBIGJsYWNrIGNpcmNsZSBvdmVybGF5cyB0aGUgaHVlIGNpcmNsZSB0byBtaW1pYyB0aGUgYnJpZ2h0bmVzcyBkZWNyZWFzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJnYmFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVBpY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGlja2VyKCkge1xuICAgICAgdmFyIHJnYmEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuY29sb3I7XG4gICAgICB2YXIgaHN2ID0gUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG4gICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEodGhpcy5odWVDaXJjbGUsIDAsIDApO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCxcIiArICgxIC0gaHN2LnYpICsgXCIpXCI7XG4gICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuXG4gICAgICBmaWxsKGN0eCkuY2FsbChjdHgpO1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9IDEwMCAqIGhzdi52O1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSAxMDAgKiByZ2JhLmE7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgXCIsXCIgKyB0aGlzLmluaXRpYWxDb2xvci5nICsgXCIsXCIgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgXCIsXCIgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgXCIpXCI7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYShcIiArIHRoaXMuY29sb3IuciArIFwiLFwiICsgdGhpcy5jb2xvci5nICsgXCIsXCIgKyB0aGlzLmNvbG9yLmIgKyBcIixcIiArIHRoaXMuY29sb3IuYSArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IGNyZWF0ZSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2l6ZSgpIHtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLndpZHRoID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhbGwgZG9tIGVsZW1lbnRzXG4gICAgICogVE9ETzogY2xlYW51cCwgbG90cyBvZiBzaW1pbGFyIGRvbSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIHZhciBfY29udGV4dDE2LCBfY29udGV4dDE3LCBfY29udGV4dDE4LCBfY29udGV4dDE5O1xuXG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gXCJ2aXMtY29sb3ItcGlja2VyXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gXCJ2aXMtc2VsZWN0b3JcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlclNlbGVjdG9yKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcblxuICAgICAgaWYgKCF0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgdmFyIG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHhcIjtcbiAgICAgICAgbm9DYW52YXMuaW5uZXJUZXh0ID0gXCJFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXNcIjtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5jbGFzc05hbWUgPSBcInZpcy1jb2xvclwiO1xuICAgICAgdGhpcy5vcGFjaXR5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWUgPSBcInZpcy1vcGFjaXR5XCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmNsYXNzTmFtZSA9IFwidmlzLWJyaWdodG5lc3NcIjtcbiAgICAgIHRoaXMuYXJyb3dEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5hcnJvd0Rpdi5jbGFzc05hbWUgPSBcInZpcy1hcnJvd1wiO1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG5cbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gXCIwXCI7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1heCA9IFwiMTAwXCI7XG4gICAgICB9IGNhdGNoIChlcnIpIHsvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICAgIH1cblxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSBcIjEwMFwiO1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtcmFuZ2VcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gXCJyYW5nZVwiOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuXG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1pbiA9IFwiMFwiO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5tYXggPSBcIjEwMFwiO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7Ly8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gXCIxMDBcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9IFwidmlzLXJhbmdlXCI7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzc1wiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuaW5uZXJUZXh0ID0gXCJicmlnaHRuZXNzOlwiO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLW9wYWNpdHlcIjtcbiAgICAgIHRoaXMub3BhY2l0eUxhYmVsLmlubmVyVGV4dCA9IFwib3BhY2l0eTpcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1uZXctY29sb3JcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuaW5uZXJUZXh0ID0gXCJuZXdcIjtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLWluaXRpYWwtY29sb3JcIjtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmlubmVyVGV4dCA9IFwiaW5pdGlhbFwiO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1jYW5jZWxcIjtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmlubmVyVGV4dCA9IFwiY2FuY2VsXCI7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gYmluZCQ2KF9jb250ZXh0MTYgPSB0aGlzLl9oaWRlKS5jYWxsKF9jb250ZXh0MTYsIHRoaXMsIGZhbHNlKTtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWFwcGx5XCI7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVyVGV4dCA9IFwiYXBwbHlcIjtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24ub25jbGljayA9IGJpbmQkNihfY29udGV4dDE3ID0gdGhpcy5fYXBwbHkpLmNhbGwoX2NvbnRleHQxNywgdGhpcyk7XG4gICAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtc2F2ZVwiO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLmlubmVyVGV4dCA9IFwic2F2ZVwiO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSBiaW5kJDYoX2NvbnRleHQxOCA9IHRoaXMuX3NhdmUpLmNhbGwoX2NvbnRleHQxOCwgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtbG9hZFwiO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmlubmVyVGV4dCA9IFwibG9hZCBsYXN0XCI7XG4gICAgICB0aGlzLmxvYWRCdXR0b24ub25jbGljayA9IGJpbmQkNihfY29udGV4dDE5ID0gdGhpcy5fbG9hZExhc3QpLmNhbGwoX2NvbnRleHQxOSwgdGhpcyk7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFycm93RGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzTGFiZWwpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlMYWJlbCk7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eURpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmV3Q29sb3JEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmluaXRpYWxDb2xvckRpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2FuY2VsQnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc2F2ZUJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubG9hZEJ1dHRvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJpbmQgaGFtbWVyIHRvIHRoZSBjb2xvciBwaWNrZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmluZEhhbW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lciQxKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuICAgICAgdGhpcy5oYW1tZXIuZ2V0KFwicGluY2hcIikuc2V0KHtcbiAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbnN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFubW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBodWUgY2lyY2xlLiBUaGlzIGlzIHJlbGF0aXZlbHkgaGVhdnkgKDIwMG1zKSBhbmQgaXMgZG9uZSBvbmx5IG9uY2Ugb24gdGhlIGZpcnN0IHRpbWUgaXQgaXMgc2hvd24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlSHVlQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICAgIGlmICh0aGlzLmdlbmVyYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTsgLy8gZHJhdyBodWUgY2lyY2xlXG5cbiAgICAgICAgdmFyIHgsIHksIGh1ZSwgc2F0O1xuICAgICAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0ge1xuICAgICAgICAgIHg6IHcgKiAwLjUsXG4gICAgICAgICAgeTogaCAqIDAuNVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJIC8gMzYwO1xuICAgICAgICB2YXIgaGZhYyA9IDEgLyAzNjA7XG4gICAgICAgIHZhciBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgICAgdmFyIHJnYjtcblxuICAgICAgICBmb3IgKGh1ZSA9IDA7IGh1ZSA8IDM2MDsgaHVlKyspIHtcbiAgICAgICAgICBmb3IgKHNhdCA9IDA7IHNhdCA8IHRoaXMucjsgc2F0KyspIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyBzYXQgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHNhdCAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICByZ2IgPSBIU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYihcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIilcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5IC0gMC41LCAyLCAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMSlcIjtcbiAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmh1ZUNpcmNsZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgc2VsZWN0b3IuIFRoaXMgaXMgY2FsbGVkIGJ5IGhhbW1lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVTZWxlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbGVmdCA9IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG4gICAgICB2YXIgY2VudGVyWSA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgdmFyIGNlbnRlclggPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudFdpZHRoO1xuICAgICAgdmFyIHggPSBsZWZ0IC0gY2VudGVyWDtcbiAgICAgIHZhciB5ID0gdG9wIC0gY2VudGVyWTtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeCwgeSk7XG4gICAgICB2YXIgcmFkaXVzID0gMC45OCAqIE1hdGgubWluKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgY2VudGVyWCk7XG4gICAgICB2YXIgbmV3VG9wID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzICsgY2VudGVyWTtcbiAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzICsgY2VudGVyWDtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSBuZXdUb3AgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSBuZXdMZWZ0IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgXCJweFwiOyAvLyBzZXQgY29sb3JcblxuICAgICAgdmFyIGggPSBhbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgICBoID0gaCA8IDAgPyBoICsgMSA6IGg7XG4gICAgICB2YXIgcyA9IHJhZGl1cyAvIHRoaXMucjtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi5oID0gaDtcbiAgICAgIGhzdi5zID0gcztcbiAgICAgIHZhciByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICByZ2JhW1wiYVwiXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhOyAvLyB1cGRhdGUgcHJldmlld3NcblxuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5pbml0aWFsQ29sb3IuciArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuZyArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYiArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYSArIFwiKVwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmNvbG9yLnIgKyBcIixcIiArIHRoaXMuY29sb3IuZyArIFwiLFwiICsgdGhpcy5jb2xvci5iICsgXCIsXCIgKyB0aGlzLmNvbG9yLmEgKyBcIilcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3JQaWNrZXIkMTtcbn0oKTtcbi8qKlxuICogV3JhcCBnaXZlbiB0ZXh0IChsYXN0IGFyZ3VtZW50KSBpbiBIVE1MIGVsZW1lbnRzIChhbGwgcHJlY2VkaW5nIGFyZ3VtZW50cykuXG4gKlxuICogQHBhcmFtIHsuLi5hbnl9IHJlc3QgLSBMaXN0IG9mIHRhZyBuYW1lcyBmb2xsb3dlZCBieSBpbm5lciB0ZXh0LlxuICogQHJldHVybnMgQW4gZWxlbWVudCBvciBhIHRleHQgbm9kZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyYXBJblRhZygpIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgcmVzdFtfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgaWYgKHJlc3QubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy5cIik7XG4gIH0gZWxzZSBpZiAocmVzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVzdFswXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHJlc3RbMF0pO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcEluVGFnLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KHNsaWNlKHJlc3QpLmNhbGwocmVzdCwgMSkpKSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cbi8qKlxuICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gKi9cblxuXG52YXIgQ29uZmlndXJhdG9yJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE1vZHVsZSAgICAgICAgfCB0aGUgbG9jYXRpb24gd2hlcmUgcGFyZW50TW9kdWxlLnNldE9wdGlvbnMoKSBjYW4gYmUgY2FsbGVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0Q29udGFpbmVyICAgIHwgdGhlIGRlZmF1bHQgY29udGFpbmVyIG9mIHRoZSBtb2R1bGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ3VyZU9wdGlvbnMgICAgfCB0aGUgZnVsbHkgY29uZmlndXJlZCBhbmQgcHJlZGVmaW5lZCBvcHRpb25zIHNldCBmb3VuZCBpbiBhbGxPcHRpb25zLmpzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvICAgICAgICAgIHwgY2FudmFzIHBpeGVsIHJhdGlvXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhpZGVPcHRpb24gICAgICAgIHwgY3VzdG9tIGxvZ2ljIHRvIGR5bmFtaWNhbGx5IGhpZGUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ29uZmlndXJhdG9yJDEocGFyZW50TW9kdWxlLCBkZWZhdWx0Q29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgdmFyIGhpZGVPcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRvciQxKTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50TW9kdWxlO1xuICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXI7XG4gICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5oaWRlT3B0aW9uID0gaGlkZU9wdGlvbjtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgc2hvd0J1dHRvbjogdHJ1ZVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVPcHRpb25zID0gY29uZmlndXJlT3B0aW9ucztcbiAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5wb3B1cERpdiA9IHt9O1xuICAgIHRoaXMucG9wdXBMaW1pdCA9IDU7XG4gICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcbiAgICB0aGlzLmNvbG9yUGlja2VyID0gbmV3IENvbG9yUGlja2VyJDEocGl4ZWxSYXRpbyk7XG4gICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiByZWZyZXNoIGFsbCBvcHRpb25zLlxuICAgKiBCZWNhdXNlIGFsbCBtb2R1bGVzIHBhcnNlIHRoZWlyIG9wdGlvbnMgYnkgdGhlbXNlbHZlcywgd2UganVzdCB1c2UgdGhlaXIgb3B0aW9ucy4gV2UgY29weSB0aGVtIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbmZpZ3VyYXRvciQxLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXNldCB0aGUgcG9wdXAgaGlzdG9yeSBiZWNhdXNlIHRoZSBpbmRpY2VzIG1heSBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuXG4gICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIob3B0aW9ucykpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5qb2luKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpbHRlcihvcHRpb25zKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gZmlsdGVyKG9wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnNob3dCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dCdXR0b24gPSBvcHRpb25zLnNob3dCdXR0b247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyKHRoaXMub3B0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2R1bGVPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRNb2R1bGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgICAgdGhpcy5tb2R1bGVPcHRpb25zID0gbW9kdWxlT3B0aW9ucztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcblxuICAgICAgdmFyIGZpbHRlciQxID0gZmlsdGVyKHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBzaG93ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9vcHRpb24gaW4gdGhpcy5jb25maWd1cmVPcHRpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25maWd1cmVPcHRpb25zLCBfb3B0aW9uKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHNob3cgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyJDEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlciQxKF9vcHRpb24sIFtdKTtcbiAgICAgICAgICAgIHNob3cgPSBzaG93IHx8IHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbX29wdGlvbl0sIFtfb3B0aW9uXSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIkMSA9PT0gdHJ1ZSB8fCBpbmRleE9mKGZpbHRlciQxKS5jYWxsKGZpbHRlciQxLCBfb3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gdHJ1ZTsgLy8gbGluZWJyZWFrIGJldHdlZW4gY2F0ZWdvcmllc1xuXG4gICAgICAgICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10pO1xuICAgICAgICAgICAgfSAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG5cblxuICAgICAgICAgICAgdGhpcy5fbWFrZUhlYWRlcihfb3B0aW9uKTsgLy8gZ2V0IHRoZSBzdWIgb3B0aW9uc1xuXG5cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbX29wdGlvbl0sIFtfb3B0aW9uXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21ha2VCdXR0b24oKTtcblxuICAgICAgdGhpcy5fcHVzaCgpOyAvL34gdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyh0aGlzLmNvbnRhaW5lcik7XG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogZHJhdyBhbGwgRE9NIGVsZW1lbnRzIG9uIHRoZSBzY3JlZW5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVzaCgpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyXCI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWxldGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53cmFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYWN0dWFsT3B0aW9ucyBpZiBpdCBleGlzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZhbHVlKHBhdGgpIHtcbiAgICAgIHZhciBiYXNlID0gdGhpcy5tb2R1bGVPcHRpb25zO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJhc2VbcGF0aFtpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJhc2UgPSBiYXNlW3BhdGhbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFsbCBvcHRpb24gZWxlbWVudHMgYXJlIHdyYXBwZWQgaW4gYW4gaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGRvbUVsZW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlSXRlbShwYXRoKSB7XG4gICAgICBpZiAodGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaXRlbS5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaXRlbSB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgZG9tRWxlbWVudHMgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICAgIGRvbUVsZW1lbnRzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaCQyKGRvbUVsZW1lbnRzKS5jYWxsKGRvbUVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGVhZGVyIGZvciBtYWpvciBzdWJqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VIZWFkZXIobmFtZSkge1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWhlYWRlclwiO1xuICAgICAgZGl2LmlubmVyVGV4dCA9IG5hbWU7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKFtdLCBkaXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgbGFiZWwsIGlmIGl0IGlzIGFuIG9iamVjdCBsYWJlbCwgaXQgZ2V0cyBkaWZmZXJlbnQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdExhYmVsXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlTGFiZWwobmFtZSwgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdExhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqZWN0TGFiZWwgPT09IHRydWUpIHtcbiAgICAgICAgd2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCh3cmFwSW5UYWcoXCJpXCIsIFwiYlwiLCBuYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuaW5uZXJUZXh0ID0gbmFtZSArIFwiOlwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGl2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZHJvcGRvd24gbGlzdCBmb3IgbXVsdGlwbGUgcG9zc2libGUgc3RyaW5nIG9wdG9pbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZURyb3Bkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICBzZWxlY3QuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdFwiO1xuICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSAwO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaW5kZXhPZihhcnIpLmNhbGwoYXJyLCB2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGluZGV4T2YoYXJyKS5jYWxsKGFyciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG5cbiAgICAgICAgX29wdGlvbjIudmFsdWUgPSBhcnJbaV07XG5cbiAgICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICBfb3B0aW9uMi5zZWxlY3RlZCA9IFwic2VsZWN0ZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vcHRpb24yLmlubmVyVGV4dCA9IGFycltpXTtcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKF9vcHRpb24yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgc2VsZWN0Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBzZWxlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgcmFuZ2Ugb2JqZWN0IGZvciBudW1lcmljIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICAgIHZhciBtaW4gPSBhcnJbMV07XG4gICAgICB2YXIgbWF4ID0gYXJyWzJdO1xuICAgICAgdmFyIHN0ZXAgPSBhcnJbM107XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICByYW5nZS5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VcIjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gbm90IHN1cHBvcnRlZCBvbiBJRTlcblxuICAgICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICAgIHJhbmdlLm1heCA9IG1heDtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nLlxuICAgICAgfVxuXG4gICAgICByYW5nZS5zdGVwID0gc3RlcDsgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cblxuICAgICAgdmFyIHBvcHVwU3RyaW5nID0gXCJcIjtcbiAgICAgIHZhciBwb3B1cFZhbHVlID0gMDtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IDEuMjtcblxuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAvIGZhY3Rvcik7XG4gICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZS52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaW5wdXQuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlaW5wdXRcIjtcbiAgICAgIGlucHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgIG1lLl91cGRhdGUoTnVtYmVyKHRoaXMudmFsdWUpLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB2YXIgaXRlbUluZGV4ID0gdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHJhbmdlLCBpbnB1dCk7IC8vIGlmIGEgcG9wdXAgaXMgbmVlZGVkIEFORCBpdCBoYXMgbm90IGJlZW4gc2hvd24gZm9yIHRoaXMgdmFsdWUsIHNob3cgaXQuXG5cblxuICAgICAgaWYgKHBvcHVwU3RyaW5nICE9PSBcIlwiICYmIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gIT09IHBvcHVwVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSA9IHBvcHVwVmFsdWU7XG5cbiAgICAgICAgdGhpcy5fc2V0dXBQb3B1cChwb3B1cFN0cmluZywgaXRlbUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGJ1dHRvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUJ1dHRvbigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dCdXR0b24gPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvblwiO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5pbm5lclRleHQgPSBcImdlbmVyYXRlIG9wdGlvbnNcIjtcblxuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5fcHJpbnRPcHRpb25zKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbiBob3ZlclwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvblwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lclwiO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2godGhpcy5vcHRpb25zQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGdlbmVyYXRlQnV0dG9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcHJlcGFyZSB0aGUgcG9wdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwUG9wdXAoc3RyaW5nLCBpbmRleCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlICYmIHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLnBvcHVwQ291bnRlciA8IHRoaXMucG9wdXBMaW1pdCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gXCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiO1xuICAgICAgICBkaXYuaW5uZXJUZXh0ID0gc3RyaW5nO1xuXG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBvcHVwQ291bnRlciArPSAxO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge1xuICAgICAgICAgIGh0bWw6IGRpdixcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBwb3B1cCBmcm9tIHRoZSBkb21cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVBvcHVwKCkge1xuICAgICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaG93UG9wdXBJZk5lZWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd1BvcHVwSWZOZWVkZWQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjb3JyZXNwb25kaW5nRWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudHNbdGhpcy5wb3B1cERpdi5pbmRleF07XG4gICAgICAgIHZhciByZWN0ID0gY29ycmVzcG9uZGluZ0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUudG9wID0gcmVjdC50b3AgLSAzMCArIFwicHhcIjsgLy8gMzAgaXMgdGhlIGhlaWdodDtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNi5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0ID0gc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYuX3JlbW92ZVBvcHVwKCk7XG4gICAgICAgIH0sIDE4MDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY2hlY2tib3ggZm9yIGJvb2xlYW4gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VDaGVja2JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUNoZWNrYm94KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY2hlY2tib3hcIjtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGRlZmF1bHRWYWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy5jaGVja2VkLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlVGV4dElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVGV4dElucHV0KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcInRleHRcIjtcbiAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy10ZXh0XCI7XG4gICAgICBjaGVja2JveC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VDb2xvckZpZWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGFyclsxXTtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrXCI7XG4gICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lXCI7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM3Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcblxuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGRpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVzZWQgYnkgdGhlIGNvbG9yIGJ1dHRvbnMgdG8gY2FsbCB0aGUgY29sb3IgcGlja2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGl2XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaG93Q29sb3JQaWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhpcyBkaXZcbiAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZGl2KTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2hvdygpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih2YWx1ZSk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldFVwZGF0ZUNhbGxiYWNrKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sb3JTdHJpbmcgPSBcInJnYmEoXCIgKyBjb2xvci5yICsgXCIsXCIgKyBjb2xvci5nICsgXCIsXCIgKyBjb2xvci5iICsgXCIsXCIgKyBjb2xvci5hICsgXCIpXCI7XG4gICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvclN0cmluZztcblxuICAgICAgICBfdGhpczguX3VwZGF0ZShjb2xvclN0cmluZywgcGF0aCk7XG4gICAgICB9KTsgLy8gb24gY2xvc2Ugb2YgdGhlIGNvbG9ycGlja2VyLCByZXN0b3JlIHRoZSBjYWxsYmFjay5cblxuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM4Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcGFyc2UgYW4gb2JqZWN0IGFuZCBkcmF3IHRoZSBjb3JyZWN0IGl0ZW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhdGg9W11dICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja09ubHk9ZmFsc2VdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU9iamVjdChvYmopIHtcbiAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBjaGVja09ubHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcblxuICAgICAgdmFyIGZpbHRlciQxID0gZmlsdGVyKHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIHZhciB2aXNpYmxlSW5TZXQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgc3ViT2JqIGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc3ViT2JqKSkge1xuICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgIHZhciBpdGVtID0gb2JqW3N1Yk9ial07XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyJDEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlciQxKHN1Yk9iaiwgcGF0aCk7IC8vIGlmIG5lZWRlZCB3ZSBtdXN0IGdvIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgIGlmIChzaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkkMihpdGVtKSAmJiB0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbSAhPT0gXCJib29sZWFuXCIgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNob3cgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUobmV3UGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5JDIoaXRlbSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQXJyYXkoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlVGV4dElucHV0KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgb3B0aW9ucyB0aGF0IGFyZSBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICBpZiAoIXRoaXMuaGlkZU9wdGlvbihwYXRoLCBzdWJPYmosIHRoaXMubW9kdWxlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsbHkgY29sbGFwc2Ugb3B0aW9ucyB3aXRoIGFuIGRpc2FibGVkIGVuYWJsZWQgb3B0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRQYXRoID0gY29weUFuZEV4dGVuZEFycmF5KG5ld1BhdGgsIFwiZW5hYmxlZFwiKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2xhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIF9sYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZG9udCBrbm93IGhvdyB0byBoYW5kbGVcIiwgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpc2libGVJblNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQXJyYXkoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwic3RyaW5nXCIgJiYgYXJyWzBdID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCk7XG5cbiAgICAgICAgaWYgKGFyclsxXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpO1xuXG4gICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcblxuICAgICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgdG8gdXBkYXRlIHRoZSBuZXR3b3JrIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUodmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudC5ib2R5ICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlciAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdCkge1xuICAgICAgICB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdChcImNvbmZpZ0NoYW5nZVwiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgYm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHt7fX0gb3B0aW9uc09ialxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnN0cnVjdE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajsgLy8gd2hlbiBkcm9wZG93biBib3hlcyBjYW4gYmUgc3RyaW5nIG9yIGJvb2xlYW4sIHdlIHR5cGVjYXN0IGl0IGludG8gY29ycmVjdCB0eXBlc1xuXG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgICAgIGlmIChwb2ludGVyW3BhdGhbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSAhPT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltwYXRoW2ldXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9uc09iajtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcmludE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByaW50T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG5cbiAgICAgIHdoaWxlICh0aGlzLm9wdGlvbnNDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5vcHRpb25zQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQod3JhcEluVGFnKFwicHJlXCIsIFwiY29uc3Qgb3B0aW9ucyA9IFwiICsgc3RyaW5naWZ5JDEob3B0aW9ucywgbnVsbCwgMikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e319IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFuZ2VkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKHRoaXMuY2hhbmdlZE9wdGlvbnNbaV0udmFsdWUsIHRoaXMuY2hhbmdlZE9wdGlvbnNbaV0ucGF0aCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25maWd1cmF0b3IkMTtcbn0oKTtcbi8qKlxuICogUG9wdXAgaXMgYSBjbGFzcyB0byBjcmVhdGUgYSBwb3B1cCB3aW5kb3cgd2l0aCBzb21lIHRleHRcbiAqL1xuXG5cbnZhciBQb3B1cCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgICAgIFRoZSBjb250YWluZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIG92ZXJmbG93TWV0aG9kICBIb3cgdGhlIHBvcHVwIHNob3VsZCBhY3QgdG8gb3ZlcmZsb3dpbmcgKCdmbGlwJyBvciAnY2FwJylcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHVwJDEoY29udGFpbmVyLCBvdmVyZmxvd01ldGhvZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cCQxKTtcblxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMub3ZlcmZsb3dNZXRob2QgPSBvdmVyZmxvd01ldGhvZCB8fCBcImNhcFwiO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7IC8vIGNyZWF0ZSB0aGUgZnJhbWVcblxuICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gXCJ2aXMtdG9vbHRpcFwiO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgKiBAcGFyYW0ge251bWJlcn0geSAgIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUG9wdXAkMSwgW3tcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSkge1xuICAgICAgdGhpcy54ID0gX3BhcnNlSW50KHgpO1xuICAgICAgdGhpcy55ID0gX3BhcnNlSW50KHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRlbnQgZm9yIHRoZSBwb3B1cCB3aW5kb3cuIFRoaXMgY2FuIGJlIEhUTUwgY29kZSBvciB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBFbGVtZW50fSBjb250ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHQoY29udGVudCkge1xuICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYW1lLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RyaW5nIGNvbnRhaW5pbmcgbGl0ZXJhbCB0ZXh0LCBlbGVtZW50IGhhcyB0byBiZSB1c2VkIGZvciBIVE1MIGR1ZSB0b1xuICAgICAgICAvLyBYU1Mgcmlza3MgYXNzb2NpYXRlZCB3aXRoIGlubmVySFRNTCAoaS5lLiBwcmV2ZW50IFhTUyBieSBhY2NpZGVudCkuXG4gICAgICAgIHRoaXMuZnJhbWUuaW5uZXJUZXh0ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcG9wdXAgd2luZG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb1Nob3ddICAgIFNob3cgb3IgaGlkZSB0aGUgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coZG9TaG93KSB7XG4gICAgICBpZiAoZG9TaG93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZG9TaG93ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZnJhbWUuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgICAgIHRvcCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dNZXRob2QgPT0gXCJmbGlwXCIpIHtcbiAgICAgICAgICB2YXIgaXNMZWZ0ID0gZmFsc2UsXG4gICAgICAgICAgICAgIGlzVG9wID0gdHJ1ZTsgLy8gV2hlcmUgYXJvdW5kIHRoZSBwb3NpdGlvbiBpdCdzIGxvY2F0ZWRcblxuICAgICAgICAgIGlmICh0aGlzLnkgLSBoZWlnaHQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlzVG9wID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMueCArIHdpZHRoID4gbWF4V2lkdGggLSB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlzTGVmdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMueCAtIHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1RvcCkge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcblxuICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgKyB0aGlzLnBhZGRpbmcgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHRvcCA9IG1heEhlaWdodCAtIGhlaWdodCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9wIDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVmdCA9IHRoaXMueDtcblxuICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggKyB0aGlzLnBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgbGVmdCA9IG1heFdpZHRoIC0gd2lkdGggLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlZnQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKTsgLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9wdXAkMTtcbn0oKTtcblxudmFyIGVycm9yRm91bmQgPSBmYWxzZTtcbnZhciBhbGxPcHRpb25zJDE7XG52YXIgVkFMSURBVE9SX1BSSU5UX1NUWUxFJDEgPSBcImJhY2tncm91bmQ6ICNGRmVlZWU7IGNvbG9yOiAjZGQwMDAwXCI7XG4vKipcbiAqICBVc2VkIHRvIHZhbGlkYXRlIG9wdGlvbnMuXG4gKi9cblxudmFyIFZhbGlkYXRvciQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmFsaWRhdG9yJDEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZhbGlkYXRvciQxKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IkMSwgbnVsbCwgW3tcbiAgICBrZXk6IFwidmFsaWRhdGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdWJPYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgICBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgICBhbGxPcHRpb25zJDEgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgICAgdmFyIHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9ucztcblxuICAgICAgaWYgKHN1Yk9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9uc1tzdWJPYmplY3RdO1xuICAgICAgfVxuXG4gICAgICBWYWxpZGF0b3IkMS5wYXJzZShvcHRpb25zLCB1c2VkT3B0aW9ucywgW10pO1xuICAgICAgcmV0dXJuIGVycm9yRm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgdHJhdmVyc2UgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IGFuZCBjaGVjayBldmVyeSB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIGZvciAodmFyIF9vcHRpb24zIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBfb3B0aW9uMykpIHtcbiAgICAgICAgICBWYWxpZGF0b3IkMS5jaGVjayhfb3B0aW9uMywgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBWYWxpZGF0b3IkMS5nZXRTdWdnZXN0aW9uKG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZmVyZW5jZU9wdGlvbiA9IG9wdGlvbjtcbiAgICAgIHZhciBpc19vYmplY3QgPSB0cnVlO1xuXG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IHRyaWdnZXJzIGlmIHRoZSBfX2FueV9fIGlzIGluIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAvLyAgICAgICBUSEFUJ1MgQSBSRUFMTFkgQkFEIFBMQUNFIFRPIEFMTE9XIElUISEhIVxuICAgICAgICAvLyBUT0RPOiBFeGFtaW5lIGlmIG5lZWRlZCwgcmVtb3ZlIGlmIHBvc3NpYmxlXG4gICAgICAgIC8vIF9fYW55X18gaXMgYSB3aWxkY2FyZC4gQW55IHZhbHVlIGlzIGFjY2VwdGVkIGFuZCB3aWxsIGJlIGZ1cnRoZXIgYW5hbHlzZWQgYnkgcmVmZXJlbmNlLlxuICAgICAgICByZWZlcmVuY2VPcHRpb24gPSBcIl9fYW55X19cIjsgLy8gaWYgdGhlIGFueS1zdWJncm91cCBpcyBub3QgYSBwcmVkZWZpbmVkIG9iamVjdCBpbiB0aGUgY29uZmlndXJhdG9yLFxuICAgICAgICAvLyB3ZSBkbyBub3QgbG9vayBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuXG4gICAgICAgIGlzX29iamVjdCA9IFZhbGlkYXRvciQxLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKSA9PT0gXCJvYmplY3RcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZk9wdGlvbk9iaiA9IHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXTtcblxuICAgICAgaWYgKGlzX29iamVjdCAmJiByZWZPcHRpb25PYmouX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWZPcHRpb25PYmogPSByZWZPcHRpb25PYmouX190eXBlX187XG4gICAgICB9XG5cbiAgICAgIFZhbGlkYXRvciQxLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcmVmZXJlbmNlT3B0aW9uLCByZWZPcHRpb25PYmosIHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgb3B0aW9uICAgICAgICAgICB8IHRoZSBvcHRpb24gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgICAgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIHJlZmVyZW5jZU9wdGlvbnMgfCBUaGUgcmVmZXJlbmNlIG9wdGlvbnMgY29udGFpbmluZyBhbGwgb3B0aW9ucyBhbmQgdGhlaXIgYWxsb3dlZCBmb3JtYXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZlcmVuY2VPcHRpb24gIHwgVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIG9wdGlvbiwgZXhjZXB0IHdoZW4gaGFuZGxpbmcgYW4gX19hbnlfXyB0YWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZPcHRpb25PYmogICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhdGggICAgICAgICAgICAgfCB3aGVyZSBpbiB0aGUgb2JqZWN0IGlzIHRoZSBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKSB7XG4gICAgICB2YXIgbG9nID0gZnVuY3Rpb24gbG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIiVjXCIgKyBtZXNzYWdlICsgVmFsaWRhdG9yJDEucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUkMSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb3B0aW9uVHlwZSA9IFZhbGlkYXRvciQxLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKTtcbiAgICAgIHZhciByZWZPcHRpb25UeXBlID0gcmVmT3B0aW9uT2JqW29wdGlvblR5cGVdO1xuXG4gICAgICBpZiAocmVmT3B0aW9uVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIHdlIGNoZWNrIGlmIGl0IGlzIHN1cHBvc2VkIHRvIGJlIG9uZSBvZiBhIGZldyBzZWxlY3QgdmFsdWVzXG4gICAgICAgIGlmIChWYWxpZGF0b3IkMS5nZXRUeXBlKHJlZk9wdGlvblR5cGUpID09PSBcImFycmF5XCIgJiYgaW5kZXhPZihyZWZPcHRpb25UeXBlKS5jYWxsKHJlZk9wdGlvblR5cGUsIG9wdGlvbnNbb3B0aW9uXSkgPT09IC0xKSB7XG4gICAgICAgICAgbG9nKCdJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArIFwiIEFsbG93ZWQgdmFsdWVzIGFyZTpcIiArIFZhbGlkYXRvciQxLnByaW50KHJlZk9wdGlvblR5cGUpICsgJyBub3QgXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiLiAnKTtcbiAgICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25UeXBlID09PSBcIm9iamVjdFwiICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgICBwYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgVmFsaWRhdG9yJDEucGFyc2Uob3B0aW9uc1tvcHRpb25dLCByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZk9wdGlvbk9ialtcImFueVwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHR5cGUgb2YgdGhlIGZpZWxkIGlzIGluY29ycmVjdCBhbmQgdGhlIGZpZWxkIGNhbm5vdCBiZSBhbnlcbiAgICAgICAgbG9nKCdJbnZhbGlkIHR5cGUgcmVjZWl2ZWQgZm9yIFwiJyArIG9wdGlvbiArICdcIi4gRXhwZWN0ZWQ6ICcgKyBWYWxpZGF0b3IkMS5wcmludChrZXlzJDQocmVmT3B0aW9uT2JqKSkgKyBcIi4gUmVjZWl2ZWQgW1wiICsgb3B0aW9uVHlwZSArICddIFwiJyArIG9wdGlvbnNbb3B0aW9uXSArICdcIicpO1xuICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBBcnJheS48bnVtYmVyPiB8IERhdGUgfCBOb2RlIHwgTW9tZW50IHwgdW5kZWZpbmVkIHwgbnVsbH0gb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFR5cGUob2JqZWN0KSB7XG4gICAgICB2YXIgdHlwZSA9IF90eXBlb2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkkMihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZG9tXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJtb21lbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdWdnZXN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN1Z2dlc3Rpb24ob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgbG9jYWxTZWFyY2ggPSBWYWxpZGF0b3IkMS5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgZmFsc2UpO1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaCA9IFZhbGlkYXRvciQxLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBhbGxPcHRpb25zJDEsIFtdLCB0cnVlKTtcbiAgICAgIHZhciBsb2NhbFNlYXJjaFRocmVzaG9sZCA9IDg7XG4gICAgICB2YXIgZ2xvYmFsU2VhcmNoVGhyZXNob2xkID0gNDtcbiAgICAgIHZhciBtc2c7XG5cbiAgICAgIGlmIChsb2NhbFNlYXJjaC5pbmRleE1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXNnID0gXCIgaW4gXCIgKyBWYWxpZGF0b3IkMS5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgKyAnUGVyaGFwcyBpdCB3YXMgaW5jb21wbGV0ZT8gRGlkIHlvdSBtZWFuOiBcIicgKyBsb2NhbFNlYXJjaC5pbmRleE1hdGNoICsgJ1wiP1xcblxcbic7XG4gICAgICB9IGVsc2UgaWYgKGdsb2JhbFNlYXJjaC5kaXN0YW5jZSA8PSBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgJiYgbG9jYWxTZWFyY2guZGlzdGFuY2UgPiBnbG9iYWxTZWFyY2guZGlzdGFuY2UpIHtcbiAgICAgICAgbXNnID0gXCIgaW4gXCIgKyBWYWxpZGF0b3IkMS5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgKyBcIlBlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiBcIiArIFZhbGlkYXRvciQxLnByaW50TG9jYXRpb24oZ2xvYmFsU2VhcmNoLnBhdGgsIGdsb2JhbFNlYXJjaC5jbG9zZXN0TWF0Y2gsIFwiXCIpO1xuICAgICAgfSBlbHNlIGlmIChsb2NhbFNlYXJjaC5kaXN0YW5jZSA8PSBsb2NhbFNlYXJjaFRocmVzaG9sZCkge1xuICAgICAgICBtc2cgPSAnLiBEaWQgeW91IG1lYW4gXCInICsgbG9jYWxTZWFyY2guY2xvc2VzdE1hdGNoICsgJ1wiPycgKyBWYWxpZGF0b3IkMS5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtc2cgPSBcIi4gRGlkIHlvdSBtZWFuIG9uZSBvZiB0aGVzZTogXCIgKyBWYWxpZGF0b3IkMS5wcmludChrZXlzJDQob3B0aW9ucykpICsgVmFsaWRhdG9yJDEucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCInICsgbXNnLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUkMSk7XG4gICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJhdmVyc2UgdGhlIG9wdGlvbnMgaW4gc2VhcmNoIGZvciBhIG1hdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgcmVjdXJzaXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoID0gXCJcIjtcbiAgICAgIHZhciBjbG9zZXN0TWF0Y2hQYXRoID0gW107XG4gICAgICB2YXIgbG93ZXJDYXNlT3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgaW5kZXhNYXRjaCA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFZhbGlkYXRvciQxLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zW29wXSwgY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wKSk7XG5cbiAgICAgICAgICBpZiAobWluID4gcmVzdWx0LmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSByZXN1bHQuY2xvc2VzdE1hdGNoO1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IHJlc3VsdC5wYXRoO1xuICAgICAgICAgICAgbWluID0gcmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICAgICAgaW5kZXhNYXRjaCA9IHJlc3VsdC5pbmRleE1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQyMDtcblxuICAgICAgICAgIGlmIChpbmRleE9mKF9jb250ZXh0MjAgPSBvcC50b0xvd2VyQ2FzZSgpKS5jYWxsKF9jb250ZXh0MjAsIGxvd2VyQ2FzZU9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleE1hdGNoID0gb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdGFuY2UgPSBWYWxpZGF0b3IkMS5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuXG4gICAgICAgICAgaWYgKG1pbiA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSBvcDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSBjb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2VzdE1hdGNoOiBjbG9zZXN0TWF0Y2gsXG4gICAgICAgIHBhdGg6IGNsb3Nlc3RNYXRjaFBhdGgsXG4gICAgICAgIGRpc3RhbmNlOiBtaW4sXG4gICAgICAgIGluZGV4TWF0Y2g6IGluZGV4TWF0Y2hcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJpbnRMb2NhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbikge1xuICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG5cIjtcbiAgICAgIHZhciBzdHIgPSBcIlxcblxcblwiICsgcHJlZml4ICsgXCJvcHRpb25zID0ge1xcblwiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBwYXRoW2ldICsgXCI6IHtcXG5cIjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHBhdGgubGVuZ3RoICsgMTsgX2orKykge1xuICAgICAgICBzdHIgKz0gXCIgIFwiO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gb3B0aW9uICsgXCJcXG5cIjtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcGF0aC5sZW5ndGggKyAxOyBfaTMrKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwYXRoLmxlbmd0aCAtIF9pMzsgX2oyKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IFwifVxcblwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyICsgXCJcXG5cXG5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkkMShvcHRpb25zKS5yZXBsYWNlKC8oXCIpfChcXFspfChcXF0pfCgsXCJfX3R5cGVfX1wiKS9nLCBcIlwiKS5yZXBsYWNlKC8oLCkvZywgXCIsIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbiAgICAgKiBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAoYykgMjAxMSBBbmRyZWkgTWFja2VuemllXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZW5zaHRlaW5EaXN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbnNodGVpbkRpc3RhbmNlKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgICAgaWYgKGIubGVuZ3RoID09PSAwKSByZXR1cm4gYS5sZW5ndGg7XG4gICAgICB2YXIgbWF0cml4ID0gW107IC8vIGluY3JlbWVudCBhbG9uZyB0aGUgZmlyc3QgY29sdW1uIG9mIGVhY2ggcm93XG5cbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgfSAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuXG5cbiAgICAgIHZhciBqO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICAgIH0gLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgbWF0cml4XG5cblxuICAgICAgZm9yIChpID0gMTsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT0gYS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgIG1hdHJpeFtpIC0gMV1bal0gKyAxKSk7IC8vIGRlbGV0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmFsaWRhdG9yJDE7XG59KCk7XG5cbnZhciBBY3RpdmF0b3IgPSBBY3RpdmF0b3IkMTtcbnZhciBDb25maWd1cmF0b3IgPSBDb25maWd1cmF0b3IkMTtcbnZhciBIYW1tZXIgPSBIYW1tZXIkMTtcbnZhciBQb3B1cCA9IFBvcHVwJDE7XG52YXIgVkFMSURBVE9SX1BSSU5UX1NUWUxFID0gVkFMSURBVE9SX1BSSU5UX1NUWUxFJDE7XG52YXIgVmFsaWRhdG9yID0gVmFsaWRhdG9yJDE7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxuLyoqXG4gKiBQYXJzZSBhIHRleHQgc291cmNlIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIEpTT04gb2JqZWN0LlxuICogVGhlIG9iamVjdCBjb250YWlucyB0d28gbGlzdHM6IG9uZSB3aXRoIG5vZGVzIGFuZCBvbmUgd2l0aCBlZGdlcy5cbiAqXG4gKiBET1QgbGFuZ3VhZ2UgcmVmZXJlbmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9kb2MvaW5mby9sYW5nLmh0bWxcbiAqXG4gKiBET1QgbGFuZ3VhZ2UgYXR0cmlidXRlczogaHR0cDovL2dyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgICAgIFRleHQgY29udGFpbmluZyBhIGdyYXBoIGluIERPVC1ub3RhdGlvblxuICogQHJldHVybnMge29iamVjdH0gZ3JhcGggICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBlZGdlc1xuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRPRE9cbiAqID09PT1cbiAqXG4gKiBGb3IgbGFiZWwgaGFuZGxpbmcsIHRoaXMgaXMgYW4gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvbi4gRnJvbSBkb2NzIChxdW90ZSAjMzAxNSk6XG4gKlxuICogPiB0aGUgZXNjYXBlIHNlcXVlbmNlcyBcIlxcblwiLCBcIlxcbFwiIGFuZCBcIlxcclwiIGRpdmlkZSB0aGUgbGFiZWwgaW50byBsaW5lcywgY2VudGVyZWQsXG4gKiA+IGxlZnQtanVzdGlmaWVkLCBhbmQgcmlnaHQtanVzdGlmaWVkLCByZXNwZWN0aXZlbHkuXG4gKlxuICogU291cmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzI2tlc2NTdHJpbmdcbiAqXG4gKiA+IEFzIGFub3RoZXIgYWlkIGZvciByZWFkYWJpbGl0eSwgZG90IGFsbG93cyBkb3VibGUtcXVvdGVkIHN0cmluZ3MgdG8gc3BhbiBtdWx0aXBsZSBwaHlzaWNhbFxuICogPiBsaW5lcyB1c2luZyB0aGUgc3RhbmRhcmQgQyBjb252ZW50aW9uIG9mIGEgYmFja3NsYXNoIGltbWVkaWF0ZWx5IHByZWNlZGluZyBhIG5ld2xpbmVcbiAqID4gY2hhcmFjdGVyXG4gKiA+IEluIGFkZGl0aW9uLCBkb3VibGUtcXVvdGVkIHN0cmluZ3MgY2FuIGJlIGNvbmNhdGVuYXRlZCB1c2luZyBhICcrJyBvcGVyYXRvci5cbiAqID4gQXMgSFRNTCBzdHJpbmdzIGNhbiBjb250YWluIG5ld2xpbmUgY2hhcmFjdGVycywgd2hpY2ggYXJlIHVzZWQgc29sZWx5IGZvciBmb3JtYXR0aW5nLFxuICogPiB0aGUgbGFuZ3VhZ2UgZG9lcyBub3QgYWxsb3cgZXNjYXBlZCBuZXdsaW5lcyBvciBjb25jYXRlbmF0aW9uIG9wZXJhdG9ycyB0byBiZSB1c2VkXG4gKiA+IHdpdGhpbiB0aGVtLlxuICpcbiAqIC0gQ3VycmVudGx5LCBvbmx5ICdcXFxcbicgaXMgaGFuZGxlZFxuICogLSBOb3RlIHRoYXQgdGV4dCBleHBsaWNpdGx5IHNheXMgJ2xhYmVscyc7IHRoZSBkb3QgcGFyc2VyIGN1cnJlbnRseSBoYW5kbGVzIGVzY2FwZVxuICogICBzZXF1ZW5jZXMgaW4gKiphbGwqKiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZURPVChkYXRhKSB7XG4gIGRvdCA9IGRhdGE7XG4gIHJldHVybiBwYXJzZUdyYXBoKCk7XG59IC8vIG1hcHBpbmcgb2YgYXR0cmlidXRlcyBmcm9tIERPVCAodGhlIGtleXMpIHRvIHZpcy5qcyAodGhlIHZhbHVlcylcblxudmFyIE5PREVfQVRUUl9NQVBQSU5HID0ge1xuICBmb250c2l6ZTogXCJmb250LnNpemVcIixcbiAgZm9udGNvbG9yOiBcImZvbnQuY29sb3JcIixcbiAgbGFiZWxmb250Y29sb3I6IFwiZm9udC5jb2xvclwiLFxuICBmb250bmFtZTogXCJmb250LmZhY2VcIixcbiAgY29sb3I6IFtcImNvbG9yLmJvcmRlclwiLCBcImNvbG9yLmJhY2tncm91bmRcIl0sXG4gIGZpbGxjb2xvcjogXCJjb2xvci5iYWNrZ3JvdW5kXCIsXG4gIHRvb2x0aXA6IFwidGl0bGVcIixcbiAgbGFiZWx0b29sdGlwOiBcInRpdGxlXCJcbn07XG5cbnZhciBFREdFX0FUVFJfTUFQUElORyA9IGNyZWF0ZSQ1KE5PREVfQVRUUl9NQVBQSU5HKTtcblxuRURHRV9BVFRSX01BUFBJTkcuY29sb3IgPSBcImNvbG9yLmNvbG9yXCI7XG5FREdFX0FUVFJfTUFQUElORy5zdHlsZSA9IFwiZGFzaGVzXCI7IC8vIHRva2VuIHR5cGVzIGVudW1lcmF0aW9uXG5cbnZhciBUT0tFTlRZUEUgPSB7XG4gIE5VTEw6IDAsXG4gIERFTElNSVRFUjogMSxcbiAgSURFTlRJRklFUjogMixcbiAgVU5LTk9XTjogM1xufTsgLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcblxudmFyIERFTElNSVRFUlMgPSB7XG4gIFwie1wiOiB0cnVlLFxuICBcIn1cIjogdHJ1ZSxcbiAgXCJbXCI6IHRydWUsXG4gIFwiXVwiOiB0cnVlLFxuICBcIjtcIjogdHJ1ZSxcbiAgXCI9XCI6IHRydWUsXG4gIFwiLFwiOiB0cnVlLFxuICBcIi0+XCI6IHRydWUsXG4gIFwiLS1cIjogdHJ1ZVxufTtcbnZhciBkb3QgPSBcIlwiOyAvLyBjdXJyZW50IGRvdCBmaWxlXG5cbnZhciBpbmRleCQxID0gMDsgLy8gY3VycmVudCBpbmRleCBpbiBkb3QgZmlsZVxuXG52YXIgYyA9IFwiXCI7IC8vIGN1cnJlbnQgdG9rZW4gY2hhcmFjdGVyIGluIGV4cHJcblxudmFyIHRva2VuID0gXCJcIjsgLy8gY3VycmVudCB0b2tlblxuXG52YXIgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7IC8vIHR5cGUgb2YgdGhlIHRva2VuXG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAqL1xuXG5mdW5jdGlvbiBmaXJzdCgpIHtcbiAgaW5kZXgkMSA9IDA7XG4gIGMgPSBkb3QuY2hhckF0KDApO1xufVxuLyoqXG4gKiBHZXQgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBkb3QgZmlsZSBpc1xuICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gKi9cblxuXG5mdW5jdGlvbiBuZXh0KCkge1xuICBpbmRleCQxKys7XG4gIGMgPSBkb3QuY2hhckF0KGluZGV4JDEpO1xufVxuLyoqXG4gKiBQcmV2aWV3IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjTmV4dFxuICovXG5cblxuZnVuY3Rpb24gbmV4dFByZXZpZXcoKSB7XG4gIHJldHVybiBkb3QuY2hhckF0KGluZGV4JDEgKyAxKTtcbn1cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBpcyBhbHBoYWJldGljIG9yIG51bWVyaWMgKCBhLXpBLVpfMC05LjojIClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY1xuICogQHJldHVybnMge2Jvb2xlYW59IGlzQWxwaGFOdW1lcmljXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FscGhhTnVtZXJpYyhjKSB7XG4gIHZhciBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcblxuICBpZiAoY2hhckNvZGUgPCA0Nykge1xuICAgIC8vICMuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAzNSB8fCBjaGFyQ29kZSA9PT0gNDY7XG4gIH1cblxuICBpZiAoY2hhckNvZGUgPCA1OSkge1xuICAgIC8vIDAtOSBhbmQgOlxuICAgIHJldHVybiBjaGFyQ29kZSA+IDQ3O1xuICB9XG5cbiAgaWYgKGNoYXJDb2RlIDwgOTEpIHtcbiAgICAvLyBBLVpcbiAgICByZXR1cm4gY2hhckNvZGUgPiA2NDtcbiAgfVxuXG4gIGlmIChjaGFyQ29kZSA8IDk2KSB7XG4gICAgLy8gX1xuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gOTU7XG4gIH1cblxuICBpZiAoY2hhckNvZGUgPCAxMjMpIHtcbiAgICAvLyBhLXpcbiAgICByZXR1cm4gY2hhckNvZGUgPiA5NjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogTWVyZ2UgYWxsIG9wdGlvbnMgb2Ygb2JqZWN0IGIgaW50byBvYmplY3QgYlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge29iamVjdH0gYVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UkMShhLCBiKSB7XG4gIGlmICghYSkge1xuICAgIGEgPSB7fTtcbiAgfVxuXG4gIGlmIChiKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBiKSB7XG4gICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBhW25hbWVdID0gYltuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxuICogU2V0IGEgdmFsdWUgaW4gYW4gb2JqZWN0LCB3aGVyZSB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIG5hbWUgY2FuIGJlIGFcbiAqIHBhdGggd2l0aCBuZXN0ZWQgcGFyYW1ldGVycy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIHZhciBvYmogPSB7YTogMn07XG4gKiAgICAgc2V0VmFsdWUob2JqLCAnYi5jJywgMyk7ICAgICAvLyBvYmogPSB7YTogMiwgYjoge2M6IDN9fVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICBBIHBhcmFtZXRlciBuYW1lIG9yIGRvdC1zZXBhcmF0ZWQgcGFyYW1ldGVyIHBhdGgsXG4gKiAgICAgICAgICAgICAgICAgICAgICBsaWtlIFwiY29sb3IuaGlnaGxpZ2h0LmJvcmRlclwiLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cblxuZnVuY3Rpb24gc2V0VmFsdWUob2JqLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICB2YXIgbyA9IG9iajtcblxuICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHRoZSBlbmQgcG9pbnRcbiAgICAgIGlmICghb1trZXldKSB7XG4gICAgICAgIG9ba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBvID0gb1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgcG9pbnRcbiAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBZGQgYSBub2RlIHRvIGEgZ3JhcGggb2JqZWN0LiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZSB3aXRoXG4gKiB0aGUgc2FtZSBpZCwgdGhlaXIgYXR0cmlidXRlcyB3aWxsIGJlIG1lcmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKi9cblxuXG5mdW5jdGlvbiBhZGROb2RlKGdyYXBoLCBub2RlKSB7XG4gIHZhciBpLCBsZW47XG4gIHZhciBjdXJyZW50ID0gbnVsbDsgLy8gZmluZCByb290IGdyYXBoIChpbiBjYXNlIG9mIHN1YmdyYXBoKVxuXG4gIHZhciBncmFwaHMgPSBbZ3JhcGhdOyAvLyBsaXN0IHdpdGggYWxsIGdyYXBocyBmcm9tIGN1cnJlbnQgZ3JhcGggdG8gcm9vdCBncmFwaFxuXG4gIHZhciByb290ID0gZ3JhcGg7XG5cbiAgd2hpbGUgKHJvb3QucGFyZW50KSB7XG4gICAgZ3JhcGhzLnB1c2gocm9vdC5wYXJlbnQpO1xuICAgIHJvb3QgPSByb290LnBhcmVudDtcbiAgfSAvLyBmaW5kIGV4aXN0aW5nIG5vZGUgKGF0IHJvb3QgbGV2ZWwpIGJ5IGl0cyBpZFxuXG5cbiAgaWYgKHJvb3Qubm9kZXMpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByb290Lm5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobm9kZS5pZCA9PT0gcm9vdC5ub2Rlc1tpXS5pZCkge1xuICAgICAgICBjdXJyZW50ID0gcm9vdC5ub2Rlc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjdXJyZW50KSB7XG4gICAgLy8gdGhpcyBpcyBhIG5ldyBub2RlXG4gICAgY3VycmVudCA9IHtcbiAgICAgIGlkOiBub2RlLmlkXG4gICAgfTtcblxuICAgIGlmIChncmFwaC5ub2RlKSB7XG4gICAgICAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlJDEoY3VycmVudC5hdHRyLCBncmFwaC5ub2RlKTtcbiAgICB9XG4gIH0gLy8gYWRkIG5vZGUgdG8gdGhpcyAoc3ViKWdyYXBoIGFuZCBhbGwgaXRzIHBhcmVudCBncmFwaHNcblxuXG4gIGZvciAoaSA9IGdyYXBocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBfY29udGV4dDtcblxuICAgIHZhciBnID0gZ3JhcGhzW2ldO1xuXG4gICAgaWYgKCFnLm5vZGVzKSB7XG4gICAgICBnLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGluZGV4T2YoX2NvbnRleHQgPSBnLm5vZGVzKS5jYWxsKF9jb250ZXh0LCBjdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgIGcubm9kZXMucHVzaChjdXJyZW50KTtcbiAgICB9XG4gIH0gLy8gbWVyZ2UgYXR0cmlidXRlc1xuXG5cbiAgaWYgKG5vZGUuYXR0cikge1xuICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlJDEoY3VycmVudC5hdHRyLCBub2RlLmF0dHIpO1xuICB9XG59XG4vKipcbiAqIEFkZCBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge29iamVjdH0gZWRnZVxuICovXG5cblxuZnVuY3Rpb24gYWRkRWRnZShncmFwaCwgZWRnZSkge1xuICBpZiAoIWdyYXBoLmVkZ2VzKSB7XG4gICAgZ3JhcGguZWRnZXMgPSBbXTtcbiAgfVxuXG4gIGdyYXBoLmVkZ2VzLnB1c2goZWRnZSk7XG5cbiAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICB2YXIgYXR0ciA9IG1lcmdlJDEoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcblxuICAgIGVkZ2UuYXR0ciA9IG1lcmdlJDEoYXR0ciwgZWRnZS5hdHRyKTsgLy8gbWVyZ2UgYXR0cmlidXRlc1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG9iamVjdH0gZnJvbVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBvYmplY3R9IHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsfSBhdHRyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlZGdlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cikge1xuICB2YXIgZWRnZSA9IHtcbiAgICBmcm9tOiBmcm9tLFxuICAgIHRvOiB0byxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICBlZGdlLmF0dHIgPSBtZXJnZSQxKHt9LCBncmFwaC5lZGdlKTsgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gIH1cblxuICBlZGdlLmF0dHIgPSBtZXJnZSQxKGVkZ2UuYXR0ciB8fCB7fSwgYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgLy8gTW92ZSBhcnJvd3MgYXR0cmlidXRlIGZyb20gYXR0ciB0byBlZGdlIHRlbXBvcmFsbHkgY3JlYXRlZCBpblxuICAvLyBwYXJzZUF0dHJpYnV0ZUxpc3QoKS5cblxuICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkoXCJhcnJvd3NcIikgJiYgYXR0cltcImFycm93c1wiXSAhPSBudWxsKSB7XG4gICAgICBlZGdlW1wiYXJyb3dzXCJdID0ge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgdHlwZTogYXR0ci5hcnJvd3MudHlwZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXR0cltcImFycm93c1wiXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVkZ2U7XG59XG4vKipcbiAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IGRvdCBmaWxlLlxuICogVGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIGFyZSBhdmFpbGFibGUgYXMgdG9rZW4gYW5kIHRva2VuVHlwZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMO1xuICB0b2tlbiA9IFwiXCI7IC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuXG4gIHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgZG8ge1xuICAgIHZhciBpc0NvbW1lbnQgPSBmYWxzZTsgLy8gc2tpcCBjb21tZW50XG5cbiAgICBpZiAoYyA9PT0gXCIjXCIpIHtcbiAgICAgIC8vIGZpbmQgdGhlIHByZXZpb3VzIG5vbi1zcGFjZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBpID0gaW5kZXgkMSAtIDE7XG5cbiAgICAgIHdoaWxlIChkb3QuY2hhckF0KGkpID09PSBcIiBcIiB8fCBkb3QuY2hhckF0KGkpID09PSBcIlxcdFwiKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvdC5jaGFyQXQoaSkgPT09IFwiXFxuXCIgfHwgZG90LmNoYXJBdChpKSA9PT0gXCJcIikge1xuICAgICAgICAvLyB0aGUgIyBpcyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLCB0aGlzIGlzIGluZGVlZCBhIGxpbmUgY29tbWVudFxuICAgICAgICB3aGlsZSAoYyAhPSBcIlwiICYmIGMgIT0gXCJcXG5cIikge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPT09IFwiL1wiICYmIG5leHRQcmV2aWV3KCkgPT09IFwiL1wiKSB7XG4gICAgICAvLyBza2lwIGxpbmUgY29tbWVudFxuICAgICAgd2hpbGUgKGMgIT0gXCJcIiAmJiBjICE9IFwiXFxuXCIpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjID09PSBcIi9cIiAmJiBuZXh0UHJldmlldygpID09PSBcIipcIikge1xuICAgICAgLy8gc2tpcCBibG9jayBjb21tZW50XG4gICAgICB3aGlsZSAoYyAhPSBcIlwiKSB7XG4gICAgICAgIGlmIChjID09PSBcIipcIiAmJiBuZXh0UHJldmlldygpID09PSBcIi9cIikge1xuICAgICAgICAgIC8vIGVuZCBvZiBibG9jayBjb21tZW50IGZvdW5kLiBza2lwIHRoZXNlIGxhc3QgdHdvIGNoYXJhY3RlcnNcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgIH0gLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG5cblxuICAgIHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgICAgLy8gc3BhY2UsIHRhYiwgZW50ZXJcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH0gd2hpbGUgKGlzQ29tbWVudCk7IC8vIGNoZWNrIGZvciBlbmQgb2YgZG90IGZpbGVcblxuXG4gIGlmIChjID09PSBcIlwiKSB7XG4gICAgLy8gdG9rZW4gaXMgc3RpbGwgZW1wdHlcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHJldHVybjtcbiAgfSAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDIgY2hhcmFjdGVyc1xuXG5cbiAgdmFyIGMyID0gYyArIG5leHRQcmV2aWV3KCk7XG5cbiAgaWYgKERFTElNSVRFUlNbYzJdKSB7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB0b2tlbiA9IGMyO1xuICAgIG5leHQoKTtcbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMSBjaGFyYWN0ZXJcblxuXG4gIGlmIChERUxJTUlURVJTW2NdKSB7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB0b2tlbiA9IGM7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBjaGVjayBmb3IgYW4gaWRlbnRpZmllciAobnVtYmVyIG9yIHN0cmluZylcbiAgLy8gVE9ETzogbW9yZSBwcmVjaXNlIHBhcnNpbmcgb2YgbnVtYmVycy9zdHJpbmdzIChhbmQgdGhlIHBvcnQgc2VwYXJhdG9yICc6JylcblxuXG4gIGlmIChpc0FscGhhTnVtZXJpYyhjKSB8fCBjID09PSBcIi1cIikge1xuICAgIHRva2VuICs9IGM7XG4gICAgbmV4dCgpO1xuXG4gICAgd2hpbGUgKGlzQWxwaGFOdW1lcmljKGMpKSB7XG4gICAgICB0b2tlbiArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0b2tlbiA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICB0b2tlbiA9IGZhbHNlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSBcInRydWVcIikge1xuICAgICAgdG9rZW4gPSB0cnVlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICB9IGVsc2UgaWYgKCFpc05hTihOdW1iZXIodG9rZW4pKSkge1xuICAgICAgdG9rZW4gPSBOdW1iZXIodG9rZW4pOyAvLyBjb252ZXJ0IHRvIG51bWJlclxuICAgIH1cblxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfSAvLyBjaGVjayBmb3IgYSBzdHJpbmcgZW5jbG9zZWQgYnkgZG91YmxlIHF1b3Rlc1xuXG5cbiAgaWYgKGMgPT09ICdcIicpIHtcbiAgICBuZXh0KCk7XG5cbiAgICB3aGlsZSAoYyAhPSBcIlwiICYmIChjICE9ICdcIicgfHwgYyA9PT0gJ1wiJyAmJiBuZXh0UHJldmlldygpID09PSAnXCInKSkge1xuICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFwiXFxcXFwiICYmIG5leHRQcmV2aWV3KCkgPT09IFwiblwiKSB7XG4gICAgICAgIC8vIEhvbm9yIGEgbmV3bGluZSBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgdG9rZW4gKz0gXCJcXG5cIjtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgIH1cblxuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIGlmIChjICE9ICdcIicpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFbmQgb2Ygc3RyaW5nIFwiIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfSAvLyBzb21ldGhpbmcgdW5rbm93biBpcyBmb3VuZCwgd3JvbmcgY2hhcmFjdGVycywgYSBzeW50YXggZXJyb3JcblxuXG4gIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5VTktOT1dOO1xuXG4gIHdoaWxlIChjICE9IFwiXCIpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcbiAgfVxuXG4gIHRocm93IG5ldyBTeW50YXhFcnJvcignU3ludGF4IGVycm9yIGluIHBhcnQgXCInICsgY2hvcCh0b2tlbiwgMzApICsgJ1wiJyk7XG59XG4vKipcbiAqIFBhcnNlIGEgZ3JhcGguXG4gKlxuICogQHJldHVybnMge29iamVjdH0gZ3JhcGhcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlR3JhcGgoKSB7XG4gIHZhciBncmFwaCA9IHt9O1xuICBmaXJzdCgpO1xuICBnZXRUb2tlbigpOyAvLyBvcHRpb25hbCBzdHJpY3Qga2V5d29yZFxuXG4gIGlmICh0b2tlbiA9PT0gXCJzdHJpY3RcIikge1xuICAgIGdyYXBoLnN0cmljdCA9IHRydWU7XG4gICAgZ2V0VG9rZW4oKTtcbiAgfSAvLyBncmFwaCBvciBkaWdyYXBoIGtleXdvcmRcblxuXG4gIGlmICh0b2tlbiA9PT0gXCJncmFwaFwiIHx8IHRva2VuID09PSBcImRpZ3JhcGhcIikge1xuICAgIGdyYXBoLnR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICB9IC8vIG9wdGlvbmFsIGdyYXBoIGlkXG5cblxuICBpZiAodG9rZW5UeXBlID09PSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgIGdyYXBoLmlkID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgfSAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcblxuXG4gIGlmICh0b2tlbiAhPSBcIntcIikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQW5nbGUgYnJhY2tldCB7IGV4cGVjdGVkXCIpO1xuICB9XG5cbiAgZ2V0VG9rZW4oKTsgLy8gc3RhdGVtZW50c1xuXG4gIHBhcnNlU3RhdGVtZW50cyhncmFwaCk7IC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcblxuICBpZiAodG9rZW4gIT0gXCJ9XCIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkFuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZFwiKTtcbiAgfVxuXG4gIGdldFRva2VuKCk7IC8vIGVuZCBvZiBmaWxlXG5cbiAgaWYgKHRva2VuICE9PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJFbmQgb2YgZmlsZSBleHBlY3RlZFwiKTtcbiAgfVxuXG4gIGdldFRva2VuKCk7IC8vIHJlbW92ZSB0ZW1wb3JhcnkgZGVmYXVsdCBvcHRpb25zXG5cbiAgZGVsZXRlIGdyYXBoLm5vZGU7XG4gIGRlbGV0ZSBncmFwaC5lZGdlO1xuICBkZWxldGUgZ3JhcGguZ3JhcGg7XG4gIHJldHVybiBncmFwaDtcbn1cbi8qKlxuICogUGFyc2UgYSBsaXN0IHdpdGggc3RhdGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50cyhncmFwaCkge1xuICB3aGlsZSAodG9rZW4gIT09IFwiXCIgJiYgdG9rZW4gIT0gXCJ9XCIpIHtcbiAgICBwYXJzZVN0YXRlbWVudChncmFwaCk7XG5cbiAgICBpZiAodG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuIENhbiBiZSBhIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQsIG5vZGVcbiAqIHN0YXRlbWVudCwgYSBzZXJpZXMgb2Ygbm9kZSBzdGF0ZW1lbnRzIGFuZCBlZGdlIHN0YXRlbWVudHMsIG9yIGFcbiAqIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGdyYXBoKSB7XG4gIC8vIHBhcnNlIHN1YmdyYXBoXG4gIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuXG4gIGlmIChzdWJncmFwaCkge1xuICAgIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICAgIHBhcnNlRWRnZShncmFwaCwgc3ViZ3JhcGgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBwYXJzZSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50XG5cblxuICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlU3RhdGVtZW50KGdyYXBoKTtcblxuICBpZiAoYXR0cikge1xuICAgIHJldHVybjtcbiAgfSAvLyBwYXJzZSBub2RlXG5cblxuICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO1xuICB9XG5cbiAgdmFyIGlkID0gdG9rZW47IC8vIGlkIGNhbiBiZSBhIHN0cmluZyBvciBhIG51bWJlclxuXG4gIGdldFRva2VuKCk7XG5cbiAgaWYgKHRva2VuID09PSBcIj1cIikge1xuICAgIC8vIGlkIHN0YXRlbWVudFxuICAgIGdldFRva2VuKCk7XG5cbiAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIklkZW50aWZpZXIgZXhwZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgZ3JhcGhbaWRdID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTsgLy8gVE9ETzogaW1wbGVtZW50IGNvbW1hIHNlcGFyYXRlZCBsaXN0IHdpdGggXCJhX2xpc3Q6IElEPUlEIFsnLCddIFthX2xpc3RdIFwiXG4gIH0gZWxzZSB7XG4gICAgcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCk7XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzdWJncmFwaFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaCAgICBwYXJlbnQgZ3JhcGggb2JqZWN0XG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgbnVsbH0gc3ViZ3JhcGhcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlU3ViZ3JhcGgoZ3JhcGgpIHtcbiAgdmFyIHN1YmdyYXBoID0gbnVsbDsgLy8gb3B0aW9uYWwgc3ViZ3JhcGgga2V5d29yZFxuXG4gIGlmICh0b2tlbiA9PT0gXCJzdWJncmFwaFwiKSB7XG4gICAgc3ViZ3JhcGggPSB7fTtcbiAgICBzdWJncmFwaC50eXBlID0gXCJzdWJncmFwaFwiO1xuICAgIGdldFRva2VuKCk7IC8vIG9wdGlvbmFsIGdyYXBoIGlkXG5cbiAgICBpZiAodG9rZW5UeXBlID09PSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgc3ViZ3JhcGguaWQgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICB9IC8vIG9wZW4gYW5nbGUgYnJhY2tldFxuXG5cbiAgaWYgKHRva2VuID09PSBcIntcIikge1xuICAgIGdldFRva2VuKCk7XG5cbiAgICBpZiAoIXN1YmdyYXBoKSB7XG4gICAgICBzdWJncmFwaCA9IHt9O1xuICAgIH1cblxuICAgIHN1YmdyYXBoLnBhcmVudCA9IGdyYXBoO1xuICAgIHN1YmdyYXBoLm5vZGUgPSBncmFwaC5ub2RlO1xuICAgIHN1YmdyYXBoLmVkZ2UgPSBncmFwaC5lZGdlO1xuICAgIHN1YmdyYXBoLmdyYXBoID0gZ3JhcGguZ3JhcGg7IC8vIHN0YXRlbWVudHNcblxuICAgIHBhcnNlU3RhdGVtZW50cyhzdWJncmFwaCk7IC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcblxuICAgIGlmICh0b2tlbiAhPSBcIn1cIikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW4oKTsgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcblxuICAgIGRlbGV0ZSBzdWJncmFwaC5ub2RlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5lZGdlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ncmFwaDtcbiAgICBkZWxldGUgc3ViZ3JhcGgucGFyZW50OyAvLyByZWdpc3RlciBhdCB0aGUgcGFyZW50IGdyYXBoXG5cbiAgICBpZiAoIWdyYXBoLnN1YmdyYXBocykge1xuICAgICAgZ3JhcGguc3ViZ3JhcGhzID0gW107XG4gICAgfVxuXG4gICAgZ3JhcGguc3ViZ3JhcGhzLnB1c2goc3ViZ3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIHN1YmdyYXBoO1xufVxuLyoqXG4gKiBwYXJzZSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50IGxpa2UgXCJub2RlIFtzaGFwZT1jaXJjbGUgZm9udFNpemU9MTZdXCIuXG4gKiBBdmFpbGFibGUga2V5d29yZHMgYXJlICdub2RlJywgJ2VkZ2UnLCAnZ3JhcGgnLlxuICogVGhlIHByZXZpb3VzIGxpc3Qgd2l0aCBkZWZhdWx0IGF0dHJpYnV0ZXMgd2lsbCBiZSByZXBsYWNlZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IGtleXdvcmQgUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgcGFyc2VkIGF0dHJpYnV0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUsIGVkZ2UsIGdyYXBoKSwgb3IgbnVsbCBpZiBub3RoaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBwYXJzZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCkge1xuICAvLyBhdHRyaWJ1dGUgc3RhdGVtZW50c1xuICBpZiAodG9rZW4gPT09IFwibm9kZVwiKSB7XG4gICAgZ2V0VG9rZW4oKTsgLy8gbm9kZSBhdHRyaWJ1dGVzXG5cbiAgICBncmFwaC5ub2RlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwibm9kZVwiO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSBcImVkZ2VcIikge1xuICAgIGdldFRva2VuKCk7IC8vIGVkZ2UgYXR0cmlidXRlc1xuXG4gICAgZ3JhcGguZWRnZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcImVkZ2VcIjtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJncmFwaFwiKSB7XG4gICAgZ2V0VG9rZW4oKTsgLy8gZ3JhcGggYXR0cmlidXRlc1xuXG4gICAgZ3JhcGguZ3JhcGggPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICByZXR1cm4gXCJncmFwaFwiO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIHBhcnNlIGEgbm9kZSBzdGF0ZW1lbnRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBpZFxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCkge1xuICAvLyBub2RlIHN0YXRlbWVudFxuICB2YXIgbm9kZSA9IHtcbiAgICBpZDogaWRcbiAgfTtcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcblxuICBpZiAoYXR0cikge1xuICAgIG5vZGUuYXR0ciA9IGF0dHI7XG4gIH1cblxuICBhZGROb2RlKGdyYXBoLCBub2RlKTsgLy8gZWRnZSBzdGF0ZW1lbnRzXG5cbiAgcGFyc2VFZGdlKGdyYXBoLCBpZCk7XG59XG4vKipcbiAqIFBhcnNlIGFuIGVkZ2Ugb3IgYSBzZXJpZXMgb2YgZWRnZXNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBmcm9tICAgICAgICBJZCBvZiB0aGUgZnJvbSBub2RlXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZ3JhcGgsIGZyb20pIHtcbiAgd2hpbGUgKHRva2VuID09PSBcIi0+XCIgfHwgdG9rZW4gPT09IFwiLS1cIikge1xuICAgIHZhciB0bztcbiAgICB2YXIgdHlwZSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG5cbiAgICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAgIHRvID0gc3ViZ3JhcGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJZGVudGlmaWVyIG9yIHN1YmdyYXBoIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICB0byA9IHRva2VuO1xuICAgICAgYWRkTm9kZShncmFwaCwge1xuICAgICAgICBpZDogdG9cbiAgICAgIH0pO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9IC8vIHBhcnNlIGVkZ2UgYXR0cmlidXRlc1xuXG5cbiAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpOyAvLyBjcmVhdGUgZWRnZVxuXG4gICAgdmFyIGVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cik7XG4gICAgYWRkRWRnZShncmFwaCwgZWRnZSk7XG4gICAgZnJvbSA9IHRvO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGEgc2V0IHdpdGggYXR0cmlidXRlcyxcbiAqIGZvciBleGFtcGxlIFtsYWJlbD1cIjEuMDAwXCIsIHNoYXBlPXNvbGlkXVxuICpcbiAqIEByZXR1cm5zIHtvYmplY3QgfCBudWxsfSBhdHRyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZUxpc3QoKSB7XG4gIHZhciBpO1xuICB2YXIgYXR0ciA9IG51bGw7IC8vIGVkZ2Ugc3R5bGVzIG9mIGRvdCBhbmQgdmlzXG5cbiAgdmFyIGVkZ2VTdHlsZXMgPSB7XG4gICAgZGFzaGVkOiB0cnVlLFxuICAgIHNvbGlkOiBmYWxzZSxcbiAgICBkb3R0ZWQ6IFsxLCA1XVxuICB9O1xuICAvKipcbiAgICogRGVmaW5lIGFycm93IHR5cGVzLlxuICAgKiB2aXMgY3VycmVudGx5IHN1cHBvcnRzIHR5cGVzIGRlZmluZWQgaW4gJ2Fycm93VHlwZXMnLlxuICAgKiBEZXRhaWxzIG9mIGFycm93IHNoYXBlcyBhcmUgZGVzY3JpYmVkIGluXG4gICAqIGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXJyb3ctc2hhcGVzXG4gICAqL1xuXG4gIHZhciBhcnJvd1R5cGVzID0ge1xuICAgIGRvdDogXCJjaXJjbGVcIixcbiAgICBib3g6IFwiYm94XCIsXG4gICAgY3JvdzogXCJjcm93XCIsXG4gICAgY3VydmU6IFwiY3VydmVcIixcbiAgICBpY3VydmU6IFwiaW52X2N1cnZlXCIsXG4gICAgbm9ybWFsOiBcInRyaWFuZ2xlXCIsXG4gICAgaW52OiBcImludl90cmlhbmdsZVwiLFxuICAgIGRpYW1vbmQ6IFwiZGlhbW9uZFwiLFxuICAgIHRlZTogXCJiYXJcIixcbiAgICB2ZWU6IFwidmVlXCJcbiAgfTtcbiAgLyoqXG4gICAqICdhdHRyX2xpc3QnIGNvbnRhaW5zIGF0dHJpYnV0ZXMgZm9yIGNoZWNraW5nIGlmIHNvbWUgb2YgdGhlbSBhcmUgYWZmZWN0ZWRcbiAgICogbGF0ZXIuIEZvciBpbnN0YW5jZSwgYm90aCBvZiAnYXJyb3doZWFkJyBhbmQgJ2RpcicgKGVkZ2Ugc3R5bGUgZGVmaW5lZFxuICAgKiBpbiBET1QpIG1ha2UgY2hhbmdlcyB0byAnYXJyb3dzJyBhdHRyaWJ1dGUgaW4gdmlzLlxuICAgKi9cblxuICB2YXIgYXR0cl9saXN0ID0gbmV3IEFycmF5KCk7XG4gIHZhciBhdHRyX25hbWVzID0gbmV3IEFycmF5KCk7IC8vIHVzZWQgZm9yIGNoZWNraW5nIHRoZSBjYXNlLlxuICAvLyBwYXJzZSBhdHRyaWJ1dGVzXG5cbiAgd2hpbGUgKHRva2VuID09PSBcIltcIikge1xuICAgIGdldFRva2VuKCk7XG4gICAgYXR0ciA9IHt9O1xuXG4gICAgd2hpbGUgKHRva2VuICE9PSBcIlwiICYmIHRva2VuICE9IFwiXVwiKSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQXR0cmlidXRlIG5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW4gIT0gXCI9XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJFcXVhbCBzaWduID0gZXhwZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBdHRyaWJ1dGUgdmFsdWUgZXhwZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRva2VuOyAvLyBjb252ZXJ0IGZyb20gZG90IHN0eWxlIHRvIHZpc1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHZhbHVlID0gZWRnZVN0eWxlc1t2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcnJvd1R5cGU7XG5cbiAgICAgIGlmIChuYW1lID09PSBcImFycm93aGVhZFwiKSB7XG4gICAgICAgIGFycm93VHlwZSA9IGFycm93VHlwZXNbdmFsdWVdO1xuICAgICAgICBuYW1lID0gXCJhcnJvd3NcIjtcbiAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhcnJvd1R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSBcImFycm93dGFpbFwiKSB7XG4gICAgICAgIGFycm93VHlwZSA9IGFycm93VHlwZXNbdmFsdWVdO1xuICAgICAgICBuYW1lID0gXCJhcnJvd3NcIjtcbiAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGFycm93VHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICBhdHRyOiBhdHRyLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgYXR0cl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuID09IFwiLFwiKSB7XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuICE9IFwiXVwiKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkJyYWNrZXQgXSBleHBlY3RlZFwiKTtcbiAgICB9XG5cbiAgICBnZXRUb2tlbigpO1xuICB9XG4gIC8qKlxuICAgKiBBcyBleHBsYWluZWQgaW4gWzFdLCBncmFwaHZpeiBoYXMgbGltaXRhdGlvbnMgZm9yIGNvbWJpbmF0aW9uIG9mXG4gICAqIGFycm93W2hlYWR8dGFpbF0gYW5kIGRpci4gSWYgYXR0cmlidXRlIGxpc3QgaW5jbHVkZXMgJ2RpcicsXG4gICAqIGZvbGxvd2luZyBjYXNlcyBqdXN0IGJlIHN1cHBvcnRlZC5cbiAgICogICAxLiBib3RoIG9yIG5vbmUgKyBhcnJvd2hlYWQsIGFycm93dGFpbFxuICAgKiAgIDIuIGZvcndhcmQgKyBhcnJvd2hlYWQgKGFycm93dGFpbCBpcyBub3QgYWZmZWR0ZWQpXG4gICAqICAgMy4gYmFjayArIGFycm93dGFpbCAoYXJyb3doZWFkIGlzIG5vdCBhZmZlY3RlZClcbiAgICogWzFdIGh0dHBzOi8vd3d3LmdyYXBodml6Lm9yZy9kb2MvaW5mby9hdHRycy5odG1sI2g6dW5kaXJfbm90ZVxuICAgKi9cblxuXG4gIGlmIChpbmNsdWRlcyhhdHRyX25hbWVzKS5jYWxsKGF0dHJfbmFtZXMsIFwiZGlyXCIpKSB7XG4gICAgdmFyIGlkeCA9IHt9OyAvLyBnZXQgaW5kZXggb2YgJ2Fycm93cycgYW5kICdkaXInXG5cbiAgICBpZHguYXJyb3dzID0ge307XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cl9saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwiYXJyb3dzXCIpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS50byAhPSBudWxsKSB7XG4gICAgICAgICAgaWR4LmFycm93cy50byA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLnZhbHVlLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIGFycm93c1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gXCJkaXJcIikge1xuICAgICAgICBpZHguZGlyID0gaTtcbiAgICAgIH1cbiAgICB9IC8vIGZpcnN0LCBhZGQgZGVmYXVsdCBhcnJvdyBzaGFwZSBpZiBpdCBpcyBub3QgYXNzaWduZWQgdG8gYXZvaWQgZXJyb3JcblxuXG4gICAgdmFyIGRpcl90eXBlID0gYXR0cl9saXN0W2lkeC5kaXJdLnZhbHVlO1xuXG4gICAgaWYgKCFpbmNsdWRlcyhhdHRyX25hbWVzKS5jYWxsKGF0dHJfbmFtZXMsIFwiYXJyb3dzXCIpKSB7XG4gICAgICBpZiAoZGlyX3R5cGUgPT09IFwiYm90aFwiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImZvcndhcmRcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSW52YWxpZCBkaXIgdHlwZSBcIicgKyBkaXJfdHlwZSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tX3R5cGU7XG4gICAgdmFyIHRvX3R5cGU7IC8vIHVwZGF0ZSAnYXJyb3dzJyBhdHRyaWJ1dGUgZnJvbSAnZGlyJy5cblxuICAgIGlmIChkaXJfdHlwZSA9PT0gXCJib3RoXCIpIHtcbiAgICAgIC8vIGJvdGggb2Ygc2hhcGVzIG9mICdmcm9tJyBhbmQgJ3RvJyBhcmUgZ2l2ZW5cbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3BsaWNlJDEoYXR0cl9saXN0KS5jYWxsKGF0dHJfbGlzdCwgaWR4LmFycm93cy5mcm9tLCAxKTsgLy8gc2hhcGUgb2YgJ3RvJyBpcyBhc3NpZ25lZCBhbmQgdXNlIGRlZmF1bHQgdG8gJ2Zyb20nXG5cbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIG9ubHkgc2hhcGUgb2YgJ2Zyb20nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCBmb3IgJ3RvJ1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImJhY2tcIikge1xuICAgICAgLy8gZ2l2ZW4gYm90aCBvZiBzaGFwZXMsIGJ1dCB1c2Ugb25seSAnZnJvbSdcbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJcIjtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gZ2l2ZW4gc2hhcGUgb2YgJ3RvJywgYnV0IGRvZXMgbm90IHVzZSBpdFxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGlkeC5hcnJvd3MudG87XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBhc3NpZ24gZ2l2ZW4gJ2Zyb20nIHNoYXBlXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJcIjtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHZhciBpZHhfYXJyb3c7XG5cbiAgICAgIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIGlkeF9hcnJvdyA9IGlkeC5hcnJvd3MudG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHhfYXJyb3cgPSBpZHguYXJyb3dzLmZyb207XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdFtpZHhfYXJyb3ddID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4X2Fycm93XS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4X2Fycm93XS5uYW1lLFxuICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImZvcndhcmRcIikge1xuICAgICAgLy8gZ2l2ZW4gYm90aCBvZiBzaGFwZXMsIGJ1dCB1c2Ugb25seSAndG8nXG4gICAgICBpZiAoaWR4LmFycm93cy50byAmJiBpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBcIlwiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gYXNzaWduIGdpdmVuICd0bycgc2hhcGVcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiXCI7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBnaXZlbiBzaGFwZSBvZiAnZnJvbScsIGJ1dCBkb2VzIG5vdCB1c2UgaXRcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiXCI7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBpZHguYXJyb3dzLmZyb207XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSW52YWxpZCBkaXIgdHlwZSBcIicgKyBkaXJfdHlwZSArICdcIicpO1xuICAgIH0gLy8gcmVtb3ZlICdkaXInIGF0dHJpYnV0ZSBubyBuZWVkIGFueW1vcmVcblxuXG4gICAgc3BsaWNlJDEoYXR0cl9saXN0KS5jYWxsKGF0dHJfbGlzdCwgaWR4LmRpciwgMSk7XG4gIH0gLy8gcGFyc2UgJ3BlbndpZHRoJ1xuXG5cbiAgdmFyIG5vZl9hdHRyX2xpc3Q7XG5cbiAgaWYgKGluY2x1ZGVzKGF0dHJfbmFtZXMpLmNhbGwoYXR0cl9uYW1lcywgXCJwZW53aWR0aFwiKSkge1xuICAgIHZhciB0bXBfYXR0cl9saXN0ID0gW107XG4gICAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9mX2F0dHJfbGlzdDsgaSsrKSB7XG4gICAgICAvLyBleGNsdWRlICd3aWR0aCcgZnJvbSBhdHRyX2xpc3QgaWYgJ3BlbndpZHRoJyBleGlzdHNcbiAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSAhPT0gXCJ3aWR0aFwiKSB7XG4gICAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gXCJwZW53aWR0aFwiKSB7XG4gICAgICAgICAgYXR0cl9saXN0W2ldLm5hbWUgPSBcIndpZHRoXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0bXBfYXR0cl9saXN0LnB1c2goYXR0cl9saXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyX2xpc3QgPSB0bXBfYXR0cl9saXN0O1xuICB9XG5cbiAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5vZl9hdHRyX2xpc3Q7IGkrKykge1xuICAgIHNldFZhbHVlKGF0dHJfbGlzdFtpXS5hdHRyLCBhdHRyX2xpc3RbaV0ubmFtZSwgYXR0cl9saXN0W2ldLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBhdHRyO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzeW50YXggZXJyb3Igd2l0aCBleHRyYSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IHRva2VuIGFuZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge1N5bnRheEVycm9yfSBlcnJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5ld1N5bnRheEVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihtZXNzYWdlICsgJywgZ290IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIiAoY2hhciAnICsgaW5kZXgkMSArIFwiKVwiKTtcbn1cbi8qKlxuICogQ2hvcCBvZmYgdGV4dCBhZnRlciBhIG1heGltdW0gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBjaG9wKHRleHQsIG1heExlbmd0aCkge1xuICByZXR1cm4gdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoID8gdGV4dCA6IHRleHQuc3Vic3RyKDAsIDI3KSArIFwiLi4uXCI7XG59XG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmbiBmb3IgZWFjaCBwYWlyIG9mIGVsZW1lbnRzIGluIHR3byBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5IHwgKn0gYXJyYXkxXG4gKiBAcGFyYW0ge0FycmF5IHwgKn0gYXJyYXkyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cblxuZnVuY3Rpb24gZm9yRWFjaDIoYXJyYXkxLCBhcnJheTIsIGZuKSB7XG4gIGlmIChpc0FycmF5JDIoYXJyYXkxKSkge1xuICAgIGZvckVhY2gkMihhcnJheTEpLmNhbGwoYXJyYXkxLCBmdW5jdGlvbiAoZWxlbTEpIHtcbiAgICAgIGlmIChpc0FycmF5JDIoYXJyYXkyKSkge1xuICAgICAgICBmb3JFYWNoJDIoYXJyYXkyKS5jYWxsKGFycmF5MiwgZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgICAgZm4oZWxlbTEsIGVsZW0yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbihlbGVtMSwgYXJyYXkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNBcnJheSQyKGFycmF5MikpIHtcbiAgICAgIGZvckVhY2gkMihhcnJheTIpLmNhbGwoYXJyYXkyLCBmdW5jdGlvbiAoZWxlbTIpIHtcbiAgICAgICAgZm4oYXJyYXkxLCBlbGVtMik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4oYXJyYXkxLCBhcnJheTIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBTZXQgYSBuZXN0ZWQgcHJvcGVydHkgb24gYW4gb2JqZWN0XG4gKiBXaGVuIG5lc3RlZCBvYmplY3RzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEZvciBleGFtcGxlIHNldFByb3Aoe30sICdmb250LmNvbG9yJywgJ3JlZCcpIHdpbGwgcmV0dXJuIHtmb250OiB7Y29sb3I6ICdyZWQnfX1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgIEEgZG90IHNlcGFyYXRlZCBzdHJpbmcgbGlrZSAnZm9udC5jb2xvcidcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgICAgICAgVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eVxuICogQHJldHVybnMge29iamVjdH0gUmV0dXJucyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBhbGxvd3MgZm9yIGNoYWluaW5nLlxuICovXG5cblxuZnVuY3Rpb24gc2V0UHJvcChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICB2YXIgcHJvcCA9IG5hbWVzLnBvcCgpOyAvLyB0cmF2ZXJzZSBvdmVyIHRoZSBuZXN0ZWQgb2JqZWN0c1xuXG4gIHZhciBvYmogPSBvYmplY3Q7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG5cbiAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgIG9ialtuYW1lXSA9IHt9O1xuICAgIH1cblxuICAgIG9iaiA9IG9ialtuYW1lXTtcbiAgfSAvLyBzZXQgdGhlIHByb3BlcnR5IHZhbHVlXG5cblxuICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3Qgd2l0aCBET1QgYXR0cmlidXRlcyB0byB0aGVpciB2aXMuanMgZXF1aXZhbGVudHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGF0dHIgICAgIE9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge29iamVjdH0gbWFwcGluZ1xuICogQHJldHVybnMge29iamVjdH0gICAgICAgICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHZpcy5qcyBhdHRyaWJ1dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBjb252ZXJ0QXR0cihhdHRyLCBtYXBwaW5nKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIGF0dHIpIHtcbiAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIHZpc1Byb3AgPSBtYXBwaW5nW3Byb3BdO1xuXG4gICAgICBpZiAoaXNBcnJheSQyKHZpc1Byb3ApKSB7XG4gICAgICAgIGZvckVhY2gkMih2aXNQcm9wKS5jYWxsKHZpc1Byb3AsIGZ1bmN0aW9uICh2aXNQcm9wSSkge1xuICAgICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wSSwgYXR0cltwcm9wXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmlzUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgdmlzUHJvcCwgYXR0cltwcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgcHJvcCwgYXR0cltwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9UIGxhbmd1YWdlIGludG8gYSBtYXAgY29udGFpbmluZ1xuICogd2l0aCBub2RlcyBhbmQgZWRnZXMgaW4gdGhlIGZvcm1hdCBvZiBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAgICAgICAgIFRleHQgY29udGFpbmluZyBhIGdyYXBoIGluIERPVC1ub3RhdGlvblxuICogQHJldHVybnMge29iamVjdH0gZ3JhcGhEYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBET1RUb0dyYXBoKGRhdGEpIHtcbiAgLy8gcGFyc2UgdGhlIERPVCBmaWxlXG4gIHZhciBkb3REYXRhID0gcGFyc2VET1QoZGF0YSk7XG4gIHZhciBncmFwaERhdGEgPSB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBvcHRpb25zOiB7fVxuICB9OyAvLyBjb3B5IHRoZSBub2Rlc1xuXG4gIGlmIChkb3REYXRhLm5vZGVzKSB7XG4gICAgdmFyIF9jb250ZXh0MjtcblxuICAgIGZvckVhY2gkMihfY29udGV4dDIgPSBkb3REYXRhLm5vZGVzKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGRvdE5vZGUpIHtcbiAgICAgIHZhciBncmFwaE5vZGUgPSB7XG4gICAgICAgIGlkOiBkb3ROb2RlLmlkLFxuICAgICAgICBsYWJlbDogU3RyaW5nKGRvdE5vZGUubGFiZWwgfHwgZG90Tm9kZS5pZClcbiAgICAgIH07XG4gICAgICBtZXJnZSQxKGdyYXBoTm9kZSwgY29udmVydEF0dHIoZG90Tm9kZS5hdHRyLCBOT0RFX0FUVFJfTUFQUElORykpO1xuXG4gICAgICBpZiAoZ3JhcGhOb2RlLmltYWdlKSB7XG4gICAgICAgIGdyYXBoTm9kZS5zaGFwZSA9IFwiaW1hZ2VcIjtcbiAgICAgIH1cblxuICAgICAgZ3JhcGhEYXRhLm5vZGVzLnB1c2goZ3JhcGhOb2RlKTtcbiAgICB9KTtcbiAgfSAvLyBjb3B5IHRoZSBlZGdlc1xuXG5cbiAgaWYgKGRvdERhdGEuZWRnZXMpIHtcbiAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBlZGdlIGluIERPVCBmb3JtYXQgdG8gYW4gZWRnZSB3aXRoIFZpc0dyYXBoIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvdEVkZ2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaEVkZ2VcbiAgICAgKi9cbiAgICB2YXIgY29udmVydEVkZ2UgPSBmdW5jdGlvbiBjb252ZXJ0RWRnZShkb3RFZGdlKSB7XG4gICAgICB2YXIgZ3JhcGhFZGdlID0ge1xuICAgICAgICBmcm9tOiBkb3RFZGdlLmZyb20sXG4gICAgICAgIHRvOiBkb3RFZGdlLnRvXG4gICAgICB9O1xuICAgICAgbWVyZ2UkMShncmFwaEVkZ2UsIGNvbnZlcnRBdHRyKGRvdEVkZ2UuYXR0ciwgRURHRV9BVFRSX01BUFBJTkcpKTsgLy8gQWRkIGFycm93cyBhdHRyaWJ1dGUgdG8gZGVmYXVsdCBzdHlsZWQgYXJyb3cuXG4gICAgICAvLyBUaGUgcmVhc29uIHdoeSBkZWZhdWx0IHN0eWxlIGlzIG5vdCBhZGRlZCBpbiBwYXJzZUF0dHJpYnV0ZUxpc3QoKSBpc1xuICAgICAgLy8gYmVjYXVzZSBvbmx5IGRlZmF1bHQgaXMgY2xlYXJlZCBiZWZvcmUgaGVyZS5cblxuICAgICAgaWYgKGdyYXBoRWRnZS5hcnJvd3MgPT0gbnVsbCAmJiBkb3RFZGdlLnR5cGUgPT09IFwiLT5cIikge1xuICAgICAgICBncmFwaEVkZ2UuYXJyb3dzID0gXCJ0b1wiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhcGhFZGdlO1xuICAgIH07XG5cbiAgICBmb3JFYWNoJDIoX2NvbnRleHQzID0gZG90RGF0YS5lZGdlcykuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChkb3RFZGdlKSB7XG4gICAgICB2YXIgZnJvbSwgdG87XG5cbiAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgZnJvbSA9IGRvdEVkZ2UuZnJvbS5ub2RlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSB7XG4gICAgICAgICAgaWQ6IGRvdEVkZ2UuZnJvbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB0byA9IGRvdEVkZ2UudG8ubm9kZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9IHtcbiAgICAgICAgICBpZDogZG90RWRnZS50b1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZG90RWRnZS5mcm9tIGluc3RhbmNlb2YgT2JqZWN0ICYmIGRvdEVkZ2UuZnJvbS5lZGdlcykge1xuICAgICAgICB2YXIgX2NvbnRleHQ0O1xuXG4gICAgICAgIGZvckVhY2gkMihfY29udGV4dDQgPSBkb3RFZGdlLmZyb20uZWRnZXMpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yRWFjaDIoZnJvbSwgdG8sIGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICB2YXIgc3ViRWRnZSA9IGNyZWF0ZUVkZ2UoZ3JhcGhEYXRhLCBmcm9tLmlkLCB0by5pZCwgZG90RWRnZS50eXBlLCBkb3RFZGdlLmF0dHIpO1xuICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS50by5lZGdlcykge1xuICAgICAgICB2YXIgX2NvbnRleHQ1O1xuXG4gICAgICAgIGZvckVhY2gkMihfY29udGV4dDUgPSBkb3RFZGdlLnRvLmVkZ2VzKS5jYWxsKF9jb250ZXh0NSwgZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gY29weSB0aGUgb3B0aW9uc1xuXG5cbiAgaWYgKGRvdERhdGEuYXR0cikge1xuICAgIGdyYXBoRGF0YS5vcHRpb25zID0gZG90RGF0YS5hdHRyO1xuICB9XG5cbiAgcmV0dXJuIGdyYXBoRGF0YTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdmFyICovXG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyogZXNsaW50LWVuYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cblxudmFyIGRvdHBhcnNlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRwYXJzZURPVDogcGFyc2VET1QsXG5cdERPVFRvR3JhcGg6IERPVFRvR3JhcGhcbn0pO1xuXG4vKipcclxuICogQ29udmVydCBHZXBoaSB0byBWaXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBnZXBoaUpTT04gLSBUaGUgcGFyc2VkIEpTT04gZGF0YSBpbiBHZXBoaSBmb3JtYXQuXHJcbiAqIEBwYXJhbSBvcHRpb25zT2JqIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGRhdGEgcmVhZHkgdG8gYmUgdXNlZCBpbiBWaXMuXHJcbiAqL1xuZnVuY3Rpb24gcGFyc2VHZXBoaShnZXBoaUpTT04sIG9wdGlvbnNPYmopIHtcbiAgdmFyIF9jb250ZXh0O1xuXG4gIHZhciBvcHRpb25zID0ge1xuICAgIGVkZ2VzOiB7XG4gICAgICBpbmhlcml0Q29sb3I6IGZhbHNlXG4gICAgfSxcbiAgICBub2Rlczoge1xuICAgICAgZml4ZWQ6IGZhbHNlLFxuICAgICAgcGFyc2VDb2xvcjogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnNPYmogIT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zT2JqLmZpeGVkICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMuZml4ZWQgPSBvcHRpb25zT2JqLmZpeGVkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zT2JqLnBhcnNlQ29sb3IgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID0gb3B0aW9uc09iai5wYXJzZUNvbG9yO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zT2JqLmluaGVyaXRDb2xvciAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLmVkZ2VzLmluaGVyaXRDb2xvciA9IG9wdGlvbnNPYmouaW5oZXJpdENvbG9yO1xuICAgIH1cbiAgfVxuXG4gIHZhciBnRWRnZXMgPSBnZXBoaUpTT04uZWRnZXM7XG5cbiAgdmFyIHZFZGdlcyA9IG1hcCQzKGdFZGdlcykuY2FsbChnRWRnZXMsIGZ1bmN0aW9uIChnRWRnZSkge1xuICAgIHZhciB2RWRnZSA9IHtcbiAgICAgIGZyb206IGdFZGdlLnNvdXJjZSxcbiAgICAgIGlkOiBnRWRnZS5pZCxcbiAgICAgIHRvOiBnRWRnZS50YXJnZXRcbiAgICB9O1xuXG4gICAgaWYgKGdFZGdlLmF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgdkVkZ2UuYXR0cmlidXRlcyA9IGdFZGdlLmF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgaWYgKGdFZGdlLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLmxhYmVsID0gZ0VkZ2UubGFiZWw7XG4gICAgfVxuXG4gICAgaWYgKGdFZGdlLmF0dHJpYnV0ZXMgIT0gbnVsbCAmJiBnRWRnZS5hdHRyaWJ1dGVzLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLnRpdGxlID0gZ0VkZ2UuYXR0cmlidXRlcy50aXRsZTtcbiAgICB9XG5cbiAgICBpZiAoZ0VkZ2UudHlwZSA9PT0gXCJEaXJlY3RlZFwiKSB7XG4gICAgICB2RWRnZS5hcnJvd3MgPSBcInRvXCI7XG4gICAgfSAvLyBlZGdlWyd2YWx1ZSddID0gZ0VkZ2UuYXR0cmlidXRlcyAhPSBudWxsID8gZ0VkZ2UuYXR0cmlidXRlcy5XZWlnaHQgOiB1bmRlZmluZWQ7XG4gICAgLy8gZWRnZVsnd2lkdGgnXSA9IGVkZ2VbJ3ZhbHVlJ10gIT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2VnRWRnZS5zaXplO1xuXG5cbiAgICBpZiAoZ0VkZ2UuY29sb3IgJiYgb3B0aW9ucy5lZGdlcy5pbmhlcml0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgICB2RWRnZS5jb2xvciA9IGdFZGdlLmNvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiB2RWRnZTtcbiAgfSk7XG5cbiAgdmFyIHZOb2RlcyA9IG1hcCQzKF9jb250ZXh0ID0gZ2VwaGlKU09OLm5vZGVzKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAoZ05vZGUpIHtcbiAgICB2YXIgdk5vZGUgPSB7XG4gICAgICBpZDogZ05vZGUuaWQsXG4gICAgICBmaXhlZDogb3B0aW9ucy5ub2Rlcy5maXhlZCAmJiBnTm9kZS54ICE9IG51bGwgJiYgZ05vZGUueSAhPSBudWxsXG4gICAgfTtcblxuICAgIGlmIChnTm9kZS5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLmF0dHJpYnV0ZXMgPSBnTm9kZS5hdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5sYWJlbCA9IGdOb2RlLmxhYmVsO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS5zaXplICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnNpemUgPSBnTm9kZS5zaXplO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS5hdHRyaWJ1dGVzICE9IG51bGwgJiYgZ05vZGUuYXR0cmlidXRlcy50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS50aXRsZSA9IGdOb2RlLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnRpdGxlID0gZ05vZGUudGl0bGU7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLnggIT0gbnVsbCkge1xuICAgICAgdk5vZGUueCA9IGdOb2RlLng7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLnkgIT0gbnVsbCkge1xuICAgICAgdk5vZGUueSA9IGdOb2RlLnk7XG4gICAgfVxuXG4gICAgaWYgKGdOb2RlLmNvbG9yICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm5vZGVzLnBhcnNlQ29sb3IgPT09IHRydWUpIHtcbiAgICAgICAgdk5vZGUuY29sb3IgPSBnTm9kZS5jb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZOb2RlLmNvbG9yID0ge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogZ05vZGUuY29sb3IsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICAgIGJvcmRlcjogZ05vZGUuY29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICAgIGJvcmRlcjogZ05vZGUuY29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZOb2RlO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG5vZGVzOiB2Tm9kZXMsXG4gICAgZWRnZXM6IHZFZGdlc1xuICB9O1xufVxuXG52YXIgZ2VwaGlQYXJzZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0cGFyc2VHZXBoaTogcGFyc2VHZXBoaVxufSk7XG5cbi8vIEVuZ2xpc2hcbnZhciBlbiA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpY2sgaW4gYW4gZW1wdHkgc3BhY2UgdG8gcGxhY2UgYSBuZXcgbm9kZS5cIixcbiAgYWRkRWRnZTogXCJBZGQgRWRnZVwiLFxuICBhZGROb2RlOiBcIkFkZCBOb2RlXCIsXG4gIGJhY2s6IFwiQmFja1wiLFxuICBjbG9zZTogXCJDbG9zZVwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiQ2Fubm90IGxpbmsgZWRnZXMgdG8gYSBjbHVzdGVyLlwiLFxuICBkZWw6IFwiRGVsZXRlIHNlbGVjdGVkXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBjYW5ub3QgYmUgZGVsZXRlZC5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLlwiLFxuICBlZGl0OiBcIkVkaXRcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBjYW5ub3QgYmUgZWRpdGVkLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0IEVkZ2VcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGljayBvbiB0aGUgY29udHJvbCBwb2ludHMgYW5kIGRyYWcgdGhlbSB0byBhIG5vZGUgdG8gY29ubmVjdCB0byBpdC5cIixcbiAgZWRpdE5vZGU6IFwiRWRpdCBOb2RlXCJcbn07IC8vIEdlcm1hblxuXG52YXIgZGUgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIktsaWNrZSBhdWYgZWluZSBmcmVpZSBTdGVsbGUsIHVtIGVpbmVuIG5ldWVuIEtub3RlbiB6dSBwbGF6aWVyZW4uXCIsXG4gIGFkZEVkZ2U6IFwiS2FudGUgaGluenVmXFx4RkNnZW5cIixcbiAgYWRkTm9kZTogXCJLbm90ZW4gaGluenVmXFx4RkNnZW5cIixcbiAgYmFjazogXCJadXJcXHhGQ2NrXCIsXG4gIGNsb3NlOiBcIlNjaGxpZcOfZW5cIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIkVzIGlzdCBuaWNodCBtXFx4RjZnbGljaCwgS2FudGVuIG1pdCBDbHVzdGVybiB6dSB2ZXJiaW5kZW4uXCIsXG4gIGRlbDogXCJMXFx4RjZzY2hlIEF1c3dhaGxcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXIga1xceEY2bm5lbiBuaWNodCBnZWxcXHhGNnNjaHQgd2VyZGVuLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiS2xpY2tlIGF1ZiBlaW5lbiBLbm90ZW4gdW5kIHppZWhlIGRpZSBLYW50ZSB6dSBlaW5lbSBhbmRlcmVuIEtub3RlbiwgdW0gZGllc2UgenUgdmVyYmluZGVuLlwiLFxuICBlZGl0OiBcIkVkaXRpZXJlblwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXIga1xceEY2bm5lbiBuaWNodCBlZGl0aWVydCB3ZXJkZW4uXCIsXG4gIGVkaXRFZGdlOiBcIkthbnRlIGVkaXRpZXJlblwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIktsaWNrZSBhdWYgZGllIFZlcmJpbmR1bmdzcHVua3RlIHVuZCB6aWVoZSBkaWVzZSBhdWYgZWluZW4gS25vdGVuLCB1bSBzaWUgenUgdmVyYmluZGVuLlwiLFxuICBlZGl0Tm9kZTogXCJLbm90ZW4gZWRpdGllcmVuXCJcbn07IC8vIFNwYW5pc2hcblxudmFyIGVzID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gbHVnYXIgdmFjXFx4RURvIHBhcmEgY29sb2NhciB1biBudWV2byBub2RvLlwiLFxuICBhZGRFZGdlOiBcIkFcXHhGMWFkaXIgYXJpc3RhXCIsXG4gIGFkZE5vZGU6IFwiQVxceEYxYWRpciBub2RvXCIsXG4gIGJhY2s6IFwiQXRyXFx4RTFzXCIsXG4gIGNsb3NlOiBcIkNlcnJhclwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTm8gc2UgcHVlZGUgY29uZWN0YXIgdW5hIGFyaXN0YSBhIHVuIGdydXBvLlwiLFxuICBkZWw6IFwiRWxpbWluYXIgc2VsZWNjaVxceEYzblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gbm9kbyB5IGFycmFzdHJlIGxhIGFyaXN0YSBoYWNpYSBvdHJvIG5vZG8gcGFyYSBjb25lY3Rhcmxvcy5cIixcbiAgZWRpdDogXCJFZGl0YXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJObyBlcyBwb3NpYmxlIGVkaXRhciBncnVwb3MuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXRhciBhcmlzdGFcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby5cIixcbiAgZWRpdE5vZGU6IFwiRWRpdGFyIG5vZG9cIlxufTsgLy9JdGFsaWFub1xuXG52YXIgaXQgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvXCIsXG4gIGFkZEVkZ2U6IFwiQWdnaXVuZ2kgdW4gdmVydGljZVwiLFxuICBhZGROb2RlOiBcIkFnZ2l1bmdpIHVuIG5vZG9cIixcbiAgYmFjazogXCJJbmRpZXRyb1wiLFxuICBjbG9zZTogXCJDaGl1ZGVyZVwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTm9uIHNpIHBvc3Nvbm8gY29sbGVnYXJlIHZlcnRpY2kgYWQgdW4gY2x1c3RlclwiLFxuICBkZWw6IFwiQ2FuY2VsbGEgbGEgc2VsZXppb25lXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJJIGNsdXN0ZXIgbm9uIHBvc3Nvbm8gZXNzZXJlIGNhbmNlbGxhdGlcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaWNjYSBzdSB1biBub2RvIGUgdHJhc2NpbmFsbyBhZCB1biBhbHRybyBub2RvIHBlciBjb25uZXR0ZXJsaS5cIixcbiAgZWRpdDogXCJNb2RpZmljYVwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkkgY2x1c3RlcnMgbm9uIHBvc3Nvbm8gZXNzZXJlIG1vZGlmaWNhdGkuXCIsXG4gIGVkaXRFZGdlOiBcIk1vZGlmaWNhIGlsIHZlcnRpY2VcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGljY2Egc3VpIFB1bnRpIGRpIGNvbnRyb2xsbyBlIHRyYXNjaW5hbGkgYWQgdW4gbm9kbyBwZXIgY29ubmV0dGVybGkuXCIsXG4gIGVkaXROb2RlOiBcIk1vZGlmaWNhIGlsIG5vZG9cIlxufTsgLy8gRHV0Y2hcblxudmFyIG5sID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJLbGlrIG9wIGVlbiBsZWVnIGdlYmllZCBvbSBlZW4gbmlldXdlIG5vZGUgdGUgbWFrZW4uXCIsXG4gIGFkZEVkZ2U6IFwiTGluayB0b2V2b2VnZW5cIixcbiAgYWRkTm9kZTogXCJOb2RlIHRvZXZvZWdlblwiLFxuICBiYWNrOiBcIlRlcnVnXCIsXG4gIGNsb3NlOiBcIlNsdWl0ZW5cIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIkthbiBnZWVuIGxpbmsgbWFrZW4gbmFhciBlZW4gY2x1c3Rlci5cIixcbiAgZGVsOiBcIlNlbGVjdGllIHZlcndpamRlcmVuXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gdmVyd2lqZGVyZC5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIktsaWsgb3AgZWVuIG5vZGUgZW4gc2xlZXAgZGUgbGluayBuYWFyIGVlbiBhbmRlcmUgbm9kZSBvbSB6ZSB0ZSB2ZXJiaW5kZW4uXCIsXG4gIGVkaXQ6IFwiV2lqemlnZW5cIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gYWFuZ2VwYXN0LlwiLFxuICBlZGl0RWRnZTogXCJMaW5rIHdpanppZ2VuXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiS2xpayBvcCBkZSB2ZXJiaW5kaW5nc3B1bnRlbiBlbiBzbGVlcCB6ZSBuYWFyIGVlbiBub2RlIG9tIGRhYXJtZWUgdGUgdmVyYmluZGVuLlwiLFxuICBlZGl0Tm9kZTogXCJOb2RlIHdpanppZ2VuXCJcbn07IC8vIFBvcnR1Z3Vlc2UgQnJhemlsXG5cbnZhciBwdCA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpcXVlIGVtIHVtIGVzcGHDp28gZW0gYnJhbmNvIHBhcmEgYWRpY2lvbmFyIHVtIG5vdm8gbsOzXCIsXG4gIGFkZEVkZ2U6IFwiQWRpY2lvbmFyIGFyZXN0YVwiLFxuICBhZGROb2RlOiBcIkFkaWNpb25hciBuw7NcIixcbiAgYmFjazogXCJWb2x0YXJcIixcbiAgY2xvc2U6IFwiRmVjaGFyXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgbGlua2FyIGFyZXN0YXMgYSB1bSBjbHVzdGVyLlwiLFxuICBkZWw6IFwiUmVtb3ZlciBzZWxlY2lvbmFkb1wiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciByZW1vdmlkb3MuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWUgZW0gdW0gbsOzIGUgYXJyYXN0ZSBhIGFyZXN0YSBhdMOpIG91dHJvIG7DsyBwYXJhIGNvbmVjdMOhLWxvc1wiLFxuICBlZGl0OiBcIkVkaXRhclwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgZWRpdGFkb3MuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXRhciBhcmVzdGFcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWUgbm9zIHBvbnRvcyBkZSBjb250cm9sZSBlIG9zIGFycmFzdGUgcGFyYSB1bSBuw7MgcGFyYSBjb25lY3TDoS1sb3NcIixcbiAgZWRpdE5vZGU6IFwiRWRpdGFyIG7Ds1wiXG59OyAvLyBSdXNzaWFuXG5cbnZhciBydSA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQsiDRgdCy0L7QsdC+0LTQvdC+0LUg0LzQtdGB0YLQviwg0YfRgtC+0LHRiyDQtNC+0LHQsNCy0LjRgtGMINC90L7QstGL0Lkg0YPQt9C10LsuXCIsXG4gIGFkZEVkZ2U6IFwi0JTQvtCx0LDQstC40YLRjCDRgNC10LHRgNC+XCIsXG4gIGFkZE5vZGU6IFwi0JTQvtCx0LDQstC40YLRjCDRg9C30LXQu1wiLFxuICBiYWNrOiBcItCd0LDQt9Cw0LRcIixcbiAgY2xvc2U6IFwi0JfQsNC60YDRi9Cy0LDRgtGMXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCLQndC10LLQvtC30LzQvtC20L3QviDRgdC+0LXQtNC40L3QuNGC0Ywg0YDQtdCx0YDQsCDQsiDQutC70LDRgdGC0LXRgC5cIixcbiAgZGVsOiBcItCj0LTQsNC70LjRgtGMINCy0YvQsdGA0LDQvdC90L7QtVwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwi0JrQu9Cw0YHRgtC10YDRiyDQvdC1INC80L7Qs9GD0YIg0LHRi9GC0Ywg0YPQtNCw0LvQtdC90YtcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcItCa0LvQuNC60L3QuNGC0LUg0L3QsCDRg9C30LXQuyDQuCDQv9GA0L7RgtGP0L3QuNGC0LUg0YDQtdCx0YDQviDQuiDQtNGA0YPQs9C+0LzRgyDRg9C30LvRgywg0YfRgtC+0LHRiyDRgdC+0LXQtNC40L3QuNGC0Ywg0LjRhS5cIixcbiAgZWRpdDogXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcItCa0LvQsNGB0YLQtdGA0Ysg0L3QtdC00L7RgdGC0YPQv9C90Ysg0LTQu9GPINGA0LXQtNCw0LrRgtC40YDQvtCy0LDQvdC40Y8uXCIsXG4gIGVkaXRFZGdlOiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGA0LXQsdGA0L5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70LjQutC90LjRgtC1INC90LAg0LrQvtC90YLRgNC+0LvRjNC90YvQtSDRgtC+0YfQutC4INC4INC/0LXRgNC10YLQsNGJ0LjRgtC1INC40YUg0LIg0YPQt9C10LssINGH0YLQvtCx0Ysg0L/QvtC00LrQu9GO0YfQuNGC0YzRgdGPINC6INC90LXQvNGDLlwiLFxuICBlZGl0Tm9kZTogXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCDRg9C30LXQu1wiXG59OyAvLyBDaGluZXNlXG5cbnZhciBjbiA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwi5Y2V5Ye756m655m95aSE5pS+572u5paw6IqC54K544CCXCIsXG4gIGFkZEVkZ2U6IFwi5re75Yqg6L+e5o6l57q/XCIsXG4gIGFkZE5vZGU6IFwi5re75Yqg6IqC54K5XCIsXG4gIGJhY2s6IFwi6L+U5ZueXCIsXG4gIGNsb3NlOiBcIumXnOmWiVwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwi5peg5rOV5bCG6L+e5o6l57q/6L+e5o6l5Yiw576k6ZuG44CCXCIsXG4gIGRlbDogXCLliKDpmaTpgInlrppcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIuaXoOazleWIoOmZpOe+pOmbhuOAglwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwi5Y2V5Ye75p+Q5Liq6IqC54K55bm25bCG6K+l6L+e5o6l57q/5ouW5Yqo5Yiw5Y+m5LiA5Liq6IqC54K55Lul6L+e5o6l5a6D5Lus44CCXCIsXG4gIGVkaXQ6IFwi57yW6L6RXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwi5peg5rOV57yW6L6R576k6ZuG44CCXCIsXG4gIGVkaXRFZGdlOiBcIue8lui+kei/nuaOpee6v1wiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIuWNleWHu+aOp+WItuiKgueCueW5tuWwhuWug+S7rOaLluWIsOiKgueCueS4iui/nuaOpeOAglwiLFxuICBlZGl0Tm9kZTogXCLnvJbovpHoioLngrlcIlxufTsgLy8gVWtyYWluaWFuXG5cbnZhciB1ayA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS9C70ZbQutC90ZbRgtGMINC90LAg0LLRltC70YzQvdC1INC80ZbRgdGG0LUsINGJ0L7QsSDQtNC+0LTQsNGC0Lgg0L3QvtCy0LjQuSDQstGD0LfQvtC7LlwiLFxuICBhZGRFZGdlOiBcItCU0L7QtNCw0YLQuCDQutGA0LDQuVwiLFxuICBhZGROb2RlOiBcItCU0L7QtNCw0YLQuCDQstGD0LfQvtC7XCIsXG4gIGJhY2s6IFwi0J3QsNC30LDQtFwiLFxuICBjbG9zZTogXCLQl9Cw0LrRgNC40YLQuFwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwi0J3QtSDQvNC+0LbQu9C40LLQviDQvtCxJ9GU0LTQvdCw0YLQuCDQutGA0LDRlyDQsiDQs9GA0YPQv9GDLlwiLFxuICBkZWw6IFwi0JLQuNC00LDQu9C40YLQuCDQvtCx0YDQsNC90LVcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcItCT0YDRg9C/0Lgg0L3QtSDQvNC+0LbRg9GC0Ywg0LHRg9GC0Lgg0LLQuNC00LDQu9C10L3Rli5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcItCa0LvRltC60L3RltGC0Ywg0L3QsCDQstGD0LfQvtC7INGWINC/0LXRgNC10YLRj9Cz0L3RltGC0Ywg0LrRgNCw0Lkg0LTQviDRltC90YjQvtCz0L4g0LLRg9C30LvQsCwg0YnQvtCxINGX0YUg0Lcn0ZTQtNC90LDRgtC4LlwiLFxuICBlZGl0OiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4XCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwi0JPRgNGD0L/QuCDQvdC10LTQvtGB0YLRg9C/0L3RliDQtNC70Y8g0YDQtdC00LDQs9GD0LLQsNC90L3Rjy5cIixcbiAgZWRpdEVkZ2U6IFwi0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LrRgNCw0LlcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70ZbQutC90ZbRgtGMINC90LAg0LrQvtC90YLRgNC+0LvRjNC90ZYg0YLQvtGH0LrQuCDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINGX0YUg0YMg0LLRg9C30L7Quywg0YnQvtCxINC/0ZbQtNC60LvRjtGH0LjRgtC40YHRjyDQtNC+INC90YzQvtCz0L4uXCIsXG4gIGVkaXROb2RlOiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INCy0YPQt9C+0LtcIlxufTsgLy8gRnJlbmNoXG5cbnZhciBmciA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpcXVleiBkYW5zIHVuIGVuZHJvaXQgdmlkZSBwb3VyIHBsYWNlciB1biBuxZN1ZC5cIixcbiAgYWRkRWRnZTogXCJBam91dGVyIHVuIGxpZW5cIixcbiAgYWRkTm9kZTogXCJBam91dGVyIHVuIG7Fk3VkXCIsXG4gIGJhY2s6IFwiUmV0b3VyXCIsXG4gIGNsb3NlOiBcIkZlcm1lclwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiSW1wb3NzaWJsZSBkZSBjcsOpZXIgdW4gbGllbiB2ZXJzIHVuIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJFZmZhY2VyIGxhIHPDqWxlY3Rpb25cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkxlcyBjbHVzdGVycyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBlZmZhY8Opcy5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZXogc3VyIHVuIG7Fk3VkIGV0IGdsaXNzZXogbGUgbGllbiB2ZXJzIHVuIGF1dHJlIG7Fk3VkIHBvdXIgbGVzIGNvbm5lY3Rlci5cIixcbiAgZWRpdDogXCLDiWRpdGVyXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZGl0w6lzLlwiLFxuICBlZGl0RWRnZTogXCLDiWRpdGVyIGxlIGxpZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWV6IHN1ciBsZXMgcG9pbnRzIGRlIGNvbnRyw7RsZSBldCBnbGlzc2V6LWxlcyBwb3VyIGNvbm5lY3RlciB1biBuxZN1ZC5cIixcbiAgZWRpdE5vZGU6IFwiw4lkaXRlciBsZSBuxZN1ZFwiXG59OyAvLyBDemVjaFxuXG52YXIgY3MgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIktsdWtudXTDrW0gZG8gcHLDoXpkbsOpaG8gcHJvc3RvcnUgbcWvxb5ldGUgcMWZaWRhdCBub3bDvSB2cmNob2wuXCIsXG4gIGFkZEVkZ2U6IFwiUMWZaWRhdCBocmFudVwiLFxuICBhZGROb2RlOiBcIlDFmWlkYXQgdnJjaG9sXCIsXG4gIGJhY2s6IFwiWnDEm3RcIixcbiAgY2xvc2U6IFwiWmF2xZnDrXRcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIk5lbHplIHDFmWlwb2ppdCBocmFudSBrZSBzaGx1a3UuXCIsXG4gIGRlbDogXCJTbWF6YXQgdsO9YsSbclwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTmVsemUgbWF6YXQgc2hsdWt5LlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiUMWZZXRhxb5lbsOtbSB6IGplZG5vaG8gdnJjaG9sdSBkbyBkcnVow6lobyBtxa/FvmV0ZSBzcG9qaXQgdHl0byB2cmNob2x5IG5vdm91IGhyYW5vdS5cIixcbiAgZWRpdDogXCJVcHJhdml0XCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTmVsemUgdXByYXZvdmF0IHNobHVreS5cIixcbiAgZWRpdEVkZ2U6IFwiVXByYXZpdCBocmFudVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIlDFmWV0YcW+ZW7DrW0ga29udHJvbG7DrWhvIHZyY2hvbHUgaHJhbnkgamkgbcWvxb5ldGUgcMWZaXBvaml0IGsgamluw6ltdSB2cmNob2x1LlwiLFxuICBlZGl0Tm9kZTogXCJVcHJhdml0IHZyY2hvbFwiXG59O1xuXG52YXIgbG9jYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRlbjogZW4sXG5cdGRlOiBkZSxcblx0ZXM6IGVzLFxuXHRpdDogaXQsXG5cdG5sOiBubCxcblx0cHQ6IHB0LFxuXHRydTogcnUsXG5cdGNuOiBjbixcblx0dWs6IHVrLFxuXHRmcjogZnIsXG5cdGNzOiBjc1xufSk7XG5cbi8qKlxyXG4gKiBOb3JtYWxpemVzIGxhbmd1YWdlIGNvZGUgaW50byB0aGUgZm9ybWF0IHVzZWQgaW50ZXJuYWxseS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZXMgLSBBbGwgdGhlIGF2YWlsYWJsZSBsb2NhbGVzLlxyXG4gKiBAcGFyYW0gcmF3Q29kZSAtIFRoZSBvcmlnaW5hbCBjb2RlIGFzIHN1cHBsaWVkIGJ5IHRoZSB1c2VyLlxyXG4gKiBAcmV0dXJucyBMYW5ndWFnZSBjb2RlIGluIHRoZSBmb3JtYXQgbGFuZ3VhZ2UtQ09VTlRSWSBvciBsYW5ndWFnZSwgZXZlbnR1YWxseVxyXG4gKiBmYWxsYmFja3MgdG8gZW4uXHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTGFuZ3VhZ2VDb2RlKGxvY2FsZXMsIHJhd0NvZGUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgX3Jhd0NvZGUkc3BsaXQgPSByYXdDb2RlLnNwbGl0KC9bLV8gL10vLCAyKSxcbiAgICAgICAgX3Jhd0NvZGUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Jhd0NvZGUkc3BsaXQsIDIpLFxuICAgICAgICByYXdMYW5ndWFnZSA9IF9yYXdDb2RlJHNwbGl0MlswXSxcbiAgICAgICAgcmF3Q291bnRyeSA9IF9yYXdDb2RlJHNwbGl0MlsxXTtcblxuICAgIHZhciBsYW5ndWFnZSA9IHJhd0xhbmd1YWdlICE9IG51bGwgPyByYXdMYW5ndWFnZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICB2YXIgY291bnRyeSA9IHJhd0NvdW50cnkgIT0gbnVsbCA/IHJhd0NvdW50cnkudG9VcHBlckNhc2UoKSA6IG51bGw7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgY291bnRyeSkge1xuICAgICAgdmFyIGNvZGUgPSBsYW5ndWFnZSArIFwiLVwiICsgY291bnRyeTtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsb2NhbGVzLCBjb2RlKSkge1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICBjb25zb2xlLndhcm4oY29uY2F0KF9jb250ZXh0ID0gXCJVbmtub3duIHZhcmlhbnQgXCIuY29uY2F0KGNvdW50cnksIFwiIG9mIGxhbmd1YWdlIFwiKSkuY2FsbChfY29udGV4dCwgbGFuZ3VhZ2UsIFwiLlwiKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICB2YXIgX2NvZGUgPSBsYW5ndWFnZTtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsb2NhbGVzLCBfY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIF9jb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsYW5ndWFnZSBcIi5jb25jYXQobGFuZ3VhZ2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIGxvY2FsZSBcIi5jb25jYXQocmF3Q29kZSwgXCIsIGZhbGxpbmcgYmFjayB0byBFbmdsaXNoLlwiKSk7XG4gICAgcmV0dXJuIFwiZW5cIjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIGVycm9yIHdoaWxlIG5vcm1hbGl6aW5nIGxvY2FsZSBcIi5jb25jYXQocmF3Q29kZSwgXCIsIGZhbGxpbmcgYmFjayB0byBFbmdsaXNoLlwiKSk7XG4gICAgcmV0dXJuIFwiZW5cIjtcbiAgfVxufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYSBjYW52YXMgdG8gYSBnaXZlbiBpbWFnZSwgY29udGFpbmluZyBhIG51bWJlciBvZiByZW5kZXJpbmdzXG4gKiBvZiB0aGUgaW1hZ2UgYXQgdmFyaW91cyBzaXplcy5cbiAqXG4gKiBUaGlzIHRlY2huaXF1ZSBpcyBrbm93biBhcyAnbWlwbWFwcGluZycuXG4gKlxuICogTk9URTogSW1hZ2VzIGNhbiBhbHNvIGJlIG9mIHR5cGUgJ2RhdGE6c3ZnK3htbGAuIFRoaXMgY29kZSBhbHNvIHdvcmtzXG4gKiAgICAgICBmb3Igc3ZnLCBidXQgdGhlIG1pcG1hcHBpbmcgbWF5IG5vdCBiZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAqL1xudmFyIENhY2hlZEltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIENhY2hlZEltYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZWRJbWFnZSk7XG5cbiAgICB0aGlzLk5VTV9JVEVSQVRJT05TID0gNDsgLy8gTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjb29yZGluYXRlcyBhcnJheVxuXG4gICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGltYWdlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENhY2hlZEltYWdlLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47XG4gICAgICB0aGlzLnNyYyA9IHRoaXMuaW1hZ2Uuc3JjOyAvLyBGb3Igc2FtZSBpbnRlcmZhY2Ugd2l0aCBJbWFnZVxuXG4gICAgICB2YXIgdyA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgICB2YXIgaCA9IHRoaXMuaW1hZ2UuaGVpZ2h0OyAvLyBFYXNlIGV4dGVybmFsIGFjY2Vzc1xuXG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICAgIHZhciBoMiA9IE1hdGguZmxvb3IoaCAvIDIpO1xuICAgICAgdmFyIGg0ID0gTWF0aC5mbG9vcihoIC8gNCk7XG4gICAgICB2YXIgaDggPSBNYXRoLmZsb29yKGggLyA4KTtcbiAgICAgIHZhciBoMTYgPSBNYXRoLmZsb29yKGggLyAxNik7XG4gICAgICB2YXIgdzIgPSBNYXRoLmZsb29yKHcgLyAyKTtcbiAgICAgIHZhciB3NCA9IE1hdGguZmxvb3IodyAvIDQpO1xuICAgICAgdmFyIHc4ID0gTWF0aC5mbG9vcih3IC8gOCk7XG4gICAgICB2YXIgdzE2ID0gTWF0aC5mbG9vcih3IC8gMTYpOyAvLyBNYWtlIGNhbnZhcyBhcyBzbWFsbCBhcyBwb3NzaWJsZVxuXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDMgKiB3NDtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGgyOyAvLyBDb29yZGluYXRlcyBhbmQgc2l6ZXMgb2YgaW1hZ2VzIGNvbnRhaW5lZCBpbiB0aGUgY2FudmFzXG4gICAgICAvLyBWYWx1ZXMgcGVyIHJvdzogIFt0b3AgeCwgbGVmdCB5LCB3aWR0aCwgaGVpZ2h0XVxuXG4gICAgICB0aGlzLmNvb3JkaW5hdGVzID0gW1swLCAwLCB3MiwgaDJdLCBbdzIsIDAsIHc0LCBoNF0sIFt3MiwgaDQsIHc4LCBoOF0sIFs1ICogdzgsIGg0LCB3MTYsIGgxNl1dO1xuXG4gICAgICB0aGlzLl9maWxsTWlwTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGluaXQoKSBoYXMgYmVlbiBjYWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IG1haW4gaW1hZ2UgaW4gdmFyaW91cyBzaXplcyB0byB0aGUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFRoZSByYXRpb25hbGUgYmVoaW5kIHRoaXMgaXMgdG8gcmVkdWNlIGFydGVmYWN0cyBkdWUgdG8gaW50ZXJwb2xhdGlvblxuICAgICAqIGF0IGRpZmZlcmluZyB6b29tIGxldmVscy5cbiAgICAgKlxuICAgICAqIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTg3NjE0MDQvMTIyMzUzMVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2RzIHRha2VzIHRoZSByZXNpemluZyBvdXQgb2YgdGhlIGRyYXdpbmcgbG9vcCwgaW4gb3JkZXIgdG9cbiAgICAgKiByZWR1Y2UgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBUaGUgY29kZSBhc3N1bWVzIHRoYXQgYSAyRCBjb250ZXh0IGNhbiBhbHdheXMgYmUgZ290dGVuLiBUaGlzIGlzXG4gICAgICogICAgICAgbm90IG5lY2Vzc2FyaWx5IHRydWUhIE9UT0gsIGlmIG5vdCB0cnVlIHRoZW4gdXNhZ2Ugb2YgdGhpcyBjbGFzc1xuICAgICAqICAgICAgIGlzIHNlbnNlbGVzcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmlsbE1pcE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsbE1pcE1hcCgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7IC8vIEZpcnN0IHpvb20tbGV2ZWwgY29tZXMgZnJvbSB0aGUgaW1hZ2VcblxuICAgICAgdmFyIHRvID0gdGhpcy5jb29yZGluYXRlc1swXTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgdG9bMF0sIHRvWzFdLCB0b1syXSwgdG9bM10pOyAvLyBUaGUgcmVzdCBhcmUgY29weSBhY3Rpb25zIGludGVybmFsIHRvIHRoZSBjYW52YXMvY29udGV4dFxuXG4gICAgICBmb3IgKHZhciBpdGVyYXRpb25zID0gMTsgaXRlcmF0aW9ucyA8IHRoaXMuTlVNX0lURVJBVElPTlM7IGl0ZXJhdGlvbnMrKykge1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9ucyAtIDFdO1xuICAgICAgICB2YXIgX3RvID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zXTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgZnJvbVswXSwgZnJvbVsxXSwgZnJvbVsyXSwgZnJvbVszXSwgX3RvWzBdLCBfdG9bMV0sIF90b1syXSwgX3RvWzNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgaW1hZ2UsIHVzaW5nIHRoZSBtaXBtYXAgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogTWlwTWFwIGlzIG9ubHkgdXNlZCBpZiBwYXJhbSBmYWN0b3IgPiAyOyBvdGhlcndpc2UsIG9yaWdpbmFsIGJpdG1hcFxuICAgICAqIGlzIHJlc2l6ZWQuIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNraXAgbWlwbWFwIHVzYWdlLCBlLmcuIGJ5IHNldHRpbmcgZmFjdG9yID0gMVxuICAgICAqXG4gICAgICogQ3JlZGl0cyB0byAnQWxleCBkZSBNdWxkZXInIGZvciBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIGNvbnRleHQgb24gd2hpY2ggdG8gZHJhdyB6b29tZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBmYWN0b3Igc2NhbGUgZmFjdG9yIGF0IHdoaWNoIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3SW1hZ2VBdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCBmYWN0b3IsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKCkpIHJldHVybjsgLy9jYW4ndCBkcmF3IGltYWdlIHlldCBub3QgaW50aWFsaXplZFxuXG4gICAgICBpZiAoZmFjdG9yID4gMikge1xuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggem9vbWVkIGltYWdlIHRvIHVzZVxuICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGZhY3RvciA+IDIgJiYgaXRlcmF0aW9ucyA8IHRoaXMuTlVNX0lURVJBVElPTlMpIHtcbiAgICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb25zID49IHRoaXMuTlVNX0lURVJBVElPTlMpIHtcbiAgICAgICAgICBpdGVyYXRpb25zID0gdGhpcy5OVU1fSVRFUkFUSU9OUyAtIDE7XG4gICAgICAgIH0gLy9jb25zb2xlLmxvZyhcIml0ZXJhdGlvbnM6IFwiICsgaXRlcmF0aW9ucyk7XG5cblxuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9uc107XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGltYWdlIGRpcmVjdGx5XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FjaGVkSW1hZ2U7XG59KCk7XG5cbi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyBhIGNhbGxiYWNrIHRoYXQgYWNjZXB0cyBhbiBJbWFnZS5cbiAqXG4gKiBAY2FsbGJhY2sgSW1hZ2VDYWxsYmFja1xuICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgbG9hZHMgaW1hZ2VzIGFuZCBrZWVwcyB0aGVtIHN0b3JlZC5cbiAqXG4gKiBAcGFyYW0ge0ltYWdlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cblxudmFyIEltYWdlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0ltYWdlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBJbWFnZXMoY2FsbGJhY2spIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VzKTtcblxuICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgdGhpcy5pbWFnZUJyb2tlbiA9IHt9O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICAgICAgICAgICAgICBUaGUgb3JpZ2luYWwgVXJsIHRoYXQgZmFpbGVkIHRvIGxvYWQsIGlmIHRoZSBicm9rZW4gaW1hZ2UgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjYWNoZSB1c2luZyB0aGlzIFVybCBhcyB0aGUga2V5IHNvIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhpcyBVcmwgd2lsbCByZXR1cm4gdGhlIGJyb2tlbiBpbWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgICAgICAgICAgICAgIFVybCB0aGUgYnJva2VuIGltYWdlIHRvIHRyeSBhbmQgbG9hZFxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVRvTG9hZEJyb2tlblVybE9uICAgVGhlIGltYWdlIG9iamVjdFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZXMsIFt7XG4gICAga2V5OiBcIl90cnlsb2FkQnJva2VuVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWFnZVRvTG9hZEJyb2tlblVybE9uKSB7XG4gICAgICAvL0lmIHRoZXNlIHBhcmFtZXRlcnMgYXJlbid0IHNwZWNpZmllZCB0aGVuIGV4aXQgdGhlIGZ1bmN0aW9uIGJlY2F1c2Ugbm90aGluZyBjb25zdHJ1Y3RpdmUgY2FuIGJlIGRvbmVcbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCBpbWFnZVRvTG9hZEJyb2tlblVybE9uID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgaWYgKGJyb2tlblVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIGJyb2tlbiB1cmwgaW1hZ2UgZGVmaW5lZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvL0NsZWFyIHRoZSBvbGQgc3Vic2NyaXB0aW9uIHRvIHRoZSBlcnJvciBldmVudCBhbmQgcHV0IGEgbmV3IGluIHBsYWNlIHRoYXQgb25seSBoYW5kbGUgZXJyb3JzIGluIGxvYWRpbmcgdGhlIGJyb2tlbkltYWdlVXJsXG5cblxuICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5pbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgYnJva2VuSW1hZ2U6XCIsIGJyb2tlblVybCk7IC8vIGNhY2hlIGl0ZW0gd2lsbCBjb250YWluIGVtcHR5IGltYWdlLCB0aGlzIHNob3VsZCBiZSBPSyBmb3IgZGVmYXVsdFxuICAgICAgfTsgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIGJyb2tlblVybCwgdGhpcyBpcyBhY3R1YWxseSB3aGF0IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgYnJva2VuIGltYWdlXG5cblxuICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5pbWFnZS5zcmMgPSBicm9rZW5Vcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9SZWRyYXdXaXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWRyYXdXaXRoSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhd1dpdGhJbWFnZShpbWFnZVRvUmVkcmF3V2l0aCkge1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhpbWFnZVRvUmVkcmF3V2l0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgVXJsIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgVXJsIG9mIGFuIGltYWdlIHRvIHVzZSBpZiB0aGUgdXJsIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAqIEByZXR1cm5zIHtJbWFnZX0gaW1nICAgICAgICAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGJyb2tlblVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9UcnkgYW5kIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgY2FjaGUsIGlmIHN1Y2Nlc3NmdWwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBpbWFnZVxuICAgICAgdmFyIGNhY2hlZEltYWdlID0gdGhpcy5pbWFnZXNbdXJsXTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSkgcmV0dXJuIGNhY2hlZEltYWdlOyAvL0NyZWF0ZSBhIG5ldyBpbWFnZVxuXG4gICAgICB2YXIgaW1nID0gbmV3IENhY2hlZEltYWdlKCk7IC8vIE5lZWQgdG8gYWRkIHRvIGNhY2hlIGhlcmUsIG90aGVyd2lzZSBmaW5hbCByZXR1cm4gd2lsbCBzcGF3biBkaWZmZXJlbnQgY29waWVzIG9mIHRoZSBzYW1lIGltYWdlLFxuICAgICAgLy8gQWxzbywgdGhlcmUgd2lsbCBiZSBtdWx0aXBsZSBsb2FkcyBvZiB0aGUgc2FtZSBpbWFnZS5cblxuICAgICAgdGhpcy5pbWFnZXNbdXJsXSA9IGltZzsgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHlcblxuICAgICAgaW1nLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJvcGVybHkgaW5pdCB0aGUgY2FjaGVkIGl0ZW0gYW5kIHRoZW4gcmVxdWVzdCBhIHJlZHJhd1xuICAgICAgICBfdGhpcy5fZml4SW1hZ2VDb29yZGluYXRlcyhpbWcuaW1hZ2UpO1xuXG4gICAgICAgIGltZy5pbml0KCk7XG5cbiAgICAgICAgX3RoaXMuX3JlZHJhd1dpdGhJbWFnZShpbWcpO1xuICAgICAgfTsgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG5cblxuICAgICAgaW1nLmltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBpbWFnZTpcIiwgdXJsKTsgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG5cbiAgICAgICAgX3RoaXMuX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltZyk7XG4gICAgICB9OyAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgdXJsLCB0aGlzIGlzIHdoYXQgYWN0dWFsbHkga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBpbWFnZVxuXG5cbiAgICAgIGltZy5pbWFnZS5zcmMgPSB1cmw7IC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcblxuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSUUxMSBmaXggLS0gdGhhbmtzIGRwb25jaCFcbiAgICAgKlxuICAgICAqIExvY2FsIGhlbHBlciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9DYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZml4SW1hZ2VDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml4SW1hZ2VDb29yZGluYXRlcyhpbWFnZVRvQ2FjaGUpIHtcbiAgICAgIGlmIChpbWFnZVRvQ2FjaGUud2lkdGggPT09IDApIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgICBpbWFnZVRvQ2FjaGUud2lkdGggPSBpbWFnZVRvQ2FjaGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIGltYWdlVG9DYWNoZS5oZWlnaHQgPSBpbWFnZVRvQ2FjaGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlcztcbn0oKTtcblxudmFyIGludGVybmFsTWV0YWRhdGEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZmFpbHMkNyA9IGZhaWxzJHQ7XG52YXIgYXJyYXlCdWZmZXJOb25FeHRlbnNpYmxlID0gZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoYnVmZmVyKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1ZmZlciwgJ2EnLCB7XG4gICAgICB2YWx1ZTogOFxuICAgIH0pO1xuICB9XG59KTtcblxudmFyIGZhaWxzJDYgPSBmYWlscyR0O1xudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCRqO1xudmFyIGNsYXNzb2YkNCA9IGNsYXNzb2ZSYXckMTtcbnZhciBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgPSBhcnJheUJ1ZmZlck5vbkV4dGVuc2libGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlIC0tIHNhZmVcblxudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMSA9IGZhaWxzJDYoZnVuY3Rpb24gKCkge1xuICAkaXNFeHRlbnNpYmxlKDEpO1xufSk7IC8vIGBPYmplY3QuaXNFeHRlbnNpYmxlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZXh0ZW5zaWJsZVxuXG52YXIgb2JqZWN0SXNFeHRlbnNpYmxlID0gRkFJTFNfT05fUFJJTUlUSVZFUyQxIHx8IEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSA/IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICBpZiAoIWlzT2JqZWN0JDYoaXQpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgJiYgY2xhc3NvZiQ0KGl0KSA9PSAnQXJyYXlCdWZmZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlO1xufSA6ICRpc0V4dGVuc2libGU7XG5cbnZhciBmYWlscyQ1ID0gZmFpbHMkdDtcbnZhciBmcmVlemluZyA9ICFmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzL25vLW9iamVjdC1wcmV2ZW50ZXh0ZW5zaW9ucyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuXG52YXIgJCRlID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoaWRkZW5LZXlzID0gaGlkZGVuS2V5cyQ2O1xudmFyIGlzT2JqZWN0JDUgPSBpc09iamVjdCRqO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWw7XG52YXIgaXNFeHRlbnNpYmxlJDEgPSBvYmplY3RJc0V4dGVuc2libGU7XG52YXIgdWlkID0gdWlkJDQ7XG52YXIgRlJFRVpJTkcgPSBmcmVlemluZztcbnZhciBSRVFVSVJFRCA9IGZhbHNlO1xudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQkMSA9IDA7XG5cbnZhciBzZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBkZWZpbmVQcm9wZXJ0eSQyKGl0LCBNRVRBREFUQSwge1xuICAgIHZhbHVlOiB7XG4gICAgICBvYmplY3RJRDogJ08nICsgaWQkMSsrLFxuICAgICAgLy8gb2JqZWN0IElEXG4gICAgICB3ZWFrRGF0YToge30gLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcblxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZmFzdEtleSQxID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QkNShpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG5cbiAgaWYgKCFoYXNPd24kNShpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZSQxKGl0KSkgcmV0dXJuICdGJzsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnOyAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXG4gICAgc2V0TWV0YWRhdGEoaXQpOyAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH1cblxuICByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xufTtcblxudmFyIGdldFdlYWtEYXRhJDEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhc093biQ1KGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlJDEoaXQpKSByZXR1cm4gdHJ1ZTsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICBzZXRNZXRhZGF0YShpdCk7IC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfVxuXG4gIHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG59OyAvLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcblxuXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaSU5HICYmIFJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZSQxKGl0KSAmJiAhaGFzT3duJDUoaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICBtZXRhLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9O1xuXG4gIFJFUVVJUkVEID0gdHJ1ZTtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmY7XG4gIHZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyQ0KFtdLnNwbGljZSk7XG4gIHZhciB0ZXN0ID0ge307XG4gIHRlc3RbTUVUQURBVEFdID0gMTsgLy8gcHJldmVudCBleHBvc2luZyBvZiBtZXRhZGF0YSBrZXlcblxuICBpZiAoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0KS5sZW5ndGgpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzdWx0W2ldID09PSBNRVRBREFUQSkge1xuICAgICAgICAgIHNwbGljZShyZXN1bHQsIGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgICQkZSh7XG4gICAgICB0YXJnZXQ6ICdPYmplY3QnLFxuICAgICAgc3RhdDogdHJ1ZSxcbiAgICAgIGZvcmNlZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZS5mXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtZXRhID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzID0ge1xuICBlbmFibGU6IGVuYWJsZSxcbiAgZmFzdEtleTogZmFzdEtleSQxLFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEkMSxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkUDtcbnZhciBiaW5kJDMgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkZDtcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNDtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ0ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBpc1Byb3RvdHlwZU9mJDkgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yJDUgPSBnZXRJdGVyYXRvciQ3O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkODtcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQyO1xudmFyIFR5cGVFcnJvciQ1ID0gZ2xvYmFsJGEuVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG52YXIgaXRlcmF0ZSQzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQkMyh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0JDModmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuICB9O1xuXG4gIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyBUeXBlRXJyb3IkNSh0cnlUb1N0cmluZyQxKGl0ZXJhYmxlKSArICcgaXMgbm90IGl0ZXJhYmxlJyk7IC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG5cbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ0KGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQ5KFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkNShpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuXG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsJDEobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDkoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJFA7XG52YXIgaXNQcm90b3R5cGVPZiQ4ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBUeXBlRXJyb3IkNCA9IGdsb2JhbCQ5LlR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDgoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgVHlwZUVycm9yJDQoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuXG52YXIgJCRkID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkOCA9IGdsb2JhbCRQO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUkMSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cztcbnZhciBmYWlscyQ0ID0gZmFpbHMkdDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBpdGVyYXRlJDIgPSBpdGVyYXRlJDM7XG52YXIgYW5JbnN0YW5jZSQyID0gYW5JbnN0YW5jZSQzO1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJGg7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JGo7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDIgPSBpbnRlcm5hbFN0YXRlO1xudmFyIHNldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldHRlckZvcjtcblxudmFyIGNvbGxlY3Rpb24kMyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsJDhbQ09OU1RSVUNUT1JfTkFNRV07XG4gIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuICB2YXIgQ29uc3RydWN0b3I7XG5cbiAgaWYgKCFERVNDUklQVE9SUyQyIHx8ICFpc0NhbGxhYmxlKE5hdGl2ZUNvbnN0cnVjdG9yKSB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSQxLmVuYWJsZSgpO1xuICB9IGVsc2Uge1xuICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQyKGFuSW5zdGFuY2UkMih0YXJnZXQsIFByb3RvdHlwZSksIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgY29sbGVjdGlvbjogbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKClcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZSQyKGl0ZXJhYmxlLCB0YXJnZXRbQURERVJdLCB7XG4gICAgICAgIHRoYXQ6IHRhcmdldCxcbiAgICAgICAgQVNfRU5UUklFUzogSVNfTUFQXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQyKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIGZvckVhY2goWydhZGQnLCAnY2xlYXInLCAnZGVsZXRlJywgJ2ZvckVhY2gnLCAnZ2V0JywgJ2hhcycsICdzZXQnLCAna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcyddLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuXG4gICAgICBpZiAoS0VZIGluIE5hdGl2ZVByb3RvdHlwZSAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShQcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbjtcbiAgICAgICAgICBpZiAoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0JDQoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbltLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgSVNfV0VBSyB8fCBkZWZpbmVQcm9wZXJ0eSQxKFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZhbHNlLCB0cnVlKTtcbiAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAgJCRkKHtcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgZm9yY2VkOiB0cnVlXG4gIH0sIGV4cG9ydGVkKTtcbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59O1xuXG52YXIgcmVkZWZpbmUgPSByZWRlZmluZSQ0O1xuXG52YXIgcmVkZWZpbmVBbGwkMyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bnNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyQxID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbiQxKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyQxICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgY3JlYXRlJDQgPSBvYmplY3RDcmVhdGU7XG52YXIgcmVkZWZpbmVBbGwkMiA9IHJlZGVmaW5lQWxsJDM7XG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBhbkluc3RhbmNlJDEgPSBhbkluc3RhbmNlJDM7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQzO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMztcbnZhciBzZXRTcGVjaWVzID0gc2V0U3BlY2llcyQxO1xudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG52YXIgZmFzdEtleSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cy5mYXN0S2V5O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuZ2V0dGVyRm9yO1xudmFyIGNvbGxlY3Rpb25TdHJvbmckMiA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UkMSh0aGF0LCBQcm90b3R5cGUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaW5kZXg6IGNyZWF0ZSQ0KG51bGwpLFxuICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFERVNDUklQVE9SUykgdGhhdC5zaXplID0gMDtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUkMShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHtcbiAgICAgICAgdGhhdDogdGhhdCxcbiAgICAgICAgQVNfRU5UUklFUzogSVNfTUFQXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgIHZhciBwcmV2aW91cywgaW5kZXg7IC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTsgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdCA9IGVudHJ5ID0ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSsrO2Vsc2UgdGhhdC5zaXplKys7IC8vIGFkZCB0byBpbmRleFxuXG4gICAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSBzdGF0ZS5pbmRleFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7IC8vIGZhc3QgY2FzZVxuXG4gICAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTsgLy8gZnJvemVuIG9iamVjdCBjYXNlXG5cbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWRlZmluZUFsbCQyKFByb3RvdHlwZSwge1xuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuY2xlYXIoKWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcblxuICAgICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5sYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUgPSAwO2Vsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5kZWxldGUoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5pbmRleFtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucHJldmlvdXMgPSBwcmV2O1xuICAgICAgICAgIGlmIChzdGF0ZS5maXJzdCA9PSBlbnRyeSkgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09IGVudHJ5KSBzdGF0ZS5sYXN0ID0gcHJldjtcbiAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUtLTtlbHNlIHRoYXQuc2l6ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmZvcmVhY2hcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbiAgICAgIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqL1xuICAgICAgKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZCQyKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuXG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XG4gICAgICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTsgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0fS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5oYXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5oYXNcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsJDIoUHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZ2V0XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8vIGBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuc2V0XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyBgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5hZGRcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkoUHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCkge1xuICAgIHZhciBJVEVSQVRPUl9OQU1FID0gQ09OU1RSVUNUT1JfTkFNRSArICcgSXRlcmF0b3InO1xuICAgIHZhciBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKElURVJBVE9SX05BTUUpOyAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS57IGtleXMsIHZhbHVlcywgZW50cmllcywgQEBpdGVyYXRvciB9KClgIG1ldGhvZHNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmVudHJpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUua2V5c1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUtQEBpdGVyYXRvclxuXG4gICAgZGVmaW5lSXRlcmF0b3IoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0OyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7IC8vIGdldCBuZXh0IGVudHJ5XG5cblxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSAvLyByZXR1cm4gc3RlcCBieSBraW5kXG5cblxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZW50cnkua2V5LFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZW50cnkudmFsdWUsXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpOyAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1tYXAtQEBzcGVjaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfVxufTtcblxudmFyIGNvbGxlY3Rpb24kMiA9IGNvbGxlY3Rpb24kMztcbnZhciBjb2xsZWN0aW9uU3Ryb25nJDEgPSBjb2xsZWN0aW9uU3Ryb25nJDI7IC8vIGBNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC1vYmplY3RzXG5cbmNvbGxlY3Rpb24kMignTWFwJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmckMSk7XG5cbnZhciBwYXRoJGIgPSBwYXRoJHk7XG52YXIgbWFwJDIgPSBwYXRoJGIuTWFwO1xuXG52YXIgcGFyZW50JHYgPSBtYXAkMjtcbnZhciBtYXAkMSA9IHBhcmVudCR2O1xuXG52YXIgbWFwID0gbWFwJDE7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjYW4gc3RvcmUgZ3JvdXBzIGFuZCBvcHRpb25zIHNwZWNpZmljIGZvciBncm91cHMuXG4gKi9cbnZhciBHcm91cHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gR3JvdXBzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcm91cHMpO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuX2RlZmF1bHRJbmRleCA9IDA7XG4gICAgdGhpcy5fZ3JvdXBJbmRleCA9IDA7XG4gICAgdGhpcy5fZGVmYXVsdEdyb3VwcyA9IFt7XG4gICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgfVxuICAgIH0sIC8vIDA6IGJsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkZGRjAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkE1MDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZGRkEzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIlxuICAgICAgfVxuICAgIH0sIC8vIDE6IHllbGxvd1xuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkEwQTEwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGQjdFODFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZBMEExMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkFGQjFcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkEwQTEwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiXG4gICAgICB9XG4gICAgfSwgLy8gMjogcmVkXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzdCRTE0MVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ExRUM3NlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQTFFQzc2XCJcbiAgICAgIH1cbiAgICB9LCAvLyAzOiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNFQjdERjRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0UxMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGMEIzRjVcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiXG4gICAgICB9XG4gICAgfSwgLy8gNDogbWFnZW50YVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjN0MyOUYwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNBRDg1RTRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzdDMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEM0JERjBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjN0MyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiXG4gICAgICB9XG4gICAgfSwgLy8gNTogcHVycGxlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQTgwN1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQ0E2NlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZDQTY2XCJcbiAgICAgIH1cbiAgICB9LCAvLyA2OiBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjNkU2RUZEXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MjIwRkJcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOUI5QkZEXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIlxuICAgICAgfVxuICAgIH0sIC8vIDc6IGRhcmtibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRDVBNzdcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQzBDQlwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkQ1QTc3XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRDFEOVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRDVBNzdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCJcbiAgICAgIH1cbiAgICB9LCAvLyA4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0MyRkFCQ1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0U2RkZFM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRTZGRkUzXCJcbiAgICAgIH1cbiAgICB9LCAvLyA5OiBtaW50XG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM5OTAwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0VFMDAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjQkIwMDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMzMzM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCQjAwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYzMzMzXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxMDpicmlnaHQgcmVkXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkY2MDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxMjogcmVhbCBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzk3QzJGQ1wiLFxuICAgICAgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEMkU1RkZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0QyRTVGRlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIlxuICAgICAgfVxuICAgIH0sIC8vIDEzOiBibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjU1QzAzXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNDogZ3JlZW5cbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCNzAwNTRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIlxuICAgICAgfVxuICAgIH0sIC8vIDE1OiBtYWdlbnRhXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNBRDg1RTRcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDNCREYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEM0JERjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjN0MyOUYwXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNjogcHVycGxlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0NTU3RkFcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNkU2RUZEXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM2RTZFRkRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMDAwRUExXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNzogZGFya2JsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGQzBDQlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkQxRDlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGRDFEOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIlxuICAgICAgfVxuICAgIH0sIC8vIDE4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNDMkZBQkNcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTZGRkUzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFNkZGRTNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzRENjZBXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxOTogbWludFxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRUUwMDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM5OTAwMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGMzMzM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNCQjAwMDBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkYzMzMzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiXG4gICAgICB9XG4gICAgfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdXNlRGVmYXVsdEdyb3VwczogdHJ1ZVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhHcm91cHMsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9uRmllbGRzID0gW1widXNlRGVmYXVsdEdyb3Vwc1wiXTtcblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBncm91cE5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgaWYgKGluZGV4T2Yob3B0aW9uRmllbGRzKS5jYWxsKG9wdGlvbkZpZWxkcywgZ3JvdXBOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdmFyIGdyb3VwID0gb3B0aW9uc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICB0aGlzLmFkZChncm91cE5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyb3Vwc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLl9ncm91cHMgPSBuZXcgbWFwKCk7XG4gICAgICB0aGlzLl9ncm91cE5hbWVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBncm91cCBvcHRpb25zIG9mIGEgZ3JvdXBuYW1lLlxuICAgICAqIElmIGdyb3VwbmFtZSBpcyBub3QgZm91bmQsIGEgbmV3IGdyb3VwIG1heSBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBncm91cG5hbWUgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkQ3JlYXRlPXRydWVdIElmIHRydWUsIGNyZWF0ZSBhIG5ldyBncm91cFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBmb3VuZCBvciBjcmVhdGVkIGdyb3VwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGdyb3VwbmFtZSkge1xuICAgICAgdmFyIHNob3VsZENyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXBzLmdldChncm91cG5hbWUpO1xuXG4gICAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCAmJiBzaG91bGRDcmVhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VEZWZhdWx0R3JvdXBzID09PSBmYWxzZSAmJiB0aGlzLl9ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ3JvdXBJbmRleCAlIHRoaXMuX2dyb3VwTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICsrdGhpcy5fZ3JvdXBJbmRleDtcbiAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5fZ3JvdXBzLmdldCh0aGlzLl9ncm91cE5hbWVzW2luZGV4XSk7XG5cbiAgICAgICAgICB0aGlzLl9ncm91cHMuc2V0KGdyb3VwbmFtZSwgZ3JvdXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICB2YXIgX2luZGV4ID0gdGhpcy5fZGVmYXVsdEluZGV4ICUgdGhpcy5fZGVmYXVsdEdyb3Vwcy5sZW5ndGg7XG5cbiAgICAgICAgICB0aGlzLl9kZWZhdWx0SW5kZXgrKztcbiAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5fZGVmYXVsdEdyb3Vwc1tfaW5kZXhdO1xuXG4gICAgICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cG5hbWUsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZ3JvdXAgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwLCBhIG5ldyBncm91cCB3aWxsIGJlXG4gICAgICogY3JlYXRlZCBpZiBhIGdyb3VwIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0LCBvdGhlcndpc2UgdGhlIG9sZFxuICAgICAqIGdyb3VwcyBzdHlsZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZSAtIEFuIG9iamVjdCBjb250YWluaW5nIGJvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICogZXRjLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBjcmVhdGVkIGdyb3VwIG9iamVjdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZ3JvdXBOYW1lLCBzdHlsZSkge1xuICAgICAgLy8gT25seSBwdXNoIGdyb3VwIG5hbWUgb25jZSB0byBwcmV2ZW50IGR1cGxpY2F0ZXMgd2hpY2ggd291bGQgY29uc3VtZSBtb3JlXG4gICAgICAvLyBSQU0gYW5kIGFsc28gc2tldyB0aGUgZGlzdHJpYnV0aW9uIHRvd2FyZHMgbW9yZSBvZnRlbiB1cGRhdGVkIGdyb3VwcyxcbiAgICAgIC8vIG5laXRoZXIgb2Ygd2hpY2ggaXMgZGVzaXJhYmxlLlxuICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBOYW1lcy5wdXNoKGdyb3VwTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBOYW1lLCBzdHlsZSk7XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR3JvdXBzO1xufSgpO1xuXG52YXIgJCRjID0gX2V4cG9ydDsgLy8gYE51bWJlci5pc05hTmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc25hblxuXG4kJGMoe1xuICB0YXJnZXQ6ICdOdW1iZXInLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxudmFyIHBhdGgkYSA9IHBhdGgkeTtcbnZhciBpc05hbiQyID0gcGF0aCRhLk51bWJlci5pc05hTjtcblxudmFyIHBhcmVudCR1ID0gaXNOYW4kMjtcbnZhciBpc05hbiQxID0gcGFyZW50JHU7XG5cbnZhciBpc05hbiA9IGlzTmFuJDE7XG5cbnZhciBnbG9iYWwkNyA9IGdsb2JhbCRQO1xudmFyIGdsb2JhbElzRmluaXRlID0gZ2xvYmFsJDcuaXNGaW5pdGU7IC8vIGBOdW1iZXIuaXNGaW5pdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNmaW5pdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1udW1iZXItaXNmaW5pdGUgLS0gc2FmZVxuXG52YXIgbnVtYmVySXNGaW5pdGUkMSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIGdsb2JhbElzRmluaXRlKGl0KTtcbn07XG5cbnZhciAkJGIgPSBfZXhwb3J0O1xudmFyIG51bWJlcklzRmluaXRlID0gbnVtYmVySXNGaW5pdGUkMTsgLy8gYE51bWJlci5pc0Zpbml0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxuXG4kJGIoe1xuICB0YXJnZXQ6ICdOdW1iZXInLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIGlzRmluaXRlOiBudW1iZXJJc0Zpbml0ZVxufSk7XG5cbnZhciBwYXRoJDkgPSBwYXRoJHk7XG52YXIgX2lzRmluaXRlJDIgPSBwYXRoJDkuTnVtYmVyLmlzRmluaXRlO1xuXG52YXIgcGFyZW50JHQgPSBfaXNGaW5pdGUkMjtcbnZhciBfaXNGaW5pdGUkMSA9IHBhcmVudCR0O1xuXG52YXIgX2lzRmluaXRlID0gX2lzRmluaXRlJDE7XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyICRzb21lID0gYXJyYXlJdGVyYXRpb24uc29tZTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDMgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgU1RSSUNUX01FVEhPRCQzID0gYXJyYXlNZXRob2RJc1N0cmljdCQzKCdzb21lJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG5cbiQkYSh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIVNUUklDVF9NRVRIT0QkM1xufSwge1xuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDcgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBzb21lJDMgPSBlbnRyeVZpcnR1YWwkNygnQXJyYXknKS5zb21lO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ3ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNyA9IHNvbWUkMztcbnZhciBBcnJheVByb3RvdHlwZSQ3ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc29tZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zb21lO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDcgfHwgaXNQcm90b3R5cGVPZiQ3KEFycmF5UHJvdG90eXBlJDcsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDcuc29tZSA/IG1ldGhvZCQ3IDogb3duO1xufTtcblxudmFyIHBhcmVudCRzID0gc29tZSQyO1xudmFyIHNvbWUkMSA9IHBhcmVudCRzO1xuXG52YXIgc29tZSA9IHNvbWUkMTtcblxudmFyIGdsb2JhbCQ2ID0gZ2xvYmFsJFA7XG52YXIgaXNDb25zdHJ1Y3RvciA9IGlzQ29uc3RydWN0b3IkNDtcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgVHlwZUVycm9yJDMgPSBnbG9iYWwkNi5UeXBlRXJyb3I7IC8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG5cbnZhciBhQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yJDModHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyICQkOSA9IF9leHBvcnQ7XG52YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kOTtcbnZhciBhcHBseSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgYmluZCQxID0gZnVuY3Rpb25CaW5kO1xudmFyIGFDb25zdHJ1Y3RvciA9IGFDb25zdHJ1Y3RvciQxO1xudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRkO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCRqO1xudmFyIGNyZWF0ZSQzID0gb2JqZWN0Q3JlYXRlO1xudmFyIGZhaWxzJDMgPSBmYWlscyR0O1xudmFyIG5hdGl2ZUNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBwdXNoJDEgPSBbXS5wdXNoOyAvLyBgUmVmbGVjdC5jb25zdHJ1Y3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmNvbnN0cnVjdFxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG5cbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSk7XG59KTtcbnZhciBGT1JDRUQkMiA9IE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHO1xuJCQ5KHtcbiAgdGFyZ2V0OiAnUmVmbGVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRk9SQ0VEJDIsXG4gIHNoYW06IEZPUkNFRCQyXG59LCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJnc1xuICAvKiAsIG5ld1RhcmdldCAqL1xuICApIHtcbiAgICBhQ29uc3RydWN0b3IoVGFyZ2V0KTtcbiAgICBhbk9iamVjdCQyKGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFDb25zdHJ1Y3Rvcihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiBuYXRpdmVDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuXG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH0gLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcblxuXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICBhcHBseShwdXNoJDEsICRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGFwcGx5KGJpbmQkMSwgVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfSAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcblxuXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUkMyhpc09iamVjdCQzKHByb3RvKSA/IHByb3RvIDogT2JqZWN0UHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gYXBwbHkoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0JDMocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcblxudmFyIHBhdGgkOCA9IHBhdGgkeTtcbnZhciBjb25zdHJ1Y3QkMiA9IHBhdGgkOC5SZWZsZWN0LmNvbnN0cnVjdDtcblxudmFyIHBhcmVudCRyID0gY29uc3RydWN0JDI7XG52YXIgY29uc3RydWN0JDEgPSBwYXJlbnQkcjtcblxudmFyIGNvbnN0cnVjdCA9IGNvbnN0cnVjdCQxO1xuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG52YXIgcGFyZW50JHEgPSBjcmVhdGUkNjtcbnZhciBjcmVhdGUkMiA9IHBhcmVudCRxO1xuXG52YXIgcGFyZW50JHAgPSBjcmVhdGUkMjtcbnZhciBjcmVhdGUkMSA9IHBhcmVudCRwO1xuXG52YXIgY3JlYXRlID0gY3JlYXRlJDE7XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIHNldFByb3RvdHlwZU9mJDUgPSBvYmplY3RTZXRQcm90b3R5cGVPZjsgLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuXG4kJDgoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIHNldFByb3RvdHlwZU9mOiBzZXRQcm90b3R5cGVPZiQ1XG59KTtcblxudmFyIHBhdGgkNyA9IHBhdGgkeTtcbnZhciBzZXRQcm90b3R5cGVPZiQ0ID0gcGF0aCQ3Lk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxudmFyIHBhcmVudCRvID0gc2V0UHJvdG90eXBlT2YkNDtcbnZhciBzZXRQcm90b3R5cGVPZiQzID0gcGFyZW50JG87XG5cbnZhciBwYXJlbnQkbiA9IHNldFByb3RvdHlwZU9mJDM7XG52YXIgc2V0UHJvdG90eXBlT2YkMiA9IHBhcmVudCRuO1xuXG52YXIgcGFyZW50JG0gPSBzZXRQcm90b3R5cGVPZiQyO1xudmFyIHNldFByb3RvdHlwZU9mJDEgPSBwYXJlbnQkbTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YkMTtcblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgZGVmaW5lUHJvcGVydHkkMyhzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG52YXIgcGFyZW50JGwgPSBnZXRQcm90b3R5cGVPZiQ1O1xudmFyIGdldFByb3RvdHlwZU9mJDMgPSBwYXJlbnQkbDtcblxudmFyIHBhcmVudCRrID0gZ2V0UHJvdG90eXBlT2YkMztcbnZhciBnZXRQcm90b3R5cGVPZiQyID0gcGFyZW50JGs7XG5cbnZhciBnZXRQcm90b3R5cGVPZiQxID0gZ2V0UHJvdG90eXBlT2YkMjtcblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YgPyBnZXRQcm90b3R5cGVPZiQxIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgZ2V0UHJvdG90eXBlT2YkMShvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxudmFyIHJ1bnRpbWUgPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBydW50aW1lID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICAgIHZhciB1bmRlZmluZWQkMTsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG5cbiAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICAgIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gICAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgICBkZWZpbmUoe30sIFwiXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuXG4gICAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH1cblxuICAgIGV4cG9ydHMud3JhcCA9IHdyYXA7IC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAgIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAgIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAgIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gICAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAgIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gICAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gICAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAgIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cblxuICAgIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgICBhcmc6IGVyclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICAgIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gICAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjsgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAgIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cblxuICAgIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAgIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAgIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gICAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG5cbiAgICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuXG5cbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuXG4gICAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTsgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuXG4gICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICAgIH07XG5cbiAgICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICAgIHJldHVybiBnZW5GdW47XG4gICAgfTsgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gICAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cblxuXG4gICAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgICAgfSAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG5cblxuICAgICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgICB9XG5cbiAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICAgIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjsgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAgIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuXG4gICAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gICAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH0gLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG5cblxuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cblxuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gICAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAgIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAgIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuXG5cbiAgICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQkMSkge1xuICAgICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlOyAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG5cbiAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9IC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuXG5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAgIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cblxuXG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcbiAgICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTsgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAgIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gICAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICAgIH07XG5cbiAgICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICAgIH1dO1xuICAgICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXlzLnJldmVyc2UoKTsgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuXG5cbiAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQkMSxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIChza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICAgIHRoaXMubmV4dCA9IDA7IC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG5cbiAgICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gKGZpbmFsbHlMb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJjYXRjaFwiOiBmdW5jdGlvbiAodHJ5TG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG5cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgICB9LFxuICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cbiAgICB9OyAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gICAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gICAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gICAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cblxuICAgIHJldHVybiBleHBvcnRzO1xuICB9KCAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIG1vZHVsZS5leHBvcnRzICk7XG5cbiAgdHJ5IHtcbiAgICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAgIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gICAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gICAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAgIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAgIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gICAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gICAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gICAgfVxuICB9XG59KShydW50aW1lKTtcblxudmFyIHJlZ2VuZXJhdG9yID0gcnVudGltZS5leHBvcnRzO1xuXG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkUDtcbnZhciBhQ2FsbGFibGUkMiA9IGFDYWxsYWJsZSQ3O1xudmFyIHRvT2JqZWN0JDIgPSB0b09iamVjdCRlO1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJDUuVHlwZUVycm9yOyAvLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhQ2FsbGFibGUkMihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDIodGhhdCk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IGk7XG5cbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IkMignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xuXG52YXIgYXJyYXlSZWR1Y2UgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJFA7XG52YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZiQzKGdsb2JhbCQ0LnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxudmFyICQkNyA9IF9leHBvcnQ7XG52YXIgJHJlZHVjZSA9IGFycmF5UmVkdWNlLmxlZnQ7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQyID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIENIUk9NRV9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgU1RSSUNUX01FVEhPRCQyID0gYXJyYXlNZXRob2RJc1N0cmljdCQyKCdyZWR1Y2UnKTsgLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0OTk4MlxuXG52YXIgQ0hST01FX0JVRyA9ICFJU19OT0RFICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MzsgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG5cbiQkNyh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIVNUUklDVF9NRVRIT0QkMiB8fCBDSFJPTUVfQlVHXG59LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm5cbiAgLyogLCBpbml0aWFsVmFsdWUgKi9cbiAgKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgbGVuZ3RoLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkNiA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHJlZHVjZSQzID0gZW50cnlWaXJ0dWFsJDYoJ0FycmF5JykucmVkdWNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ2ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNiA9IHJlZHVjZSQzO1xudmFyIEFycmF5UHJvdG90eXBlJDYgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciByZWR1Y2UkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQucmVkdWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDYgfHwgaXNQcm90b3R5cGVPZiQ2KEFycmF5UHJvdG90eXBlJDYsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDYucmVkdWNlID8gbWV0aG9kJDYgOiBvd247XG59O1xuXG52YXIgcGFyZW50JGogPSByZWR1Y2UkMjtcbnZhciByZWR1Y2UkMSA9IHBhcmVudCRqO1xuXG52YXIgcmVkdWNlID0gcmVkdWNlJDE7XG5cbnZhciBnbG9iYWwkMyA9IGdsb2JhbCRQO1xudmFyIGlzQXJyYXkgPSBpc0FycmF5JGQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgYmluZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkMy5UeXBlRXJyb3I7IC8vIGBGbGF0dGVuSW50b0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcblxudmFyIGZsYXR0ZW5JbnRvQXJyYXkkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9yaWdpbmFsLCBzb3VyY2UsIHNvdXJjZUxlbiwgc3RhcnQsIGRlcHRoLCBtYXBwZXIsIHRoaXNBcmcpIHtcbiAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG4gIHZhciBtYXBGbiA9IG1hcHBlciA/IGJpbmQobWFwcGVyLCB0aGlzQXJnKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudCwgZWxlbWVudExlbjtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgaWYgKGRlcHRoID4gMCAmJiBpc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnRMZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQyKGVsZW1lbnQpO1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkkMSh0YXJnZXQsIG9yaWdpbmFsLCBlbGVtZW50LCBlbGVtZW50TGVuLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxRkZGRkZGRkZGRkZGRikgdGhyb3cgVHlwZUVycm9yJDEoJ0V4Y2VlZCB0aGUgYWNjZXB0YWJsZSBhcnJheSBsZW5ndGgnKTtcbiAgICAgICAgdGFyZ2V0W3RhcmdldEluZGV4XSA9IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEluZGV4Kys7XG4gICAgfVxuXG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn07XG5cbnZhciBmbGF0dGVuSW50b0FycmF5XzEgPSBmbGF0dGVuSW50b0FycmF5JDE7XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSBmbGF0dGVuSW50b0FycmF5XzE7XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkNztcbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQxID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBhcnJheVNwZWNpZXNDcmVhdGUkNDsgLy8gYEFycmF5LnByb3RvdHlwZS5mbGF0TWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZsYXRtYXBcblxuJCQ2KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZVxufSwge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHZhciBPID0gdG9PYmplY3QkMSh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShPKTtcbiAgICB2YXIgQTtcbiAgICBhQ2FsbGFibGUkMShjYWxsYmFja2ZuKTtcbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIEEubGVuZ3RoID0gZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkNSA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGZsYXRNYXAkMyA9IGVudHJ5VmlydHVhbCQ1KCdBcnJheScpLmZsYXRNYXA7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDUgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ1ID0gZmxhdE1hcCQzO1xudmFyIEFycmF5UHJvdG90eXBlJDUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBmbGF0TWFwJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZsYXRNYXA7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNSB8fCBpc1Byb3RvdHlwZU9mJDUoQXJyYXlQcm90b3R5cGUkNSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNS5mbGF0TWFwID8gbWV0aG9kJDUgOiBvd247XG59O1xuXG52YXIgcGFyZW50JGkgPSBmbGF0TWFwJDI7XG52YXIgZmxhdE1hcCQxID0gcGFyZW50JGk7XG5cbnZhciBmbGF0TWFwID0gZmxhdE1hcCQxO1xuXG52YXIgY29sbGVjdGlvbiQxID0gY29sbGVjdGlvbiQzO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSBjb2xsZWN0aW9uU3Ryb25nJDI7IC8vIGBTZXRgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXG5cbmNvbGxlY3Rpb24kMSgnU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuXG52YXIgcGF0aCQ2ID0gcGF0aCR5O1xudmFyIHNldCQyID0gcGF0aCQ2LlNldDtcblxudmFyIHBhcmVudCRoID0gc2V0JDI7XG52YXIgc2V0JDEgPSBwYXJlbnQkaDtcblxudmFyIHNldCA9IHNldCQxO1xuXG52YXIgaXRlcmF0b3IgPSBpdGVyYXRvciQ0O1xuXG52YXIgZ2V0SXRlcmF0b3IkNCA9IGdldEl0ZXJhdG9yJDc7XG52YXIgZ2V0SXRlcmF0b3JfMSA9IGdldEl0ZXJhdG9yJDQ7XG5cbnZhciBwYXJlbnQkZyA9IGdldEl0ZXJhdG9yXzE7XG52YXIgZ2V0SXRlcmF0b3IkMyA9IHBhcmVudCRnO1xuXG52YXIgcGFyZW50JGYgPSBnZXRJdGVyYXRvciQzO1xudmFyIGdldEl0ZXJhdG9yJDIgPSBwYXJlbnQkZjtcblxudmFyIHBhcmVudCRlID0gZ2V0SXRlcmF0b3IkMjtcbnZhciBnZXRJdGVyYXRvciQxID0gcGFyZW50JGU7XG5cbnZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDE7XG5cbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKGFycmF5LCBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSwgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbiksIGNvbXBhcmVmbik7XG59O1xuXG52YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBpID0gMTtcbiAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBqID0gaTtcbiAgICBlbGVtZW50ID0gYXJyYXlbaV07XG5cbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG5cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAoYXJyYXksIGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcblxuICB3aGlsZSAobGluZGV4IDwgbGxlbmd0aCB8fCByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgYXJyYXlbbGluZGV4ICsgcmluZGV4XSA9IGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aCA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXSA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheVNvcnQgPSBtZXJnZVNvcnQ7XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBmaXJlZm94ID0gdXNlckFnZW50JDEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XG52YXIgZW5naW5lRmZWZXJzaW9uID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG52YXIgVUEgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgZW5naW5lSXNJZU9yRWRnZSA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xudmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcbnZhciBlbmdpbmVXZWJraXRWZXJzaW9uID0gISF3ZWJraXQgJiYgK3dlYmtpdFsxXTtcblxudmFyICQkNSA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkMyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDc7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCRlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckODtcbnZhciBmYWlscyQyID0gZmFpbHMkdDtcbnZhciBpbnRlcm5hbFNvcnQgPSBhcnJheVNvcnQ7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQxID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIEZGID0gZW5naW5lRmZWZXJzaW9uO1xudmFyIElFX09SX0VER0UgPSBlbmdpbmVJc0llT3JFZGdlO1xudmFyIFY4ID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIFdFQktJVCA9IGVuZ2luZVdlYmtpdFZlcnNpb247XG52YXIgdGVzdCA9IFtdO1xudmFyIHVuJFNvcnQgPSB1bmN1cnJ5VGhpcyQzKHRlc3Quc29ydCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzJDModGVzdC5wdXNoKTsgLy8gSUU4LVxuXG52YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7IC8vIFY4IGJ1Z1xuXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTsgLy8gT2xkIFdlYktpdFxuXG52YXIgU1RSSUNUX01FVEhPRCQxID0gYXJyYXlNZXRob2RJc1N0cmljdCQxKCdzb3J0Jyk7XG52YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIGNhbiBiZSB0b28gc2xvdywgc28gY2hlY2sgZW5naW5lcyB2ZXJzaW9uc1xuICBpZiAoVjgpIHJldHVybiBWOCA8IDcwO1xuICBpZiAoRkYgJiYgRkYgPiAzKSByZXR1cm47XG4gIGlmIChJRV9PUl9FREdFKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFdFQktJVCkgcmV0dXJuIFdFQktJVCA8IDYwMztcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7IC8vIGdlbmVyYXRlIGFuIGFycmF5IHdpdGggbW9yZSA1MTIgZWxlbWVudHMgKENoYWtyYSBhbmQgb2xkIFY4IGZhaWxzIG9ubHkgaW4gdGhpcyBjYXNlKVxuXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6XG4gICAgICBjYXNlIDY5OlxuICAgICAgY2FzZSA3MDpcbiAgICAgIGNhc2UgNzI6XG4gICAgICAgIHZhbHVlID0gMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjg6XG4gICAgICBjYXNlIDcxOlxuICAgICAgICB2YWx1ZSA9IDQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YWx1ZSA9IDI7XG4gICAgfVxuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDc7IGluZGV4KyspIHtcbiAgICAgIHRlc3QucHVzaCh7XG4gICAgICAgIGs6IGNociArIGluZGV4LFxuICAgICAgICB2OiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudiAtIGEudjtcbiAgfSk7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGVzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjaHIgPSB0ZXN0W2luZGV4XS5rLmNoYXJBdCgwKTtcbiAgICBpZiAocmVzdWx0LmNoYXJBdChyZXN1bHQubGVuZ3RoIC0gMSkgIT09IGNocikgcmVzdWx0ICs9IGNocjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgIT09ICdER0JFRkhBQ0lKSyc7XG59KTtcbnZhciBGT1JDRUQkMSA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCAhU1RSSUNUX01FVEhPRCQxIHx8ICFTVEFCTEVfU09SVDtcblxudmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gK2NvbXBhcmVmbih4LCB5KSB8fCAwO1xuICAgIHJldHVybiB0b1N0cmluZyQxKHgpID4gdG9TdHJpbmckMSh5KSA/IDEgOiAtMTtcbiAgfTtcbn07IC8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG5cblxuJCQ1KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBGT1JDRUQkMVxufSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlKGNvbXBhcmVmbik7XG4gICAgdmFyIGFycmF5ID0gdG9PYmplY3QodGhpcyk7XG4gICAgaWYgKFNUQUJMRV9TT1JUKSByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWQgPyB1biRTb3J0KGFycmF5KSA6IHVuJFNvcnQoYXJyYXksIGNvbXBhcmVmbik7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIGFycmF5TGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoYXJyYXkpO1xuICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGluZGV4IGluIGFycmF5KSBwdXNoKGl0ZW1zLCBhcnJheVtpbmRleF0pO1xuICAgIH1cblxuICAgIGludGVybmFsU29ydChpdGVtcywgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG4gICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgaXRlbXNMZW5ndGgpIGFycmF5W2luZGV4XSA9IGl0ZW1zW2luZGV4KytdO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgYXJyYXlMZW5ndGgpIGRlbGV0ZSBhcnJheVtpbmRleCsrXTtcblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkNCA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHNvcnQkMyA9IGVudHJ5VmlydHVhbCQ0KCdBcnJheScpLnNvcnQ7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ0ID0gc29ydCQzO1xudmFyIEFycmF5UHJvdG90eXBlJDQgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzb3J0JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvcnQ7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNCB8fCBpc1Byb3RvdHlwZU9mJDQoQXJyYXlQcm90b3R5cGUkNCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNC5zb3J0ID8gbWV0aG9kJDQgOiBvd247XG59O1xuXG52YXIgcGFyZW50JGQgPSBzb3J0JDI7XG52YXIgc29ydCQxID0gcGFyZW50JGQ7XG5cbnZhciBzb3J0ID0gc29ydCQxO1xuXG52YXIgZW50cnlWaXJ0dWFsJDMgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBrZXlzJDMgPSBlbnRyeVZpcnR1YWwkMygnQXJyYXknKS5rZXlzO1xuXG52YXIgcGFyZW50JGMgPSBrZXlzJDM7XG52YXIga2V5cyQyID0gcGFyZW50JGM7XG5cbnZhciBjbGFzc29mJDIgPSBjbGFzc29mJGU7XG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkMyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDMgPSBrZXlzJDI7XG52YXIgQXJyYXlQcm90b3R5cGUkMyA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBET01JdGVyYWJsZXMkMiA9IHtcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBOb2RlTGlzdDogdHJ1ZVxufTtcblxudmFyIGtleXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQua2V5cztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQzIHx8IGlzUHJvdG90eXBlT2YkMyhBcnJheVByb3RvdHlwZSQzLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQzLmtleXMgfHwgaGFzT3duJDQoRE9NSXRlcmFibGVzJDIsIGNsYXNzb2YkMihpdCkpID8gbWV0aG9kJDMgOiBvd247XG59O1xuXG52YXIga2V5cyA9IGtleXMkMTtcblxudmFyIGVudHJ5VmlydHVhbCQyID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgdmFsdWVzJDMgPSBlbnRyeVZpcnR1YWwkMignQXJyYXknKS52YWx1ZXM7XG5cbnZhciBwYXJlbnQkYiA9IHZhbHVlcyQzO1xudmFyIHZhbHVlcyQyID0gcGFyZW50JGI7XG5cbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJGU7XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkMiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDIgPSB2YWx1ZXMkMjtcbnZhciBBcnJheVByb3RvdHlwZSQyID0gQXJyYXkucHJvdG90eXBlO1xudmFyIERPTUl0ZXJhYmxlcyQxID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIgdmFsdWVzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnZhbHVlcztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQyIHx8IGlzUHJvdG90eXBlT2YkMihBcnJheVByb3RvdHlwZSQyLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQyLnZhbHVlcyB8fCBoYXNPd24kMyhET01JdGVyYWJsZXMkMSwgY2xhc3NvZiQxKGl0KSkgPyBtZXRob2QkMiA6IG93bjtcbn07XG5cbnZhciB2YWx1ZXMgPSB2YWx1ZXMkMTtcblxudmFyIGVudHJ5VmlydHVhbCQxID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgZW50cmllcyQzID0gZW50cnlWaXJ0dWFsJDEoJ0FycmF5JykuZW50cmllcztcblxudmFyIHBhcmVudCRhID0gZW50cmllcyQzO1xudmFyIGVudHJpZXMkMiA9IHBhcmVudCRhO1xuXG52YXIgY2xhc3NvZiA9IGNsYXNzb2YkZTtcbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkMSA9IGVudHJpZXMkMjtcbnZhciBBcnJheVByb3RvdHlwZSQxID0gQXJyYXkucHJvdG90eXBlO1xudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBOb2RlTGlzdDogdHJ1ZVxufTtcblxudmFyIGVudHJpZXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZW50cmllcztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQxIHx8IGlzUHJvdG90eXBlT2YkMShBcnJheVByb3RvdHlwZSQxLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQxLmVudHJpZXMgfHwgaGFzT3duJDIoRE9NSXRlcmFibGVzLCBjbGFzc29mKGl0KSkgPyBtZXRob2QkMSA6IG93bjtcbn07XG5cbnZhciBlbnRyaWVzID0gZW50cmllcyQxO1xuXG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59XG5cbnZhciBSRUdFWCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDsgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG5cbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG52YXIgX1N5bWJvbCRpdGVyYXRvcjtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDQob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IGZpbHRlcihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBfY29udGV4dDMyLCBfY29udGV4dDMzOyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBmb3JFYWNoJDIoX2NvbnRleHQzMiA9IG93bktleXMkNChPYmplY3Qoc291cmNlKSwgITApKS5jYWxsKF9jb250ZXh0MzIsIGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogZm9yRWFjaCQyKF9jb250ZXh0MzMgPSBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0MzMsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkdChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MzE7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQzMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDMxLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDcoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcclxuICogQ3JlYXRlIG5ldyBkYXRhIHBpcGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBmcm9tIC0gVGhlIHNvdXJjZSBkYXRhIHNldCBvciBkYXRhIHZpZXcuXHJcbiAqIEByZW1hcmtzXHJcbiAqIEV4YW1wbGUgdXNhZ2U6XHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW50ZXJmYWNlIEFwcEl0ZW0ge1xyXG4gKiAgIHdob2FtaTogc3RyaW5nO1xyXG4gKiAgIGFwcERhdGE6IHVua25vd247XHJcbiAqICAgdmlzRGF0YTogVmlzSXRlbTtcclxuICogfVxyXG4gKiBpbnRlcmZhY2UgVmlzSXRlbSB7XHJcbiAqICAgaWQ6IG51bWJlcjtcclxuICogICBsYWJlbDogc3RyaW5nO1xyXG4gKiAgIGNvbG9yOiBzdHJpbmc7XHJcbiAqICAgeDogbnVtYmVyO1xyXG4gKiAgIHk6IG51bWJlcjtcclxuICogfVxyXG4gKlxyXG4gKiBjb25zdCBkczEgPSBuZXcgRGF0YVNldDxBcHBJdGVtLCBcIndob2FtaVwiPihbXSwgeyBmaWVsZElkOiBcIndob2FtaVwiIH0pO1xyXG4gKiBjb25zdCBkczIgPSBuZXcgRGF0YVNldDxWaXNJdGVtLCBcImlkXCI+KCk7XHJcbiAqXHJcbiAqIGNvbnN0IHBpcGUgPSBjcmVhdGVOZXdEYXRhUGlwZUZyb20oZHMxKVxyXG4gKiAgIC5maWx0ZXIoKGl0ZW0pOiBib29sZWFuID0+IGl0ZW0uZW5hYmxlZCA9PT0gdHJ1ZSlcclxuICogICAubWFwPFZpc0l0ZW0sIFwiaWRcIj4oKGl0ZW0pOiBWaXNJdGVtID0+IGl0ZW0udmlzRGF0YSlcclxuICogICAudG8oZHMyKTtcclxuICpcclxuICogcGlwZS5zdGFydCgpO1xyXG4gKiBgYGBcclxuICogQHJldHVybnMgQSBmYWN0b3J5IHdob3NlIG1ldGhvZHMgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBwaXBlLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTmV3RGF0YVBpcGVGcm9tKGZyb20pIHtcbiAgcmV0dXJuIG5ldyBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uKGZyb20pO1xufVxuLyoqXHJcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwaXBlLiBUaGlzIHNob3VsZCBiZSBhY2Nlc3NpYmxlIG9ubHkgdGhyb3VnaFxyXG4gKiBgY3JlYXRlTmV3RGF0YVBpcGVGcm9tYCBmcm9tIHRoZSBvdXRzaWRlLlxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIFNJIC0gU291cmNlIGl0ZW0gdHlwZS5cclxuICogQHR5cGVQYXJhbSBTUCAtIFNvdXJjZSBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICogQHR5cGVQYXJhbSBUUCAtIFRhcmdldCBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gKi9cblxuXG52YXIgU2ltcGxlRGF0YVBpcGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBCb3VuZCBsaXN0ZW5lcnMgZm9yIHVzZSB3aXRoIGBEYXRhSW50ZXJmYWNlWydvbicgfCAnb2ZmJ11gLlxyXG4gICAqL1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhIHBpcGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gX3NvdXJjZSAtIFRoZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgdGhhdCB3aWxsIGJlIG9ic2VydmVkLlxyXG4gICAqIEBwYXJhbSBfdHJhbnNmb3JtZXJzIC0gQW4gYXJyYXkgb2YgdHJhbnNmb3JtaW5nIGZ1bmN0aW9ucyB0byBiZSB1c2VkIHRvXHJcbiAgICogZmlsdGVyIG9yIHRyYW5zZm9ybSB0aGUgaXRlbXMgaW4gdGhlIHBpcGUuXHJcbiAgICogQHBhcmFtIF90YXJnZXQgLSBUaGUgZGF0YSBzZXQgb3IgZGF0YSB2aWV3IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBpdGVtcy5cclxuICAgKi9cbiAgZnVuY3Rpb24gU2ltcGxlRGF0YVBpcGUoX3NvdXJjZSwgX3RyYW5zZm9ybWVycywgX3RhcmdldCkge1xuICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyLCBfY29udGV4dDM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlRGF0YVBpcGUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NvdXJjZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RyYW5zZm9ybWVyc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xpc3RlbmVyc1wiLCB7XG4gICAgICBhZGQ6IGJpbmQkNihfY29udGV4dCA9IHRoaXMuX2FkZCkuY2FsbChfY29udGV4dCwgdGhpcyksXG4gICAgICByZW1vdmU6IGJpbmQkNihfY29udGV4dDIgPSB0aGlzLl9yZW1vdmUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSxcbiAgICAgIHVwZGF0ZTogYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMuX3VwZGF0ZSkuY2FsbChfY29udGV4dDMsIHRoaXMpXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zb3VyY2UgPSBfc291cmNlO1xuICAgIHRoaXMuX3RyYW5zZm9ybWVycyA9IF90cmFuc2Zvcm1lcnM7XG4gICAgdGhpcy5fdGFyZ2V0ID0gX3RhcmdldDtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTaW1wbGVEYXRhUGlwZSwgW3tcbiAgICBrZXk6IFwiYWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFsbCgpIHtcbiAgICAgIHRoaXMuX3RhcmdldC51cGRhdGUodGhpcy5fdHJhbnNmb3JtSXRlbXModGhpcy5fc291cmNlLmdldCgpKSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5fc291cmNlLm9uKFwiYWRkXCIsIHRoaXMuX2xpc3RlbmVycy5hZGQpO1xuXG4gICAgICB0aGlzLl9zb3VyY2Uub24oXCJyZW1vdmVcIiwgdGhpcy5fbGlzdGVuZXJzLnJlbW92ZSk7XG5cbiAgICAgIHRoaXMuX3NvdXJjZS5vbihcInVwZGF0ZVwiLCB0aGlzLl9saXN0ZW5lcnMudXBkYXRlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5fc291cmNlLm9mZihcImFkZFwiLCB0aGlzLl9saXN0ZW5lcnMuYWRkKTtcblxuICAgICAgdGhpcy5fc291cmNlLm9mZihcInJlbW92ZVwiLCB0aGlzLl9saXN0ZW5lcnMucmVtb3ZlKTtcblxuICAgICAgdGhpcy5fc291cmNlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9saXN0ZW5lcnMudXBkYXRlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdGhlIHRyYW5zZm9ybWVycyB0byB0aGUgaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIGl0ZW1zIHRvIGJlIHRyYW5zZm9ybWVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zZm9ybWVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdHJhbnNmb3JtSXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybUl0ZW1zKGl0ZW1zKSB7XG4gICAgICB2YXIgX2NvbnRleHQ0O1xuXG4gICAgICByZXR1cm4gcmVkdWNlKF9jb250ZXh0NCA9IHRoaXMuX3RyYW5zZm9ybWVycykuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChpdGVtcywgdHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0oaXRlbXMpO1xuICAgICAgfSwgaXRlbXMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBhbiBhZGQgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIF9uYW1lIC0gSWdub3JlZC5cclxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkKF9uYW1lLCBwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGFyZ2V0LmFkZCh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KHBheWxvYWQuaXRlbXMpKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGFuIHVwZGF0ZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgLSBJZ25vcmVkLlxyXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgcGF5bG9hZCBjb250YWluaW5nIHRoZSBpZHMgb2YgdGhlIHVwZGF0ZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShfbmFtZSwgcGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RhcmdldC51cGRhdGUodGhpcy5fdHJhbnNmb3JtSXRlbXModGhpcy5fc291cmNlLmdldChwYXlsb2FkLml0ZW1zKSkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBhIHJlbW92ZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgLSBJZ25vcmVkLlxyXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgcGF5bG9hZCBjb250YWluaW5nIHRoZSBkYXRhIG9mIHRoZSByZW1vdmVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmUoX25hbWUsIHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90YXJnZXQucmVtb3ZlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHBheWxvYWQub2xkRGF0YSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaW1wbGVEYXRhUGlwZTtcbn0oKTtcbi8qKlxyXG4gKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcGlwZSBmYWN0b3J5LiBUaGlzIHNob3VsZCBiZSBhY2Nlc3NpYmxlXHJcbiAqIG9ubHkgdGhyb3VnaCBgY3JlYXRlTmV3RGF0YVBpcGVGcm9tYCBmcm9tIHRoZSBvdXRzaWRlLlxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICogQHR5cGVQYXJhbSBUUCAtIFRhcmdldCBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxyXG4gKi9cblxuXG52YXIgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEFycmF5IHRyYW5zZm9ybWVycyB1c2VkIHRvIHRyYW5zZm9ybSBpdGVtcyB3aXRoaW4gdGhlIHBpcGUuIFRoaXMgaXMgdHlwZWRcclxuICAgKiBhcyBhbnkgZm9yIHRoZSBzYWtlIG9mIHNpbXBsaWNpdHkuXHJcbiAgICovXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGEgcGlwZSBmYWN0b3J5LiBUaGlzIGlzIGFuIGludGVybmFsIGNvbnN0cnVjdG9yIHRoYXRcclxuICAgKiBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGZyb20gb3V0c2lkZSBvZiB0aGlzIGZpbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gX3NvdXJjZSAtIFRoZSBzb3VyY2UgZGF0YSBzZXQgb3IgZGF0YSB2aWV3IGZvciB0aGlzIHBpcGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24oX3NvdXJjZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zb3VyY2VcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmFuc2Zvcm1lcnNcIiwgW10pO1xuXG4gICAgdGhpcy5fc291cmNlID0gX3NvdXJjZTtcbiAgfVxuICAvKipcclxuICAgKiBGaWx0ZXIgdGhlIGl0ZW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmaWx0ZXJpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgZ2l2ZW4gaXRlbVxyXG4gICAqIHNob3VsZCBiZSBwaXBlZCBhbmQgZmFsc2UgaWYgbm90LlxyXG4gICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24sIFt7XG4gICAga2V5OiBcImZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIkMShjYWxsYmFjaykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoaW5wdXQpLmNhbGwoaW5wdXQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBNYXAgZWFjaCBzb3VyY2UgaXRlbSB0byBhIG5ldyB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc291cmNlIGl0ZW0gYW5kIHJldHVybnNcclxuICAgICAqIGNvcnJlc3BvbmRpbmcgbWFwcGVkIGl0ZW0uXHJcbiAgICAgKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICAgICAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICAgICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1lcnMucHVzaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG1hcCQzKGlucHV0KS5jYWxsKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTWFwIGVhY2ggc291cmNlIGl0ZW0gdG8gemVybyBvciBtb3JlIGl0ZW1zIG9mIGEgbmV3IHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBtYXBwaW5nIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzb3VyY2UgaXRlbSBhbmQgcmV0dXJuc1xyXG4gICAgICogYW4gYXJyYXkgb2YgY29ycmVzcG9uZGluZyBtYXBwZWQgaXRlbXMuXHJcbiAgICAgKiBAdHlwZVBhcmFtIFRJIC0gVGFyZ2V0IGl0ZW0gdHlwZS5cclxuICAgICAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICAgICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmbGF0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXRNYXAkMShjYWxsYmFjaykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBmbGF0TWFwKGlucHV0KS5jYWxsKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdCB0aGlzIHBpcGUgdG8gZ2l2ZW4gZGF0YSBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBkYXRhIHNldCB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgaXRlbXMgZnJvbSB0aGlzIHBpcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcGlwZSBjb25uZWN0ZWQgYmV0d2VlbiBnaXZlbiBkYXRhIHNldHMgYW5kIHBlcmZvcm1pbmdcclxuICAgICAqIGNvbmZpZ3VyZWQgdHJhbnNmb3JtYXRpb24gb24gdGhlIHByb2Nlc3NlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG8odGFyZ2V0KSB7XG4gICAgICByZXR1cm4gbmV3IFNpbXBsZURhdGFQaXBlKHRoaXMuX3NvdXJjZSwgdGhpcy5fdHJhbnNmb3JtZXJzLCB0YXJnZXQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uO1xufSgpO1xuLyoqXHJcbiAqIERldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdmFsaWQgaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNJZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKlxyXG4gKiBBIHF1ZXVlLlxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIFQgLSBUaGUgdHlwZSBvZiBtZXRob2QgbmFtZXMgdG8gYmUgcmVwbGFjZWQgYnkgcXVldWVkIHZlcnNpb25zLlxyXG4gKi9cblxuXG52YXIgUXVldWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKiogRGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBJZiBkZWZpbmVkIHRoZSBxdWV1ZSB3aWxsIGJlIHBlcmlvZGljYWxseSBmbHVzaGVkLiAqL1xuXG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBxdWV1ZSBiZWZvcmUgaXQgd2lsbCBiZSBmbHVzaGVkLiAqL1xuXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBRdWV1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUXVldWUgY29uZmlndXJhdGlvbi5cclxuICAgKi9cbiAgZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWV1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWxheVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcXVldWVcIiwgW10pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RpbWVvdXRcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZXh0ZW5kZWRcIiwgbnVsbCk7XG5cbiAgICAvLyBvcHRpb25zXG4gICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgdGhpcy5tYXggPSBJbmZpbml0eTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBxdWV1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUXVldWUgY29uZmlndXJhdGlvbi5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhRdWV1ZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgKiBUaGUgb2JqZWN0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBhIGZ1bmN0aW9uIGZsdXNoLCBhbmQgdGhlIG1ldGhvZHMgcHJvdmlkZWQgaW4gb3B0aW9ucy5yZXBsYWNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcXVldWUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIHF1ZXVlLiBUaGUgcXVldWUgd2lsbCBmaXJzdCBmbHVzaCBhbGwgcXVldWVkIGFjdGlvbnMsIGFuZCBpbiBjYXNlIGl0IGhhcyBleHRlbmRlZCBhbiBvYmplY3QsIHdpbGwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZmx1c2goKTtcblxuICAgICAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9leHRlbmRlZC5vYmplY3Q7XG4gICAgICAgIHZhciBtZXRob2RzID0gdGhpcy5fZXh0ZW5kZWQubWV0aG9kcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcblxuICAgICAgICAgIGlmIChtZXRob2Qub3JpZ2luYWwpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBiZXR0ZXIgc29sdXRpb24/XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kLm5hbWVdID0gbWV0aG9kLm9yaWdpbmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgZGVsZXRlIG9iamVjdFttZXRob2QubmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlcGxhY2UgYSBtZXRob2Qgb24gYW4gb2JqZWN0IHdpdGggYSBxdWV1ZWQgdmVyc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IGhhdmluZyB0aGUgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgbmFtZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKG9iamVjdCwgbWV0aG9kKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMgLS0gRnVuY3Rpb24gdGhpcyBpcyBuZWNlc3NhcnkgaW4gdGhlIGZ1bmN0aW9uIGJlbGxvdywgc28gY2xhc3MgdGhpcyBoYXMgdG8gYmUgc2F2ZWQgaW50byBhIHZhcmlhYmxlIGhlcmUuICovXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIG9yaWdpbmFsID0gb2JqZWN0W21ldGhvZF07XG5cbiAgICAgIGlmICghb3JpZ2luYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIFwiICsgbWV0aG9kICsgXCIgdW5kZWZpbmVkXCIpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGlzIGNhbGwgdG8gdGhlIHF1ZXVlXG4gICAgICAgIG1lLnF1ZXVlKHtcbiAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgIGZuOiBvcmlnaW5hbCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZSBhIGNhbGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudHJ5IC0gVGhlIGZ1bmN0aW9uIG9yIGVudHJ5IHRvIGJlIHF1ZXVlZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcXVldWUoZW50cnkpIHtcbiAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBmbjogZW50cnlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9mbHVzaElmTmVlZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mbHVzaElmTmVlZGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gZmx1c2ggd2hlbiB0aGUgbWF4aW11bSBpcyBleGNlZWRlZC5cbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICB9IC8vIGZsdXNoIGFmdGVyIGEgcGVyaW9kIG9mIGluYWN0aXZpdHkgd2hlbiBhIGRlbGF5IGlzIGNvbmZpZ3VyZWRcblxuXG4gICAgICBpZiAodGhpcy5fdGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHRoaXMuZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZmx1c2goKTtcbiAgICAgICAgfSwgdGhpcy5kZWxheSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmx1c2ggYWxsIHF1ZXVlZCBjYWxsc1xyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciBfY29udGV4dDUsIF9jb250ZXh0NjtcblxuICAgICAgZm9yRWFjaCQyKF9jb250ZXh0NSA9IHNwbGljZSQxKF9jb250ZXh0NiA9IHRoaXMuX3F1ZXVlKS5jYWxsKF9jb250ZXh0NiwgMCkpLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKG9wdGlvbnMpO1xuXG4gICAgICBpZiAob2JqZWN0LmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoXCIpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHF1ZXVlLmZsdXNoKCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWV0aG9kcyA9IFt7XG4gICAgICAgIG5hbWU6IFwiZmx1c2hcIixcbiAgICAgICAgb3JpZ2luYWw6IHVuZGVmaW5lZFxuICAgICAgfV07XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucmVwbGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5yZXBsYWNlW2ldO1xuICAgICAgICAgIG1ldGhvZHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cbiAgICAgICAgICAgIG9yaWdpbmFsOiBvYmplY3RbbmFtZV1cbiAgICAgICAgICB9KTsgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cblxuICAgICAgICAgIHF1ZXVlLnJlcGxhY2Uob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWV1ZS5fZXh0ZW5kZWQgPSB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBtZXRob2RzOiBtZXRob2RzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWV1ZTtcbn0oKTtcbi8qKlxyXG4gKiBbW0RhdGFTZXRdXSBjb2RlIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBbW0RhdGFWaWV3XV0gb3Igb3RoZXIgc2ltaWxhciBpbXBsZW1lbnRhdGlvbnMgb2YgW1tEYXRhSW50ZXJmYWNlXV0uXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAqL1xuXG5cbnZhciBEYXRhU2V0UGFydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFTZXRQYXJ0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU2V0UGFydCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Vic2NyaWJlcnNcIiwge1xuICAgICAgXCIqXCI6IFtdLFxuICAgICAgYWRkOiBbXSxcbiAgICAgIHJlbW92ZTogW10sXG4gICAgICB1cGRhdGU6IFtdXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdWJzY3JpYmVcIiwgRGF0YVNldFBhcnQucHJvdG90eXBlLm9uKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVuc3Vic2NyaWJlXCIsIERhdGFTZXRQYXJ0LnByb3RvdHlwZS5vZmYpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFTZXRQYXJ0LCBbe1xuICAgIGtleTogXCJfdHJpZ2dlclwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBhbiBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIEV2ZW50IHBheWxvYWQuXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBJZCBvZiB0aGUgc2VuZGVyLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3RyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHNlbmRlcklkKSB7XG4gICAgICB2YXIgX2NvbnRleHQ3LCBfY29udGV4dDg7XG5cbiAgICAgIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyaWdnZXIgZXZlbnQgKlwiKTtcbiAgICAgIH1cblxuICAgICAgZm9yRWFjaCQyKF9jb250ZXh0NyA9IGNvbmNhdChfY29udGV4dDggPSBbXSkuY2FsbChfY29udGV4dDgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fc3Vic2NyaWJlcnNbXCIqXCJdKSkpLmNhbGwoX2NvbnRleHQ3LCBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBzdWJzY3JpYmVyKGV2ZW50LCBwYXlsb2FkLCBzZW5kZXJJZCAhPSBudWxsID8gc2VuZGVySWQgOiBudWxsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byBhbiBldmVudCwgYWRkIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzIE5vbi1mdW5jdGlvbiBjYWxsYmFja3MgYXJlIGlnbm9yZWQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgbWV0aG9kLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9IC8vIEBUT0RPOiBNYXliZSB0aHJvdyBmb3IgaW52YWxpZCBjYWxsYmFja3M/XG5cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LCByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3MgSWYgdGhlIHNhbWUgY2FsbGJhY2sgd2FzIHN1YnNjcmliZWQgbW9yZSB0aGFuIG9uY2UgKiphbGwqKiBvY2N1cmVuY2VzIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBtZXRob2QuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9mZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX2NvbnRleHQ5O1xuXG4gICAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBmaWx0ZXIoX2NvbnRleHQ5ID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKS5jYWxsKF9jb250ZXh0OSwgZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIgIT09IGNhbGxiYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIG9uIGluc3RlYWQgKFBTOiBEYXRhVmlldy5zdWJzY3JpYmUgPT09IERhdGFWaWV3Lm9uKS5cclxuICAgICAqL1xuXG4gIH1dKTtcblxuICByZXR1cm4gRGF0YVNldFBhcnQ7XG59KCk7XG4vKipcclxuICogRGF0YSBzdHJlYW1cclxuICpcclxuICogQHJlbWFya3NcclxuICogW1tEYXRhU3RyZWFtXV0gb2ZmZXJzIGFuIGFsd2F5cyB1cCB0byBkYXRlIHN0cmVhbSBvZiBpdGVtcyBmcm9tIGEgW1tEYXRhU2V0XV0gb3IgW1tEYXRhVmlld11dLlxyXG4gKiBUaGF0IG1lYW5zIHRoYXQgdGhlIHN0cmVhbSBpcyBldmFsdWF0ZWQgYXQgdGhlIHRpbWUgb2YgaXRlcmF0aW9uLCBjb252ZXJzaW9uIHRvIGFub3RoZXIgZGF0YSB0eXBlIG9yIHdoZW4gW1tjYWNoZV1dIGlzIGNhbGxlZCwgbm90IHdoZW4gdGhlIFtbRGF0YVN0cmVhbV1dIHdhcyBjcmVhdGVkLlxyXG4gKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBvZiBmb3IgZXhhbXBsZSBbW3RvSXRlbUFycmF5XV0gbWF5IHlpZWxkIGRpZmZlcmVudCByZXN1bHRzIChpZiB0aGUgZGF0YSBzb3VyY2UgbGlrZSBmb3IgZXhhbXBsZSBbW0RhdGFTZXRdXSBnZXRzIG1vZGlmaWVkKS5cclxuICogQHR5cGVQYXJhbSBJdGVtIC0gVGhlIGl0ZW0gdHlwZSB0aGlzIHN0cmVhbSBpcyBnb2luZyB0byB3b3JrIHdpdGguXHJcbiAqL1xuXG5cbl9TeW1ib2wkaXRlcmF0b3IgPSBpdGVyYXRvcjtcblxudmFyIERhdGFTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBzdHJlYW0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcGFpcnMgLSBUaGUgaWQsIGl0ZW0gcGFpcnMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFTdHJlYW0ocGFpcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVN0cmVhbSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFpcnNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX3BhaXJzID0gcGFpcnM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBzdHJlYW0uXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0YVN0cmVhbSwgW3tcbiAgICBrZXk6IF9TeW1ib2wkaXRlcmF0b3IsXG4gICAgdmFsdWU6XG4gICAgLyojX19QVVJFX18qL1xuICAgIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yLCBfc3RlcCwgX3N0ZXAkdmFsdWUsIGlkLCBpdGVtO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiB2YWx1ZSQoX2NvbnRleHQxMCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvci5zKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksIGlkID0gX3N0ZXAkdmFsdWVbMF0sIGl0ZW0gPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgaXRlbV07XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC50MCA9IF9jb250ZXh0MTBbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dDEwLnQwKTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZSwgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgIH0pXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW50cmllc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qI19fUFVSRV9fKi9cbiAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiwgX3N0ZXAyLCBfc3RlcDIkdmFsdWUsIGlkLCBpdGVtO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBlbnRyaWVzJChfY29udGV4dDExKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpO1xuICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucygpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGlmICgoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSwgaWQgPSBfc3RlcDIkdmFsdWVbMF0sIGl0ZW0gPSBfc3RlcDIkdmFsdWVbMV07XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBbaWQsIGl0ZW1dO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEudDAgPSBfY29udGV4dDExW1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKF9jb250ZXh0MTEudDApO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBlbnRyaWVzLCB0aGlzLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgfSlcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXlzIGluIHRoZSBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImtleXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjMsIF9zdGVwMywgX3N0ZXAzJHZhbHVlLCBpZDtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24ga2V5cyQoX2NvbnRleHQxMikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IzLnMoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMSksIGlkID0gX3N0ZXAzJHZhbHVlWzBdO1xuICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gaWQ7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dDEyLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi50MCA9IF9jb250ZXh0MTJbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IzLmUoX2NvbnRleHQxMi50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmZpbmlzaCgxNCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXMsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICB9KVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIHZhbHVlcyBpbiB0aGUgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNCwgX3N0ZXA0LCBfc3RlcDQkdmFsdWUsIGl0ZW07XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIHZhbHVlcyQoX2NvbnRleHQxMykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3I0LnMoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksIGl0ZW0gPSBfc3RlcDQkdmFsdWVbMV07XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMudDAgPSBfY29udGV4dDEzW1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5lKF9jb250ZXh0MTMudDApO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfY29udGV4dDEzLnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZXMsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICB9KVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBpZHMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIGFsbCBpZHMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9JZEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSWRBcnJheSgpIHtcbiAgICAgIHZhciBfY29udGV4dDE0O1xuXG4gICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQxNCA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycykpLmNhbGwoX2NvbnRleHQxNCwgZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJbMF07XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljaXRpZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYXJyYXkgd2l0aCBhbGwgaXRlbXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9JdGVtQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JdGVtQXJyYXkoKSB7XG4gICAgICB2YXIgX2NvbnRleHQxNTtcblxuICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0MTUgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGFpcnMpKS5jYWxsKF9jb250ZXh0MTUsIGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHJldHVybiBwYWlyWzFdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBlbnRyaWVzIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljaXRpZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYXJyYXkgd2l0aCBhbGwgZW50cmllcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0VudHJ5QXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9FbnRyeUFycmF5KCkge1xuICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBtYXAgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtIGFjY2Vzc2libGUgYnkgaWRzLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBJbiBjYXNlIG9mIGR1cGxpY2F0ZSBpZHMgKGNvZXJjZWQgdG8gc3RyaW5nIHNvIGA3ID09ICc3J2ApIHRoZSBsYXN0IGVuY291dGVyZWQgYXBwZWFycyBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCBtYXAgb2YgYWxsIGlkIOKGkiBpdGVtIHBhaXJzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvT2JqZWN0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0TWFwKCkge1xuICAgICAgdmFyIG1hcCA9IGNyZWF0ZSQ1KG51bGwpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpLFxuICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfc3RlcDUkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGl0ZW0gPSBfc3RlcDUkdmFsdWVbMV07XG5cbiAgICAgICAgICBtYXBbaWRdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBpdGVtcyBpbiB0aGlzIHN0cmVhbSBhY2Nlc3NpYmxlIGJ5IGlkcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWFwIG9mIGFsbCBpZCDihpIgaXRlbSBwYWlycyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b01hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b01hcCgpIHtcbiAgICAgIHJldHVybiBuZXcgbWFwKHRoaXMuX3BhaXJzKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBzZXQgY29udGFpbmluZyBhbGwgdGhlICh1bmlxdWUpIGlkcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0IG9mIGFsbCBpZHMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9JZFNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0lkU2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBzZXQodGhpcy50b0lkQXJyYXkoKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSAodW5pcXVlKSBpdGVtcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0IG9mIGFsbCBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0l0ZW1TZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JdGVtU2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBzZXQodGhpcy50b0l0ZW1BcnJheSgpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZSB0aGUgaXRlbXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBpdGVtcyB0byBiZSBmZXRjaGVkIGltbWVkaWF0ZWxseSBhbmQgdXNlZCAocG9zc2libHkgbXVsdGlwbGUgdGltZXMpIGxhdGVyLlxyXG4gICAgICogSXQgY2FuIGFsc28gYmUgdXNlZCB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBhcyBbW0RhdGFTdHJlYW1dXSB3b3VsZCBvdGhlcndpc2UgcmVldmFsdWF0ZSBldmVyeXRoaW5nIHVwb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogIyMgRXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogY29uc3QgZHMgPSBuZXcgRGF0YVNldChb4oCmXSlcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBjYWNoZWRTdHJlYW0gPSBkcy5zdHJlYW0oKVxyXG4gICAgICogICAuZmlsdGVyKOKApilcclxuICAgICAqICAgLnNvcnQo4oCmKVxyXG4gICAgICogICAubWFwKOKApilcclxuICAgICAqICAgLmNhY2hlZCjigKYpIC8vIERhdGEgYXJlIGZldGNoZWQsIHByb2Nlc3NlZCBhbmQgY2FjaGVkIGhlcmUuXHJcbiAgICAgKlxyXG4gICAgICogZHMuY2xlYXIoKVxyXG4gICAgICogY2hhY2hlZFN0cmVhbSAvLyBTdGlsbCBoYXMgYWxsIHRoZSBpdGVtcy5cclxuICAgICAqIGBgYFxyXG4gICAgICogQHJldHVybnMgQSBuZXcgW1tEYXRhU3RyZWFtXV0gd2l0aCBjYWNoZWQgaXRlbXMgKGRldGFjaGVkIGZyb20gdGhlIG9yaWdpbmFsIFtbRGF0YVNldF1dKS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGUoKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkaXN0aW5jdCB2YWx1ZXMgb2YgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGlja3MgYW5kIHBvc3NpYmx5IGNvbnZlcnRzIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEEgc2V0IG9mIGFsbCBkaXN0aW5jdCBwcm9wZXJ0aWVzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0aW5jdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0aW5jdChjYWxsYmFjaykge1xuICAgICAgdmFyIHNldCQxID0gbmV3IHNldCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpLFxuICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfc3RlcDYkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGl0ZW0gPSBfc3RlcDYkdmFsdWVbMV07XG5cbiAgICAgICAgICBzZXQkMS5hZGQoY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXQkMTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgdGhlIGl0ZW1zIG9mIHRoZSBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgZGVjaWRlcyB3aGV0aGVyIGFuIGl0ZW0gd2lsbCBiZSBpbmNsdWRlZC5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGRhdGEgc3RyZWFtIHdpdGggdGhlIGZpbHRlcmVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcGFpcnMgPSB0aGlzLl9wYWlycztcbiAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yNywgX3N0ZXA3LCBfc3RlcDckdmFsdWUsIGlkLCBpdGVtO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0MTYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE2LnByZXYgPSBfY29udGV4dDE2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHBhaXJzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5zKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICgoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3N0ZXA3JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA3LnZhbHVlLCAyKSwgaWQgPSBfc3RlcDckdmFsdWVbMF0sIGl0ZW0gPSBfc3RlcDckdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKGl0ZW0sIGlkKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgaXRlbV07XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYudDAgPSBfY29udGV4dDE2W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LmUoX2NvbnRleHQxNi50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2LnByZXYgPSAxNTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuZmluaXNoKDE1KTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxMiwgMTUsIDE4XV0pO1xuICAgICAgfSkpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggaXRlbSBvZiB0aGUgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgZWFjaCBpdGVtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyksXG4gICAgICAgICAgX3N0ZXA4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDgkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDgudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpZCA9IF9zdGVwOCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwOCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTWFwIHRoZSBpdGVtcyBpbnRvIGEgZGlmZmVyZW50IHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgY29udmVyc2lvbi5cclxuICAgICAqIEB0eXBlUGFyYW0gTWFwcGVkIC0gVGhlIHR5cGUgb2YgdGhlIGl0ZW0gYWZ0ZXIgbWFwcGluZy5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGRhdGEgc3RyZWFtIHdpdGggdGhlIG1hcHBlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaykge1xuICAgICAgdmFyIHBhaXJzID0gdGhpcy5fcGFpcnM7XG4gICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3I5LCBfc3RlcDksIF9zdGVwOSR2YWx1ZSwgaWQsIGl0ZW07XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0MTcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE3LnByZXYgPSBfY29udGV4dDE3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHBhaXJzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5zKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICgoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc3RlcDkkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDkudmFsdWUsIDIpLCBpZCA9IF9zdGVwOSR2YWx1ZVswXSwgaXRlbSA9IF9zdGVwOSR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiBbaWQsIGNhbGxiYWNrKGl0ZW0sIGlkKV07XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy50MCA9IF9jb250ZXh0MTdbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjkuZShfY29udGV4dDE3LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNy5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgICAgfSkpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGl0ZW0gd2l0aCB0aGUgbWF4aW11bSB2YWx1ZSBvZiBnaXZlbiBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBwaWNrcyBhbmQgcG9zc2libHkgY29udmVydHMgdGhlIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gd2l0aCB0aGUgbWF4aW11bSBpZiBmb3VuZCBvdGhlcndpc2UgbnVsbC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChjYWxsYmFjaykge1xuICAgICAgdmFyIGl0ZXIgPSBnZXRJdGVyYXRvcih0aGlzLl9wYWlycyk7XG5cbiAgICAgIHZhciBjdXJyID0gaXRlci5uZXh0KCk7XG5cbiAgICAgIGlmIChjdXJyLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhJdGVtID0gY3Vyci52YWx1ZVsxXTtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IGNhbGxiYWNrKGN1cnIudmFsdWVbMV0sIGN1cnIudmFsdWVbMF0pO1xuXG4gICAgICB3aGlsZSAoIShjdXJyID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgdmFyIF9jdXJyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoY3Vyci52YWx1ZSwgMiksXG4gICAgICAgICAgICBpZCA9IF9jdXJyJHZhbHVlWzBdLFxuICAgICAgICAgICAgaXRlbSA9IF9jdXJyJHZhbHVlWzFdO1xuXG4gICAgICAgIHZhciBfdmFsdWUgPSBjYWxsYmFjayhpdGVtLCBpZCk7XG5cbiAgICAgICAgaWYgKF92YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgbWF4VmFsdWUgPSBfdmFsdWU7XG4gICAgICAgICAgbWF4SXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heEl0ZW07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpdGVtIHdpdGggdGhlIG1pbmltdW0gdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGlja3MgYW5kIHBvc3NpYmx5IGNvbnZlcnRzIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGggdGhlIG1pbmltdW0gaWYgZm91bmQgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4oY2FsbGJhY2spIHtcbiAgICAgIHZhciBpdGVyID0gZ2V0SXRlcmF0b3IodGhpcy5fcGFpcnMpO1xuXG4gICAgICB2YXIgY3VyciA9IGl0ZXIubmV4dCgpO1xuXG4gICAgICBpZiAoY3Vyci5kb25lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluSXRlbSA9IGN1cnIudmFsdWVbMV07XG4gICAgICB2YXIgbWluVmFsdWUgPSBjYWxsYmFjayhjdXJyLnZhbHVlWzFdLCBjdXJyLnZhbHVlWzBdKTtcblxuICAgICAgd2hpbGUgKCEoY3VyciA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIHZhciBfY3VyciR2YWx1ZTIgPSBfc2xpY2VkVG9BcnJheShjdXJyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGlkID0gX2N1cnIkdmFsdWUyWzBdLFxuICAgICAgICAgICAgaXRlbSA9IF9jdXJyJHZhbHVlMlsxXTtcblxuICAgICAgICB2YXIgX3ZhbHVlMiA9IGNhbGxiYWNrKGl0ZW0sIGlkKTtcblxuICAgICAgICBpZiAoX3ZhbHVlMiA8IG1pblZhbHVlKSB7XG4gICAgICAgICAgbWluVmFsdWUgPSBfdmFsdWUyO1xuICAgICAgICAgIG1pbkl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW5JdGVtO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlZHVjZSB0aGUgaXRlbXMgaW50byBhIHNpbmdsZSB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSByZWR1Y3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYWNjdW11bGF0b3IgLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXHJcbiAgICAgKiBAdHlwZVBhcmFtIFQgLSBUaGUgdHlwZSBvZiB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVkdWNlZCB2YWx1ZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVkdWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFjaywgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IxMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpLFxuICAgICAgICAgIF9zdGVwMTA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDEwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfc3RlcDEwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBpdGVtID0gX3N0ZXAxMCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjEwLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjEwLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNvcnQgdGhlIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEl0ZW0gY29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHN0cmVhbSB3aXRoIHNvcnRlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0JDEoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2NvbnRleHQxODtcblxuICAgICAgICByZXR1cm4gZ2V0SXRlcmF0b3Ioc29ydChfY29udGV4dDE4ID0gX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzMi5fcGFpcnMpKS5jYWxsKF9jb250ZXh0MTgsIGZ1bmN0aW9uIChfcmVmLCBfcmVmMikge1xuICAgICAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgICBpZEEgPSBfcmVmM1swXSxcbiAgICAgICAgICAgICAgaXRlbUEgPSBfcmVmM1sxXTtcblxuICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgICAgICAgaWRCID0gX3JlZjRbMF0sXG4gICAgICAgICAgICAgIGl0ZW1CID0gX3JlZjRbMV07XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soaXRlbUEsIGl0ZW1CLCBpZEEsIGlkQik7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YVN0cmVhbTtcbn0oKTtcbi8qKlxyXG4gKiBBZGQgYW4gaWQgdG8gZ2l2ZW4gaXRlbSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lIGFscmVhZHkuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBpdGVtIHdpbGwgYmUgbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gdGhhdCB3aWxsIGhhdmUgYW4gaWQgYWZ0ZXIgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSBpZFByb3AgLSBUaGUga2V5IG9mIHRoZSBpZCBwcm9wZXJ0eS5cclxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cclxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICogQHJldHVybnMgdHJ1ZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBlbnN1cmVGdWxsSXRlbShpdGVtLCBpZFByb3ApIHtcbiAgaWYgKGl0ZW1baWRQcm9wXSA9PSBudWxsKSB7XG4gICAgLy8gZ2VuZXJhdGUgYW4gaWRcbiAgICBpdGVtW2lkUHJvcF0gPSB2NCgpO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW07XG59XG4vKipcclxuICogIyBEYXRhU2V0XHJcbiAqXHJcbiAqIFZpcy5qcyBjb21lcyB3aXRoIGEgZmxleGlibGUgRGF0YVNldCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gaG9sZCBhbmRcclxuICogbWFuaXB1bGF0ZSB1bnN0cnVjdHVyZWQgZGF0YSBhbmQgbGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBkYXRhLiBUaGUgRGF0YVNldFxyXG4gKiBpcyBrZXkvdmFsdWUgYmFzZWQuIERhdGEgaXRlbXMgY2FuIGJlIGFkZGVkLCB1cGRhdGVkIGFuZCByZW1vdmVkIGZyb20gdGhlXHJcbiAqIERhdGFTZXQsIGFuZCBvbmUgY2FuIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBEYXRhU2V0LiBUaGUgZGF0YSBpbiB0aGVcclxuICogRGF0YVNldCBjYW4gYmUgZmlsdGVyZWQgYW5kIG9yZGVyZWQuIERhdGEgY2FuIGJlIG5vcm1hbGl6ZWQgd2hlbiBhcHBlbmRpbmcgaXRcclxuICogdG8gdGhlIERhdGFTZXQgYXMgd2VsbC5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBhIERhdGFTZXQuXHJcbiAqXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gKiB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gKiB2YXIgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChvcHRpb25zKTtcclxuICpcclxuICogLy8gYWRkIGl0ZW1zXHJcbiAqIC8vIG5vdGUgdGhhdCB0aGUgZGF0YSBpdGVtcyBjYW4gY29udGFpbiBkaWZmZXJlbnQgcHJvcGVydGllcyBhbmQgZGF0YSBmb3JtYXRzXHJcbiAqIGRhdGEuYWRkKFtcclxuICogICB7aWQ6IDEsIHRleHQ6ICdpdGVtIDEnLCBkYXRlOiBuZXcgRGF0ZSgyMDEzLCA2LCAyMCksIGdyb3VwOiAxLCBmaXJzdDogdHJ1ZX0sXHJcbiAqICAge2lkOiAyLCB0ZXh0OiAnaXRlbSAyJywgZGF0ZTogJzIwMTMtMDYtMjMnLCBncm91cDogMn0sXHJcbiAqICAge2lkOiAzLCB0ZXh0OiAnaXRlbSAzJywgZGF0ZTogJzIwMTMtMDYtMjUnLCBncm91cDogMn0sXHJcbiAqICAge2lkOiA0LCB0ZXh0OiAnaXRlbSA0J31cclxuICogXSk7XHJcbiAqXHJcbiAqIC8vIHN1YnNjcmliZSB0byBhbnkgY2hhbmdlIGluIHRoZSBEYXRhU2V0XHJcbiAqIGRhdGEub24oJyonLCBmdW5jdGlvbiAoZXZlbnQsIHByb3BlcnRpZXMsIHNlbmRlcklkKSB7XHJcbiAqICAgY29uc29sZS5sb2coJ2V2ZW50JywgZXZlbnQsIHByb3BlcnRpZXMpO1xyXG4gKiB9KTtcclxuICpcclxuICogLy8gdXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW1cclxuICogZGF0YS51cGRhdGUoe2lkOiAyLCBncm91cDogMX0pO1xyXG4gKlxyXG4gKiAvLyByZW1vdmUgYW4gaXRlbVxyXG4gKiBkYXRhLnJlbW92ZSg0KTtcclxuICpcclxuICogLy8gZ2V0IGFsbCBpZHNcclxuICogdmFyIGlkcyA9IGRhdGEuZ2V0SWRzKCk7XHJcbiAqIGNvbnNvbGUubG9nKCdpZHMnLCBpZHMpO1xyXG4gKlxyXG4gKiAvLyBnZXQgYSBzcGVjaWZpYyBpdGVtXHJcbiAqIHZhciBpdGVtMSA9IGRhdGEuZ2V0KDEpO1xyXG4gKiBjb25zb2xlLmxvZygnaXRlbTEnLCBpdGVtMSk7XHJcbiAqXHJcbiAqIC8vIHJldHJpZXZlIGEgZmlsdGVyZWQgc3Vic2V0IG9mIHRoZSBkYXRhXHJcbiAqIHZhciBpdGVtcyA9IGRhdGEuZ2V0KHtcclxuICogICBmaWx0ZXI6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAqICAgICByZXR1cm4gaXRlbS5ncm91cCA9PSAxO1xyXG4gKiAgIH1cclxuICogfSk7XHJcbiAqIGNvbnNvbGUubG9nKCdmaWx0ZXJlZCBpdGVtcycsIGl0ZW1zKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAqL1xuXG5cbnZhciBEYXRhU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGF0YVNldFBhcnQpIHtcbiAgX2luaGVyaXRzKERhdGFTZXQsIF9EYXRhU2V0UGFydCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciR0KERhdGFTZXQpO1xuXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBEYXRhU2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBJbml0aWFsIGRhdGEgb3Igb3B0aW9ucy5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgKHR5cGUgZXJyb3IgaWYgZGF0YSBpcyBhbHNvIG9wdGlvbnMpLlxyXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhU2V0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFTZXQpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyLmNhbGwodGhpcyk7IC8vIGNvcnJlY3RseSByZWFkIG9wdGlvbmFsIGFyZ3VtZW50c1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgXCJmbHVzaFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgXCJsZW5ndGhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIFwiX29wdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIFwiX2RhdGFcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIFwiX2lkUHJvcFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgXCJfcXVldWVcIiwgbnVsbCk7XG5cbiAgICBpZiAoZGF0YSAmJiAhaXNBcnJheSQyKGRhdGEpKSB7XG4gICAgICBvcHRpb25zID0gZGF0YTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICBfdGhpczMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF90aGlzMy5fZGF0YSA9IG5ldyBtYXAoKTsgLy8gbWFwIHdpdGggZGF0YSBpbmRleGVkIGJ5IGlkXG5cbiAgICBfdGhpczMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG5cbiAgICBfdGhpczMuX2lkUHJvcCA9IF90aGlzMy5fb3B0aW9ucy5maWVsZElkIHx8IFwiaWRcIjsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICAgIC8vIGFkZCBpbml0aWFsIGRhdGEgd2hlbiBwcm92aWRlZFxuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgIF90aGlzMy5hZGQoZGF0YSk7XG4gICAgfVxuXG4gICAgX3RoaXMzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBuZXcgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG5ldyBvcHRpb25zLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFTZXQsIFt7XG4gICAga2V5OiBcImlkUHJvcFwiLFxuICAgIGdldDpcbiAgICAvKiogRmx1c2ggYWxsIHF1ZXVlZCBjYWxscy4gKi9cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkUHJvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5xdWV1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBkZWxldGUgcXVldWUgaWYgbG9hZGVkXG4gICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHF1ZXVlIGFuZCB1cGRhdGUgaXRzIG9wdGlvbnNcbiAgICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IFF1ZXVlLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICAgIHJlcGxhY2U6IFtcImFkZFwiLCBcInVwZGF0ZVwiLCBcInJlbW92ZVwiXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucXVldWUgJiYgX3R5cGVvZihvcHRpb25zLnF1ZXVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5fcXVldWUuc2V0T3B0aW9ucyhvcHRpb25zLnF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBkYXRhIGl0ZW0gb3IgYW4gYXJyYXkgd2l0aCBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIGFkZGVkIHRvIHRoZSBEYXRhU2V0LCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYGFkZGAuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgRXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoKVxyXG4gICAgICpcclxuICAgICAqIC8vIGFkZCBpdGVtc1xyXG4gICAgICogY29uc3QgaWRzID0gZGF0YS5hZGQoW1xyXG4gICAgICogICB7IGlkOiAxLCB0ZXh0OiAnaXRlbSAxJyB9LFxyXG4gICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICogICB7IHRleHQ6ICdpdGVtIHdpdGhvdXQgYW4gaWQnIH1cclxuICAgICAqIF0pXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMSwgMiwgJzxVVUlEdjQ+J11cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gSXRlbXMgdG8gYmUgYWRkZWQgKGlkcyB3aWxsIGJlIGdlbmVyYXRlZCBpZiBtaXNzaW5nKS5cclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAqIEByZXR1cm5zIGFkZGVkSWRzIC0gQXJyYXkgd2l0aCB0aGUgaWRzIChnZW5lcmF0ZWQgaWYgbm90IHByZXNlbnQpIG9mIHRoZSBhZGRlZCBpdGVtcy5cclxuICAgICAqIEB0aHJvd3MgV2hlbiBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQgYXMgYW55IG9mIHRoZSBhZGRlZCBpdGVtcyBhbHJlYWR5IGV4aXN0cy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChkYXRhLCBzZW5kZXJJZCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgICAgdmFyIGlkO1xuXG4gICAgICBpZiAoaXNBcnJheSQyKGRhdGEpKSB7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIHZhciBpZHNUb0FkZCA9IG1hcCQzKGRhdGEpLmNhbGwoZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFtfdGhpczQuX2lkUHJvcF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzb21lKGlkc1RvQWRkKS5jYWxsKGlkc1RvQWRkLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9kYXRhLmhhcyhpZCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBkdXBsaWNhdGUgaWQgd2FzIGZvdW5kIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IHRoaXMuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBfdHlwZW9mKGRhdGEpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICAgIGlkID0gdGhpcy5fYWRkSXRlbShkYXRhKTtcbiAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFUeXBlXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwge1xuICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRlZElkcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgaXRlbXMuIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgcHJvdmlkZWQgcHJvcGVydGllcyB3aWxsIGJlIG1lcmdlZCBpbiB0aGUgZXhpc3RpbmcgaXRlbS4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSB1cGRhdGVkLCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYGFkZGAgZm9yIHRoZSBhZGRlZCBpdGVtcywgYW5kIGFuIGV2ZW50IGB1cGRhdGVgLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICAgKiBjb25zdCBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KFtcclxuICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcclxuICAgICAqICAgeyBpZDogMywgdGV4dDogJ2l0ZW0gMycgfVxyXG4gICAgICogXSlcclxuICAgICAqXHJcbiAgICAgKiAvLyB1cGRhdGUgaXRlbXNcclxuICAgICAqIGNvbnN0IGlkcyA9IGRhdGEudXBkYXRlKFtcclxuICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMiAodXBkYXRlZCknIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDQsIHRleHQ6ICdpdGVtIDQgKG5ldyknIH1cclxuICAgICAqIF0pXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMiwgNF1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqICMjIFdhcm5pbmcgZm9yIFR5cGVTY3JpcHQgdXNlcnNcclxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBpbnRyb2R1Y2UgcGFydGlhbCBpdGVtcyBpbnRvIHRoZSBkYXRhIHNldC4gVXNlIGFkZCBvciB1cGRhdGVPbmx5IGluc3RlYWQgZm9yIGJldHRlciB0eXBlIHNhZmV0eS5cclxuICAgICAqIEBwYXJhbSBkYXRhIC0gSXRlbXMgdG8gYmUgdXBkYXRlZCAoaWYgdGhlIGlkIGlzIGFscmVhZHkgcHJlc2VudCkgb3IgYWRkZWQgKGlmIHRoZSBpZCBpcyBtaXNzaW5nKS5cclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAqIEByZXR1cm5zIHVwZGF0ZWRJZHMgLSBUaGUgaWRzIG9mIHRoZSBhZGRlZCAodGhlc2UgbWF5IGJlIG5ld2x5IGdlbmVyYXRlZCBpZiB0aGVyZSB3YXMgbm8gaWQgaW4gdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YSkgb3IgdXBkYXRlZCBpdGVtcy5cclxuICAgICAqIEB0aHJvd3MgV2hlbiB0aGUgc3VwcGxpZWQgZGF0YSBpcyBuZWl0aGVyIGFuIGl0ZW0gbm9yIGFuIGFycmF5IG9mIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEsIHNlbmRlcklkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgICB2YXIgdXBkYXRlZElkcyA9IFtdO1xuICAgICAgdmFyIG9sZERhdGEgPSBbXTtcbiAgICAgIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICAgICAgdmFyIGlkUHJvcCA9IHRoaXMuX2lkUHJvcDtcblxuICAgICAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gYWRkT3JVcGRhdGUoaXRlbSkge1xuICAgICAgICB2YXIgb3JpZ0lkID0gaXRlbVtpZFByb3BdO1xuXG4gICAgICAgIGlmIChvcmlnSWQgIT0gbnVsbCAmJiBfdGhpczUuX2RhdGEuaGFzKG9yaWdJZCkpIHtcbiAgICAgICAgICB2YXIgZnVsbEl0ZW0gPSBpdGVtOyAvLyBpdCBoYXMgYW4gaWQsIHRoZXJlZm9yZSBpdCBpcyBhIGZ1bGxpdGVtXG5cbiAgICAgICAgICB2YXIgb2xkSXRlbSA9IGFzc2lnbiQyKHt9LCBfdGhpczUuX2RhdGEuZ2V0KG9yaWdJZCkpOyAvLyB1cGRhdGUgaXRlbVxuXG5cbiAgICAgICAgICB2YXIgaWQgPSBfdGhpczUuX3VwZGF0ZUl0ZW0oZnVsbEl0ZW0pO1xuXG4gICAgICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICB1cGRhdGVkRGF0YS5wdXNoKGZ1bGxJdGVtKTtcbiAgICAgICAgICBvbGREYXRhLnB1c2gob2xkSXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIG5ldyBpdGVtXG4gICAgICAgICAgdmFyIF9pZCA9IF90aGlzNS5fYWRkSXRlbShpdGVtKTtcblxuICAgICAgICAgIGFkZGVkSWRzLnB1c2goX2lkKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGlzQXJyYXkkMihkYXRhKSkge1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChkYXRhW2ldICYmIF90eXBlb2YoZGF0YVtpXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGFkZE9yVXBkYXRlKGRhdGFbaV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJZ25vcmluZyBpbnB1dCBpdGVtLCB3aGljaCBpcyBub3QgYW4gb2JqZWN0IGF0IGluZGV4IFwiICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgJiYgX3R5cGVvZihkYXRhKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBTaW5nbGUgaXRlbVxuICAgICAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YVR5cGVcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgaXRlbXM6IGFkZGVkSWRzXG4gICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBpdGVtczogdXBkYXRlZElkcyxcbiAgICAgICAgICBvbGREYXRhOiBvbGREYXRhLFxuICAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhXG4gICAgICAgIH07IC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHByb3BlcnR5ICdkYXRhJyBzb21lIGRheVxuICAgICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2RhdGEnLCB7XG4gICAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5IGRhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQuZ2V0KGlkcykgdG8gcmV0cmlldmUgdGhlIG5ldyBkYXRhLCB1c2UgdGhlIG9sZERhdGEgcHJvcGVydHkgb24gdGhpcyBvYmplY3QgdG8gZ2V0IHRoZSBvbGQgZGF0YScpO1xuICAgICAgICAvLyAgICByZXR1cm4gdXBkYXRlZERhdGE7XG4gICAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAgIC8vfSk7XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLCBwcm9wcywgc2VuZGVySWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0KGFkZGVkSWRzKS5jYWxsKGFkZGVkSWRzLCB1cGRhdGVkSWRzKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgaXRlbXMuIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIHdpbGwgYmUgZGVlcGx5IG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyBpdGVtLlxyXG4gICAgICogV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0IChpZCBub3QgcHJlc2VudCBpbiB0aGUgZGF0YSBzZXQgb3IgYWJzZW50KSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gYW5kIG5vdGhpbmcgd2lsbCBiZSBjaGFuZ2VkLlxyXG4gICAgICpcclxuICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgdXBkYXRlZCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGB1cGRhdGVgLlxyXG4gICAgICogV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDInIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH0sXHJcbiAgICAgKiBdKVxyXG4gICAgICpcclxuICAgICAqIC8vIHVwZGF0ZSBpdGVtc1xyXG4gICAgICogY29uc3QgaWRzID0gZGF0YS51cGRhdGUoW1xyXG4gICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyICh1cGRhdGVkKScgfSwgLy8gd29ya3NcclxuICAgICAqICAgLy8geyBpZDogNCwgdGV4dDogJ2l0ZW0gNCAobmV3KScgfSwgLy8gd291bGQgdGhyb3dcclxuICAgICAqICAgLy8geyB0ZXh0OiAnaXRlbSA0IChuZXcpJyB9LCAvLyB3b3VsZCBhbHNvIHRocm93XHJcbiAgICAgKiBdKVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzJdXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVXBkYXRlcyAodGhlIGlkIGFuZCBvcHRpb25hbGx5IG90aGVyIHByb3BzKSB0byB0aGUgaXRlbXMgaW4gdGhpcyBkYXRhIHNldC5cclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAqIEByZXR1cm5zIHVwZGF0ZWRJZHMgLSBUaGUgaWRzIG9mIHRoZSB1cGRhdGVkIGl0ZW1zLlxyXG4gICAgICogQHRocm93cyBXaGVuIHRoZSBzdXBwbGllZCBkYXRhIGlzIG5laXRoZXIgYW4gaXRlbSBub3IgYW4gYXJyYXkgb2YgaXRlbXMsIHdoZW4gdGhlIGlkcyBhcmUgbWlzc2luZy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlT25seVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVPbmx5KGRhdGEsIHNlbmRlcklkKSB7XG4gICAgICB2YXIgX2NvbnRleHQxOSxcbiAgICAgICAgICBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAoIWlzQXJyYXkkMihkYXRhKSkge1xuICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlRXZlbnREYXRhID0gbWFwJDMoX2NvbnRleHQxOSA9IG1hcCQzKGRhdGEpLmNhbGwoZGF0YSwgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICB2YXIgb2xkRGF0YSA9IF90aGlzNi5fZGF0YS5nZXQodXBkYXRlW190aGlzNi5faWRQcm9wXSk7XG5cbiAgICAgICAgaWYgKG9sZERhdGEgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVwZGF0aW5nIG5vbi1leGlzdGVudCBpdGVtcyBpcyBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9sZERhdGE6IG9sZERhdGEsXG4gICAgICAgICAgdXBkYXRlOiB1cGRhdGVcbiAgICAgICAgfTtcbiAgICAgIH0pKS5jYWxsKF9jb250ZXh0MTksIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgb2xkRGF0YSA9IF9yZWY1Lm9sZERhdGEsXG4gICAgICAgICAgICB1cGRhdGUgPSBfcmVmNS51cGRhdGU7XG4gICAgICAgIHZhciBpZCA9IG9sZERhdGFbX3RoaXM2Ll9pZFByb3BdO1xuICAgICAgICB2YXIgdXBkYXRlZERhdGEgPSBwdXJlRGVlcE9iamVjdEFzc2lnbihvbGREYXRhLCB1cGRhdGUpO1xuXG4gICAgICAgIF90aGlzNi5fZGF0YS5zZXQoaWQsIHVwZGF0ZWREYXRhKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBvbGREYXRhOiBvbGREYXRhLFxuICAgICAgICAgIHVwZGF0ZWREYXRhOiB1cGRhdGVkRGF0YVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh1cGRhdGVFdmVudERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBpdGVtczogbWFwJDModXBkYXRlRXZlbnREYXRhKS5jYWxsKHVwZGF0ZUV2ZW50RGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuaWQ7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgb2xkRGF0YTogbWFwJDModXBkYXRlRXZlbnREYXRhKS5jYWxsKHVwZGF0ZUV2ZW50RGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUub2xkRGF0YTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkYXRhOiBtYXAkMyh1cGRhdGVFdmVudERhdGEpLmNhbGwodXBkYXRlRXZlbnREYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS51cGRhdGVkRGF0YTtcbiAgICAgICAgICB9KVxuICAgICAgICB9OyAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0eSAnZGF0YScgc29tZSBkYXlcbiAgICAgICAgLy9PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdkYXRhJywge1xuICAgICAgICAvLyAgJ2dldCc6IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSBkYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0LmdldChpZHMpIHRvIHJldHJpZXZlIHRoZSBuZXcgZGF0YSwgdXNlIHRoZSBvbGREYXRhIHByb3BlcnR5IG9uIHRoaXMgb2JqZWN0IHRvIGdldCB0aGUgb2xkIGRhdGEnKTtcbiAgICAgICAgLy8gICAgcmV0dXJuIHVwZGF0ZWREYXRhO1xuICAgICAgICAvLyAgfSkuYmluZCh0aGlzKVxuICAgICAgICAvL30pO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwgcHJvcHMsIHNlbmRlcklkKTtcblxuICAgICAgICByZXR1cm4gcHJvcHMuaXRlbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAvLyBAVE9ETzogV291ZG4ndCBpdCBiZSBiZXR0ZXIgdG8gc3BsaXQgdGhpcyBpbnRvIG11bHRpcGxlIG1ldGhvZHM/XG4gICAgICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgICB2YXIgaWQgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaWRzID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0lkKGZpcnN0KSkge1xuICAgICAgICAvLyBnZXQoaWQgWywgb3B0aW9uc10pXG4gICAgICAgIGlkID0gZmlyc3Q7XG4gICAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihmaXJzdCkpIHtcbiAgICAgICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSlcbiAgICAgICAgaWRzID0gZmlyc3Q7XG4gICAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXQoWywgb3B0aW9uc10pXG4gICAgICAgIG9wdGlvbnMgPSBmaXJzdDtcbiAgICAgIH0gLy8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZVxuXG5cbiAgICAgIHZhciByZXR1cm5UeXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblR5cGUgPT09IFwiT2JqZWN0XCIgPyBcIk9iamVjdFwiIDogXCJBcnJheVwiOyAvLyBAVE9ETzogV1RGIGlzIHRoaXM/IE9yIGFtIEkgbWlzc2luZyBzb21ldGhpbmc/XG4gICAgICAvLyB2YXIgcmV0dXJuVHlwZVxuICAgICAgLy8gaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlKSB7XG4gICAgICAvLyAgIHZhciBhbGxvd2VkVmFsdWVzID0gWydBcnJheScsICdPYmplY3QnXVxuICAgICAgLy8gICByZXR1cm5UeXBlID1cbiAgICAgIC8vICAgICBhbGxvd2VkVmFsdWVzLmluZGV4T2Yob3B0aW9ucy5yZXR1cm5UeXBlKSA9PSAtMVxuICAgICAgLy8gICAgICAgPyAnQXJyYXknXG4gICAgICAvLyAgICAgICA6IG9wdGlvbnMucmV0dXJuVHlwZVxuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgcmV0dXJuVHlwZSA9ICdBcnJheSdcbiAgICAgIC8vIH1cbiAgICAgIC8vIGJ1aWxkIG9wdGlvbnNcblxuICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgdmFyIGl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXRlbUlkcyA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpdGVtSWQgPSB1bmRlZmluZWQ7IC8vIGNvbnZlcnQgaXRlbXNcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgc2luZ2xlIGl0ZW1cbiAgICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoaXRlbSAmJiBmaWx0ZXIkMSAmJiAhZmlsdGVyJDEoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkcyAhPSBudWxsKSB7XG4gICAgICAgIC8vIHJldHVybiBhIHN1YnNldCBvZiBpdGVtc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkc1tpXSk7XG5cbiAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoaXRlbSkpKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjA7XG5cbiAgICAgICAgLy8gcmV0dXJuIGFsbCBpdGVtc1xuICAgICAgICBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoX2NvbnRleHQyMCA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyMCkpO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2xlbjIgPSBpdGVtSWRzLmxlbmd0aDsgX2kgPCBfbGVuMjsgX2krKykge1xuICAgICAgICAgIGl0ZW1JZCA9IGl0ZW1JZHNbX2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpdGVtSWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiAoIWZpbHRlciQxIHx8IGZpbHRlciQxKGl0ZW0pKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3JkZXIgdGhlIHJlc3VsdHNcblxuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgICAgIH0gLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcblxuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpZWxkcykge1xuICAgICAgICB2YXIgZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG5cbiAgICAgICAgaWYgKGlkICE9IHVuZGVmaW5lZCAmJiBpdGVtICE9IG51bGwpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2xlbjMgPSBpdGVtcy5sZW5ndGg7IF9pMiA8IF9sZW4zOyBfaTIrKykge1xuICAgICAgICAgICAgaXRlbXNbX2kyXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tfaTJdLCBmaWVsZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyByZXR1cm4gdGhlIHJlc3VsdHNcblxuXG4gICAgICBpZiAocmV0dXJuVHlwZSA9PSBcIk9iamVjdFwiKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfbGVuNCA9IGl0ZW1zLmxlbmd0aDsgX2kzIDwgX2xlbjQ7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdGFudCA9IGl0ZW1zW19pM107IC8vIEBUT0RPOiBTaG91ZG4ndCB0aGlzIGJlIHRoaXMuX2ZpZWxkSWQ/XG4gICAgICAgICAgLy8gcmVzdWx0W3Jlc3VsdGFudC5pZF0gPSByZXN1bHRhbnRcblxuICAgICAgICAgIHZhciBfaWQyID0gcmVzdWx0YW50W3RoaXMuX2lkUHJvcF07XG4gICAgICAgICAgcmVzdWx0W19pZDJdID0gcmVzdWx0YW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9pdGVtO1xuXG4gICAgICAgICAgLy8gYSBzaW5nbGUgaXRlbVxuICAgICAgICAgIHJldHVybiAoX2l0ZW0gPSBpdGVtKSAhPT0gbnVsbCAmJiBfaXRlbSAhPT0gdm9pZCAwID8gX2l0ZW0gOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGp1c3QgcmV0dXJuIG91ciBhcnJheVxuICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldElkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHMob3B0aW9ucykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgdmFyIG9yZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyO1xuXG4gICAgICB2YXIgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKGRhdGEpLmNhbGwoZGF0YSkpO1xuXG4gICAgICB2YXIgaWRzID0gW107XG5cbiAgICAgIGlmIChmaWx0ZXIkMSkge1xuICAgICAgICAvLyBnZXQgZmlsdGVyZWQgaXRlbXNcbiAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG9yZGVyZWQgbGlzdFxuICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmIGZpbHRlciQxKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX2xlbjUgPSBpdGVtcy5sZW5ndGg7IF9pNCA8IF9sZW41OyBfaTQrKykge1xuICAgICAgICAgICAgaWRzLnB1c2goaXRlbXNbX2k0XVt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX2xlbjYgPSBpdGVtSWRzLmxlbmd0aDsgX2k1IDwgX2xlbjY7IF9pNSsrKSB7XG4gICAgICAgICAgICB2YXIgX2lkMyA9IGl0ZW1JZHNbX2k1XTtcblxuICAgICAgICAgICAgdmFyIF9pdGVtMiA9IHRoaXMuX2RhdGEuZ2V0KF9pZDMpO1xuXG4gICAgICAgICAgICBpZiAoX2l0ZW0yICE9IG51bGwgJiYgZmlsdGVyJDEoX2l0ZW0yKSkge1xuICAgICAgICAgICAgICBpZHMucHVzaChfaXRlbTJbdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXQgYWxsIGl0ZW1zXG4gICAgICAgIGlmIChvcmRlcikge1xuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgICB2YXIgX2l0ZW1zID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTYgPSAwLCBfbGVuNyA9IGl0ZW1JZHMubGVuZ3RoOyBfaTYgPCBfbGVuNzsgX2k2KyspIHtcbiAgICAgICAgICAgIHZhciBfaWQ0ID0gaXRlbUlkc1tfaTZdO1xuXG4gICAgICAgICAgICBfaXRlbXMucHVzaChkYXRhLmdldChfaWQ0KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc29ydChfaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNyA9IDAsIF9sZW44ID0gX2l0ZW1zLmxlbmd0aDsgX2k3IDwgX2xlbjg7IF9pNysrKSB7XG4gICAgICAgICAgICBpZHMucHVzaChfaXRlbXNbX2k3XVt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX2xlbjkgPSBpdGVtSWRzLmxlbmd0aDsgX2k4IDwgX2xlbjk7IF9pOCsrKSB7XG4gICAgICAgICAgICB2YXIgX2lkNSA9IGl0ZW1JZHNbX2k4XTtcblxuICAgICAgICAgICAgdmFyIF9pdGVtMyA9IGRhdGEuZ2V0KF9pZDUpO1xuXG4gICAgICAgICAgICBpZiAoX2l0ZW0zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWRzLnB1c2goX2l0ZW0zW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWRzO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YVNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgICAgICAvLyBleGVjdXRlIGZvckVhY2ggb24gb3JkZXJlZCBsaXN0XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgdmFyIGlkID0gaXRlbVt0aGlzLl9pZFByb3BdO1xuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5vcmRlcmVkXG4gICAgICAgIGZvciAodmFyIF9pOSA9IDAsIF9sZW4xMCA9IGl0ZW1JZHMubGVuZ3RoOyBfaTkgPCBfbGVuMTA7IF9pOSsrKSB7XG4gICAgICAgICAgdmFyIF9pZDYgPSBpdGVtSWRzW19pOV07XG5cbiAgICAgICAgICB2YXIgX2l0ZW00ID0gdGhpcy5fZGF0YS5nZXQoX2lkNik7XG5cbiAgICAgICAgICBpZiAoX2l0ZW00ICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShfaXRlbTQpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soX2l0ZW00LCBfaWQ2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZmlsdGVyJDEgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgdmFyIG1hcHBlZEl0ZW1zID0gW107XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7IC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG5cbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiAoIWZpbHRlciQxIHx8IGZpbHRlciQxKGl0ZW0pKSkge1xuICAgICAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBvcmRlciBpdGVtc1xuXG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgICAgdGhpcy5fc29ydChtYXBwZWRJdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXBwZWRJdGVtcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgdGhlIGZpZWxkcyBvZiBhbiBpdGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gd2hvc2UgZmllbGRzIHNob3VsZCBiZSBmaWx0ZXJlZC5cclxuICAgICAqIEBwYXJhbSBmaWVsZHMgLSBUaGUgbmFtZXMgb2YgdGhlIGZpZWxkcyB0aGF0IHdpbGwgYmUga2VwdC5cclxuICAgICAqIEB0eXBlUGFyYW0gSyAtIEZpZWxkIG5hbWUgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgZmllbGRzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmlsdGVyRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMTtcblxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIC8vIGl0ZW0gaXMgbnVsbFxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZHVjZShfY29udGV4dDIxID0gaXNBcnJheSQyKGZpZWxkcykgPyAvLyBVc2UgdGhlIHN1cHBsaWVkIGFycmF5XG4gICAgICBmaWVsZHMgOiAvLyBVc2UgdGhlIGtleXMgb2YgdGhlIHN1cHBsaWVkIG9iamVjdFxuICAgICAga2V5cyQ0KGZpZWxkcykpLmNhbGwoX2NvbnRleHQyMSwgZnVuY3Rpb24gKGZpbHRlcmVkSXRlbSwgZmllbGQpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRJdGVtO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNvcnQgdGhlIHByb3ZpZGVkIGFycmF5IHdpdGggaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gSXRlbXMgdG8gYmUgc29ydGVkIGluIHBsYWNlLlxyXG4gICAgICogQHBhcmFtIG9yZGVyIC0gQSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxyXG4gICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGl0ZW1zIGluIHRoZSBpdGVtcyBhcnJheS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NvcnQoaXRlbXMsIG9yZGVyKSB7XG4gICAgICBpZiAodHlwZW9mIG9yZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIG9yZGVyIGJ5IHByb3ZpZGVkIGZpZWxkIG5hbWVcbiAgICAgICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuXG4gICAgICAgIHNvcnQoaXRlbXMpLmNhbGwoaXRlbXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgLy8gQFRPRE86IEhvdyB0byB0cmVhdCBtaXNzaW5nIHByb3BlcnRpZXM/XG4gICAgICAgICAgdmFyIGF2ID0gYVtuYW1lXTtcbiAgICAgICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgICAgIHJldHVybiBhdiA+IGJ2ID8gMSA6IGF2IDwgYnYgPyAtMSA6IDA7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgICAgIHNvcnQoaXRlbXMpLmNhbGwoaXRlbXMsIG9yZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IGV4dGVuZCBvcmRlciBieSBhbiBPYmplY3Qge2ZpZWxkOnN0cmluZywgZGlyZWN0aW9uOnN0cmluZ31cbiAgICAgICAgLy8gICAgICAgd2hlcmUgZGlyZWN0aW9uIGNhbiBiZSAnYXNjJyBvciAnZGVzYydcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gaXRlbSBvciBtdWx0aXBsZSBpdGVtcyBieSDigJxyZWZlcmVuY2XigJ0gKG9ubHkgdGhlIGlkIGlzIHVzZWQpIG9yIGJ5IGlkLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtZXRob2QgaWdub3JlcyByZW1vdmFsIG9mIG5vbi1leGlzdGluZyBpdGVtcywgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSBpdGVtcyB3aGljaCBhcmUgYWN0dWFsbHkgcmVtb3ZlZCBmcm9tIHRoZSBEYXRhU2V0LlxyXG4gICAgICpcclxuICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgcmVtb3ZlZCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGByZW1vdmVgIGZvciB0aGUgcmVtb3ZlZCBpdGVtcy4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICAgKiBjb25zdCBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KFtcclxuICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcclxuICAgICAqICAgeyBpZDogMywgdGV4dDogJ2l0ZW0gMycgfVxyXG4gICAgICogXSlcclxuICAgICAqXHJcbiAgICAgKiAvLyByZW1vdmUgaXRlbXNcclxuICAgICAqIGNvbnN0IGlkcyA9IGRhdGEucmVtb3ZlKFsyLCB7IGlkOiAzIH0sIDRdKVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzIsIDNdXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBPbmUgb3IgbW9yZSBpdGVtcyBvciBpZHMgb2YgaXRlbXMgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWQsIHNlbmRlcklkKSB7XG4gICAgICB2YXIgcmVtb3ZlZElkcyA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWRJdGVtcyA9IFtdOyAvLyBmb3JjZSBldmVyeXRoaW5nIHRvIGJlIGFuIGFycmF5IGZvciBzaW1wbGljaXR5XG5cbiAgICAgIHZhciBpZHMgPSBpc0FycmF5JDIoaWQpID8gaWQgOiBbaWRdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fcmVtb3ZlKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVt0aGlzLl9pZFByb3BdO1xuXG4gICAgICAgICAgaWYgKGl0ZW1JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goaXRlbUlkKTtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgICAgaXRlbXM6IHJlbW92ZWRJZHMsXG4gICAgICAgICAgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zXG4gICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZWRJZHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGl0ZW0gYnkgaXRzIGlkIG9yIHJlZmVyZW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBJZCBvZiBhbiBpdGVtIG9yIHRoZSBpdGVtIGl0c2VsZi5cclxuICAgICAqIEByZXR1cm5zIFRoZSByZW1vdmVkIGl0ZW0gaWYgcmVtb3ZlZCwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZShpZCkge1xuICAgICAgLy8gQFRPRE86IEl0IG9yaWdpYW5sbHkgcmV0dXJuZWQgdGhlIGl0ZW0gYWx0aG91Z2ggdGhlIGRvY3Mgc2F5IGlkLlxuICAgICAgLy8gVGhlIGNvZGUgZXhwZWN0cyB0aGUgaXRlbSwgc28gcHJvYmFibHkgYW4gZXJyb3IgaW4gdGhlIGRvY3MuXG4gICAgICB2YXIgaWRlbnQ7IC8vIGNvbmZpcm0gdGhlIGlkIHRvIHVzZSBiYXNlZCBvbiB0aGUgYXJncyB0eXBlXG5cbiAgICAgIGlmIChpc0lkKGlkKSkge1xuICAgICAgICBpZGVudCA9IGlkO1xuICAgICAgfSBlbHNlIGlmIChpZCAmJiBfdHlwZW9mKGlkKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZGVudCA9IGlkW3RoaXMuX2lkUHJvcF07IC8vIGxvb2sgZm9yIHRoZSBpZGVudGlmaWVyIGZpZWxkIHVzaW5nIC5faWRQcm9wXG4gICAgICB9IC8vIGRvIHRoZSByZW1vdmluZyBpZiB0aGUgaXRlbSBpcyBmb3VuZFxuXG5cbiAgICAgIGlmIChpZGVudCAhPSBudWxsICYmIHRoaXMuX2RhdGEuaGFzKGlkZW50KSkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkZW50KSB8fCBudWxsO1xuXG4gICAgICAgIHRoaXMuX2RhdGEuZGVsZXRlKGlkZW50KTtcblxuICAgICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhlIGVudGlyZSBkYXRhIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHJlbW92ZWQsIHRoZSBbW0RhdGFTZXRdXSB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYHJlbW92ZWAgZm9yIGFsbCByZW1vdmVkIGl0ZW1zLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIFNlbmRlciBpZC5cclxuICAgICAqIEByZXR1cm5zIHJlbW92ZWRJZHMgLSBUaGUgaWRzIG9mIGFsbCByZW1vdmVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcihzZW5kZXJJZCkge1xuICAgICAgdmFyIF9jb250ZXh0MjI7XG5cbiAgICAgIHZhciBpZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhfY29udGV4dDIyID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDIyKSk7XG5cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy5fZGF0YS5nZXQoaWRzW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RhdGEuY2xlYXIoKTtcblxuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgaXRlbXM6IGlkcyxcbiAgICAgICAgb2xkRGF0YTogaXRlbXNcbiAgICAgIH0sIHNlbmRlcklkKTtcblxuICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBpdGVtIHdpdGggbWF4aW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGQgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgbWF4IHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChmaWVsZCkge1xuICAgICAgdmFyIF9jb250ZXh0MjM7XG5cbiAgICAgIHZhciBtYXggPSBudWxsO1xuICAgICAgdmFyIG1heEZpZWxkID0gbnVsbDtcblxuICAgICAgdmFyIF9pdGVyYXRvcjExID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh2YWx1ZXMoX2NvbnRleHQyMyA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyMykpLFxuICAgICAgICAgIF9zdGVwMTE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDExLnZhbHVlO1xuICAgICAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbUZpZWxkID09PSBcIm51bWJlclwiICYmIChtYXhGaWVsZCA9PSBudWxsIHx8IGl0ZW1GaWVsZCA+IG1heEZpZWxkKSkge1xuICAgICAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgICAgIG1heEZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjExLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjExLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heCB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtaW5pbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWVsZCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBtaW4gdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBJdGVtIGNvbnRhaW5pbmcgbWluIHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKGZpZWxkKSB7XG4gICAgICB2YXIgX2NvbnRleHQyNDtcblxuICAgICAgdmFyIG1pbiA9IG51bGw7XG4gICAgICB2YXIgbWluRmllbGQgPSBudWxsO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMTIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHZhbHVlcyhfY29udGV4dDI0ID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDI0KSksXG4gICAgICAgICAgX3N0ZXAxMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxMi5zKCk7ICEoX3N0ZXAxMiA9IF9pdGVyYXRvcjEyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMTIudmFsdWU7XG4gICAgICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtRmllbGQgPT09IFwibnVtYmVyXCIgJiYgKG1pbkZpZWxkID09IG51bGwgfHwgaXRlbUZpZWxkIDwgbWluRmllbGQpKSB7XG4gICAgICAgICAgICBtaW4gPSBpdGVtO1xuICAgICAgICAgICAgbWluRmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTIuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmluZCBhbGwgZGlzdGluY3QgdmFsdWVzIG9mIGEgc3BlY2lmaWVkIGZpZWxkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3AgLSBUaGUgcHJvcGVydHkgbmFtZSB3aG9zZSBkaXN0aW5jdCB2YWx1ZXMgc2hvdWxkIGJlIHJldHVybmVkLlxyXG4gICAgICogQHJldHVybnMgVW5vcmRlcmVkIGFycmF5IGNvbnRhaW5pbmcgYWxsIGRpc3RpbmN0IHZhbHVlcy4gSXRlbXMgd2l0aG91dCBzcGVjaWZpZWQgcHJvcGVydHkgYXJlIGlnbm9yZWQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RpbmN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RpbmN0KHByb3ApIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTtcblxuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgdmFyIGl0ZW0gPSBkYXRhLmdldChpZCk7XG4gICAgICAgIHZhciBfdmFsdWUzID0gaXRlbVtwcm9wXTtcbiAgICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgIGlmICh2YWx1ZXNbal0gPT0gX3ZhbHVlMykge1xuICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhpc3RzICYmIF92YWx1ZTMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlc1tjb3VudF0gPSBfdmFsdWUzO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtIC0gQSBuZXcgaXRlbSB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIEFkZGVkIGl0ZW0ncyBpZC4gQW4gaWQgaXMgZ2VuZXJhdGVkIHdoZW4gaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIGl0ZW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRJdGVtKGl0ZW0pIHtcbiAgICAgIHZhciBmdWxsSXRlbSA9IGVuc3VyZUZ1bGxJdGVtKGl0ZW0sIHRoaXMuX2lkUHJvcCk7XG4gICAgICB2YXIgaWQgPSBmdWxsSXRlbVt0aGlzLl9pZFByb3BdOyAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaWQgaXMgYWxyZWFkeSB0YWtlblxuXG4gICAgICBpZiAodGhpcy5fZGF0YS5oYXMoaWQpKSB7XG4gICAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgXCIgKyBpZCArIFwiIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXRhLnNldChpZCwgZnVsbEl0ZW0pO1xuXG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXHJcbiAgICAgKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cGRhdGUgLSBUaGUgbmV3IGl0ZW1cclxuICAgICAqIEByZXR1cm5zIFRoZSBpZCBvZiB0aGUgdXBkYXRlZCBpdGVtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSXRlbSh1cGRhdGUpIHtcbiAgICAgIHZhciBpZCA9IHVwZGF0ZVt0aGlzLl9pZFByb3BdO1xuXG4gICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGl0ZW06IGl0ZW0gaGFzIG5vIGlkIChpdGVtOiBcIiArIHN0cmluZ2lmeSQxKHVwZGF0ZSkgKyBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuXG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgLy8gaXRlbSBkb2Vzbid0IGV4aXN0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgaXRlbTogbm8gaXRlbSB3aXRoIGlkIFwiICsgaWQgKyBcIiBmb3VuZFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGF0YS5zZXQoaWQsIF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIGl0ZW0pLCB1cGRhdGUpKTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0cmVhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW0oaWRzKSB7XG4gICAgICBpZiAoaWRzKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IxMywgX3N0ZXAxMywgaWQsIGl0ZW07XG5cbiAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQyNSkge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI1LnByZXYgPSBfY29udGV4dDI1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoaWRzKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEzLnMoKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGlmICgoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlkID0gX3N0ZXAxMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGl0ZW0gPSBkYXRhLmdldChpZCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghKGl0ZW0gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUucHJldiA9IDEzO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS50MCA9IF9jb250ZXh0MjVbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMTMuZShfY29udGV4dDI1LnQwKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1LnByZXYgPSAxNjtcblxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMTMuZigpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5maW5pc2goMTYpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1sxLCAxMywgMTYsIDE5XV0pO1xuICAgICAgICB9KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjY7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIGJpbmQkNihfY29udGV4dDI2ID0gZW50cmllcyh0aGlzLl9kYXRhKSkuY2FsbChfY29udGV4dDI2LCB0aGlzLl9kYXRhKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhU2V0O1xufShEYXRhU2V0UGFydCk7XG4vKipcclxuICogRGF0YVZpZXdcclxuICpcclxuICogQSBEYXRhVmlldyBvZmZlcnMgYSBmaWx0ZXJlZCBhbmQvb3IgZm9ybWF0dGVkIHZpZXcgb24gYSBEYXRhU2V0LiBPbmUgY2FuIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIGEgRGF0YVZpZXcsIGFuZCBlYXNpbHkgZ2V0IGZpbHRlcmVkIG9yIGZvcm1hdHRlZCBkYXRhIHdpdGhvdXQgaGF2aW5nIHRvIHNwZWNpZnkgZmlsdGVycyBhbmQgZmllbGQgdHlwZXMgYWxsIHRoZSB0aW1lLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gKiB2YXIgZGF0YSA9IG5ldyB2aXMuRGF0YVNldCgpO1xyXG4gKiBkYXRhLmFkZChbXHJcbiAqICAge2lkOiAxLCB0ZXh0OiAnaXRlbSAxJywgZGF0ZTogbmV3IERhdGUoMjAxMywgNiwgMjApLCBncm91cDogMSwgZmlyc3Q6IHRydWV9LFxyXG4gKiAgIHtpZDogMiwgdGV4dDogJ2l0ZW0gMicsIGRhdGU6ICcyMDEzLTA2LTIzJywgZ3JvdXA6IDJ9LFxyXG4gKiAgIHtpZDogMywgdGV4dDogJ2l0ZW0gMycsIGRhdGU6ICcyMDEzLTA2LTI1JywgZ3JvdXA6IDJ9LFxyXG4gKiAgIHtpZDogNCwgdGV4dDogJ2l0ZW0gNCd9XHJcbiAqIF0pO1xyXG4gKlxyXG4gKiAvLyBjcmVhdGUgYSBEYXRhVmlld1xyXG4gKiAvLyB0aGUgdmlldyB3aWxsIG9ubHkgY29udGFpbiBpdGVtcyBoYXZpbmcgYSBwcm9wZXJ0eSBncm91cCB3aXRoIHZhbHVlIDEsXHJcbiAqIC8vIGFuZCB3aWxsIG9ubHkgb3V0cHV0IGZpZWxkcyBpZCwgdGV4dCwgYW5kIGRhdGUuXHJcbiAqIHZhciB2aWV3ID0gbmV3IHZpcy5EYXRhVmlldyhkYXRhLCB7XHJcbiAqICAgZmlsdGVyOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gKiAgICAgcmV0dXJuIChpdGVtLmdyb3VwID09IDEpO1xyXG4gKiAgIH0sXHJcbiAqICAgZmllbGRzOiBbJ2lkJywgJ3RleHQnLCAnZGF0ZSddXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyBzdWJzY3JpYmUgdG8gYW55IGNoYW5nZSBpbiB0aGUgRGF0YVZpZXdcclxuICogdmlldy5vbignKicsIGZ1bmN0aW9uIChldmVudCwgcHJvcGVydGllcywgc2VuZGVySWQpIHtcclxuICogICBjb25zb2xlLmxvZygnZXZlbnQnLCBldmVudCwgcHJvcGVydGllcyk7XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyB1cGRhdGUgYW4gaXRlbSBpbiB0aGUgZGF0YSBzZXRcclxuICogZGF0YS51cGRhdGUoe2lkOiAyLCBncm91cDogMX0pO1xyXG4gKlxyXG4gKiAvLyBnZXQgYWxsIGlkcyBpbiB0aGUgdmlld1xyXG4gKiB2YXIgaWRzID0gdmlldy5nZXRJZHMoKTtcclxuICogY29uc29sZS5sb2coJ2lkcycsIGlkcyk7IC8vIHdpbGwgb3V0cHV0IFsxLCAyXVxyXG4gKlxyXG4gKiAvLyBnZXQgYWxsIGl0ZW1zIGluIHRoZSB2aWV3XHJcbiAqIHZhciBpdGVtcyA9IHZpZXcuZ2V0KCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxyXG4gKi9cblxuXG52YXIgRGF0YVZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EYXRhU2V0UGFydDIpIHtcbiAgX2luaGVyaXRzKERhdGFWaWV3LCBfRGF0YVNldFBhcnQyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlciR0KERhdGFWaWV3KTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBEYXRhVmlldy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGluc3RhbmNlIGNvbnRhaW5pbmcgZGF0YSAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSkuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGlzIGRhdGEgdmlldy5cclxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVZpZXcoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBfY29udGV4dDI3O1xuXG4gICAgdmFyIF90aGlzNztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhVmlldyk7XG5cbiAgICBfdGhpczcgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcpLCBcImxlbmd0aFwiLCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIFwiX2xpc3RlbmVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcpLCBcIl9kYXRhXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcpLCBcIl9pZHNcIiwgbmV3IHNldCgpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIFwiX29wdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgIF90aGlzNy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgX3RoaXM3Ll9saXN0ZW5lciA9IGJpbmQkNihfY29udGV4dDI3ID0gX3RoaXM3Ll9vbkV2ZW50KS5jYWxsKF9jb250ZXh0MjcsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3KSk7XG5cbiAgICBfdGhpczcuc2V0RGF0YShkYXRhKTtcblxuICAgIHJldHVybiBfdGhpczc7XG4gIH0gLy8gVE9ETzogaW1wbGVtZW50IGEgZnVuY3Rpb24gLmNvbmZpZygpIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGluZ3MgbGlrZSBjb25maWd1cmVkIGZpbHRlclxuICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2VzIGFjY29yZGluZ2x5XG5cbiAgLyoqXHJcbiAgICogU2V0IGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB2aWV3LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgaW5zdGFuY2UgY29udGFpbmluZyBkYXRhIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KS5cclxuICAgKiBAcmVtYXJrc1xyXG4gICAqIE5vdGUgdGhhdCB3aGVuIHRoZSBkYXRhIHZpZXcgaXMgYm91bmQgdG8gYSBkYXRhIHNldCBpdCB3b24ndCBiZSBnYXJiYWdlXHJcbiAgICogY29sbGVjdGVkIHVubGVzcyB0aGUgZGF0YSBzZXQgaXMgdG9vLiBVc2UgYGRhdGFWaWV3LnNldERhdGEobnVsbClgIG9yXHJcbiAgICogYGRhdGFWaWV3LmRpc3Bvc2UoKWAgdG8gZW5hYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiBiZWZvcmUgeW91IGxvc2UgdGhlIGxhc3RcclxuICAgKiByZWZlcmVuY2UuXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0YVZpZXcsIFt7XG4gICAga2V5OiBcImlkUHJvcFwiLFxuICAgIGdldDpcbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERhdGFTZXQoKS5pZFByb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgICAgICBpZiAodGhpcy5fZGF0YS5vZmYpIHtcbiAgICAgICAgICB0aGlzLl9kYXRhLm9mZihcIipcIiwgdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgICB9IC8vIHRyaWdnZXIgYSByZW1vdmUgb2YgYWxsIGl0ZW1zIGluIG1lbW9yeVxuXG5cbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICBmaWx0ZXI6IGZpbHRlcih0aGlzLl9vcHRpb25zKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9kYXRhLmdldChpZHMpO1xuXG4gICAgICAgIHRoaXMuX2lkcy5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICBpdGVtczogaWRzLFxuICAgICAgICAgIG9sZERhdGE6IGl0ZW1zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhOyAvLyB0cmlnZ2VyIGFuIGFkZCBvZiBhbGwgYWRkZWQgaXRlbXNcblxuICAgICAgICB2YXIgX2lkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICBmaWx0ZXI6IGZpbHRlcih0aGlzLl9vcHRpb25zKVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gX2lkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IF9pZHNbaV07XG5cbiAgICAgICAgICB0aGlzLl9pZHMuYWRkKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gX2lkcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgaXRlbXM6IF9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IERhdGFTZXQoKTtcbiAgICAgIH0gLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG5cblxuICAgICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgICAgdGhpcy5fZGF0YS5vbihcIipcIiwgdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlZnJlc2ggdGhlIERhdGFWaWV3LlxyXG4gICAgICogVXNlZnVsIHdoZW4gdGhlIERhdGFWaWV3IGhhcyBhIGZpbHRlciBmdW5jdGlvbiBjb250YWluaW5nIGEgdmFyaWFibGUgcGFyYW1ldGVyLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICBmaWx0ZXI6IGZpbHRlcih0aGlzLl9vcHRpb25zKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBvbGRJZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5faWRzKTtcblxuICAgICAgdmFyIG5ld0lkcyA9IHt9O1xuICAgICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgICB2YXIgcmVtb3ZlZElkcyA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWRJdGVtcyA9IFtdOyAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICBuZXdJZHNbaWRdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG5cbiAgICAgICAgICB0aGlzLl9pZHMuYWRkKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcblxuXG4gICAgICBmb3IgKHZhciBfaTEwID0gMCwgX2xlbjExID0gb2xkSWRzLmxlbmd0aDsgX2kxMCA8IF9sZW4xMTsgX2kxMCsrKSB7XG4gICAgICAgIHZhciBfaWQ3ID0gb2xkSWRzW19pMTBdO1xuXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoX2lkNyk7XG5cbiAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEBUT0RPOiBJbnZlc3RpZ2F0ZS5cbiAgICAgICAgICAvLyBEb2Vzbid0IGhhcHBlbiBkdXJpbmcgdGVzdHMgb3IgZXhhbXBsZXMuXG4gICAgICAgICAgLy8gSXMgaXQgcmVhbGx5IGltcG9zc2libGUgb3IgY291bGQgaXQgZXZlbnR1YWxseSBoYXBwZW4/XG4gICAgICAgICAgLy8gSG93IHRvIGhhbmRsZSBpdCBpZiBpdCBkb2VzPyBUaGUgdHlwZXMgZ3VhcmFudGVlIG5vbi1udWxsYWJsZSBpdGVtcy5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSWYgeW91IHNlZSB0aGlzLCByZXBvcnQgaXQgcGxlYXNlLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghbmV3SWRzW19pZDddKSB7XG4gICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKF9pZDcpO1xuICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgICAgdGhpcy5faWRzLmRlbGV0ZShfaWQ3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBhZGRlZElkcy5sZW5ndGggLSByZW1vdmVkSWRzLmxlbmd0aDsgLy8gdHJpZ2dlciBldmVudHNcblxuICAgICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICBpdGVtczogcmVtb3ZlZElkcyxcbiAgICAgICAgICBvbGREYXRhOiByZW1vdmVkSXRlbXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG5cblxuICAgICAgdmFyIGlkcyA9IG51bGw7XG4gICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgaWYgKGlzSWQoZmlyc3QpIHx8IGlzQXJyYXkkMihmaXJzdCkpIHtcbiAgICAgICAgaWRzID0gZmlyc3Q7XG4gICAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gZmlyc3Q7XG4gICAgICB9IC8vIGV4dGVuZCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgYW5kIHByb3ZpZGVkIG9wdGlvbnNcblxuXG4gICAgICB2YXIgdmlld09wdGlvbnMgPSBhc3NpZ24kMih7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7IC8vIGNyZWF0ZSBhIGNvbWJpbmVkIGZpbHRlciBtZXRob2Qgd2hlbiBuZWVkZWRcblxuXG4gICAgICB2YXIgdGhpc0ZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgdmFyIG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgaWYgKHRoaXNGaWx0ZXIgJiYgb3B0aW9uc0ZpbHRlcikge1xuICAgICAgICB2aWV3T3B0aW9ucy5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzRmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXQodmlld09wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0KGlkcywgdmlld09wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldElkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHMob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gZmlsdGVyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAhPSBudWxsID8gZmlsdGVyKG9wdGlvbnMpIDogbnVsbDtcbiAgICAgICAgdmFyIGZpbHRlciQxO1xuXG4gICAgICAgIGlmIChvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciQxID0gb3B0aW9uc0ZpbHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyJDEgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyODtcblxuICAgICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICB2YXIgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBmaWx0ZXIkMTtcblxuICAgICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciQxID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2gkMihfY29udGV4dDI4ID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDI4LCBjYWxsYmFjaywge1xuICAgICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyOTtcblxuICAgICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICB2YXIgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBmaWx0ZXIkMTtcblxuICAgICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciQxID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXAkMyhfY29udGV4dDI5ID0gdGhpcy5fZGF0YSkuY2FsbChfY29udGV4dDI5LCBjYWxsYmFjaywge1xuICAgICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFTZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXREYXRhU2V0KCk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbShpZHMpIHtcbiAgICAgIHZhciBfY29udGV4dDMwO1xuXG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS5zdHJlYW0oaWRzIHx8IF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIGJpbmQkNihfY29udGV4dDMwID0ga2V5cyh0aGlzLl9pZHMpKS5jYWxsKF9jb250ZXh0MzAsIHRoaXMuX2lkcykpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgdGhlIGluc3RhbmNlIHVudXNhYmxlIHByaW9yIHRvIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIGludGVudGlvbiBvZiB0aGlzIG1ldGhvZCBpcyB0byBoZWxwIGRpc2NvdmVyIHNjZW5hcmlvcyB3aGVyZSB0aGUgZGF0YVxyXG4gICAgICogdmlldyBpcyBiZWluZyB1c2VkIHdoZW4gdGhlIHByb2dyYW1tZXIgdGhpbmtzIGl0IGhhcyBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkXHJcbiAgICAgKiBhbHJlYWR5LiBJdCdzIHN0cmljdGVyIHZlcnNpb24gb2YgYGRhdGFWaWV3LnNldERhdGEobnVsbClgLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB2YXIgX3RoaXMkX2RhdGE7XG5cbiAgICAgIGlmICgoX3RoaXMkX2RhdGEgPSB0aGlzLl9kYXRhKSAhPT0gbnVsbCAmJiBfdGhpcyRfZGF0YSAhPT0gdm9pZCAwICYmIF90aGlzJF9kYXRhLm9mZikge1xuICAgICAgICB0aGlzLl9kYXRhLm9mZihcIipcIiwgdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVzc2FnZSA9IFwiVGhpcyBkYXRhIHZpZXcgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi5cIjtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIHZhciBfaXRlcmF0b3IxNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcob3duS2V5cyQ1KERhdGFWaWV3LnByb3RvdHlwZSkpLFxuICAgICAgICAgIF9zdGVwMTQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTQucygpOyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwMTQudmFsdWU7XG5cbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSQ2KHRoaXMsIGtleSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTQuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIEV2ZW50IGxpc3RlbmVyLiBXaWxsIHByb3BhZ2F0ZSBhbGwgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBkYXRhIHNldCB0byB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIERhdGFWaWV3LCBidXQgd2lsbCBmaWx0ZXIgdGhlIGl0ZW1zIGFuZCBvbmx5IHRyaWdnZXIgd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgb2YgdGhlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gSWQgc3VwcGxpZWQgYnkgdGhlIHNlbmRlci5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRXZlbnQoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMuaXRlbXMgfHwgIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRzID0gcGFyYW1zLml0ZW1zO1xuICAgICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgICB2YXIgdXBkYXRlZElkcyA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWRJZHMgPSBbXTtcbiAgICAgIHZhciBvbGRJdGVtcyA9IFtdO1xuICAgICAgdmFyIHVwZGF0ZWRJdGVtcyA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWRJdGVtcyA9IFtdO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzLmFkZChpZCk7XG5cbiAgICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgICAgLy8gaXRlbSBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQsIG9yIHJlbW92ZWQgZnJvbSB0aGlzIHZpZXcuXG4gICAgICAgICAgZm9yICh2YXIgX2kxMSA9IDAsIF9sZW4xMiA9IGlkcy5sZW5ndGg7IF9pMTEgPCBfbGVuMTI7IF9pMTErKykge1xuICAgICAgICAgICAgdmFyIF9pZDggPSBpZHNbX2kxMV07XG5cbiAgICAgICAgICAgIHZhciBfaXRlbTUgPSB0aGlzLmdldChfaWQ4KTtcblxuICAgICAgICAgICAgaWYgKF9pdGVtNSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faWRzLmhhcyhfaWQ4KSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRJZHMucHVzaChfaWQ4KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkSXRlbXMucHVzaChwYXJhbXMuZGF0YVtfaTExXSk7XG4gICAgICAgICAgICAgICAgb2xkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtfaTExXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRzLmFkZChfaWQ4KTtcblxuICAgICAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goX2lkOCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKF9pZDgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRzLmRlbGV0ZShfaWQ4KTtcblxuICAgICAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChfaWQ4KTtcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtfaTExXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2xlbjEzID0gaWRzLmxlbmd0aDsgX2kxMiA8IF9sZW4xMzsgX2kxMisrKSB7XG4gICAgICAgICAgICB2YXIgX2lkOSA9IGlkc1tfaTEyXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lkcy5oYXMoX2lkOSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzLmRlbGV0ZShfaWQ5KTtcblxuICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goX2lkOSk7XG4gICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW19pMTJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7XG5cbiAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgaXRlbXM6IGFkZGVkSWRzXG4gICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwge1xuICAgICAgICAgIGl0ZW1zOiB1cGRhdGVkSWRzLFxuICAgICAgICAgIG9sZERhdGE6IG9sZEl0ZW1zLFxuICAgICAgICAgIGRhdGE6IHVwZGF0ZWRJdGVtc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsIHtcbiAgICAgICAgICBpdGVtczogcmVtb3ZlZElkcyxcbiAgICAgICAgICBvbGREYXRhOiByZW1vdmVkSXRlbXNcbiAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhVmlldztcbn0oRGF0YVNldFBhcnQpO1xuLyoqXHJcbiAqIENoZWNrIHRoYXQgZ2l2ZW4gdmFsdWUgaXMgY29tcGF0aWJsZSB3aXRoIFZpcyBEYXRhIFNldCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBpZFByb3AgLSBUaGUgZXhwZWN0ZWQgcHJvcGVydHkgdG8gY29udGFpbiBpdGVtIGlkLlxyXG4gKiBAcGFyYW0gdiAtIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWQuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGV4cGVjdGVkIHZhbHVlcyBhbmQgbWV0aG9kcyBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0RhdGFTZXRMaWtlKGlkUHJvcCwgdikge1xuICByZXR1cm4gX3R5cGVvZih2KSA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIGlkUHJvcCA9PT0gdi5pZFByb3AgJiYgdHlwZW9mIHYuYWRkID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuY2xlYXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5kaXN0aW5jdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBmb3JFYWNoJDIodikgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXREYXRhU2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0SWRzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubGVuZ3RoID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBtYXAkMyh2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm1heCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm1pbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm9mZiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm9uID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuc2V0T3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnVwZGF0ZU9ubHkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxyXG4gKiBDaGVjayB0aGF0IGdpdmVuIHZhbHVlIGlzIGNvbXBhdGlibGUgd2l0aCBWaXMgRGF0YSBWaWV3IGludGVyZmFjZS5cclxuICpcclxuICogQHBhcmFtIGlkUHJvcCAtIFRoZSBleHBlY3RlZCBwcm9wZXJ0eSB0byBjb250YWluIGl0ZW0gaWQuXHJcbiAqIEBwYXJhbSB2IC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZC5cclxuICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgZXhwZWN0ZWQgdmFsdWVzIGFuZCBtZXRob2RzIG1hdGNoLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdMaWtlKGlkUHJvcCwgdikge1xuICByZXR1cm4gX3R5cGVvZih2KSA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIGlkUHJvcCA9PT0gdi5pZFByb3AgJiYgdHlwZW9mIGZvckVhY2gkMih2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldERhdGFTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXRJZHMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5sZW5ndGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1hcCQzKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub2ZmID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYub24gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiAmJiBpc0RhdGFTZXRMaWtlKGlkUHJvcCwgdi5nZXREYXRhU2V0KCkpO1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0REVMRVRFOiBERUxFVEUsXG5cdERhdGFTZXQ6IERhdGFTZXQsXG5cdERhdGFTdHJlYW06IERhdGFTdHJlYW0sXG5cdERhdGFWaWV3OiBEYXRhVmlldyxcblx0UXVldWU6IFF1ZXVlLFxuXHRjcmVhdGVOZXdEYXRhUGlwZUZyb206IGNyZWF0ZU5ld0RhdGFQaXBlRnJvbSxcblx0aXNEYXRhU2V0TGlrZTogaXNEYXRhU2V0TGlrZSxcblx0aXNEYXRhVmlld0xpa2U6IGlzRGF0YVZpZXdMaWtlXG59KTtcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJFA7XG52YXIgZmFpbHMkMSA9IGZhaWxzJHQ7XG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9TdHJpbmcgPSB0b1N0cmluZyQ4O1xudmFyIHRyaW0gPSBzdHJpbmdUcmltLnRyaW07XG52YXIgd2hpdGVzcGFjZXMgPSB3aGl0ZXNwYWNlcyQ0O1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzJDIoJycuY2hhckF0KTtcbnZhciBuJFBhcnNlRmxvYXQgPSBnbG9iYWwkMi5wYXJzZUZsb2F0O1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJDIuU3ltYm9sO1xudmFyIElURVJBVE9SID0gU3ltYm9sJDEgJiYgU3ltYm9sJDEuaXRlcmF0b3I7XG52YXIgRk9SQ0VEID0gMSAvIG4kUGFyc2VGbG9hdCh3aGl0ZXNwYWNlcyArICctMCcpICE9PSAtSW5maW5pdHkgLy8gTVMgRWRnZSAxOC0gYnJva2VuIHdpdGggYm94ZWQgc3ltYm9sc1xufHwgSVRFUkFUT1IgJiYgIWZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICBuJFBhcnNlRmxvYXQoT2JqZWN0KElURVJBVE9SKSk7XG59KTsgLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xuXG52YXIgbnVtYmVyUGFyc2VGbG9hdCA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyaW5nKSB7XG4gIHZhciB0cmltbWVkU3RyaW5nID0gdHJpbSh0b1N0cmluZyhzdHJpbmcpKTtcbiAgdmFyIHJlc3VsdCA9IG4kUGFyc2VGbG9hdCh0cmltbWVkU3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBjaGFyQXQodHJpbW1lZFN0cmluZywgMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogbiRQYXJzZUZsb2F0O1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciAkcGFyc2VGbG9hdCA9IG51bWJlclBhcnNlRmxvYXQ7IC8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VmbG9hdC1zdHJpbmdcblxuJCQ0KHtcbiAgZ2xvYmFsOiB0cnVlLFxuICBmb3JjZWQ6IHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXRcbn0sIHtcbiAgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXRcbn0pO1xuXG52YXIgcGF0aCQ1ID0gcGF0aCR5O1xudmFyIF9wYXJzZUZsb2F0JDIgPSBwYXRoJDUucGFyc2VGbG9hdDtcblxudmFyIHBhcmVudCQ5ID0gX3BhcnNlRmxvYXQkMjtcbnZhciBfcGFyc2VGbG9hdCQxID0gcGFyZW50JDk7XG5cbnZhciBfcGFyc2VGbG9hdCA9IF9wYXJzZUZsb2F0JDE7XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyIGZhaWxzID0gZmFpbHMkdDtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKDEpO1xufSk7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5cbiQkMyh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFU1xufSwge1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzJDNcbn0pO1xuXG52YXIgcGF0aCQ0ID0gcGF0aCR5O1xudmFyIE9iamVjdCQxID0gcGF0aCQ0Lk9iamVjdDtcblxudmFyIGdldE93blByb3BlcnR5TmFtZXMkMiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIE9iamVjdCQxLmdldE93blByb3BlcnR5TmFtZXMoaXQpO1xufTtcblxudmFyIHBhcmVudCQ4ID0gZ2V0T3duUHJvcGVydHlOYW1lcyQyO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMkMSA9IHBhcmVudCQ4O1xuXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXMkMTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmUgdmFsdWVzIHRvIHVzZSBmb3IgKHN1YilvcHRpb25zIG9mICdjaG9zZW4nLlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIGVpdGhlciBhIGJvb2xlYW4gb3IgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgZXhhbWluZWQgZnVydGhlci5cbiAqIFRoZSByZWxldmFudCBzdHJ1Y3R1cmVzIGFyZTpcbiAqXG4gKiAtIGNob3NlbjogPGJvb2xlYW4gdmFsdWU+XG4gKiAtIGNob3NlbjogeyBzdWJPcHRpb246IDxib29sZWFuIG9yIGZ1bmN0aW9uPiB9XG4gKlxuICogV2hlcmUgc3ViT3B0aW9uIGlzICdub2RlJywgJ2VkZ2UnIG9yICdsYWJlbCcuXG4gKlxuICogVGhlIGludGVudGlvbiBvZiB0aGlzIG1ldGhvZCBhcHBlYXJzIHRvIGJlIHRvIHNldCBhIHNwZWNpZmljIHByaW9yaXR5IHRvIHRoZSBvcHRpb25zO1xuICogU2luY2UgbW9zdCBwcm9wZXJ0aWVzIGFyZSBlaXRoZXIgYnJpZGdlZCBvciBtZXJnZWQgaW50byB0aGUgbG9jYWwgb3B0aW9ucyBvYmplY3RzLCB0aGVyZVxuICogaXMgbm90IG11Y2ggcG9pbnQgaW4gaGFuZGxpbmcgdGhlbSBzZXBhcmF0ZWx5LlxuICogVE9ETzogZXhhbWluZSBpZiAnbW9zdCcgaW4gcHJldmlvdXMgc2VudGVuY2UgY2FuIGJlIHJlcGxhY2VkIHdpdGggJ2FsbCcuIEluIHRoYXQgY2FzZSwgd2VcbiAqICAgICAgIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICBzdWJPcHRpb24gIG9wdGlvbiB3aXRoaW4gb2JqZWN0ICdjaG9zZW4nIHRvIGNvbnNpZGVyOyBlaXRoZXIgJ25vZGUnLCAnZWRnZScgb3IgJ2xhYmVsJ1xuICogQHBhcmFtIHtvYmplY3R9ICBwaWxlICAgICAgIGFycmF5IG9mIG9wdGlvbnMgb2JqZWN0cyB0byBjb25zaWRlclxuICogQHJldHVybnMge2Jvb2xlYW4gfCBGdW5jdGlvbn0gIHZhbHVlIGZvciBwYXNzZWQgc3ViT3B0aW9uIG9mICdjaG9zZW4nIHRvIHVzZVxuICovXG5cbmZ1bmN0aW9uIGNob29zaWZ5KHN1Yk9wdGlvbiwgcGlsZSkge1xuICAvLyBhbGxvd2VkIHZhbHVlcyBmb3Igc3ViT3B0aW9uXG4gIHZhciBhbGxvd2VkID0gW1wibm9kZVwiLCBcImVkZ2VcIiwgXCJsYWJlbFwiXTtcbiAgdmFyIHZhbHVlID0gdHJ1ZTtcbiAgdmFyIGNob3NlbiA9IHRvcE1vc3QocGlsZSwgXCJjaG9zZW5cIik7XG5cbiAgaWYgKHR5cGVvZiBjaG9zZW4gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgdmFsdWUgPSBjaG9zZW47XG4gIH0gZWxzZSBpZiAoX3R5cGVvZihjaG9zZW4pID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKGluZGV4T2YoYWxsb3dlZCkuY2FsbChhbGxvd2VkLCBzdWJPcHRpb24pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hvb3NpZnk6IHN1Yk9wdGlvbiAnXCIgKyBzdWJPcHRpb24gKyBcIicgc2hvdWxkIGJlIG9uZSBvZiBcIiArIFwiJ1wiICsgYWxsb3dlZC5qb2luKFwiJywgJ1wiKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICB2YXIgY2hvc2VuRWRnZSA9IHRvcE1vc3QocGlsZSwgW1wiY2hvc2VuXCIsIHN1Yk9wdGlvbl0pO1xuXG4gICAgaWYgKHR5cGVvZiBjaG9zZW5FZGdlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgY2hvc2VuRWRnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YWx1ZSA9IGNob3NlbkVkZ2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcG9pbnQgZmFsbHMgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGUuXG4gKlxuICogQHBhcmFtIHtyZWN0fSByZWN0XG4gKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICogQHBhcmFtIHtyb3RhdGlvblBvaW50fSBbcm90YXRpb25Qb2ludF0gaWYgc3BlY2lmaWVkLCB0aGUgcm90YXRpb24gdGhhdCBhcHBsaWVzIHRvIHRoZSByZWN0YW5nbGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gIHRydWUgaWYgcG9pbnQgd2l0aGluIHJlY3RhbmdsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblxuZnVuY3Rpb24gcG9pbnRJblJlY3QocmVjdCwgcG9pbnQsIHJvdGF0aW9uUG9pbnQpIHtcbiAgaWYgKHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBlYXJseSBvdXRcbiAgfVxuXG4gIGlmIChyb3RhdGlvblBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBSb3RhdGUgdGhlIHBvaW50IHRoZSBzYW1lIGFtb3VudCBhcyB0aGUgcmVjdGFuZ2xlXG4gICAgdmFyIHRtcCA9IHtcbiAgICAgIHg6IHBvaW50LnggLSByb3RhdGlvblBvaW50LngsXG4gICAgICB5OiBwb2ludC55IC0gcm90YXRpb25Qb2ludC55XG4gICAgfTtcblxuICAgIGlmIChyb3RhdGlvblBvaW50LmFuZ2xlICE9PSAwKSB7XG4gICAgICAvLyBJbiBvcmRlciB0byBnZXQgdGhlIGNvb3JkaW5hdGVzIHRoZSBzYW1lLCB5b3UgbmVlZCB0b1xuICAgICAgLy8gcm90YXRlIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgdmFyIGFuZ2xlID0gLXJvdGF0aW9uUG9pbnQuYW5nbGU7XG4gICAgICB2YXIgdG1wMiA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogdG1wLnggLSBNYXRoLnNpbihhbmdsZSkgKiB0bXAueSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogdG1wLnggKyBNYXRoLmNvcyhhbmdsZSkgKiB0bXAueVxuICAgICAgfTtcbiAgICAgIHBvaW50ID0gdG1wMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnQgPSB0bXA7XG4gICAgfSAvLyBOb3RlIHRoYXQgaWYgYSByb3RhdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSByZWN0YW5nbGUgY29vcmRpbmF0ZXNcbiAgICAvLyBhcmUgKipub3QqIHRoZSBmdWxsIGNhbnZhcyBjb29yZGluYXRlcy4gVGhleSBhcmUgcmVsYXRpdmUgdG8gdGhlXG4gICAgLy8gcm90YXRpb25Qb2ludC4gSGVuY2UsIHRoZSBwb2ludCBjb29yZGluYXRlcyBuZWVkIG5vdCBiZSB0cmFuc2xhdGVkXG4gICAgLy8gYmFjayBpbiB0aGlzIGNhc2UuXG5cbiAgfVxuXG4gIHZhciByaWdodCA9IHJlY3QueCArIHJlY3Qud2lkdGg7XG4gIHZhciBib3R0b20gPSByZWN0LnkgKyByZWN0LndpZHRoO1xuICByZXR1cm4gcmVjdC5sZWZ0IDwgcG9pbnQueCAmJiByaWdodCA+IHBvaW50LnggJiYgcmVjdC50b3AgPCBwb2ludC55ICYmIGJvdHRvbSA+IHBvaW50Lnk7XG59XG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIHZhbHVlIGlzIGFjY2VwdGFibGUgYXMgYSBsYWJlbCB0ZXh0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCB2YWx1ZSB0byBjaGVjazsgY2FuIGJlIGFueXRoaW5nIGF0IHRoaXMgcG9pbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbGlkIGxhYmVsIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkTGFiZWwodGV4dCkge1xuICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBxdWl0ZSBzdHJpY3Q6IHR5cGVzIHRoYXQgKm1pZ2h0KiBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5nIGFyZSBkaXNhbGxvd2VkXG4gIHJldHVybiB0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0ZXh0ICE9PSBcIlwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHgsIHkgb2Ygc2VsZiByZWZlcmVuY2UgY2lyY2xlIGJhc2VkIG9uIHByb3ZpZGVkIGFuZ2xlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGN0eFxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gKiBAcGFyYW0ge1Zpc05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IHggYW5kIHkgY29vcmRpbmF0ZXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCBhbmdsZSwgcmFkaXVzLCBub2RlKSB7XG4gIHZhciB4ID0gbm9kZS54O1xuICB2YXIgeSA9IG5vZGUueTtcblxuICBpZiAodHlwZW9mIG5vZGUuZGlzdGFuY2VUb0JvcmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy9jYWxjdWxhdGluZyBvcHBvc2l0ZSBhbmQgYWRqYWNlbnRcbiAgICAvL2Rpc3RhbmVUb0JvcmRlciBiZWNvbWVzIEh5cG90ZW51c2UuXG4gICAgLy9Gb3JtdWxhcyBzaW4oYSkgPSBPcHBvc2l0ZSAvIEh5cG90ZW51c2UgYW5kIGNvcyhhKSA9IEFkamFjZW50IC8gSHlwb3RlbnVzZVxuICAgIHZhciB0b0JvcmRlckRpc3QgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgdmFyIHlGcm9tTm9kZUNlbnRlciA9IE1hdGguc2luKGFuZ2xlKSAqIHRvQm9yZGVyRGlzdDtcbiAgICB2YXIgeEZyb21Ob2RlQ2VudGVyID0gTWF0aC5jb3MoYW5nbGUpICogdG9Cb3JkZXJEaXN0OyAvL3hGcm9tTm9kZUNlbnRlciBpcyBiYXNpY2FsbHkgeCBhbmQgaWYgeEZyb21Ob2RlQ2VudGVyIGVxdWFscyB0byB0aGUgZGlzdGFuY2UgdG8gYm9yZGVyIHRoZW4gaXQgbWVhbnNcbiAgICAvL3RoYXQgeSBkb2VzIG5vdCBuZWVkIGNhbGN1bGF0aW9uIGJlY2F1c2UgaXQgaXMgZXF1YWwgbm9kZS5oZWlnaHQgLyAyIG9yIG5vZGUueVxuICAgIC8vc2FtZSB0aGluZyB3aXRoIHlGcm9tTm9kZUNlbnRlciBhbmQgaWYgeUZyb21Ob2RlQ2VudGVyIGVxdWFscyB0byB0aGUgZGlzdGFuY2UgdG8gYm9yZGVyIHRoZW4gaXQgbWVhbnNcbiAgICAvL3RoYXQgeCBpcyBlcXVhbCBub2RlLndpZHRoIC8gMiBvciBub2RlLnhcblxuICAgIGlmICh4RnJvbU5vZGVDZW50ZXIgPT09IHRvQm9yZGVyRGlzdCkge1xuICAgICAgeCArPSB0b0JvcmRlckRpc3Q7XG4gICAgICB5ID0gbm9kZS55O1xuICAgIH0gZWxzZSBpZiAoeUZyb21Ob2RlQ2VudGVyID09PSB0b0JvcmRlckRpc3QpIHtcbiAgICAgIHggPSBub2RlLng7XG4gICAgICB5IC09IHRvQm9yZGVyRGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSB4RnJvbU5vZGVDZW50ZXI7XG4gICAgICB5IC09IHlGcm9tTm9kZUNlbnRlcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5zaGFwZS53aWR0aCA+IG5vZGUuc2hhcGUuaGVpZ2h0KSB7XG4gICAgeCA9IG5vZGUueCArIG5vZGUuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgeSA9IG5vZGUueSAtIHJhZGl1cztcbiAgfSBlbHNlIHtcbiAgICB4ID0gbm9kZS54ICsgcmFkaXVzO1xuICAgIHkgPSBub2RlLnkgLSBub2RlLnNoYXBlLmhlaWdodCAqIDAuNTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHRleHQgZGltZW5zaW9ucywgdXNpbmcgdGhlIHBhcmVudCBsYWJlbCBzZXR0aW5ncy5cbiAqXG4gKiBAY2FsbGJhY2sgTWVhc3VyZVRleHRcbiAqIEBwYXJhbSB7dGV4dH0gdGV4dFxuICogQHBhcmFtIHt0ZXh0fSBtb2RcbiAqIEByZXR1cm5zIHtvYmplY3R9IHsgd2lkdGgsIHZhbHVlc30gd2lkdGggaW4gcGl4ZWxzIGFuZCBmb250IGF0dHJpYnV0ZXNcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgTGFiZWwgd2hpY2ggY29sbGVjdHMgcmVzdWx0cyBvZiBzcGxpdHRpbmcgbGFiZWxzIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge01lYXN1cmVUZXh0fSBtZWFzdXJlVGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxBY2N1bXVsYXRvcihtZWFzdXJlVGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbEFjY3VtdWxhdG9yKTtcblxuICAgIHRoaXMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbiAgICB0aGlzLmN1cnJlbnQgPSAwO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBnaXZlbiB0ZXh0IHRvIHRoZSBnaXZlbiBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gIGwgICAgaW5kZXggb2YgbGluZSB0byBhZGQgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0ZXh0IHN0cmluZyB0byBhcHBlbmQgdG8gbGluZVxuICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExhYmVsQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcIl9hZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZChsLCB0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIm5vcm1hbFwiO1xuXG4gICAgICBpZiAodGhpcy5saW5lc1tsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGluZXNbbF0gPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIGJsb2NrczogW11cbiAgICAgICAgfTtcbiAgICAgIH0gLy8gV2Ugc3RpbGwgbmVlZCB0byBzZXQgYSBibG9jayBmb3IgdW5kZWZpbmVkIGFuZCBlbXB0eSB0ZXh0cywgaGVuY2UgcmV0dXJuIGF0IHRoaXMgcG9pbnRcbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBhdCB0aGlzIHBvaW50IGlmIHdlJ3JlIGF0IHRoZVxuICAgICAgLy8gc3RhcnQgb2YgYW4gZW1wdHkgbGluZSBvciBub3QuXG4gICAgICAvLyBUbyBjb21wZW5zYXRlLCBlbXB0eSBibG9ja3MgYXJlIHJlbW92ZWQgaW4gYGZpbmFsaXplKClgLlxuICAgICAgLy9cbiAgICAgIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIHN0aWxsIGhhdmUgYSBoZWlnaHRcblxuXG4gICAgICB2YXIgdG1wVGV4dCA9IHRleHQ7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09IFwiXCIpIHRtcFRleHQgPSBcIiBcIjsgLy8gRGV0ZXJtaW5lIHdpZHRoIGFuZCBnZXQgdGhlIGZvbnQgcHJvcGVydGllc1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5tZWFzdXJlVGV4dCh0bXBUZXh0LCBtb2QpO1xuXG4gICAgICB2YXIgYmxvY2sgPSBhc3NpZ24kMih7fSwgdmFsdWVzKHJlc3VsdCkpO1xuXG4gICAgICBibG9jay50ZXh0ID0gdGV4dDtcbiAgICAgIGJsb2NrLndpZHRoID0gcmVzdWx0LndpZHRoO1xuICAgICAgYmxvY2subW9kID0gbW9kO1xuXG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgYmxvY2sud2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpbmVzW2xdLmJsb2Nrcy5wdXNoKGJsb2NrKTsgLy8gVXBkYXRlIHRoZSBsaW5lIHdpZHRoLiBXZSBuZWVkIHRoaXMgZm9yIGRldGVybWluaW5nIGlmIGEgc3RyaW5nIGdvZXMgb3ZlciBtYXggd2lkdGhcblxuICAgICAgdGhpcy5saW5lc1tsXS53aWR0aCArPSBibG9jay53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VyV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VyV2lkdGgoKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy5jdXJyZW50XTtcbiAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIGxpbmUud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG5cbiAgICAgIHRoaXMuX2FkZCh0aGlzLmN1cnJlbnQsIHRleHQsIG1vZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZSBhbmQgc3RhcnQgYSBuZXcgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0xpbmUodGV4dCkge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJub3JtYWxcIjtcblxuICAgICAgdGhpcy5fYWRkKHRoaXMuY3VycmVudCwgdGV4dCwgbW9kKTtcblxuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbmQgc2V0IHRoZSBoZWlnaHRzIG9mIGFsbCB0aGUgbGluZXMgY3VycmVudGx5IGNvbnRhaW5lZCBpbiB0aGlzIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2lkdGggaGFzIGFscmVhZHkgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lTGluZUhlaWdodHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGluZUhlaWdodHMoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdOyAvLyBMb29raW5nIGZvciBtYXggaGVpZ2h0IG9mIGJsb2NrcyBpbiBsaW5lXG5cbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBDYW4gaGFwcGVuIGlmIHRleHQgY29udGFpbnMgZS5nLiAnXFxuICdcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tsXTtcblxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IGJsb2NrLmhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBibG9jay5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZnVsbCBzaXplIG9mIHRoZSBsYWJlbCB0ZXh0LCBhcyBkZXRlcm1pbmVkIGJ5IGN1cnJlbnQgbGluZXMgYW5kIGJsb2Nrc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUxhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVMYWJlbFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5saW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNba107XG5cbiAgICAgICAgaWYgKGxpbmUud2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodCArPSBsaW5lLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZW1wdHkgYmxvY2tzIGFuZCBlbXB0eSBsaW5lcyB3ZSBkb24ndCBuZWVkXG4gICAgICpcbiAgICAgKiBUaGlzIG11c3QgYmUgZG9uZSBhZnRlciB0aGUgd2lkdGgvaGVpZ2h0IGRldGVybWluYXRpb24sXG4gICAgICogc28gdGhhdCB0aGVzZSBhcmUgc2V0IHByb3Blcmx5IGZvciBwcm9jZXNzaW5nIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8TGluZT59IExpbmVzIHdpdGggZW1wdHkgYmxvY2tzIChhbmQgc29tZSBlbXB0eSBsaW5lcykgcmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFbXB0eUJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFbXB0eUJsb2NrcygpIHtcbiAgICAgIHZhciB0bXBMaW5lcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdOyAvLyBOb3RlOiBhbiBlbXB0eSBsaW5lIGluIGJldHdlZW4gdGV4dCBoYXMgd2lkdGggemVybyBidXQgaXMgc3RpbGwgcmVsZXZhbnQgdG8gbGF5b3V0LlxuICAgICAgICAvLyBTbyB3ZSBjYW4ndCB1c2Ugd2lkdGggZm9yIHRlc3RpbmcgZW1wdHkgbGluZSBoZXJlXG5cbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzLmxlbmd0aCA9PT0gMCkgY29udGludWU7IC8vIERpc2NhcmQgZmluYWwgZW1wdHkgbGluZSBhbHdheXNcblxuICAgICAgICBpZiAoayA9PT0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkdGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcExpbmUgPSB7fTtcblxuICAgICAgICBhc3NpZ24kMih0bXBMaW5lLCBsaW5lKTtcblxuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IFtdO1xuICAgICAgICB2YXIgZmlyc3RFbXB0eUJsb2NrID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG1wQmxvY2tzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuXG4gICAgICAgICAgaWYgKGJsb2NrLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICB0bXBCbG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaXJzdEVtcHR5QmxvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmaXJzdEVtcHR5QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgKnNvbWUqIHRleHQgcHJlc2VudFxuXG5cbiAgICAgICAgaWYgKHRtcEJsb2Nrcy5sZW5ndGggPT09IDAgJiYgZmlyc3RFbXB0eUJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0bXBCbG9ja3MucHVzaChmaXJzdEVtcHR5QmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wTGluZS5ibG9ja3MgPSB0bXBCbG9ja3M7XG4gICAgICAgIHRtcExpbmVzLnB1c2godG1wTGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0bXBMaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplcyBmb3IgYWxsIGxpbmVzIGFuZCB0aGUgd2hvbGUgdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyfCopLCBoZWlnaHQ6IChudW1iZXJ8KiksIGxpbmVzOiBBcnJheX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodGhpcy5saW5lcywgbnVsbCwgMikpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMaW5lSGVpZ2h0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMYWJlbFNpemUoKTtcbiAgICAgIHZhciB0bXBMaW5lcyA9IHRoaXMucmVtb3ZlRW1wdHlCbG9ja3MoKTsgLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggb2JqZWN0IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBsaW5lczogdG1wTGluZXNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhYmVsQWNjdW11bGF0b3I7XG59KCk7XG5cbnZhciB0YWdQYXR0ZXJuID0ge1xuICAvLyBIVE1MXG4gIFwiPGI+XCI6IC88Yj4vLFxuICBcIjxpPlwiOiAvPGk+LyxcbiAgXCI8Y29kZT5cIjogLzxjb2RlPi8sXG4gIFwiPC9iPlwiOiAvPFxcL2I+LyxcbiAgXCI8L2k+XCI6IC88XFwvaT4vLFxuICBcIjwvY29kZT5cIjogLzxcXC9jb2RlPi8sXG4gIC8vIE1hcmtkb3duXG4gIFwiKlwiOiAvXFwqLyxcbiAgLy8gYm9sZFxuICBfOiAvXy8sXG4gIC8vIGl0YWxcbiAgXCJgXCI6IC9gLyxcbiAgLy8gbW9ub1xuICBhZnRlckJvbGQ6IC9bXipdLyxcbiAgYWZ0ZXJJdGFsOiAvW15fXS8sXG4gIGFmdGVyTW9ubzogL1teYF0vXG59O1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgY2xhc3MgZm9yIHBhcnNpbmcgdGhlIG1hcmt1cCB0YWdzIGZvciBIVE1MIGFuZCBNYXJrZG93bi5cbiAqXG4gKiBOT1RFOiBTZXF1ZW5jZXMgb2YgdGFicyBhbmQgc3BhY2VzIGFyZSByZWR1Y2VkIHRvIHNpbmdsZSBzcGFjZS5cbiAqICAgICAgIFNjYW4gdXNhZ2Ugb2YgYHRoaXMuc3BhY2luZ2Agd2l0aGluIG1ldGhvZFxuICovXG5cbnZhciBNYXJrdXBBY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gcGFyc2UgZm9yIG1hcmt1cFxuICAgKi9cbiAgZnVuY3Rpb24gTWFya3VwQWNjdW11bGF0b3IodGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrdXBBY2N1bXVsYXRvcik7XG5cbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuYm9sZCA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbCA9IGZhbHNlO1xuICAgIHRoaXMubW9ubyA9IGZhbHNlO1xuICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLm1vZFN0YWNrID0gW107XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICBsYWJlbCBvZiB0b3Btb3N0IG1vZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNYXJrdXBBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwibW9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZFN0YWNrLmxlbmd0aCA9PT0gMCA/IFwibm9ybWFsXCIgOiB0aGlzLm1vZFN0YWNrWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1vZCBsYWJlbCBjdXJyZW50bHkgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgbGFiZWwgb2YgYWN0aXZlIG1vZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb2ROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vZE5hbWUoKSB7XG4gICAgICBpZiAodGhpcy5tb2RTdGFjay5sZW5ndGggPT09IDApIHJldHVybiBcIm5vcm1hbFwiO2Vsc2UgaWYgKHRoaXMubW9kU3RhY2tbMF0gPT09IFwibW9ub1wiKSByZXR1cm4gXCJtb25vXCI7ZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmJvbGQgJiYgdGhpcy5pdGFsKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYm9sZGl0YWxcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJvbGQpIHtcbiAgICAgICAgICByZXR1cm4gXCJib2xkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pdGFsKSB7XG4gICAgICAgICAgcmV0dXJuIFwiaXRhbFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0QmxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdEJsb2NrKCkge1xuICAgICAgaWYgKHRoaXMuc3BhY2luZykge1xuICAgICAgICB0aGlzLmFkZChcIiBcIik7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLmJ1ZmZlcixcbiAgICAgICAgICBtb2Q6IHRoaXMubW9kTmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91dHB1dCB0ZXh0IHRvIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gYWRkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gXCIgXCI7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCAhPSBcIiBcIikge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGFyc2luZyBvZiB3aGl0ZXNwYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2ggIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIHdhcyBwcm9jZXNzZWQgYXMgd2hpdGVzcGFjZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVdTXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlV1MoY2gpIHtcbiAgICAgIGlmICgvWyBcXHRdLy50ZXN0KGNoKSkge1xuICAgICAgICBpZiAoIXRoaXMubW9ubykge1xuICAgICAgICAgIHRoaXMuc3BhY2luZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGQoY2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGFnKHRhZ05hbWUpIHtcbiAgICAgIHRoaXMuZW1pdEJsb2NrKCk7XG4gICAgICB0aGlzW3RhZ05hbWVdID0gdHJ1ZTtcbiAgICAgIHRoaXMubW9kU3RhY2sudW5zaGlmdCh0YWdOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHVuc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc2V0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2V0VGFnKHRhZ05hbWUpIHtcbiAgICAgIHRoaXMuZW1pdEJsb2NrKCk7XG4gICAgICB0aGlzW3RhZ05hbWVdID0gZmFsc2U7XG4gICAgICB0aGlzLm1vZFN0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIGxhYmVsIGZvciBibG9jayB0eXBlIHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlU3RhcnRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTdGFydFRhZyh0YWdOYW1lLCB0YWcpIHtcbiAgICAgIC8vIE5vdGU6IGlmICdtb25vJyBwYXNzZWQgYXMgdGFnTmFtZSwgdGhlcmUgaXMgYSBkb3VibGUgY2hlY2sgaGVyZS4gVGhpcyBpcyBPS1xuICAgICAgaWYgKCF0aGlzLm1vbm8gJiYgIXRoaXNbdGFnTmFtZV0gJiYgdGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIHRoaXMuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWR2YW5jZT10cnVlXSBpZiBzZXQsIGFkdmFuY2UgY3VycmVudCBwb3NpdGlvbiBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbWF0Y2ggYXQgZ2l2ZW4gcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaCh0YWcpIHtcbiAgICAgIHZhciBhZHZhbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICB2YXIgX3RoaXMkcHJlcGFyZVJlZ0V4cCA9IHRoaXMucHJlcGFyZVJlZ0V4cCh0YWcpLFxuICAgICAgICAgIF90aGlzJHByZXBhcmVSZWdFeHAyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcHJlcGFyZVJlZ0V4cCwgMiksXG4gICAgICAgICAgcmVnRXhwID0gX3RoaXMkcHJlcGFyZVJlZ0V4cDJbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gX3RoaXMkcHJlcGFyZVJlZ0V4cDJbMV07XG5cbiAgICAgIHZhciBtYXRjaGVkID0gcmVnRXhwLnRlc3QodGhpcy50ZXh0LnN1YnN0cih0aGlzLnBvc2l0aW9uLCBsZW5ndGgpKTtcblxuICAgICAgaWYgKG1hdGNoZWQgJiYgYWR2YW5jZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBsYWJlbCBmb3IgYmxvY2sgdHlwZSB3ZSBhcmUgY3VycmVudGx5IHByb2Nlc3NpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbbmV4dFRhZ10gcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGZvciBjaGFyYWN0ZXJzICpmb2xsb3dpbmcqIHRoZSBjdXJyZW50IHRhZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0YWcgd2FzIHByb2Nlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUVuZFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWdOYW1lLCB0YWcsIG5leHRUYWcpIHtcbiAgICAgIHZhciBjaGVja1RhZyA9IHRoaXMubW9kKCkgPT09IHRhZ05hbWU7XG5cbiAgICAgIGlmICh0YWdOYW1lID09PSBcIm1vbm9cIikge1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAnbW9ubydcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiB0aGlzLm1vbm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja1RhZyA9IGNoZWNrVGFnICYmICF0aGlzLm1vbm87XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja1RhZyAmJiB0aGlzLm1hdGNoKHRhZykpIHtcbiAgICAgICAgaWYgKG5leHRUYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFB1cnBvc2Ugb2YgdGhlIGZvbGxvd2luZyBtYXRjaCBpcyB0byBwcmV2ZW50IGEgZGlyZWN0IHVuc2V0L3NldCBvZiBhIGdpdmVuIHRhZ1xuICAgICAgICAgIC8vIEUuZy4gJypib2xkICoqc3RpbGwgYm9sZConID0+ICcqYm9sZCBzdGlsbCBib2xkKidcbiAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gdGhpcy50ZXh0Lmxlbmd0aCAtIDEgfHwgdGhpcy5tYXRjaChuZXh0VGFnLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMudW5zZXRUYWcodGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudW5zZXRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSAgc3RyaW5nIHRvIHJlcGxhY2UgdGFnIHdpdGgsIGlmIGZvdW5kIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRhZywgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHRhZykpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHRhZyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgYFtSZWdFeHAsIG51bWJlcl1gLCB3aXRoIGV4YWN0bHkgdHdvIHZhbHVlLCB3aGVyZTpcbiAgICAgKiAgLSBSZWdFeHAgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2VcbiAgICAgKiAgLSBudW1iZXIgaXMgdGhlIGxlbnRoIG9mIHRoZSBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgYW5kIGxlbmd0aCBvZiBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZVJlZ0V4cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlUmVnRXhwKHRhZykge1xuICAgICAgdmFyIGxlbmd0aDtcbiAgICAgIHZhciByZWdFeHA7XG5cbiAgICAgIGlmICh0YWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmVnRXhwID0gdGFnO1xuICAgICAgICBsZW5ndGggPSAxOyAvLyBBU1NVTVBUSU9OOiByZWdleHAgb25seSB0ZXN0cyBvbmUgY2hhcmFjdGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgcHJlcGFyZWQgcmVnZXhwIGlmIHByZXNlbnRcbiAgICAgICAgdmFyIHByZXBhcmVkID0gdGFnUGF0dGVyblt0YWddO1xuXG4gICAgICAgIGlmIChwcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVnRXhwID0gcHJlcGFyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cCh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyZWdFeHAsIGxlbmd0aF07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcmt1cEFjY3VtdWxhdG9yO1xufSgpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIExhYmVsIHdoaWNoIGV4cGxvZGVzIHRoZSBsYWJlbCB0ZXh0IGludG8gbGluZXMgYW5kIGJsb2NrcyB3aXRoaW4gbGluZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIExhYmVsU3BsaXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtMYWJlbH0gcGFyZW50IHJlZmVyZW5jZSB0byB0aGUgTGFiZWwgaW5zdGFuY2UgdXNpbmcgY3VycmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG4gIGZ1bmN0aW9uIExhYmVsU3BsaXR0ZXIoY3R4LCBwYXJlbnQsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWxTcGxpdHRlcik7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgdGhpcy5ob3ZlciA9IGhvdmVyO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGRldGVybWluZSB0ZXh0IHdpZHRoOyBwYXNzZWQgdG8gTGFiZWxBY2N1bXVsYXRvciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IHN0cmluZyB0byBkZXRlcm1pbmUgd2lkdGggb2ZcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG1vZCAgZm9udCB0eXBlIHRvIHVzZSBmb3IgdGhpcyB0ZXh0XG4gICAgICogQHJldHVybnMge29iamVjdH0geyB3aWR0aCwgdmFsdWVzfSB3aWR0aCBpbiBwaXhlbHMgYW5kIGZvbnQgYXR0cmlidXRlc1xuICAgICAqL1xuXG4gICAgdmFyIHRleHRXaWR0aCA9IGZ1bmN0aW9uIHRleHRXaWR0aCh0ZXh0LCBtb2QpIHtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHJldHVybiAwOyAvLyBUT0RPOiBUaGlzIGNhbiBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkgd2l0aCBjYWNoaW5nXG4gICAgICAvLyBUaGlzIHdpbGwgc2V0IHRoZSBjdHguZm9udCBjb3JyZWN0bHksIGRlcGVuZGluZyBvbiBzZWxlY3RlZC9ob3ZlciBhbmQgbW9kIC0gc28gdGhhdCBjdHgubWVhc3VyZVRleHQoKSB3aWxsIGJlIGFjY3VyYXRlLlxuXG4gICAgICB2YXIgdmFsdWVzID0gX3RoaXMucGFyZW50LmdldEZvcm1hdHRpbmdWYWx1ZXMoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIG1vZCk7XG5cbiAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgIGlmICh0ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIHZhciBtZWFzdXJlID0gX3RoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuXG4gICAgICAgIHdpZHRoID0gbWVhc3VyZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5saW5lcyA9IG5ldyBMYWJlbEFjY3VtdWxhdG9yKHRleHRXaWR0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0IHBhc3NlZCB0ZXh0IG9mIGEgbGFiZWwgaW50byBsaW5lcyBhbmQgYmxvY2tzLlxuICAgKlxuICAgKiAjIE5PVEVcbiAgICpcbiAgICogVGhlIGhhbmRsaW5nIG9mIHNwYWNpbmcgaXMgb3B0aW9uIGRlcGVuZGVudDpcbiAgICpcbiAgICogLSBpZiBgZm9udC5tdWx0aSA6IGZhbHNlYCwgYWxsIHNwYWNlcyBhcmUgcmV0YWluZWRcbiAgICogLSBpZiBgZm9udC5tdWx0aSA6IHRydWVgLCBldmVyeSBzZXF1ZW5jZSBvZiBzcGFjZXMgaXMgY29tcHJlc3NlZCB0byBhIHNpbmdsZSBzcGFjZVxuICAgKlxuICAgKiBUaGlzIG1pZ2h0IG5vdCBiZSB0aGUgYmVzdCB3YXkgdG8gZG8gaXQsIGJ1dCB0aGlzIGlzIGFzIGl0IGhhcyBiZWVuIHdvcmtpbmcgdGlsbCBub3cuXG4gICAqIEluIG9yZGVyIG5vdCB0byBicmVhayBleGlzdGluZyBmdW5jdGlvbmFsaXR5LCBmb3IgdGhlIHRpbWUgYmVpbmcgdGhpcyBiZWhhdmlvdXIgd2lsbFxuICAgKiBiZSByZXRhaW5lZCBpbiBhbnkgY29kZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgdGV4dCB0byBzcGxpdFxuICAgKiBAcmV0dXJucyB7QXJyYXk8bGluZT59XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExhYmVsU3BsaXR0ZXIsIFt7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyh0ZXh0KSB7XG4gICAgICBpZiAoIWlzVmFsaWRMYWJlbCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lcy5maW5hbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udCA9IHRoaXMucGFyZW50LmZvbnRPcHRpb25zOyAvLyBOb3JtYWxpemUgdGhlIGVuZC1vZi1saW5lJ3MgdG8gYSBzaW5nbGUgcmVwcmVzZW50YXRpb24gLSBvcmRlciBpbXBvcnRhbnRcblxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpOyAvLyBEb3MgRU9MJ3NcblxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpOyAvLyBNYWMgRU9MJ3NcbiAgICAgIC8vIE5vdGUgdGhhdCBhdCB0aGlzIHBvaW50LCB0aGVyZSBjYW4gYmUgbm8gXFxyJ3MgaW4gdGhlIHRleHQuXG4gICAgICAvLyBUaGlzIGlzIHVzZWQgbGF0ZXIgb24gc3BsaXRTdHJpbmdJbnRvTGluZXMoKSB0byBzcGxpdCBtdWx0aWZvbnQgdGV4dHMuXG5cbiAgICAgIHZhciBubExpbmVzID0gU3RyaW5nKHRleHQpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgdmFyIGxpbmVDb3VudCA9IG5sTGluZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZm9udC5tdWx0aSkge1xuICAgICAgICAvLyBNdWx0aS1mb250IGNhc2U6IHN0eWxpbmcgdGFncyBhY3RpdmVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgIHZhciBibG9ja3MgPSB0aGlzLnNwbGl0QmxvY2tzKG5sTGluZXNbaV0sIGZvbnQubXVsdGkpOyAvLyBQb3N0OiBTZXF1ZW5jZXMgb2YgdGFicyBhbmQgc3BhY2VzIGFyZSByZWR1Y2VkIHRvIHNpbmdsZSBzcGFjZVxuXG4gICAgICAgICAgaWYgKGJsb2NrcyA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoXCJcIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm9udC5tYXhXZHQgPiAwKSB7XG4gICAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBkZWZpbmVkXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdSdW5uaW5nIHdpZHRoQ29uc3RyYWludCBtdWx0aSwgbWF4OiAnICsgdGhpcy5mb250T3B0aW9ucy5tYXhXZHQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBibG9ja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIG1vZCA9IGJsb2Nrc1tqXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dCA9IGJsb2Nrc1tqXS50ZXh0O1xuICAgICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nSW50b0xpbmVzKF90ZXh0LCBtb2QsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBOT1QgZGVmaW5lZFxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGJsb2Nrcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9tb2QgPSBibG9ja3NbX2pdLm1vZDtcbiAgICAgICAgICAgICAgdmFyIF90ZXh0MiA9IGJsb2Nrc1tfal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5saW5lcy5hcHBlbmQoX3RleHQyLCBfbW9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luZ2xlLWZvbnQgY2FzZVxuICAgICAgICBpZiAoZm9udC5tYXhXZHQgPiAwKSB7XG4gICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gZGVmaW5lZFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSdW5uaW5nIHdpZHRoQ29uc3RyYWludCBub3JtYWwsIG1heDogJyArIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0KTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGluZUNvdW50OyBfaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nSW50b0xpbmVzKG5sTGluZXNbX2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gTk9UIGRlZmluZWRcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsaW5lQ291bnQ7IF9pMisrKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUobmxMaW5lc1tfaTJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubGluZXMuZmluYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbm9ybWFsaXplIHRoZSBtYXJrdXAgc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZU1hcmt1cFN5c3RlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVNYXJrdXBTeXN0ZW0obWFya3VwU3lzdGVtKSB7XG4gICAgICB2YXIgc3lzdGVtID0gXCJub25lXCI7XG5cbiAgICAgIGlmIChtYXJrdXBTeXN0ZW0gPT09IFwibWFya2Rvd25cIiB8fCBtYXJrdXBTeXN0ZW0gPT09IFwibWRcIikge1xuICAgICAgICBzeXN0ZW0gPSBcIm1hcmtkb3duXCI7XG4gICAgICB9IGVsc2UgaWYgKG1hcmt1cFN5c3RlbSA9PT0gdHJ1ZSB8fCBtYXJrdXBTeXN0ZW0gPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIHN5c3RlbSA9IFwiaHRtbFwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3lzdGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRIdG1sQmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0SHRtbEJsb2Nrcyh0ZXh0KSB7XG4gICAgICB2YXIgcyA9IG5ldyBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KTtcblxuICAgICAgdmFyIHBhcnNlRW50aXRpZXMgPSBmdW5jdGlvbiBwYXJzZUVudGl0aWVzKGNoKSB7XG4gICAgICAgIGlmICgvJi8udGVzdChjaCkpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gcy5yZXBsYWNlKHMudGV4dCwgXCImbHQ7XCIsIFwiPFwiKSB8fCBzLnJlcGxhY2Uocy50ZXh0LCBcIiZhbXA7XCIsIFwiJlwiKTtcblxuICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICBzLmFkZChcIiZcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHMucGFyc2VXUyhjaCkgfHwgLzwvLnRlc3QoY2gpICYmIChzLnBhcnNlU3RhcnRUYWcoXCJib2xkXCIsIFwiPGI+XCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIml0YWxcIiwgXCI8aT5cIikgfHwgcy5wYXJzZVN0YXJ0VGFnKFwibW9ub1wiLCBcIjxjb2RlPlwiKSB8fCBzLnBhcnNlRW5kVGFnKFwiYm9sZFwiLCBcIjwvYj5cIikgfHwgcy5wYXJzZUVuZFRhZyhcIml0YWxcIiwgXCI8L2k+XCIpIHx8IHMucGFyc2VFbmRUYWcoXCJtb25vXCIsIFwiPC9jb2RlPlwiKSkgfHwgcGFyc2VFbnRpdGllcyhjaCk7XG5cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICBzLmFkZChjaCk7XG4gICAgICAgIH1cblxuICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICB9XG5cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdE1hcmtkb3duQmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0TWFya2Rvd25CbG9ja3ModGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzID0gbmV3IE1hcmt1cEFjY3VtdWxhdG9yKHRleHQpO1xuICAgICAgdmFyIGJlZ2luYWJsZSA9IHRydWU7XG5cbiAgICAgIHZhciBwYXJzZU92ZXJyaWRlID0gZnVuY3Rpb24gcGFyc2VPdmVycmlkZShjaCkge1xuICAgICAgICBpZiAoL1xcXFwvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgaWYgKHMucG9zaXRpb24gPCBfdGhpczIudGV4dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICAgICAgICBjaCA9IF90aGlzMi50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYgKC8gXFx0Ly50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICBzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICAgICAgICBiZWdpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChzLnBvc2l0aW9uIDwgcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBzLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuICAgICAgICB2YXIgcGFyc2VkID0gcy5wYXJzZVdTKGNoKSB8fCBwYXJzZU92ZXJyaWRlKGNoKSB8fCAoYmVnaW5hYmxlIHx8IHMuc3BhY2luZykgJiYgKHMucGFyc2VTdGFydFRhZyhcImJvbGRcIiwgXCIqXCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIml0YWxcIiwgXCJfXCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIm1vbm9cIiwgXCJgXCIpKSB8fCBzLnBhcnNlRW5kVGFnKFwiYm9sZFwiLCBcIipcIiwgXCJhZnRlckJvbGRcIikgfHwgcy5wYXJzZUVuZFRhZyhcIml0YWxcIiwgXCJfXCIsIFwiYWZ0ZXJJdGFsXCIpIHx8IHMucGFyc2VFbmRUYWcoXCJtb25vXCIsIFwiYFwiLCBcImFmdGVyTW9ub1wiKTtcblxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICBiZWdpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgIH1cblxuICAgICAgcy5lbWl0QmxvY2soKTtcbiAgICAgIHJldHVybiBzLmJsb2NrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwbG9kZXMgYSBwaWVjZSBvZiB0ZXh0IGludG8gc2luZ2xlLWZvbnQgYmxvY2tzIHVzaW5nIGEgZ2l2ZW4gbWFya3VwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnwnbWQnfCdtYXJrZG93bid8J2h0bWwnfSBtYXJrdXBTeXN0ZW1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt0ZXh0OiBzdHJpbmcsIG1vZDogc3RyaW5nfT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0QmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0QmxvY2tzKHRleHQsIG1hcmt1cFN5c3RlbSkge1xuICAgICAgdmFyIHN5c3RlbSA9IHRoaXMuZGVjb2RlTWFya3VwU3lzdGVtKG1hcmt1cFN5c3RlbSk7XG5cbiAgICAgIGlmIChzeXN0ZW0gPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgbW9kOiBcIm5vcm1hbFwiXG4gICAgICAgIH1dO1xuICAgICAgfSBlbHNlIGlmIChzeXN0ZW0gPT09IFwibWFya2Rvd25cIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdE1hcmtkb3duQmxvY2tzKHRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzeXN0ZW0gPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0SHRtbEJsb2Nrcyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0ZXh0IGxlbmd0aCBvdmVyIHRoZSBjdXJyZW50IG1heCB3aXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJNYXhXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVyTWF4V2lkdGgodGV4dCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICByZXR1cm4gdGhpcy5saW5lcy5jdXJXaWR0aCgpICsgd2lkdGggPiB0aGlzLnBhcmVudC5mb250T3B0aW9ucy5tYXhXZHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9uZ2VzdCBwYXJ0IG9mIHRoZSBzZW50ZW5jZSB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgIEFycmF5IG9mIHN0cmluZ3Mgc2lnbmlmeWluZyBhIHRleHQgbGluZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAgICAgIGluZGV4IG9mIGZpcnN0IGl0ZW0gaW4gc3RyaW5nIG1ha2luZyBzdHJpbmcgZ28gb3ZlciBtYXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9uZ2VzdEZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb25nZXN0Rml0KHdvcmRzKSB7XG4gICAgICB2YXIgdGV4dCA9IFwiXCI7XG4gICAgICB2YXIgdyA9IDA7XG5cbiAgICAgIHdoaWxlICh3IDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0ZXh0ID09PSBcIlwiID8gXCJcIiA6IFwiIFwiO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IHRleHQgKyBwcmUgKyB3b3Jkc1t3XTtcbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKG5ld1RleHQpKSBicmVhaztcbiAgICAgICAgdGV4dCA9IG5ld1RleHQ7XG4gICAgICAgIHcrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9uZ2VzdCBwYXJ0IG9mIHRoZSBzdHJpbmcgd2hpY2ggc3RpbGwgZml0cyBpbiB0aGVcbiAgICAgKiBjdXJyZW50IG1heCB3aWR0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIEFycmF5IG9mIHN0cmluZ3Mgc2lnbmlmeWluZyBhIHRleHQgbGluZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCBvZiBmaXJzdCBpdGVtIGluIHN0cmluZyBtYWtpbmcgc3RyaW5nIGdvIG92ZXIgbWF4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb25nZXN0Rml0V29yZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb25nZXN0Rml0V29yZCh3b3Jkcykge1xuICAgICAgdmFyIHcgPSAwO1xuXG4gICAgICB3aGlsZSAodyA8IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5vdmVyTWF4V2lkdGgoc2xpY2Uod29yZHMpLmNhbGwod29yZHMsIDAsIHcpKSkgYnJlYWs7XG4gICAgICAgIHcrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzLCBhY2NvcmRpbmcgdG8gd2lkdGggY29uc3RyYWludCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSBzaW5nbGUgbGluZSwgaS5lLiB3aXRob3V0IGxpbmVzIGJyZWFrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0YWlucyBzcGFjZXMsIGlmIHN0aWxsIHByZXNlbnQgKGNhc2UgYGZvbnQubXVsdGk6IGZhbHNlYCkuXG4gICAgICogQSBzcGFjZSB3aGljaCBmYWxscyBvbiBhbiBpbnRlcm5hbCBsaW5lIGJyZWFrLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgbmV3bGluZS5cbiAgICAgKiBUaGVyZSBpcyBubyBzcGVjaWFsIGhhbmRsaW5nIG9mIHRhYnM7IHRoZXNlIGdvIGFsb25nIHdpdGggdGhlIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2Q9J25vcm1hbCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXBwZW5kTGFzdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRTdHJpbmdJbnRvTGluZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRTdHJpbmdJbnRvTGluZXMoc3RyKSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIm5vcm1hbFwiO1xuICAgICAgdmFyIGFwcGVuZExhc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgLy8gU2V0IHRoZSBjYW52YXMgY29udGV4dCBmb250LCBiYXNlZCB1cG9uIHRoZSBjdXJyZW50IHNlbGVjdGVkL2hvdmVyIHN0YXRlXG4gICAgICAvLyBhbmQgdGhlIHByb3ZpZGVkIG1vZCwgc28gdGhlIHRleHQgbWVhc3VyZW1lbnQgcGVyZm9ybWVkIGJ5IGdldExvbmdlc3RGaXRcbiAgICAgIC8vIHdpbGwgYmUgYWNjdXJhdGUgLSBhbmQgbm90IGp1c3QgdXNlIHRoZSBmb250IG9mIHdob2V2ZXIgbGFzdCB1c2VkIHRoZSBjYW52YXMuXG4gICAgICB0aGlzLnBhcmVudC5nZXRGb3JtYXR0aW5nVmFsdWVzKHRoaXMuY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBtb2QpOyAvLyBTdGlsbC1wcmVzZW50IHNwYWNlcyBhcmUgcmVsZXZhbnQsIHJldGFpbiB0aGVtXG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKCArKS9nLCBcIiQxXFxyXCIpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbXlxccl1bXiBdKikoICspL2csIFwiJDFcXHIkMlxcclwiKTtcbiAgICAgIHZhciB3b3JkcyA9IHN0ci5zcGxpdChcIlxcclwiKTtcblxuICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldExvbmdlc3RGaXQod29yZHMpO1xuXG4gICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aGUgZmlyc3Qgd29yZCBpcyBhbHJlYWR5IGxhcmdlciB0aGFuIHRoZSBtYXggd2lkdGguXG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1swXTsgLy8gQnJlYWsgdGhlIHdvcmQgdG8gdGhlIGxhcmdlc3QgcGFydCB0aGF0IGZpdHMgdGhlIGxpbmVcblxuICAgICAgICAgIHZhciB4ID0gdGhpcy5nZXRMb25nZXN0Rml0V29yZCh3b3JkKTtcbiAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoc2xpY2Uod29yZCkuY2FsbCh3b3JkLCAwLCB4KSwgbW9kKTsgLy8gQWRqdXN0IHRoZSB3b3JkLCBzbyB0aGF0IHRoZSByZXN0IHdpbGwgYmUgZG9uZSBuZXh0IGl0ZXJhdGlvblxuXG4gICAgICAgICAgd29yZHNbMF0gPSBzbGljZSh3b3JkKS5jYWxsKHdvcmQsIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNraXAgYW55IHNwYWNlIHRoYXQgaXMgcmVwbGFjZWQgYnkgYSBuZXdsaW5lXG4gICAgICAgICAgdmFyIG5ld1cgPSB3O1xuXG4gICAgICAgICAgaWYgKHdvcmRzW3cgLSAxXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIHctLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdvcmRzW25ld1ddID09PSBcIiBcIikge1xuICAgICAgICAgICAgbmV3VysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0ZXh0ID0gc2xpY2Uod29yZHMpLmNhbGwod29yZHMsIDAsIHcpLmpvaW4oXCJcIik7XG5cbiAgICAgICAgICBpZiAodyA9PSB3b3Jkcy5sZW5ndGggJiYgYXBwZW5kTGFzdCkge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5hcHBlbmQodGV4dCwgbW9kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKHRleHQsIG1vZCk7XG4gICAgICAgICAgfSAvLyBBZGp1c3QgdGhlIHdvcmQsIHNvIHRoYXQgdGhlIHJlc3Qgd2lsbCBiZSBkb25lIG5leHQgaXRlcmF0aW9uXG5cblxuICAgICAgICAgIHdvcmRzID0gc2xpY2Uod29yZHMpLmNhbGwod29yZHMsIG5ld1cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhYmVsU3BsaXR0ZXI7XG59KCk7XG5cbi8qKlxuICogTGlzdCBvZiBzcGVjaWFsIHN0eWxlcyBmb3IgbXVsdGktZm9udHNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtdWx0aUZvbnRTdHlsZSA9IFtcImJvbGRcIiwgXCJpdGFsXCIsIFwiYm9sZGl0YWxcIiwgXCJtb25vXCJdO1xuLyoqXG4gKiBBIExhYmVsIHRvIGJlIHVzZWQgZm9yIE5vZGVzIG9yIEVkZ2VzLlxuICovXG5cbnZhciBMYWJlbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlZGdlbGFiZWw9ZmFsc2VdXG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbChib2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIGVkZ2VsYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWwpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvbnRPcHRpb25zID0ge307IC8vIGluc3RhbmNlIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlICppbnN0YW5jZS1sb2NhbCogZm9udCBvcHRpb25zXG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zaXplID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgeUxpbmU6IDBcbiAgICB9O1xuICAgIHRoaXMuaXNFZGdlTGFiZWwgPSBlZGdlbGFiZWw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBwYXJlbnQgTm9kZS1pbnN0YW5jZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhMYWJlbCwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZWxlbWVudE9wdGlvbnMgPSBvcHRpb25zOyAvLyBSZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBOb2RlLWluc3RhbmNlXG5cbiAgICAgIHRoaXMuaW5pdEZvbnRPcHRpb25zKG9wdGlvbnMuZm9udCk7XG5cbiAgICAgIGlmIChpc1ZhbGlkTGFiZWwob3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJhZCBsYWJlbCEgQ2hhbmdlIHRoZSBvcHRpb24gdmFsdWUgdG8gcHJldmVudCBiYWQgc3R1ZmYgaGFwcGVuaW5nXG4gICAgICAgIG9wdGlvbnMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZm9udCBvcHRpb25zIGNhbiBiZSBkZWxldGVkIGF0IHZhcmlvdXMgbGV2ZWxzXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMuZm9udCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuZm9udC5zaXplO1xuXG4gICAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IHNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIGZvbnQgT3B0aW9ucyBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBNZW1iZXIgZm9udE9wdGlvbnMgc2VydmVzIGFzIGFuIGFjY3VtdWxhdG9yIGZvciB0aGUgY3VycmVudCBmb250IG9wdGlvbnMuXG4gICAgICogQXMgc3VjaCwgaXQgbmVlZHMgdG8gYmUgY29tcGxldGVseSBzZXBhcmF0ZWQgZnJvbSB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld0ZvbnRPcHRpb25zIHRoZSBuZXcgZm9udCBvcHRpb25zIHRvIHByb2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdEZvbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRGb250T3B0aW9ucyhuZXdGb250T3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gUHJlcGFyZSB0aGUgbXVsdGktZm9udCBvcHRpb24gb2JqZWN0cy5cbiAgICAgIC8vIFRoZXNlIHdpbGwgYmUgZmlsbGVkIGluIHByb3BhZ2F0ZUZvbnRzKCksIGlmIHJlcXVpcmVkXG4gICAgICBmb3JFYWNoJDEobXVsdGlGb250U3R5bGUsIGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBfdGhpcy5mb250T3B0aW9uc1tzdHlsZV0gPSB7fTtcbiAgICAgIH0pOyAvLyBIYW5kbGUgc2hvcnRoYW5kIG9wdGlvbiwgaWYgcHJlc2VudFxuXG4gICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRoaXMuZm9udE9wdGlvbnMsIG5ld0ZvbnRPcHRpb25zKSkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLnZhZGp1c3QgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENvcHkgb3ZlciB0aGUgbm9uLW11bHRpZm9udCBvcHRpb25zLCBpZiBzcGVjaWZpZWRcblxuXG4gICAgICBmb3JFYWNoJDEobmV3Rm9udE9wdGlvbnMsIGZ1bmN0aW9uIChwcm9wLCBuKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSB1bmRlZmluZWQgJiYgcHJvcCAhPT0gbnVsbCAmJiBfdHlwZW9mKHByb3ApICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgX3RoaXMuZm9udE9wdGlvbnNbbl0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgaW4tdmFyaWFibGUgaXMgYSBzdHJpbmcsIHBhcnNlIGl0IGFzIGEgZm9udCBzcGVjaWZpZXIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgZm9sbG93aW5nIGlzIG5vdCBkb25lIGhlcmUgYW5kIGhhdmUgdG8gYmUgZG9uZSBhZnRlciB0aGUgY2FsbDpcbiAgICAgKiAtIE5vdCBhbGwgZm9udCBvcHRpb25zIGFyZSBzZXQgKHZhZGp1c3QsIG1vZClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvdXRPcHRpb25zICBvdXQtcGFyYW1ldGVyLCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHBhcnNlIHJlc3VsdHMgKGlmIGFueSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5PcHRpb25zICBmb250IG9wdGlvbnMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBmb250IHBhcnNlZCBhcyBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN0cmFpblwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBjb25zdHJhaW50cyBiYXNlZCBvbiAnbmVhcmVzdCcgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBpbGUgYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgYWN0dWFsIGNvbnN0cmFpbnQgdmFsdWVzIHRvIHVzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RyYWluKHBpbGUpIHtcbiAgICAgIC8vIE5PVEU6IGNvbnN0cmFpbldpZHRoIGFuZCAgY29uc3RyYWluSGVpZ2h0IG5ldmVyIHNldCFcbiAgICAgIC8vIE5PVEU6IGZvciBlZGdlIGxhYmVscywgb25seSAnbWF4V2R0JyBzZXRcbiAgICAgIC8vIE5vZGUgbGFiZWxzIGNhbiBzZXQgYWxsIHRoZSBmaWVsZHNcbiAgICAgIHZhciBmb250T3B0aW9ucyA9IHtcbiAgICAgICAgY29uc3RyYWluV2lkdGg6IGZhbHNlLFxuICAgICAgICBtYXhXZHQ6IC0xLFxuICAgICAgICBtaW5XZHQ6IC0xLFxuICAgICAgICBjb25zdHJhaW5IZWlnaHQ6IGZhbHNlLFxuICAgICAgICBtaW5IZ3Q6IC0xLFxuICAgICAgICB2YWxpZ246IFwibWlkZGxlXCJcbiAgICAgIH07XG4gICAgICB2YXIgd2lkdGhDb25zdHJhaW50ID0gdG9wTW9zdChwaWxlLCBcIndpZHRoQ29uc3RyYWludFwiKTtcblxuICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9udE9wdGlvbnMubWF4V2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludCk7XG4gICAgICAgIGZvbnRPcHRpb25zLm1pbldkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHdpZHRoQ29uc3RyYWludCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1heGltdW0gPSB0b3BNb3N0KHBpbGUsIFtcIndpZHRoQ29uc3RyYWludFwiLCBcIm1heGltdW1cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50TWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnRNYXhpbXVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID0gdG9wTW9zdChwaWxlLCBbXCJ3aWR0aENvbnN0cmFpbnRcIiwgXCJtaW5pbXVtXCJdKTtcblxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWluaW11bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGhlaWdodENvbnN0cmFpbnQgPSB0b3BNb3N0KHBpbGUsIFwiaGVpZ2h0Q29uc3RyYWludFwiKTtcblxuICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1pbkhndCA9IE51bWJlcihoZWlnaHRDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihoZWlnaHRDb25zdHJhaW50KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludE1pbmltdW0gPSB0b3BNb3N0KHBpbGUsIFtcImhlaWdodENvbnN0cmFpbnRcIiwgXCJtaW5pbXVtXCJdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodENvbnN0cmFpbnRNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMubWluSGd0ID0gTnVtYmVyKGhlaWdodENvbnN0cmFpbnRNaW5pbXVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50VmFsaWduID0gdG9wTW9zdChwaWxlLCBbXCJoZWlnaHRDb25zdHJhaW50XCIsIFwidmFsaWduXCJdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gXCJ0b3BcIiB8fCBoZWlnaHRDb25zdHJhaW50VmFsaWduID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgICBmb250T3B0aW9ucy52YWxpZ24gPSBoZWlnaHRDb25zdHJhaW50VmFsaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9udE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBvcHRpb25zIGFuZCB1cGRhdGUgaW50ZXJuYWwgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBvcHRpb25zIHRvIHNldFxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBwaWxlICAgICBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlciBmb3Igb3B0aW9uICdjaG9zZW4nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG9wdGlvbnMsIHBpbGUpIHtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLCB0cnVlKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlRm9udHMocGlsZSk7XG4gICAgICBkZWVwRXh0ZW5kKHRoaXMuZm9udE9wdGlvbnMsIHRoaXMuY29uc3RyYWluKHBpbGUpKTtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9IGNob29zaWZ5KFwibGFiZWxcIiwgcGlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gbWFyZ2lucyBhcmUgc2V0IGluIGFuIGVsZW1lbnQsIGFkanVzdCBzaXplcyBpcyBjYWxsZWQgdG8gcmVtb3ZlIHRoZW1cbiAgICAgKiBmcm9tIHRoZSB3aWR0aC9oZWlnaHQgY29uc3RyYWludHMuIFRoaXMgbXVzdCBiZSBkb25lIHByaW9yIHRvIGxhYmVsIHNpemluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gbWFyZ2luc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRqdXN0U2l6ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0U2l6ZXMobWFyZ2lucykge1xuICAgICAgdmFyIHdpZHRoQmlhcyA9IG1hcmdpbnMgPyBtYXJnaW5zLnJpZ2h0ICsgbWFyZ2lucy5sZWZ0IDogMDtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy5tYXhXZHQgLT0gd2lkdGhCaWFzO1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1pbldkdCAtPSB3aWR0aEJpYXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWlnaHRCaWFzID0gbWFyZ2lucyA/IG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b20gOiAwO1xuXG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5IZWlnaHQpIHtcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy5taW5IZ3QgLT0gaGVpZ2h0QmlhcztcbiAgICAgIH1cbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE1ldGhvZHMgZm9yIGhhbmRsaW5nIG9wdGlvbnMgcGlsZXNcbiAgICAvLyBFdmVudHVhbGx5LCB0aGVzZSB3aWxsIGJlIG1vdmVkIHRvIGEgc2VwYXJhdGUgY2xhc3NcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZm9udCBtZW1iZXJzIG9mIHRoZSBwYXNzZWQgbGlzdCBvZiBvcHRpb24gb2JqZWN0cyB0byB0aGUgcGlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gZHN0UGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyBhZGQgdG9cbiAgICAgKiBAcGFyYW0ge1BpbGV9IHNyY1BpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdGFrZSBmb250IG9wdGlvbnMgZnJvbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRGb250T3B0aW9uc1RvUGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250T3B0aW9uc1RvUGlsZShkc3RQaWxlLCBzcmNQaWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1BpbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGRGb250VG9QaWxlKGRzdFBpbGUsIHNyY1BpbGVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZ2l2ZW4gZm9udCBvcHRpb24gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgKHRoZSAncGlsZScpIHRvIGNvbnNpZGVyIGZvciBkZXRlcm1pbmluZ1xuICAgICAqIG11bHRpLWZvbnQgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgaW5zdGFuY2UgdG8gYWRkIHRvIHBpbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRm9udFRvUGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250VG9QaWxlKHBpbGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIGlmIChvcHRpb25zLmZvbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZvbnQgPT09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBpdGVtID0gb3B0aW9ucy5mb250O1xuICAgICAgcGlsZS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0IGFsbCBvd24tcHJvcGVydHkgdmFsdWVzIGZyb20gdGhlIGZvbnQgcGlsZSB0aGF0IGFyZW4ndCBtdWx0aS1mb250IG9wdGlvbiBvYmplY3Rzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBvYmplY3Qgd2l0aCBhbGwgY3VycmVudCBvd24gYmFzaWMgZm9udCBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2ljT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNpY09wdGlvbnMocGlsZSkge1xuICAgICAgdmFyIHJldCA9IHt9OyAvLyBTY2FucyB0aGUgd2hvbGUgcGlsZSB0byBnZXQgYWxsIG9wdGlvbnMgcHJlc2VudFxuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBpbGUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgdmFyIGZvbnRPcHRpb25zID0gcGlsZVtuXTsgLy8gQ29udmVydCBzaG9ydGhhbmQgaWYgbmVjZXNzYXJ5XG5cbiAgICAgICAgdmFyIHRtcFNob3J0aGFuZCA9IHt9O1xuXG4gICAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodG1wU2hvcnRoYW5kLCBmb250T3B0aW9ucykpIHtcbiAgICAgICAgICBmb250T3B0aW9ucyA9IHRtcFNob3J0aGFuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2gkMShmb250T3B0aW9ucywgZnVuY3Rpb24gKG9wdCwgbmFtZSkge1xuICAgICAgICAgIGlmIChvcHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBtdWx0aS1mb250IG9wdGlvbiBuZWVkIG5vdCBiZSBwcmVzZW50XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJldCwgbmFtZSkpIHJldHVybjsgLy8gS2VlcCBmaXJzdCB2YWx1ZSB3ZSBlbmNvdW50ZXJcblxuICAgICAgICAgIGlmIChpbmRleE9mKG11bHRpRm9udFN0eWxlKS5jYWxsKG11bHRpRm9udFN0eWxlLCBuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNraXAgbXVsdGktZm9udCBwcm9wZXJ0aWVzIGJ1dCB3ZSBkbyBuZWVkIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRbbmFtZV0gPSBvcHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBmb3IgZ2l2ZW4gb3B0aW9uIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udC5cbiAgICAgKlxuICAgICAqIEFsbCBhdmFpbGFibGUgb3B0aW9uIG9iamVjdHMgYXJlIHRyYXdsZWQgaW4gdGhlIHNldCBvcmRlciB0byBjb25zdHJ1Y3QgdGhlIG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAjIyBUcmF2ZXJzYWwgb2YgcGlsZSBmb3IgbXVsdGktZm9udHNcbiAgICAgKlxuICAgICAqIFRoZSBkZXRlcm1pbmF0aW9uIG9mIG11bHRpLWZvbnQgb3B0aW9uIHZhbHVlcyBpcyBhIHNwZWNpYWwgY2FzZSwgYmVjYXVzZSBhbnkgdmFsdWVzIG5vdFxuICAgICAqIHByZXNlbnQgaW4gdGhlIG11bHRpLWZvbnQgb3B0aW9ucyBzaG91bGQgYnkgZGVmaW5pdGlvbiBiZSB0YWtlbiBmcm9tIHRoZSBtYWluIGZvbnQgb3B0aW9ucyxcbiAgICAgKiBpLmUuIGZyb20gdGhlIGN1cnJlbnQgJ3BhcmVudCcgb2JqZWN0IG9mIHRoZSBtdWx0aS1mb250IG9wdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyBTZWFyY2ggb3JkZXIgZm9yIG11bHRpLWZvbnRzXG4gICAgICpcbiAgICAgKiAnYm9sZCcgdXNlZCBhcyBleGFtcGxlOlxuICAgICAqXG4gICAgICogICAtIHNlYXJjaCBpbiBvcHRpb24gZ3JvdXAgJ2JvbGQnIGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgKiAgIC0gc2VhcmNoIGluIG1haW4gZm9udCBvcHRpb24gZ3JvdXAgaW4gbG9jYWwgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtNdWx0aUZvbnRTdHlsZX0gbXVsdGlOYW1lIHN1YiBwYXRoIGZvciB0aGUgbXVsdGktZm9udFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24gIHRoZSBvcHRpb24gdG8gc2VhcmNoIGZvciwgZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb250T3B0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvbnRPcHRpb24ocGlsZSwgbXVsdGlOYW1lLCBvcHRpb24pIHtcbiAgICAgIHZhciBtdWx0aUZvbnQ7IC8vIFNlYXJjaCBtdWx0aSBmb250IGluIGxvY2FsIHByb3BlcnRpZXNcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBwaWxlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIHZhciBmb250T3B0aW9ucyA9IHBpbGVbbl07XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb250T3B0aW9ucywgbXVsdGlOYW1lKSkge1xuICAgICAgICAgIG11bHRpRm9udCA9IGZvbnRPcHRpb25zW211bHRpTmFtZV07XG4gICAgICAgICAgaWYgKG11bHRpRm9udCA9PT0gdW5kZWZpbmVkIHx8IG11bHRpRm9udCA9PT0gbnVsbCkgY29udGludWU7IC8vIENvbnZlcnQgc2hvcnRoYW5kIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIC8vIFRPRE86IGluZWZmaWNpZW50IHRvIGRvIHRoaXMgY29udmVyc2lvbiBldmVyeSB0aW1lOyBmaW5kIGEgYmV0dGVyIHdheS5cblxuICAgICAgICAgIHZhciB0bXBTaG9ydGhhbmQgPSB7fTtcblxuICAgICAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodG1wU2hvcnRoYW5kLCBtdWx0aUZvbnQpKSB7XG4gICAgICAgICAgICBtdWx0aUZvbnQgPSB0bXBTaG9ydGhhbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtdWx0aUZvbnQsIG9wdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBtdWx0aUZvbnRbb3B0aW9uXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT3B0aW9uIGlzIG5vdCBtZW50aW9uZWQgaW4gdGhlIG11bHRpIGZvbnQgb3B0aW9uczsgdGFrZSBpdCBmcm9tIHRoZSBwYXJlbnQgZm9udCBvcHRpb25zLlxuICAgICAgLy8gVGhlc2UgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIHdpdGggZ2V0QmFzaWNPcHRpb25zKCksIHNvIHVzZSB0aGUgY29udmVydGVkIHZhbHVlcy5cblxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZm9udE9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIH0gLy8gQSB2YWx1ZSAqKm11c3QqKiBiZSBmb3VuZDsgeW91IHNob3VsZCBuZXZlciBnZXQgaGVyZS5cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IGZpbmQgdmFsdWUgZm9yIG11bHRpLWZvbnQgZm9yIHByb3BlcnR5OiAnXCIgKyBvcHRpb24gKyBcIidcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgb3B0aW9ucyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250LlxuICAgICAqXG4gICAgICogQWxsIGF2YWlsYWJsZSBvcHRpb24gb2JqZWN0cyBhcmUgdHJhd2xlZCBpbiB0aGUgc2V0IG9yZGVyIHRvIGNvbnN0cnVjdCB0aGUgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge011bHRpRm9udFN0eWxlfSBtdWx0aU5hbWUgc3ViIHBhdGggZm9yIHRoZSBtb2QtZm9udFxuICAgICAqIEByZXR1cm5zIHtNdWx0aUZvbnRPcHRpb25zfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb250T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb250T3B0aW9ucyhwaWxlLCBtdWx0aU5hbWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHZhciBvcHRpb25OYW1lcyA9IFtcImNvbG9yXCIsIFwic2l6ZVwiLCBcImZhY2VcIiwgXCJtb2RcIiwgXCJ2YWRqdXN0XCJdOyAvLyBMaXN0IG9mIGFsbG93ZWQgb3B0aW9ucyBwZXIgbXVsdGktZm9udFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbk5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtb2QgPSBvcHRpb25OYW1lc1tpXTtcbiAgICAgICAgcmVzdWx0W21vZF0gPSB0aGlzLmdldEZvbnRPcHRpb24ocGlsZSwgbXVsdGlOYW1lLCBtb2QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRW5kIG1ldGhvZHMgZm9yIGhhbmRsaW5nIG9wdGlvbnMgcGlsZXNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIHRoZSBmb250IG9wdGlvbnMgZm9yIHRoZSBtdWx0aS1mb250IHRvIHNpbmdsZSBvYmplY3RzLCBmcm9tXG4gICAgICogdGhlIGNoYWluIG9mIG9wdGlvbiBvYmplY3RzIHBhc3NlZCAodGhlICdwaWxlJykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHNlcXVlbmNlIG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgRmlyc3QgaXRlbSBpbiBsaXN0IGFzc3VtZWQgdG8gYmUgdGhlIG5ld2x5IHNldCBvcHRpb25zLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvcGFnYXRlRm9udHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGFnYXRlRm9udHMocGlsZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb250UGlsZSA9IFtdOyAvLyBzZXF1ZW5jZSBvZiBmb250IG9iamVjdHMgdG8gY29uc2lkZXIsIG9yZGVyIGltcG9ydGFudFxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMuZWxlbWVudE9wdGlvbnMgaXMgbm90IHVzZWQgaGVyZS5cblxuICAgICAgdGhpcy5hZGRGb250T3B0aW9uc1RvUGlsZShmb250UGlsZSwgcGlsZSk7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zID0gdGhpcy5nZXRCYXNpY09wdGlvbnMoZm9udFBpbGUpOyAvLyBXZSBzZXQgbXVsdGlmb250IHZhbHVlcyBldmVuIGlmIG11bHRpID09PSBmYWxzZSwgZm9yIGNvbnNpc3RlbmN5ICh0aGluZ3MgYnJlYWsgb3RoZXJ3aXNlKVxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBtb2QgPSBtdWx0aUZvbnRTdHlsZVtpXTtcbiAgICAgICAgdmFyIG1vZE9wdGlvbnMgPSBfdGhpczIuZm9udE9wdGlvbnNbbW9kXTtcblxuICAgICAgICB2YXIgdG1wTXVsdGlGb250T3B0aW9ucyA9IF90aGlzMi5nZXRGb250T3B0aW9ucyhmb250UGlsZSwgbW9kKTsgLy8gQ29weSBvdmVyIGZvdW5kIHZhbHVlc1xuXG5cbiAgICAgICAgZm9yRWFjaCQxKHRtcE11bHRpRm9udE9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24sIG4pIHtcbiAgICAgICAgICBtb2RPcHRpb25zW25dID0gb3B0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kT3B0aW9ucy5zaXplID0gTnVtYmVyKG1vZE9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIG1vZE9wdGlvbnMudmFkanVzdCA9IE51bWJlcihtb2RPcHRpb25zLnZhZGp1c3QpO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aUZvbnRTdHlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbi4gVGhpcyBpcyBjYWxsZWQgZnJvbSBhbnl0aGluZyB0aGF0IHdhbnRzIHRvIGRyYXcgYSBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IFwibWlkZGxlXCI7XG4gICAgICAvLyBpZiBubyBsYWJlbCwgcmV0dXJuXG4gICAgICBpZiAodGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIGNoZWNrIGlmIHdlIGhhdmUgdG8gcmVuZGVyIHRoZSBsYWJlbFxuXG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICBpZiAodGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCAmJiB2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHJldHVybjsgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlcmUgd2lsbCBub3QgYmUgSFVHRSBsZXR0ZXJzIG9uIHNjcmVlblxuICAgICAgLy8gYnkgc2V0dGluZyBhbiB1cHBlciBsaW1pdCBvbiB0aGUgdmlzaWJsZSB0ZXh0IHNpemUgKHJlZ2FyZGxlc3Mgb2Ygem9vbUxldmVsKVxuXG4gICAgICBpZiAodmlld0ZvbnRTaXplID49IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSB7XG4gICAgICAgIHZpZXdGb250U2l6ZSA9IE51bWJlcih0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH0gLy8gdXBkYXRlIHRoZSBzaXplIGNhY2hlIGlmIHJlcXVpcmVkXG5cblxuICAgICAgdGhpcy5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksIGJhc2VsaW5lKTtcblxuICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQoY3R4KTtcblxuICAgICAgdGhpcy5fZHJhd1RleHQoY3R4LCB4LCB0aGlzLnNpemUueUxpbmUsIGJhc2VsaW5lLCB2aWV3Rm9udFNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0JhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCYWNrZ3JvdW5kKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZDtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHNpemUubGVmdCwgc2l6ZS50b3AsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFzZWxpbmU9J21pZGRsZSddXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdGb250U2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdUZXh0KGN0eCwgeCwgeSkge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIm1pZGRsZVwiO1xuICAgICAgdmFyIHZpZXdGb250U2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgX3RoaXMkX3NldEFsaWdubWVudCA9IHRoaXMuX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKTtcblxuICAgICAgdmFyIF90aGlzJF9zZXRBbGlnbm1lbnQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX3NldEFsaWdubWVudCwgMik7XG5cbiAgICAgIHggPSBfdGhpcyRfc2V0QWxpZ25tZW50MlswXTtcbiAgICAgIHkgPSBfdGhpcyRfc2V0QWxpZ25tZW50MlsxXTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgIHggPSB4IC0gdGhpcy5zaXplLndpZHRoIC8gMjsgLy8gU2hpZnQgbGFiZWwgMS8yLWRpc3RhbmNlIHRvIHRoZSBsZWZ0XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiAmJiB0aGlzLnNpemUuaGVpZ2h0ID4gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIHkgLT0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHkgKz0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBkcmF3IHRoZSB0ZXh0XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcblxuICAgICAgICBpZiAobGluZSAmJiBsaW5lLmJsb2Nrcykge1xuICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCB8fCB0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICB3aWR0aCArPSAodGhpcy5zaXplLndpZHRoIC0gbGluZS53aWR0aCkgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICB3aWR0aCArPSB0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2pdO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBibG9jay5mb250O1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMkX2dldENvbG9yID0gdGhpcy5fZ2V0Q29sb3IoYmxvY2suY29sb3IsIHZpZXdGb250U2l6ZSwgYmxvY2suc3Ryb2tlQ29sb3IpLFxuICAgICAgICAgICAgICAgIF90aGlzJF9nZXRDb2xvcjIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q29sb3IsIDIpLFxuICAgICAgICAgICAgICAgIGZvbnRDb2xvciA9IF90aGlzJF9nZXRDb2xvcjJbMF0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBfdGhpcyRfZ2V0Q29sb3IyWzFdO1xuXG4gICAgICAgICAgICBpZiAoYmxvY2suc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBibG9jay5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjtcblxuICAgICAgICAgICAgaWYgKGJsb2NrLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChibG9jay50ZXh0LCB4ICsgd2lkdGgsIHkgKyBibG9jay52YWRqdXN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGJsb2NrLnRleHQsIHggKyB3aWR0aCwgeSArIGJsb2NrLnZhZGp1c3QpO1xuICAgICAgICAgICAgd2lkdGggKz0gYmxvY2sud2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeSArPSBsaW5lLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VsaW5lXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QWxpZ25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5LCBiYXNlbGluZSkge1xuICAgICAgLy8gY2hlY2sgZm9yIGxhYmVsIGFsaWdubWVudCAoZm9yIGVkZ2VzKVxuICAgICAgLy8gVE9ETzogbWFrZSBhbGlnbm1lbnQgZm9yIG5vZGVzXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCAmJiB0aGlzLmZvbnRPcHRpb25zLmFsaWduICE9PSBcImhvcml6b250YWxcIiAmJiB0aGlzLnBvaW50VG9TZWxmID09PSBmYWxzZSkge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcblxuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICAgICAgICB5IC09IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGFscGhhYmV0aWMuIEFscGhhYmV0aWMgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcImhhbmdpbmdcIjtcbiAgICAgICAgICB5ICs9IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGhhbmdpbmcuIEhhbmdpbmcgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZmFkZSBpbiB3aGVuIHJlbGF0aXZlIHNjYWxlIGlzIGJldHdlZW4gdGhyZXNob2xkIGFuZCB0aHJlc2hvbGQgLSAxLlxuICAgICAqIElmIHRoZSByZWxhdGl2ZSBzY2FsZSB3b3VsZCBiZSBzbWFsbGVyIHRoYW4gdGhyZXNob2xkIC0xIHRoZSBkcmF3IGZ1bmN0aW9uIHdvdWxkIGhhdmUgcmV0dXJuZWQgYmVmb3JlIGNvbWluZyBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yICBUaGUgZm9udCBjb2xvciB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxTdHJva2VDb2xvclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm9udCBjb2xvciBhbmQgc3Ryb2tlIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29sb3IoY29sb3IsIHZpZXdGb250U2l6ZSwgaW5pdGlhbFN0cm9rZUNvbG9yKSB7XG4gICAgICB2YXIgZm9udENvbG9yID0gY29sb3IgfHwgXCIjMDAwMDAwXCI7XG4gICAgICB2YXIgc3Ryb2tlQ29sb3IgPSBpbml0aWFsU3Ryb2tlQ29sb3IgfHwgXCIjZmZmZmZmXCI7XG5cbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPD0gdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAxIC0gKHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gdmlld0ZvbnRTaXplKSkpO1xuICAgICAgICBmb250Q29sb3IgPSBvdmVycmlkZU9wYWNpdHkoZm9udENvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgc3Ryb2tlQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkoc3Ryb2tlQ29sb3IsIG9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2ZvbnRDb2xvciwgc3Ryb2tlQ29sb3JdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdGhpcy5fcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0LFxuICAgICAgICBsaW5lQ291bnQ6IHRoaXMubGluZUNvdW50XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZGltZW5zaW9ucyBvZiB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtyZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuICAgICAgdmFyIHggPSB0aGlzLnNpemUubGVmdDsgLy8gZGVmYXVsdCB2YWx1ZXMgd2hpY2ggbWlnaHQgYmUgb3ZlcnJpZGRlbiBiZWxvd1xuXG4gICAgICB2YXIgeSA9IHRoaXMuc2l6ZS50b3AgLSAwLjUgKiBsaW5lTWFyZ2luOyAvLyBpZGVtXG5cbiAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsKSB7XG4gICAgICAgIHZhciB4MiA9IC10aGlzLnNpemUud2lkdGggKiAwLjU7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmZvbnRPcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgeSA9IC10aGlzLnNpemUuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLSh0aGlzLnNpemUuaGVpZ2h0ICsgbGluZU1hcmdpbik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSBsaW5lTWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAqIEBwYXJhbSB7J21pZGRsZSd8J2hhbmdpbmcnfSBbYmFzZWxpbmU9J21pZGRsZSddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVMYWJlbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBcIm1pZGRsZVwiO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICB0aGlzLnNpemUubGVmdCA9IHggLSB0aGlzLnNpemUud2lkdGggKiAwLjU7XG4gICAgICB0aGlzLnNpemUudG9wID0geSAtIHRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICB0aGlzLnNpemUueUxpbmUgPSB5ICsgKDEgLSB0aGlzLmxpbmVDb3VudCkgKiAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG5cbiAgICAgIGlmIChiYXNlbGluZSA9PT0gXCJoYW5naW5nXCIpIHtcbiAgICAgICAgdGhpcy5zaXplLnRvcCArPSAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuXG4gICAgICAgIHRoaXMuc2l6ZS55TGluZSArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGVcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kXG4gICAgICogQHJldHVybnMge3tjb2xvciwgc2l6ZSwgZmFjZSwgbW9kLCB2YWRqdXN0LCBzdHJva2VXaWR0aDogKiwgc3Ryb2tlQ29sb3I6ICgqfHN0cmluZ3xhbGxPcHRpb25zLmVkZ2VzLmZvbnQuc3Ryb2tlQ29sb3J8e3N0cmluZ318YWxsT3B0aW9ucy5ub2Rlcy5mb250LnN0cm9rZUNvbG9yfEFycmF5KX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIG1vZCkge1xuICAgICAgdmFyIGdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoZm9udE9wdGlvbnMsIG1vZCwgb3B0aW9uKSB7XG4gICAgICAgIGlmIChtb2QgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICBpZiAob3B0aW9uID09PSBcIm1vZFwiKSByZXR1cm4gXCJcIjtcbiAgICAgICAgICByZXR1cm4gZm9udE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb250T3B0aW9uc1ttb2RdW29wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEdydW1ibCBsZWF2aW5nIG91dCB0ZXN0IG9uIHVuZGVmaW5lZCBlcXVhbHMgZmFsc2UgZm9yIFwiXCJcbiAgICAgICAgICByZXR1cm4gZm9udE9wdGlvbnNbbW9kXVtvcHRpb25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRha2UgZnJvbSBwYXJlbnQgZm9udCBvcHRpb25cbiAgICAgICAgICByZXR1cm4gZm9udE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgY29sb3I6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgXCJjb2xvclwiKSxcbiAgICAgICAgc2l6ZTogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcInNpemVcIiksXG4gICAgICAgIGZhY2U6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgXCJmYWNlXCIpLFxuICAgICAgICBtb2Q6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgXCJtb2RcIiksXG4gICAgICAgIHZhZGp1c3Q6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgXCJ2YWRqdXN0XCIpLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlQ29sb3JcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWxlY3RlZCB8fCBob3Zlcikge1xuICAgICAgICBpZiAobW9kID09PSBcIm5vcm1hbFwiICYmIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9PT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsSGlnaGxpZ2h0Qm9sZCkge1xuICAgICAgICAgIHZhbHVlcy5tb2QgPSBcImJvbGRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIodmFsdWVzLCB0aGlzLmVsZW1lbnRPcHRpb25zLmlkLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZm9udFN0cmluZyA9IFwiXCI7XG5cbiAgICAgIGlmICh2YWx1ZXMubW9kICE9PSB1bmRlZmluZWQgJiYgdmFsdWVzLm1vZCAhPT0gXCJcIikge1xuICAgICAgICAvLyBzYWZlZ3VhcmQgZm9yIHVuZGVmaW5lZCAtIHRoaXMgaGFwcGVuZWRcbiAgICAgICAgZm9udFN0cmluZyArPSB2YWx1ZXMubW9kICsgXCIgXCI7XG4gICAgICB9XG5cbiAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLnNpemUgKyBcInB4IFwiICsgdmFsdWVzLmZhY2U7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcucmVwbGFjZSgvXCIvZywgXCJcIik7XG4gICAgICB2YWx1ZXMuZm9udCA9IGN0eC5mb250O1xuICAgICAgdmFsdWVzLmhlaWdodCA9IHZhbHVlcy5zaXplO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlmZmVyZW50U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgIT09IHRoaXMuc2VsZWN0ZWRTdGF0ZSB8fCBob3ZlciAhPT0gdGhpcy5ob3ZlclN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGV4cGxvZGVzIHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzIGFuZCBkZXRlcm1pbmVzIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBudW1iZXIgb2YgbGluZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UZXh0ICB0aGUgdGV4dCB0byBleHBsb2RlXG4gICAgICogQHJldHVybnMge3t3aWR0aCwgaGVpZ2h0LCBsaW5lc318Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2Nlc3NMYWJlbFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbFRleHQoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIGluVGV4dCkge1xuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IExhYmVsU3BsaXR0ZXIoY3R4LCB0aGlzLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyLnByb2Nlc3MoaW5UZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBleHBsb2RlcyB0aGUgbGFiZWwgc3RyaW5nIGludG8gbGluZXMgYW5kIHNldHMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0xhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLmxhYmVsRGlydHkgPT09IGZhbHNlICYmICF0aGlzLmRpZmZlcmVudFN0YXRlKHNlbGVjdGVkLCBob3ZlcikpIHJldHVybjtcblxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcHJvY2Vzc0xhYmVsVGV4dChjdHgsIHNlbGVjdGVkLCBob3ZlciwgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCk7XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLm1pbldkdCA+IDAgJiYgc3RhdGUud2lkdGggPCB0aGlzLmZvbnRPcHRpb25zLm1pbldkdCkge1xuICAgICAgICBzdGF0ZS53aWR0aCA9IHRoaXMuZm9udE9wdGlvbnMubWluV2R0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNpemUubGFiZWxIZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLm1pbkhndCA+IDAgJiYgc3RhdGUuaGVpZ2h0IDwgdGhpcy5mb250T3B0aW9ucy5taW5IZ3QpIHtcbiAgICAgICAgc3RhdGUuaGVpZ2h0ID0gdGhpcy5mb250T3B0aW9ucy5taW5IZ3Q7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGluZXMgPSBzdGF0ZS5saW5lcztcbiAgICAgIHRoaXMubGluZUNvdW50ID0gc3RhdGUubGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5zaXplLndpZHRoID0gc3RhdGUud2lkdGg7XG4gICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgICAgdGhpcy5zZWxlY3RlZFN0YXRlID0gc2VsZWN0ZWQ7XG4gICAgICB0aGlzLmhvdmVyU3RhdGUgPSBob3ZlcjtcbiAgICAgIHRoaXMubGFiZWxEaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGxhYmVsIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgbGFiZWwgd2lsbCBiZSBzaG93LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlzaWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUud2lkdGggPT09IDAgfHwgdGhpcy5zaXplLmhlaWdodCA9PT0gMCB8fCB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBub3RoaW5nIHRvIGRpc3BsYXlcbiAgICAgIH1cblxuICAgICAgdmFyIHZpZXdGb250U2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuXG4gICAgICBpZiAodmlld0ZvbnRTaXplIDwgdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVG9vIHNtYWxsIG9yIHRvbyBmYXIgYXdheSB0byBzaG93XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlRm9udFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUZvbnRTdHJpbmcob3V0T3B0aW9ucywgaW5PcHRpb25zKSB7XG4gICAgICBpZiAoIWluT3B0aW9ucyB8fCB0eXBlb2YgaW5PcHRpb25zICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbmV3T3B0aW9uc0FycmF5ID0gaW5PcHRpb25zLnNwbGl0KFwiIFwiKTtcbiAgICAgIG91dE9wdGlvbnMuc2l6ZSA9ICtuZXdPcHRpb25zQXJyYXlbMF0ucmVwbGFjZShcInB4XCIsIFwiXCIpO1xuICAgICAgb3V0T3B0aW9ucy5mYWNlID0gbmV3T3B0aW9uc0FycmF5WzFdO1xuICAgICAgb3V0T3B0aW9ucy5jb2xvciA9IG5ld09wdGlvbnNBcnJheVsyXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYWJlbDtcbn0oKTtcblxuLyoqXG4gKiBUaGUgQmFzZSBjbGFzcyBmb3IgYWxsIE5vZGVzLlxuICovXG52YXIgTm9kZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVCYXNlKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IGxhYmVsTW9kdWxlO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hcmdpbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlZnJlc2hOZWVkZWQgPSB0cnVlO1xuICAgIHRoaXMuYm91bmRpbmdCb3ggPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlQmFzZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldE1hcmdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpIHtcbiAgICAgIHRoaXMubWFyZ2luID0ge307XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWFyZ2luKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHRoaXMub3B0aW9ucy5tYXJnaW4pID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aGlzLm1hcmdpbi50b3AgPSB0aGlzLm9wdGlvbnMubWFyZ2luLnRvcDtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5yaWdodCA9IHRoaXMub3B0aW9ucy5tYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgdGhpcy5tYXJnaW4uYm90dG9tID0gdGhpcy5vcHRpb25zLm1hcmdpbi5ib3R0b207XG4gICAgICAgICAgdGhpcy5tYXJnaW4ubGVmdCA9IHRoaXMub3B0aW9ucy5tYXJnaW4ubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hcmdpbi50b3AgPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMubWFyZ2luLnJpZ2h0ID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5ib3R0b20gPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmxlZnQgPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhYmVsTW9kdWxlLmFkanVzdFNpemVzKHRoaXMubWFyZ2luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHZhbHVlcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB2YWx1ZXMuc2hhZG93U2l6ZTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB2YWx1ZXMuc2hhZG93WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB2YWx1ZXMuc2hhZG93WTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMCwwLDAsMClcIjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlQm9yZGVyRGFzaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5ib3JkZXJEYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBkYXNoZXMgPSB2YWx1ZXMuYm9yZGVyRGFzaGVzO1xuXG4gICAgICAgICAgaWYgKGRhc2hlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGFzaGVzID0gWzUsIDE1XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICAgIHZhbHVlcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlQm9yZGVyRGFzaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICAgIHZhbHVlcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIHNoYXBlIG9mIGEgbm9kZSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5lZWRzUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5yZWZyZXNoTmVlZGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHRoZSBiZXN0IGxvY2F0aW9uIHRvIHJlc2V0IHRoaXMgbWVtYmVyLlxuICAgICAgICAvLyBIb3dldmVyLCBpbiB0aGUgY3VycmVudCBsb2dpYywgaXQgaXMgdGhlIG1vc3QgY29udmVuaWVudCBvbmUuXG4gICAgICAgIHRoaXMucmVmcmVzaE5lZWRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxhYmVsTW9kdWxlLmRpZmZlcmVudFN0YXRlKHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRDb250ZXh0Rm9yRHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHZhbHVlcy5ib3JkZXJXaWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlcy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZXMuY29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBlcmZvcm1TdHJva2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcykge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdmFsdWVzLmJvcmRlcldpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7IC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG5cbiAgICAgIGN0eC5zYXZlKCk7IC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG5cbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5lbmFibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpOyAvL2RyYXcgdGhlIGJvcmRlclxuXG4gICAgICAgIGN0eC5zdHJva2UoKTsgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGVyZm9ybUZpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVzLmNvbG9yOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTsgLy8gZHJhdyB0aGUgYmFja2dyb3VuZFxuXG4gICAgICBmaWxsKGN0eCkuY2FsbChjdHgpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5wZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRCb3VuZGluZ0JveE1hcmdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQm91bmRpbmdCb3hNYXJnaW4obWFyZ2luKSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgLT0gbWFyZ2luO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgLT0gbWFyZ2luO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKz0gbWFyZ2luO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCArPSBtYXJnaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqXG4gICAgICogRG9pbmcgaXQgbGlrZSB0aGlzIG1ha2VzIGl0IGVhc2llciB0byBvdmVycmlkZVxuICAgICAqIGluIHRoZSBjaGlsZCBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAgICogVGhpcyBhY3RzIGFzIGEgc3R1YiB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRpbWVuc2lvbnMgdG8gdXNlIGZvciBub2RlcyB3aXRoIGFuIGludGVybmFsIGxhYmVsXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHksIHRoZXNlIGFyZTogQ2lyY2xlLCBFbGxpcHNlLCBEYXRhYmFzZSwgQm94XG4gICAgICogVGhlIG90aGVyIG5vZGVzIGhhdmUgZXh0ZXJuYWwgbGFiZWxzLCBhbmQgd2lsbCBub3QgY2FsbCB0aGlzIG1ldGhvZFxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgbm8gbGFiZWwsIGRlY2VudCBkZWZhdWx0IHZhbHVlcyBhcmUgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAgICogQHJldHVybnMge3t3aWR0aDpudW1iZXIsIGhlaWdodDpudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc0Zyb21MYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAvLyBOT1RFOiBwcmV2aW91c2x5ICd0ZXh0U2l6ZScgd2FzIG5vdCBwdXQgaW4gJ3RoaXMnIGZvciBFbGxpcHNlXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIHRoZSBjb25zZXF1ZW5jZXMuXG4gICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0O1xuICAgICAgdmFyIERFRkFVTFRfU0laRSA9IDE0O1xuXG4gICAgICBpZiAod2lkdGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbGFiZWwgdGV4dCBzZXRcbiAgICAgICAgd2lkdGggPSBERUZBVUxUX1NJWkU7IC8vIHVzZSBhIGRlY2VudCBkZWZhdWx0XG5cbiAgICAgICAgaGVpZ2h0ID0gREVGQVVMVF9TSVpFOyAvLyBpZiB3aWR0aCB6ZXJvLCB0aGVuIGhlaWdodCBhbHNvIGFsd2F5cyB6ZXJvXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVCYXNlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRzKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgQm94IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgQm94JDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoQm94LCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkcyhCb3gpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQm94KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJveCwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBkcmF3Um91bmRSZWN0KGN0eCwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHZhbHVlcy5ib3JkZXJSYWRpdXMpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHZhciBib3JkZXJSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1czsgLy8gb25seSBlZmZlY3RpdmUgZm9yIGJveFxuXG4gICAgICB0aGlzLl9hZGRCb3VuZGluZ0JveE1hcmdpbihib3JkZXJSYWRpdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94O1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRyKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogTk9URTogVGhpcyBpcyBhIGJhZCBiYXNlIGNsYXNzXG4gKlxuICogQ2hpbGQgY2xhc3NlcyBhcmU6XG4gKlxuICogICBJbWFnZSAgICAgICAtIHVzZXMgKm9ubHkqIGltYWdlIG1ldGhvZHNcbiAqICAgQ2lyY2xlICAgICAgLSB1c2VzICpvbmx5KiBfZHJhd1Jhd0NpcmNsZVxuICogICBDaXJjbGVJbWFnZSAtIHVzZXMgYWxsXG4gKlxuICogVE9ETzogUmVmYWN0b3IsIG1vdmUgX2RyYXdSYXdDaXJjbGUgdG8gZGlmZmVyZW50IG1vZHVsZSwgZGVyaXZlIENpcmNsZSBmcm9tIE5vZGVCYXNlXG4gKiAgICAgICBSZW5hbWUgdGhpcyB0byBJbWFnZUJhc2VcbiAqICAgICAgIENvbnNvbGlkYXRlIGNvbW1vbiBjb2RlIGluIEltYWdlIGFuZCBDaXJjbGVJbWFnZSB0byBiYXNlIGNsYXNzXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIENpcmNsZUltYWdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhDaXJjbGVJbWFnZUJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRyKENpcmNsZUltYWdlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBDaXJjbGVJbWFnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICAgIF90aGlzLmxhYmVsT2Zmc2V0ID0gMDtcbiAgICBfdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtpbWFnZU9ial1cbiAgICogQHBhcmFtIHtvYmplY3R9IFtpbWFnZU9iakFsdF1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlSW1hZ2VCYXNlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIShpbWFnZU9iaiA9PT0gdW5kZWZpbmVkICYmIGltYWdlT2JqQWx0ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRoaXMuc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW1hZ2VzIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGUgaW1hZ2VzIGNhbiBiZSB1cGRhdGVkIGFmdGVyIHRoZSBpbml0aWFsIHNldHRpbmcgb2Ygb3B0aW9ucztcbiAgICAgKiB0aGVyZWZvcmUsIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIHJlZW50cmFudC5cbiAgICAgKlxuICAgICAqIEZvciBjb3JyZWN0IHdvcmtpbmcgaW4gZXJyb3IgY2FzZXMsIGl0IGlzIG5lY2Vzc2FyeSB0byBwcm9wZXJseSBzZXRcbiAgICAgKiBmaWVsZCAnbm9kZXMuYnJva2VuSW1hZ2UnIGluIHRoZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmogIHJlcXVpcmVkOyBtYWluIGltYWdlIHRvIHNob3cgZm9yIHRoaXMgbm9kZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V8dW5kZWZpbmVkfSBpbWFnZU9iakFsdCBvcHRpb25hbDsgaW1hZ2UgdG8gc2hvdyB3aGVuIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEltYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgICBpZiAoaW1hZ2VPYmpBbHQgJiYgdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmpBbHQ7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZU9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSBpbWFnZU9iajtcbiAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IGltYWdlT2JqQWx0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgc2VsZWN0aW9uIGFuZCBzd2l0Y2ggYmV0d2VlbiB0aGUgYmFzZSBhbmQgdGhlIHNlbGVjdGVkIGltYWdlLlxuICAgICAqXG4gICAgICogRG8gdGhlIHN3aXRjaCBvbmx5IGlmIGltYWdlT2JqQWx0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgdmFsdWUgb2YgbmV3IHNlbGVjdGVkIHN0YXRlIGZvciBjdXJyZW50IG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN3aXRjaEltYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2l0Y2hJbWFnZXMoc2VsZWN0ZWQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25fY2hhbmdlZCA9IHNlbGVjdGVkICYmICF0aGlzLnNlbGVjdGVkIHx8ICFzZWxlY3RlZCAmJiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkOyAvLyBSZW1lbWJlciBuZXcgc2VsZWN0aW9uXG5cbiAgICAgIGlmICh0aGlzLmltYWdlT2JqQWx0ICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0aW9uX2NoYW5nZWQpIHtcbiAgICAgICAgdmFyIGltYWdlVG1wID0gdGhpcy5pbWFnZU9iajtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VPYmpBbHQ7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZVRtcDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBJbWFnZSBQYWRkaW5nIGZyb20gbm9kZSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLGxlZnQ6IG51bWJlcixib3R0b206IG51bWJlcixyaWdodDogbnVtYmVyfX0gaW1hZ2UgcGFkZGluZyBpbnNpZGUgdGhpcyBzaGFwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SW1hZ2VQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRJbWFnZVBhZGRpbmcoKSB7XG4gICAgICB2YXIgaW1nUGFkZGluZyA9IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlUGFkZGluZykge1xuICAgICAgICB2YXIgb3B0SW1nUGFkZGluZyA9IHRoaXMub3B0aW9ucy5pbWFnZVBhZGRpbmc7XG5cbiAgICAgICAgaWYgKF90eXBlb2Yob3B0SW1nUGFkZGluZykgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGltZ1BhZGRpbmcudG9wID0gb3B0SW1nUGFkZGluZy50b3A7XG4gICAgICAgICAgaW1nUGFkZGluZy5yaWdodCA9IG9wdEltZ1BhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgaW1nUGFkZGluZy5ib3R0b20gPSBvcHRJbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgICBpbWdQYWRkaW5nLmxlZnQgPSBvcHRJbWdQYWRkaW5nLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1nUGFkZGluZy50b3AgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcucmlnaHQgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcuYm90dG9tID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLmxlZnQgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWdQYWRkaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIG5vZGUgZGltZW5zaW9ucyBmb3IgYSBsb2FkZWQgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBQcmU6IHRoaXMuaW1hZ2VPYmogaXMgdmFsaWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplSW1hZ2UoKSB7XG4gICAgICB2YXIgd2lkdGgsIGhlaWdodDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlSW1hZ2VTaXplID09PSBmYWxzZSkge1xuICAgICAgICAvLyBVc2UgdGhlIHNpemUgcHJvcGVydHlcbiAgICAgICAgdmFyIHJhdGlvX3dpZHRoID0gMTtcbiAgICAgICAgdmFyIHJhdGlvX2hlaWdodCA9IDE7IC8vIE9ubHkgY2FsY3VsYXRlIHRoZSBwcm9wZXIgcmF0aW8gaWYgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IG5vdCB6ZXJvXG5cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggJiYgdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCA+IHRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgICByYXRpb193aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmF0aW9faGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQgLyB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW9fd2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvX2hlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSB0aGUgaW1hZ2Ugc2l6ZSB3aXRoIGltYWdlIHBhZGRpbmdcbiAgICAgICAgdmFyIGltZ1BhZGRpbmcgPSB0aGlzLl9nZXRJbWFnZVBhZGRpbmcoKTtcblxuICAgICAgICB3aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGggKyBpbWdQYWRkaW5nLmxlZnQgKyBpbWdQYWRkaW5nLnJpZ2h0O1xuICAgICAgICBoZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodCArIGltZ1BhZGRpbmcudG9wICsgaW1nUGFkZGluZy5ib3R0b207XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdSYXdDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMuc2l6ZSk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ltYWdlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggIT0gMCkge1xuICAgICAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZXMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gdmFsdWVzLm9wYWNpdHkgOiAxOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICB2YXIgZmFjdG9yID0gMTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZmFjdG9yID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMud2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWdQYWRkaW5nID0gdGhpcy5fZ2V0SW1hZ2VQYWRkaW5nKCk7XG5cbiAgICAgICAgdmFyIGltZ1Bvc0xlZnQgPSB0aGlzLmxlZnQgKyBpbWdQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHZhciBpbWdQb3NUb3AgPSB0aGlzLnRvcCArIGltZ1BhZGRpbmcudG9wO1xuICAgICAgICB2YXIgaW1nV2lkdGggPSB0aGlzLndpZHRoIC0gaW1nUGFkZGluZy5sZWZ0IC0gaW1nUGFkZGluZy5yaWdodDtcbiAgICAgICAgdmFyIGltZ0hlaWdodCA9IHRoaXMuaGVpZ2h0IC0gaW1nUGFkZGluZy50b3AgLSBpbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgdGhpcy5pbWFnZU9iai5kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBpbWdQb3NMZWZ0LCBpbWdQb3NUb3AsIGltZ1dpZHRoLCBpbWdIZWlnaHQpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdJbWFnZUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICB2YXIgbGFiZWxEaW1lbnNpb25zID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgaWYgKGxhYmVsRGltZW5zaW9ucy5saW5lQ291bnQgPj0gMSkge1xuICAgICAgICAgIG9mZnNldCArPSBsYWJlbERpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgeUxhYmVsID0geSArIG9mZnNldDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCkge1xuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCBob3ZlciwgXCJoYW5naW5nXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGVJbWFnZUJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIENpcmNsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIENpcmNsZUltYWdlQmFzZVxuICovXG5cbnZhciBDaXJjbGUkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICBfaW5oZXJpdHMoQ2lyY2xlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHEoQ2lyY2xlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIENpcmNsZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDaXJjbGUsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdmFyIGRpYW1ldGVyID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdCwgZGltZW5zaW9ucy5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b20pO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IGRpYW1ldGVyIC8gMjsgLy8gTk9URTogdGhpcyBzaXplIGZpZWxkIG9ubHkgc2V0IGhlcmUsIG5vdCBpbiBFbGxpcHNlLCBEYXRhYmFzZSwgQm94XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY2xlO1xufShDaXJjbGVJbWFnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgQ2lyY3VsYXJJbWFnZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIENpcmNsZUltYWdlQmFzZVxuICovXG5cbnZhciBDaXJjdWxhckltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhDaXJjdWxhckltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHAoQ2lyY3VsYXJJbWFnZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqQWx0XG4gICAqL1xuICBmdW5jdGlvbiBDaXJjdWxhckltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY3VsYXJJbWFnZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2lyY3VsYXJJbWFnZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciBpbWFnZUFic2VudCA9IHRoaXMuaW1hZ2VPYmouc3JjID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbWFnZUFic2VudCkge1xuICAgICAgICB2YXIgZGlhbWV0ZXIgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIGFuIGltYWdlIGlzIHByZXNlbnQsIGkuZS4gdGhpcy5pbWFnZU9iaiBpcyB2YWxpZC5cblxuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB2YXIgbGFiZWxYID0geCxcbiAgICAgICAgICBsYWJlbFkgPSB5O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy50b3AgPSB5O1xuICAgICAgICBsYWJlbFggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGxhYmVsWSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gLy8gZHJhdyB0aGUgYmFja2dyb3VuZCBjaXJjbGUuIElNUE9SVEFOVDogdGhlIHN0cm9rZSBpbiB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGlwIG1ldGhvZCBiZWxvdy5cblxuXG4gICAgICB0aGlzLl9kcmF3UmF3Q2lyY2xlKGN0eCwgbGFiZWxYLCBsYWJlbFksIHZhbHVlcyk7IC8vIG5vdyB3ZSBkcmF3IGluIHRoZSBjaXJjbGUsIHdlIHNhdmUgc28gd2UgY2FuIHJldmVydCB0aGUgY2xpcCBvcGVyYXRpb24gYWZ0ZXIgZHJhd2luZy5cblxuXG4gICAgICBjdHguc2F2ZSgpOyAvLyBjbGlwIGlzIHVzZWQgdG8gdXNlIHRoZSBzdHJva2UgaW4gZHJhd1Jhd0NpcmNsZSBhcyBhbiBhcmVhIHRoYXQgd2UgY2FuIGRyYXcgaW4uXG5cbiAgICAgIGN0eC5jbGlwKCk7IC8vIGRyYXcgdGhlIGltYWdlXG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpOyAvLyByZXN0b3JlIHNvIHdlIGNhbiBhZ2FpbiBkcmF3IG9uIHRoZSBmdWxsIGNhbnZhc1xuXG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgbGFiZWxYLCBsYWJlbFksIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgfSAvLyBUT0RPOiBjb21wYXJlIHdpdGggQ2lyY2xlLnVwZGF0ZUJvdW5kaW5nQm94KCksIGNvbnNvbGlkYXRlPyBNb3JlIHN0dWZmIGlzIGhhcHBlbmluZyBoZXJlXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB9IC8vIFRPRE86IGNvbXBhcmUgd2l0aCBJbWFnZS51cGRhdGVCb3VuZGluZ0JveCgpLCBjb25zb2xpZGF0ZT9cblxuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY3VsYXJJbWFnZTtcbn0oQ2lyY2xlSW1hZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG8oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjb25zdHJ1Y3RpbmcgTm9kZS9DbHVzdGVyIFNoYXBlcy5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgU2hhcGVCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKFNoYXBlQmFzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG8oU2hhcGVCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFNoYXBlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFwZUJhc2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzPXtzaXplOiB0aGlzLm9wdGlvbnMuc2l6ZX1dXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNoYXBlQmFzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHtcbiAgICAgICAgc2l6ZTogdGhpcy5vcHRpb25zLnNpemVcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBfdGhpcyRjdXN0b21TaXplV2lkdGgsIF90aGlzJGN1c3RvbVNpemVIZWlnaDtcblxuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdmFyIHNpemUgPSAyICogdmFsdWVzLnNpemU7XG4gICAgICAgIHRoaXMud2lkdGggPSAoX3RoaXMkY3VzdG9tU2l6ZVdpZHRoID0gdGhpcy5jdXN0b21TaXplV2lkdGgpICE9PSBudWxsICYmIF90aGlzJGN1c3RvbVNpemVXaWR0aCAhPT0gdm9pZCAwID8gX3RoaXMkY3VzdG9tU2l6ZVdpZHRoIDogc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAoX3RoaXMkY3VzdG9tU2l6ZUhlaWdoID0gdGhpcy5jdXN0b21TaXplSGVpZ2h0KSAhPT0gbnVsbCAmJiBfdGhpcyRjdXN0b21TaXplSGVpZ2ggIT09IHZvaWQgMCA/IF90aGlzJGN1c3RvbVNpemVIZWlnaCA6IHNpemU7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVNdWx0aXBsaWVyIC0gVW51c2VkISBUT0RPOiBSZW1vdmUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3U2hhcGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdTaGFwZShjdHgsIHNoYXBlLCBzaXplTXVsdGlwbGllciwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZ2V0U2hhcGUoc2hhcGUpKGN0eCwgeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/IFwiYm9sZCBcIiA6IFwiXCIpICsgdGhpcy5oZWlnaHQgLyAyICsgXCJweCBcIiArICh0aGlzLm9wdGlvbnMuaWNvbi5mYWNlIHx8IFwiRm9udEF3ZXNvbWVcIik7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWw6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVsKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBmb2xsb3dpbmcgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdmFsdWUgZm9yXG4gICAgICAgICAgICAvLyBgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodGAuXG4gICAgICAgICAgICBfdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksIFwiaGFuZ2luZ1wiKTtcblxuICAgICAgICAgICAgdmFyIHlMYWJlbCA9IHkgKyAwLjUgKiBfdGhpcy5oZWlnaHQgKyAwLjUgKiBfdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodDtcblxuICAgICAgICAgICAgX3RoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsIGhvdmVyLCBcImhhbmdpbmdcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGFwZUJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDQob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IGZpbHRlcihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBfY29udGV4dCwgX2NvbnRleHQyOyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBmb3JFYWNoJDIoX2NvbnRleHQgPSBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksICEwKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBmb3JFYWNoJDIoX2NvbnRleHQyID0gb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgQ3VzdG9tU2hhcGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgQ3VzdG9tU2hhcGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKEN1c3RvbVNoYXBlLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG4oQ3VzdG9tU2hhcGUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdHhSZW5kZXJlclxuICAgKi9cbiAgZnVuY3Rpb24gQ3VzdG9tU2hhcGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGN0eFJlbmRlcmVyKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbVNoYXBlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGN0eFJlbmRlcmVyKTtcbiAgICBfdGhpcy5jdHhSZW5kZXJlciA9IGN0eFJlbmRlcmVyO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gZGlmZmVyZW50IGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ3VzdG9tU2hhcGUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjsgLy8gR3VhcmQgcmlnaHQgYXdheSBiZWNhdXNlIHNvbWVvbmUgbWF5IGp1c3QgZHJhdyBpbiB0aGUgZnVuY3Rpb24gaXRzZWxmLlxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGRyYXdMYXRlciA9IHRoaXMuY3R4UmVuZGVyZXIoe1xuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgaG92ZXI6IGhvdmVyXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkJDMoe30sIHZhbHVlcyksXG4gICAgICAgIGxhYmVsOiB0aGlzLm9wdGlvbnMubGFiZWxcbiAgICAgIH0pOyAvLyBSZW5kZXIgdGhlIG5vZGUgc2hhcGUgYmVsbG93IGFycm93cy5cblxuICAgICAgaWYgKGRyYXdMYXRlci5kcmF3Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGRyYXdMYXRlci5kcmF3Tm9kZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAoZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsKSB7XG4gICAgICAgIC8vIEd1YXJkIHRoZSBleHRlcm5hbCBsYWJlbCAoYWJvdmUgYXJyb3dzKSBkcmF3aW5nIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgZHJhd0V4dGVybmFsTGFiZWwgPSBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWw7XG5cbiAgICAgICAgZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZHJhd0V4dGVybmFsTGFiZWwoKTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZHJhd0xhdGVyLm5vZGVEaW1lbnNpb25zKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tU2l6ZVdpZHRoID0gZHJhd0xhdGVyLm5vZGVEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB0aGlzLmN1c3RvbVNpemVIZWlnaHQgPSBkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHJhd0xhdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXN0b21TaGFwZTtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG0oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIERhdGFiYXNlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgRGF0YWJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoRGF0YWJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRtKERhdGFiYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFiYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFiYXNlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhYmFzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IGRpbWVuc2lvbnMud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0RhdGFiYXNlKGN0eCwgeCAtIHRoaXMud2lkdGggLyAyLCB5IC0gdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YWJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGwoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIERpYW1vbmQgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgRGlhbW9uZCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhEaWFtb25kLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGwoRGlhbW9uZCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEaWFtb25kKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpYW1vbmQpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGlhbW9uZCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcImRpYW1vbmRcIiwgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaWFtb25kO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkayhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgRG90IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIERvdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoRG90LCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGsoRG90KTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIERvdChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb3QpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRG90LCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwiY2lyY2xlXCIsIDIsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb3Q7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRqKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQW0gRWxsaXBzZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIEVsbGlwc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoRWxsaXBzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGooRWxsaXBzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBFbGxpcHNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsbGlwc2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVsbGlwc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0VsbGlwc2UoY3R4LCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhID0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgIHZhciBiID0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICB2YXIgdyA9IE1hdGguc2luKGFuZ2xlKSAqIGE7XG4gICAgICB2YXIgaCA9IE1hdGguY29zKGFuZ2xlKSAqIGI7XG4gICAgICByZXR1cm4gYSAqIGIgLyBNYXRoLnNxcnQodyAqIHcgKyBoICogaCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVsbGlwc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBbiBpY29uIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBJY29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKEljb24sIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRpKEljb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gSWNvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEljb24sIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMuaWNvblNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKSxcbiAgICAgICAgICBoZWlnaHQ6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pY29uU2l6ZS53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmljb25TaXplLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMub3B0aW9ucy5pY29uLnNpemUgPSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplIHx8IDUwO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICB0aGlzLl9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbDogZnVuY3Rpb24gZHJhd0V4dGVybmFsTGFiZWwoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpY29uVGV4dFNwYWNpbmcgPSA1O1xuXG4gICAgICAgICAgICBfdGhpczIubGFiZWxNb2R1bGUuZHJhdyhjdHgsIF90aGlzMi5sZWZ0ICsgX3RoaXMyLmljb25TaXplLndpZHRoIC8gMiArIF90aGlzMi5tYXJnaW4ubGVmdCwgeSArIF90aGlzMi5oZWlnaHQgLyAyICsgaWNvblRleHRTcGFjaW5nLCBzZWxlY3RlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHZhciBpY29uVGV4dFNwYWNpbmcgPSA1O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0ICsgaWNvblRleHRTcGFjaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlciAtIFVudXNlZFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pY29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpY29uU2l6ZSA9IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZm9udCA9IFt0aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5pY29uLndlaWdodCA6IHNlbGVjdGVkID8gXCJib2xkXCIgOiBcIlwiLCAvLyBJZiB0aGUgd2VpZ2h0IGlzIGZvcmNlZCAoZm9yIGV4YW1wbGUgdG8gbWFrZSBGb250IEF3ZXNvbWUgNSB3b3JrXG4gICAgICAgIC8vIHByb3Blcmx5KSBzdWJzdGl0dXRlIHNsaWdodGx5IGJpZ2dlciBzaXplIGZvciBib2xkIGZvbnQgZmFjZS5cbiAgICAgICAgKHRoaXMub3B0aW9ucy5pY29uLndlaWdodCAhPSBudWxsICYmIHNlbGVjdGVkID8gNSA6IDApICsgaWNvblNpemUgKyBcInB4XCIsIHRoaXMub3B0aW9ucy5pY29uLmZhY2VdLmpvaW4oXCIgXCIpOyAvLyBkcmF3IGljb25cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmljb24uY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlLCB4LCB5KTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIldoZW4gdXNpbmcgdGhlIGljb24gc2hhcGUsIHlvdSBuZWVkIHRvIGRlZmluZSB0aGUgY29kZSBpbiB0aGUgaWNvbiBvcHRpb25zIG9iamVjdC4gVGhpcyBjYW4gYmUgZG9uZSBwZXIgbm9kZSBvciBnbG9iYWxseS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEljb247XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBbiBpbWFnZS1iYXNlZCByZXBsYWNlbWVudCBmb3IgdGhlIGRlZmF1bHQgTm9kZSBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cblxudmFyIEltYWdlJDIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGgoSW1hZ2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9ialxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9iakFsdFxuICAgKi9cbiAgZnVuY3Rpb24gSW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEltYWdlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuICAgICAgdmFyIGltYWdlQWJzZW50ID0gdGhpcy5pbWFnZU9iai5zcmMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGltYWdlQWJzZW50KSB7XG4gICAgICAgIHZhciBzaWRlID0gdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gc2lkZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaWRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB2YXIgbGFiZWxYID0geCxcbiAgICAgICAgICBsYWJlbFkgPSB5O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy50b3AgPSB5O1xuICAgICAgICBsYWJlbFggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGxhYmVsWSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlQm9yZGVyV2l0aEltYWdlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgIHZhciBmaWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQgOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDtcblxuICAgICAgICBpZiAodmFsdWVzLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0cm9rZVN0eWxlID0gb3ZlcnJpZGVPcGFjaXR5KHN0cm9rZVN0eWxlLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgZmlsbFN0eWxlID0gb3ZlcnJpZGVPcGFjaXR5KGZpbGxTdHlsZSwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9IC8vIHNldHVwIHRoZSBsaW5lIHByb3BlcnRpZXMuXG5cblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTsgLy8gc2V0IGEgZmlsbHN0eWxlXG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTsgLy8gZHJhdyBhIHJlY3RhbmdsZSB0byBmb3JtIHRoZSBib3JkZXIgYXJvdW5kLiBUaGlzIHJlY3RhbmdsZSBpcyBmaWxsZWQgc28gdGhlIG9wYWNpdHkgb2YgYSBwaWN0dXJlIChpbiBmdXR1cmUgdmlzIHJlbGVhc2VzPykgY2FuIGJlIHVzZWQgdG8gdGludCB0aGUgaW1hZ2VcblxuICAgICAgICBjdHgucmVjdCh0aGlzLmxlZnQgLSAwLjUgKiBjdHgubGluZVdpZHRoLCB0aGlzLnRvcCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMud2lkdGggKyBjdHgubGluZVdpZHRoLCB0aGlzLmhlaWdodCArIGN0eC5saW5lV2lkdGgpO1xuXG4gICAgICAgIGZpbGwoY3R4KS5jYWxsKGN0eCk7XG5cbiAgICAgICAgdGhpcy5wZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgdmFsdWVzKTtcblxuICAgICAgdGhpcy5fZHJhd0ltYWdlTGFiZWwoY3R4LCBsYWJlbFgsIGxhYmVsWSwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHg7XG4gICAgICAgIHRoaXMudG9wID0geTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZTtcbn0oQ2lyY2xlSW1hZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIFNxdWFyZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBTcXVhcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKFNxdWFyZSwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRnKFNxdWFyZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTcXVhcmUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3F1YXJlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNxdWFyZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInNxdWFyZVwiLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNxdWFyZTtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGYoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIEhleGFnb24gTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgSGV4YWdvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoSGV4YWdvbiwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRmKEhleGFnb24pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gSGV4YWdvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZXhhZ29uKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhleGFnb24sIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJoZXhhZ29uXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGV4YWdvbjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIFN0YXIgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgU3RhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoU3RhciwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRlKFN0YXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RhcihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFyKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN0YXIsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJzdGFyXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Rhcjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIHRleHQtYmFzZWQgcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIFRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoVGV4dCwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGQoVGV4dCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRleHQsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMudGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudGV4dFNpemUud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy50ZXh0U2l6ZS5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b207XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0O1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRjKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBUcmlhbmdsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBUcmlhbmdsZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhUcmlhbmdsZSwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRjKFRyaWFuZ2xlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJ0cmlhbmdsZVwiLCAzLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyaWFuZ2xlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgZG93bndhcmQgZmFjaW5nIFRyaWFuZ2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIFRyaWFuZ2xlRG93biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoVHJpYW5nbGVEb3duLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGIoVHJpYW5nbGVEb3duKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlRG93bihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZURvd24pO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhUcmlhbmdsZURvd24sIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJ0cmlhbmdsZURvd25cIiwgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmlhbmdsZURvd247XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0ga2V5cyQ0KG9iamVjdCk7IGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBmaWx0ZXIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgX2NvbnRleHQ1LCBfY29udGV4dDY7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IGZvckVhY2gkMihfY29udGV4dDUgPSBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksICEwKSkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogZm9yRWFjaCQyKF9jb250ZXh0NiA9IG93bktleXMkMihPYmplY3Qoc291cmNlKSkpLmNhbGwoX2NvbnRleHQ2LCBmdW5jdGlvbiAoa2V5KSB7IGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxuICogQSBub2RlLiBBIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyB2aWEgb25lIG9yIG11bHRpcGxlIGVkZ2VzLlxuICovXG5cbnZhciBOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHRoZSBub2RlLiBBbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBhcmUgb3B0aW9uYWwsIGV4Y2VwdCBmb3IgdGhlIGlkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IGlkICAgICBJZCBvZiB0aGUgbm9kZS4gUmVxdWlyZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsYWJlbCAgVGV4dCBsYWJlbCBmb3IgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB4ICAgICAgSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IHkgICAgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IHNoYXBlICBOb2RlIHNoYXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gaW1hZ2UgIEFuIGltYWdlIHVybFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IHRpdGxlICBBIHRpdGxlIHRleHQsIGNhbiBiZSBIVE1MXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2FueXR5cGV9IGdyb3VwIEEgZ3JvdXAgbmFtZSBvciBudW1iZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHkgICAgICAgICAgICAgICBTaGFyZWQgc3RhdGUgb2YgY3VycmVudCBuZXR3b3JrIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TmV0d29yay5JbWFnZXN9IGltYWdlbGlzdCAgQSBsaXN0IHdpdGggaW1hZ2VzLiBPbmx5IG5lZWRlZCB3aGVuIHRoZSBub2RlIGhhcyBhbiBpbWFnZVxuICAgKiBAcGFyYW0ge0dyb3Vwc30gZ3JvdXBsaXN0ICAgICAgICAgIEEgbGlzdCB3aXRoIGdyb3Vwcy4gTmVlZGVkIGZvciByZXRyaWV2aW5nIGdyb3VwIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnMgICAgICBDdXJyZW50IGdsb2JhbCBub2RlIG9wdGlvbnM7IHRoZXNlIHNlcnZlIGFzIGRlZmF1bHRzIGZvciB0aGUgbm9kZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdE9wdGlvbnMgICAgIEdsb2JhbCBkZWZhdWx0IG9wdGlvbnMgZm9yIG5vZGVzOyBub3RlIHRoYXQgdGhpcyBpcyBhbHNvIHRoZSBwcm90b3R5cGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgcGFyYW1ldGVyIGBnbG9iYWxPcHRpb25zYC5cbiAgICovXG4gIGZ1bmN0aW9uIE5vZGUob3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5lZGdlcyA9IFtdOyAvLyBhbGwgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZVxuICAgIC8vIHNldCBkZWZhdWx0cyBmb3IgdGhlIG9wdGlvbnNcblxuICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbWFnZWxpc3QgPSBpbWFnZWxpc3Q7XG4gICAgdGhpcy5ncm91cGxpc3QgPSBncm91cGxpc3Q7IC8vIHN0YXRlIG9wdGlvbnNcblxuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMub3B0aW9ucy5zaXplO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlOyAvLyB1c2VkIHRvIGNoZWNrIGlmIGluaXRpYWwgZml0IHNob3VsZCBqdXN0IHRha2UgdGhlIHJhbmdlIG9yIGFwcHJveGltYXRlXG5cbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIGZhbHNlXG4gICAgLyogTm90IGVkZ2UgbGFiZWwgKi9cbiAgICApO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIGEgZWRnZSB0byB0aGUgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICBrZXk6IFwiYXR0YWNoRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgaWYgKGluZGV4T2YoX2NvbnRleHQgPSB0aGlzLmVkZ2VzKS5jYWxsKF9jb250ZXh0LCBlZGdlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSBlZGdlIGZyb20gdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0YWNoRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgIHZhciBpbmRleCA9IGluZGV4T2YoX2NvbnRleHQyID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dDIsIGVkZ2UpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICBzcGxpY2UkMShfY29udGV4dDMgPSB0aGlzLmVkZ2VzKS5jYWxsKF9jb250ZXh0MywgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgb3Igb3ZlcndyaXRlIG9wdGlvbnMgZm9yIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAgICogQHJldHVybnMge251bGx8Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFNoYXBlID0gdGhpcy5vcHRpb25zLnNoYXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBOb3RlIHRoYXQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlICd1bmRlZmluZWQnISBUaGlzIGlzIE9LLlxuICAgICAgfSAvLyBTYXZlIHRoZSBjb2xvciBmb3IgbGF0ZXIuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2FsIGNvbG9yIGZyb20gYmVpbmcgb3ZlcndyaXR0ZW4gYnkgZ3JvdXAgY29sb3IuXG4gICAgICAvLyBUT0RPOiBUbyBwcmV2ZW50IHN1Y2ggd29ya2Fyb3VuZHMgdGhlIHdheSBvcHRpb25zIGFyZSBoYW5kbGVkIHNob3VsZCBiZSByZXdyaXR0ZW4gZnJvbSBzY3JhdGNoLlxuICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIG9ubHkgcHJvYmxlbSB3aXRoIGN1cnJlbnQgb3B0aW9ucyBoYW5kbGluZy5cblxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29sb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxDb2xvciA9IG9wdGlvbnMuY29sb3I7XG4gICAgICB9IC8vIGJhc2ljIG9wdGlvbnNcblxuXG4gICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgbXVzdCBoYXZlIGFuIGlkXCIpO1xuICAgICAgfVxuXG4gICAgICBOb2RlLmNoZWNrTWFzcyhvcHRpb25zLCB0aGlzLmlkKTsgLy8gc2V0IHRoZXNlIG9wdGlvbnMgbG9jYWxseVxuICAgICAgLy8gY2xlYXIgeCBhbmQgeSBwb3NpdGlvbnNcblxuICAgICAgaWYgKG9wdGlvbnMueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnggPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnggPSBfcGFyc2VJbnQob3B0aW9ucy54KTtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnkgPSBfcGFyc2VJbnQob3B0aW9ucy55KTtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZVNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IF9wYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgfSAvLyB0aGlzIHRyYW5zZm9ybXMgYWxsIHNob3J0aGFuZHMgaW50byBmdWxseSBkZWZpbmVkIG9wdGlvbnNcblxuXG4gICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucywgdGhpcy5ncm91cGxpc3QpO1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zXTtcbiAgICAgIHRoaXMuY2hvb3NlciA9IGNob29zaWZ5KFwibm9kZVwiLCBwaWxlKTtcblxuICAgICAgdGhpcy5fbG9hZF9pbWFnZXMoKTtcblxuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTsgLy8gTmVlZCB0byBzZXQgbG9jYWwgb3BhY2l0eSBhZnRlciBgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTtgIGJlY2F1c2UgYHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7YCBvdmVycml0ZXMgbG9jYWwgb3BhY2l0eSB3aXRoIGdyb3VwIG9wYWNpdHlcblxuICAgICAgaWYgKG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIE5vZGUuY2hlY2tPcGFjaXR5KG9wdGlvbnMub3BhY2l0eSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU2hhcGUoY3VycmVudFNoYXBlKTtcbiAgICAgIHJldHVybiBvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBpbWFnZXMgZnJvbSB0aGUgb3B0aW9ucywgZm9yIHRoZSBub2RlcyB0aGF0IG5lZWQgdGhlbS5cbiAgICAgKlxuICAgICAqIEltYWdlcyBhcmUgYWx3YXlzIGxvYWRlZCwgZXZlbiBpZiB0aGV5IGFyZSBub3QgdXNlZCBpbiB0aGUgY3VycmVudCBzaGFwZS5cbiAgICAgKiBUaGUgdXNlciBtYXkgc3dpdGNoIHRvIGFuIGltYWdlIHNoYXBlIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkX2ltYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZF9pbWFnZXMoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlID09PSBcImNpcmN1bGFySW1hZ2VcIiB8fCB0aGlzLm9wdGlvbnMuc2hhcGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gaW1hZ2UgbXVzdCBiZSBkZWZpbmVkIGZvciBub2RlIHR5cGUgJ1wiICsgdGhpcy5vcHRpb25zLnNoYXBlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmltYWdlbGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBObyBpbWFnZXMgcHJvdmlkZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZSwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UudW5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdW5zZWxlY3RlZCBpbWFnZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgb3BhY2l0eSBpcyBvbmx5IGJldHdlZW4gMCBhbmQgMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7Y29sb3I6ICosIGJvcmRlcldpZHRoOiAqLCBib3JkZXJDb2xvcjogKiwgc2l6ZTogKiwgYm9yZGVyRGFzaGVzOiAoYm9vbGVhbnxBcnJheXxhbGxPcHRpb25zLm5vZGVzLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXN8e2Jvb2xlYW4sIGFycmF5fSksIGJvcmRlclJhZGl1czogKG51bWJlcnxhbGxPcHRpb25zLm5vZGVzLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXN8e251bWJlcn18QXJyYXkpLCBzaGFkb3c6ICosIHNoYWRvd0NvbG9yOiAqLCBzaGFkb3dTaXplOiAqLCBzaGFkb3dYOiAqLCBzaGFkb3dZOiAqfX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgY29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wdGlvbnMub3BhY2l0eSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXIsXG4gICAgICAgIHNpemU6IHRoaXMub3B0aW9ucy5zaXplLFxuICAgICAgICBib3JkZXJEYXNoZXM6IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWx1ZXMuYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJXaWR0aCAqPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQ7XG4gICAgICAgICAgICB2YWx1ZXMuYm9yZGVyQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvd0NvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IHZhbHVlcy5zaGFkb3dTaXplICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUgfHwgdmFsdWVzLnNoYWRvd1ggIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueCB8fCB2YWx1ZXMuc2hhZG93WSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy55KSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5ib3JkZXJDb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIHZhbHVlcy5jb2xvciA9IG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuY29sb3IsIG9wYWNpdHkpO1xuICAgICAgICB2YWx1ZXMuc2hhZG93Q29sb3IgPSBvdmVycmlkZU9wYWNpdHkodmFsdWVzLnNoYWRvd0NvbG9yLCBvcGFjaXR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTGFiZWxNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5sYWJlbCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubGFiZWwgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyh0aGlzLm9wdGlvbnMsIF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBjb2xvcjogb3B0aW9ucyAmJiBvcHRpb25zLmNvbG9yIHx8IHRoaXMuX2xvY2FsQ29sb3IgfHwgdW5kZWZpbmVkXG4gICAgICB9KSwgdGhpcy5ncm91cGxpc3QpOyAvL1xuICAgICAgLy8gTm90ZTpUaGUgcHJvdG90eXBlIGNoYWluIGZvciB0aGlzLm9wdGlvbnMgaXM6XG4gICAgICAvL1xuICAgICAgLy8gdGhpcy5vcHRpb25zIC0+ICAgIE5vZGVzSGFuZGxlci5vcHRpb25zICAgIC0+IE5vZGVzSGFuZGxlci5kZWZhdWx0T3B0aW9uc1xuICAgICAgLy8gICAgICAgICAgICAgICAgIChhbHNvOiB0aGlzLmdsb2JhbE9wdGlvbnMpXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHRoZSBwcm90b3R5cGVzIGFyZSBtZW50aW9uZWQgZXhwbGljaXRseSBpbiB0aGUgcGlsZSBsaXN0IGJlbG93O1xuICAgICAgLy8gV0UgRE9OJ1QgV0FOVCBUSEUgT1JERVIgT0YgVEhFIFBST1RPVFlQRVMhISEhIEF0IGxlYXN0LCBub3QgZm9yIGZvbnQgaGFuZGxpbmcgb2YgbGFiZWxzLlxuICAgICAgLy8gVGhpcyBpcyBhIGdvb2QgaW5kaWNhdGlvbiB0aGF0IHRoZSBwcm90b3R5cGUgdXNhZ2Ugb2Ygb3B0aW9ucyBpcyBkZWZpY2llbnQuXG4gICAgICAvL1xuXG4gICAgICB2YXIgY3VycmVudEdyb3VwID0gdGhpcy5ncm91cGxpc3QuZ2V0KHRoaXMub3B0aW9ucy5ncm91cCwgZmFsc2UpO1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgLy8gbmV3IG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9ucywgLy8gY3VycmVudCBub2RlIG9wdGlvbnMsIHNlZSBjb21tZW50IGFib3ZlIGZvciBwcm90b3R5cGVcbiAgICAgIGN1cnJlbnRHcm91cCwgLy8gZ3JvdXAgb3B0aW9ucywgaWYgYW55XG4gICAgICB0aGlzLmdsb2JhbE9wdGlvbnMsIC8vIEN1cnJlbnRseSBzZXQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyAvLyBEZWZhdWx0IGdsb2JhbCBub2RlIG9wdGlvbnNcbiAgICAgIF07XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLnVwZGF0ZSh0aGlzLm9wdGlvbnMsIHBpbGUpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFNoYXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpIHtcbiAgICAgIGlmIChjdXJyZW50U2hhcGUgPT09IHRoaXMub3B0aW9ucy5zaGFwZSAmJiB0aGlzLnNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hvb3NlIGRyYXcgbWV0aG9kIGRlcGVuZGluZyBvbiB0aGUgc2hhcGVcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgICBjYXNlIFwiYm94XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEJveCQxKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDaXJjbGUkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJjaXJjdWxhckltYWdlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IENpcmN1bGFySW1hZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY3VzdG9tXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEN1c3RvbVNoYXBlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLm9wdGlvbnMuY3R4UmVuZGVyZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZGF0YWJhc2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRGF0YWJhc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEaWFtb25kJDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZG90XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERvdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEVsbGlwc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaWNvblwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBJY29uKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEltYWdlJDIodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFNxdWFyZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJoZXhhZ29uXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEhleGFnb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwic3RhclwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdGFyKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVGV4dCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZSQxKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRyaWFuZ2xlRG93blwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZURvd24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBFbGxpcHNlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVlZHNSZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubmVlZHNSZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVuc2VsZWN0IHRoaXMgbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY2FsY3VsYXRlZCBzaXplIG9mIHRoZSBub2RlLCBmb3JjZXMgaXQgdG8gcmVjYWxjdWxhdGUgaXRzIHNpemVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5lZWRzUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWVkc1JlZnJlc2goKSB7XG4gICAgICB0aGlzLnNoYXBlLnJlZnJlc2hOZWVkZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgbm9kZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGUgYm9yZGVyIG9mIHRoZSBOb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgICAgICAgIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZSAgIERpc3RhbmNlIHRvIHRoZSBib3JkZXIgaW4gcGl4ZWxzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBub2RlIGhhcyBhIGZpeGVkIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgIHRydWUgaWYgZml4ZWQsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGaXhlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpeGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXhlZC54ICYmIHRoaXMub3B0aW9ucy5maXhlZC55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGlzIG5vZGUgaXMgc2VsZWN0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHNlbGVjdGVkICAgVHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBlbHNlIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1NlbGVjdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBub2RlLiBDYW4gYmUgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZGltZW5zaW9ucyBvZiB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtyZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsTW9kdWxlLnNpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSB2YWx1ZSByYW5nZSBvZiB0aGUgbm9kZS4gVGhlIG5vZGUgd2lsbCBhZGp1c3QgaXQncyBzaXplXG4gICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFZhbHVlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVSYW5nZShtaW4sIG1heCwgdG90YWwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICB2YXIgc2l6ZURpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbiArIHNjYWxlICogc2l6ZURpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IHRoaXMuYmFzZVNpemU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLmJhc2VGb250U2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgbm9kZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZHJhdyhjdHgsIHRoaXMueCwgdGhpcy55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpIHx8IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgc2hhcGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goY3R4KSB7XG4gICAgICB0aGlzLnNoYXBlLnVwZGF0ZUJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCBjdHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgdGhpcy5zaGFwZS5yZXNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHZpc3VhbCBlbGVtZW50cyBvZiB0aGlzIG5vZGUgaW5zdGFuY2UsIGluIHdoaWNoIHRoZSBnaXZlblxuICAgICAqIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgYm91bmRpbmcgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bm9kZUNsaWNrSXRlbXxub2RlTGFiZWxDbGlja0l0ZW0+fSBsaXN0IHdpdGggdGhlIGl0ZW1zIHdoaWNoIGFyZSBvbiB0aGUgcG9pbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEl0ZW1zT25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtc09uUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSwgcG9pbnQpKSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgbm9kZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbGFiZWxJZDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLnNoYXBlLmJvdW5kaW5nQm94LCBwb2ludCkpIHtcbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgIG5vZGVJZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlZnQgPCBvYmoucmlnaHQgJiYgdGhpcy5zaGFwZS5sZWZ0ICsgdGhpcy5zaGFwZS53aWR0aCA+IG9iai5sZWZ0ICYmIHRoaXMuc2hhcGUudG9wIDwgb2JqLmJvdHRvbSAmJiB0aGlzLnNoYXBlLnRvcCArIHRoaXMuc2hhcGUuaGVpZ2h0ID4gb2JqLnRvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQgPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20gPiBvYmoudG9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZCB2YWx1ZXMgZm9yIG1hc3NcbiAgICAgKlxuICAgICAqIFRoZSBtYXNzIG1heSBub3QgYmUgbmVnYXRpdmUgb3IgemVyby4gSWYgaXQgaXMsIHJlc2V0IHRvIDFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBpZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwiY2hlY2tPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICByZXR1cm4gMCA8PSBvcGFjaXR5ICYmIG9wYWNpdHkgPD0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBvcmlnaW4gaXMgJ2NlbnRlcicgb3IgJ3RvcC1sZWZ0J1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tDb29yZGluYXRlT3JpZ2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29vcmRpbmF0ZU9yaWdpbihvcmlnaW4pIHtcbiAgICAgIHJldHVybiBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fCBvcmlnaW4gPT09IFwiY2VudGVyXCIgfHwgb3JpZ2luID09PSBcInRvcC1sZWZ0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgZ3JvdXAgb3B0aW9uIHZhbHVlcyBpbnRvIHRoZSBub2RlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgZ3JvdXAgb3B0aW9ucyBvdmVycmlkZSB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucywgc28gdGhlIGNvcHkgb2YgZ3JvdXAgb3B0aW9uc1xuICAgICAqICBtdXN0IGhhcHBlbiAqYWZ0ZXIqIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGFsc28gYmUgY2FsbGVkIGFsc28gaWYgdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkIGFuZCB0aGUgZ3JvdXAgb3B0aW9ucyBkaWQgbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9ucyAgbmV3IHZhbHVlcyBmb3IgdGhlIG9wdGlvbnMsIGN1cnJlbnRseSBvbmx5IHBhc3NlZCBpbiBmb3IgY2hlY2tcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBMaXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVHcm91cE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlR3JvdXBPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGdyb3VwTGlzdCkge1xuICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgaWYgKGdyb3VwTGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIE5vIGdyb3Vwcywgbm90aGluZyB0byBkb1xuXG4gICAgICB2YXIgZ3JvdXAgPSBwYXJlbnRPcHRpb25zLmdyb3VwOyAvLyBwYXJhbm9pYTogdGhlIHNlbGVjdGVkIGdyb3VwIGlzIGFscmVhZHkgbWVyZ2VkIGludG8gbm9kZSBvcHRpb25zLCBjaGVjay5cblxuICAgICAgaWYgKG5ld09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmdyb3VwICE9PSB1bmRlZmluZWQgJiYgZ3JvdXAgIT09IG5ld09wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXBkYXRlR3JvdXBPcHRpb25zOiBncm91cCB2YWx1ZXMgaW4gb3B0aW9ucyBkb24ndCBtYXRjaC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNHcm91cCA9IHR5cGVvZiBncm91cCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZ3JvdXAgPT09IFwic3RyaW5nXCIgJiYgZ3JvdXAgIT0gXCJcIjtcbiAgICAgIGlmICghaGFzR3JvdXApIHJldHVybjsgLy8gY3VycmVudCBub2RlIGhhcyBubyBncm91cCwgbm8gbmVlZCB0byBtZXJnZVxuXG4gICAgICB2YXIgZ3JvdXBPYmogPSBncm91cExpc3QuZ2V0KGdyb3VwKTtcblxuICAgICAgaWYgKGdyb3VwT2JqLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLm9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU5vZGUuY2hlY2tPcGFjaXR5KGdyb3VwT2JqLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBncm91cE9iai5vcGFjaXR5KTtcbiAgICAgICAgICBncm91cE9iai5vcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IC8vIFNraXAgYW55IG5ldyBvcHRpb24gdG8gYXZvaWQgdGhlbSBiZWluZyBvdmVycmlkZGVuIGJ5IHRoZSBncm91cCBvcHRpb25zLlxuXG5cbiAgICAgIHZhciBza2lwUHJvcGVydGllcyA9IGZpbHRlcihfY29udGV4dDQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKG5ld09wdGlvbnMpKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnNbcF0gIT0gbnVsbDtcbiAgICAgIH0pOyAvLyBBbHdheXMgc2tpcCBtZXJnaW5nIGdyb3VwIGZvbnQgb3B0aW9ucyBpbnRvIHBhcmVudDsgdGhlc2UgYXJlIHJlcXVpcmVkIHRvIGJlIGRpc3RpbmN0IGZvciBsYWJlbHNcblxuXG4gICAgICBza2lwUHJvcGVydGllcy5wdXNoKFwiZm9udFwiKTtcbiAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoc2tpcFByb3BlcnRpZXMsIHBhcmVudE9wdGlvbnMsIGdyb3VwT2JqKTsgLy8gdGhlIGNvbG9yIG9iamVjdCBuZWVkcyB0byBiZSBjb21wbGV0ZWx5IGRlZmluZWQuXG4gICAgICAvLyBTaW5jZSBncm91cHMgY2FuIHBhcnRpYWxseSBvdmVyd3JpdGUgdGhlIGNvbG9ycywgd2UgcGFyc2UgaXQgYWdhaW4sIGp1c3QgaW4gY2FzZS5cblxuICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHBhcnNlQ29sb3IocGFyZW50T3B0aW9ucy5jb2xvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvY2VzcyBhbGwgcG9zc2libGUgc2hvcnRoYW5kcyBpbiB0aGUgbmV3IG9wdGlvbnMgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50T3B0aW9ucyBhcmUgZnVsbHkgZGVmaW5lZC5cbiAgICAgKiBTdGF0aWMgc28gaXQgY2FuIGFsc28gYmUgdXNlZCBieSB0aGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2dyb3VwTGlzdF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBncm91cExpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmaWVsZHMgPSBbXCJjb2xvclwiLCBcImZpeGVkXCIsIFwic2hhZG93XCJdO1xuICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuICAgICAgTm9kZS5jaGVja01hc3MobmV3T3B0aW9ucyk7XG5cbiAgICAgIGlmIChwYXJlbnRPcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU5vZGUuY2hlY2tPcGFjaXR5KHBhcmVudE9wdGlvbnMub3BhY2l0eSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIHBhcmVudE9wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5vcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU5vZGUuY2hlY2tPcGFjaXR5KG5ld09wdGlvbnMub3BhY2l0eSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIG5ld09wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgbmV3T3B0aW9ucy5vcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLnNoYXBlUHJvcGVydGllcyAmJiAhTm9kZS5jaGVja0Nvb3JkaW5hdGVPcmlnaW4obmV3T3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIGNvb3JkaW5hdGVPcmlnaW4sIGZvdW5kOiBcIiArIG5ld09wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pO1xuICAgICAgfSAvLyBtZXJnZSB0aGUgc2hhZG93IG9wdGlvbnMgaW50byB0aGUgcGFyZW50LlxuXG5cbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNoYWRvd1wiLCBnbG9iYWxPcHRpb25zKTsgLy8gaW5kaXZpZHVhbCBzaGFwZSBuZXdPcHRpb25zXG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZUNvbG9yKG5ld09wdGlvbnMuY29sb3IpO1xuICAgICAgICBmaWxsSWZEZWZpbmVkKHBhcmVudE9wdGlvbnMuY29sb3IsIHBhcnNlZENvbG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9IC8vIGhhbmRsZSB0aGUgZml4ZWQgb3B0aW9uc1xuXG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5maXhlZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZml4ZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC54ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnkgPSBuZXdPcHRpb25zLmZpeGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC54ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC54ID0gbmV3T3B0aW9ucy5maXhlZC54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC55ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZC55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmZvbnQgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5mb250ID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIE5vZGUudXBkYXRlR3JvdXBPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGdyb3VwTGlzdCk7IC8vIGhhbmRsZSB0aGUgc2NhbGluZyBvcHRpb25zLCBzcGVjaWZpY2FsbHkgdGhlIGxhYmVsIHBhcnRcblxuICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgXCJsYWJlbFwiLCBnbG9iYWxPcHRpb25zLnNjYWxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja01hc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tNYXNzKG9wdGlvbnMsIGlkKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5tYXNzIDw9IDApIHtcbiAgICAgICAgdmFyIHN0cklkID0gXCJcIjtcblxuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0cklkID0gXCIgaW4gbm9kZSBpZDogXCIgKyBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY05lZ2F0aXZlIG9yIHplcm8gbWFzcyBkaXNhbGxvd2VkXCIgKyBzdHJJZCArIFwiLCBzZXR0aW5nIG1hc3MgdG8gMS5cIiwgVkFMSURBVE9SX1BSSU5UX1NUWUxFKTtcbiAgICAgICAgb3B0aW9ucy5tYXNzID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQ0OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0NCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDQsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxuICogSGFuZGxlciBmb3IgTm9kZXNcbiAqL1xuXG52YXIgTm9kZXNIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7SW1hZ2VzfSBpbWFnZXNcbiAgICogQHBhcmFtIHtBcnJheS48R3JvdXA+fSBncm91cHNcbiAgICogQHBhcmFtIHtMYXlvdXRFbmdpbmV9IGxheW91dEVuZ2luZVxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzLCBsYXlvdXRFbmdpbmUpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2Rlc0hhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcbiAgICB0aGlzLmxheW91dEVuZ2luZSA9IGxheW91dEVuZ2luZTsgLy8gY3JlYXRlIHRoZSBub2RlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcblxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSA9IGJpbmQkNihfY29udGV4dCA9IHRoaXMuY3JlYXRlKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLm5vZGVzTGlzdGVuZXJzID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMsIHBhcmFtcy5kYXRhLCBwYXJhbXMub2xkRGF0YSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGJyb2tlbkltYWdlOiB1bmRlZmluZWQsXG4gICAgICBjb2xvcjoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5N0MyRkNcIixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHVuZGVmaW5lZCxcbiAgICAgIC8vIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgIGZpeGVkOiB7XG4gICAgICAgIHg6IGZhbHNlLFxuICAgICAgICB5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFwiIzM0MzQzNFwiLFxuICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZTogXCJhcmlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogXCJib2xkXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcIml0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6IFwiXCIsXG4gICAgICAgICAgc2l6ZTogMTUsXG4gICAgICAgICAgLy8gcHhcbiAgICAgICAgICBmYWNlOiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiBcIkZvbnRBd2Vzb21lXCIsXG4gICAgICAgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAgICAgY29kZTogdW5kZWZpbmVkLFxuICAgICAgICAvLydcXHVmMDA3JyxcbiAgICAgICAgc2l6ZTogNTAsXG4gICAgICAgIC8vNTAsXG4gICAgICAgIGNvbG9yOiBcIiMyQjdDRTlcIiAvLycjYWEwMGZmJ1xuXG4gICAgICB9LFxuICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgIC8vIC0tPiBVUkxcbiAgICAgIGltYWdlUGFkZGluZzoge1xuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgbGV2ZWw6IHVuZGVmaW5lZCxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICB0b3A6IDUsXG4gICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICBib3R0b206IDUsXG4gICAgICAgIGxlZnQ6IDVcbiAgICAgIH0sXG4gICAgICBtYXNzOiAxLFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiAxMCxcbiAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBtaW46IDE0LFxuICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogNVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgeDogNSxcbiAgICAgICAgeTogNVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiBcImVsbGlwc2VcIixcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBib3JkZXJzXG4gICAgICAgIGJvcmRlclJhZGl1czogNixcbiAgICAgICAgLy8gb25seSBmb3IgYm94IHNoYXBlXG4gICAgICAgIGludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICB1c2VJbWFnZVNpemU6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgY29vcmRpbmF0ZU9yaWdpbjogXCJjZW50ZXJcIiAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcblxuICAgICAgfSxcbiAgICAgIHNpemU6IDI1LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB4OiB1bmRlZmluZWQsXG4gICAgICB5OiB1bmRlZmluZWRcbiAgICB9OyAvLyBQcm90ZWN0IGZyb20gaWRpb2N5XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy5tYXNzIDw9IDApIHtcbiAgICAgIHRocm93IFwiSW50ZXJuYWwgZXJyb3I6IG1hc3MgaW4gZGVmYXVsdE9wdGlvbnMgb2YgTm9kZXNIYW5kbGVyIG1heSBub3QgYmUgemVybyBvciBuZWdhdGl2ZVwiO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IGJyaWRnZU9iamVjdCh0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTm9kZXNIYW5kbGVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF9jb250ZXh0MixcbiAgICAgICAgICBfY29udGV4dDMsXG4gICAgICAgICAgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gcmVmcmVzaCB0aGUgbm9kZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hOb2Rlc1wiLCBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsIGJpbmQkNihfY29udGV4dDMgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXMyLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEubm9kZXMpIF90aGlzMi5ib2R5LmRhdGEubm9kZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLnVwZGF0ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgTm9kZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gTmVlZCB0byBzZXQgb3BhY2l0eSBoZXJlIGJlY2F1c2UgTm9kZS5wYXJzZU9wdGlvbnMgaXMgYWxzbyB1c2VkIGZvciBncm91cHMsXG4gICAgICAgIC8vIGlmIHlvdSBzZXQgb3BhY2l0eSBpbiBOb2RlLnBhcnNlT3B0aW9ucyBpdCBvdmVyd3JpdGVzIGdyb3VwIG9wYWNpdHkuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGlzTmFuKG9wdGlvbnMub3BhY2l0eSkgfHwgIV9pc0Zpbml0ZShvcHRpb25zLm9wYWNpdHkpIHx8IG9wdGlvbnMub3BhY2l0eSA8IDAgfHwgb3B0aW9ucy5vcGFjaXR5ID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBvcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIHRoZSBzaGFwZSBpbiBhbGwgbm9kZXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zLnNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS51cGRhdGVTaGFwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIGxhYmVscyBvZiBub2RlcyBpZiBhbnkgcmVsZXZhbnQgb3B0aW9ucyBjaGFuZ2VkLlxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvbnQgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG9wdGlvbnMud2lkdGhDb25zdHJhaW50ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBvcHRpb25zLmhlaWdodENvbnN0cmFpbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IGtleXMkNCh0aGlzLmJvZHkubm9kZXMpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZUlkID0gX09iamVjdCRrZXlzW19pXTtcblxuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIHRoZSBzaGFwZSBzaXplIGluIGFsbCBub2Rlc1xuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcywgX25vZGVJZDIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0ubmVlZHNSZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHZhcmlhYmxlcyBpZiBuZWVkZWRcblxuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBkYXRhIHNldCB3aXRoIG5vZGVzIGZvciB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gbm9kZXMgICAgICAgICBUaGUgZGF0YSBjb250YWluaW5nIHRoZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdIC0gU3VwcHJlc3MgZGF0YSBjaGFuZ2VkIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEobm9kZXMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZE5vZGVzRGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzO1xuXG4gICAgICBpZiAoaXNEYXRhVmlld0xpa2UoXCJpZFwiLCBub2RlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKG5vZGVzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmFkZChub2Rlcyk7XG4gICAgICB9IGVsc2UgaWYgKCFub2Rlcykge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZE5vZGVzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkTm9kZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmVtb3ZlIGRyYXduIG5vZGVzXG5cblxuICAgICAgdGhpcy5ib2R5Lm5vZGVzID0ge307XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5ub2Rlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBtZS5ib2R5LmRhdGEubm9kZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7IC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXRJZHMoKTtcbiAgICAgICAgdGhpcy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGlkO1xuICAgICAgdmFyIG5ld05vZGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldChpZCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGUocHJvcGVydGllcyk7XG4gICAgICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tpZF0gPSBub2RlOyAvLyBub3RlOiB0aGlzIG1heSByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobmV3Tm9kZXMpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3Rpbmcgbm9kZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHMgaWQncyBvZiBjaGFuZ2VkIG5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhbmdlZERhdGEgYXJyYXkgd2l0aCBjaGFuZ2VkIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5fHVuZGVmaW5lZH0gb2xkRGF0YSBvcHRpb25hbDsgYXJyYXkgd2l0aCBwcmV2aW91cyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzLCBjaGFuZ2VkRGF0YSwgb2xkRGF0YSkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgIHZhciBkYXRhID0gY2hhbmdlZERhdGFbaV07XG5cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBub2RlXG4gICAgICAgICAgaWYgKG5vZGUuc2V0T3B0aW9ucyhkYXRhKSkge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7IC8vIGNyZWF0ZSBub2RlXG5cbiAgICAgICAgICBub2RlID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgbm9kZXNbaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGFDaGFuZ2VkICYmIG9sZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGNoYW5nZXMgd2hpY2ggc2hvdWxkIHRyaWdnZXIgYSBsYXlvdXQgcmVjYWxjdWxhdGlvblxuICAgICAgICAvLyBGb3Igbm93LCB0aGlzIGlzIGp1c3QgJ2xldmVsJyBmb3IgaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICAvLyBBc3N1bXB0aW9uOiBvbGQgYW5kIG5ldyBkYXRhIGFycmFuZ2VkIGluIHNhbWUgb3JkZXI7IGF0IHRpbWUgb2Ygd3JpdGluZywgdGhpcyBob2xkcy5cbiAgICAgICAgZGF0YUNoYW5nZWQgPSBzb21lKGNoYW5nZWREYXRhKS5jYWxsKGNoYW5nZWREYXRhLCBmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkRGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlICYmIG9sZFZhbHVlLmxldmVsICE9PSBuZXdWYWx1ZS5sZXZlbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV4aXN0aW5nIG5vZGVzLiBJZiBub2RlcyBkbyBub3QgZXhpc3QsIHRoZSBtZXRob2Qgd2lsbCBqdXN0IGlnbm9yZSBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgZGVsZXRlIG5vZGVzW2lkXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2NsYXNzfSBbY29uc3RydWN0b3JDbGFzcz1Ob2RlLmRlZmF1bHRdXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvckNsYXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOb2RlO1xuICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvckNsYXNzKHByb3BlcnRpZXMsIHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsZWFyUG9zaXRpb25zPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjbGVhclBvc2l0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXQobm9kZUlkKTtcblxuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNsZWFyUG9zaXRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICBub2RlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgICB5OiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgZml4ZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGUuaWQ+IHwgc3RyaW5nfSBbaWRzXSAgLS0+IG9wdGlvbmFsLCBjYW4gYmUgYXJyYXkgb2Ygbm9kZUlkcywgY2FuIGJlIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoaWRzKSB7XG4gICAgICB2YXIgZGF0YUFycmF5ID0ge307XG5cbiAgICAgIGlmIChpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNBcnJheSQyKGlkcykgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzW2ldXTtcbiAgICAgICAgICAgICAgZGF0YUFycmF5W2lkc1tpXV0gPSB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChub2RlLngpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobm9kZS55KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkc107XG4gICAgICAgICAgICBkYXRhQXJyYXlbaWRzXSA9IHtcbiAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChfbm9kZS54KSxcbiAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChfbm9kZS55KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlMiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbX2kyXV07XG4gICAgICAgICAgZGF0YUFycmF5W3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaTJdXSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGgucm91bmQoX25vZGUyLngpLFxuICAgICAgICAgICAgeTogTWF0aC5yb3VuZChfbm9kZTIueSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhQXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgeCB5IHBvc2l0aW9uIG9mIGEgc3BlY2lmaWMgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIHRvIHJldHJpZXZlLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgbm8gaWQgaXMgaW5jbHVkZWQuXG4gICAgICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IElmIGFuIGludmFsaWQgaWQgaXMgcHJvdmlkZWQuXG4gICAgICogQHJldHVybnMge3sgeDogbnVtYmVyLCB5OiBudW1iZXIgfX0gUmV0dXJucyBYLCBZIGNhbnZhcyBwb3NpdGlvbiBvZiB0aGUgbm9kZSB3aXRoIGdpdmVuIGlkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24oaWQpIHtcbiAgICAgIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGlkIHdhcyBzcGVjaWZpZWQgZm9yIGdldFBvc2l0aW9uIG1ldGhvZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZF0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0UG9zaXRpb24gZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIi5jb25jYXQoaWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmJvZHkubm9kZXNbaWRdLngpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW2lkXS55KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBYWSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGludG8gdGhlIGRhdGFzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9yZVBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9yZVBvc2l0aW9ucygpIHtcbiAgICAgIC8vIHRvZG86IGFkZCBzdXBwb3J0IGZvciBjbHVzdGVycyBhbmQgaGllcmFyY2hpY2FsLlxuICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KGRhdGFzZXQuZ2V0KCkpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkc05vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgaWQgPSBkc05vZGUuaWQ7XG4gICAgICAgICAgdmFyIGJvZHlOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkXTtcbiAgICAgICAgICB2YXIgeCA9IE1hdGgucm91bmQoYm9keU5vZGUueCk7XG4gICAgICAgICAgdmFyIHkgPSBNYXRoLnJvdW5kKGJvZHlOb2RlLnkpO1xuXG4gICAgICAgICAgaWYgKGRzTm9kZS54ICE9PSB4IHx8IGRzTm9kZS55ICE9PSB5KSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFzZXQudXBkYXRlKGRhdGFBcnJheSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge2p8Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIElkcyBvZiBub2RlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0geyd0byd8J2Zyb20nfHVuZGVmaW5lZH0gZGlyZWN0aW9uIHZhbHVlcyAnZnJvbScgYW5kICd0bycgc2VsZWN0IHJlc3BlY3RpdmVseSBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzIG9ubHkuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnkgb3RoZXIgdmFsdWUgcmV0dXJucyBib3RoIHBhcmVudCBhbmQgY2hpbGQgbm9kZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkTm9kZXMobm9kZUlkLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICB2YXIgbm9kZU9iaiA9IHt9OyAvLyB1c2VkIHRvIHF1aWNrbHkgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0c1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwidG9cIiAmJiBlZGdlLnRvSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS5mcm9tSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS5mcm9tSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAhPT0gXCJmcm9tXCIgJiYgZWRnZS5mcm9tSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLnRvSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFZGdlcyhub2RlSWQpIHtcbiAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2VMaXN0LnB1c2gobm9kZS5lZGdlc1tpXS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldENvbm5lY3RlZEVkZ2VzIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIsIG5vZGVJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZSBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVOb2RlKG5vZGVJZCwgeCwgeSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnggPSBOdW1iZXIoeCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnkgPSBOdW1iZXIoeSk7XG5cbiAgICAgICAgc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgaWQgc3VwcGxpZWQgdG8gbW92ZU5vZGUgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIiwgbm9kZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZXNIYW5kbGVyO1xufSgpO1xuXG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgaXNEYXRhRGVzY3JpcHRvciQxID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCAmJiAoaGFzT3duJDEoZGVzY3JpcHRvciwgJ3ZhbHVlJykgfHwgaGFzT3duJDEoZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykpO1xufTtcblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkajtcbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkZDtcbnZhciBpc0RhdGFEZXNjcmlwdG9yID0gaXNEYXRhRGVzY3JpcHRvciQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mOyAvLyBgUmVmbGVjdC5nZXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmdldFxuXG5mdW5jdGlvbiBnZXQkNSh0YXJnZXQsIHByb3BlcnR5S2V5XG4vKiAsIHJlY2VpdmVyICovXG4pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjcmlwdG9yLCBwcm90b3R5cGU7XG4gIGlmIChhbk9iamVjdCQxKHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mKHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICBpZiAoZGVzY3JpcHRvcikgcmV0dXJuIGlzRGF0YURlc2NyaXB0b3IoZGVzY3JpcHRvcikgPyBkZXNjcmlwdG9yLnZhbHVlIDogZGVzY3JpcHRvci5nZXQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNhbGwoZGVzY3JpcHRvci5nZXQsIHJlY2VpdmVyKTtcbiAgaWYgKGlzT2JqZWN0JDIocHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQkNShwcm90b3R5cGUsIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiQkMih7XG4gIHRhcmdldDogJ1JlZmxlY3QnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIGdldDogZ2V0JDVcbn0pO1xuXG52YXIgcGF0aCQzID0gcGF0aCR5O1xudmFyIGdldCQ0ID0gcGF0aCQzLlJlZmxlY3QuZ2V0O1xuXG52YXIgcGFyZW50JDcgPSBnZXQkNDtcbnZhciBnZXQkMyA9IHBhcmVudCQ3O1xuXG52YXIgcGFyZW50JDYgPSBnZXQkMztcbnZhciBnZXQkMiA9IHBhcmVudCQ2O1xuXG52YXIgcGFyZW50JDUgPSBnZXQkMjtcbnZhciBnZXQkMSA9IHBhcmVudCQ1O1xuXG52YXIgZ2V0ID0gZ2V0JDE7XG5cbnZhciBwYXJlbnQkNCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gcGFyZW50JDQ7XG5cbnZhciBwYXJlbnQkMyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gcGFyZW50JDM7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIGdldCkge1xuICAgIF9nZXQgPSBnZXQ7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcblxuICAgICAgdmFyIGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgJCQxID0gX2V4cG9ydDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtaHlwb3QgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxudmFyICRoeXBvdCA9IE1hdGguaHlwb3Q7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgc3FydCA9IE1hdGguc3FydDsgLy8gQ2hyb21lIDc3IGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTU0NlxuXG52YXIgQlVHR1kgPSAhISRoeXBvdCAmJiAkaHlwb3QoSW5maW5pdHksIE5hTikgIT09IEluZmluaXR5OyAvLyBgTWF0aC5oeXBvdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGguaHlwb3RcblxuJCQxKHtcbiAgdGFyZ2V0OiAnTWF0aCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogQlVHR1lcbn0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuXG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuXG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG5cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBzcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCQyID0gcGF0aCR5O1xudmFyIGh5cG90JDIgPSBwYXRoJDIuTWF0aC5oeXBvdDtcblxudmFyIHBhcmVudCQyID0gaHlwb3QkMjtcbnZhciBoeXBvdCQxID0gcGFyZW50JDI7XG5cbnZhciBoeXBvdCA9IGh5cG90JDE7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRhKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBDb21tb24gbWV0aG9kcyBmb3IgZW5kcG9pbnRzXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKi9cblxudmFyIEVuZFBvaW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW5kUG9pbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZFBvaW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbmRQb2ludCwgbnVsbCwgW3tcbiAgICBrZXk6IFwidHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm1hdGlvbiBvbiBwb2ludHMgZm9yIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvbGxvd2luZyBpcyBkb25lOlxyXG4gICAgICogLSByb3RhdGUgYnkgdGhlIHNwZWNpZmllZCBhbmdsZVxyXG4gICAgICogLSBtdWx0aXBseSB0aGUgKG5vcm1hbGl6ZWQpIGNvb3JkaW5hdGVzIGJ5IHRoZSBwYXNzZWQgbGVuZ3RoXHJcbiAgICAgKiAtIG9mZnNldCBieSB0aGUgdGFyZ2V0IGNvb3JkaW5hdGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvaW50cyAtIFRoZSBwb2ludChzKSB0byBiZSB0cmFuc2Zvcm1lZC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgcmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSkge1xuICAgICAgaWYgKCFpc0FycmF5JDIocG9pbnRzKSkge1xuICAgICAgICBwb2ludHMgPSBbcG9pbnRzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBhcnJvd0RhdGEucG9pbnQueDtcbiAgICAgIHZhciB5ID0gYXJyb3dEYXRhLnBvaW50Lnk7XG4gICAgICB2YXIgYW5nbGUgPSBhcnJvd0RhdGEuYW5nbGU7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyb3dEYXRhLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciB4dCA9IHAueCAqIE1hdGguY29zKGFuZ2xlKSAtIHAueSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIHl0ID0gcC54ICogTWF0aC5zaW4oYW5nbGUpICsgcC55ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBwLnggPSB4ICsgbGVuZ3RoICogeHQ7XG4gICAgICAgIHAueSA9IHkgKyBsZW5ndGggKiB5dDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgY2xvc2VkIHBhdGggdXNpbmcgdGhlIGdpdmVuIHJlYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBwYXRoIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIC0gVGhlIHBvaW50cyBvZiB0aGUgcGF0aC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BhdGgoY3R4LCBwb2ludHMpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgfVxuXG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVuZFBvaW50O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGFycm93IGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgSW1hZ2UkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VuZFBvaW50KSB7XG4gIF9pbmhlcml0cyhJbWFnZSwgX0VuZFBvaW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGEoSW1hZ2UpO1xuXG4gIGZ1bmN0aW9uIEltYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2UsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgRmFsc2UgYXMgdGhlcmUgaXMgbm8gd2F5IHRvIGZpbGwgYW4gaW1hZ2UuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICBpZiAoYXJyb3dEYXRhLmltYWdlKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoYXJyb3dEYXRhLnBvaW50LngsIGFycm93RGF0YS5wb2ludC55KTtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gMiArIGFycm93RGF0YS5hbmdsZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IGFycm93RGF0YS5pbWFnZVdpZHRoICE9IG51bGwgPyBhcnJvd0RhdGEuaW1hZ2VXaWR0aCA6IGFycm93RGF0YS5pbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGFycm93RGF0YS5pbWFnZUhlaWdodCAhPSBudWxsID8gYXJyb3dEYXRhLmltYWdlSGVpZ2h0IDogYXJyb3dEYXRhLmltYWdlLmhlaWdodDtcbiAgICAgICAgYXJyb3dEYXRhLmltYWdlLmRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCAxLCAvLyBzY2FsZVxuICAgICAgICAtd2lkdGggLyAyLCAvLyB4XG4gICAgICAgIDAsIC8vIHlcbiAgICAgICAgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2U7XG59KEVuZFBvaW50KTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBhcnJvdyBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEFycm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW5kUG9pbnQyKSB7XG4gIF9pbmhlcml0cyhBcnJvdywgX0VuZFBvaW50Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIkYShBcnJvdyk7XG5cbiAgZnVuY3Rpb24gQXJyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycm93KTtcblxuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXJyb3csIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjksXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBcnJvdztcbn0oRW5kUG9pbnQpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGNyb3cgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBDcm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3JvdygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Jvdyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3JvdywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvdztcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjdXJ2ZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEN1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnZlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdXJ2ZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTsgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cblxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMClcIjsgLy8gRGVmaW5lIGN1cnZlIGVuZHBvaW50IGFzIHNlbWljaXJjbGUuXG5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSAtIHBpIC8gMjtcbiAgICAgIHZhciBlbmRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIHBpIC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgYXJyb3dEYXRhLmxlbmd0aCAqIDAuNCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJ2ZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBpbnZlcnRlZCBjdXJ2ZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEludmVydGVkQ3VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnZlcnRlZEN1cnZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZlcnRlZEN1cnZlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbnZlcnRlZEN1cnZlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC4zLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpOyAvLyBVcGRhdGUgZW5kcG9pbnQgc3R5bGUgZm9yIGRyYXdpbmcgdHJhbnNwYXJlbnQgYXJjLlxuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwKVwiOyAvLyBEZWZpbmUgaW52ZXJ0ZWQgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cblxuICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgdmFyIGVuZEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgMyAqIHBpIC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgYXJyb3dEYXRhLmxlbmd0aCAqIDAuNCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnZlcnRlZEN1cnZlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIHRyaW5hZ2xlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgVHJpYW5nbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmlhbmdsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJpYW5nbGUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAuMDIsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyaWFuZ2xlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGludmVydGVkIHRyaW5hZ2xlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgSW52ZXJ0ZWRUcmlhbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludmVydGVkVHJpYW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludmVydGVkVHJpYW5nbGUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEludmVydGVkVHJpYW5nbGUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDBcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnZlcnRlZFRyaWFuZ2xlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGNpcmNsZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIENpcmNsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaXJjbGUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IC0wLjQsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnQsIGFycm93RGF0YSk7XG4gICAgICBkcmF3Q2lyY2xlKGN0eCwgcG9pbnQueCwgcG9pbnQueSwgYXJyb3dEYXRhLmxlbmd0aCAqIDAuNCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY2xlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGJhciBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXIsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvKlxyXG4gICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgIHt4OjAsIHk6MC41fSxcclxuICAgICAgICB7eDowLCB5Oi0wLjV9XHJcbiAgICAgIF07XHJcbiAgICAgICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XHJcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcclxuICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAqL1xuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuNVxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC41XG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjE1LFxuICAgICAgICB5OiAtMC41XG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjE1LFxuICAgICAgICB5OiAwLjVcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXI7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYm94IGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm94KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJveCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC42LFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjYsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJveDtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBkaWFtb25kIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgRGlhbW9uZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpYW1vbmQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpYW1vbmQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERpYW1vbmQsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC41LFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjUsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpYW1vbmQ7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdmVlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgVmVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmVlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZlZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjUsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZlZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBlbmRwb2ludHMuXHJcbiAqL1xuXG5cbnZhciBFbmRQb2ludHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbmRQb2ludHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZFBvaW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRW5kUG9pbnRzLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGFuIGVuZHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3csIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciB0eXBlO1xuXG4gICAgICBpZiAoYXJyb3dEYXRhLnR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGFycm93RGF0YS50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICByZXR1cm4gSW1hZ2UkMS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgcmV0dXJuIENpcmNsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiYm94XCI6XG4gICAgICAgICAgcmV0dXJuIEJveC5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiY3Jvd1wiOlxuICAgICAgICAgIHJldHVybiBDcm93LmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJjdXJ2ZVwiOlxuICAgICAgICAgIHJldHVybiBDdXJ2ZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgICAgIHJldHVybiBEaWFtb25kLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJpbnZfY3VydmVcIjpcbiAgICAgICAgICByZXR1cm4gSW52ZXJ0ZWRDdXJ2ZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwidHJpYW5nbGVcIjpcbiAgICAgICAgICByZXR1cm4gVHJpYW5nbGUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImludl90cmlhbmdsZVwiOlxuICAgICAgICAgIHJldHVybiBJbnZlcnRlZFRyaWFuZ2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgICByZXR1cm4gQmFyLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJ2ZWVcIjpcbiAgICAgICAgICByZXR1cm4gVmVlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJhcnJvd1wiOiAvLyBmYWxsLXRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBBcnJvdy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW5kUG9pbnRzO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkNChvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gZmlsdGVyKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIF9jb250ZXh0MiwgX2NvbnRleHQzOyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBmb3JFYWNoJDIoX2NvbnRleHQyID0gb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCAhMCkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IGZvckVhY2gkMihfY29udGV4dDMgPSBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQ2KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBlZGdlcy5cclxuICovXG5cbnZhciBFZGdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIF9ib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIF9sYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRWRnZUJhc2Uob3B0aW9ucywgX2JvZHksIF9sYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQmFzZSk7XG5cbiAgICB0aGlzLl9ib2R5ID0gX2JvZHk7XG4gICAgdGhpcy5fbGFiZWxNb2R1bGUgPSBfbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5jb2xvciA9IHt9O1xuICAgIHRoaXMuY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5ob3ZlcldpZHRoID0gMS41O1xuICAgIHRoaXMuc2VsZWN0aW9uV2lkdGggPSAyO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmZyb21Qb2ludCA9IHRoaXMuZnJvbTtcbiAgICB0aGlzLnRvUG9pbnQgPSB0aGlzLnRvO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVkZ2VCYXNlLCBbe1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgIHRoaXMudG8gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldCBuZXcgZWRnZSBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG5ldyBlZGdlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIF9zZWxlY3RlZCwgX2hvdmVyKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdGhpcy5nZXRWaWFOb2RlKCk7XG4gICAgICAvLyBzZXQgc3R5bGVcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0Q29sb3IoY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlcy53aWR0aDtcblxuICAgICAgaWYgKHZhbHVlcy5kYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2RyYXdEYXNoZWRMaW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgbGluZSB3aXRoIGdpdmVuIHN0eWxlIGJldHdlZW4gdHdvIG5vZGVzIHRocm91Z2ggc3VwcGxpZWQgbm9kZShzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlIC0gQWRkaXRpb25hbCBjb250cm9sIHBvaW50KHMpIGZvciB0aGUgZWRnZS5cclxuICAgICAqIEBwYXJhbSBmcm9tUG9pbnQgLSBUT0RPOiBTZWVtcyBpZ25vcmVkLCByZW1vdmU/XHJcbiAgICAgKiBAcGFyYW0gdG9Qb2ludCAtIFRPRE86IFNlZW1zIGlnbm9yZWQsIHJlbW92ZT9cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgLy8gZHJhdyBsaW5lXG4gICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzBdLFxuICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsyXTtcblxuICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB2YWx1ZXMsIHgsIHksIHJhZGl1cyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRhc2hlZCBsaW5lIHdpdGggZ2l2ZW4gc3R5bGUgYmV0d2VlbiB0d28gbm9kZXMgdGhyb3VnaCBzdXBwbGllZCBub2RlKHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUgLSBBZGRpdGlvbmFsIGNvbnRyb2wgcG9pbnQocykgZm9yIHRoZSBlZGdlLlxyXG4gICAgICogQHBhcmFtIF9mcm9tUG9pbnQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcGFyYW0gX3RvUG9pbnQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RGFzaGVkTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0Rhc2hlZExpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIF9mcm9tUG9pbnQsIF90b1BvaW50KSB7XG4gICAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgIHZhciBwYXR0ZXJuID0gaXNBcnJheSQyKHZhbHVlcy5kYXNoZXMpID8gdmFsdWVzLmRhc2hlcyA6IFs1LCA1XTsgLy8gb25seSBmaXJlZm94IGFuZCBjaHJvbWUgc3VwcG9ydCB0aGlzIG1ldGhvZCwgZWxzZSB3ZSB1c2UgdGhlIGxlZ2FjeSBvbmUuXG5cbiAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguc2F2ZSgpOyAvLyBzZXQgZGFzaCBzZXR0aW5ncyBmb3IgY2hyb21lIG9yIGZpcmVmb3hcblxuICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7IC8vIGRyYXcgdGhlIGxpbmVcblxuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEzID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTMsIDMpLFxuICAgICAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGE0WzBdLFxuICAgICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGE0WzFdLFxuICAgICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMl07XG5cbiAgICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB2YWx1ZXMsIHgsIHksIHJhZGl1cyk7XG4gICAgICAgIH0gLy8gcmVzdG9yZSB0aGUgZGFzaCBzZXR0aW5ncy5cblxuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5zdXBwb3J0aW5nIHNtb290aCBsaW5lc1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICBkcmF3RGFzaGVkTGluZShjdHgsIHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnksIHBhdHRlcm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTUgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhNiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhNSwgMyksXG4gICAgICAgICAgICAgIF94ID0gX3RoaXMkX2dldENpcmNsZURhdGE2WzBdLFxuICAgICAgICAgICAgICBfeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNlsxXSxcbiAgICAgICAgICAgICAgX3JhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNlsyXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgX3gsIF95LCBfcmFkaXVzKTtcbiAgICAgICAgfSAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cblxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIGN0eC5zdHJva2UoKTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb24obm9kZSwgY3R4LCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihub2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShub2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRCb3JkZXJQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9ucyhjdHgpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCksXG4gICAgICAgICAgdG86IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLnRvLCBjdHgpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhJCA9IHNsaWNlKF9jb250ZXh0ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpKS5jYWxsKF9jb250ZXh0LCAwLCAyKSxcbiAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhJDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQsIDIpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhJDJbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGEkMlsxXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuMjUsXG4gICAgICAgICAgICBoaWdoOiAwLjYsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdG86IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICAgIGhpZ2g6IDAuOCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgY2VudGVyIHBvaW50IGFuZCByYWRpdXMgb2YgYW4gZWRnZSBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbm9kZSBhdCBib3RoIGVuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBgW3gsIHksIHJhZGl1c11gXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDaXJjbGVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaXJjbGVEYXRhKGN0eCkge1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemU7XG5cbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLnNoYXBlLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmZyb20uc2hhcGUucmVzaXplKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZ2V0IGNpcmNsZSBjb29yZGluYXRlc1xuXG5cbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGdldFNlbGZSZWZDb29yZGluYXRlcyhjdHgsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlLCByYWRpdXMsIHRoaXMuZnJvbSk7XG4gICAgICByZXR1cm4gW2Nvb3JkaW5hdGVzLngsIGNvb3JkaW5hdGVzLnksIHJhZGl1c107XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgcG9pbnQgb24gYSBjaXJjbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggLSBDZW50ZXIgb2YgdGhlIGNpcmNsZSBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkgLSBDZW50ZXIgb2YgdGhlIGNpcmNsZSBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpLlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHJlcXVlc3RlZCBwb2ludCBvbiB0aGUgY2lyY2xlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcG9pbnRPbkNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwb3NpdGlvbiAqIDIgKiBNYXRoLlBJO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogeSAtIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGJpbmFyeSBzZWFyY2ggdG8gbG9vayBmb3IgdGhlIHBvaW50IHdoZXJlIHRoZSBjaXJjbGUgY3Jvc3NlcyB0aGUgYm9yZGVyIG9mIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIG5lYXJOb2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShuZWFyTm9kZSwgY3R4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgeCA9IG9wdGlvbnMueDtcbiAgICAgIHZhciB5ID0gb3B0aW9ucy55O1xuICAgICAgdmFyIGxvdyA9IG9wdGlvbnMubG93O1xuICAgICAgdmFyIGhpZ2ggPSBvcHRpb25zLmhpZ2g7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemU7XG4gICAgICB2YXIgdGhyZXNob2xkID0gMC4wNTtcbiAgICAgIHZhciBwb3M7XG4gICAgICB2YXIgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuICAgICAgdmFyIGVuZFBvaW50T2Zmc2V0ID0gMDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICAgIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgICAgcG9zID0gdGhpcy5fcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIG1pZGRsZSk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIobmVhck5vZGUueSAtIHBvcy55LCBuZWFyTm9kZS54IC0gcG9zLngpO1xuICAgICAgICB2YXIgZGlzdGFuY2VUb0JvcmRlciA9IG5lYXJOb2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkgKyBlbmRQb2ludE9mZnNldDtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Qb2ludCA9IE1hdGguc3FydChNYXRoLnBvdyhwb3MueCAtIG5lYXJOb2RlLngsIDIpICsgTWF0aC5wb3cocG9zLnkgLSBuZWFyTm9kZS55LCAyKSk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gZGlzdGFuY2VUb0JvcmRlciAtIGRpc3RhbmNlVG9Qb2ludDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICsraXRlcmF0aW9uO1xuICAgICAgfSB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucyk7XG5cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb3MpLCB7fSwge1xuICAgICAgICB0OiBtaWRkbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGluZSB3aWR0aCBvZiB0aGUgZWRnZS4gRGVwZW5kcyBvbiB3aWR0aCBhbmQgd2hldGhlciBvbmUgb2YgdGhlIGNvbm5lY3RlZCBub2RlcyBpcyBzZWxlY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWQgLSBEZXRlcm1pbmVzIHdoZXRlciB0aGUgbGluZSBpcyBzZWxlY3RlZC5cclxuICAgICAqIEBwYXJhbSBob3ZlciAtIERldGVybWluZXMgd2hldGVyIHRoZSBsaW5lIGlzIGJlaW5nIGhvdmVyZWQsIG9ubHkgYXBwbGllcyBpZiBzZWxlY3RlZCBpcyBmYWxzZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB3aWR0aCBvZiB0aGUgbGluZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGluZVdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5zZWxlY3Rpb25XaWR0aCwgMC4zIC8gdGhpcy5fYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuaG92ZXJXaWR0aCwgMC4zIC8gdGhpcy5fYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm9wdGlvbnMud2lkdGgsIDAuMyAvIHRoaXMuX2JvZHkudmlldy5zY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgY29sb3Igb3IgZ3JhZGllbnQgZm9yIGdpdmVuIGVkZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0gX3NlbGVjdGVkIC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICogQHBhcmFtIF9ob3ZlciAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqIEByZXR1cm5zIENvbG9yIHN0cmluZyBpZiBzaW5nbGUgY29sb3IgaXMgaW5oZXJpdGVkIG9yIGdyYWRpZW50IGlmIHR3by5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3IoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09IFwiYm90aFwiICYmIHRoaXMuZnJvbS5pZCAhPT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHZhciBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5mcm9tLngsIHRoaXMuZnJvbS55LCB0aGlzLnRvLngsIHRoaXMudG8ueSk7XG4gICAgICAgICAgdmFyIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgdmFyIHRvQ29sb3IgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcblxuICAgICAgICAgIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmcm9tQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgICB0b0NvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIGZyb21Db2xvcik7XG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgxLCB0b0NvbG9yKTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gdGhpcyByZXR1cm5zIC0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgICAgICAgICByZXR1cm4gZ3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy5pbmhlcml0c0NvbG9yID09PSBcInRvXCIpIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBcImZyb21cIlxuICAgICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgZnJvbSBhIG5vZGUgdG8gaXRzZWxmLCBhIGNpcmNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSB4IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpIHtcbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTsgLy9mdWxsIGNpcmNsZVxuXG4gICAgICB2YXIgYW5nbGVGcm9tID0gMDtcbiAgICAgIHZhciBhbmdsZVRvID0gTWF0aC5QSSAqIDI7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UucmVuZGVyQmVoaW5kVGhlTm9kZSkge1xuICAgICAgICAvL3JlbmRlciBvbmx5IHBhcnRzIHdoaWNoIGFyZSBub3Qgb3ZlcmxhcGluZyB3aXRoIHBhcmVudCBub2RlXG4gICAgICAgIC8vbmVlZCB0byBmaW5kIHgseSBvZiBmcm9tIHBvaW50IGFuZCB4LHkgdG8gcG9pbnRcbiAgICAgICAgLy9jYWxjdWxhdGluZyByYWRpYW5zXG4gICAgICAgIHZhciBsb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG5cbiAgICAgICAgdmFyIHBvaW50VEZyb20gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgbG93OiBsb3csXG4gICAgICAgICAgaGlnaDogaGlnaCxcbiAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwb2ludFRUbyA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICB9KTtcblxuICAgICAgICBhbmdsZUZyb20gPSBNYXRoLmF0YW4yKHBvaW50VEZyb20ueSAtIHksIHBvaW50VEZyb20ueCAtIHgpO1xuICAgICAgICBhbmdsZVRvID0gTWF0aC5hdGFuMihwb2ludFRUby55IC0geSwgcG9pbnRUVG8ueCAtIHgpO1xuICAgICAgfSAvLyBkcmF3IGEgY2lyY2xlXG5cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlRnJvbSwgYW5nbGVUbywgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTcgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKHVuZGVmaW5lZCksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTggPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTcsIDMpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhOFswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YThbMV0sXG4gICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YThbMl07XG5cbiAgICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgICB2YXIgZHkgPSB5IC0geTM7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC0gcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMsIHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEsIHkxKSB0byAoeDIsIHkyKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9MaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBweCA9IHgyIC0geDE7XG4gICAgICB2YXIgcHkgPSB5MiAtIHkxO1xuICAgICAgdmFyIHNvbWV0aGluZyA9IHB4ICogcHggKyBweSAqIHB5O1xuICAgICAgdmFyIHUgPSAoKHgzIC0geDEpICogcHggKyAoeTMgLSB5MSkgKiBweSkgLyBzb21ldGhpbmc7XG5cbiAgICAgIGlmICh1ID4gMSkge1xuICAgICAgICB1ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodSA8IDApIHtcbiAgICAgICAgdSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0geDEgKyB1ICogcHg7XG4gICAgICB2YXIgeSA9IHkxICsgdSAqIHB5O1xuICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgdmFyIGR5ID0geSAtIHkzOyAvLyMgTm90ZTogSWYgdGhlIGFjdHVhbCBkaXN0YW5jZSBkb2VzIG5vdCBtYXR0ZXIsXG4gICAgICAvLyMgaWYgeW91IG9ubHkgd2FudCB0byBjb21wYXJlIHdoYXQgdGhpcyBmdW5jdGlvblxuICAgICAgLy8jIHJldHVybnMgdG8gb3RoZXIgcmVzdWx0cyBvZiB0aGlzIGZ1bmN0aW9uLCB5b3VcbiAgICAgIC8vIyBjYW4ganVzdCByZXR1cm4gdGhlIHNxdWFyZWQgZGlzdGFuY2UgaW5zdGVhZFxuICAgICAgLy8jIChpLmUuIHJlbW92ZSB0aGUgc3FydCkgdG8gZ2FpbiBhIGxpdHRsZSBwZXJmb3JtYW5jZVxuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBcnJvd0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJyb3dEYXRhKGN0eCwgcG9zaXRpb24sIHZpYU5vZGUsIF9zZWxlY3RlZCwgX2hvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIC8vIHNldCBsZXRzXG4gICAgICB2YXIgYW5nbGU7XG4gICAgICB2YXIgYXJyb3dQb2ludDtcbiAgICAgIHZhciBub2RlMTtcbiAgICAgIHZhciBub2RlMjtcbiAgICAgIHZhciByZXZlcnNlZDtcbiAgICAgIHZhciBzY2FsZUZhY3RvcjtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHZhbHVlcy53aWR0aDtcblxuICAgICAgaWYgKHBvc2l0aW9uID09PSBcImZyb21cIikge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy5mcm9tQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLmZyb21BcnJvd1NjYWxlKTtcbiAgICAgICAgdHlwZSA9IHZhbHVlcy5mcm9tQXJyb3dUeXBlO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJ0b1wiKSB7XG4gICAgICAgIG5vZGUxID0gdGhpcy50bztcbiAgICAgICAgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICAgIHJldmVyc2VkID0gdmFsdWVzLnRvQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLnRvQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMudG9BcnJvd1R5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy5taWRkbGVBcnJvd1NjYWxlIDwgMDtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSBNYXRoLmFicyh2YWx1ZXMubWlkZGxlQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMubWlkZGxlQXJyb3dUeXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gMTUgKiBzY2FsZUZhY3RvciArIDMgKiBsaW5lV2lkdGg7IC8vIDMqIGxpbmVXaWR0aCBpcyB0aGUgd2lkdGggb2YgdGhlIGVkZ2UuXG4gICAgICAvLyBpZiBub3QgY29ubmVjdGVkIHRvIGl0c2VsZlxuXG4gICAgICBpZiAobm9kZTEgIT0gbm9kZTIpIHtcbiAgICAgICAgdmFyIGFwcHJveGltYXRlRWRnZUxlbmd0aCA9IGh5cG90KG5vZGUxLnggLSBub2RlMi54LCBub2RlMS55IC0gbm9kZTIueSk7XG5cbiAgICAgICAgdmFyIHJlbGF0aXZlTGVuZ3RoID0gbGVuZ3RoIC8gYXBwcm94aW1hdGVFZGdlTGVuZ3RoO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gXCJtaWRkbGVcIikge1xuICAgICAgICAgIC8vIGRyYXcgYXJyb3cgaGVhZFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBwb2ludFQgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24obm9kZTEsIGN0eCwge1xuICAgICAgICAgICAgICB2aWE6IHZpYU5vZGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZ3VpZGVQb3MgPSB0aGlzLmdldFBvaW50KHBvaW50VC50ICsgcmVsYXRpdmVMZW5ndGggKiAocG9zaXRpb24gPT09IFwiZnJvbVwiID8gMSA6IC0xKSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIocG9pbnRULnkgLSBndWlkZVBvcy55LCBwb2ludFQueCAtIGd1aWRlUG9zLngpO1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHBvaW50VDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOZWdhdGl2ZSBoYWxmIGxlbmd0aCByZXZlcnNlcyBhcnJvdyBkaXJlY3Rpb24uXG4gICAgICAgICAgdmFyIGhhbGZMZW5ndGggPSAocmV2ZXJzZWQgPyAtcmVsYXRpdmVMZW5ndGggOiByZWxhdGl2ZUxlbmd0aCkgLyAyO1xuICAgICAgICAgIHZhciBndWlkZVBvczEgPSB0aGlzLmdldFBvaW50KDAuNSArIGhhbGZMZW5ndGgsIHZpYU5vZGUpO1xuICAgICAgICAgIHZhciBndWlkZVBvczIgPSB0aGlzLmdldFBvaW50KDAuNSAtIGhhbGZMZW5ndGgsIHZpYU5vZGUpO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihndWlkZVBvczEueSAtIGd1aWRlUG9zMi55LCBndWlkZVBvczEueCAtIGd1aWRlUG9zMi54KTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcmF3IGNpcmNsZVxuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE5ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGExMCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhOSwgMyksXG4gICAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGExMFswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGExMFsyXTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IFwiZnJvbVwiKSB7XG4gICAgICAgICAgdmFyIGxvdyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlO1xuICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgKyBNYXRoLlBJO1xuXG4gICAgICAgICAgdmFyIF9wb2ludFQgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgbG93OiBsb3csXG4gICAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAtMVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYW5nbGUgPSBfcG9pbnRULnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gX3BvaW50VDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJ0b1wiKSB7XG4gICAgICAgICAgdmFyIF9sb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcblxuICAgICAgICAgIHZhciBfaGlnaCA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlICsgTWF0aC5QSTtcblxuICAgICAgICAgIHZhciBfcG9pbnRUMiA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IF9sb3csXG4gICAgICAgICAgICBoaWdoOiBfaGlnaCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYW5nbGUgPSBfcG9pbnRUMi50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSAtIDEuMSAqIE1hdGguUEk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IF9wb2ludFQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwb3MpO1xuICAgICAgICAgIGFuZ2xlID0gcG9zICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSArIDAuMSAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHhpID0gYXJyb3dQb2ludC54IC0gbGVuZ3RoICogMC45ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHlpID0gYXJyb3dQb2ludC55IC0gbGVuZ3RoICogMC45ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIGFycm93Q29yZSA9IHtcbiAgICAgICAgeDogeGksXG4gICAgICAgIHk6IHlpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGFycm93UG9pbnQsXG4gICAgICAgIGNvcmU6IGFycm93Q29yZSxcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QXJyb3dIZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIF9zZWxlY3RlZCwgX2hvdmVyLCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlcy53aWR0aDtcbiAgICAgIHZhciBjYW5GaWxsID0gRW5kUG9pbnRzLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICBpZiAoY2FuRmlsbCkge1xuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcblxuICAgICAgICBmaWxsKGN0eCkuY2FsbChjdHgpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNoYWRvdyBmb3JtYXR0aW5nIHZhbHVlcyBpbiB0aGUgY29udGV4dCBpZiBlbmFibGVkLCBkbyBub3RoaW5nIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBmb3IgdGhlIHNoYWRvdy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IHRydWUpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdmFsdWVzLnNoYWRvd0NvbG9yO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHZhbHVlcy5zaGFkb3dTaXplO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHZhbHVlcy5zaGFkb3dYO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHZhbHVlcy5zaGFkb3dZO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzaGFkb3cgZm9ybWF0dGluZyB2YWx1ZXMgaW4gdGhlIGNvbnRleHQgaWYgZW5hYmxlZCwgZG8gbm90aGluZyBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgZm9yIHRoZSBzaGFkb3cuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IHRydWUpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIHRoZSBiYWNrZ3JvdW5kIGFjY29yZGluZyB0byB0aGUgZm9ybWF0dGluZyB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgZm9yIHRoZSBiYWNrZ3JvdW5kLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5iYWNrZ3JvdW5kICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBzYXZlIG9yaWdpbmFsIGxpbmUgYXR0cnNcbiAgICAgICAgdmFyIG9yaWdDdHhBdHRyID0ge1xuICAgICAgICAgIHN0cm9rZVN0eWxlOiBjdHguc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgbGluZVdpZHRoOiBjdHgubGluZVdpZHRoLFxuICAgICAgICAgIGRhc2hlczogY3R4LmRhc2hlc1xuICAgICAgICB9O1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdmFsdWVzLmJhY2tncm91bmRTaXplO1xuICAgICAgICB0aGlzLnNldFN0cm9rZURhc2hlZChjdHgsIHZhbHVlcy5iYWNrZ3JvdW5kRGFzaGVzKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpOyAvLyByZXN0b3JlIG9yaWdpbmFsIGxpbmUgYXR0cnNcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnQ3R4QXR0ci5zdHJva2VTdHlsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9yaWdDdHhBdHRyLmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmRhc2hlcyA9IG9yaWdDdHhBdHRyLmRhc2hlcztcbiAgICAgICAgdGhpcy5zZXRTdHJva2VEYXNoZWQoY3R4LCB2YWx1ZXMuZGFzaGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxpbmUgZGFzaCBwYXR0ZXJuIGlmIHN1cHBvcnRlZC4gTG9ncyBhIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUgaWYgaXQgaXNuJ3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIGRhc2hlcyAtIFRoZSBwYXR0ZXJuIFtsaW5lLCBzcGFjZSwgbGluZeKApl0sIHRydWUgZm9yIGRlZmF1bHQgZGFzaGVkIGxpbmUgb3IgZmFsc2UgZm9yIG5vcm1hbCBsaW5lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdHJva2VEYXNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3Ryb2tlRGFzaGVkKGN0eCwgZGFzaGVzKSB7XG4gICAgICBpZiAoZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IGlzQXJyYXkkMihkYXNoZXMpID8gZGFzaGVzIDogWzUsIDVdO1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWRnZUJhc2U7XG59KCk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkNChvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gZmlsdGVyKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBfY29udGV4dCwgX2NvbnRleHQyOyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBmb3JFYWNoJDIoX2NvbnRleHQgPSBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogZm9yRWFjaCQyKF9jb250ZXh0MiA9IG93bktleXMoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQ2KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ5KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBUaGUgQmFzZSBDbGFzcyBmb3IgYWxsIEJlemllciBlZGdlcy5cclxuICogQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICovXG5cbnZhciBCZXppZXJFZGdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhCZXppZXJFZGdlQmFzZSwgX0VkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDkoQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VCYXNlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICpcclxuICAgKiBAcmVtYXJrc1xyXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBiaW5hcnkgc2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBwb2ludCB3aGVyZSB0aGUgYmV6aWVyIGN1cnZlIGNyb3NzZXMgdGhlIGJvcmRlciBvZiB0aGUgbm9kZS5cclxuICAgKiBAcGFyYW0gbmVhck5vZGUgLSBUaGUgbm9kZSAoZWl0aGVyIGZyb20gb3IgdG8gbm9kZSBvZiB0aGUgZWRnZSkuXHJcbiAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICogQHBhcmFtIHZpYU5vZGUgLSBBZGRpdGlvbmFsIG5vZGUocykgdGhlIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjI7XG4gICAgICB2YXIgZnJvbSA9IGZhbHNlO1xuICAgICAgdmFyIGhpZ2ggPSAxO1xuICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMudG87XG4gICAgICB2YXIgcG9zO1xuICAgICAgdmFyIG1pZGRsZTtcbiAgICAgIHZhciBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldCA/IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA6IDA7XG5cbiAgICAgIGlmIChuZWFyTm9kZS5pZCA9PT0gdGhpcy5mcm9tLmlkKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmZyb207XG4gICAgICAgIGZyb20gPSB0cnVlO1xuICAgICAgICBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldCA/IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tIDogMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB7XG4gICAgICAgIGVuZFBvaW50T2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuICAgICAgICBwb3MgPSB0aGlzLmdldFBvaW50KG1pZGRsZSwgdmlhTm9kZSk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Cb3JkZXIgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkgKyBlbmRQb2ludE9mZnNldDtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Qb2ludCA9IE1hdGguc3FydChNYXRoLnBvdyhwb3MueCAtIG5vZGUueCwgMikgKyBNYXRoLnBvdyhwb3MueSAtIG5vZGUueSwgMikpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgYnJlYWs7IC8vIGZvdW5kXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA8IDApIHtcbiAgICAgICAgICAvLyBkaXN0YW5jZSB0byBub2RlcyBpcyBsYXJnZXIgdGhhbiBkaXN0YW5jZSB0byBib3JkZXIgLS0+IHQgbmVlZHMgdG8gYmUgYmlnZ2VyIGlmIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIHRvIG5vZGUuXG4gICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmcm9tID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICsraXRlcmF0aW9uO1xuICAgICAgfSB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucyk7XG5cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcyksIHt9LCB7XG4gICAgICAgIHQ6IG1pZGRsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHZpYSAtIFRoZSBjb250cm9sIHBvaW50IGZvciB0aGUgZWRnZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBwb2ludC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9CZXppZXJFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWEpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgdmFyIGRpc3RhbmNlO1xuICAgICAgdmFyIGksIHQsIHgsIHk7XG4gICAgICB2YXIgbGFzdFggPSB4MTtcbiAgICAgIHZhciBsYXN0WSA9IHkxO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB0ID0gMC4xICogaTtcbiAgICAgICAgeCA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHgxICsgMiAqIHQgKiAoMSAtIHQpICogdmlhLnggKyBNYXRoLnBvdyh0LCAyKSAqIHgyO1xuICAgICAgICB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeTEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueSArIE1hdGgucG93KHQsIDIpICogeTI7XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlID8gZGlzdGFuY2UgOiBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIGEgYmV6aWVyIGN1cnZlIGJldHdlZW4gdHdvIG5vZGVzLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgbWV0aG9kIGFjY2VwdHMgemVybywgb25lIG9yIHR3byBjb250cm9sIHBvaW50cy5cclxuICAgICAqIFBhc3NpbmcgemVybyBjb250cm9sIHBvaW50cyBqdXN0IGRyYXdzIGEgc3RyYWlnaHQgbGluZS5cclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFN0eWxlIG9wdGlvbnMgZm9yIGVkZ2UgZHJhd2luZy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlMSAtIEZpcnN0IGNvbnRyb2wgcG9pbnQgZm9yIGN1cnZlIGRyYXdpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZTIgLSBTZWNvbmQgY29udHJvbCBwb2ludCBmb3IgY3VydmUgZHJhd2luZy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JlemllckN1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZTEsIHZpYU5vZGUyKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuXG4gICAgICBpZiAodmlhTm9kZTEgIT0gbnVsbCAmJiB2aWFOb2RlMS54ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHZpYU5vZGUyICE9IG51bGwgJiYgdmlhTm9kZTIueCAhPSBudWxsKSB7XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdmlhTm9kZTIueCwgdmlhTm9kZTIueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh2aWFOb2RlMS54LCB2aWFOb2RlMS55LCB0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayB0byBub3JtYWwgc3RyYWlnaHQgZWRnZVxuICAgICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICB9IC8vIGRyYXcgYSBiYWNrZ3JvdW5kXG5cblxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChjdHgsIHZhbHVlcyk7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmV6aWVyRWRnZUJhc2U7XG59KEVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgRHluYW1pYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbFxyXG4gKiBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy4gVGhlIER5bmFtaWMgcGllY2UgcmVmZXJzIHRvIGhvdyB0aGUgY3VydmVcclxuICogcmVhY3RzIHRvIHBoeXNpY3MgY2hhbmdlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEJlemllckVkZ2VCYXNlXHJcbiAqL1xuXG52YXIgQmV6aWVyRWRnZUR5bmFtaWMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQmV6aWVyRWRnZUR5bmFtaWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ4KEJlemllckVkZ2VEeW5hbWljKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlRHluYW1pYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlRHluYW1pYyk7XG5cbiAgICAvL3RoaXMudmlhID0gdW5kZWZpbmVkOyAvLyBIZXJlIGZvciBjb21wbGV0ZW5lc3MgYnV0IG5vdCBhbGxvd2VkIHRvIGRlZmluZWQgYmVmb3JlIHN1cGVyKCkgaXMgaW52b2tlZC5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTsgLy8gLS0+IHRoaXMgY2FsbHMgdGhlIHNldE9wdGlvbnMgYmVsb3dcblxuICAgIF90aGlzLnZpYSA9IF90aGlzLnZpYTsgLy8gY29uc3RydWN0b3Ig4oaSIHN1cGVyIOKGkiBzdXBlciDihpIgc2V0T3B0aW9ucyDihpIgc2V0dXBTdXBwb3J0Tm9kZVxuXG4gICAgX3RoaXMuX2JvdW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2JvZHkuZW1pdHRlci5vbihcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIiwgX3RoaXMuX2JvdW5kRnVuY3Rpb24pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VEeW5hbWljLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQmV6aWVyRWRnZUR5bmFtaWMucHJvdG90eXBlKSwgXCJzZXRPcHRpb25zXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhcyBjaGFuZ2VkLlxuXG5cbiAgICAgIHZhciBwaHlzaWNzQ2hhbmdlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgIHBoeXNpY3NDaGFuZ2UgPSB0cnVlO1xuICAgICAgfSAvLyBzZXQgdGhlIG9wdGlvbnMgYW5kIHRoZSB0byBhbmQgZnJvbSBub2Rlc1xuXG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dOyAvLyBzZXR1cCB0aGUgc3VwcG9ydCBub2RlIGFuZCBjb25uZWN0XG5cbiAgICAgIHRoaXMuc2V0dXBTdXBwb3J0Tm9kZSgpO1xuICAgICAgdGhpcy5jb25uZWN0KCk7IC8vIHdoZW4gd2UgY2hhbmdlIHRoZSBwaHlzaWNzIHN0YXRlIG9mIHRoZSBlZGdlLCB3ZSByZXBvc2l0aW9uIHRoZSBzdXBwb3J0IG5vZGUuXG5cbiAgICAgIGlmIChwaHlzaWNzQ2hhbmdlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IHRoaXMub3B0aW9ucy5waHlzaWNzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcblxuICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudG8gPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMucGh5c2ljcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5pZCA9PT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHRoaXMuX2JvZHkuZW1pdHRlci5vZmYoXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIsIHRoaXMuX2JvdW5kRnVuY3Rpb24pO1xuXG4gICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF07XG4gICAgICAgIHRoaXMudmlhID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgc3VwcG9ydCBub2RlIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIEJlemllciBjdXJ2ZXMgcmVxdWlyZSBhbiBhbmNob3IgcG9pbnQgdG8gY2FsY3VsYXRlIHRoZSBzbW9vdGggZmxvdy5cclxuICAgICAqIFRoZXNlIHBvaW50cyBhcmUgbm9kZXMuXHJcbiAgICAgKiBUaGVzZSBub2RlcyBhcmUgaW52aXNpYmxlIGJ1dCBhcmUgdXNlZCBmb3IgdGhlIGZvcmNlIGNhbGN1bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBjaGFuZ2VkIGRhdGEgaXMgbm90IGNhbGxlZCwgaWYgbmVlZGVkLCBpdCBpcyByZXR1cm5lZCBieSB0aGUgbWFpbiBlZGdlIGNvbnN0cnVjdG9yLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cFN1cHBvcnROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwU3VwcG9ydE5vZGUoKSB7XG4gICAgICBpZiAodGhpcy52aWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZUlkID0gXCJlZGdlSWQ6XCIgKyB0aGlzLmlkO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSh7XG4gICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB0aGlzLnZpYSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlhLnBhcmVudEVkZ2VJZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gYmV6aWVyIG5vZGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBvc2l0aW9uQmV6aWVyTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbkJlemllck5vZGUoKSB7XG4gICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52aWEueCA9IDAuNSAqICh0aGlzLmZyb20ueCArIHRoaXMudG8ueCk7XG4gICAgICAgIHRoaXMudmlhLnkgPSAwLjUgKiAodGhpcy5mcm9tLnkgKyB0aGlzLnRvLnkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmlhLnggPSAwO1xuICAgICAgICB0aGlzLnZpYS55ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSkge1xuICAgICAgdGhpcy5fYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52aWE7XG5cbiAgICAgIGlmICh0aGlzLmZyb20gPT09IHRoaXMudG8pIHtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGEsIDMpLFxuICAgICAgICAgICAgY3ggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMF0sXG4gICAgICAgICAgICBjeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICAgIGNyID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzJdO1xuXG4gICAgICAgIHZhciBhID0gMiAqIE1hdGguUEkgKiAoMSAtIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjeCArIGNyICogTWF0aC5zaW4oYSksXG4gICAgICAgICAgeTogY3kgKyBjciAtIGNyICogKDEgLSBNYXRoLmNvcyhhKSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5wb3coMSAtIHBvc2l0aW9uLCAyKSAqIHRoaXMuZnJvbVBvaW50LnggKyAyICogcG9zaXRpb24gKiAoMSAtIHBvc2l0aW9uKSAqIHZpYU5vZGUueCArIE1hdGgucG93KHBvc2l0aW9uLCAyKSAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICAgIHk6IE1hdGgucG93KDEgLSBwb3NpdGlvbiwgMikgKiB0aGlzLmZyb21Qb2ludC55ICsgMiAqIHBvc2l0aW9uICogKDEgLSBwb3NpdGlvbikgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyhwb3NpdGlvbiwgMikgKiB0aGlzLnRvUG9pbnQueVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIHRoaXMudmlhKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRoaXMudmlhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmV6aWVyRWRnZUR5bmFtaWM7XG59KEJlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgU3RhdGljIEJlemllciBFZGdlLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cblxudmFyIEJlemllckVkZ2VTdGF0aWMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQmV6aWVyRWRnZVN0YXRpYywgX0JlemllckVkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDcoQmV6aWVyRWRnZVN0YXRpYyk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZVN0YXRpYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlU3RhdGljKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZVN0YXRpYywgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpIHtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdmlhIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFdlIGRvIG5vdCB1c2UgdGhlIHRvIGFuZCBmcm9tUG9pbnRzIGhlcmUgdG8gbWFrZSB0aGUgdmlhIG5vZGVzIHRoZSBzYW1lIGFzIGVkZ2VzIHdpdGhvdXQgYXJyb3dzLlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSB2aWEgbm9kZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpYUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIC8vIEFzc3VtcHRpb246IHgveSBjb29yZGluYXRlcyBpbiBmcm9tL3RvIGFsd2F5cyBkZWZpbmVkXG4gICAgICB2YXIgZmFjdG9yID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3B0aW9ucy5zbW9vdGgudHlwZTtcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KTtcblxuICAgICAgaWYgKHR5cGUgPT09IFwiZGlzY3JldGVcIiB8fCB0eXBlID09PSBcImRpYWdvbmFsQ3Jvc3NcIikge1xuICAgICAgICB2YXIgc3RlcFg7XG4gICAgICAgIHZhciBzdGVwWTtcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICBzdGVwWCA9IHN0ZXBZID0gZmFjdG9yICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcFggPSBzdGVwWSA9IGZhY3RvciAqIGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgc3RlcFggPSAtc3RlcFg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgc3RlcFkgPSAtc3RlcFk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeFZpYSA9IHRoaXMuZnJvbS54ICsgc3RlcFg7XG4gICAgICAgIHZhciB5VmlhID0gdGhpcy5mcm9tLnkgKyBzdGVwWTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJkaXNjcmV0ZVwiKSB7XG4gICAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgICB4VmlhID0gZHggPCBmYWN0b3IgKiBkeSA/IHRoaXMuZnJvbS54IDogeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeVZpYSA9IGR5IDwgZmFjdG9yICogZHggPyB0aGlzLmZyb20ueSA6IHlWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4VmlhLFxuICAgICAgICAgIHk6IHlWaWFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJhaWdodENyb3NzXCIpIHtcbiAgICAgICAgdmFyIF9zdGVwWCA9ICgxIC0gZmFjdG9yKSAqIGR4O1xuXG4gICAgICAgIHZhciBfc3RlcFkgPSAoMSAtIGZhY3RvcikgKiBkeTtcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICAvLyB1cCAtIGRvd25cbiAgICAgICAgICBfc3RlcFggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICBfc3RlcFkgPSAtX3N0ZXBZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsZWZ0IC0gcmlnaHRcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIF9zdGVwWCA9IC1fc3RlcFg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3N0ZXBZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy50by54ICsgX3N0ZXBYLFxuICAgICAgICAgIHk6IHRoaXMudG8ueSArIF9zdGVwWVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICB2YXIgX3N0ZXBYMiA9ICgxIC0gZmFjdG9yKSAqIGR4O1xuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueCA8IHRoaXMudG8ueCkge1xuICAgICAgICAgIF9zdGVwWDIgPSAtX3N0ZXBYMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy50by54ICsgX3N0ZXBYMixcbiAgICAgICAgICB5OiB0aGlzLmZyb20ueVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgdmFyIF9zdGVwWTIgPSAoMSAtIGZhY3RvcikgKiBkeTtcblxuICAgICAgICBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICBfc3RlcFkyID0gLV9zdGVwWTI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54LFxuICAgICAgICAgIHk6IHRoaXMudG8ueSArIF9zdGVwWTJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjdXJ2ZWRDV1wiKSB7XG4gICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgICB2YXIgb3JpZ2luYWxBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgdmFyIG15QW5nbGUgPSAob3JpZ2luYWxBbmdsZSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcGkpICUgKDIgKiBwaSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy5mcm9tLnggKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHJhZGl1cyAqIE1hdGguc2luKG15QW5nbGUpLFxuICAgICAgICAgIHk6IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLmNvcyhteUFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImN1cnZlZENDV1wiKSB7XG4gICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG5cbiAgICAgICAgdmFyIF9yYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIHZhciBfcGkgPSBNYXRoLlBJO1xuXG4gICAgICAgIHZhciBfb3JpZ2luYWxBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcblxuICAgICAgICB2YXIgX215QW5nbGUgPSAoX29yaWdpbmFsQW5nbGUgKyAoLWZhY3RvciAqIDAuNSArIDAuNSkgKiBfcGkpICUgKDIgKiBfcGkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy5mcm9tLnggKyAoZmFjdG9yICogMC41ICsgMC41KSAqIF9yYWRpdXMgKiBNYXRoLnNpbihfbXlBbmdsZSksXG4gICAgICAgICAgeTogdGhpcy5mcm9tLnkgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIF9yYWRpdXMgKiBNYXRoLmNvcyhfbXlBbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgICAgdmFyIF9zdGVwWDM7XG5cbiAgICAgICAgdmFyIF9zdGVwWTM7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IF9zdGVwWTMgPSBmYWN0b3IgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3RlcFgzID0gX3N0ZXBZMyA9IGZhY3RvciAqIGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IC1fc3RlcFgzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgIF9zdGVwWTMgPSAtX3N0ZXBZMztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfeFZpYSA9IHRoaXMuZnJvbS54ICsgX3N0ZXBYMztcblxuICAgICAgICB2YXIgX3lWaWEgPSB0aGlzLmZyb20ueSArIF9zdGVwWTM7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgX3hWaWEgPSB0aGlzLnRvLnggPCBfeFZpYSA/IHRoaXMudG8ueCA6IF94VmlhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfeFZpYSA9IHRoaXMudG8ueCA+IF94VmlhID8gdGhpcy50by54IDogX3hWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgIF95VmlhID0gdGhpcy50by55ID4gX3lWaWEgPyB0aGlzLnRvLnkgOiBfeVZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3lWaWEgPSB0aGlzLnRvLnkgPCBfeVZpYSA/IHRoaXMudG8ueSA6IF95VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogX3hWaWEsXG4gICAgICAgICAgeTogX3lWaWFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4LCBvcHRpb25zLnZpYSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciB0ID0gcG9zaXRpb247XG4gICAgICB2YXIgeCA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnggKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnggKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC54O1xuICAgICAgdmFyIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC55ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS55ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJlemllckVkZ2VTdGF0aWM7XG59KEJlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDYoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgQmFzZSBDbGFzcyBmb3IgYWxsIEN1YmljIEJlemllciBFZGdlcy4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbFxyXG4gKiBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEJlemllckVkZ2VCYXNlXHJcbiAqL1xuXG52YXIgQ3ViaWNCZXppZXJFZGdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhDdWJpY0JlemllckVkZ2VCYXNlLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNihDdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMseTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tICh4MSx5MSkgdG8gKHgyLHkyKS5cclxuICAgKlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcclxuICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxyXG4gICAqIEBwYXJhbSB4MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICogQHBhcmFtIHkxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgKiBAcGFyYW0geDIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgKiBAcGFyYW0geTIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgKiBAcGFyYW0geDMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcy5cclxuICAgKiBAcGFyYW0geTMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpcy5cclxuICAgKiBAcGFyYW0gdmlhMSAtIFRoZSBmaXJzdCBwb2ludCB0aGlzIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICogQHBhcmFtIHZpYTIgLSBUaGUgc2Vjb25kIHBvaW50IHRoaXMgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGluZSBzZWdtZW50IGFuZCB0aGUgcG9pbnQuXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgIHZhciB2ZWMgPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB2YXIgdCA9IDAuMSAqIGk7XG4gICAgICAgIHZlY1swXSA9IE1hdGgucG93KDEgLSB0LCAzKTtcbiAgICAgICAgdmVjWzFdID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMik7XG4gICAgICAgIHZlY1syXSA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCk7XG4gICAgICAgIHZlY1szXSA9IE1hdGgucG93KHQsIDMpO1xuICAgICAgICB2YXIgeCA9IHZlY1swXSAqIHgxICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogeDI7XG4gICAgICAgIHZhciB5ID0gdmVjWzBdICogeTEgKyB2ZWNbMV0gKiB2aWExLnkgKyB2ZWNbMl0gKiB2aWEyLnkgKyB2ZWNbM10gKiB5MjtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG5cbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW5EaXN0YW5jZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3ViaWNCZXppZXJFZGdlQmFzZTtcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQSBDdWJpYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICovXG5cbnZhciBDdWJpY0JlemllckVkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdWJpY0JlemllckVkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhDdWJpY0JlemllckVkZ2UsIF9DdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDUoQ3ViaWNCZXppZXJFZGdlKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViaWNCZXppZXJFZGdlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJFZGdlLCBbe1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZXMpIHtcbiAgICAgIC8vIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHN1cHBvcnQgcG9pbnRzLlxuICAgICAgdmFyIHZpYTEgPSB2aWFOb2Rlc1swXTtcbiAgICAgIHZhciB2aWEyID0gdmlhTm9kZXNbMV07XG5cbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWExLCB2aWEyKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBhZGRpdGlvbmFsIHBvaW50cyB0aGUgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50cyB0aGUgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpYUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICB2YXIgeDE7XG4gICAgICB2YXIgeTE7XG4gICAgICB2YXIgeDI7XG4gICAgICB2YXIgeTI7XG4gICAgICB2YXIgcm91bmRuZXNzID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7IC8vIGhvcml6b250YWwgaWYgeCA+IHkgb3IgaWYgZGlyZWN0aW9uIGlzIGZvcmNlZCBvciBpZiBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbFxuXG4gICAgICBpZiAoKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiKSAmJiB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgeTEgPSB0aGlzLmZyb20ueTtcbiAgICAgICAgeTIgPSB0aGlzLnRvLnk7XG4gICAgICAgIHgxID0gdGhpcy5mcm9tLnggLSByb3VuZG5lc3MgKiBkeDtcbiAgICAgICAgeDIgPSB0aGlzLnRvLnggKyByb3VuZG5lc3MgKiBkeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gdGhpcy5mcm9tLnkgLSByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgeTIgPSB0aGlzLnRvLnkgKyByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgeDEgPSB0aGlzLmZyb20ueDtcbiAgICAgICAgeDIgPSB0aGlzLnRvLng7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB4OiB4MSxcbiAgICAgICAgeTogeTFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogeDIsXG4gICAgICAgIHk6IHkyXG4gICAgICB9XTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgdmlhMSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHZpYTIgPSBfcmVmMlsxXTtcblxuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCksXG4gICAgICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgdmlhMSA9IF9yZWY0WzBdLFxuICAgICAgICAgIHZpYTIgPSBfcmVmNFsxXTtcblxuICAgICAgdmFyIHQgPSBwb3NpdGlvbjtcbiAgICAgIHZhciB2ZWMgPSBbTWF0aC5wb3coMSAtIHQsIDMpLCAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKSwgMyAqIE1hdGgucG93KHQsIDIpICogKDEgLSB0KSwgTWF0aC5wb3codCwgMyldO1xuICAgICAgdmFyIHggPSB2ZWNbMF0gKiB0aGlzLmZyb21Qb2ludC54ICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogdGhpcy50b1BvaW50Lng7XG4gICAgICB2YXIgeSA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnkgKyB2ZWNbMV0gKiB2aWExLnkgKyB2ZWNbMl0gKiB2aWEyLnkgKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1YmljQmV6aWVyRWRnZTtcbn0oQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ0KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIFN0cmFpZ2h0IEVkZ2UuXHJcbiAqL1xuXG52YXIgU3RyYWlnaHRFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKFN0cmFpZ2h0RWRnZSwgX0VkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDQoU3RyYWlnaHRFZGdlKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBTdHJhaWdodEVkZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyYWlnaHRFZGdlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3RyYWlnaHRFZGdlLCBbe1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcykge1xuICAgICAgLy8gZHJhdyBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG4gICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSAtIHBvc2l0aW9uKSAqIHRoaXMuZnJvbVBvaW50LnggKyBwb3NpdGlvbiAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICB5OiAoMSAtIHBvc2l0aW9uKSAqIHRoaXMuZnJvbVBvaW50LnkgKyBwb3NpdGlvbiAqIHRoaXMudG9Qb2ludC55XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5mcm9tO1xuXG4gICAgICBpZiAobmVhck5vZGUuaWQgPT09IHRoaXMuZnJvbS5pZCkge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgIHZhciBkeSA9IG5vZGUxLnkgLSBub2RlMi55O1xuICAgICAgdmFyIGVkZ2VTZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIHZhciB0b0JvcmRlckRpc3QgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgdmFyIHRvQm9yZGVyUG9pbnQgPSAoZWRnZVNlZ21lbnRMZW5ndGggLSB0b0JvcmRlckRpc3QpIC8gZWRnZVNlZ21lbnRMZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueCArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS54LFxuICAgICAgICB5OiAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueSArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS55LFxuICAgICAgICB0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbn0oRWRnZUJhc2UpO1xuXG4vKipcbiAqIEFuIGVkZ2UgY29ubmVjdHMgdHdvIG5vZGVzIGFuZCBoYXMgYSBzcGVjaWZpYyBkaXJlY3Rpb24uXG4gKi9cblxudmFyIEVkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgIHZhbHVlcyBzcGVjaWZpYyB0byB0aGlzIGVkZ2UsIG11c3QgY29udGFpbiBhdCBsZWFzdCAnZnJvbScgYW5kICd0bydcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHkgICAgICAgICAgIHNoYXJlZCBzdGF0ZSBmcm9tIE5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkltYWdlc30gaW1hZ2VsaXN0ICBBIGxpc3Qgd2l0aCBpbWFnZXMuIE9ubHkgbmVlZGVkIHdoZW4gdGhlIGVkZ2UgaGFzIGltYWdlIGFycm93cy5cbiAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnMgIG9wdGlvbnMgZnJvbSB0aGUgRWRnZXNIYW5kbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyBkZWZhdWx0IG9wdGlvbnMgZnJvbSB0aGUgRWRnZUhhbmRsZXIgaW5zdGFuY2UuIFZhbHVlIGFuZCByZWZlcmVuY2UgYXJlIGNvbnN0YW50XG4gICAqL1xuICBmdW5jdGlvbiBFZGdlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZSk7XG5cbiAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBib2R5IHByb3ZpZGVkXCIpO1xuICAgIH0gLy8gU2luY2UgZ2xvYmFsT3B0aW9ucyBpcyBjb25zdGFudCBpbiB2YWx1ZXMgYXMgd2VsbCBhcyByZWZlcmVuY2UsXG4gICAgLy8gRm9sbG93aW5nIG5lZWRzIHRvIGJlIGRvbmUgb25seSBvbmNlLlxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlbGlzdCA9IGltYWdlbGlzdDsgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcblxuICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b0lkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmJhc2VXaWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG4gICAgdGhpcy5mcm9tID0gdW5kZWZpbmVkOyAvLyBhIG5vZGVcblxuICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgdGhpcy5lZGdlVHlwZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIHRydWVcbiAgICAvKiBJdCdzIGFuIGVkZ2UgbGFiZWwgKi9cbiAgICApO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9yIG92ZXJ3cml0ZSBvcHRpb25zIGZvciB0aGUgZWRnZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IHVuZGVmaW5lZCBpZiBubyBvcHRpb25zLCB0cnVlIGlmIGxheW91dCBhZmZlY3RpbmcgZGF0YSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVkZ2UsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGb2xsb3dpbmcgb3B0aW9ucyBpZiBjaGFuZ2VkIGFmZmVjdCB0aGUgbGF5b3V0LlxuXG5cbiAgICAgIHZhciBhZmZlY3RzTGF5b3V0ID0gdHlwZW9mIG9wdGlvbnMucGh5c2ljcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzIHx8IHR5cGVvZiBvcHRpb25zLmhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAodGhpcy5vcHRpb25zLmhpZGRlbiB8fCBmYWxzZSkgIT09IChvcHRpb25zLmhpZGRlbiB8fCBmYWxzZSkgfHwgdHlwZW9mIG9wdGlvbnMuZnJvbSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMuZnJvbSAhPT0gb3B0aW9ucy5mcm9tIHx8IHR5cGVvZiBvcHRpb25zLnRvICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMub3B0aW9ucy50byAhPT0gb3B0aW9ucy50bztcbiAgICAgIEVkZ2UucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zKTtcblxuICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJvbUlkID0gb3B0aW9ucy5mcm9tO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudG9JZCA9IG9wdGlvbnMudG87XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy50aXRsZSA9IG9wdGlvbnMudGl0bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IF9wYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnNdO1xuICAgICAgdGhpcy5jaG9vc2VyID0gY2hvb3NpZnkoXCJlZGdlXCIsIHBpbGUpOyAvLyB1cGRhdGUgbGFiZWwgTW9kdWxlXG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7IC8vIFVwZGF0ZSBlZGdlIHR5cGUsIHRoaXMgaWYgY2hhbmdlZCBhZmZlY3RzIHRoZSBsYXlvdXQuXG5cbiAgICAgIGFmZmVjdHNMYXlvdXQgPSB0aGlzLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgYWZmZWN0c0xheW91dDsgLy8gaWYgYW55dGhpbmcgaGFzIGJlZW4gdXBkYXRlcywgcmVzZXQgdGhlIHNlbGVjdGlvbiB3aWR0aCBhbmQgdGhlIGhvdmVyIHdpZHRoXG5cbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7IC8vIEEgbm9kZSBpcyBjb25uZWN0ZWQgd2hlbiBpdCBoYXMgYSBmcm9tIGFuZCB0byBub2RlIHRoYXQgYm90aCBleGlzdCBpbiB0aGUgbmV0d29yay5ib2R5Lm5vZGVzLlxuXG5cbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIGFmZmVjdHNMYXlvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtnbG9iYWxPcHRpb25zPXt9XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHlGcm9tR2xvYmFscz1mYWxzZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJvd09wdGlvbnN9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpIHtcbiAgICAgIHZhciB0b0Fycm93ID0gdGhpcy5vcHRpb25zLmFycm93cy50byA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgZnJvbUFycm93ID0gdGhpcy5vcHRpb25zLmFycm93cy5mcm9tID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIG1pZGRsZUFycm93ID0gdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUgPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBpbmhlcml0c0NvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmluaGVyaXQ7XG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICB0b0Fycm93OiB0b0Fycm93LFxuICAgICAgICB0b0Fycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uc2NhbGVGYWN0b3IsXG4gICAgICAgIHRvQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnR5cGUsXG4gICAgICAgIHRvQXJyb3dTcmM6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uc3JjLFxuICAgICAgICB0b0Fycm93SW1hZ2VXaWR0aDogdGhpcy5vcHRpb25zLmFycm93cy50by5pbWFnZVdpZHRoLFxuICAgICAgICB0b0Fycm93SW1hZ2VIZWlnaHQ6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uaW1hZ2VIZWlnaHQsXG4gICAgICAgIG1pZGRsZUFycm93OiBtaWRkbGVBcnJvdyxcbiAgICAgICAgbWlkZGxlQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3IsXG4gICAgICAgIG1pZGRsZUFycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUudHlwZSxcbiAgICAgICAgbWlkZGxlQXJyb3dTcmM6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNyYyxcbiAgICAgICAgbWlkZGxlQXJyb3dJbWFnZVdpZHRoOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5pbWFnZVdpZHRoLFxuICAgICAgICBtaWRkbGVBcnJvd0ltYWdlSGVpZ2h0OiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5pbWFnZUhlaWdodCxcbiAgICAgICAgZnJvbUFycm93OiBmcm9tQXJyb3csXG4gICAgICAgIGZyb21BcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uc2NhbGVGYWN0b3IsXG4gICAgICAgIGZyb21BcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS50eXBlLFxuICAgICAgICBmcm9tQXJyb3dTcmM6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5zcmMsXG4gICAgICAgIGZyb21BcnJvd0ltYWdlV2lkdGg6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5pbWFnZVdpZHRoLFxuICAgICAgICBmcm9tQXJyb3dJbWFnZUhlaWdodDogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmltYWdlSGVpZ2h0LFxuICAgICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2gsXG4gICAgICAgIGNvbG9yOiBpbmhlcml0c0NvbG9yID8gdW5kZWZpbmVkIDogdGhpcy5vcHRpb25zLmNvbG9yLmNvbG9yLFxuICAgICAgICBpbmhlcml0c0NvbG9yOiBpbmhlcml0c0NvbG9yLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wdGlvbnMuY29sb3Iub3BhY2l0eSxcbiAgICAgICAgaGlkZGVuOiB0aGlzLm9wdGlvbnMuaGlkZGVuLFxuICAgICAgICBsZW5ndGg6IHRoaXMub3B0aW9ucy5sZW5ndGgsXG4gICAgICAgIHNoYWRvdzogdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLFxuICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixcbiAgICAgICAgc2hhZG93U2l6ZTogdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplLFxuICAgICAgICBzaGFkb3dYOiB0aGlzLm9wdGlvbnMuc2hhZG93LngsXG4gICAgICAgIHNoYWRvd1k6IHRoaXMub3B0aW9ucy5zaGFkb3cueSxcbiAgICAgICAgZGFzaGVzOiB0aGlzLm9wdGlvbnMuZGFzaGVzLFxuICAgICAgICB3aWR0aDogdGhpcy5vcHRpb25zLndpZHRoLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5lbmFibGVkLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmNvbG9yLFxuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuc2l6ZSxcbiAgICAgICAgYmFja2dyb3VuZERhc2hlczogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuZGFzaGVzXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLmhvdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNob29zZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRXaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IHNlbGVjdGVkV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoICs9IHNlbGVjdGVkV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBob3ZlcldpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBob3ZlcldpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBob3ZlcldpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3ZlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMub3B0aW9ucy5pZCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG5cbiAgICAgICAgICBpZiAodmFsdWVzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5pbmhlcml0c0NvbG9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvd0NvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IHZhbHVlcy5zaGFkb3dTaXplICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUgfHwgdmFsdWVzLnNoYWRvd1ggIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueCB8fCB2YWx1ZXMuc2hhZG93WSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy55KSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgb3B0aW9ucyBpbiB0aGUgbGFiZWwgbW9kdWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTGFiZWxNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucykge1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmdsb2JhbE9wdGlvbnMsIC8vIEN1cnJlbnRseSBzZXQgZ2xvYmFsIGVkZ2Ugb3B0aW9uc1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLnVwZGF0ZSh0aGlzLm9wdGlvbnMsIHBpbGUpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBlZGdlIHR5cGUsIHNldCB0aGUgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFZGdlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlVHlwZSgpIHtcbiAgICAgIHZhciBzbW9vdGggPSB0aGlzLm9wdGlvbnMuc21vb3RoO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY2hhbmdlSW5UeXBlID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VEeW5hbWljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSBcImR5bmFtaWNcIiB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQ3ViaWNCZXppZXJFZGdlICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSBcImN1YmljQmV6aWVyXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VTdGF0aWMgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgIT09IFwiZHluYW1pY1wiICYmIHNtb290aC50eXBlICE9PSBcImN1YmljQmV6aWVyXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIFN0cmFpZ2h0RWRnZSAmJiBzbW9vdGgudHlwZS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGNoYW5nZUluVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VEeW5hbWljKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNtb290aC50eXBlID09PSBcImN1YmljQmV6aWVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgQ3ViaWNCZXppZXJFZGdlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBCZXppZXJFZGdlU3RhdGljKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBTdHJhaWdodEVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3RoaW5nIGNoYW5nZXMsIHdlIGp1c3Qgc2V0IHRoZSBvcHRpb25zLlxuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGFuIGVkZ2UgdG8gaXRzIG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdIHx8IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5mcm9tLmF0dGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMudG8uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgICB0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZVR5cGUuY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFuIGVkZ2UgZnJvbSBpdHMgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLnRvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgZWRnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgZWRnZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGVkZ2UuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGVkZ2UuIFRoZSBlZGdlIHdpbGwgYWRqdXN0IGl0J3Mgd2lkdGhcbiAgICAgKiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIHZhciB3aWR0aERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHdpZHRoRGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMuYmFzZVdpZHRoO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7XG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEludGVyYWN0aW9uV2lkdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbnRlcmFjdGlvbldpZHRocygpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCArIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGEgZWRnZVxuICAgICAqIERyYXcgdGhpcyBlZGdlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuXG4gICAgICBpZiAodmFsdWVzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG5cblxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTsgLy8gZHJhdyBsaW5lIGFuZCBsYWJlbFxuXG4gICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdMaW5lKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2aWFOb2RlKTtcbiAgICAgIHRoaXMuZHJhd0xhYmVsKGN0eCwgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhcnJvd3NcbiAgICAgKiBEcmF3IHRoaXMgYXJyb3dzIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0Fycm93c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dzKGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuXG4gICAgICBpZiAodmFsdWVzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG5cblxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTsgLy8gcmVzdG9yZSBlZGdlIHRhcmdldHMgdG8gZGVmYXVsdHNcblxuICAgICAgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmZyb207XG4gICAgICB0aGlzLmVkZ2VUeXBlLnRvUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLnRvOyAvLyBmcm9tIGFuZCB0byBhcnJvd3MgZ2l2ZSBhIGRpZmZlcmVudCBlbmQgcG9pbnQgZm9yIGVkZ2VzLiB3ZSBzZXQgdGhlbSBoZXJlXG5cbiAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93KSB7XG4gICAgICAgIGFycm93RGF0YS5mcm9tID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCBcImZyb21cIiwgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IGFycm93RGF0YS5mcm9tLmNvcmU7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dTcmMpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLmZyb21BcnJvd1NyYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZVdpZHRoID0gdmFsdWVzLmZyb21BcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd0ltYWdlSGVpZ2h0KSB7XG4gICAgICAgICAgYXJyb3dEYXRhLmZyb20uaW1hZ2VIZWlnaHQgPSB2YWx1ZXMuZnJvbUFycm93SW1hZ2VIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy50b0Fycm93KSB7XG4gICAgICAgIGFycm93RGF0YS50byA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJ0b1wiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUudG9Qb2ludCA9IGFycm93RGF0YS50by5jb3JlO1xuXG4gICAgICAgIGlmICh2YWx1ZXMudG9BcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLnRvQXJyb3dTcmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy50b0Fycm93SW1hZ2VXaWR0aCkge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZVdpZHRoID0gdmFsdWVzLnRvQXJyb3dJbWFnZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy50b0Fycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2VIZWlnaHQgPSB2YWx1ZXMudG9BcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IC8vIHRoZSBtaWRkbGUgYXJyb3cgZGVwZW5kcyBvbiB0aGUgbGluZSwgd2hpY2ggY2FuIGRlcGVuZCBvbiB0aGUgdG8gYW5kIGZyb20gYXJyb3dzIHNvIHdlIGRvIHRoaXMgb25lIGxhc3RseS5cblxuXG4gICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93KSB7XG4gICAgICAgIGFycm93RGF0YS5taWRkbGUgPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsIFwibWlkZGxlXCIsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2UgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHZhbHVlcy5taWRkbGVBcnJvd1NyYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93SW1hZ2VXaWR0aCkge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2VXaWR0aCA9IHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEubWlkZGxlLmltYWdlSGVpZ2h0ID0gdmFsdWVzLm1pZGRsZUFycm93SW1hZ2VIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEuZnJvbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEubWlkZGxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy50b0Fycm93KSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xhYmVsKGN0eCwgdmlhTm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgICB2YXIgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIHZhciBub2RlMiA9IHRoaXMudG87XG5cbiAgICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUodGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlcikpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQ7XG5cbiAgICAgICAgaWYgKG5vZGUxLmlkICE9IG5vZGUyLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5lZGdlVHlwZS5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKGN0eCk7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Qb2ludC5hbmdsZSAhPSAwKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHJvdGF0aW9uUG9pbnQueCwgcm90YXRpb25Qb2ludC55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocm90YXRpb25Qb2ludC5hbmdsZSk7XG4gICAgICAgICAgfSAvLyBkcmF3IHRoZSBsYWJlbFxuXG5cbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgICAvKlxuICAgICAgICAgIC8vIFVzZWZ1bCBkZWJ1ZyBjb2RlOiBkcmF3IGEgYm9yZGVyIGFyb3VuZCB0aGUgbGFiZWxcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCAqKm5vdCoqIGJlIGVuYWJsZWQgaW4gcHJvZHVjdGlvbiFcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpOzsgLy8gOzsgaW50ZW50aW9uYWwgc28gbGludCBjYXRjaGVzIGl0XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjZmYwMDAwXCI7XG4gICAgICAgICAgY3R4LnN0cm9rZVJlY3Qoc2l6ZS5sZWZ0LCBzaXplLnRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgIC8vIEVuZCAgZGVidWcgY29kZVxuICAgICAgICAgICovXG5cbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElnbm9yZSB0aGUgb3JpZW50YXRpb25zLlxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSB0cnVlOyAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG5cbiAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZSwgbm9kZTEpO1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5fcG9pbnRPbkNpcmNsZShjb29yZGluYXRlcy54LCBjb29yZGluYXRlcy55LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSk7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBlZGdlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJdGVtc09uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbXNPblBvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCwgcm90YXRpb25Qb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICBlZGdlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBsYWJlbElkOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgdG9wOiBwb2ludC55XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pc092ZXJsYXBwaW5nV2l0aChvYmopKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBlZGdlSWQ6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gdGhlIGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBkaXN0TWF4ID0gMTA7XG4gICAgICAgIHZhciB4RnJvbSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgdmFyIHhUbyA9IHRoaXMudG8ueDtcbiAgICAgICAgdmFyIHlUbyA9IHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgdmFyIHlPYmogPSBvYmoudG9wO1xuICAgICAgICB2YXIgZGlzdCA9IHRoaXMuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgeE9iaiwgeU9iaik7XG4gICAgICAgIHJldHVybiBkaXN0IDwgZGlzdE1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSByb3RhdGlvbiBwb2ludCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIGlmIHBhc3NlZCwgZG8gYSByZWNhbGN1bGF0aW9uIG9mIHRoZSBsYWJlbCBzaXplXG4gICAgICogQHJldHVybnMge3JvdGF0aW9uUG9pbnR9IHRoZSBwb2ludCB0byByb3RhdGUgYXJvdW5kIGFuZCB0aGUgYW5nbGUgaW4gcmFkaWFucyB0byByb3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSb3RhdGlvbihjdHgpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG5cbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiB0aGlzLmxhYmVsTW9kdWxlLnNpemUueUxpbmUsXG4gICAgICAgIGFuZ2xlOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiByZXQ7IC8vIERvbid0IGV2ZW4gYm90aGVyIGRvaW5nIHRoZSBhdGFuMiwgdGhlcmUncyBub3RoaW5nIHRvIGRyYXdcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250LmFsaWduID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBObyBuZWVkIHRvIGNhbGN1bGF0ZSBhbmdsZVxuICAgICAgfVxuXG4gICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpOyAvLyByYWRpYW5zXG4gICAgICAvLyByb3RhdGUgc28gdGhhdCBsYWJlbCBpcyByZWFkYWJsZVxuXG4gICAgICBpZiAoYW5nbGUgPCAtMSAmJiBkeCA8IDAgfHwgYW5nbGUgPiAwICYmIGR4IDwgMCkge1xuICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xuICAgICAgfVxuXG4gICAgICByZXQuYW5nbGUgPSBhbmdsZTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wb2ludE9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgYW5nbGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IHkgLSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgc3RhdGUgdG8gdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xlYW5zIGFsbCByZXF1aXJlZCB0aGluZ3Mgb24gZGVsZXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VUeXBlLmNsZWFudXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVkZ2UgZnJvbSB0aGUgbGlzdCBhbmQgcGVyZm9ybSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1t0aGlzLmlkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYm90aCBjb25uZWN0aW5nIG5vZGVzIGV4aXN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuZFBvaW50c1ZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZFBvaW50c1ZhbGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucykge1xuICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIGNvcHlGcm9tR2xvYmFscyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgICB2YXIgZmllbGRzID0gW1wiZW5kUG9pbnRPZmZzZXRcIiwgXCJhcnJvd1N0cmlrZXRocm91Z2hcIiwgXCJpZFwiLCBcImZyb21cIiwgXCJoaWRkZW5cIiwgXCJob3ZlcldpZHRoXCIsIFwibGFiZWxIaWdobGlnaHRCb2xkXCIsIFwibGVuZ3RoXCIsIFwibGluZVwiLCBcIm9wYWNpdHlcIiwgXCJwaHlzaWNzXCIsIFwic2NhbGluZ1wiLCBcInNlbGVjdGlvbldpZHRoXCIsIFwic2VsZlJlZmVyZW5jZVNpemVcIiwgXCJzZWxmUmVmZXJlbmNlXCIsIFwidG9cIiwgXCJ0aXRsZVwiLCBcInZhbHVlXCIsIFwid2lkdGhcIiwgXCJmb250XCIsIFwiY2hvc2VuXCIsIFwid2lkdGhDb25zdHJhaW50XCJdOyAvLyBvbmx5IGRlZXAgZXh0ZW5kIHRoZSBpdGVtcyBpbiB0aGUgZmllbGQgYXJyYXkuIFRoZXNlIGRvIG5vdCBoYXZlIHNob3J0aGFuZC5cblxuICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pOyAvLyBPbmx5IHVzZSBlbmRQb2ludE9mZnNldCB2YWx1ZXMgKGZyb20gYW5kIHRvKSBpZiBpdCdzIHZhbGlkIHZhbHVlc1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfaXNGaW5pdGUobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tKSkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA9IG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gPSBnbG9iYWxPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gIT09IHVuZGVmaW5lZCA/IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA6IDA7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImVuZFBvaW50T2Zmc2V0LmZyb20gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfaXNGaW5pdGUobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC50bykpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvID0gbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC50bztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvID0gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC50byAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA6IDA7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImVuZFBvaW50T2Zmc2V0LnRvIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBPbmx5IGNvcHkgbGFiZWwgaWYgaXQncyBhIGxlZ2FsIHZhbHVlLlxuXG5cbiAgICAgIGlmIChpc1ZhbGlkTGFiZWwobmV3T3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5sYWJlbCA9IG5ld09wdGlvbnMubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkTGFiZWwocGFyZW50T3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwic21vb3RoXCIsIGdsb2JhbE9wdGlvbnMpO1xuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwic2hhZG93XCIsIGdsb2JhbE9wdGlvbnMpO1xuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwiYmFja2dyb3VuZFwiLCBnbG9iYWxPcHRpb25zKTtcblxuICAgICAgaWYgKG5ld09wdGlvbnMuZGFzaGVzICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5kYXNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5kYXNoZXMgPSBuZXdPcHRpb25zLmRhc2hlcztcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmRhc2hlcyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IGNyZWF0ZSQ1KGdsb2JhbE9wdGlvbnMuZGFzaGVzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH0gLy8gc2V0IHRoZSBzY2FsaW5nIG5ld09wdGlvbnNcblxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5zY2FsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWluID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWF4ID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgXCJsYWJlbFwiLCBnbG9iYWxPcHRpb25zLnNjYWxpbmcpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuc2NhbGluZyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcgPSBjcmVhdGUkNShnbG9iYWxPcHRpb25zLnNjYWxpbmcpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgfSAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGFycm93c1xuXG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmFycm93cyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuYXJyb3dzICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hcnJvd3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgYXJyb3dzID0gbmV3T3B0aW9ucy5hcnJvd3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy50by5lbmFibGVkID0gaW5kZXhPZihhcnJvd3MpLmNhbGwoYXJyb3dzLCBcInRvXCIpICE9IC0xO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID0gaW5kZXhPZihhcnJvd3MpLmNhbGwoYXJyb3dzLCBcIm1pZGRsZVwiKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPSBpbmRleE9mKGFycm93cykuY2FsbChhcnJvd3MsIFwiZnJvbVwiKSAhPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG5ld09wdGlvbnMuYXJyb3dzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwidG9cIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwibWlkZGxlXCIsIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCBcImZyb21cIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcnJvdyBuZXdPcHRpb25zIGNhbiBvbmx5IGJlIGFuIG9iamVjdCBvciBhIHN0cmluZy4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uIFlvdSB1c2VkOlwiICsgc3RyaW5naWZ5JDEobmV3T3B0aW9ucy5hcnJvd3MpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuYXJyb3dzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzID0gY3JlYXRlJDUoZ2xvYmFsT3B0aW9ucy5hcnJvd3MpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgfSAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGNvbG9yXG5cblxuICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBmcm9tQ29sb3IgPSBpc1N0cmluZyhuZXdPcHRpb25zLmNvbG9yKSA/IHtcbiAgICAgICAgICBjb2xvcjogbmV3T3B0aW9ucy5jb2xvcixcbiAgICAgICAgICBoaWdobGlnaHQ6IG5ld09wdGlvbnMuY29sb3IsXG4gICAgICAgICAgaG92ZXI6IG5ld09wdGlvbnMuY29sb3IsXG4gICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9IDogbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdmFyIHRvQ29sb3IgPSBwYXJlbnRPcHRpb25zLmNvbG9yOyAvLyBJZiBwYXNzZWQsIGZpbGwgaW4gdmFsdWVzIGZyb20gZGVmYXVsdCBvcHRpb25zIC0gcmVxdWlyZWQgaW4gdGhlIGNhc2Ugb2Ygbm8gcHJvdG90eXBlIGJyaWRnaW5nXG5cbiAgICAgICAgaWYgKGNvcHlGcm9tR2xvYmFscykge1xuICAgICAgICAgIGRlZXBFeHRlbmQodG9Db2xvciwgZ2xvYmFsT3B0aW9ucy5jb2xvciwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsZWFyIGxvY2FsIHByb3BlcnRpZXMgLSBuZWVkIHRvIGRvIGl0IGxpa2UgdGhpcyBpbiBvcmRlciB0byByZXRhaW4gcHJvdG90eXBlIGJyaWRnZXNcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRvQ29sb3IpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG9Db2xvciwgaSkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRvQ29sb3JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKHRvQ29sb3IpKSB7XG4gICAgICAgICAgdG9Db2xvci5jb2xvciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaG92ZXIgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3Iub3BhY2l0eSA9IDEuMDsgLy8gc2V0IGRlZmF1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbG9yc0RlZmluZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5jb2xvciA9IGZyb21Db2xvci5jb2xvcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaGlnaGxpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaGlnaGxpZ2h0ID0gZnJvbUNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5ob3ZlciA9IGZyb21Db2xvci5ob3ZlcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaW5oZXJpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBmcm9tQ29sb3IuaW5oZXJpdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5vcGFjaXR5ID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZnJvbUNvbG9yLm9wYWNpdHkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29sb3JzRGVmaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b0NvbG9yLmluaGVyaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBcImZyb21cIjsgLy8gU2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdPcHRpb25zLCBcInNlbGZSZWZlcmVuY2VTaXplXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBzZWxmUmVmZXJlbmNlU2l6ZSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHNlbGZSZWZlcmVuY2UgcHJvcGVydHkgaW5zdGVhZC4gVGhlIHNlbGZSZWZlcmVuY2UgY2FuIGJlIHNldCBsaWtlIHRoaXNlIHNlbGZSZWZlcmVuY2U6e3NpemU6MzAsIGFuZ2xlOk1hdGguUEkgLyA0fVwiKTtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUgPSBuZXdPcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGdlO1xufSgpO1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIEVkZ2VzXG4gKi9cblxudmFyIEVkZ2VzSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxJbWFnZT59IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKi9cbiAgZnVuY3Rpb24gRWRnZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzKSB7XG4gICAgdmFyIF9jb250ZXh0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZXNIYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgdGhpcy5ncm91cHMgPSBncm91cHM7IC8vIGNyZWF0ZSB0aGUgZWRnZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG5cbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UgPSBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLmNyZWF0ZSkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgdGhpcy5lZGdlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGFycm93czoge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICB9LFxuICAgICAgICAvLyBib29sZWFuIC8ge2Fycm93U2NhbGVGYWN0b3I6MX0gLyB7ZW5hYmxlZDogZmFsc2UsIGFycm93U2NhbGVGYWN0b3I6MX1cbiAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgIH0sXG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVuZFBvaW50T2Zmc2V0OiB7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAwXG4gICAgICB9LFxuICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IFwiIzg0ODQ4NFwiLFxuICAgICAgICBoaWdobGlnaHQ6IFwiIzg0ODQ4NFwiLFxuICAgICAgICBob3ZlcjogXCIjODQ4NDg0XCIsXG4gICAgICAgIGluaGVyaXQ6IFwiZnJvbVwiLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IGZhbHNlLFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogXCIjMzQzNDM0XCIsXG4gICAgICAgIHNpemU6IDE0LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiBcImFyaWFsXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgLy8gcHhcbiAgICAgICAgc3Ryb2tlQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBhbGlnbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgdmFkanVzdDogMCxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogXCJib2xkXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcIml0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6IFwiXCIsXG4gICAgICAgICAgc2l6ZTogMTUsXG4gICAgICAgICAgLy8gcHhcbiAgICAgICAgICBmYWNlOiBcImNvdXJpZXIgbmV3XCIsXG4gICAgICAgICAgdmFkanVzdDogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGhvdmVyV2lkdGg6IDEuNSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMSxcbiAgICAgICAgbWF4OiAxNSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGlvbldpZHRoOiAxLjUsXG4gICAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICAgIHNpemU6IDIwLFxuICAgICAgICBhbmdsZTogTWF0aC5QSSAvIDQsXG4gICAgICAgIHJlbmRlckJlaGluZFRoZU5vZGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgeDogNSxcbiAgICAgICAgeTogNVxuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMTExLDExMSwxMTEsMSlcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIGRhc2hlczogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzbW9vdGg6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJkeW5hbWljXCIsXG4gICAgICAgIGZvcmNlRGlyZWN0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgcm91bmRuZXNzOiAwLjVcbiAgICAgIH0sXG4gICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBkZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVkZ2VzSGFuZGxlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzLFxuICAgICAgICAgIF9jb250ZXh0MixcbiAgICAgICAgICBfY29udGV4dDM7XG5cbiAgICAgIC8vIHRoaXMgYWxsb3dzIGV4dGVybmFsIG1vZHVsZXMgdG8gZm9yY2UgYWxsIGR5bmFtaWMgY3VydmVzIHRvIHR1cm4gc3RhdGljLlxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICB0eXBlID0gXCJjb250aW51b3VzXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gX3RoaXMyLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzMi5ib2R5LmVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzMi5ib2R5LmVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgICAgIHZhciBlZGdlRGF0YSA9IF90aGlzMi5ib2R5LmRhdGEuZWRnZXMuZ2V0KGVkZ2VJZCk7IC8vIG9ubHkgZm9yY2libHkgcmVtb3ZlIHRoZSBzbW9vdGggY3VydmUgaWYgdGhlIGRhdGEgaGFzIGJlZW4gc2V0IG9mIHRoZSBlZGdlIGhhcyB0aGUgc21vb3RoIGN1cnZlcyBkZWZpbmVkLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIGEgY2hhbmdlIGluIHRoZSBnbG9iYWwgd291bGQgbm90IGFmZmVjdCB0aGVzZSBjdXJ2ZXMuXG5cblxuICAgICAgICAgICAgaWYgKGVkZ2VEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHNtb290aE9wdGlvbnMgPSBlZGdlRGF0YS5zbW9vdGg7XG5cbiAgICAgICAgICAgICAgaWYgKHNtb290aE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGhPcHRpb25zLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoT3B0aW9ucy50eXBlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgIHNtb290aDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSAmJiBkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogTm90IHRydWUsIGNhbGxlZCB3aGVuIG9wdGlvbnMgaGF2ZSBOT1QgY2hhbmdlZCwgZm9yIGJvdGggZXhpc3RpbmcgYXMgd2VsbCBhcyBuZXcgbm9kZXMuXG4gICAgICAvLyAgICAgICBTZWUgdXBkYXRlKCkgZm9yIGxvZ2ljLlxuICAgICAgLy8gVE9ETzogVmVyaWZ5IGFuZCBleGFtaW5lIHRoZSBjb25zZXF1ZW5jZXMgb2YgdGhpcy4gSXQgbWlnaHQgc3RpbGwgdHJpZ2dlciB3aGVuXG4gICAgICAvLyAgICAgICBub24tb3B0aW9uIGZpZWxkcyBoYXZlIGNoYW5nZWQsIGJ1dCB0aGVuIHJlY29ubmVjdGluZyBlZGdlcyBpcyBzdGlsbCB1c2VsZXNzLlxuICAgICAgLy8gICAgICAgQWx0ZXJuYXRpdmVseSwgaXQgbWlnaHQgYWxzbyBiZSBjYWxsZWQgd2hlbiBlZGdlcyBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlY29ubmVjdEVkZ2VzKCk7XG4gICAgICB9KTsgLy8gcmVmcmVzaCB0aGUgZWRnZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaEVkZ2VzXCIsIGJpbmQkNihfY29udGV4dDIgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hcIiwgYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczIuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZGF0YS5lZGdlcykgX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy5hZGQ7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLnJlbW92ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1c2UgdGhlIHBhcnNlciBmcm9tIHRoZSBFZGdlIGNsYXNzIHRvIGZpbGwgaW4gYWxsIHNob3J0aGFuZCBub3RhdGlvbnNcbiAgICAgICAgRWRnZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmRlZmF1bHRPcHRpb25zLCB0cnVlKTsgLy8gdXBkYXRlIHNtb290aCBzZXR0aW5ncyBpbiBhbGwgZWRnZXNcblxuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zbW9vdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0udXBkYXRlRWRnZVR5cGUoKSB8fCBkYXRhQ2hhbmdlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIGZvbnRzIGluIGFsbCBlZGdlc1xuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2VkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLCBfZWRnZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgdmFyaWFibGVzIGlmIG5lZWRlZFxuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQgfHwgZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgZWRnZXMgYnkgcmVhZGluZyB0aGUgZGF0YSB0YWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gZWRnZXMgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgZWRnZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXSAtIFN1cHByZXNzIGRhdGEgY2hhbmdlZCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGVkZ2VzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgb2xkRWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG5cbiAgICAgIGlmIChpc0RhdGFWaWV3TGlrZShcImlkXCIsIGVkZ2VzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IGVkZ2VzO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIoZWRnZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuYWRkKGVkZ2VzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWVkZ2VzKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkXCIpO1xuICAgICAgfSAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuXG5cbiAgICAgIGlmIChvbGRFZGdlc0RhdGEpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICBmb3JFYWNoJDEodGhpcy5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIG9sZEVkZ2VzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHJlbW92ZSBkcmF3biBlZGdlc1xuXG5cbiAgICAgIHRoaXMuYm9keS5lZGdlcyA9IHt9OyAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuXG4gICAgICBpZiAodGhpcy5ib2R5LmRhdGEuZWRnZXMpIHtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5lZGdlcy5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTsgLy8gZHJhdyBhbGwgbmV3IG5vZGVzXG5cbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldElkcygpO1xuICAgICAgICB0aGlzLmFkZChpZHMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGlkcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIG9sZEVkZ2UgPSBlZGdlc1tpZF07XG5cbiAgICAgICAgaWYgKG9sZEVkZ2UpIHtcbiAgICAgICAgICBvbGRFZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCwge1xuICAgICAgICAgIHNob3dJbnRlcm5hbElkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIik7XG5cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBleGlzdGluZyBlZGdlcywgb3IgY3JlYXRlIHRoZW0gd2hlbiBub3QgeWV0IGV4aXN0aW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcykge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBlZGdlc0RhdGEuZ2V0KGlkKTtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG5cbiAgICAgICAgaWYgKGVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBlZGdlXG4gICAgICAgICAgZWRnZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSBlZGdlLnNldE9wdGlvbnMoZGF0YSkgfHwgZGF0YUNoYW5nZWQ7IC8vIGlmIGEgc3VwcG9ydCBub2RlIGlzIGFkZGVkLCBkYXRhIGNhbiBiZSBjaGFuZ2VkLlxuXG4gICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV4aXN0aW5nIGVkZ2VzLiBOb24gZXhpc3RpbmcgaWRzIHdpbGwgYmUgaWdub3JlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIGVhcmx5IG91dFxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3JFYWNoJDEoaWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG5cbiAgICAgICAgaWYgKGVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZW1pdCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgRWRnZSBIYW5kbGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzNC5ib2R5LmRhdGEuZWRnZXMuZ2V0KGVkZ2VJZCk7XG5cbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7RWRnZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIG5ldyBFZGdlKHByb3BlcnRpZXMsIHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdCBhbGwgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWNvbm5lY3RFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvbm5lY3RFZGdlcygpIHtcbiAgICAgIHZhciBpZDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgZm9yIChpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBpZCkpIHtcbiAgICAgICAgICBub2Rlc1tpZF0uZWRnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWRnZXMsIGlkKSkge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgIGVkZ2UuZnJvbSA9IG51bGw7XG4gICAgICAgICAgZWRnZS50byA9IG51bGw7XG4gICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbm5lY3RlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKGVkZ2VJZCkge1xuICAgICAgdmFyIG5vZGVMaXN0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgaWYgKGVkZ2UuZnJvbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlLnRvSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZUxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZXJlIGlzIG5vIGRpcmVjdCByZWxhdGlvbiBiZXR3ZWVuIHRoZSBub2RlcyBhbmQgdGhlIGVkZ2VzIERhdGFTZXQsXG4gICAgICogc28gdGhlIHJpZ2h0IHBsYWNlIHRvIGRvIGNhbGwgdGhpcyBpcyBpbiB0aGUgaGFuZGxlciBmb3IgZXZlbnQgYF9kYXRhVXBkYXRlZGAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN0YXRlKCkge1xuICAgICAgdGhpcy5fYWRkTWlzc2luZ0VkZ2VzKCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUludmFsaWRFZGdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FuIGZvciBtaXNzaW5nIG5vZGVzIGFuZCByZW1vdmUgY29ycmVzcG9uZGluZyBlZGdlcywgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVJbnZhbGlkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUludmFsaWRFZGdlcygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgZWRnZXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGlkKSB7XG4gICAgICAgIHZhciB0b05vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLnRvSWRdO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF07IC8vIFNraXAgY2x1c3RlcmluZyBlZGdlcyBoZXJlLCBsZXQgdGhlIENsdXN0ZXJpbmcgbW9kdWxlIGhhbmRsZSB0aG9zZVxuXG4gICAgICAgIGlmICh0b05vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUuaXNDbHVzdGVyID09PSB0cnVlIHx8IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgZnJvbU5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZyb21Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlc1RvRGVsZXRlLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVtb3ZlKGVkZ2VzVG9EZWxldGUsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkIGFsbCBlZGdlcyBmcm9tIGRhdGFzZXQgdGhhdCBhcmUgbm90IGluIHRoZSBjYWNoZWQgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkTWlzc2luZ0VkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRNaXNzaW5nRWRnZXMoKSB7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG5cbiAgICAgIGlmIChlZGdlc0RhdGEgPT09IHVuZGVmaW5lZCB8fCBlZGdlc0RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBObyBlZGdlcyBEYXRhU2V0IHlldDsgY2FuIGhhcHBlbiBvbiBzdGFydHVwXG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBhZGRJZHMgPSBbXTtcblxuICAgICAgZm9yRWFjaCQyKGVkZ2VzRGF0YSkuY2FsbChlZGdlc0RhdGEsIGZ1bmN0aW9uIChlZGdlRGF0YSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICBpZiAoZWRnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkSWRzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYWRkKGFkZElkcywgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkZ2VzSGFuZGxlcjtcbn0oKTtcblxuLyoqXG4gKiBCYXJuZXMgSHV0IFNvbHZlclxuICovXG5cbnZhciBCYXJuZXNIdXRTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQmFybmVzSHV0U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhcm5lc0h1dFNvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLmJhcm5lc0h1dFRyZWU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX3JuZyA9IEFsZWEoXCJCQVJORVMgSFVUIFNPTFZFUlwiKTsgLy8gZGVidWc6IHNob3cgZ3JpZFxuICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kZWJ1ZyhjdHgsJyNmZjAwMDAnKX0pXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJhcm5lc0h1dFNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnRoZXRhSW52ZXJzZWQgPSAxIC8gdGhpcy5vcHRpb25zLnRoZXRhOyAvLyBpZiAxIHRoZW4gbWluIGRpc3RhbmNlID0gMC41LCBpZiAwLjUgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUgKyAwLjUqbm9kZS5zaGFwZS5yYWRpdXNcblxuICAgICAgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yID0gMSAtIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSBncmF2aXRhdGlvbmFsIG1vZGVsLlxuICAgICAqIFRoZSBCYXJuZXMgSHV0IG1ldGhvZCBpcyB1c2VkIHRvIHNwZWVkIHVwIHRoaXMgTi1ib2R5IHNpbXVsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAhPT0gMCAmJiB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoOyAvLyBjcmVhdGUgdGhlIHRyZWVcblxuICAgICAgICB2YXIgYmFybmVzSHV0VHJlZSA9IHRoaXMuX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcyk7IC8vIGZvciBkZWJ1Z2dpbmdcblxuXG4gICAgICAgIHRoaXMuYmFybmVzSHV0VHJlZSA9IGJhcm5lc0h1dFRyZWU7IC8vIHBsYWNlIHRoZSBub2RlcyBvbmUgYnkgb25lIHJlY3Vyc2l2ZWx5XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgICAvLyBzdGFydGluZyB3aXRoIHJvb3QgaXMgaXJyZWxldmFudCwgaXQgbmV2ZXIgcGFzc2VzIHRoZSBCYXJuZXNIdXRTb2x2ZXIgY29uZGl0aW9uXG4gICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnMoYmFybmVzSHV0VHJlZS5yb290LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Rm9yY2VDb250cmlidXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGb3JjZUNvbnRyaWJ1dGlvbnMocGFyZW50QnJhbmNoLCBub2RlKSB7XG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcsIG5vZGUpO1xuXG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uTkUsIG5vZGUpO1xuXG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU1csIG5vZGUpO1xuXG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU0UsIG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgYmFybmVzSHV0VHJlZS4gSXQgY2hlY2tzIHdoZW4gaXQgY2FuIGFwcHJveGltYXRlIGRpc3RhbnQgbm9kZXMgd2l0aCB0aGVpciBjZW50ZXIgb2YgbWFzcy5cbiAgICAgKiBJZiBhIHJlZ2lvbiBjb250YWlucyBhIHNpbmdsZSBub2RlLCB3ZSBjaGVjayBpZiBpdCBpcyBub3QgaXRzZWxmLCB0aGVuIHdlIGFwcGx5IHRoZSBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEZvcmNlQ29udHJpYnV0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIC8vIHdlIGdldCBubyBmb3JjZSBjb250cmlidXRpb24gZnJvbSBhbiBlbXB0eSByZWdpb25cbiAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA+IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgbm9kZS5cbiAgICAgICAgdmFyIGR4ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54IC0gbm9kZS54O1xuICAgICAgICB2YXIgZHkgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgLSBub2RlLnk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7IC8vIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgLy8gb3JpZ2luYWwgY29uZGl0aW9uIDogcy9kIDwgdGhldGEgPSBwYXNzZWQgID09PSAgZC9zID4gMS90aGV0YSA9IHBhc3NlZFxuICAgICAgICAvLyBjYWxjU2l6ZSA9IDEvcyAtLT4gZCAqIDEvcyA+IDEvdGhldGEgPSBwYXNzZWRcblxuICAgICAgICBpZiAoZGlzdGFuY2UgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUgPiB0aGlzLnRoZXRhSW52ZXJzZWQpIHtcbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEaWQgbm90IHBhc3MgdGhlIGNvbmRpdGlvbiwgZ28gaW50byBjaGlsZHJlbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXJlbnRCcmFuY2ggbXVzdCBoYXZlIG9ubHkgb25lIG5vZGUsIGlmIGl0IHdhcyBlbXB0eSB3ZSB3b3VsZG50IGJlIGhlcmVcbiAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YS5pZCAhPSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG5vdCBzZWxmXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IDAuMTtcbiAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEgJiYgbm9kZS5zaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICB9IC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuXG5cbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICogcGFyZW50QnJhbmNoLm1hc3MgKiBub2RlLm9wdGlvbnMubWFzcyAvIE1hdGgucG93KGRpc3RhbmNlLCAzKTtcbiAgICAgIHZhciBmeCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdmFyIGZ5ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIHRoZSBiYXJuZXNIdXQgdHJlZSByZWN1cnNpdmVseS4gSXQgY3JlYXRlcyB0aGUgcm9vdCwgc3BsaXRzIGl0IGFuZCBzdGFydHMgcGxhY2luZyB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBub2RlSW5kaWNlc1xuICAgICAqIEByZXR1cm5zIHt7cm9vdDoge2NlbnRlck9mTWFzczoge3g6IG51bWJlciwgeTogbnVtYmVyfSwgbWFzczogbnVtYmVyLCByYW5nZToge21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn0sIHNpemU6IG51bWJlciwgY2FsY1NpemU6IG51bWJlciwgY2hpbGRyZW46IHtkYXRhOiBudWxsfSwgbWF4V2lkdGg6IG51bWJlciwgbGV2ZWw6IG51bWJlciwgY2hpbGRyZW5Db3VudDogbnVtYmVyfX19IEJhcm5lc0h1dFRyZWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Zvcm1CYXJuZXNIdXRUcmVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mb3JtQmFybmVzSHV0VHJlZShub2Rlcywgbm9kZUluZGljZXMpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVJbmRpY2VzLmxlbmd0aDtcbiAgICAgIHZhciBtaW5YID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICB2YXIgbWluWSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuICAgICAgdmFyIG1heFggPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueDtcbiAgICAgIHZhciBtYXhZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7IC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIG5vZGVzXG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICB2YXIgeCA9IF9ub2RlLng7XG4gICAgICAgIHZhciB5ID0gX25vZGUueTtcblxuICAgICAgICBpZiAoX25vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgICBtYXhYID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2UgdGhlIHJhbmdlIGEgc3F1YXJlXG5cblxuICAgICAgdmFyIHNpemVEaWZmID0gTWF0aC5hYnMobWF4WCAtIG1pblgpIC0gTWF0aC5hYnMobWF4WSAtIG1pblkpOyAvLyBkaWZmZXJlbmNlIGJldHdlZW4gWCBhbmQgWVxuXG4gICAgICBpZiAoc2l6ZURpZmYgPiAwKSB7XG4gICAgICAgIG1pblkgLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgIG1heFkgKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICB9IC8vIHhTaXplID4geVNpemVcbiAgICAgIGVsc2Uge1xuICAgICAgICBtaW5YICs9IDAuNSAqIHNpemVEaWZmO1xuICAgICAgICBtYXhYIC09IDAuNSAqIHNpemVEaWZmO1xuICAgICAgfSAvLyB4U2l6ZSA8IHlTaXplXG5cblxuICAgICAgdmFyIG1pbmltdW1UcmVlU2l6ZSA9IDFlLTU7XG4gICAgICB2YXIgcm9vdFNpemUgPSBNYXRoLm1heChtaW5pbXVtVHJlZVNpemUsIE1hdGguYWJzKG1heFggLSBtaW5YKSk7XG4gICAgICB2YXIgaGFsZlJvb3RTaXplID0gMC41ICogcm9vdFNpemU7XG4gICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIChtaW5YICsgbWF4WCksXG4gICAgICAgICAgY2VudGVyWSA9IDAuNSAqIChtaW5ZICsgbWF4WSk7IC8vIGNvbnN0cnVjdCB0aGUgYmFybmVzSHV0VHJlZVxuXG4gICAgICB2YXIgYmFybmVzSHV0VHJlZSA9IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIGNlbnRlck9mTWFzczoge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hc3M6IDAsXG4gICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIG1pblg6IGNlbnRlclggLSBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtYXhYOiBjZW50ZXJYICsgaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWluWTogY2VudGVyWSAtIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1heFk6IGNlbnRlclkgKyBoYWxmUm9vdFNpemVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpemU6IHJvb3RTaXplLFxuICAgICAgICAgIGNhbGNTaXplOiAxIC8gcm9vdFNpemUsXG4gICAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1heFdpZHRoOiAwLFxuICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgIGNoaWxkcmVuQ291bnQ6IDRcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc3BsaXRCcmFuY2goYmFybmVzSHV0VHJlZS5yb290KTsgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZUNvdW50OyBfaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tfaV1dO1xuXG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShiYXJuZXNIdXRUcmVlLnJvb3QsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2UgZ2xvYmFsXG5cblxuICAgICAgcmV0dXJuIGJhcm5lc0h1dFRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgdXBkYXRlcyB0aGUgbWFzcyBvZiBhIGJyYW5jaC4gdGhpcyBpcyBpbmNyZWFzZWQgYnkgYWRkaW5nIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUJyYW5jaE1hc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJyYW5jaE1hc3MocGFyZW50QnJhbmNoLCBub2RlKSB7XG4gICAgICB2YXIgY2VudGVyT2ZNYXNzID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcztcbiAgICAgIHZhciB0b3RhbE1hc3MgPSBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgdmFyIHRvdGFsTWFzc0ludiA9IDEgLyB0b3RhbE1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueCA9IGNlbnRlck9mTWFzcy54ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnggKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy54ICo9IHRvdGFsTWFzc0ludjtcbiAgICAgIGNlbnRlck9mTWFzcy55ID0gY2VudGVyT2ZNYXNzLnkgKiBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUueSAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgY2VudGVyT2ZNYXNzLnkgKj0gdG90YWxNYXNzSW52O1xuICAgICAgcGFyZW50QnJhbmNoLm1hc3MgPSB0b3RhbE1hc3M7XG4gICAgICB2YXIgYmlnZ2VzdFNpemUgPSBNYXRoLm1heChNYXRoLm1heChub2RlLmhlaWdodCwgbm9kZS5yYWRpdXMpLCBub2RlLndpZHRoKTtcbiAgICAgIHBhcmVudEJyYW5jaC5tYXhXaWR0aCA9IHBhcmVudEJyYW5jaC5tYXhXaWR0aCA8IGJpZ2dlc3RTaXplID8gYmlnZ2VzdFNpemUgOiBwYXJlbnRCcmFuY2gubWF4V2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpbiB3aGljaCBicmFuY2ggdGhlIG5vZGUgd2lsbCBiZSBwbGFjZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwTWFzc1VwZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGxhY2VJblRyZWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaCwgbm9kZSwgc2tpcE1hc3NVcGRhdGUpIHtcbiAgICAgIGlmIChza2lwTWFzc1VwZGF0ZSAhPSB0cnVlIHx8IHNraXBNYXNzVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBtYXNzIG9mIHRoZSBicmFuY2guXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJyYW5jaE1hc3MocGFyZW50QnJhbmNoLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLnJhbmdlO1xuICAgICAgdmFyIHJlZ2lvbjtcblxuICAgICAgaWYgKHJhbmdlLm1heFggPiBub2RlLngpIHtcbiAgICAgICAgLy8gaW4gTlcgb3IgU1dcbiAgICAgICAgaWYgKHJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICByZWdpb24gPSBcIk5XXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJTV1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbiBORSBvciBTRVxuICAgICAgICBpZiAocmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiTkVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBcIlNFXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIHJlZ2lvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFjdHVhbGx5IHBsYWNlIHRoZSBub2RlIGluIGEgcmVnaW9uIChvciBicmFuY2gpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsnTlcnfCAnTkUnIHwgJ1NXJyB8ICdTRSd9IHJlZ2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGxhY2VJblJlZ2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIHJlZ2lvbikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl07XG5cbiAgICAgIHN3aXRjaCAoY2hpbGRyZW4uY2hpbGRyZW5Db3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gcGxhY2Ugbm9kZSBoZXJlXG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW4uZGF0YSA9IG5vZGU7XG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW5Db3VudCA9IDE7XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVCcmFuY2hNYXNzKGNoaWxkcmVuLCBub2RlKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyBjb252ZXJ0IGludG8gY2hpbGRyZW5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIG5vZGVzIGV4YWN0bHkgb3ZlcmxhcHBpbmcgKG9uIGluaXQsIG9uIG9wZW5pbmcgb2YgY2x1c3RlciBldGMuKVxuICAgICAgICAgIC8vIHdlIG1vdmUgb25lIG5vZGUgYSBsaXR0bGUgYml0IGFuZCB3ZSBkbyBub3QgcHV0IGl0IGluIHRoZSB0cmVlLlxuICAgICAgICAgIGlmIChjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnggPT09IG5vZGUueCAmJiBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnkgPT09IG5vZGUueSkge1xuICAgICAgICAgICAgbm9kZS54ICs9IHRoaXMuX3JuZygpO1xuICAgICAgICAgICAgbm9kZS55ICs9IHRoaXMuX3JuZygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zcGxpdEJyYW5jaChjaGlsZHJlbik7XG5cbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGNoaWxkcmVuLCBub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgLy8gcGxhY2UgaW4gYnJhbmNoXG4gICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoY2hpbGRyZW4sIG5vZGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gc3BsaXRzIGEgYnJhbmNoIGludG8gNCBzdWIgYnJhbmNoZXMuIElmIHRoZSBicmFuY2ggY29udGFpbmVkIGEgbm9kZSwgd2UgcGxhY2UgaXQgaW4gdGhlIHN1YmJyYW5jaFxuICAgICAqIGFmdGVyIHRoZSBzcGxpdCBpcyBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NwbGl0QnJhbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEJyYW5jaChwYXJlbnRCcmFuY2gpIHtcbiAgICAgIC8vIGlmIHRoZSBicmFuY2ggaXMgc2hhZGVkIHdpdGggYSBub2RlLCByZXBsYWNlIHRoZSBub2RlIGluIHRoZSBuZXcgc3Vic2V0LlxuICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSBudWxsO1xuXG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDEpIHtcbiAgICAgICAgY29udGFpbmVkTm9kZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhO1xuICAgICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IDA7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCA9IDA7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID0gNDtcbiAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhID0gbnVsbDtcblxuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJOV1wiKTtcblxuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJORVwiKTtcblxuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTV1wiKTtcblxuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTRVwiKTtcblxuICAgICAgaWYgKGNvbnRhaW5lZE5vZGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIGNvbnRhaW5lZE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN1YmRpdmlkZXMgdGhlIHJlZ2lvbiBpbnRvIGZvdXIgbmV3IHNlZ21lbnRzLlxuICAgICAqIFNwZWNpZmljYWxseSwgdGhpcyBpbnNlcnRzIGEgc2luZ2xlIG5ldyBzZWdtZW50LlxuICAgICAqIEl0IGZpbGxzIHRoZSBjaGlsZHJlbiBzZWN0aW9uIG9mIHRoZSBwYXJlbnRCcmFuY2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0geydOVyd8ICdORScgfCAnU1cnIHwgJ1NFJ30gcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbnNlcnRSZWdpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIHJlZ2lvbikge1xuICAgICAgdmFyIG1pblgsIG1heFgsIG1pblksIG1heFk7XG4gICAgICB2YXIgY2hpbGRTaXplID0gMC41ICogcGFyZW50QnJhbmNoLnNpemU7XG5cbiAgICAgIHN3aXRjaCAocmVnaW9uKSB7XG4gICAgICAgIGNhc2UgXCJOV1wiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTkVcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhYO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlNXXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJTRVwiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFg7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0gPSB7XG4gICAgICAgIGNlbnRlck9mTWFzczoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBtYXNzOiAwLFxuICAgICAgICByYW5nZToge1xuICAgICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICAgIG1heFk6IG1heFlcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogMC41ICogcGFyZW50QnJhbmNoLnNpemUsXG4gICAgICAgIGNhbGNTaXplOiAyICogcGFyZW50QnJhbmNoLmNhbGNTaXplLFxuICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgIGxldmVsOiBwYXJlbnRCcmFuY2gubGV2ZWwgKyAxLFxuICAgICAgICBjaGlsZHJlbkNvdW50OiAwXG4gICAgICB9O1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIERFQlVHR0lORyBCRUxPVyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3NlZCwgaXQgZHJhd3MgdGhlIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZWJ1Z1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVidWcoY3R4LCBjb2xvcikge1xuICAgICAgaWYgKHRoaXMuYmFybmVzSHV0VHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2godGhpcy5iYXJuZXNIdXRUcmVlLnJvb3QsIGN0eCwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIEl0IGRyYXdzIHRoZSBicmFuY2hlcyByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBicmFuY2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3QnJhbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QnJhbmNoKGJyYW5jaCwgY3R4LCBjb2xvcikge1xuICAgICAgaWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sb3IgPSBcIiNGRjAwMDBcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSA0KSB7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5XLCBjdHgpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5FLCBjdHgpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNFLCBjdHgpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNXLCBjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIC8qXG4gICAgICAgaWYgKGJyYW5jaC5tYXNzID4gMCkge1xuICAgICAgIGN0eC5jaXJjbGUoYnJhbmNoLmNlbnRlck9mTWFzcy54LCBicmFuY2guY2VudGVyT2ZNYXNzLnksIDMqYnJhbmNoLm1hc3MpO1xuICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICB9XG4gICAgICAgKi9cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFybmVzSHV0U29sdmVyO1xufSgpO1xuXG4vKipcbiAqIFJlcHVsc2lvbiBTb2x2ZXJcbiAqL1xuXG52YXIgUmVwdWxzaW9uU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgdGhpcy5fcm5nID0gQWxlYShcIlJFUFVMU0lPTiBTT0xWRVJcIik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTI7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlczsgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG5cbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlOyAvLyBhcHByb3hpbWF0aW9uIGNvbnN0YW50c1xuXG4gICAgICB2YXIgYSA9IC0yIC8gMyAvIG5vZGVEaXN0YW5jZTtcbiAgICAgIHZhciBiID0gNCAvIDM7IC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbm9kZUluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTtcbiAgICAgICAgICBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpOyAvLyBzYW1lIGNvbmRpdGlvbiBhcyBCYXJuZXNIdXRTb2x2ZXIsIG1ha2luZyBzdXJlIG5vZGVzIGFyZSBuZXZlciAxMDAlIG92ZXJsYXBwaW5nLlxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIHRoaXMuX3JuZygpO1xuICAgICAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAyICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjUgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IGEgKiBkaXN0YW5jZSArIGI7IC8vIGxpbmVhciBhcHByb3ggb2YgIDEgLyAoMSArIE1hdGguZXhwKChkaXN0YW5jZSAvIG5vZGVEaXN0YW5jZSAtIDEpICogc3RlZXBuZXNzKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZnkgPSBkeSAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS54IC09IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS55IC09IGZ5O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS54ICs9IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS55ICs9IGZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXB1bHNpb25Tb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFJlcHVsc2lvbiBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXAgfHwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzOyAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcblxuICAgICAgdmFyIG5vZGVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ub2RlRGlzdGFuY2U7IC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dOyAvLyBub2RlcyBvbmx5IGFmZmVjdCBub2RlcyBvbiB0aGVpciBsZXZlbFxuXG4gICAgICAgICAgaWYgKG5vZGUxLmxldmVsID09PSBub2RlMi5sZXZlbCkge1xuICAgICAgICAgICAgdmFyIHRoZXNlTm9kZXNEaXN0YW5jZSA9IG5vZGVEaXN0YW5jZSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqICgobm9kZTEuc2hhcGUucmFkaXVzIHx8IDApIC8gMiArIChub2RlMi5zaGFwZS5yYWRpdXMgfHwgMCkgLyAyKTtcbiAgICAgICAgICAgIHZhciBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgICAgdmFyIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgdmFyIHN0ZWVwbmVzcyA9IDAuMDU7XG4gICAgICAgICAgICB2YXIgcmVwdWxzaW5nRm9yY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IHRoZXNlTm9kZXNEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IC1NYXRoLnBvdyhzdGVlcG5lc3MgKiBkaXN0YW5jZSwgMikgKyBNYXRoLnBvdyhzdGVlcG5lc3MgKiB0aGVzZU5vZGVzRGlzdGFuY2UsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAwO1xuICAgICAgICAgICAgfSAvLyBub3JtYWxpemUgZm9yY2Ugd2l0aFxuXG5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSAhPT0gMCkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICB2YXIgZnkgPSBkeSAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS54IC09IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS55IC09IGZ5O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS54ICs9IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS55ICs9IGZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogU3ByaW5nIFNvbHZlclxuICovXG52YXIgU3ByaW5nU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpbmdTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTcHJpbmdTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGVkZ2VMZW5ndGgsIGVkZ2U7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBub2RlMSwgbm9kZTIsIG5vZGUzOyAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIGVkZ2UudG9JZCAhPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAvLyBvbmx5IGNhbGN1bGF0ZSBmb3JjZXMgaWYgbm9kZXMgYXJlIGluIHRoZSBzYW1lIHNlY3RvclxuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVkZ2UuZWRnZVR5cGUudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICBub2RlMSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIG5vZGUyID0gZWRnZS5lZGdlVHlwZS52aWE7XG4gICAgICAgICAgICAgIG5vZGUzID0gZWRnZS5mcm9tO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUxLCBub2RlMiwgMC41ICogZWRnZUxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTIsIG5vZGUzLCAwLjUgKiBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSAqIDEuNSBpcyBoZXJlIHNvIHRoZSBlZGdlIGxvb2tzIGFzIGxhcmdlIGFzIGEgc21vb3RoIGVkZ2UuIEl0IGRvZXMgbm90IGluaXRpYWxseSBiZWNhdXNlIHRoZSBzbW9vdGggZWRnZXMgdXNlXG4gICAgICAgICAgICAgIC8vIHRoZSBzdXBwb3J0IG5vZGVzIHdoaWNoIGV4ZXJ0IGEgcmVwdWxzaXZlIGZvcmNlIG9uIHRoZSB0byBhbmQgZnJvbSBub2RlcywgbWFraW5nIHRoZSBlZGdlIGFwcGVhciBsYXJnZXIuXG4gICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoICogMS41IDogZWRnZS5vcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShlZGdlLmZyb20sIGVkZ2UudG8sIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjb2RlIGFjdHVhbGx5IHBlcmZvcm1pbmcgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgZnVuY3Rpb24gYWJvdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlTGVuZ3RoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVTcHJpbmdGb3JjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCBlZGdlTGVuZ3RoKSB7XG4gICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgIHZhciBkeSA9IG5vZGUxLnkgLSBub2RlMi55O1xuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSwgMC4wMSk7IC8vIHRoZSAxL2Rpc3RhbmNlIGlzIHNvIHRoZSBmeCBhbmQgZnkgY2FuIGJlIGNhbGN1bGF0ZWQgd2l0aG91dCBzaW5lIG9yIGNvc2luZS5cblxuICAgICAgdmFyIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcbiAgICAgIHZhciBmeCA9IGR4ICogc3ByaW5nRm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIHNwcmluZ0ZvcmNlOyAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb25lIG5vZGUgaXMgbm90IHBhcnQgb2YgdGhlIHBoeXNjaXNcblxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS54ICs9IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueSArPSBmeTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS54IC09IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueSAtPSBmeTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ByaW5nU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIEhpZXJhcmNoaWNhbCBTcHJpbmcgU29sdmVyXG4gKi9cbnZhciBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgIHZhciBkeCwgZHksIGZ4LCBmeSwgc3ByaW5nRm9yY2UsIGRpc3RhbmNlO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGZhY3RvciA9IDAuNTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7IC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnggPSAwO1xuICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeSA9IDA7XG4gICAgICB9IC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgZHggPSBlZGdlLmZyb20ueCAtIGVkZ2UudG8ueDtcbiAgICAgICAgICBkeSA9IGVkZ2UuZnJvbS55IC0gZWRnZS50by55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09PSAwID8gMC4wMSA6IGRpc3RhbmNlOyAvLyB0aGUgMS9kaXN0YW5jZSBpcyBzbyB0aGUgZnggYW5kIGZ5IGNhbiBiZSBjYWxjdWxhdGVkIHdpdGhvdXQgc2luZSBvciBjb3NpbmUuXG5cbiAgICAgICAgICBzcHJpbmdGb3JjZSA9IHRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCAqIChlZGdlTGVuZ3RoIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG4gICAgICAgICAgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgICAgIGZ5ID0gZHkgKiBzcHJpbmdGb3JjZTtcblxuICAgICAgICAgIGlmIChlZGdlLnRvLmxldmVsICE9IGVkZ2UuZnJvbS5sZXZlbCkge1xuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0uc3ByaW5nRnggLT0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z5IC09IGZ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnggKz0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnkgKz0gZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnggLT0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnkgLT0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS54ICs9IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnkgKz0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIG5vcm1hbGl6ZSBzcHJpbmcgZm9yY2VzXG5cblxuICAgICAgc3ByaW5nRm9yY2UgPSAxO1xuICAgICAgdmFyIHNwcmluZ0Z4LCBzcHJpbmdGeTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IG5vZGVJbmRpY2VzW19pMl07XG4gICAgICAgIHNwcmluZ0Z4ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z4KSk7XG4gICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkXS54ICs9IHNwcmluZ0Z4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZF0ueSArPSBzcHJpbmdGeTtcbiAgICAgIH0gLy8gcmV0YWluIGVuZXJneSBiYWxhbmNlXG5cblxuICAgICAgdmFyIHRvdGFsRnggPSAwO1xuICAgICAgdmFyIHRvdGFsRnkgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkMiA9IG5vZGVJbmRpY2VzW19pM107XG4gICAgICAgIHRvdGFsRnggKz0gZm9yY2VzW19ub2RlSWQyXS54O1xuICAgICAgICB0b3RhbEZ5ICs9IGZvcmNlc1tfbm9kZUlkMl0ueTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvcnJlY3Rpb25GeCA9IHRvdGFsRnggLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgY29ycmVjdGlvbkZ5ID0gdG90YWxGeSAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnggLT0gY29ycmVjdGlvbkZ4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnkgLT0gY29ycmVjdGlvbkZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogQ2VudHJhbCBHcmF2aXR5IFNvbHZlclxuICovXG52YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgZm9yY2VzIGZvciBlYWNoIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIG5vZGU7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICBkeCA9IC1ub2RlLng7XG4gICAgICAgIGR5ID0gLW5vZGUueTtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICAgKiBAcGFyYW0ge29iamVjdDxOb2RlLmlkLCB2aXMuTm9kZT59IGZvcmNlc1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gZGlzdGFuY2UgPT09IDAgPyAwIDogdGhpcy5vcHRpb25zLmNlbnRyYWxHcmF2aXR5IC8gZGlzdGFuY2U7XG4gICAgICBmb3JjZXNbbm9kZS5pZF0ueCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQGF1Z21lbnRzIEJhcm5lc0h1dFNvbHZlclxuICovXG5cbnZhciBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFybmVzSHV0U29sdmVyKSB7XG4gIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBfQmFybmVzSHV0U29sdmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDMoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICBfdGhpcy5fcm5nID0gQWxlYShcIkZPUkNFIEFUTEFTIDIgQkFTRUQgUkVQVUxTSU9OIFNPTFZFUlwiKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCkge1xuICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGRpc3RhbmNlID0gMC4xICogdGhpcy5fcm5nKCk7XG4gICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxICYmIG5vZGUuc2hhcGUucmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVncmVlID0gbm9kZS5lZGdlcy5sZW5ndGggKyAxOyAvLyB0aGUgZGl2aWRpbmcgYnkgdGhlIGRpc3RhbmNlIGN1YmVkIGluc3RlYWQgb2Ygc3F1YXJlZCBhbGxvd3MgdXMgdG8gZ2V0IHRoZSBmeCBhbmQgZnkgY29tcG9uZW50cyB3aXRob3V0IHNpbmVzIGFuZCBjb3NpbmVzXG4gICAgICAvLyBpdCBpcyBzaG9ydGhhbmQgZm9yIGdyYXZpdHlmb3JjZSB3aXRoIGRpc3RhbmNlIHNxdWFyZWQgYW5kIGZ4ID0gZHgvZGlzdGFuY2UgKiBncmF2aXR5Rm9yY2VcblxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzICogZGVncmVlIC8gTWF0aC5wb3coZGlzdGFuY2UsIDIpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyO1xufShCYXJuZXNIdXRTb2x2ZXIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkMihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEBhdWdtZW50cyBDZW50cmFsR3Jhdml0eVNvbHZlclxuICovXG5cbnZhciBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DZW50cmFsR3Jhdml0eVNvbHZlcikge1xuICBfaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMihGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICogQHBhcmFtIHtvYmplY3Q8Tm9kZS5pZCwgTm9kZT59IGZvcmNlc1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgKiBkZWdyZWUgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyO1xufShDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbi8qKlxuICogVGhlIHBoeXNpY3MgZW5naW5lXG4gKi9cblxudmFyIFBoeXNpY3NFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIFBoeXNpY3NFbmdpbmUoYm9keSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaHlzaWNzRW5naW5lKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHtcbiAgICAgIHBoeXNpY3NOb2RlSW5kaWNlczogW10sXG4gICAgICBwaHlzaWNzRWRnZUluZGljZXM6IFtdLFxuICAgICAgZm9yY2VzOiB7fSxcbiAgICAgIHZlbG9jaXRpZXM6IHt9XG4gICAgfTtcbiAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCA9IDEwMDAgLyA2MDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5wcmV2aW91c1N0YXRlcyA9IHt9O1xuICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcbiAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDsgLy8gcGFyYW1ldGVycyBmb3IgdGhlIGFkYXB0aXZlIHRpbWVzdGVwXG5cbiAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgPSAwO1xuICAgIHRoaXMuYWRhcHRpdmVJbnRlcnZhbCA9IDM7XG4gICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTsgLy8gd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGUgc3RhYmlsaXplXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGJhcm5lc0h1dDoge1xuICAgICAgICB0aGV0YTogMC41LFxuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC0yMDAwLFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4zLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDk1LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNCxcbiAgICAgICAgZGFtcGluZzogMC4wOSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgICB0aGV0YTogMC41LFxuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC01MCxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMDEsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA4LFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMC40LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICByZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMixcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAyMDAsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA1LFxuICAgICAgICBub2RlRGlzdGFuY2U6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMC4wOSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wMSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiAxMjAsXG4gICAgICAgIGRhbXBpbmc6IDAuMDlcbiAgICAgIH0sXG4gICAgICBtYXhWZWxvY2l0eTogNTAsXG4gICAgICBtaW5WZWxvY2l0eTogMC43NSxcbiAgICAgIC8vIHB4L3NcbiAgICAgIHNvbHZlcjogXCJiYXJuZXNIdXRcIixcbiAgICAgIHN0YWJpbGl6YXRpb246IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMCxcbiAgICAgICAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgICB1cGRhdGVJbnRlcnZhbDogNTAsXG4gICAgICAgIG9ubHlEeW5hbWljRWRnZXM6IGZhbHNlLFxuICAgICAgICBmaXQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB0aW1lc3RlcDogMC41LFxuICAgICAgYWRhcHRpdmVUaW1lc3RlcDogdHJ1ZSxcbiAgICAgIHdpbmQ6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy50aW1lc3RlcCA9IDAuNTtcbiAgICB0aGlzLmxheW91dEZhaWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQaHlzaWNzRW5naW5lLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmluaXRQaHlzaWNzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2xheW91dEZhaWxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmxheW91dEZhaWxlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVzZXRQaHlzaWNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcblxuICAgICAgICBfdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRpc2FibGVQaHlzaWNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlc3RvcmVQaHlzaWNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2V0T3B0aW9ucyhfdGhpcy5vcHRpb25zKTtcblxuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0YXJ0U2ltdWxhdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwic3RvcFNpbXVsYXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbihmYWxzZSk7XG5cbiAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vZGVzIGFuZC9vciBlZGdlcyBoYXZlIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZCwgdXBkYXRlIHNob3J0Y3V0IGxpc3RzLlxuICAgICAgICBfdGhpcy51cGRhdGVQaHlzaWNzRGF0YSgpO1xuICAgICAgfSk7IC8vIGRlYnVnOiBzaG93IGZvcmNlc1xuICAgICAgLy8gdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhZnRlckRyYXdpbmdcIiwgKGN0eCkgPT4ge3RoaXMuX2RyYXdGb3JjZXMoY3R4KTt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBwaHlzaWNzIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoW1wic3RhYmlsaXphdGlvblwiXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCBcInN0YWJpbGl6YXRpb25cIik7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdpbmQgPSB0aGlzLm9wdGlvbnMud2luZDtcblxuICAgICAgICAgIGlmICh3aW5kKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmQueCAhPT0gXCJudW1iZXJcIiB8fCBpc05hbih3aW5kLngpKSB7XG4gICAgICAgICAgICAgIHdpbmQueCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZC55ICE9PSBcIm51bWJlclwiIHx8IGlzTmFuKHdpbmQueSkpIHtcbiAgICAgICAgICAgICAgd2luZC55ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHNldCB0aGUgdGltZXN0ZXBcblxuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uZmlndXJlIHRoZSBlbmdpbmUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgb3B0aW9ucztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09IFwiZm9yY2VBdGxhczJCYXNlZFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZm9yY2VBdGxhczJCYXNlZDtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gXCJyZXB1bHNpb25cIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLnJlcHVsc2lvbjtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBSZXB1bHNpb25Tb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09IFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWxSZXB1bHNpb247XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmFybmVzSHV0XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYmFybmVzSHV0O1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEJhcm5lc0h1dFNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIHRoZSBlbmdpbmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRQaHlzaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQaHlzaWNzKCkge1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnN0YWJpbGl6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIiwge30sIHRoaXMubGF5b3V0RmFpbGVkKTsgLy8gaWYgdGhlIGxheW91dCBmYWlsZWQsIHdlIHVzZSB0aGUgYXBwcm94aW1hdGlvbiBmb3IgdGhlIHpvb21cblxuICAgICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgc2ltdWxhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRTaW11bGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2ltdWxhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlOyAvLyB3aGVuIHZpc2libGUsIGFkYXB0aXZpdHkgaXMgZGlzYWJsZWQuXG5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7IC8vIHRoaXMgc2V0cyB0aGUgd2lkdGggb2YgYWxsIG5vZGVzIGluaXRpYWxseSB3aGljaCBjb3VsZCBiZSByZXF1aXJlZCBmb3IgdGhlIGF2b2lkT3ZlcmxhcFxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG5cbiAgICAgICAgaWYgKHRoaXMudmlld0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IGJpbmQkNihfY29udGV4dCA9IHRoaXMuc2ltdWxhdGlvblN0ZXApLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHNpbXVsYXRpb24sIGZvcmNlIHN0YWJpbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wU2ltdWxhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wU2ltdWxhdGlvbigpIHtcbiAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdGhpcy5zdGFiaWxpemVkID0gdHJ1ZTtcblxuICAgICAgaWYgKGVtaXQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3RnVuY3Rpb24gaW5zZXJ0cyB0aGlzIHN0ZXAgaW50byBlYWNoIHJlbmRlciBsb29wLiBJdCBjYWxscyB0aGUgcGh5c2ljcyB0aWNrIGFuZCBoYW5kbGVzIHRoZSBjbGVhbnVwIGF0IHN0YWJpbGl6ZWQuXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNpbXVsYXRpb25TdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbXVsYXRpb25TdGVwKCkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHBoeXNpY3MgaGF2ZSBzZXR0bGVkXG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93JDEoKTtcblxuICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgdmFyIHBoeXNpY3NUaW1lID0gbm93JDEoKSAtIHN0YXJ0VGltZTsgLy8gcnVuIGRvdWJsZSBzcGVlZCBpZiBpdCBpcyBhIGxpdHRsZSBncmFwaFxuXG4gICAgICBpZiAoKHBoeXNpY3NUaW1lIDwgMC40ICogdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwgfHwgdGhpcy5ydW5Eb3VibGVTcGVlZCA9PT0gdHJ1ZSkgJiYgdGhpcy5zdGFiaWxpemVkID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7IC8vIHRoaXMgbWFrZXMgc3VyZSB0aGVyZSBpcyBubyBqaXR0ZXIuIFRoZSBkZWNpc2lvbiBpcyB0YWtlbiBvbmNlIHRvIHJ1biBpdCBhdCBkb3VibGUgc3BlZWQuXG5cbiAgICAgICAgdGhpcy5ydW5Eb3VibGVTcGVlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmlnZ2VyIHRoZSBzdGFiaWxpemVkIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRPZkl0ZXJhdGlvbnM9dGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9uc11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRTdGFiaWxpemVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3RhYmlsaXplZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYW1vdW50T2ZJdGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zO1xuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA+IDEgfHwgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YWJpbGl6ZWRcIiwge1xuICAgICAgICAgICAgaXRlcmF0aW9uczogYW1vdW50T2ZJdGVyYXRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczIuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICBfdGhpczIuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgZm9yIG9uZSBwaHlzaWNzIGl0ZXJhdGlvbiBhbmQgbW92ZSB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGh5c2ljc1N0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGh5c2ljc1N0ZXAoKSB7XG4gICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIuc29sdmUoKTtcbiAgICAgIHRoaXMubm9kZXNTb2x2ZXIuc29sdmUoKTtcbiAgICAgIHRoaXMuZWRnZXNTb2x2ZXIuc29sdmUoKTtcbiAgICAgIHRoaXMubW92ZU5vZGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgZHluYW1pYyBhZGp1c3RtZW50cyB0byB0aGUgdGltZXN0ZXAsIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHBoeXNpY3NUaWNrKCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRqdXN0VGltZVN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0VGltZVN0ZXAoKSB7XG4gICAgICB2YXIgZmFjdG9yID0gMS4yOyAvLyBGYWN0b3IgZm9yIGluY3JlYXNpbmcgdGhlIHRpbWVzdGVwIG9uIHN1Y2Nlc3MuXG4gICAgICAvLyB3ZSBjb21wYXJlIHRoZSB0d28gc3RlcHMuIGlmIGl0IGlzIGFjY2VwdGFibGUgd2UgZG91YmxlIHRoZSBzdGVwLlxuXG4gICAgICBpZiAodGhpcy5fZXZhbHVhdGVTdGVwUXVhbGl0eSgpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudGltZXN0ZXAgPSBmYWN0b3IgKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm90LCB3ZSBkZWNyZWFzZSB0aGUgc3RlcCB0byBhIG1pbmltdW0gb2YgdGhlIG9wdGlvbnMgdGltZXN0ZXAuXG4gICAgICAgIC8vIGlmIHRoZSBkZWNyZWFzZWQgdGltZXN0ZXAgaXMgc21hbGxlciB0aGFuIHRoZSBvcHRpb25zIHN0ZXAsIHdlIGRvIG5vdCByZXNldCB0aGUgY291bnRlclxuICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCB0aGUgb3B0aW9ucyB0aW1lc3RlcCBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAgICBpZiAodGhpcy50aW1lc3RlcCAvIGZhY3RvciA8IHRoaXMub3B0aW9ucy50aW1lc3RlcCkge1xuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHRpbWVzdGVwIHdhcyBsYXJnZXIgdGhhbiAyIHRpbWVzIHRoZSBvcHRpb24gb25lIHdlIGNoZWNrIHRoZSBhZGFwdGl2aXR5IGFnYWluIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgbGFyZ2UgaW5zdGFiaWxpdGllcyBkbyBub3QgZm9ybS5cbiAgICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IC0xOyAvLyBjaGVjayBhZ2FpbiBuZXh0IGl0ZXJhdGlvblxuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy50aW1lc3RlcCwgdGhpcy50aW1lc3RlcCAvIGZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGUgc2ltdWxhdGlvbiBzdGVwIChvciAndGljaycpIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwaHlzaWNzVGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzVGljaygpIHtcbiAgICAgIHRoaXMuX3N0YXJ0U3RhYmlsaXppbmcoKTsgLy8gdGhpcyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm8gc3RhcnQgZXZlbnQgd2hlbiB0aGUgbmV0d29yayBpcyBhbHJlYWR5IHN0YWJsZS5cblxuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSByZXR1cm47IC8vIGFkYXB0aXZpdHkgbWVhbnMgdGhlIHRpbWVzdGVwIGFkYXB0cyB0byB0aGUgc2l0dWF0aW9uLCBvbmx5IGFwcGxpY2FibGUgZm9yIHN0YWJpbGl6YXRpb25cblxuICAgICAgaWYgKHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9PT0gdHJ1ZSAmJiB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHRpbWVzdGVwIHJlbWFpbnMgc3RhYmxlIGZvciBcImludGVydmFsXCIgaXRlcmF0aW9ucy5cbiAgICAgICAgdmFyIGRvQWRhcHRpdmUgPSB0aGlzLmFkYXB0aXZlQ291bnRlciAlIHRoaXMuYWRhcHRpdmVJbnRlcnZhbCA9PT0gMDtcblxuICAgICAgICBpZiAoZG9BZGFwdGl2ZSkge1xuICAgICAgICAgIC8vIGZpcnN0IHRoZSBiaWcgc3RlcCBhbmQgcmV2ZXJ0LlxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSAyICogdGhpcy50aW1lc3RlcDtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICAgICAgdGhpcy5yZXZlcnQoKTsgLy8gc2F2ZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZVxuICAgICAgICAgIC8vIG5vdyB0aGUgbm9ybWFsIHN0ZXAuIFNpbmNlIHRoaXMgaXMgdGhlIGxhc3Qgc3RlcCwgaXQgaXMgdGhlIG1vcmUgc3RhYmxlIG9uZSBhbmQgd2Ugd2lsbCB0YWtlIHRoaXMuXG5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMC41ICogdGhpcy50aW1lc3RlcDsgLy8gc2luY2UgaXQncyBoYWxmIHRoZSBzdGVwLCB3ZSBkbyBpdCB0d2ljZS5cblxuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICAgICAgdGhpcy5hZGp1c3RUaW1lU3RlcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTsgLy8gbm9ybWFsIHN0ZXAsIGtlZXBpbmcgdGltZXN0ZXAgY29uc3RhbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYXNlIGZvciB0aGUgc3RhdGljIHRpbWVzdGVwLCB3ZSByZXNldCBpdCB0byB0aGUgb25lIGluIG9wdGlvbnMgYW5kIHRha2UgYSBub3JtYWwgc3RlcC5cbiAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB0aGlzLnJldmVydCgpO1xuICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucysrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb2RlcyBhbmQgZWRnZXMgY2FuIGhhdmUgdGhlIHBoeXNpY3MgdG9nZ2xlcyBvbiBvciBvZmYuIEEgY29sbGVjdGlvbiBvZiBpbmRpY2VzIGlzIGNyZWF0ZWQgaGVyZSBzbyB3ZSBjYW4gc2tpcCB0aGUgY2hlY2sgYWxsIHRoZSB0aW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBoeXNpY3NEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBoeXNpY3NEYXRhKCkge1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXMgPSB7fTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzID0gW107XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcyA9IFtdO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzOyAvLyBnZXQgbm9kZSBpbmRpY2VzIGZvciBwaHlzaWNzXG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBnZXQgZWRnZSBpbmRpY2VzIGZvciBwaHlzaWNzXG5cblxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICBpZiAoZWRnZXNbZWRnZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzLnB1c2goZWRnZXNbZWRnZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGdldCB0aGUgdmVsb2NpdHkgYW5kIHRoZSBmb3JjZXMgdmVjdG9yXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tfbm9kZUlkXSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTsgLy8gZm9yY2VzIGNhbiBiZSByZXNldCBiZWNhdXNlIHRoZXkgYXJlIHJlY2FsY3VsYXRlZC4gVmVsb2NpdGllcyBoYXZlIHRvIHBlcnNpc3QuXG5cbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IC8vIGNsZWFuIGRlbGV0ZWQgbm9kZXMgZnJvbSB0aGUgdmVsb2NpdHkgdmVjdG9yXG5cblxuICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzKSB7XG4gICAgICAgIGlmIChub2Rlc1tfbm9kZUlkMl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgc2ltdWxhdGlvbiBvbmUgc3RlcC4gVGhpcyBpcyBkb25lIHNvIGFmdGVyIHN0YWJpbGl6YXRpb24sIGV2ZXJ5IG5ldyBzdGFydCBvZiB0aGUgc2ltdWxhdGlvbiB3aWxsIGFsc28gc2F5IHN0YWJpbGl6ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KCkge1xuICAgICAgdmFyIG5vZGVJZHMgPSBrZXlzJDQodGhpcy5wcmV2aW91c1N0YXRlcyk7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciB2ZWxvY2l0aWVzID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzO1xuICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJZHNbaV07XG5cbiAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZVtub2RlSWRdID0ge1xuICAgICAgICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB4OiBub2Rlc1tub2RlSWRdLngsXG4gICAgICAgICAgICAgICAgeTogbm9kZXNbbm9kZUlkXS55XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eDtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS55ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ5O1xuICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLng7XG4gICAgICAgICAgICBub2Rlc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbXBhcmVzIHRoZSByZWZlcmVuY2Ugc3RhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbHVhdGVTdGVwUXVhbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbHVhdGVTdGVwUXVhbGl0eSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRwb3M7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy5yZWZlcmVuY2VTdGF0ZTtcbiAgICAgIHZhciBwb3NUaHJlc2hvbGQgPSAwLjM7XG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnJlZmVyZW5jZVN0YXRlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yZWZlcmVuY2VTdGF0ZSwgbm9kZUlkKSAmJiBub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkeCA9IG5vZGVzW25vZGVJZF0ueCAtIHJlZmVyZW5jZVtub2RlSWRdLnBvc2l0aW9ucy54O1xuICAgICAgICAgIGR5ID0gbm9kZXNbbm9kZUlkXS55IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLnk7XG4gICAgICAgICAgZHBvcyA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuXG4gICAgICAgICAgaWYgKGRwb3MgPiBwb3NUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1vdmUgdGhlIG5vZGVzIG9uZSB0aW1lc3RlcCBhbmQgY2hlY2sgaWYgdGhleSBhcmUgc3RhYmlsaXplZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVOb2RlcygpIHtcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIG1heE5vZGVWZWxvY2l0eSA9IDA7XG4gICAgICB2YXIgYXZlcmFnZU5vZGVWZWxvY2l0eSA9IDA7IC8vIHRoZSB2ZWxvY2l0eSB0aHJlc2hvbGQgKGVuZXJneSBpbiB0aGUgc3lzdGVtKSBmb3IgdGhlIGFkYXB0aXZpdHkgdG9nZ2xlXG5cbiAgICAgIHZhciB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkID0gNTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG5cbiAgICAgICAgdmFyIG5vZGVWZWxvY2l0eSA9IHRoaXMuX3BlcmZvcm1TdGVwKG5vZGVJZCk7IC8vIHN0YWJpbGl6ZWQgaXMgdHJ1ZSBpZiBzdGFiaWxpemVkIGlzIHRydWUgYW5kIHZlbG9jaXR5IGlzIHNtYWxsZXIgdGhhbiB2bWluIC0tPiBhbGwgbm9kZXMgbXVzdCBiZSBzdGFiaWxpemVkXG5cblxuICAgICAgICBtYXhOb2RlVmVsb2NpdHkgPSBNYXRoLm1heChtYXhOb2RlVmVsb2NpdHksIG5vZGVWZWxvY2l0eSk7XG4gICAgICAgIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgKz0gbm9kZVZlbG9jaXR5O1xuICAgICAgfSAvLyBldmFsdWF0aW5nIHRoZSBzdGFiaWxpemVkIGFuZCBhZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCBjb25kaXRpb25zXG5cblxuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9IGF2ZXJhZ2VOb2RlVmVsb2NpdHkgLyBub2RlSW5kaWNlcy5sZW5ndGggPCB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkO1xuICAgICAgdGhpcy5zdGFiaWxpemVkID0gbWF4Tm9kZVZlbG9jaXR5IDwgdGhpcy5vcHRpb25zLm1pblZlbG9jaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbmV3IHZlbG9jaXR5IGZvciBhIGNvb3JkaW5hdGUgZGlyZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdiAgdmVsb2NpdHkgZm9yIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmICByZWd1bGFyIGZvcmNlIGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbSAgbWFzcyBvZiBjdXJyZW50IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBuZXcgdmVsb2NpdHkgZm9yIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2LCBmLCBtKSB7XG4gICAgICB2YXIgZGYgPSB0aGlzLm1vZGVsT3B0aW9ucy5kYW1waW5nICogdjsgLy8gZGFtcGluZyBmb3JjZVxuXG4gICAgICB2YXIgYSA9IChmIC0gZGYpIC8gbTsgLy8gYWNjZWxlcmF0aW9uXG5cbiAgICAgIHYgKz0gYSAqIHRoaXMudGltZXN0ZXA7IC8vIFB1dCBhIGxpbWl0IG9uIHRoZSB2ZWxvY2l0aWVzIGlmIGl0IGlzIHJlYWxseSBoaWdoXG5cbiAgICAgIHZhciBtYXhWID0gdGhpcy5vcHRpb25zLm1heFZlbG9jaXR5IHx8IDFlOTtcblxuICAgICAgaWYgKE1hdGguYWJzKHYpID4gbWF4Vikge1xuICAgICAgICB2ID0gdiA+IDAgPyBtYXhWIDogLW1heFY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgc3RlcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbmV3IHZlbG9jaXR5IG9mIGdpdmVuIG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1TdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtU3RlcChub2RlSWQpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICB2YXIgZm9yY2UgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlSWRdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLndpbmQpIHtcbiAgICAgICAgZm9yY2UueCArPSB0aGlzLm9wdGlvbnMud2luZC54O1xuICAgICAgICBmb3JjZS55ICs9IHRoaXMub3B0aW9ucy53aW5kLnk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tub2RlSWRdOyAvLyBzdG9yZSB0aGUgc3RhdGUgc28gd2UgY2FuIHJldmVydFxuXG4gICAgICB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0gPSB7XG4gICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgeTogbm9kZS55LFxuICAgICAgICB2eDogdmVsb2NpdHkueCxcbiAgICAgICAgdnk6IHZlbG9jaXR5LnlcbiAgICAgIH07XG5cbiAgICAgIGlmIChub2RlLm9wdGlvbnMuZml4ZWQueCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmVsb2NpdHkueCA9IHRoaXMuY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHkodmVsb2NpdHkueCwgZm9yY2UueCwgbm9kZS5vcHRpb25zLm1hc3MpO1xuICAgICAgICBub2RlLnggKz0gdmVsb2NpdHkueCAqIHRoaXMudGltZXN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZS54ID0gMDtcbiAgICAgICAgdmVsb2NpdHkueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm9wdGlvbnMuZml4ZWQueSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmVsb2NpdHkueSA9IHRoaXMuY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHkodmVsb2NpdHkueSwgZm9yY2UueSwgbm9kZS5vcHRpb25zLm1hc3MpO1xuICAgICAgICBub2RlLnkgKz0gdmVsb2NpdHkueSAqIHRoaXMudGltZXN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZS55ID0gMDtcbiAgICAgICAgdmVsb2NpdHkueSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbFZlbG9jaXR5ID0gTWF0aC5zcXJ0KE1hdGgucG93KHZlbG9jaXR5LngsIDIpICsgTWF0aC5wb3codmVsb2NpdHkueSwgMikpO1xuICAgICAgcmV0dXJuIHRvdGFsVmVsb2NpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gaW5pdGlhbGl6aW5nIGFuZCBzdGFiaWxpemluZywgd2UgY2FuIGZyZWV6ZSBub2RlcyB3aXRoIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi5cbiAgICAgKiBUaGlzIGdyZWF0bHkgc3BlZWRzIHVwIHN0YWJpbGl6YXRpb24gYmVjYXVzZSBvbmx5IHRoZSBzdXBwb3J0bm9kZXMgZm9yIHRoZSBzbW9vdGhDdXJ2ZXMgaGF2ZSB0byBzZXR0bGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZyZWV6ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mcmVlemVOb2RlcygpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgaWQpKSB7XG4gICAgICAgICAgaWYgKG5vZGVzW2lkXS54ICYmIG5vZGVzW2lkXS55KSB7XG4gICAgICAgICAgICB2YXIgZml4ZWQgPSBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZnJlZXplQ2FjaGVbaWRdID0ge1xuICAgICAgICAgICAgICB4OiBmaXhlZC54LFxuICAgICAgICAgICAgICB5OiBmaXhlZC55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICBmaXhlZC55ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5mcmVlemVzIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBmcm96ZW4gYnkgX2ZyZWV6ZURlZmluZWROb2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdG9yZUZyb3plbk5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRnJvemVuTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIGlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyZWV6ZUNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZC54ID0gdGhpcy5mcmVlemVDYWNoZVtpZF0ueDtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnkgPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBzdGFibGUgcG9zaXRpb24gZm9yIGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpdGVyYXRpb25zPXRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnNdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGFiaWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhYmlsaXplKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaXRlcmF0aW9ucyA9IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgc3RhYmlsaXplIG1ldGhvZCBuZWVkcyBhIG51bWVyaWMgYW1vdW50IG9mIGl0ZXJhdGlvbnMuIFN3aXRjaGluZyB0byBkZWZhdWx0OiBcIiwgaXRlcmF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZW5hYmxlIGFkYXB0aXZlIHRpbWVzdGVwc1xuXG5cbiAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IHRoaXMub3B0aW9ucy5hZGFwdGl2ZVRpbWVzdGVwOyAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTsgLy8gc3RvcCB0aGUgcmVuZGVyIGxvb3BcblxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7IC8vIGJsb2NrIHJlZHJhdyByZXF1ZXN0c1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2Jsb2NrUmVkcmF3XCIpO1xuICAgICAgdGhpcy50YXJnZXRJdGVyYXRpb25zID0gaXRlcmF0aW9uczsgLy8gc3RhcnQgdGhlIHN0YWJpbGl6YXRpb25cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZnJlZXplTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgIHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX3N0YWJpbGl6YXRpb25CYXRjaCgpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIG5vdCBhbHJlYWR5IHN0YWJpbGl6aW5nLCBzdGFydCBpdCBhbmQgZW1pdCBhIHN0YXJ0IGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3RhYmlsaXphdGlvbiBzdGFydGVkIHdpdGggdGhpcyBjYWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFN0YWJpbGl6aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFN0YWJpbGl6aW5nKCkge1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFN0YWJpbGl6aW5nXCIpO1xuICAgICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25lIGJhdGNoIG9mIHN0YWJpbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhYmlsaXphdGlvbkJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFiaWxpemF0aW9uQmF0Y2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJ1bm5pbmcgPSBmdW5jdGlvbiBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIF90aGlzNC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IF90aGlzNC50YXJnZXRJdGVyYXRpb25zO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNlbmRQcm9ncmVzcygpIHtcbiAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvblByb2dyZXNzXCIsIHtcbiAgICAgICAgICBpdGVyYXRpb25zOiBfdGhpczQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMsXG4gICAgICAgICAgdG90YWw6IF90aGlzNC50YXJnZXRJdGVyYXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXJ0U3RhYmlsaXppbmcoKSkge1xuICAgICAgICBzZW5kUHJvZ3Jlc3MoKTsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHN0YXJ0IGV2ZW50LlxuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICB3aGlsZSAocnVubmluZygpICYmIGNvdW50IDwgdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24udXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuXG4gICAgICBzZW5kUHJvZ3Jlc3MoKTtcblxuICAgICAgaWYgKHJ1bm5pbmcoKSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICAgIHNldFRpbWVvdXQkMShiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXAgdXAgdGhlIHN0YWJpbGl6YXRpb24sIGZpdCBhbmQgZW1pdCB0aGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5hbGl6ZVN0YWJpbGl6YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWxsb3dSZWRyYXdcIik7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5maXQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcmVzdG9yZUZyb3plbk5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmVcIik7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIERFQlVHR0lORyBCRUxPVyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIERlYnVnIGZ1bmN0aW9uIHRoYXQgZGlzcGxheSBhcnJvd3MgZm9yIHRoZSBmb3JjZXMgY3VycmVudGx5IGFjdGl2ZSBpbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHdoZW4gZGVidWdnaW5nIG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3Rm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3Rm9yY2VzKGN0eCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kZXhdO1xuICAgICAgICB2YXIgZm9yY2UgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tpbmRleF07XG4gICAgICAgIHZhciBmYWN0b3IgPSAyMDtcbiAgICAgICAgdmFyIGNvbG9yRmFjdG9yID0gMC4wMztcbiAgICAgICAgdmFyIGZvcmNlU2l6ZSA9IE1hdGguc3FydChNYXRoLnBvdyhmb3JjZS54LCAyKSArIE1hdGgucG93KGZvcmNlLngsIDIpKTtcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihNYXRoLm1heCg1LCBmb3JjZVNpemUpLCAxNSk7XG4gICAgICAgIHZhciBhcnJvd1NpemUgPSAzICogc2l6ZTtcbiAgICAgICAgdmFyIGNvbG9yID0gSFNWVG9IZXgoKDE4MCAtIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGNvbG9yRmFjdG9yICogZm9yY2VTaXplKSkgKiAxODApIC8gMzYwLCAxLCAxKTtcbiAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgIHg6IG5vZGUueCArIGZhY3RvciAqIGZvcmNlLngsXG4gICAgICAgICAgeTogbm9kZS55ICsgZmFjdG9yICogZm9yY2UueVxuICAgICAgICB9O1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhub2RlLngsIG5vZGUueSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihmb3JjZS55LCBmb3JjZS54KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBFbmRQb2ludHMuZHJhdyhjdHgsIHtcbiAgICAgICAgICB0eXBlOiBcImFycm93XCIsXG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBsZW5ndGg6IGFycm93U2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgICBmaWxsKGN0eCkuY2FsbChjdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaHlzaWNzRW5naW5lO1xufSgpO1xuXG4vKipcbiAqIFV0aWxpdHkgQ2xhc3NcbiAqL1xuXG52YXIgTmV0d29ya1V0aWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gTmV0d29ya1V0aWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5ldHdvcmtVdGlsKTtcbiAgfVxuICAvKipcbiAgICogRmluZCB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBuZXR3b3JrIGNvbnNpZGVyaW5nIHRoZSBib3VuZGluZyBib3hlc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gYWxsTm9kZXNcbiAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IFtzcGVjaWZpY05vZGVzPVtdXVxuICAgKiBAcmV0dXJucyB7e21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn19XG4gICAqIEBzdGF0aWNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTmV0d29ya1V0aWwsIG51bGwsIFt7XG4gICAga2V5OiBcImdldFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKGFsbE5vZGVzKSB7XG4gICAgICB2YXIgc3BlY2lmaWNOb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICAgIG5vZGU7XG5cbiAgICAgIGlmIChzcGVjaWZpY05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IGFsbE5vZGVzW3NwZWNpZmljTm9kZXNbaV1dO1xuXG4gICAgICAgICAgaWYgKG1pblggPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQpIHtcbiAgICAgICAgICAgIG1pblggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heFggPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0KSB7XG4gICAgICAgICAgICBtYXhYID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluWSA+IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gudG9wKSB7XG4gICAgICAgICAgICBtaW5ZID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3A7XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuXG5cbiAgICAgICAgICBpZiAobWF4WSA8IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tKSB7XG4gICAgICAgICAgICBtYXhZID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b207XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pblggPT09IDFlOSAmJiBtYXhYID09PSAtMWU5ICYmIG1pblkgPT09IDFlOSAmJiBtYXhZID09PSAtMWU5KSB7XG4gICAgICAgIG1pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhZOiBtYXhZXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBhbGxOb2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBbc3BlY2lmaWNOb2Rlcz1bXV1cbiAgICAgKiBAcmV0dXJucyB7e21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VDb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlQ29yZShhbGxOb2Rlcykge1xuICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcblxuICAgICAgICAgIGlmIChtaW5YID4gbm9kZS54KSB7XG4gICAgICAgICAgICBtaW5YID0gbm9kZS54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS54KSB7XG4gICAgICAgICAgICBtYXhYID0gbm9kZS54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS55KSB7XG4gICAgICAgICAgICBtaW5ZID0gbm9kZS55O1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnkpIHtcbiAgICAgICAgICAgIG1heFkgPSBub2RlLnk7XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pblggPT09IDFlOSAmJiBtYXhYID09PSAtMWU5ICYmIG1pblkgPT09IDFlOSAmJiBtYXhZID09PSAtMWU5KSB7XG4gICAgICAgIG1pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhZOiBtYXhZXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmFuZ2UgPSB7bWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WX07XG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2VudGVyKHJhbmdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLjUgKiAocmFuZ2UubWF4WCArIHJhbmdlLm1pblgpLFxuICAgICAgICB5OiAwLjUgKiAocmFuZ2UubWF4WSArIHJhbmdlLm1pblkpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHJldHVybnMgYSBjbG9uZSBvZiB0aGUgb3B0aW9ucyBvciBvcHRpb25zIG9mIHRoZSBlZGdlIG9yIG5vZGUgdG8gYmUgdXNlZCBmb3IgY29uc3RydWN0aW9uIG9mIG5ldyBlZGdlcyBvciBjaGVjayBmdW5jdGlvbnMgZm9yIG5ldyBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkl0ZW19IGl0ZW1cbiAgICAgKiBAcGFyYW0geydub2RlJ3x1bmRlZmluZWR9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lT3B0aW9ucyhpdGVtLCB0eXBlKSB7XG4gICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy54ID0gaXRlbS54O1xuICAgICAgICBjbG9uZWRPcHRpb25zLnkgPSBpdGVtLnk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMuYW1vdW50T2ZDb25uZWN0aW9ucyA9IGl0ZW0uZWRnZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBpdGVtLm9wdGlvbnMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmVkT3B0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV0d29ya1V0aWw7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQxKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBDbHVzdGVyIGlzIGEgc3BlY2lhbCBOb2RlIHRoYXQgYWxsb3dzIGEgZ3JvdXAgb2YgTm9kZXMgcG9zaXRpb25lZCBjbG9zZWx5IHRvZ2V0aGVyXG4gKiB0byBiZSByZXByZXNlbnRlZCBieSBhIHNpbmdsZSBDbHVzdGVyIE5vZGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVcbiAqL1xuXG52YXIgQ2x1c3RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKENsdXN0ZXIsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDEoQ2x1c3Rlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkuPEhUTUxJbWFnZUVsZW1lbnQ+fWltYWdlbGlzdFxuICAgKiBAcGFyYW0ge0FycmF5fSBncm91cGxpc3RcbiAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2x1c3RlcihvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3Rlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgX3RoaXMuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICBfdGhpcy5jb250YWluZWROb2RlcyA9IHt9O1xuICAgIF90aGlzLmNvbnRhaW5lZEVkZ2VzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2ZlciBjaGlsZCBjbHVzdGVyIGRhdGEgdG8gY3VycmVudCBhbmQgZGlzY29ubmVjdCB0aGUgY2hpbGQgY2x1c3Rlci5cbiAgICpcbiAgICogUGxlYXNlIGNvbnN1bHQgdGhlIGhlYWRlciBjb21tZW50IGluICdDbHVzdGVyaW5nLmpzJyBmb3IgdGhlIGZpZWxkcyBzZXQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjaGlsZENsdXN0ZXJJZCAgaWQgb2YgY2hpbGQgY2x1c3RlciB0byBvcGVuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENsdXN0ZXIsIFt7XG4gICAga2V5OiBcIl9vcGVuQ2hpbGRDbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcGVuQ2hpbGRDbHVzdGVyKGNoaWxkQ2x1c3RlcklkKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkQ2x1c3RlciA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZENsdXN0ZXJJZF07XG5cbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lZE5vZGVzW2NoaWxkQ2x1c3RlcklkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGUgd2l0aCBpZDogXCIgKyBjaGlsZENsdXN0ZXJJZCArIFwiIG5vdCBpbiBjdXJyZW50IGNsdXN0ZXJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2hpbGRDbHVzdGVyLmlzQ2x1c3Rlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIHdpdGggaWQ6IFwiICsgY2hpbGRDbHVzdGVySWQgKyBcIiBpcyBub3QgYSBjbHVzdGVyXCIpO1xuICAgICAgfSAvLyBEaXNjb25uZWN0IGNoaWxkIGNsdXN0ZXIgZnJvbSBjdXJyZW50IGNsdXN0ZXJcblxuXG4gICAgICBkZWxldGUgdGhpcy5jb250YWluZWROb2Rlc1tjaGlsZENsdXN0ZXJJZF07XG4gICAgICBmb3JFYWNoJDEoY2hpbGRDbHVzdGVyLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBkZWxldGUgX3RoaXMyLmNvbnRhaW5lZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgfSk7IC8vIFRyYW5zZmVyIG5vZGVzIGFuZCBlZGdlc1xuXG4gICAgICBmb3JFYWNoJDEoY2hpbGRDbHVzdGVyLmNvbnRhaW5lZE5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIF90aGlzMi5jb250YWluZWROb2Rlc1tub2RlSWRdID0gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgICBmb3JFYWNoJDEoY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIF90aGlzMi5jb250YWluZWRFZGdlc1tlZGdlSWRdID0gZWRnZTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzID0ge307IC8vIFRyYW5zZmVyIGVkZ2VzIHdpdGhpbiBjbHVzdGVyIGVkZ2VzIHdoaWNoIGFyZSBjbHVzdGVyZWRcblxuICAgICAgZm9yRWFjaCQxKGNoaWxkQ2x1c3Rlci5lZGdlcywgZnVuY3Rpb24gKGNsdXN0ZXJFZGdlKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczIuZWRnZXMsIGZ1bmN0aW9uIChwYXJlbnRDbHVzdGVyRWRnZSkge1xuICAgICAgICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyO1xuXG4gICAgICAgICAgLy8gQXNzdW1wdGlvbjogYSBjbHVzdGVyZWQgZWRnZSBjYW4gb25seSBiZSBwcmVzZW50IGluIGEgc2luZ2xlIGNsdXN0ZXJpbmcgZWRnZVxuICAgICAgICAgIC8vIE5vdCB0ZXN0ZWQgaGVyZVxuICAgICAgICAgIHZhciBpbmRleCA9IGluZGV4T2YoX2NvbnRleHQgPSBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcykuY2FsbChfY29udGV4dCwgY2x1c3RlckVkZ2UuaWQpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICAgIGZvckVhY2gkMShjbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywgZnVuY3Rpb24gKHNyY0lkKSB7XG4gICAgICAgICAgICBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5wdXNoKHNyY0lkKTsgLy8gTWFpbnRhaW4gY29ycmVjdCBib29ra2VlcGluZyBmb3IgdHJhbnNmZXJyZWQgZWRnZVxuXG4gICAgICAgICAgICBfdGhpczIuYm9keS5lZGdlc1tzcmNJZF0uZWRnZVJlcGxhY2VkQnlJZCA9IHBhcmVudENsdXN0ZXJFZGdlLmlkO1xuICAgICAgICAgIH0pOyAvLyBSZW1vdmUgY2x1c3RlciBlZGdlIGZyb20gcGFyZW50IGNsdXN0ZXIgZWRnZVxuXG4gICAgICAgICAgc3BsaWNlJDEoX2NvbnRleHQyID0gcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMpLmNhbGwoX2NvbnRleHQyLCBpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuZWRnZXMgPSBbXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2x1c3Rlcjtcbn0oTm9kZSk7XG5cbi8qKlxuICogVGhlIGNsdXN0ZXJpbmcgZW5naW5lXG4gKi9cblxudmFyIENsdXN0ZXJFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIENsdXN0ZXJFbmdpbmUoYm9keSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3RlckVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTsgLy8ga2V5OiBub2RlIGlkLCB2YWx1ZTogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuXG4gICAgdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9OyAvLyBrZXk6IGVkZ2UgaWQsIHZhbHVlOiByZXN0b3JlIGluZm9ybWF0aW9uIGZvciBnaXZlbiBlZGdlXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge307XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXREYXRhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaHVic2l6ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDbHVzdGVyRW5naW5lLCBbe1xuICAgIGtleTogXCJjbHVzdGVyQnlIdWJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUh1YnNpemUoaHVic2l6ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKGh1YnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGh1YnNpemUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMoaHVic2l6ZSk7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2Rlc1RvQ2x1c3RlciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+PSBodWJzaXplKSB7XG4gICAgICAgICAgbm9kZXNUb0NsdXN0ZXIucHVzaChub2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXNUb0NsdXN0ZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRoaXMuY2x1c3RlckJ5Q29ubmVjdGlvbihub2Rlc1RvQ2x1c3RlcltfaV0sIG9wdGlvbnMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBsb29wIG92ZXIgYWxsIG5vZGVzLCBjaGVjayBpZiB0aGV5IGFkaGVyZSB0byB0aGUgY29uZGl0aW9uIGFuZCBjbHVzdGVyIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBjbHVzdGVyQnlOb2RlRGF0YSB3aXRob3V0IGEgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpbiB0aGUgb3B0aW9ucy5cIik7XG4gICAgICB9IC8vIGNoZWNrIGlmIHRoZSBvcHRpb25zIG9iamVjdCBpcyBmaW5lLCBhcHBlbmQgaWYgbmVlZGVkXG5cblxuICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9OyAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcblxuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUsIG5vZGVJZCkge1xuICAgICAgICBpZiAobm9kZS5vcHRpb25zICYmIG9wdGlvbnMuam9pbkNvbmRpdGlvbihub2RlLm9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gbm9kZTsgLy8gY29sbGVjdCB0aGUgZWRnZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG5cbiAgICAgICAgICBmb3JFYWNoJDEobm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSBYIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUNvdW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3RlckJ5RWRnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUVkZ2VDb3VudChlZGdlQ291bnQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICB2YXIgdXNlZE5vZGVzID0ge307XG4gICAgICB2YXIgZWRnZSwgZWRnZXMsIHJlbGV2YW50RWRnZUNvdW50OyAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgICB2YXIgbm9kZUlkID0gX3RoaXMzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXTsgLy8gaWYgdGhpcyBub2RlIGlzIGFscmVhZHkgdXNlZCBpbiBhbm90aGVyIGNsdXN0ZXIgdGhpcyBzZXNzaW9uLCB3ZSBkbyBub3QgaGF2ZSB0byByZS1ldmFsdWF0ZSBpdC5cblxuICAgICAgICBpZiAodXNlZE5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50ID0gMDtcbiAgICAgICAgICBlZGdlcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBlZGdlID0gbm9kZS5lZGdlc1tqXTtcblxuICAgICAgICAgICAgaWYgKF90aGlzMy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyB0aGlzIG5vZGUgcXVhbGlmaWVzLCB3ZSBjb2xsZWN0IGl0cyBuZWlnaGJvdXJzIHRvIHN0YXJ0IHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG5cblxuICAgICAgICAgIGlmIChyZWxldmFudEVkZ2VDb3VudCA9PT0gZWRnZUNvdW50KSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tKb2luQ29uZGl0aW9uID0gZnVuY3Rpb24gY2hlY2tKb2luQ29uZGl0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmpvaW5Db25kaXRpb24oY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBlZGdlcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgZWRnZSA9IGVkZ2VzW19qXTtcblxuICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSBfdGhpczMuX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCk7IC8vIGFkZCB0aGUgbm9kZXMgdG8gdGhlIGxpc3QgYnkgdGhlIGpvaW4gY29uZGl0aW9uLlxuXG5cbiAgICAgICAgICAgICAgaWYgKGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSBfdGhpczMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgICAgdXNlZE5vZGVzW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBkb2VzIG5vdCBxdWFsaWZ5IGFmdGVyIGFsbC5cbiAgICAgICAgICAgICAgICBnYXRoZXJpbmdTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gYWRkIHRvIHRoZSBjbHVzdGVyIHF1ZXVlXG5cblxuICAgICAgICAgICAgaWYgKGtleXMkNChjaGlsZE5vZGVzT2JqKS5sZW5ndGggPiAwICYmIGtleXMkNChjaGlsZEVkZ2VzT2JqKS5sZW5ndGggPiAwICYmIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNlYXJjaCBmb3IgY2x1c3RlciBkYXRhIHRoYXQgY29udGFpbnMgYW55IG9mIHRoZSBub2RlIGlkJ3NcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbm8gam9pbkNvbmRpdGlvbiwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBvZiBqb2luQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICB2YXIgZmluZENsdXN0ZXJEYXRhID0gZnVuY3Rpb24gZmluZENsdXN0ZXJEYXRhKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2x1c3RlcnMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjbHVzdGVyIGNvbnRhaW5pbmcgYW55IG9mIHRoZSBub2RlIGlkJ3NcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2x1c3RlcnNbbl0ubm9kZXNbbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbHVzdGVyc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH07IC8vIElmIGFueSBvZiB0aGUgZm91bmQgbm9kZXMgaXMgcGFydCBvZiBhIGNsdXN0ZXIgZm91bmQgaW4gdGhpcyBtZXRob2QsXG4gICAgICAgICAgICAgIC8vIGFkZCB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhhdCBjbHVzdGVyXG5cblxuICAgICAgICAgICAgICB2YXIgZm91bmRDbHVzdGVyID0gZmluZENsdXN0ZXJEYXRhKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIHRvIGZvdW5kIGNsdXN0ZXIgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIubm9kZXNbbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIubm9kZXNbbV0gPSBjaGlsZE5vZGVzT2JqW21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gQWRkIGVkZ2VzIHRvIGZvdW5kIGNsdXN0ZXIsIGlmIG5vdCBwcmVzZW50XG5cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9tIGluIGNoaWxkRWRnZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIuZWRnZXNbX21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDbHVzdGVyLmVkZ2VzW19tXSA9IGNoaWxkRWRnZXNPYmpbX21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2x1c3RlciBncm91cFxuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbm9kZXM6IGNoaWxkTm9kZXNPYmosXG4gICAgICAgICAgICAgICAgICBlZGdlczogY2hpbGRFZGdlc09ialxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2x1c3RlcnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB0aGlzLl9jbHVzdGVyKGNsdXN0ZXJzW19pMl0ubm9kZXMsIGNsdXN0ZXJzW19pMl0uZWRnZXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDEgZWRnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3Rlck91dGxpZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJPdXRsaWVycyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgxLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDIgZWRnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3RlckJyaWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJyaWRnZXMob3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzdWNrIGFsbCBjb25uZWN0ZWQgbm9kZXMgb2YgYSBub2RlIGludG8gdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCeUNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5Q29ubmVjdGlvbihub2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBub2RlSWQgc3VwcGxpZWQgdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiFcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBub2RlSWQgZ2l2ZW4gdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiBkb2VzIG5vdCBleGlzdCFcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMsIG5vZGUpO1xuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBub2RlLng7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9IG5vZGUueTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueCA9IG5vZGUub3B0aW9ucy5maXhlZC54O1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC55ID0gbm9kZS5vcHRpb25zLmZpeGVkLnk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgdmFyIHBhcmVudE5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50Q2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgIGNoaWxkTm9kZXNPYmpbcGFyZW50Tm9kZUlkXSA9IG5vZGU7IC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuXG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSB0aGlzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBwYXJlbnROb2RlSWQpOyAvLyBpZiB0aGUgY2hpbGQgbm9kZSBpcyBub3QgaW4gYSBjbHVzdGVyXG5cblxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZE5vZGVzW2NoaWxkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlSWQgIT09IHBhcmVudE5vZGVJZCkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG9wdGlvbnMgYW5kIGluc2VydCBzb21lIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNvdWxkIGJlIGludGVyZXN0aW5nLlxuICAgICAgICAgICAgICAgIHZhciBjaGlsZENsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnModGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKHBhcmVudENsb25lZE9wdGlvbnMsIGNoaWxkQ2xvbmVkT3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3dhbGxvdyB0aGUgZWRnZSBpZiBpdCBpcyBzZWxmLXJlZmVyZW5jaW5nLlxuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkTm9kZUlEcyA9IG1hcCQzKF9jb250ZXh0ID0ga2V5cyQ0KGNoaWxkTm9kZXNPYmopKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZV0uaWQ7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgY2hpbGROb2RlS2V5IGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlc09iaiwgY2hpbGROb2RlS2V5KSkgY29udGludWU7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUtleV07XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlID0gY2hpbGROb2RlLmVkZ2VzW3ldO1xuXG4gICAgICAgICAgaWYgKGluZGV4T2YoY2hpbGROb2RlSURzKS5jYWxsKGNoaWxkTm9kZUlEcywgdGhpcy5fZ2V0Q29ubmVjdGVkSWQoY2hpbGRFZGdlLCBjaGlsZE5vZGUuaWQpKSA+IC0xKSB7XG4gICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2NoaWxkRWRnZS5pZF0gPSBjaGlsZEVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY2x1c3RlclxuICAgICAqIEl0IGxvb2tzIGZvciBlZGdlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhlIG5vZGVzIGZyb20gdGhlIFwib3V0c2lkZScgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tOb2RlLmlkOiB2aXMuTm9kZX19IGNoaWxkTm9kZXNPYmpcbiAgICAgKiBAcGFyYW0ge3t2aXMuRWRnZS5pZDogdmlzLkVkZ2V9fSBjaGlsZEVkZ2VzT2JqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbHVzdGVyRWRnZVByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUNsdXN0ZXJFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgZWRnZSwgY2hpbGROb2RlSWQsIGNoaWxkTm9kZSwgdG9JZCwgZnJvbUlkLCBvdGhlck5vZGVJZDsgLy8gbG9vcCBvdmVyIGFsbCBjaGlsZCBub2RlcyBhbmQgdGhlaXIgZWRnZXMgdG8gZmluZCBlZGdlcyBnb2luZyBvdXQgb2YgdGhlIGNsdXN0ZXJcbiAgICAgIC8vIHRoZXNlIGVkZ2VzIHdpbGwgYmUgcmVwbGFjZWQgYnkgY2x1c3RlckVkZ2VzLlxuXG4gICAgICB2YXIgY2hpbGRLZXlzID0ga2V5cyQ0KGNoaWxkTm9kZXNPYmopO1xuXG4gICAgICB2YXIgY3JlYXRlRWRnZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlSWQgPSBjaGlsZEtleXNbaV07XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdOyAvLyBjb25zdHJ1Y3QgbmV3IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgdG8gb3RoZXJzXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBlZGdlID0gY2hpbGROb2RlLmVkZ2VzW2pdOyAvLyB3ZSBvbmx5IGhhbmRsZSBlZGdlcyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBzeXN0ZW0sIG5vdCB0aGUgZGlzYWJsZWQgb25lcyBmcm9tIHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG5cbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZWxmLXJlZmVyZW5jaW5nIGVkZ2VzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFwiaGlkZGVuXCIgbGlzdFxuICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHNldCB1cCB0aGUgZnJvbSBhbmQgdG8uXG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gY2hpbGROb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZG91YmxlIGVxdWFscyBiZWNhdXNlIGludHMgYW5kIHN0cmluZ3MgY2FuIGJlIGludGVyY2hhbmdlZCBoZXJlLlxuICAgICAgICAgICAgICAgIHRvSWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICAgICAgZnJvbUlkID0gZWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSBmcm9tSWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9JZCA9IGVkZ2UudG9JZDtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSB0b0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIE9ubHkgZWRnZXMgZnJvbSB0aGUgY2x1c3RlciBvdXR3YXJkcyBhcmUgYmVpbmcgcmVwbGFjZWQuXG5cblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmpbb3RoZXJOb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3JlYXRlRWRnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRnZTogZWRnZSxcbiAgICAgICAgICAgICAgICBmcm9tSWQ6IGZyb21JZCxcbiAgICAgICAgICAgICAgICB0b0lkOiB0b0lkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvL1xuICAgICAgLy8gSGVyZSB3ZSBhY3R1YWxseSBjcmVhdGUgdGhlIHJlcGxhY2VtZW50IGVkZ2VzLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIGNvdWxkIG5vdCBkbyB0aGlzIGluIHRoZSBsb29wIGFib3ZlIGFzIHRoZSBjcmVhdGlvbiBwcm9jZXNzXG4gICAgICAvLyB3b3VsZCBhZGQgYW4gZWRnZSB0byB0aGUgZWRnZXMgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IGEgY2x1c3RlcmVkIGVkZ2UgY2FuIGhhdmUgbXVsdGlwbGUgYmFzZSBlZGdlcyFcbiAgICAgIC8vXG5cblxuICAgICAgdmFyIG5ld0VkZ2VzID0gW107XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgYSBjbHVzdGVyIGVkZ2Ugd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gY3JlYXRlZCBlZGdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGNyZWF0ZWRFZGdlXG4gICAgICAgKiBAcmV0dXJucyB7dmlzLkVkZ2V9XG4gICAgICAgKi9cblxuICAgICAgdmFyIGdldE5ld0VkZ2UgPSBmdW5jdGlvbiBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKSB7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG5ld0VkZ2VzLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgbmV3RWRnZSA9IG5ld0VkZ2VzW19qMl07IC8vIFdlIHJlcGxhY2UgYm90aCB0byBhbmQgZnJvbSBlZGdlcyB3aXRoIGEgc2luZ2xlIGNsdXN0ZXIgZWRnZVxuXG4gICAgICAgICAgdmFyIG1hdGNoVG9EaXJlY3Rpb24gPSBjcmVhdGVkRWRnZS5mcm9tSWQgPT09IG5ld0VkZ2UuZnJvbUlkICYmIGNyZWF0ZWRFZGdlLnRvSWQgPT09IG5ld0VkZ2UudG9JZDtcbiAgICAgICAgICB2YXIgbWF0Y2hGcm9tRGlyZWN0aW9uID0gY3JlYXRlZEVkZ2UuZnJvbUlkID09PSBuZXdFZGdlLnRvSWQgJiYgY3JlYXRlZEVkZ2UudG9JZCA9PT0gbmV3RWRnZS5mcm9tSWQ7XG5cbiAgICAgICAgICBpZiAobWF0Y2hUb0RpcmVjdGlvbiB8fCBtYXRjaEZyb21EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgY3JlYXRlRWRnZXMubGVuZ3RoOyBfajMrKykge1xuICAgICAgICB2YXIgY3JlYXRlZEVkZ2UgPSBjcmVhdGVFZGdlc1tfajNdO1xuICAgICAgICB2YXIgX2VkZ2UgPSBjcmVhdGVkRWRnZS5lZGdlO1xuICAgICAgICB2YXIgbmV3RWRnZSA9IGdldE5ld0VkZ2UoY3JlYXRlZEVkZ2UpO1xuXG4gICAgICAgIGlmIChuZXdFZGdlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY2x1c3RlcmVkIGVkZ2UgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAgICAgIG5ld0VkZ2UgPSB0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKGNyZWF0ZWRFZGdlLmZyb21JZCwgY3JlYXRlZEVkZ2UudG9JZCwgX2VkZ2UsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7XG4gICAgICAgICAgbmV3RWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goX2VkZ2UuaWQpO1xuICAgICAgICB9IC8vIGFsc28gcmVmZXJlbmNlIHRoZSBuZXcgZWRnZSBpbiB0aGUgb2xkIGVkZ2VcblxuXG4gICAgICAgIHRoaXMuYm9keS5lZGdlc1tfZWRnZS5pZF0uZWRnZVJlcGxhY2VkQnlJZCA9IG5ld0VkZ2UuaWQ7IC8vIGhpZGUgdGhlIHJlcGxhY2VkIGVkZ2VcblxuICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhfZWRnZSk7XG5cbiAgICAgICAgX2VkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHRvIHRoZSBkaWZmZXJlbnQgY2x1c3RlciBmdW5jdGlvbnNcbiAgICAgKiBmb3IgY2VydGFpbiBmaWVsZHMgYW5kIGluc2VydHMgZGVmYXVsdHMgaWYgbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja09wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICBjaGlsZE5vZGVzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBub2RlIG9iamVjdHMsIGlkIGFzIGtleXMsIHNhbWUgYXMgY2hpbGROb2RlcyBleGNlcHQgaXQgYWxzbyBjb250YWlucyBhIHNvdXJjZSBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgIGNoaWxkRWRnZXNPYmogICAgICAgICB8IG9iamVjdCB3aXRoIGVkZ2Ugb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBvcHRpb25zICAgICAgICAgICAgICAgfCBvYmplY3Qgd2l0aCB7Y2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIHByb2Nlc3NQcm9wZXJ0aWVzfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gICByZWZyZXNoRGF0YSB8IHdoZW4gdHJ1ZSwgZG8gbm90IHdyYXAgdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgLy8gUmVtb3ZlIG5vZGVzIHdoaWNoIGFyZSBhbHJlYWR5IGNsdXN0ZXJlZFxuICAgICAgdmFyIHRtcE5vZGVzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0bXBOb2Rlc1RvUmVtb3ZlLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0bXBOb2Rlc1RvUmVtb3ZlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGRlbGV0ZSBjaGlsZE5vZGVzT2JqW3RtcE5vZGVzVG9SZW1vdmVbbl1dO1xuICAgICAgfSAvLyBraWxsIGNvbmRpdGlvbjogbm8gbm9kZXMgZG9uJ3QgYm90aGVyXG5cblxuICAgICAgaWYgKGtleXMkNChjaGlsZE5vZGVzT2JqKS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGFsbG93IGNsdXN0ZXJzIG9mIDEgaWYgb3B0aW9ucyBhbGxvd1xuXG5cbiAgICAgIGlmIChrZXlzJDQoY2hpbGROb2Rlc09iaikubGVuZ3RoID09IDEgJiYgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciAhPSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IGRlZXBFeHRlbmQoe30sIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKTsgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcblxuICAgICAgaWYgKG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBnZXQgdGhlIGNoaWxkTm9kZSBvcHRpb25zXG4gICAgICAgIHZhciBjaGlsZE5vZGVzT3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlc09iaiwgX25vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGNoaWxkTm9kZXNPYmpbX25vZGVJZF0pO1xuICAgICAgICAgICAgY2hpbGROb2Rlc09wdGlvbnMucHVzaChjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZ2V0IGNsdXN0ZXIgcHJvcGVydGllcyBiYXNlZCBvbiBjaGlsZE5vZGVzXG5cblxuICAgICAgICB2YXIgY2hpbGRFZGdlc09wdGlvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGRFZGdlc09iaiwgZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgY2x1c3RlciBlZGdlcyB3aWxsIGJlIHJlbW92ZWQgb24gY3JlYXRpb24gb2YgdGhlIGNsdXN0ZXIuXG4gICAgICAgICAgICBpZiAoZWRnZUlkLnN1YnN0cigwLCAxMikgIT09IFwiY2x1c3RlckVkZ2U6XCIpIHtcbiAgICAgICAgICAgICAgdmFyIF9jbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGNoaWxkRWRnZXNPYmpbZWRnZUlkXSwgXCJlZGdlXCIpO1xuXG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPcHRpb25zLnB1c2goX2Nsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjaGlsZE5vZGVzT3B0aW9ucywgY2hpbGRFZGdlc09wdGlvbnMpO1xuXG4gICAgICAgIGlmICghY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIVwiKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIHVuaXF1ZSBpZDtcblxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gXCJjbHVzdGVyOlwiICsgdjQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJJZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5sYWJlbCA9IFwiY2x1c3RlclwiO1xuICAgICAgfSAvLyBnaXZlIHRoZSBjbHVzdGVyTm9kZSBhIHBvc2l0aW9uIGlmIGl0IGRvZXMgbm90IGhhdmUgb25lLlxuXG5cbiAgICAgIHZhciBwb3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvcyA9IHRoaXMuX2dldENsdXN0ZXJQb3NpdGlvbihjaGlsZE5vZGVzT2JqKTtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBwb3MueDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBwb3MueTtcbiAgICAgIH0gLy8gZm9yY2UgdGhlIElEIHRvIHJlbWFpbiB0aGUgc2FtZVxuXG5cbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IGNsdXN0ZXJJZDsgLy8gY3JlYXRlIHRoZSBjbHVzdGVyIE5vZGVcbiAgICAgIC8vIE5vdGUgdGhhdCBhbGxvd1NpbmdsZU5vZGVDbHVzdGVyLCBpZiBwcmVzZW50LCBpcyBzdG9yZWQgaW4gdGhlIG9wdGlvbnMgYXMgd2VsbFxuXG4gICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBDbHVzdGVyKTtcbiAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzID0gY2hpbGROb2Rlc09iajtcbiAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID0gY2hpbGRFZGdlc09iajsgLy8gY2FjaGUgYSBjb3B5IGZyb20gdGhlIGNsdXN0ZXIgZWRnZSBwcm9wZXJ0aWVzIGlmIHdlIGhhdmUgdG8gcmVjb25uZWN0IG90aGVycyBsYXRlciBvblxuXG4gICAgICBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllczsgLy8gZmluYWxseSBwdXQgdGhlIGNsdXN0ZXIgbm9kZSBpbnRvIGdsb2JhbFxuXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkXSA9IGNsdXN0ZXJOb2RlO1xuXG4gICAgICB0aGlzLl9jbHVzdGVyRWRnZXMoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyk7IC8vIHNldCBJRCB0byB1bmRlZmluZWQgc28gbm8gZHVwbGljYXRlcyBhcmlzZVxuXG5cbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDsgLy8gd3JhcCB1cFxuXG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JhY2t1cEVkZ2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWNrdXBFZGdlT3B0aW9ucyhlZGdlKSB7XG4gICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPSB7XG4gICAgICAgICAgcGh5c2ljczogZWRnZS5vcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3RvcmVFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRWRnZShlZGdlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxPcHRpb25zID0gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcblxuICAgICAgaWYgKG9yaWdpbmFsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogb3JpZ2luYWxPcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NsdXN0ZXIobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNsdXN0ZXIgbm9kZSBiYXNlZCBvbiB3aGF0J3MgaW5zaWRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hpbGROb2Rlc09iaiAgICB8IG9iamVjdCB3aXRoIG5vZGUgb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2x1c3RlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaikge1xuICAgICAgdmFyIGNoaWxkS2V5cyA9IGtleXMkNChjaGlsZE5vZGVzT2JqKTtcblxuICAgICAgdmFyIG1pblggPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueDtcbiAgICAgIHZhciBtYXhYID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICB2YXIgbWluWSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgdmFyIG1heFkgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueTtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbaV1dO1xuICAgICAgICBtaW5YID0gbm9kZS54IDwgbWluWCA/IG5vZGUueCA6IG1pblg7XG4gICAgICAgIG1heFggPSBub2RlLnggPiBtYXhYID8gbm9kZS54IDogbWF4WDtcbiAgICAgICAgbWluWSA9IG5vZGUueSA8IG1pblkgPyBub2RlLnkgOiBtaW5ZO1xuICAgICAgICBtYXhZID0gbm9kZS55ID4gbWF4WSA/IG5vZGUueSA6IG1heFk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAuNSAqIChtaW5YICsgbWF4WCksXG4gICAgICAgIHk6IDAuNSAqIChtaW5ZICsgbWF4WSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBjbHVzdGVyIGJ5IGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9ICBjbHVzdGVyTm9kZUlkIHwgdGhlIElEIG9mIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVmcmVzaERhdGEgfCB3cmFwIHVwIGFmdGVyd2FyZHMgaWYgbm90IHRydWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5DbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAoY2x1c3Rlck5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSB8fCBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGU6XCIgKyBjbHVzdGVyTm9kZUlkICsgXCIgaXMgbm90IGEgdmFsaWQgY2x1c3Rlci5cIik7XG4gICAgICB9IC8vIENoZWNrIGlmIGN1cnJlbnQgY2x1c3RlciBpcyBjbHVzdGVyZWQgaXRzZWxmXG5cblxuICAgICAgdmFyIHN0YWNrID0gdGhpcy5maW5kTm9kZShjbHVzdGVyTm9kZUlkKTtcbiAgICAgIHZhciBwYXJlbnRJbmRleCA9IGluZGV4T2Yoc3RhY2spLmNhbGwoc3RhY2ssIGNsdXN0ZXJOb2RlSWQpIC0gMTtcblxuICAgICAgaWYgKHBhcmVudEluZGV4ID49IDApIHtcbiAgICAgICAgLy8gQ3VycmVudCBjbHVzdGVyIGlzIGNsdXN0ZXJlZDsgdHJhbnNmZXIgY29udGFpbmVkIG5vZGVzIGFuZCBlZGdlcyB0byBwYXJlbnRcbiAgICAgICAgdmFyIHBhcmVudENsdXN0ZXJOb2RlSWQgPSBzdGFja1twYXJlbnRJbmRleF07XG4gICAgICAgIHZhciBwYXJlbnRDbHVzdGVyTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1twYXJlbnRDbHVzdGVyTm9kZUlkXTsgLy8gY2x1c3RlcmluZy5jbHVzdGVyZWROb2RlcyBhbmQgY2x1c3RlcmluZy5jbHVzdGVyZWRFZGdlcyByZW1haW4gdW5jaGFuZ2VkXG5cbiAgICAgICAgcGFyZW50Q2x1c3Rlck5vZGUuX29wZW5DaGlsZENsdXN0ZXIoY2x1c3Rlck5vZGVJZCk7IC8vIEFsbCBjb21wb25lbnRzIG9mIGNoaWxkIGNsdXN0ZXIgbm9kZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWQuIEl0IGNhbiBkaWUgbm93LlxuXG5cbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXTtcblxuICAgICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtYWluIGJvZHlcblxuXG4gICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcztcbiAgICAgIHZhciBjb250YWluZWRFZGdlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzOyAvLyBhbGxvdyB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgbm9kZXMgYWZ0ZXIgcmVsZWFzZS5cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIGNsdXN0ZXJQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBjbHVzdGVyTm9kZS54LFxuICAgICAgICAgIHk6IGNsdXN0ZXJOb2RlLnlcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgcG9zaXRpb25zW25vZGVJZF0gPSB7XG4gICAgICAgICAgICAgIHg6IGNvbnRhaW5lZE5vZGUueCxcbiAgICAgICAgICAgICAgeTogY29udGFpbmVkTm9kZS55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdQb3NpdGlvbnMgPSBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbihjbHVzdGVyUG9zaXRpb24sIHBvc2l0aW9ucyk7XG5cbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl07XG5cbiAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbnNbX25vZGVJZDJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUueCA9IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueCA9PT0gdW5kZWZpbmVkID8gY2x1c3Rlck5vZGUueCA6IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueDtcbiAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUueSA9IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueSA9PT0gdW5kZWZpbmVkID8gY2x1c3Rlck5vZGUueSA6IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvcHkgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGNsdXN0ZXJcbiAgICAgICAgZm9yRWFjaCQxKGNvbnRhaW5lZE5vZGVzLCBmdW5jdGlvbiAoY29udGFpbmVkTm9kZSkge1xuICAgICAgICAgIC8vIGluaGVyaXQgcG9zaXRpb25cbiAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZS5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZWROb2RlLnggPSBjbHVzdGVyTm9kZS54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250YWluZWROb2RlLm9wdGlvbnMuZml4ZWQueSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lZE5vZGUueSA9IGNsdXN0ZXJOb2RlLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmVsZWFzZSBub2Rlc1xuXG5cbiAgICAgIGZvciAodmFyIF9ub2RlSWQzIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIF9ub2RlSWQzKSkge1xuICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDNdOyAvLyBpbmhlcml0IHNwZWVkXG5cbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIudnggPSBjbHVzdGVyTm9kZS52eDtcbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIudnkgPSBjbHVzdGVyTm9kZS52eTtcblxuICAgICAgICAgIF9jb250YWluZWROb2RlMi5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZE5vZGVzW19ub2RlSWQzXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjb3B5IHRoZSBjbHVzdGVyTm9kZSBlZGdlcyBiZWNhdXNlIHdlIGNhbm5vdCBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0IHRoYXQgd2UgYWRkIG9yIHJlbW92ZSBmcm9tLlxuXG5cbiAgICAgIHZhciBlZGdlc1RvQmVEZWxldGVkID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlck5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWRnZXNUb0JlRGVsZXRlZC5wdXNoKGNsdXN0ZXJOb2RlLmVkZ2VzW2ldKTtcbiAgICAgIH0gLy8gYWN0dWFsbHkgaGFuZGxpbmcgdGhlIGRlbGV0aW5nLlxuXG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzVG9CZURlbGV0ZWQubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzVG9CZURlbGV0ZWRbX2kzXTtcblxuICAgICAgICB2YXIgb3RoZXJOb2RlSWQgPSB0aGlzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBjbHVzdGVyTm9kZUlkKTtcblxuICAgICAgICB2YXIgb3RoZXJOb2RlID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tvdGhlck5vZGVJZF07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZmVySWQgPSBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzW2pdO1xuICAgICAgICAgIHZhciB0cmFuc2ZlckVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdHJhbnNmZXJJZF07XG4gICAgICAgICAgaWYgKHRyYW5zZmVyRWRnZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gaWYgdGhlIG90aGVyIG5vZGUgaXMgaW4gYW5vdGhlciBjbHVzdGVyLCB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgb2YgdGhpcyBlZGdlIHRvIHRoZSBvdGhlciBjbHVzdGVyXG5cbiAgICAgICAgICBpZiAob3RoZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRyYW5zZmVyIG93bmVyc2hpcDpcbiAgICAgICAgICAgIHZhciBvdGhlckNsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbb3RoZXJOb2RlLmNsdXN0ZXJJZF07XG4gICAgICAgICAgICBvdGhlckNsdXN0ZXIuY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXSA9IHRyYW5zZmVyRWRnZTsgLy8gZGVsZXRlIGxvY2FsIHJlZmVyZW5jZVxuXG4gICAgICAgICAgICBkZWxldGUgY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXTsgLy8gZ2V0IHRvIGFuZCBmcm9tXG5cbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSB0cmFuc2ZlckVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgdmFyIHRvSWQgPSB0cmFuc2ZlckVkZ2UudG9JZDtcblxuICAgICAgICAgICAgaWYgKHRyYW5zZmVyRWRnZS50b0lkID09IG90aGVyTm9kZUlkKSB7XG4gICAgICAgICAgICAgIHRvSWQgPSBvdGhlck5vZGUuY2x1c3RlcklkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbUlkID0gb3RoZXJOb2RlLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgIH0gLy8gY3JlYXRlIG5ldyBjbHVzdGVyIGVkZ2UgZnJvbSB0aGUgb3RoZXJDbHVzdGVyXG5cblxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIHRyYW5zZmVyRWRnZSwgb3RoZXJDbHVzdGVyLmNsdXN0ZXJFZGdlUHJvcGVydGllcywge1xuICAgICAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgICBwaHlzaWNzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UodHJhbnNmZXJFZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgfSAvLyBoYW5kbGUgdGhlIHJlbGVhc2luZyBvZiB0aGUgZWRnZXNcblxuXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY29udGFpbmVkRWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWRFZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgIHRoaXMuX3Jlc3RvcmVFZGdlKGNvbnRhaW5lZEVkZ2VzW2VkZ2VJZF0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIHJlbW92ZSBjbHVzdGVyTm9kZVxuXG5cbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG5cbiAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2x1c3Rlci5pZH0gY2x1c3RlcklkXG4gICAgICogQHJldHVybnMge0FycmF5LjxOb2RlLmlkPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVzSW5DbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVzSW5DbHVzdGVyKGNsdXN0ZXJJZCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyKGNsdXN0ZXJJZCkgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF0uY29udGFpbmVkTm9kZXM7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZXNBcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVzQXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhY2sgY2x1c3RlcklkJ3MgdGhhdCBhIGNlcnRhaW4gbm9kZSByZXNpZGVzIGluLiBjbHVzdGVyIEEgLT4gY2x1c3RlciBCIC0+IGNsdXN0ZXIgQyAtPiBub2RlXG4gICAgICpcbiAgICAgKiBJZiBhIG5vZGUgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGNoYWluLCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlKG5vZGVJZCkge1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuaWQpO1xuICAgICAgICBub2RlSWQgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0uY2x1c3RlcklkO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG5cbiAgICAgIHJldmVyc2Uoc3RhY2spLmNhbGwoc3RhY2spO1xuXG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgY2x1c3RlcmVkIG5vZGVJZCwgdXBkYXRlIHdpdGggdGhlIG5ldyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNsdXN0ZXJlZE5vZGVJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDbHVzdGVyZWROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNsdXN0ZXJlZE5vZGUoY2x1c3RlcmVkTm9kZUlkLCBuZXdPcHRpb25zKSB7XG4gICAgICBpZiAoY2x1c3RlcmVkTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2x1c3RlcmVkTm9kZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyZWROb2RlSWQgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyZWROb2RlSWRdLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBhIGJhc2UgZWRnZUlkLCB1cGRhdGUgYWxsIHJlbGF0ZWQgY2x1c3RlcmVkIGVkZ2VzIHdpdGggdGhlIG5ldyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBzdGFydEVkZ2VJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2Uoc3RhcnRFZGdlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChzdGFydEVkZ2VJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbc3RhcnRFZGdlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxsRWRnZUlkcyA9IHRoaXMuZ2V0Q2x1c3RlcmVkRWRnZXMoc3RhcnRFZGdlSWQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbYWxsRWRnZUlkc1tpXV07XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RhY2sgb2YgY2x1c3RlckVkZ2VJZCdzICgrYmFzZSBlZGdlaWQpIHRoYXQgYSBiYXNlIGVkZ2UgaXMgdGhlIHNhbWUgYXMuIGNsdXN0ZXIgZWRnZSBDIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBBIC0+IGJhc2UgZWRnZShlZGdlSWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlLmlkPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENsdXN0ZXJlZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsdXN0ZXJlZEVkZ2VzKGVkZ2VJZCkge1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICB3aGlsZSAoZWRnZUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHN0YWNrLnB1c2godGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5lZGdlUmVwbGFjZWRCeUlkO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG5cbiAgICAgIHJldmVyc2Uoc3RhY2spLmNhbGwoc3RhY2spO1xuXG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFzZSBlZGdlIGlkIG9mIGNsdXN0ZXJFZGdlSWQuIGNsdXN0ZXIgZWRnZSAoY2x1c3RlcmVkRWRnZUlkKSAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQyAtPiBiYXNlIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHt2aXMuRWRnZS5pZH0gYmFzZUVkZ2VJZFxuICAgICAqXG4gICAgICogVE9ETzogZGVwcmVjYXRlIGluIDUuMC4wLiBNZXRob2QgZ2V0QmFzZUVkZ2VzKCkgaXMgdGhlIGNvcnJlY3Qgb25lIHRvIHVzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VFZGdlKGNsdXN0ZXJlZEVkZ2VJZCkge1xuICAgICAgLy8gSnVzdCBrbHVkZ2UgdGhpcyBieSByZXR1cm5pbmcgdGhlIGZpcnN0IGJhc2UgZWRnZSBpZCBmb3VuZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzZUVkZ2VzKGNsdXN0ZXJlZEVkZ2VJZClbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVndWxhciBlZGdlcyBmb3IgdGhpcyBjbHVzdGVyZWQgZWRnZSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fSBhbGwgYmFzZUVkZ2VJZCdzIHVuZGVyIHRoaXMgY2x1c3RlcmVkIGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlRWRnZXMoY2x1c3RlcmVkRWRnZUlkKSB7XG4gICAgICB2YXIgSWRzVG9IYW5kbGUgPSBbY2x1c3RlcmVkRWRnZUlkXTtcbiAgICAgIHZhciBkb25lSWRzID0gW107XG4gICAgICB2YXIgZm91bmRJZHMgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgIHdoaWxlIChJZHNUb0hhbmRsZS5sZW5ndGggPiAwICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgdmFyIG5leHRJZCA9IElkc1RvSGFuZGxlLnBvcCgpO1xuICAgICAgICBpZiAobmV4dElkID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBQYXJhbm9pYSBoZXJlIGFuZCBvbndhcmRzXG5cbiAgICAgICAgdmFyIG5leHRFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW25leHRJZF07XG4gICAgICAgIGlmIChuZXh0RWRnZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgICB2YXIgcmVwbGFjaW5nSWRzID0gbmV4dEVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHM7XG5cbiAgICAgICAgaWYgKHJlcGxhY2luZ0lkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gbmV4dElkIGlzIGEgYmFzZSBpZFxuICAgICAgICAgIGZvdW5kSWRzLnB1c2gobmV4dElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbm90aGVyIGNsdXN0ZXIgZWRnZSwgdW5yYXZlbCB0aGlzIG9uZSBhcyB3ZWxsXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNpbmdJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNpbmdJZCA9IHJlcGxhY2luZ0lkc1tpXTsgLy8gRG9uJ3QgYWRkIGlmIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICAgICAgLy8gVE9ETzogbmV2ZXIgdHJpZ2dlcnM7IGZpbmQgYSB0ZXN0LWNhc2Ugd2hpY2ggZG9lc1xuXG4gICAgICAgICAgICBpZiAoaW5kZXhPZihJZHNUb0hhbmRsZSkuY2FsbChJZHNUb0hhbmRsZSwgcmVwbGFjaW5nSWRzKSAhPT0gLTEgfHwgaW5kZXhPZihkb25lSWRzKS5jYWxsKGRvbmVJZHMsIHJlcGxhY2luZ0lkcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBJZHNUb0hhbmRsZS5wdXNoKHJlcGxhY2luZ0lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkb25lSWRzLnB1c2gobmV4dElkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvdW5kSWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIElkIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZX0gZWRnZVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDb25uZWN0ZWRJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29ubmVjdGVkSWQoZWRnZSwgbm9kZUlkKSB7XG4gICAgICBpZiAoZWRnZS50b0lkICE9IG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gZWRnZS50b0lkO1xuICAgICAgfSBlbHNlIGlmIChlZGdlLmZyb21JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSBkZXRlcm1pbmUgaG93IG1hbnkgY29ubmVjdGlvbnMgZGVub3RlIGFuIGltcG9ydGFudCBodWIuXG4gICAgICogV2UgdGFrZSB0aGUgbWVhbiArIDIqc3RkIGFzIHRoZSBpbXBvcnRhbnQgaHViIHNpemUuIChBc3N1bWluZyBhIG5vcm1hbCBkaXN0cmlidXRpb24gb2YgZGF0YSwgfjIuMiUpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SHViU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZSgpIHtcbiAgICAgIHZhciBhdmVyYWdlID0gMDtcbiAgICAgIHZhciBhdmVyYWdlU3F1YXJlZCA9IDA7XG4gICAgICB2YXIgaHViQ291bnRlciA9IDA7XG4gICAgICB2YXIgbGFyZ2VzdEh1YiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKG5vZGUuZWRnZXMubGVuZ3RoID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICAgIGxhcmdlc3RIdWIgPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGF2ZXJhZ2UgKz0gbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIGF2ZXJhZ2VTcXVhcmVkICs9IE1hdGgucG93KG5vZGUuZWRnZXMubGVuZ3RoLCAyKTtcbiAgICAgICAgaHViQ291bnRlciArPSAxO1xuICAgICAgfVxuXG4gICAgICBhdmVyYWdlID0gYXZlcmFnZSAvIGh1YkNvdW50ZXI7XG4gICAgICBhdmVyYWdlU3F1YXJlZCA9IGF2ZXJhZ2VTcXVhcmVkIC8gaHViQ291bnRlcjtcbiAgICAgIHZhciB2YXJpYW5jZSA9IGF2ZXJhZ2VTcXVhcmVkIC0gTWF0aC5wb3coYXZlcmFnZSwgMik7XG4gICAgICB2YXIgc3RhbmRhcmREZXZpYXRpb24gPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuICAgICAgdmFyIGh1YlRocmVzaG9sZCA9IE1hdGguZmxvb3IoYXZlcmFnZSArIDIgKiBzdGFuZGFyZERldmlhdGlvbik7IC8vIGFsd2F5cyBoYXZlIGF0IGxlYXN0IG9uZSB0byBjbHVzdGVyXG5cbiAgICAgIGlmIChodWJUaHJlc2hvbGQgPiBsYXJnZXN0SHViKSB7XG4gICAgICAgIGh1YlRocmVzaG9sZCA9IGxhcmdlc3RIdWI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodWJUaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlZGdlIGZvciB0aGUgY2x1c3RlciByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gZnJvbUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0b0lkXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZX0gYmFzZUVkZ2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGV4dHJhT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtFZGdlfSBuZXdseSBjcmVhdGVkIGNsdXN0ZXJlZCBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVDbHVzdGVyZWRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDbHVzdGVyZWRFZGdlKGZyb21JZCwgdG9JZCwgYmFzZUVkZ2UsIGNsdXN0ZXJFZGdlUHJvcGVydGllcywgZXh0cmFPcHRpb25zKSB7XG4gICAgICAvLyBjb3B5IHRoZSBvcHRpb25zIG9mIHRoZSBlZGdlIHdlIHdpbGwgcmVwbGFjZVxuICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoYmFzZUVkZ2UsIFwiZWRnZVwiKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0aWVzIG9mIGNsdXN0ZXJFZGdlcyBhcmUgc3VwZXJpbXBvc2VkIG9uIGl0XG5cbiAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTsgLy8gc2V0IHVwIHRoZSBlZGdlXG5cbiAgICAgIGNsb25lZE9wdGlvbnMuZnJvbSA9IGZyb21JZDtcbiAgICAgIGNsb25lZE9wdGlvbnMudG8gPSB0b0lkO1xuICAgICAgY2xvbmVkT3B0aW9ucy5pZCA9IFwiY2x1c3RlckVkZ2U6XCIgKyB2NCgpOyAvLyBhcHBseSB0aGUgZWRnZSBzcGVjaWZpYyBvcHRpb25zIHRvIGl0IGlmIHNwZWNpZmllZFxuXG4gICAgICBpZiAoZXh0cmFPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShjbG9uZWRPcHRpb25zKTtcbiAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMgPSBbYmFzZUVkZ2UuaWRdO1xuICAgICAgbmV3RWRnZS5jb25uZWN0KCk7IC8vIFJlZ2lzdGVyIHRoZSBuZXcgZWRnZVxuXG4gICAgICB0aGlzLmJvZHkuZWRnZXNbbmV3RWRnZS5pZF0gPSBuZXdFZGdlO1xuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcGFzc2VkIGNoaWxkIG5vZGVzIGFuZCBlZGdlcyB0byB0aGUgZ2l2ZW4gY2x1c3RlciBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBOb2RlfSBjaGlsZE5vZGVzICBoYXNoIG9mIG5vZGVzIG9yIHNpbmdsZSBub2RlIHRvIGFkZCBpbiBjbHVzdGVyXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBFZGdlfSBjaGlsZEVkZ2VzICBoYXNoIG9mIGVkZ2VzIG9yIHNpbmdsZSBlZGdlIHRvIHRha2UgaW50byBhY2NvdW50IHdoZW4gY2x1c3RlcmluZ1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gY2x1c3Rlck5vZGUgIGNsdXN0ZXIgbm9kZSB0byBhZGQgbm9kZXMgYW5kIGVkZ2VzIHRvXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjbHVzdGVyRWRnZVByb3BlcnRpZXNdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbHVzdGVyRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzLCBjaGlsZEVkZ2VzLCBjbHVzdGVyTm9kZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoY2hpbGRFZGdlcyBpbnN0YW5jZW9mIEVkZ2UpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjaGlsZEVkZ2VzO1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIG9ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgIGNoaWxkRWRnZXMgPSBvYmo7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZE5vZGVzIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBfb2JqID0ge307XG4gICAgICAgIF9vYmpbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBjaGlsZE5vZGVzID0gX29iajtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlID09PSB1bmRlZmluZWQgfHwgY2x1c3Rlck5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX2NsdXN0ZXJFZGdlczogcGFyYW1ldGVyIGNsdXN0ZXJOb2RlIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgcmVxdWlyZWQgcHJvcGVydGllcyBmcm9tIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0gY2x1c3Rlck5vZGUuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzO1xuICAgICAgfSAvLyBjcmVhdGUgdGhlIG5ldyBlZGdlcyB0aGF0IHdpbGwgY29ubmVjdCB0byB0aGUgY2x1c3Rlci5cbiAgICAgIC8vIEFsbCBzZWxmLXJlZmVyZW5jaW5nIGVkZ2VzIHdpbGwgYmUgYWRkZWQgdG8gY2hpbGRFZGdlcyBoZXJlLlxuXG5cbiAgICAgIHRoaXMuX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzLCBjaGlsZEVkZ2VzLCBjbHVzdGVyTm9kZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTsgLy8gZGlzYWJsZSB0aGUgY2hpbGRFZGdlc1xuXG5cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjaGlsZEVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGRFZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2VkZ2UyID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF07IC8vIGNhY2hlIHRoZSBvcHRpb25zIGJlZm9yZSBjaGFuZ2luZ1xuXG4gICAgICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhfZWRnZTIpOyAvLyBkaXNhYmxlIHBoeXNpY3MgYW5kIGhpZGUgdGhlIGVkZ2VcblxuXG4gICAgICAgICAgICBfZWRnZTIuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZGlzYWJsZSB0aGUgY2hpbGROb2Rlc1xuXG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgIGNsdXN0ZXJJZDogY2x1c3Rlck5vZGUuaWQsXG4gICAgICAgICAgICBub2RlOiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpbiB3aGljaCBjbHVzdGVyIGdpdmVuIG5vZGVJZCByZXNpZGVzLlxuICAgICAqXG4gICAgICogSWYgbm90IGluIGNsdXN0ZXIsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBJZiB5b3Uga25vdyBhIGNsZWFuZXIgd2F5IHRvIGRvIHRoaXMsIHBsZWFzZSBlbmxpZ2h0ZW4gbWUgKHdpbXJpam5kZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge05vZGV8dW5kZWZpbmVkfSBOb2RlIGluc3RhbmNlIGZvciBjbHVzdGVyLCBpZiBwcmVzZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDbHVzdGVyTm9kZUZvck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENsdXN0ZXJOb2RlRm9yTm9kZShub2RlSWQpIHtcbiAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBjbHVzdGVyZWROb2RlID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdOyAvLyBOT1RFOiBJZiBubyBjbHVzdGVyIGluZm8gZm91bmQsIGl0IHNob3VsZCBhY3R1YWxseSBiZSBhbiBlcnJvclxuXG4gICAgICBpZiAoY2x1c3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGNsdXN0ZXJJZCA9IGNsdXN0ZXJlZE5vZGUuY2x1c3RlcklkO1xuICAgICAgaWYgKGNsdXN0ZXJJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVySWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbmRpdGlvbmFsbHkgcmVtb3ZpbmcgaXRlbXMgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIERvbmUgbGlrZSB0aGlzIGJlY2F1c2UgQXJyYXkuZmlsdGVyKCkgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBieSBhbGwgSUUncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWx0ZXIoYXJyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgZm9yRWFjaCQxKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZW0pKSB7XG4gICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbiBhbGwgZWRnZXMgZm9yIGNoYW5nZXMgaW4gY2x1c3RlcmluZyBhbmQgYWRqdXN0IHRoaXMgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQ2FsbCB0aGlzIChpbnRlcm5hbGx5KSBhZnRlciB0aGVyZSBoYXMgYmVlbiBhIGNoYW5nZSBpbiBub2RlIG9yIGVkZ2UgZGF0YS5cbiAgICAgKlxuICAgICAqIFByZTogU3RhdGVzIG9mIHRoaXMuYm9keS5ub2RlcyBhbmQgdGhpcy5ib2R5LmVkZ2VzIGNvbnNpc3RlbnRcbiAgICAgKiBQcmU6IHRoaXMuY2x1c3RlcmVkTm9kZXMgYW5kIHRoaXMuY2x1c3RlcmVkRWRnZSBjb25zaXN0ZW50IHdpdGggY29udGFpbmVkTm9kZXMgYW5kIGNvbnRhaW5lZEVkZ2VzXG4gICAgICogICAgICBvZiBjbHVzdGVyIG5vZGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTdGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgbm9kZUlkO1xuICAgICAgdmFyIGRlbGV0ZWROb2RlSWRzID0gW107XG4gICAgICB2YXIgZGVsZXRlZEVkZ2VJZHMgPSB7fTtcbiAgICAgIC8qKlxuICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgY2x1c3RlcmluZyBub2RlcyBvbmx5XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggY2x1c3RlciBub2RlXG4gICAgICAgKi9cblxuICAgICAgdmFyIGVhY2hDbHVzdGVyTm9kZSA9IGZ1bmN0aW9uIGVhY2hDbHVzdGVyTm9kZShjYWxsYmFjaykge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXM0LmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTsgLy9cbiAgICAgIC8vIFJlbW92ZSBkZWxldGVkIHJlZ3VsYXIgbm9kZXMgZnJvbSBjbHVzdGVyaW5nXG4gICAgICAvL1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBkZWxldGVkIG5vZGVzXG5cblxuICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5jbHVzdGVyZWROb2Rlcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNsdXN0ZXJlZE5vZGVzLCBub2RlSWQpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlZE5vZGVJZHMucHVzaChub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbW92ZSBub2RlcyBmcm9tIGNsdXN0ZXIgbm9kZXNcblxuXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZGVsZXRlZE5vZGVJZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBkZWxldGUgY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXNbZGVsZXRlZE5vZGVJZHNbbl1dO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gUmVtb3ZlIG5vZGVzIGZyb20gY2x1c3RlciBsaXN0XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZGVsZXRlZE5vZGVJZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkTm9kZXNbZGVsZXRlZE5vZGVJZHNbbl1dO1xuICAgICAgfSAvL1xuICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgZWRnZXMgZnJvbSBjbHVzdGVyaW5nXG4gICAgICAvL1xuICAgICAgLy8gQWRkIHRoZSBkZWxldGVkIGNsdXN0ZXJlZCBlZGdlcyB0byB0aGUgbGlzdFxuXG5cbiAgICAgIGZvckVhY2gkMSh0aGlzLmNsdXN0ZXJlZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICBpZiAoZWRnZSA9PT0gdW5kZWZpbmVkIHx8ICFlZGdlLmVuZFBvaW50c1ZhbGlkKCkpIHtcbiAgICAgICAgICBkZWxldGVkRWRnZUlkc1tlZGdlSWRdID0gZWRnZUlkO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQ2x1c3RlciBub2RlcyBjYW4gYWxzbyBjb250YWluIGVkZ2VzIHdoaWNoIGFyZSBub3QgY2x1c3RlcmVkLFxuICAgICAgLy8gaS5lLiBub2RlcyAxLTIgd2l0aGluIGNsdXN0ZXIgd2l0aCBhbiBlZGdlIGluIGJldHdlZW4uXG4gICAgICAvLyBTbyB0aGUgY2x1c3RlciBub2RlcyBhbHNvIG5lZWQgdG8gYmUgc2Nhbm5lZCBmb3IgaW52YWxpZCBlZGdlc1xuXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIGZvckVhY2gkMShjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICAgIGlmICghZWRnZS5lbmRQb2ludHNWYWxpZCgpICYmICFkZWxldGVkRWRnZUlkc1tlZGdlSWRdKSB7XG4gICAgICAgICAgICBkZWxldGVkRWRnZUlkc1tlZGdlSWRdID0gZWRnZUlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gQWxzbyBzY2FuIGZvciBjbHVzdGVyIGVkZ2VzIHdoaWNoIG5lZWQgdG8gYmUgcmVtb3ZlZCBpbiB0aGUgYWN0aXZlIGxpc3QuXG4gICAgICAvLyBSZWd1bGFyIGVkZ2VzIGhhdmUgYmVlbiByZW1vdmVkIGJlZm9yZWhhbmQsIHNvIHRoaXMgb25seSBwaWNrcyB1cCB0aGUgY2x1c3RlciBlZGdlcy5cblxuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHNjYW4gdGhlIGNvbnRhaW5lZCBlZGdlcyBmb3IgdmFsaWRpdHlcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmVwbGFjZWRJZHMgPSBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuXG4gICAgICAgIGlmIChyZXBsYWNlZElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG51bVZhbGlkID0gMDtcbiAgICAgICAgICBmb3JFYWNoJDEocmVwbGFjZWRJZHMsIGZ1bmN0aW9uIChjb250YWluZWRFZGdlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWRFZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbY29udGFpbmVkRWRnZUlkXTtcblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZEVkZ2UgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZWRFZGdlLmVuZFBvaW50c1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgbnVtVmFsaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpc1ZhbGlkID0gbnVtVmFsaWQgPiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlZGdlLmVuZFBvaW50c1ZhbGlkKCkgfHwgIWlzVmFsaWQpIHtcbiAgICAgICAgICBkZWxldGVkRWRnZUlkc1tlZGdlSWRdID0gZWRnZUlkO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gUmVtb3ZlIGVkZ2VzIGZyb20gY2x1c3RlciBub2Rlc1xuXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIGZvckVhY2gkMShkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGRlbGV0ZWRFZGdlSWQpIHtcbiAgICAgICAgICBkZWxldGUgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXNbZGVsZXRlZEVkZ2VJZF07XG4gICAgICAgICAgZm9yRWFjaCQxKGNsdXN0ZXJOb2RlLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgbSkge1xuICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGRlbGV0ZWRFZGdlSWQpIHtcbiAgICAgICAgICAgICAgY2x1c3Rlck5vZGUuZWRnZXNbbV0gPSBudWxsOyAvLyBEb24ndCB3YW50IHRvIGRpcmVjdGx5IGRlbGV0ZSBoZXJlLCBiZWNhdXNlIGluIHRoZSBsb29wXG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gX3RoaXM0Ll9maWx0ZXIoZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhZGVsZXRlZEVkZ2VJZHNbaWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7IC8vIENsZWFuIHVwIHRoZSBudWxsc1xuXG4gICAgICAgICAgY2x1c3Rlck5vZGUuZWRnZXMgPSBfdGhpczQuX2ZpbHRlcihjbHVzdGVyTm9kZS5lZGdlcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBSZW1vdmUgZnJvbSBjbHVzdGVyIGxpc3RcblxuICAgICAgZm9yRWFjaCQxKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczQuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pOyAvLyBSZW1vdmUgY2x1c3RlciBlZGdlcyBmcm9tIGFjdGl2ZSBsaXN0ICh0aGlzLmJvZHkuZWRnZXMpLlxuICAgICAgLy8gZGVsZXRlZEVkZ2VJZHMgc3RpbGwgY29udGFpbnMgaWQgb2YgcmVndWxhciBlZGdlcywgYnV0IHRoZXNlIHNob3VsZCBhbGxcbiAgICAgIC8vIGJlIGdvbmUgd2hlbiB5b3UgcmVhY2ggaGVyZS5cblxuICAgICAgZm9yRWFjaCQxKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczQuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgfSk7IC8vXG4gICAgICAvLyBDaGVjayBjaGFuZ2VkIGNsdXN0ZXIgc3RhdGUgb2YgZWRnZXNcbiAgICAgIC8vXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBrZXlzIGhlcmUsIGJlY2F1c2UgZWRnZXMgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGxvb3BcblxuICAgICAgdmFyIGlkcyA9IGtleXMkNCh0aGlzLmJvZHkuZWRnZXMpO1xuXG4gICAgICBmb3JFYWNoJDEoaWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICB2YXIgc2hvdWxkQmVDbHVzdGVyZWQgPSBfdGhpczQuX2lzQ2x1c3RlcmVkTm9kZShlZGdlLmZyb21JZCkgfHwgX3RoaXM0Ll9pc0NsdXN0ZXJlZE5vZGUoZWRnZS50b0lkKTtcblxuICAgICAgICBpZiAoc2hvdWxkQmVDbHVzdGVyZWQgPT09IF90aGlzNC5faXNDbHVzdGVyZWRFZGdlKGVkZ2UuaWQpKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBhbGwgaXMgd2VsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkKSB7XG4gICAgICAgICAgLy8gYWRkIGVkZ2UgdG8gY2x1c3RlcmluZ1xuICAgICAgICAgIHZhciBjbHVzdGVyRnJvbSA9IF90aGlzNC5fZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKGVkZ2UuZnJvbUlkKTtcblxuICAgICAgICAgIGlmIChjbHVzdGVyRnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpczQuX2NsdXN0ZXJFZGdlcyhfdGhpczQuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF0sIGVkZ2UsIGNsdXN0ZXJGcm9tKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2x1c3RlclRvID0gX3RoaXM0Ll9nZXRDbHVzdGVyTm9kZUZvck5vZGUoZWRnZS50b0lkKTtcblxuICAgICAgICAgIGlmIChjbHVzdGVyVG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS50b0lkXSwgZWRnZSwgY2x1c3RlclRvKTtcbiAgICAgICAgICB9IC8vIFRPRE86IGNoZWNrIHRoYXQgaXQgd29ya3MgZm9yIGJvdGggZWRnZXMgY2x1c3RlcmVkXG4gICAgICAgICAgLy8gICAgICAgKFRoaXMgbWlnaHQgYmUgcGFyYW5vaWEpXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgX3RoaXM0Ll9jbHVzdGVyRWRnZXNbZWRnZUlkXTtcblxuICAgICAgICAgIF90aGlzNC5fcmVzdG9yZUVkZ2UoZWRnZSk7IC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBoYXBwZW5pbmcsIHRoZSBzdGF0ZSBzaG91bGRcbiAgICAgICAgICAvLyBiZSBwcm9wZXJseSB1cGRhdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBpdCAqaXMqIHJlYWNoZWQgZHVyaW5nIG5vcm1hbCBvcGVyYXRpb24sIHRoZW4gd2UgaGF2ZSB0byBpbXBsZW1lbnRcbiAgICAgICAgICAvLyB1bmRvIGNsdXN0ZXJpbmcgZm9yIHRoaXMgZWRnZSBoZXJlLlxuICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigncmVtb3ZlIGVkZ2UgZnJvbSBjbHVzdGVyaW5nIG5vdCBpbXBsZW1lbnRlZCEnKVxuXG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBDbHVzdGVycyBtYXkgYmUgbmVzdGVkIHRvIGFueSBsZXZlbC4gS2VlcCBvbiBvcGVuaW5nIHVudGlsIG5vdGhpbmcgdG8gb3BlblxuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvbnRpbnVlTG9vcCA9IHRydWU7XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBjbHVzdGVyc1RvT3BlbiA9IFtdOyAvLyBEZXRlcm1pbmUgdGhlIGlkJ3Mgb2YgY2x1c3RlcnMgdGhhdCBuZWVkIG9wZW5pbmdcblxuICAgICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgICAgdmFyIG51bU5vZGVzID0ga2V5cyQ0KGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzKS5sZW5ndGg7XG5cbiAgICAgICAgICB2YXIgYWxsb3dTaW5nbGUgPSBjbHVzdGVyTm9kZS5vcHRpb25zLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIgPT09IHRydWU7XG5cbiAgICAgICAgICBpZiAoYWxsb3dTaW5nbGUgJiYgbnVtTm9kZXMgPCAxIHx8ICFhbGxvd1NpbmdsZSAmJiBudW1Ob2RlcyA8IDIpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzVG9PcGVuLnB1c2goY2x1c3Rlck5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIE9wZW4gdGhlbVxuXG4gICAgICAgIGZvciAodmFyIF9uID0gMDsgX24gPCBjbHVzdGVyc1RvT3Blbi5sZW5ndGg7ICsrX24pIHtcbiAgICAgICAgICBfdGhpczQub3BlbkNsdXN0ZXIoY2x1c3RlcnNUb09wZW5bX25dLCB7fSwgZmFsc2VcbiAgICAgICAgICAvKiBEb24ndCByZWZyZXNoLCB3ZSdyZSBpbiBhbiByZWZyZXNoL3VwZGF0ZSBhbHJlYWR5ICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlTG9vcCA9IGNsdXN0ZXJzVG9PcGVuLmxlbmd0aCA+IDA7XG4gICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGNvbnRpbnVlTG9vcDtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChjb250aW51ZUxvb3ApIHtcbiAgICAgICAgX2xvb3AyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlKCk7IC8vIFJlZG8gdGhpcyBtZXRob2QgKHJlY3Vyc2lvbiBwb3NzaWJsZSEgc2hvdWxkIGJlIHNhZmUpXG5cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIG5vZGUgd2l0aCBnaXZlbiBpZCBpcyBwYXJ0IG9mIGEgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNDbHVzdGVyZWROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NsdXN0ZXJlZE5vZGUobm9kZUlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBlZGdlIHdpdGggZ2l2ZW4gaWQgaXMgbm90IHZpc2libGUgZHVlIHRvIGNsdXN0ZXJpbmcuXG4gICAgICpcbiAgICAgKiBBbiBlZGdlIGlzIGNvbnNpZGVyZWQgY2x1c3RlcmVkIGlmOlxuICAgICAqIC0gaXQgaXMgZGlyZWN0bHkgcmVwbGFjZWQgYnkgYSBjbHVzdGVyaW5nIGVkZ2VcbiAgICAgKiAtIGFueSBvZiBpdHMgY29ubmVjdGluZyBub2RlcyBpcyBpbiBhIGNsdXN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHBhcnQgb2YgYSBjbHVzdGVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ2x1c3RlcmVkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWRFZGdlKGVkZ2VJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbHVzdGVyRW5naW5lO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobywgbWluTGVuKSB7IHZhciBfY29udGV4dDQ7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQ0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0NCwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ1KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBJbml0aWFsaXplcyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgdG8gYSB1c2FibGUgZm9ybS5cbiAqXG4gKiBTcGVjaWZpY2FsbHksIHNldCB1cCB0aGlzIG1ldGhvZCBmb3IgdGhlIGNhc2Ugb2YgcnVubmluZyBvbiBub2RlLmpzIHdpdGgganNkb20gZW5hYmxlZC5cbiAqXG4gKiBOT1RFUzpcbiAqXG4gKiBPbiBub2RlLmpzLCB3aGVuIGNhbGxpbmcgdGhpcyBkaXJlY3RseSBvdXRzaWRlIG9mIHRoaXMgY2xhc3MsIGB3aW5kb3dgIGlzIG5vdCBkZWZpbmVkLlxuICogICBUaGlzIGhhcHBlbnMgZXZlbiBpZiBqc2RvbSBpcyB1c2VkLlxuICogRm9yIG5vZGUuanMgKyBqc2RvbSwgYHdpbmRvd2AgaXMgYXZhaWxhYmxlIGF0IHRoZSBtb21lbnQgdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZC5cbiAqICAgRm9yIHRoaXMgcmVhc29uLCB0aGUgY2FsbGVkIGlzIHBsYWNlZCB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yLlxuICogRXZlbiB0aGVuLCBgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgc3RpbGwgbmVlZHMgdG8gYmUgYWRkZWQuXG4gKiBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBpdCBoYXBwZW5zIHRoYXQgdGhlIHdpbmRvdyBvYmplY3QgaXMgcmVzZXQgZHVyaW5nIGV4ZWN1dGlvbiwgY2F1c2luZ1xuICogICBhIHJ1bnRpbWUgZXJyb3IgZHVlIHRvIG1pc3NpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZSgpYC4gVGhpcyBuZWVkcyB0byBiZSBjb21wZW5zYXRlZCBmb3IsXG4gKiAgIHNlZSBgX3JlcXVlc3ROZXh0RnJhbWUoKWAuXG4gKiBTaW5jZSB0aGlzIGlzIGEgZ2xvYmFsIG9iamVjdCwgaXQgbWF5IGFmZmVjdCBvdGhlciBtb2R1bGVzIGJlc2lkZXMgYE5ldHdvcmtgLiBXaXRoIG5vcm1hbFxuICogICB1c2FnZSwgdGhpcyBkb2VzIG5vdCBjYXVzZSBhbnkgcHJvYmxlbXMuIER1cmluZyB1bml0IHRlc3RpbmcsIGVycm9ycyBtYXkgb2NjdXIuIFRoZXNlIGhhdmVcbiAqICAgYmVlbiBjb21wZW5zYXRlZCBmb3IsIHNlZSBjb21tZW50IGJsb2NrIGluIF9yZXF1ZXN0TmV4dEZyYW1lKCkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfaW5pdFJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHtcbiAgdmFyIGZ1bmM7XG5cbiAgaWYgKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZnVuYyA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyB3aW5kb3cgb3IgbWV0aG9kIG5vdCBwcmVzZW50LCBzZXR0aW5nIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIkNhbGxlZCBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuYztcbiAgfVxufVxuLyoqXG4gKiBUaGUgY2FudmFzIHJlbmRlcmVyXG4gKi9cblxuXG52YXIgQ2FudmFzUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoYm9keSwgY2FudmFzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgIF9pbml0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICB0aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhc1JlbmRlcmVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBfY29udGV4dDI7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRyYWdFbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInpvb21cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChfdGhpcy56b29tVGltZW91dElkKTtcbiAgICAgICAgX3RoaXMuem9vbVRpbWVvdXRJZCA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgICAgX3RoaXMuem9vbWluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0ID0gX3RoaXMuX3JlcXVlc3RSZWRyYXcpLmNhbGwoX2NvbnRleHQsIF90aGlzKSgpO1xuICAgICAgICB9LCAyNTApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNpemVOb2Rlc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9yZXNpemVOb2RlcygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVuZGVyaW5nQWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgICAgIF90aGlzLl9yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9ibG9ja1JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2FsbG93UmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVxdWVzdFJlZHJhd1wiLCBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5fcmVxdWVzdFJlZHJhdykuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3N0YXJ0UmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgKz0gMTtcbiAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RvcFJlbmRlcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzIC09IDE7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IF90aGlzLnJlbmRlclJlcXVlc3RzID4gMDtcbiAgICAgICAgX3RoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKF90aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmllbGRzID0gW1wiaGlkZUVkZ2VzT25EcmFnXCIsIFwiaGlkZUVkZ2VzT25ab29tXCIsIFwiaGlkZU5vZGVzT25EcmFnXCJdO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgZHJhd2luZyBvZiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSBjYWxsYmFjayB3aGVuIHRoZSBuZXh0IGZyYW1lIGNhbiBvciB3aWxsIGJlIGRyYXduLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSB0aW1lb3V0IGNhc2Ugb25seSwgd2FpdCB0aGlzIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb24gfCB1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0TmV4dEZyYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0TmV4dEZyYW1lKGNhbGxiYWNrLCBkZWxheSkge1xuICAgICAgLy8gRHVyaW5nIHVuaXQgdGVzdGluZywgaXQgaGFwcGVucyB0aGF0IHRoZSBtb2NrIHdpbmRvdyBvYmplY3QgaXMgcmVzZXQgd2hpbGVcbiAgICAgIC8vIHRoZSBuZXh0IGZyYW1lIGlzIHN0aWxsIHBlbmRpbmcuIFRoZW4sIGVpdGhlciAnd2luZG93JyBpcyBub3QgcHJlc2VudCwgb3JcbiAgICAgIC8vICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKScgaXMgbm90IHByZXNlbnQgYmVjYXVzZSBpdCBpcyBub3QgZGVmaW5lZCBvbiB0aGVcbiAgICAgIC8vIG1vY2sgd2luZG93IG9iamVjdC5cbiAgICAgIC8vXG4gICAgICAvLyBBcyBhIGNvbnNlcXVlbmNlLCB1bnJlbGF0ZWQgdW5pdCB0ZXN0cyBtYXkgYXBwZWFyIHRvIGZhaWwsIGV2ZW4gaWYgdGhlIHByb2JsZW1cbiAgICAgIC8vIGRlc2NyaWJlZCBoYXBwZW5zIGluIHRoZSBjdXJyZW50IHVuaXQgdGVzdC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGlzIG5vdCBzb21ldGhpbmcgdGhhdCB3aWxsIGhhcHBlbiBpbiBub3JtYWwgb3BlcmF0aW9uLCBidXQgd2Ugc3RpbGwgbmVlZFxuICAgICAgLy8gdG8gdGFrZSBpdCBpbnRvIGFjY291bnQuXG4gICAgICAvL1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjsgLy8gRG9pbmcgYGlmICh3aW5kb3cgPT09IHVuZGVmaW5lZClgIGRvZXMgbm90IHdvcmsgaGVyZSFcblxuICAgICAgdmFyIHRpbWVyO1xuICAgICAgdmFyIG15V2luZG93ID0gd2luZG93OyAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHJlZHVjZSB0aGUgcG9zc2liaWxpdHkgdGhhdCAnd2luZG93JyBpcyByZXNldFxuICAgICAgLy8gd2hpbGUgcnVubmluZyB0aGlzIG1ldGhvZC5cblxuICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHdhaXQgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhbmQgcGVyZm9ybSB0aGUgYW5pbWF0aW9uIHN0ZXAgZnVuY3Rpb25cbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0JDEoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChteVdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICB0aW1lciA9IG15V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpbWVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRSZW5kZXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0UmVuZGVyaW5nKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHRoaXMuX3JlcXVlc3ROZXh0RnJhbWUoYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMuX3JlbmRlclN0ZXApLmNhbGwoX2NvbnRleHQzLCB0aGlzKSwgdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW5kZXJTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJTdGVwKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSByZW5kZXJUaW1lciBzbyBhIG5ldyBzY2hlZHVsZWQgYW5pbWF0aW9uIHN0ZXAgY2FuIGJlIHNldFxuICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcblxuICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICogY2hhcnQgd2lsbCBiZSByZXNpemVkIHRvby5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic2V0U2l6ZVwiKTtcblxuICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWVzdFJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdFJlZHJhdygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5yZWRyYXdSZXF1ZXN0ZWQgIT09IHRydWUgJiYgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlICYmIHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3ROZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fcmVkcmF3KGZhbHNlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZGRlbj1mYWxzZV0gfCBVc2VkIHRvIGdldCB0aGUgZmlyc3QgZXN0aW1hdGUgb2YgdGhlIG5vZGUgc2l6ZXMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgdGhlIG5vZGVzIGFyZSBkcmF3biBhZnRlciB3aGljaCB0aGV5IGFyZSBxdWlja2x5IGRyYXduIG92ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhdygpIHtcbiAgICAgIHZhciBoaWRkZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFJlZHJhd1wiKTtcbiAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRyYXdMYXRlciA9IHtcbiAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbHM6IG51bGxcbiAgICAgICAgfTsgLy8gd2hlbiB0aGUgY29udGFpbmVyIGRpdiB3YXMgaGlkZGVuLCB0aGlzIGZpeGVzIGl0IGJhY2sgdXAhXG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy53aWR0aCA9PT0gMCB8fCB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7IC8vIGNsZWFyIHRoZSBjYW52YXNcblxuICAgICAgICB2YXIgdyA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpOyAvLyBpZiB0aGUgZGl2IGlzIGhpZGRlbiwgd2Ugc3RvcCB0aGUgcmVkcmF3IGhlcmUgZm9yIHBlcmZvcm1hbmNlLlxuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy5mcmFtZS5jbGllbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBzZXQgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cblxuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSk7XG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJiZWZvcmVEcmF3aW5nXCIsIGN0eCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmICgodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnID09PSBmYWxzZSkgJiYgKHRoaXMuem9vbWluZyA9PT0gZmFsc2UgfHwgdGhpcy56b29taW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPblpvb20gPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0VkZ2VzKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVOb2Rlc09uRHJhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2RyYXdOb2RlcyA9IHRoaXMuX2RyYXdOb2RlcyhjdHgsIGhpZGRlbiksXG4gICAgICAgICAgICAgIGRyYXdFeHRlcm5hbExhYmVscyA9IF90aGlzJF9kcmF3Tm9kZXMuZHJhd0V4dGVybmFsTGFiZWxzO1xuXG4gICAgICAgICAgZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVscyA9IGRyYXdFeHRlcm5hbExhYmVscztcbiAgICAgICAgfSAvLyBkcmF3IHRoZSBhcnJvd3MgbGFzdCBzbyB0aGV5IHdpbGwgYmUgYXQgdGhlIHRvcFxuXG5cbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uRHJhZyA9PT0gZmFsc2UpICYmICh0aGlzLnpvb21pbmcgPT09IGZhbHNlIHx8IHRoaXMuem9vbWluZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25ab29tID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdBcnJvd3MoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVscyAhPSBudWxsKSB7XG4gICAgICAgICAgZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVscygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uQm94KGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhZnRlckRyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpOyAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAoaGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZU5vZGVzKCkge1xuICAgICAgdGhpcy5jYW52YXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSk7XG4gICAgICBjdHguc2NhbGUodGhpcy5ib2R5LnZpZXcuc2NhbGUsIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlOyAvLyByZXNpemUgYWxsIG5vZGVzXG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgbm9kZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuXG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIDJEIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Fsd2F5c1Nob3ddXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd05vZGVzKGN0eCkge1xuICAgICAgdmFyIGFsd2F5c1Nob3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcbiAgICAgIHZhciBob3ZlcmVkID0gW107XG4gICAgICB2YXIgbWFyZ2luID0gMjA7XG4gICAgICB2YXIgdG9wTGVmdCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogLW1hcmdpbixcbiAgICAgICAgeTogLW1hcmdpblxuICAgICAgfSk7XG4gICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCArIG1hcmdpbixcbiAgICAgICAgeTogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCArIG1hcmdpblxuICAgICAgfSk7XG4gICAgICB2YXIgdmlld2FibGVBcmVhID0ge1xuICAgICAgICB0b3A6IHRvcExlZnQueSxcbiAgICAgICAgbGVmdDogdG9wTGVmdC54LFxuICAgICAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgICAgIHJpZ2h0OiBib3R0b21SaWdodC54XG4gICAgICB9O1xuICAgICAgdmFyIF9kcmF3RXh0ZXJuYWxMYWJlbHMgPSBbXTsgLy8gZHJhdyB1bnNlbGVjdGVkIG5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tfaV1dOyAvLyBzZXQgc2VsZWN0ZWQgYW5kIGhvdmVyZWQgbm9kZXMgYXNpZGVcblxuICAgICAgICBpZiAobm9kZS5ob3Zlcikge1xuICAgICAgICAgIGhvdmVyZWQucHVzaChub2RlSW5kaWNlc1tfaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgc2VsZWN0ZWQucHVzaChub2RlSW5kaWNlc1tfaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbHdheXNTaG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZHJhd0xhdGVyID0gbm9kZS5kcmF3KGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfZHJhd0V4dGVybmFsTGFiZWxzLnB1c2goZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aCh2aWV3YWJsZUFyZWEpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2RyYXdMYXRlciA9IG5vZGUuZHJhdyhjdHgpO1xuXG4gICAgICAgICAgICBpZiAoX2RyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS51cGRhdGVCb3VuZGluZ0JveChjdHgsIG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkLmxlbmd0aDtcbiAgICAgIHZhciBob3ZlcmVkTGVuZ3RoID0gaG92ZXJlZC5sZW5ndGg7IC8vIGRyYXcgdGhlIHNlbGVjdGVkIG5vZGVzIG9uIHRvcFxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0ZWRMZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gbm9kZXNbc2VsZWN0ZWRbaV1dO1xuXG4gICAgICAgIHZhciBfZHJhd0xhdGVyMiA9IG5vZGUuZHJhdyhjdHgpO1xuXG4gICAgICAgIGlmIChfZHJhd0xhdGVyMi5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKF9kcmF3TGF0ZXIyLmRyYXdFeHRlcm5hbExhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBkcmF3IGhvdmVyZWQgbm9kZXMgYWJvdmUgZXZlcnl0aGluZyBlbHNlOiBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vdmlzanMvdmlzLW5ldHdvcmsvaXNzdWVzLzIyNlxuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBob3ZlcmVkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2hvdmVyZWRbaV1dO1xuXG4gICAgICAgIHZhciBfZHJhd0xhdGVyMyA9IG5vZGUuZHJhdyhjdHgpO1xuXG4gICAgICAgIGlmIChfZHJhd0xhdGVyMy5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKF9kcmF3TGF0ZXIzLmRyYXdFeHRlcm5hbExhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbHM6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVscygpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShfZHJhd0V4dGVybmFsTGFiZWxzKSxcbiAgICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGRyYXcgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIDJEIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0VkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RWRnZXMoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZS5kcmF3KGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBhcnJvd3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIDJEIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0Fycm93c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0Fycm93cyhjdHgpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlLmRyYXdBcnJvd3MoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgcmVxdWlyZXMgYSBzZXRUaW1lb3V0IG9yIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBUaGlzIHdhcyByZXF1aXJlZCBiZWNhdXNlXG4gICAgICogc29tZSBpbXBsZW1lbnRhdGlvbnMgKHNhZmFyaSBhbmQgSUU5KSBkaWQgbm90IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUJyb3dzZXJNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUJyb3dzZXJNZXRob2QoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgYnJvd3NlclR5cGUgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGluZGV4T2YoYnJvd3NlclR5cGUpLmNhbGwoYnJvd3NlclR5cGUsIFwibXNpZSA5LjBcIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4T2YoYnJvd3NlclR5cGUpLmNhbGwoYnJvd3NlclR5cGUsIFwic2FmYXJpXCIpICE9IC0xKSB7XG4gICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgaWYgKGluZGV4T2YoYnJvd3NlclR5cGUpLmNhbGwoYnJvd3NlclR5cGUsIFwiY2hyb21lXCIpIDw9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBzZWxlY3Rpb24gYm94XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdTZWxlY3Rpb25Cb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdTZWxlY3Rpb25Cb3goY3R4KSB7XG4gICAgICBpZiAodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQueCAtIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kLnkgLSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0Lnk7XG4gICAgICAgIGN0eC5yZWN0KHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueCwgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgxNTEsIDE5NCwgMjUyLCAwLjIpXCI7XG4gICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LngsIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgxNTEsIDE5NCwgMjUyLCAxKVwiO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZhc1JlbmRlcmVyO1xufSgpO1xuXG52YXIgcGF0aCQxID0gcGF0aCR5O1xudmFyIHNldEludGVydmFsJDEgPSBwYXRoJDEuc2V0SW50ZXJ2YWw7XG5cbnZhciBzZXRJbnRlcnZhbCA9IHNldEludGVydmFsJDE7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAqXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmZ1bmN0aW9uIG9uVG91Y2goaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBoYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn1cbi8qKlxuICogUmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYWZ0ZXIgYSBnZXN0dXJlXG4gKlxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICogQHJldHVybnMgeyp9XG4gKi9cblxuZnVuY3Rpb24gb25SZWxlYXNlKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmluYWwpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGhhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgbWFpbiBmcmFtZSBmb3IgdGhlIE5ldHdvcmsuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIG9uY2Ugd2hlbiBhIE5ldHdvcmsgb2JqZWN0IGlzIGNyZWF0ZWQuIFRoZSBmcmFtZVxuICogY29udGFpbnMgYSBjYW52YXMsIGFuZCB0aGlzIGNhbnZhcyBjb250YWlucyBhbGwgb2JqZWN0cyBsaWtlIHRoZSBheGlzIGFuZFxuICogbm9kZXMuXG4gKi9cblxudmFyIENhbnZhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzKGJvZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gMTtcbiAgICB0aGlzLmNhbWVyYVN0YXRlID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzVmlld0NlbnRlciA9IHt9O1xuICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCJcbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDYW52YXMsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIF9jb250ZXh0O1xuXG4gICAgICAvLyBiaW5kIHRoZSBldmVudHNcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uY2UoXCJyZXNpemVcIiwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggPSBvYmoud2lkdGggKiAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgIF90aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ID0gb2JqLmhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInNldFNpemVcIiwgYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5zZXRTaXplKS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5oYW1tZXJGcmFtZS5kZXN0cm95KCk7XG5cbiAgICAgICAgX3RoaXMuaGFtbWVyLmRlc3Ryb3koKTtcblxuICAgICAgICBfdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiYXV0b1Jlc2l6ZVwiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9IC8vIEF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gY2hhbmdpbmcgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG5cblxuICAgICAgdGhpcy5fY2xlYW5VcCgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZXNpemUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgICBpZiAod2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgLy8gZGVjZW50IGJyb3dzZXJzLCBpbW1lZGlhdGUgcmVhY3Rpb25zXG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gX3RoaXMyLnNldFNpemUoKTtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZTtcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGZyYW1lKTtcblxuICAgICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZnJhbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElFMTEsIGNvbnRpbm91cyBwb2xsaW5nXG4gICAgICAgICAgdmFyIHJlc2l6ZVRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpczIuc2V0U2l6ZSgpO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDAwKTtcblxuICAgICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlc2l6ZVRpbWVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBBdXRvbWF0aWNhbGx5IGFkYXB0IHRvIGNoYW5naW5nIHNpemUgb2YgdGhlIGJyb3dzZXIuXG5cblxuICAgICAgICB2YXIgcmVzaXplRnVuY3Rpb24gPSBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5fb25SZXNpemUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKTtcblxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJyZXNpemVcIiwgcmVzaXplRnVuY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwicmVzaXplXCIsIHJlc2l6ZUZ1bmN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW5VcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW5VcCgpIHtcbiAgICAgIHZhciBfY29udGV4dDMsIF9jb250ZXh0NCwgX2NvbnRleHQ1O1xuXG4gICAgICBmb3JFYWNoJDIoX2NvbnRleHQzID0gcmV2ZXJzZShfY29udGV4dDQgPSBzcGxpY2UkMShfY29udGV4dDUgPSB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzKS5jYWxsKF9jb250ZXh0NSwgMCkpLmNhbGwoX2NvbnRleHQ0KSkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbmQgc3RvcmUgdGhlIGNhbWVyYVN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89dGhpcy5waXhlbFJhdGlvXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2FtZXJhU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENhbWVyYVN0YXRlKCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucGl4ZWxSYXRpbztcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyBwaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyBwaXhlbFJhdGlvLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FtZXJhU3RhdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0Q2FtZXJhU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENhbWVyYVN0YXRlKCkge1xuICAgICAgaWYgKHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAhPT0gMCAmJiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgIT09IDAgJiYgdGhpcy5waXhlbFJhdGlvICE9PSAwICYmIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA+IDAgJiYgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA+IDApIHtcbiAgICAgICAgdmFyIHdpZHRoUmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodDtcbiAgICAgICAgdmFyIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZTtcblxuICAgICAgICBpZiAod2lkdGhSYXRpbyAhPSAxICYmIGhlaWdodFJhdGlvICE9IDEpIHtcbiAgICAgICAgICBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgKiAwLjUgKiAod2lkdGhSYXRpbyArIGhlaWdodFJhdGlvKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aFJhdGlvICE9IDEpIHtcbiAgICAgICAgICBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgKiB3aWR0aFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKGhlaWdodFJhdGlvICE9IDEpIHtcbiAgICAgICAgICBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgKiBoZWlnaHRSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gbmV3U2NhbGU7IC8vIHRoaXMgY29tZXMgZnJvbSB0aGUgdmlldyBtb2R1bGUuXG5cbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3Q2VudGVyID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICAgIHg6IGN1cnJlbnRWaWV3Q2VudGVyLnggLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLngsXG4gICAgICAgICAgeTogY3VycmVudFZpZXdDZW50ZXIueSAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ByZXBhcmVWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZVZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIFwicHhcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHZhbHVlKS5jYWxsKHZhbHVlLCBcIiVcIikgIT09IC0xIHx8IGluZGV4T2YodmFsdWUpLmNhbGwodmFsdWUsIFwicHhcIikgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4T2YodmFsdWUpLmNhbGwodmFsdWUsIFwiJVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHVzZSB0aGUgdmFsdWUgc3VwcGxpZWQgZm9yIHdpZHRoIG9yIGhlaWdodDpcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBIVE1MXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgICAgd2hpbGUgKHRoaXMuYm9keS5jb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHRoaXMuYm9keS5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5ib2R5LmNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLW5ldHdvcmtcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgIHRoaXMuZnJhbWUudGFiSW5kZXggPSAwOyAvLyB0YWIgaW5kZXggaXMgcmVxdWlyZWQgZm9yIGtleWNoYXJtIHRvIGJpbmQga2V5c3Ryb2tlcyB0byB0aGUgZGl2IGluc3RlYWQgb2YgdGhlIHdpbmRvd1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgICAgICBub0NhbnZhcy5pbm5lclRleHQgPSBcIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIH0gLy8gYWRkIHRoZSBmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcblxuXG4gICAgICB0aGlzLmJvZHkuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSAxO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBiaW5kcyBoYW1tZXIsIGl0IGNhbiBiZSByZXBlYXRlZCBvdmVyIGFuZCBvdmVyIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmluZEhhbW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9OyAvLyBpbml0IGhhbW1lclxuXG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZS5jYW52YXMpO1xuICAgICAgdGhpcy5oYW1tZXIuZ2V0KFwicGluY2hcIikuc2V0KHtcbiAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICB9KTsgLy8gZW5hYmxlIHRvIGdldCBiZXR0ZXIgcmVzcG9uc2UsIHRvZG86IHRlc3Qgb24gbW9iaWxlLlxuXG4gICAgICB0aGlzLmhhbW1lci5nZXQoXCJwYW5cIikuc2V0KHtcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fQUxMXG4gICAgICB9KTtcbiAgICAgIG9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJ0YXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJkb3VibGV0YXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwcmVzc1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5zdGFydFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbm1vdmVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyhldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuZW5kXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBpbmNoXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoKGV2ZW50KTtcbiAgICAgIH0pOyAvLyBUT0RPOiBuZWF0bHkgY2xlYW51cCB0aGVzZSBoYW5kbGVycyB3aGVuIHJlLWNyZWF0aW5nIHRoZSBDYW52YXMsIElGIHRoZXNlIGFyZSBkb25lIHdpdGggaGFtbWVyLCBldmVudC5zdG9wUHJvcGFnYXRpb24gd2lsbCBub3Qgd29yaz9cblxuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZSk7XG4gICAgICBvblJlbGVhc2UodGhpcy5oYW1tZXJGcmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZShldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHNpemUgZm9yIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGggICBXaWR0aCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAoZm9yIGV4YW1wbGUgJzgwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICc1MCUnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgIEhlaWdodCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAgKGZvciBleGFtcGxlICc0MDBweCdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciAnMzAlJylcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLmhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fcHJlcGFyZVZhbHVlKHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IHRoaXMuX3ByZXBhcmVWYWx1ZShoZWlnaHQpO1xuICAgICAgdmFyIGVtaXRFdmVudCA9IGZhbHNlO1xuICAgICAgdmFyIG9sZFdpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGg7XG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0OyAvLyB1cGRhdGUgdGhlIHBpeGVsIHJhdGlvXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogQ29tbWVudCBpbiBmb2xsb3dpbmcgaXMgcmF0aGVyIGluY29uc2lzdGVudDsgdGhpcyBpcyB0aGUgT05MWSBwbGFjZSBpbiB0aGUgY29kZVxuICAgICAgLy8gICAgICAgd2hlcmUgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwaXhlbCByYXRpbyBjb3VsZCBjaGFuZ2UgYXQgcnVudGltZS5cbiAgICAgIC8vICAgICAgIFRoZSBvbmx5IHdheSBJIGNhbiB0aGluayBvZiB0aGlzIGhhcHBlbmluZyBpcyBhIHJvdGF0aW5nIHNjcmVlbiBvciB0YWJsZXQ7IGJ1dCB0aGVuXG4gICAgICAvLyAgICAgICB0aGVyZSBzaG91bGQgYmUgYSBtZWNoYW5pc20gZm9yIHJlbG9hZGluZyB0aGUgZGF0YSAoVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBwcmVzZW50KS5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgICBJZiB0aGUgYXNzdW1wdGlvbiBpcyB0cnVlIChpLmUuIHBpeGVsIHJhdGlvIGNhbiBjaGFuZ2UgYXQgcnVudGltZSksIHRoZW4gKmFsbCogdXNhZ2VcbiAgICAgIC8vICAgICAgIG9mIHBpeGVsIHJhdGlvIG11c3QgYmUgb3ZlcmhhdWxlZCBmb3IgdGhpcy5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgICBGb3IgdGhlIHRpbWUgYmVpbmcsIEkgd2lsbCBodW1vciB0aGUgYXNzdW1wdGlvbiBoZXJlLCBhbmQgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGUgYXNzdW1lIGl0IGlzXG4gICAgICAvLyAgICAgICBjb25zdGFudC5cblxuICAgICAgdmFyIHByZXZpb3VzUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87IC8vIHdlIGNhY2hlIHRoaXMgYmVjYXVzZSB0aGUgY2FtZXJhIHN0YXRlIHN0b3JhZ2UgbmVlZHMgdGhlIG9sZCB2YWx1ZVxuXG4gICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzVmlld0NlbnRlciA9IHtcbiAgICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudFdpZHRoLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHdvdWxkIGFkYXB0IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHRvIHRoZSB3aWR0aCBmcm9tIDEwMCUgaWYgYW5kIG9ubHkgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBjaGFuZ2UuXG4gICAgICAgIHZhciBuZXdXaWR0aCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pOyAvLyBzdG9yZSB0aGUgY2FtZXJhIGlmIHRoZXJlIGlzIGEgY2hhbmdlIGluIHNpemUuXG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoICE9PSBuZXdXaWR0aCB8fCB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuX2dldENhbWVyYVN0YXRlKHByZXZpb3VzUmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoICE9PSBuZXdXaWR0aCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbWl0RXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2l6ZVwiLCB7XG4gICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIG9sZFdpZHRoOiBNYXRoLnJvdW5kKG9sZFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRIZWlnaHQ6IE1hdGgucm91bmQob2xkSGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKVxuICAgICAgICB9KTsgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cblxuICAgICAgICB0aGlzLl9zZXRDYW1lcmFTdGF0ZSgpO1xuICAgICAgfSAvLyBzZXQgaW5pdGlhbGl6ZWQgc28gdGhlIGdldCBhbmQgc2V0IGNhbWVyYSB3aWxsIHdvcmsgZnJvbSBub3cgb24uXG5cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gZW1pdEV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHBpeGVsIHJhdGlvIGZvciB2YXJpb3VzIGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZVBpeGVsUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZVBpeGVsUmF0aW8oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZheCBjb250ZXh0XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtZXJhdG9yID0gMTtcblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSBkb2Vzbid0IHdvcmsgaGVyZSFcbiAgICAgICAgLy8gUHJvdGVjdGlvbiBkdXJpbmcgdW5pdCB0ZXN0cywgd2hlcmUgJ3dpbmRvdycgY2FuIGJlIG1pc3NpbmdcbiAgICAgICAgbnVtZXJhdG9yID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbm9taW5hdG9yID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6eSBkZXRlcm1pbmF0aW9uIG9mIHBpeGVsIHJhdGlvLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRQaXhlbFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQaXhlbFJhdGlvKCkge1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gdGhpcy5fZGV0ZXJtaW5lUGl4ZWxSYXRpbygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgY29udGFpbmVkIGNvbnRleHQsIGJhc2VkIG9uIGl0cyBwaXhlbFJhdGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNmb3JtKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dFwiKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgKiB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfWGNvbnZlcnRET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRET010b0NhbnZhcyh4KSB7XG4gICAgICByZXR1cm4gKHggLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX1hjb252ZXJ0Q2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0Q2FudmFzVG9ET00oeCkge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLng7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfWWNvbnZlcnRET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICByZXR1cm4gKHkgLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX1ljb252ZXJ0Q2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1ljb252ZXJ0Q2FudmFzVG9ET00oeSkge1xuICAgICAgcmV0dXJuIHkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbnZhc1RvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbnZhc1RvRE9NKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fWGNvbnZlcnRDYW52YXNUb0RPTShwb3MueCksXG4gICAgICAgIHk6IHRoaXMuX1ljb252ZXJ0Q2FudmFzVG9ET00ocG9zLnkpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIERPTXRvQ2FudmFzKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb3MueCksXG4gICAgICAgIHk6IHRoaXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9zLnkpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52YXM7XG59KCk7XG5cbi8qKlxyXG4gKiBWYWxpZGF0ZSB0aGUgZml0IG9wdGlvbnMsIHJlcGxhY2UgbWlzc2luZyBvcHRpb25hbCB2YWx1ZXMgYnkgZGVmYXVsdHMgZXRjLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmF3T3B0aW9ucyAtIFRoZSByYXcgb3B0aW9ucy5cclxuICogQHBhcmFtIGFsbE5vZGVJZHMgLSBBbGwgbm9kZSBpZHMgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbm9kZXMgYXJlIG9taXR0ZWQgaW5cclxuICogdGhlIHJhdyBvcHRpb25zLlxyXG4gKiBAcmV0dXJucyBPcHRpb25zIHdpdGggZXZlcnl0aGluZyBmaWxsZWQgaW4gYW5kIHZhbGlkYXRlZC5cclxuICovXG5mdW5jdGlvbiBub3JtYWxpemVGaXRPcHRpb25zKHJhd09wdGlvbnMsIGFsbE5vZGVJZHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhc3NpZ24kMih7XG4gICAgbm9kZXM6IGFsbE5vZGVJZHMsXG4gICAgbWluWm9vbUxldmVsOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgIG1heFpvb21MZXZlbDogMVxuICB9LCByYXdPcHRpb25zICE9PSBudWxsICYmIHJhd09wdGlvbnMgIT09IHZvaWQgMCA/IHJhd09wdGlvbnMgOiB7fSk7XG5cbiAgaWYgKCFpc0FycmF5JDIob3B0aW9ucy5ub2RlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm9kZXMgaGFzIHRvIGJlIGFuIGFycmF5IG9mIGlkcy5cIik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICBvcHRpb25zLm5vZGVzID0gYWxsTm9kZUlkcztcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBvcHRpb25zLm1pblpvb21MZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1pblpvb21MZXZlbCA+IDApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pbiB6b29tIGxldmVsIGhhcyB0byBiZSBhIG51bWJlciBoaWdoZXIgdGhhbiB6ZXJvLlwiKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBvcHRpb25zLm1heFpvb21MZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1pblpvb21MZXZlbCA8PSBvcHRpb25zLm1heFpvb21MZXZlbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF4IHpvb20gbGV2ZWwgaGFzIHRvIGJlIGEgbnVtYmVyIGhpZ2hlciB0aGFuIG1pbiB6b29tIGxldmVsLlwiKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFRoZSB2aWV3XG4gKi9cblxudmFyIFZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gVmlldyhib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXcpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvIHRoaXMucmVuZGVyUmVmcmVzaFJhdGU7XG4gICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVpbnRcIjtcbiAgICB0aGlzLmVhc2luZ1RpbWUgPSAwO1xuICAgIHRoaXMuc291cmNlU2NhbGUgPSAwO1xuICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAwO1xuICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSAwO1xuICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSAwO1xuICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZml0XCIsIGJpbmQkNihfY29udGV4dCA9IHRoaXMuZml0KS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhbmltYXRpb25GaW5pc2hlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwidW5sb2NrTm9kZVwiLCBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5yZWxlYXNlTm9kZSkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhWaWV3LCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHpvb21zIG91dCB0byBmaXQgYWxsIGRhdGEgb24gc2NyZWVuIGJhc2VkIG9uIGFtb3VudCBvZiBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt7bm9kZXM9QXJyYXl9fV1cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRpYWxab29tPWZhbHNlXSAgfCB6b29tIGJhc2VkIG9uIGZpdHRlZCBmb3JtdWxhIG9yIHJhbmdlLCB0cnVlID0gZml0dGVkLCBkZWZhdWx0ID0gZmFsc2U7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbml0aWFsWm9vbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBvcHRpb25zID0gbm9ybWFsaXplRml0T3B0aW9ucyhvcHRpb25zLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgcmFuZ2U7XG4gICAgICB2YXIgem9vbUxldmVsO1xuXG4gICAgICBpZiAoY2FudmFzV2lkdGggPT09IDAgfHwgY2FudmFzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gcG9pbnQgaW4gdHJ5aW5nIHRvIGZpdCBpbnRvIHplcm8gc2l6ZWQgY2FudmFzLiBUaGlzIGNvdWxkXG4gICAgICAgIC8vIHBvdGVudGlhbGx5IGV2ZW4gcmVzdWx0IGluIGludmFsaWQgdmFsdWVzIGJlaW5nIGNvbXB1dGVkLiBGb3IgZXhhbXBsZVxuICAgICAgICAvLyBmb3IgbmV0d29yayB3aXRob3V0IG5vZGVzIGFuZCB6ZXJvIHNpemVkIGNhbnZhcyB0aGUgem9vbSBsZXZlbCB3b3VsZFxuICAgICAgICAvLyBlbmQgdXAgYmVpbmcgY29tcHV0ZWQgYXMgMC8wIHdoaWNoIHJlc3VsdHMgaW4gTmFOLiBJbiBhbnkgb3RoZXIgY2FzZVxuICAgICAgICAvLyB0aGlzIHdvdWxkIGJlIDAvc29tZXRoaW5nIHdoaWNoIGlzIGFnYWluIHBvaW50bGVzcyB0byBjb21wdXRlLlxuICAgICAgICB6b29tTGV2ZWwgPSAxO1xuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxab29tID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG1vcmUgdGhhbiBoYWxmIG9mIHRoZSBub2RlcyBoYXZlIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi4gSWYgc28sIHdlIHVzZSB0aGUgcmFuZ2UsIG5vdCB0aGUgYXBwcm94aW1hdGlvbi5cbiAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA+IDAuNSAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmZpdChvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuICAgICAgICB2YXIgbnVtYmVyT2ZOb2RlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIHpvb21MZXZlbCA9IDEyLjY2MiAvIChudW1iZXJPZk5vZGVzICsgNy40MTQ3KSArIDAuMDk2NDgyMjsgLy8gdGhpcyBpcyBvYnRhaW5lZCBmcm9tIGZpdHRpbmcgYSBkYXRhc2V0IGZyb20gNSBwb2ludHMgd2l0aCBzY2FsZSBsZXZlbHMgdGhhdCBsb29rZWQgZ29vZC5cbiAgICAgICAgLy8gY29ycmVjdCBmb3IgbGFyZ2VyIGNhbnZhc3Nlcy5cblxuICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5taW4oY2FudmFzV2lkdGggLyA2MDAsIGNhbnZhc0hlaWdodCAvIDYwMCk7XG4gICAgICAgIHpvb21MZXZlbCAqPSBmYWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG4gICAgICAgIHZhciB4RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhYIC0gcmFuZ2UubWluWCkgKiAxLjE7XG4gICAgICAgIHZhciB5RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhZIC0gcmFuZ2UubWluWSkgKiAxLjE7XG4gICAgICAgIHZhciB4Wm9vbUxldmVsID0gY2FudmFzV2lkdGggLyB4RGlzdGFuY2U7XG4gICAgICAgIHZhciB5Wm9vbUxldmVsID0gY2FudmFzSGVpZ2h0IC8geURpc3RhbmNlO1xuICAgICAgICB6b29tTGV2ZWwgPSB4Wm9vbUxldmVsIDw9IHlab29tTGV2ZWwgPyB4Wm9vbUxldmVsIDogeVpvb21MZXZlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvb21MZXZlbCA+IG9wdGlvbnMubWF4Wm9vbUxldmVsKSB7XG4gICAgICAgIHpvb21MZXZlbCA9IG9wdGlvbnMubWF4Wm9vbUxldmVsO1xuICAgICAgfSBlbHNlIGlmICh6b29tTGV2ZWwgPCBvcHRpb25zLm1pblpvb21MZXZlbCkge1xuICAgICAgICB6b29tTGV2ZWwgPSBvcHRpb25zLm1pblpvb21MZXZlbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbnRlciA9IE5ldHdvcmtVdGlsLmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBjZW50ZXIsXG4gICAgICAgIHNjYWxlOiB6b29tTGV2ZWwsXG4gICAgICAgIGFuaW1hdGlvbjogb3B0aW9ucy5hbmltYXRpb25cbiAgICAgIH07XG4gICAgICB0aGlzLm1vdmVUbyhhbmltYXRpb25PcHRpb25zKTtcbiAgICB9IC8vIGFuaW1hdGlvblxuXG4gICAgLyoqXG4gICAgICogQ2VudGVyIGEgbm9kZSBpbiB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9uc11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKG5vZGVJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLngsXG4gICAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICBvcHRpb25zLmxvY2tlZE9uTm9kZSA9IG5vZGVJZDtcbiAgICAgICAgdGhpcy5tb3ZlVG8ob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZTogXCIgKyBub2RlSWQgKyBcIiBjYW5ub3QgYmUgZm91bmQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICB8ICBvcHRpb25zLm9mZnNldCAgID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIGluIERPTSBwaXhlbHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5zY2FsZSAgICA9IG51bWJlciAgICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gbW92ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuYW5pbWF0aW9uID0ge2R1cmF0aW9uOm51bWJlciwgZWFzaW5nRnVuY3Rpb246U3RyaW5nfSB8fCBCb29sZWFuICAgLy8gcG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQueCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB4IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSArb3B0aW9ucy5vZmZzZXQueDtcblxuICAgICAgICAgIGlmICghX2lzRmluaXRlKG9wdGlvbnMub2Zmc2V0LngpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwib2Zmc2V0LnhcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC55ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHkgaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueSA9ICtvcHRpb25zLm9mZnNldC55O1xuXG4gICAgICAgICAgaWYgKCFfaXNGaW5pdGUob3B0aW9ucy5vZmZzZXQueSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJvZmZzZXQueVwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm9mZnNldCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi54ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHggaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gK29wdGlvbnMucG9zaXRpb24ueDtcblxuICAgICAgICAgIGlmICghX2lzRmluaXRlKG9wdGlvbnMucG9zaXRpb24ueCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJwb3NpdGlvbi54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeSBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnkgPSArb3B0aW9ucy5wb3NpdGlvbi55O1xuXG4gICAgICAgICAgaWYgKCFfaXNGaW5pdGUob3B0aW9ucy5wb3NpdGlvbi55KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInBvc2l0aW9uLnlcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHRoZSBzY2FsZSBpcyB2YWxpZC5cbiAgICAgICAgb3B0aW9ucy5zY2FsZSA9ICtvcHRpb25zLnNjYWxlO1xuXG4gICAgICAgIGlmICghKG9wdGlvbnMuc2NhbGUgPiAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJzY2FsZVwiIGhhcyB0byBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9IDEwMDA7XG4gICAgICB9IC8vIGRlZmF1bHQgZHVyYXRpb25cblxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVhZFwiO1xuICAgICAgfSAvLyBkZWZhdWx0IGVhc2luZyBmdW5jdGlvblxuXG5cbiAgICAgIHRoaXMuYW5pbWF0ZVZpZXcob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnRpbWUgICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5zY2FsZSAgICA9IG51bWJlciAgICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gYW5pbWF0ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBhbmltYXRlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuZWFzaW5nRnVuY3Rpb24gPSBTdHJpbmcgICAgICAgICAgIC8vIGxpbmVhciwgZWFzZUluUXVhZCwgZWFzZU91dFF1YWQsIGVhc2VJbk91dFF1YWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJbkN1YmljLCBlYXNlT3V0Q3ViaWMsIGVhc2VJbk91dEN1YmljLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWFydCwgZWFzZU91dFF1YXJ0LCBlYXNlSW5PdXRRdWFydCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluUXVpbnQsIGVhc2VPdXRRdWludCwgZWFzZUluT3V0UXVpbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVWaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVWaWV3KG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb247IC8vIHJlbGVhc2UgaWYgc29tZXRoaW5nIGZvY3Vzc2VkIG9uIHRoZSBub2RlXG5cbiAgICAgIHRoaXMucmVsZWFzZU5vZGUoKTtcblxuICAgICAgaWYgKG9wdGlvbnMubG9ja2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSBvcHRpb25zLmxvY2tlZE9uTm9kZTtcbiAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcbiAgICAgIH0gLy8gZm9yY2VmdWxseSBjb21wbGV0ZSB0aGUgb2xkIGFuaW1hdGlvbiBpZiBpdCB3YXMgc3RpbGwgcnVubmluZ1xuXG5cbiAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgIT0gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KHRydWUpOyAvLyBieSBzZXR0aW5nIGVhc2luZ3RpbWUgdG8gMSwgd2UgZmluaXNoIHRoZSBhbmltYXRpb24uXG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5zb3VyY2VTY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdGhpcy5zb3VyY2VUcmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdGhpcy50YXJnZXRTY2FsZSA9IG9wdGlvbnMuc2NhbGU7IC8vIHNldCB0aGUgc2NhbGUgc28gdGhlIHZpZXdDZW50ZXIgaXMgYmFzZWQgb24gdGhlIGNvcnJlY3Qgem9vbSBsZXZlbC4gVGhpcyBpcyBvdmVycmlkZGVuIGluIHRoZSB0cmFuc2l0aW9uUmVkcmF3XG4gICAgICAvLyBidXQgYXQgbGVhc3QgdGhlbiB3ZSdsbCBoYXZlIHRoZSB0YXJnZXQgdHJhbnNpdGlvblxuXG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICB2YXIgdmlld0NlbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBvcHRpb25zLnBvc2l0aW9uLngsXG4gICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG9wdGlvbnMucG9zaXRpb24ueVxuICAgICAgfTtcbiAgICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy50YXJnZXRTY2FsZSArIG9wdGlvbnMub2Zmc2V0LngsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy50YXJnZXRTY2FsZSArIG9wdGlvbnMub2Zmc2V0LnlcbiAgICAgIH07IC8vIGlmIHRoZSB0aW1lIGlzIHNldCB0byAwLCBkb24ndCBkbyBhbiBhbmltYXRpb25cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IGJpbmQkNihfY29udGV4dDMgPSB0aGlzLl9sb2NrZWRSZWRyYXcpLmNhbGwoX2NvbnRleHQzLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRoaXMudGFyZ2V0VHJhbnNsYXRpb247XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQ0O1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gKDYwICogb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gKiAwLjAwMSkgfHwgMSAvIDYwOyAvLyA2MCBmb3IgNjAgc2Vjb25kcywgMC4wMDEgZm9yIG1pbGxpJ3NcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gYmluZCQ2KF9jb250ZXh0NCA9IHRoaXMuX3RyYW5zaXRpb25SZWRyYXcpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdXNlZCB0byBhbmltYXRlIHNtb290aGx5IGJ5IGhpamFja2luZyB0aGUgcmVkcmF3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2NrZWRSZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvY2tlZFJlZHJhdygpIHtcbiAgICAgIHZhciBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS54LFxuICAgICAgICB5OiB0aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueVxuICAgICAgfTtcbiAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHtcbiAgICAgICAgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgIHg6IHZpZXdDZW50ZXIueCAtIG5vZGVQb3NpdGlvbi54LFxuICAgICAgICB5OiB2aWV3Q2VudGVyLnkgLSBub2RlUG9zaXRpb24ueVxuICAgICAgfTtcbiAgICAgIHZhciBzb3VyY2VUcmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHRhcmdldFRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiBzb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LngsXG4gICAgICAgIHk6IHNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0gdGFyZ2V0VHJhbnNsYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBzdGF0ZSBvZiBhIGxvY2tlZCBvbiBOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWxlYXNlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlTm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpbmlzaGVkPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdHJhbnNpdGlvblJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNpdGlvblJlZHJhdygpIHtcbiAgICAgIHZhciBmaW5pc2hlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICB0aGlzLmVhc2luZ1RpbWUgKz0gdGhpcy5hbmltYXRpb25TcGVlZDtcbiAgICAgIHRoaXMuZWFzaW5nVGltZSA9IGZpbmlzaGVkID09PSB0cnVlID8gMS4wIDogdGhpcy5lYXNpbmdUaW1lO1xuICAgICAgdmFyIHByb2dyZXNzID0gZWFzaW5nRnVuY3Rpb25zW3RoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb25dKHRoaXMuZWFzaW5nVGltZSk7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMuc291cmNlU2NhbGUgKyAodGhpcy50YXJnZXRTY2FsZSAtIHRoaXMuc291cmNlU2NhbGUpICogcHJvZ3Jlc3M7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54ICsgKHRoaXMudGFyZ2V0VHJhbnNsYXRpb24ueCAtIHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCkgKiBwcm9ncmVzcyxcbiAgICAgICAgeTogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55ICsgKHRoaXMudGFyZ2V0VHJhbnNsYXRpb24ueSAtIHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSkgKiBwcm9ncmVzc1xuICAgICAgfTsgLy8gY2xlYW51cFxuXG4gICAgICBpZiAodGhpcy5lYXNpbmdUaW1lID49IDEuMCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcblxuICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ1O1xuXG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBiaW5kJDYoX2NvbnRleHQ1ID0gdGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKF9jb250ZXh0NSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhbmltYXRpb25GaW5pc2hlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld1Bvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlldztcbn0oKTtcblxudmFyIGNzc18yNDh6JDEgPSBcImRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24ge1xcbiAgd2lkdGg6IDM0cHg7XFxuICBoZWlnaHQ6IDM0cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDE3cHg7XFxuICBib3JkZXItcmFkaXVzOiAxN3B4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMnB4IDJweDtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uOmhvdmVyIHtcXG4gIGJveC1zaGFkb3c6IDAgMCAzcHggM3B4IHJnYmEoNTYsIDIwNywgMjEsIDAuMyk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b246YWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IDAgMCAxcHggM3B4IHJnYmEoNTYsIDIwNywgMjEsIDAuOTUpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy11cCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJwaEpSRUZVZU5xY1YydHdVOWNSL25iUGxWVEh4cEtSYk5uQkx5RWJQeUppc0xFY1B3Z3dVTUtRdGpOSkF6Tkpaa2dOTkpPbUphWkFhREtseGFYRFRJQkFjSnRPT3pTWUtTa2RpaW1oQWRJTWp5VDRiWWdCWXhBMkJnY1VRUExyQ2lHRFI0cXQyeCt5WFRBU0Z0MS85NTdkN3p0M3ozZDM5eERDTVFXVWZnQXovUkkvVDRwU1RBSnBBR0w4ckVDQVhYN1FGUUdxOXdPSE94WU8xb0NnakFkSmoxd3RCMDk1R2l2OVRGdVpBSVdIQXppQVRNUGhUQXdpSGdVa1lQWEZKdTkybE1QLzJNVHBCMUFLVUNWRWdOQWNsZVVvMU0rMkY4VE82Y3JTVG5jYjFRbGVBT2oyT1RTWDNHZTFwK1ZhNDJtNUpybnpibnNDRThPditFSGdwYTBMUEx2Q0pqWi93aHVJbE44d0FjWEcrZTFMVW45aG0yMzhRVTg0cDFMZDgzbnNYdnVPN0xxK0x6S1lHQVQ2L2RuNThtL0hKVFlmNE8zRVNoa1Q4SXJwemFiMVV6OXNHZXZUNSt0V24rajZOQjRBNWhwLzVOU3I0M3hqZmQ1clc1dFQ5ZTNPQWhDQmlDdWE1L1dzREVscy9oZHZZa2xaU3dEZWZtclQ4ZVhtdHp1RGtiNVlaMzNwOW5keWxJQ0FWald4ZjM5eHcvNWc1THV2LzlIODRaV05jd05FeXBaVDg3clhqcXlKQjg1VVlETUpZTjNVN1VkTEo2LzZKbGdxVjUxN3RlUnFmOXVUbHVnOGUxekVrMjdIZ0QyMm85OFdzVEJoOGZXeHZqbTZBcGRPTmJHdnNlOExNNU5VUE9tMUNmYWJ1ejNuQUNBZ3hYMFFFRlRKQW5qTnZMSitTZXBiMTRLUkhuTitFdisxWEpPaFpzM1F1MW1iRzk3SjJOUWdzWHJvYTFkdHhyR3VmOGNIaTFtVXRQVGF5MGx2MURNSlNDUlZMdG9YK0ZnR2dEUU55c0JBY2V6ODlsOW5iYnNRU2ppN3JsWGtFaGpQeGIvUWF0SE9jRnUwTTl6ejQxOW9GU1Joai8zUHVhSGl5cWFzdjFDb245Tkd4SEFZVXNvQ3hBcUltYllTZ0NXbUZiWlF3ZHN1cjdOMGVDNG02dFQ2L2pVWjc1MFplYjgyYytPWkdMV2gvMnAvVytLZnJteTBoSXAvYVZLcFRTSUpFcXUyUWdGeDJpRThDd0RwMFJiSDdMam5nLzR5WHIrWFQzUWR5aFlzb2RTMHNsR3IwZzJPckVVSzdlQ3JLVzgyU3F6Q1Z6My95ZmI2dlJ3TTR4bjlyTjdKa1JrT1FSTG1mSm4yTEJQeFFqREJxcDlsRDdYYlg3WDhwS1RQMTYwelIyYmRlaVg1alllVS9uTFNUenROa2VtM1hMNWVYYmx0UlVrb25CeGRnWjJJSVVtYWhVeEVSUVNDVlQrcks1aHpRODl4UTZQOFZhYUsxZjVWbVJ2cVE0RytsYmErbmxubGI1YnJNaHZsazdGQmlhUHp1d1FFbUVRaGc1Qk94TWpXVG5jSGMyNTAxY1FMa2pEVHNNQ1dweXVSUXhGUDB4WElKZnA1RnlWVzRaeTdLYWpDMDZJdGJpSUdnNlpJVEJ4RHhJZ2JycjFqVFNNMGZpYkdJSHo4TzlzS0swR0FpYkV1YTlzcEFOaDRhWTJWbWNFZytERWtpQmdSL0wyaFlGZ0d0Y0Vya1FRQU1WSmdCeHl5OWhib1p6djMyditLcHI3cWJFRUNUQUlNQW9hSmEzcVBUbU5paUFBZ0pBams2SjV4aHU2SERBSWdRWUdMbUkyOVBvY21NY0k4TU5ZdlQxY2tmekQ5SC91YjVicjRlNE1lOVdmT0txdHlYNlVkMmN3QzQ0OVBSYW1pZkRtNkF1YzByVFhva2NpK1hvMUVBZ0Jja2lEdVlHTGpwVHZudGNHSUErU0ZjcDZ1VUFhQUk4NzlWaFdyUnRlWUFxbi9lZHE3NThiclhKMTMyN1FNaGdKY1pqQTNFQmpOcmdaak9HMVBrQWp5VEdFTk1qWlBxNUVDUTBNREU5RVJCcUZacmswT0ozaTR4Lzd2eUlqQnhHRVJ0M3Rha2dWSkVBcDl4cTNmNzY5V2lQRE52U3NKZFQzSERPRUFTUGVsbW9CUllUM0t6dDV1TXR3YXVKRWdTT0Nwd3JrMURJSkNvTlVNd2o5djdNd2VQOVhTUTgvaEpQcDQ5NmZaVEFJQ3ZMcWN5djJCN25SYnJnQ0EwM0pONWg4dWI3QThWcXBCNDM3eEh2c095M2wzY3lhQjRMMnVxeGh0aTFXTE1jU2daUUN3NytiT29vTzNQazRKQlpJWVlYSVNNVjVzS0g1OVVlUE0xMEdFU1JHcElmL2JFOTJIVTQ1Mkh5d1NKSUdJbGxjdHJocDZZQUs1K2ZIZHMwbEx0SkZNWE53a1Y2ZkZxQTI5bVJPZWZxaU1KajFoNnVtNGE1dlkvOTJkS0dhQnhJaFU1ekpUV1cyY0ptRWdHT21lYjNjOEZ4QWZiOW1kZjJSenlHR3Y1TXZVN1F3dUV5U3dLSEZwL2MvTTcxekEvMkY3YjFSYWpuWWRMQXFNdWtNVnUyWWNmbURZRTJNRDdIKzcvWGxxNmNSSUpxbTR6WE0rcWQzVEdqVkJpcjQzS1NMbFhqaUVMZTVUc1grMy95Vy9TVDQ1UGFBSGJLbWNjV2gxMkFQOTNKTlp5d2owa1NBQklvYnBpWFJIanRaNmZhb3V0MnR5Wk1hZEdMWEJDeEJjdmw2TmZhQXordEtkRm1PYnB6V2wyK3RJSUJBQ1l5MHQveWozNE03SHZzS1VLK0NHYXNzdmljWDdhbFlEd3dxK3Z5a0lFcVBWYStROWdkWWs1K1YrVUU3bGozK0ZHYnVCTS9YNUpVVDhRd0lWU1NTWmlUZ21vRlIyTWZpcVlGRlBmanBreXJmV1BvcHd4UDQ3QVAxcEsxZzkvZHFlQUFBQUFFbEZUa1N1UW1DQycpO1xcbiAgYm90dG9tOiA1MHB4O1xcbiAgbGVmdDogNTVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtZG93biB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJwZEpSRUZVZU5xY1YyMVFsTmNWZnA1elg5aWtvQXZMRXNBSUlnc29Id3BxV0FRVU5LTE5hTnY4aVoxSk1rTkc2L1FqL2REVXlDU1R0Q0hwbUVrd1ZrM1RUb1pSTWpYajVNT0cyS2lkaklreFFZU0FRVUF0WDZJZ0lOOHN1OEtDb096Ykg0c2s0cTVnNzcvMzN1ZWU1NTV6N3JubmVZbVpEQjJNS2NKS2x5WWJxT3NaVklnR0VPZ1NIUW95NEFLYkZGanFBbzVkV24vck5BaDlPcE84NTJvZUpIWXh0cm1FdTRXQUxoTWJ4RzJaRTl1RkFsSW1EUkxZL3QveTBiM0lnK3UraVdPS3NBbGdJWlNiME9JZjE1a1d0S28xTlhoMWQ1eHhpU1BFTjJ3VUFIckdPZzExamlyaldWdEp5Rm5iNllncnpvWXdvY0NsdTBESTVndVBEYjQzWTJMTHAvSWFxZjlKQ0dTRXJHdklpZnhkN2FxUW4vVE9KQ3ZGdlo4SGY5aGFFSCttLzZzRlFnSEJ2MVN0cy8xNVdtSkxrZXlsNkZ1RndGUHpueTEvWmRFN05mZy94aHYxdVVtSDJ3NmtnZ1FwK3lxemU3ZDVKYlo4SW0rS3B1Y1N3STZFTjcvY1l0bHhaYXJCQ3RzM3B0ZnJ0cTlvZGphR0tpaEUrc1YwdlJDM3U4UnFXbW1iaWoxNDlXK1dkNXAycm5FVDZic3FzbnR5YjYrcE8zS3FrRThGdkx4bzc0bE5VWDlzOXVUSmI4LzlmRzJMODFLb29nSkZZZkNtM2I5dXNOcTBNWHh6dzFSc1VrRHFRSUNQcWYvYi9xOHNRaTNqNFdkbXRWNDdPRmdOQU82citERVVGQXRGQWM5WXRwWG1SUDZoeFZzSTI0Y3ZoeW9xbkZ0cks2ak03aXNnQmEzRGwwTzk0VGVHYjI1NU12elhwVUlGalZyaHhvL2R6Z29BUkJ1d0ZRSmtCSzlyZUNudXJ4ZnZYWDhDUlczeVcxRzc0OXZUMkJyN3lzVzBvTlgxcEtEVFBHK3JtMWdIUmJpYkFITG0vNzUyMnNLblFDWnFGZ0NVYUJDcWFTL2JFdzl2cXRXb1FST2YzZEJCaVQ2S1RBQ0ltWjNZdWVxaERkT1dqRGJGUTRJeklsNGVsTlVYNWJlZ1UxSEQ2bFBSbVVMS2VnaGhEY3BxblVtWnVEMytua2dUSDZnWkVFOWN0bFpTb0dtRzlVSXluU0NzUVZuZE15WCtJWkdpQm9ITWpIaDJTcmVDZ2xDbGFTQmlTRUc4Y1luRDI0YnY3Q1dtcy8zRm9jTzNobncxM3BsVGdnQUZiMTk2TmRsUE00NHRDMHpyU2c1SXRYbXlFejA3MFVFS0NNUnFRZ2trQlE5TnZMMmVTSityZXZvSlRPUlNwb1Q2ZG80LzcvN1VTaEJGSFFleE0rSGRmeVVIV084aU4vdWFSelgzL1FqVVNMbG5xTTcyRjRjQ1JJWTV1OVpmK1krQkF2NEF2enBrUTdXQUlCUnVqQS83Vmc2Y2lhOXhsSWQ2SW5hZlZFQUFHblFNVUNTa2I2elRNUGRCeThoVTNKanJwaElxK0NyRCtNdnhleXVtcnIrNElIOXk3bzJHRjVlRGdodXVHeDRMMnpiV1o5RGMwUm9RUmJra0ZOUmRQMi8wQkg3RXRMSkxLQ2pyK3pxaDJsNXU4aGFaODQ3dlRCVzI0a1JGUVhLQXRjc1Q1b3F6M2lnUUVOSW9FQ2tqQkpVRFpTR2V3QmxCai9hbW1qTHJkWDFjL3Q3MGVybzM0Z010ZTlJQnlMTEFqUHJVd0t3ZVQ1amF3UXNoZEl1R01pRjVYRUJVMmtvaXZCbDlOZUVmSmVZSHd1eHRJODF6UHJuMno2aXA2MGM2RGtWMWpMVE9DVGFFMkhOamQ1WjRzOU13V0JPaHFFSHAvSTljV0R0VXJKTm9IbTRLTzlQN2hkblRCb01ZWEk4R2I2Z1ZDZzYzRlM1M2pnOU81dEE1N3RTT2RIeXduQ0F5Z3JKcmZjVGdVZTVVMmN2TkhTUHRZWW9LQ1dsclRnc0luZUIyQWZGUis0RjRiNmY5WmRUekY2UDhZdHVkNDA3L2R5L25MN2s5WDlpOEo5bDV5K0VmNlJmYm5qUHZXYThONXN1ZXorS0ZDZ3F5UFk5NUxuZDNzdHYyQWNCWjIrbUZiemUrbHVpMXhjM2RYQ1VVbFBhZlhOeDQvYUt4Y2FqV1dOcC9Na2xSdzgvbVBGbnRiZCtoMW9MRTg0N0toUVF4ZWpWZzM2UVFxRDBNUFR6SHY0MlV4K3VHYXNKTkJuUGZ3bGxKZDcxa2tYN1JRM1dETmY3ZG94M0JMY05OczZ2dDM0YmJidllISmhsVEdwNk8rSlZIYjAvMkhKdFgxUEgrYXFFQ3FHLzVZTjFubFhjb2tHdnZPNnZDYzR4K1Fza290eFZIQi9xYSt4Yk9XdXp3OE5CM251bytIdDB6MmhIc3VHVTNHcldBb1pmaTNqcnhnSHB3M0JQcG9iYUNIN3ZicU93Nm1ISTgzNnZZVzNFcWNxOUF0aW9xYkp5N3VmUTNsaGZ1OHNSK3M5KzN2TDhrbEFDc1FTdTdBbnhNWTFNeEg3WVhKcDdvUHBMdWxycmorOTU3NU5pMmFlVnQxdGVXZkVXZkhRTENhc3BzZUh6T1U3VldVK2FNNUcyTm95TDRpKzZqOFhXRE5Rc21Hc0t1L2N2K25UdGpRYi9tbTdoZkVOeXZxRUFLNXY4b3BqUEphTDI2S0dCcGQ1VGZndXVCdnVaUmdCZ1k2ek8wamx5WlhYZTlKcVIrOE1LOG50SE9NSGZISWtodTJiLzB5SUg3L29YSjB5Rmx4WW5QVWRSYnZ1SUxnTzcreSs5MWw2S2E2TStjbkNmNGZNU3lwWHZ5bUhmL3Z6QlREM0N1TkdVRktUOGxtSzVSczVBU3FLaUJsQUdCWEZhaVN1bmkwZmtwMXBKN0VkNGUveHNBcUxrNDZFV3NHMUVBQUFBQVNVVk9SSzVDWUlJPScpO1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgbGVmdDogNTVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtbGVmdCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJ0NUpSRUZVZU5xc2wybFVsT2NWeC8vM1BpOURaUnNHQmdZaVMyUllCUUtJakFoRUpXNHBOclhOTWJacFd0VEdOa3R0WW1KTUc1c29TWmNrUmsrMHArZFlQWVkwR2swaWhsaFJqNjNHaFZVZ0JoREQ1b0lPeThBQU13ekQ0bENZdHgrR3FDUUt1TnlQNy9QYyszdTIrNy8zSlV6RVpGQllMaDYyUzd5SVpEbVZCRUlCcU93c1E0RE5kdEJGQVNxMkE0Y3VaQXdWZ0NDUEY1TEdITTBDaHorRTFYYW16VXlBekNNTzdJaE1JKzVNRENLK0hwQ0FOZCtVMnJZZ0MvWTdCb2ZsWWdWQTJSQU9vTll0eWpEVGU0NStoazk2ZTVReXdhSlIrTnNBd0Rob2NLNjFWQ2pMVFlXYWNsTkIwT1crZW44bWhsMjJnOEMvcm43VSt1R0V3ZG92K0MwaStRMG1JRld6b0Q3endWVTFjelEvNnBqSXJlUjNIUFg1Vkw5amFsSFhpUWdtQm9IK1hMSEF0SDVjc0RhWHR4RExMeklCdjVqeWZPbUcySDlVNFM3c25icFg0M0thUHBnQkloRHgxclB6T2xiZlBDNUdRVC9uZDFtUzF6QUJhNlBmUGY1eTVGL3JjSmVXcHA3ZlBrbHk2ZjdLWEJSQ29PU0FURmZYbGwxOXg3NEhEc3ZGQ2doc0pBRzhIcnZsdnl0Q1htN0VQVnFjNXd5enA1TlgxNW11RTFvbUtYWHlNbmQ5eXk1cjVRM3dQZ2h2SnpyTEFsaW1YVjM4KzdEMURiaFBGcTFNNk80YjZyUFZXS3NDQmZIaTVFV1d2OVRrUUJZQUVQcEx2RVJNQzlOOEZ0UnZqdDlkUGw2d3dvNWpQdnVhczdXVjVqTnFFano4d0ErQ0JzYWFuK3c5eDFocnJYSnR1YVpYOTdvb0xmcVBMQ1VFR1JSK2lPd0FzRjJYOThVYzMwVzNmYjAydTQxZnJWcWVWbW82RlVra3dDQXdDV3hKMkxzLzBUUEZOQmI4VE5kcDlXdm5WejRPQUtkbVgyUU96Y01zQUFqemlER01CZDNhc0NGNlNYSHlrbkpUZnFRVEsrenB2aG5WS1Q1emF3Q2d6RlRnTjk0cEpYdlA3Z3h4alRBSWtwQitNblNXUk1RWllFRG5QVnQvSzRlamJaLzc3NzI2TGI2aDk1dEFBaVBFTGFKMWJjVGJSZkdlTTh4djFheldTZXlFYTBQOWlnaytOcjErb05GZmtwd3pKQ0pLSVFBNjc5bnROMDh5RFhZbzNxaCtMdVVyYzBFNEVjTkw0ZFA3Vk5EenBVOEZQM3ZwZWtvUVE1Q0V3NGJQZEVmYTkrc0FnRVpVbWttQUFBUzVoTFE5cDExWEdPK3BNOFY1SkxVZk1lUUFSRE1sRU1LSUdGT1ZDWlliMEM3Rnowb2VYbUlaNm5aellvVjlvZC9qVlMrR2JhaFVPbm45YjdUNnNFT3ZpVUd5QThiTURsVWEwVzc5d0JXL2JaZitsclk5OGNEQlVJOFlDeEdEZ0hDSmlWVkVETjhSN1FXQUU4Wi8rMW1HdXQyaTNlUDFyMFMrWFJ6dGtkQnpxNk5iRjdXcGJGM1Vwckt4anZmSHhicmZ0dGxhL1FCQXJWRGJKSklBUUNVUk1SZzh1Z3JLSUFLQlNOeHpIdE4zVmRteFkwaVFZU1ptVGVlZ3dUbGdrbllBQUI3UlpCaDJObTd1cmJlZUMxcjE5Uk9UNTJrV24zc2hmSDJGdTFBTzNSeGpZLzBmZGFjNy9oUFBKTURFMTFHQytIcEJKbUlFdUFTM09hNncwMWx5Yk1iTWd2Z0NFNk8yNTV6eTI0RGVDci9CdmNrbjkrdThaalhZSVl2anhvTUp5OG9lWFpyVDlHSElxTVdUd0Eyb0k2Y0ZNZURJY0FpU0VPeWliWHNtWkcwaEFGenVxMU95WTZ4QkFuTUpnZFBPbWtzMDh6VS9iYnNCOXgxOFAzN1BxUy9iOCtvL2E5NlpjTG0zUG1CSDQ2WjV4NDBIVzFlRnZsNFVxMHcwTXdpQ0JPYjcvcVRzZDZHdlZZNTM3RFhXYXMxSXcxQWlOSm5PZ3dKaStiWGhBYkUwOE9udmFYU0lXMFR2WXc4OGVhRi91TS9XTmRqdTNtNXI5VGxoUEJ6Vk5ORG9QR0MvNXRSbWEvR0o4MHhxalBQVWpWdXZQMm5hcnJNT1dkMUpsdi9FMWZONzgyVWlOUFpmOUMvcU9LYStuZE96MmorY3owNDZzbis2S3JWT3NPRGlycE94bGQwbFV4bUVCSy9rdHZHZ0ZkMmw2dGFCWm45QkF0RXo1eFlJdkFuNC84ckZLa2dzdEF5WjZZZitTNjdlemxraVNVNzNYWFJWNnhxaDkzVHlzc1I0SkY3NWVmQnZ5bUxkRTAzamdUL1diNXR1dExXcEdiVG03d0haeFFRQVQreUR1S0x5SFJJazRjbkFaNHBmQ0Y5L0h2ZlI5dWgzeEJ4dHowMEJBTnNWRHlsbmFjNndBSUNhSE1pQm1XNU5STHk0dHJjcTBNdFozUm5wSG1lNUg5QXZqWWVDYzF0M3B6TUpnT1NWbnl3NGVIWlVCOUt5dTY4aU1GUHB5c1NwcGFiOFVKVkMzUm5wL3BEbFhxRjdtbllzZEtRYnY3Y3I2ZkRHVy9aY3pidDZqZ1V0VjZrSWxGeHV5Zy90SCs2ekpYbWxHZThHK21semRzeUIxajNwVEF3WjlxMy9Tc3BiYzl0bUR3RDBIM1VmZlhDRmx5dVRsRnBuUFJkWWI2MTJjNWM4K2lkUEN1NmZDTERLVXVienNmNmZTYVdtMHdtTzloYnZaVThmRFIyem9aOTdPdXBwQXUwVUpFREVtT0lTWm9oVDZxN0dlazVyRDNHTjZGRXAxRGFBWUI3c2ROWVBYUGFvN2FuUzFGbXJnNDAyZzcralloR0lhT1hPYVFjK3VPTmZtQ3daWEpJZjh4S3gyS1JneFlnT1MrQ1JPdXlveVFLQ3hJaGtPcjRUNkpXZ3hHbnZaMUhXbmYvQ2ZIY0JYeGNucFJIeFl3UktrVWpTRXJGS2tBUWlOalA0a21CUlRIYkttNUtrS3h3TCtLMzlmd0RYMVhHRjhjdCsrUUFBQUFCSlJVNUVya0pnZ2c9PScpO1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgbGVmdDogMTVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtcmlnaHQge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCczFKUkVGVWVOcXNsM3RRbE9jVnhwOXozbStYeWdLN0M0c0x4a1c1bzRDQWtZc3NGU2tSamFiakpFT1NKbTFJYlp4MmtyYXBpWmRlcHJXME5WVkowcHFNTTBrWUpRbHFrb1pJbUdpb0UxSXRpQ0FnSXNGd0U0RXM5OXZDc2x3Q2hmMzZ4eTVFVzFBMFBuOSs3M2ZPNzcyZTkza0pDNUVNQ3N6RmQyMFNieUZaTnBKQUFBQ3RqV1VJOEtBTjFDUkFKVGJnOUxYTlUrZEJrRytYa203Wm1nNE9Xb1VkTnFaWG1RQ1pIUUZzejB5T2NDWUdFYzhtSkdEbmwyVVRoNUFPMngyREEzT3hEYUFzQ0R2UTMyVkYxMXFQOWFaWXo2U2VGZW9vaTE3cFBRRUF2Wk5kVG5XV0tuV0Z1VmhmWVQ3djB6emE0TTNFc01rMkVQZ25OWnVzYnk4WTdQOHgvNWxJL2dNVFlOU25OS1F0LzBYdGV2MURmUXRabGFLK001NGZtREpYWGhnNEc4ekVJTkJmcWxMTWUyOEw5cy9sUThUeXI1aUFKMzJmSy90aitPRnEzSVVPMU8rSnlHazdHZ3NpRVBGcmxRLzA3Yml4WGR3RVBja0hXWkozTWdHN1F3OSsvbUxJUy9XNFN5WG9OdlFza3B5SExnMWU4Q05RM05JMGxhb2plN1RnLzhDQnVkZ0dnUXdTd08vREQzMjJ6ZS9GRm54TFJXaGlCelVLOTRHTEEyZjltU1RqZlUrN21qcXlyVmUrQVg4STRhR2dTaGJBMC80N1NuNFp1TGNSOTBpaDZxaWgwYW5SaVZwcnRVRVFiNDNiWXRsWG13TlpBRURBai9BQ01XMU04RXhwZURYeVdNVkNFbDR5Rjd2bnRSL3pMZW92OEpKbFdmWlIrWTNOOTIrY3gvcmVPbXUxcXVOcmsyN0VXVzB4dldzcEpjaWdvTk5rQTRDM1lrNTl2SDd4bHR2dTNrdER4ZTdQWDM0aWxRQ1FmZWNpMWoyeGZuOTRackdDbmVZOHV4Y0hDblcvdmJyOUVRRDRkMklUYzhBcHJBT0FRTGV3cm9WQUFhQjhvTWlMaVJIdm1WeTd6bk5UaldDRnJYS29KT1NIRlEra3ZuRjlmK2pjbzA3czkxTUZkd21Ta0hRdVlCMFQ4V1l3SWNZajBiVFFkUnVmR2xGS0pNRlZhQ2IvR3ZaVzZhR0k0eWVYT3dkMm1yL3UwNXpzeURZK1c1WDY0Tm0rZk84NU5wdUppQ0ZKVHBzbElvb25BREVlaVQyekl6SVh1aCtvMjVQUU50YnNOVk1PQlVuMmcwOE1pU1RITjN1WmpOVEVEcjRkblgvNkgrMUgvWFBhc21Ldlcrc01HZlcvTVh6ZW5kZTRLM2gvaWJ2U1l4SUFJdHlpZS9LN2NnQ2l0UXhDSUJGanBUcktNZ00rV1BmcmhMYnhGaTlpTVF0bFlqQUpTQ1NCU1lCQUlQQk5JM3A4NlRQWGo4Yms1NlI0UFZ5bEZFNjI2dUZMUWM5ZWZpVFZQRG1nQklBQXR6QUxFWU5CUVJJVGE0a1lpeDIxRndCYXg2NTVDVmFnUExrNzgwNlBqMXFvLzdNcmFGL0ZRMTQvYU1oc3pZaHZHcW4zS1RlZjg5cmtsV3JTS1hVVGtuM210Sks5QnpmM1hKQTBlL1BjcmRneEl3U0NEUG1iWk1RZ0FCSmtEQkt6dm4reXkybnBJdjl4QVBCMUNlbzJqVFo3R2M4YWZpcElnRWhBa0FDRHdjU1FRWkJJSUdueDVpdDdnZytVM3dnY25iWktSMXIrRm5XK3YyRFZ0RHd0WENYTlNLejc5N29Bd0R6Wjd5U1JBSUJCRnNUWG1CaDF3MStvWjRKM2grd3Y5bFVGZGJNRE9yTys1SUFxV0lHWnRodVYxM25DNzduS1J4OHI3UHNzeWliTElrb1QxL2g2NUhzZnpXeXU1dEY2TllOQjRFWUp6S1VFVHFnY0xOVnYwRC9jRFFCck5Bbm05K0xPZlRMZk5CNXUyaGY1eis2VE1leFlqaSt0VmRyTTVsZU1iV090U3dReC9GMUMycmN1ZWJJcXdTTzU2OGE0V211TjNtRVlTaVVpK3BSbDJsMXBMdllCc0tBclVLVnduWlJZZ2RIcE1XVkc0Ky9XWGh3b0RCWEU3T21rSHpKNkpOZW1MZnY1MWJuaUdxelZQb0lreUxicGZLN1pNRklrRTZGbHJNbjdRbCtCYmlIZyt6WEdiZ0xqeWxEcHlvc0Q1OEtabUtNMGNmV0hJOS8vYUQ1bzFWQ1pybk84M1Z1UVFPamE1UE1DZndLOG4zSzJDaEliTFZPRDlLQjM2bGUzQSt1L3MyUTgxQzJ5UmF2UW1RTmRWbmFtTG5tcTRuSEQ5anBCMHJ3bTc3anBqVFc5RTkwNkJ1MThmV2xXQ1FIQW94OUN0R29YVHdtUzhJVGhaeVhQQisyOWludW9FNmJNc0RNOXVmRUFNTkhxSnVVOGxqTXRBS0EyQjdJaHphV05pTGZXalZRYjNKMTAvU0d1RVpaN0FmMVg3K2xsdVozSGtwZ0VRUEwyOTFNK3FiekpnWFFjRzYweXBLbFZUR3dzTXhjRmFKVzYvaERYVlpadkN6M1Jscm1SaVFId3k5blJuMmJNNmJuYXM0Y0xmSDZzMVJJb3JzSmNGREEyUFRvUjdaN1FlemZRRDlxend2STZUeVRaQzQ3dHRYZWlUKzJjMSt3QmdPbmRvVFBMdDdtcm1DUmp2ZlVMUTRPMXhzVlZjaHU3YjlHeXNZVUFxeTNsbnNkTmIwYVhtUXVqN1BZV0wyZXR1Umw2UzBPZlhMamlHUUlkRVk2SzVlc2MyQldoanZrcVhMTzZ4MDhWUEt4VjZpWUF3dUJrdjVOcHZObXRicmhhWDIrdFdkWTcwZVZOSU5odExXMC9zanJ2NkIwL1lkSmxjR2xSMkF2RTRoVWxLd0hRN0JVNWN6OExSeDBIYVBZN2dYYjUzTC82NyttVWZ1ZFBtUC90d09XUzZBUWkvajZCNGlXUy9JbFlLK3lHWUpEQjF3V0xFckxSS2Qvb21PSmJBV2YwM3dFQXlPOW0rL1R0UzNBQUFBQUFTVVZPUks1Q1lJST0nKTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIGxlZnQ6IDk1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLXpvb21JbiB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJpQkpSRUZVZU5xa1YydFFsT2NWZnA3enZndkRSZTY2eThodFhVQlIxR29GSStCdEZKdlJ0alBKQkdlYUgyYThER21idHRnU1RXYlNKRXc2VFdPc3JiYnBUSWVKWkdxYVRpcFRhNkxKWkRUVlVUWVFkTkFvaG9zbzZxTHVjbkVSTjBBeGNiLzgrSGFKVUhEWDlQejZ2bm5QZTU3dlhKNXp6a2VFSXdhWWN3QkwvVnJXMFRDS3FaQU5JTkV2QmhTazN3OWVVbUM5SHpqY3NmYXJPaEJHS0pOODRHa1ZKSGNldHZxRnU0U0FJWUVMWWxwbTRMcFFRTXFvUVFLVm56ZU83RVlWL0E4Tm5ITUFHd0hXUUptQWp0Zzg5NUxrRmE3RlUxZDI1OFV2R0xCR3BJNEFRTTlkZDJUcndObjQwMTZuOWJTM0xxTnpzRDFWS1BBYmZoQ3lxZmxSMzF0aEF6ditMYStReG90Q29OaTZwbjFEMXM5YVZsaS8zeHRPVms3MmZqVDFYVmYxN0U5dUhac3BGQkQ4emRrMTNwZENBanNPeUc2S1VTRUVuclQvdFBIbHVXK2N3N2VRMTlxMno2L3QycnNZSkVqWjA3UzZkK3Vrd0k1L3lRN1J4bllDMkRabng4ZGJITnM2eHhzODVUMlI5R3ByWmNtVndZczJCWVdzbUJ6UDgzbTduSVZKUzczamRmZGQrN1BqalV1L1hXVUNHVHRQcmU3WkhqeFRZM0txOERvVjhPdTV1NDlzblBHckt4TjU4c3laOWFWWEJ6dHNpZ29VQmQrWHQyTmJmWjhsbGFWdmFoK3ZPejloY1grQ0plbldwN2VPT1lTNmVQcFRVMXczOXZrK0F3Q3pGUGREUWJGR0ZQQ1VZMnY5aHF4ZlhKMHNoTmVITHRzVUZjNlVlcXViVnZkVmt3TFgwR1hiWlBwbDZadXUvaWo5eC9WQ0JVMWRVN2JmZEZZQUlEc1NGUkNnZU9xYTloZnkvbkRod2Z3VEtPclJkMFU5NW4waXFjaDkrY0tTNUpWdHBNQ2RrbGxoQWh1Z0NIY1J3QWI3ejF0Q0VwOENDWEFXQUpSb0NGWElZbnRpK3NZV1RRMHRsbDB3UU1rK2hHVUFrQk9YNzE0eGJWMUl5dWh4SGhJTUMvaVI1T1Y5TTJKbXVoVTFWaDdQWGlha3JJVVFoY25MWGVIUXhQVDRHeUF0RnFnd2dBUEY1aUlGV2tldTFTU0xDS0F3ZVhuMy9aUjVyWFY3U2RkUXB5M1lEb05lbXM5cVRJNWhHQ2l0bTFNT0FBeDBhYUZDZXJUZDg0empCZWQzRWdxOUFEQS9ycUQ3UTNjdFFDNFJFRG1rWUhiOGdvR2dzUjJ0ejVWMERWK3hVZFFvcUFRODFSeWJVNElnRldnQUNncGFMTENJQlVvMGJ2NjN5L2FYeTYrV0JIV3o0L0lIU0lHQXVWb29pYVJnV3FEM0FzRFZvUTZiRWd0T3JmSlVod3JmMFdVdGsrcjhzTDZ3dkh2azVpalZVaUpTUnJRWnVVUnRmb0dNdWFDb1J5ZlAveU15MFh5a2dBQTBEUFJUeE5wMzF4MlpGdVVZQmdCN2JLN0hOZGhwS3o2V1hxNm9RQ29vS2doTUtoa2dqaTc3dkJvQTFqa1hsQXZWZlJRakZNVWNteFNrUldkNmdwamV1MzJSMmt4VHZ5aEtoMURRZXVkOGZGQmgyNnpmT2UweHVSNEpnQWJ6eXdDb1JTemZlRFVLYXRKS1VRSytDaktpSFo2bloyeHpCblU3Qjl2aXhUeTdxQ0hTUUVoSlUzK0R0ZFQ2bUFjQUZpV1VlUC94eVBIM0p3cmZvM1h6eXNlbVJjRUE4RjVSWThoNmFQRTFXd01MUTRPUS9FQkFOSG1kR1dIbHpaeXhrM2F5QjBtNzcxeUdvb1l5K0tFMGwzNXgwaUJ4WmVoUzZpZTlSMVBDTWFEdkN6V0RYQTRoWjI4M3B0d2N2cDZxcURCbnlhbzZBV0VRckJRUS83eStkM1lvQStOQlRBYUVsbzk3M3A4dFZGQ1F5aXBXK2MzcGROdTdCd0JPZSt0bS9lbmlLL2tQRldvd3BNZnZ1S3J6enc4MHpTS0lrV3NKZTBiSFl1MTYzQk53TXdEc3Y3RzM2T0ROdHpNbk01SVdaZmVRZ3NjYmlzdkxQbDFhRGhMVG83SThrK24vcCtkdzVwR2VnMFdLR2lTMzFLNnZ2VGRtQTdueDl1RFo5QTN4TVVJcGJ2U2V6RTZNU09tYk5XWGV3SGhENmRIMjNvN0JscVF2dnJ3VEs2S1FGcFhsMld5dmNFNkxUQjJlQ1BTZHJ1cnZtY1VuTy9jVmZQRDZwTXRleWZHczNRS3BVRlFvUzl0VS94UEg4eGUrVGRkNjkzcE4vcEh1ZzBYbXFudHZ6MXVMRG85Wjl2NW5ucm4rZHZ1anJJMUpNVUpkM09ZN245N3VhNDZkb3VPR3BrZGxEb1VEZUc3ZzFOUy91LzVhME9nOXNjQ3NCK3lzV1hTb011eUZmdFdKdk0wRTMxU0JqbVdQem5IUGp5KzhOamRoWWZlTW1KbDNFaU5TUmdDaS8yNWZwR3U0TTY3MXpqbHJtNjg1czJmRW5Vb1E1bHJMTFc4dVBMajNvWDlocWd4SXc4bjhYMUxVN3lNa0l0Q0h6UkVackdRVjZPTm15NVRnZ0hrMjQ3c0wvMWpGcW9mL2hSbi9BV2ZxQzBwSStRSEJJazN0SUNYUnJGVHBGOGhsSmFxZWZoNnlGeFE2SHdRWWxLOEhBS3l0M1dzV3hsN2ZBQUFBQUVsRlRrU3VRbUNDJyk7XFxuICBib3R0b206IDEwcHg7XFxuICByaWdodDogMTVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtem9vbU91dCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJWNUpSRUZVZU5xMGwydFFWVlVZaHQvM1cvdkFDTXIxNklGUlFEaUFnQ2hwZ2lpa01xWTFXam5OOUtzZkdPWFlUT1Zna3ZiRFVzWnVYckswcVptR1VTdk5zcGpJOFRaT21vNkFHQm9aWWx5OFlCNlF3ODBEQndRNmpKM2RqMzBPWlptaXd2dHY3N1hXOTZ5OTFsN3Y5eTFpTU5MQnVDSTg0dFprSVhVOWd3cXhBSUxkb2tOQk90emdKUVdXdVlFREZ4ZmNMQUdoM3kwazc5aWFENG1mak9WdTRXWWhvSXRuZ0JpUjZSa3VGSkF5RUpCQTNtL2xyaTNJaC91ZXdYRkZ5QUc0QThvQVdrY20ybWVFenJGTkg1M1ZraGc0eFdueENYY0JRR3UvM2JmR2VUYndqS1BVY3NaUkVsbmZVeGN1RkxoMU53aDV2dXJ4N3M4R0RiWitMK3RJL1UwaGtHR1pYNWM5L3BYcU9aWW4yZ2F6SzhWdGgwZnZzUlVrbmJ4K2JJSlFRUEN0cy9NZGErNEt0aGJKRm9xZUt3U2VqWDZwZk8ya2p5dHhIMXBmdXlxbHNHSDdkSkFnWld2Rm8yM0wvOW11Ym9GK0p4dEUwL09Fd01xSkc0NnVTSGluRnZlcFRQTzhsaEdhWCtmUEhTZGpDS2FQeS9iM3Y3YXo1OGgvd0hGRnlJSENSaXJnalVsYmZzaUpXWEVGRDZpVW9Pa2RRYWFRNno5ZFAyWVZhaGxqRjQreVhkdlovZXZmNEcraFFrMnNFQVVzdGk0dld4YTM1Z0tHU0JNRHAzVDIzT3h4VlhkWFJpaktvdlNGenJlckM2RUxBTVQ2SWhjQ1pJeWVYN2M2OFlQekdHTGx4cTg5UHlNMHE1WVUyTTFSdVFBZzBFRVJiaWFBN09obDFSZ21QVE0ycDFxakJrMU1tNkdERXJzZnN3QWdMaURaUG1mTXdyYmhBcWVIem02UDhaOWdWOVNRZFR4MmxwQ3lBRUtraGM2MllaaVZFalRkUmdvMHpYZUJSbkltQWFTRnptN3hkamp0T0JHeXZtWlZaa052ZlpqWERoVTE0K0JUb0ZFREtSQVFwQUowSFJUalA2WEhwWVVLRVg3UnpTOWJWNWMrRkpUbUFJQ1VnTlNXUS9aQ2dKd2hJT0pJUVZMZ0ZLY1h2S0htOWN5R3ZpdGhGRFVBRlFxRUNobzFDQlVJZ2dZYXBBSjFRRUZCRXhOTVlvSVNEVTEvTklSOWN2bmRURy9jMklCa3AyZkM4WnBRZ2tuQkdJLzNBc0R2dlJmRGxKaHdlbTV6d1lNczdWTmxhVXRiWEUxaDNtZXpqOW1sR1NzWHJCa3prRnNHS0dvRG1lZEJKTGZManhRUWdBWWRIUlN4dFBmYmZjZU5zUFlCUVBUSStHWmJUMzFZeHJHSXBZb0twSUtpZ2tBZ0ZPZ2dOQnJiUUJCQ0JhRU0yTCtpR0dtVGduRitVYzFlcHFPLzNWZWpBb0FPVVpTTFFrRk4xN2xBYjRlVkNlK1ZSdnZITjRzSDZ0MWZlcUFtTVVHb1BIdnZoZEx6VGp6ZktvajBzemEvR0xPeTFCdTN2cWMyMFBnbDVZSUdrVk9FWkZaMG5MTE1zenpkREFEVGdqSWRYNlVmM3pmVXg2bTZ1OHJpS1JoT0NjbURBcUxDVVJvNTNPZTRycnN5VWxHRDBubElxdWJkS05aSlhPbTlGSDZ5N1loNXVLQm5POHZOVFgyTjRZb0tFMmZNTFJFUU9zRThBZkZONC9hazRRSWZiZDJYSkZSUWtMeDg1cnVON05UcDJBb0FaeHdsQ1I5ZFdKYzgxTkRkdG9Ma2M4NktCSUp3WFEzYU9wQ1Bxd3VoUjJTUGJDQmxVYzJOeW9nUVgzTjd3cWdVNTFCQWYydzlFRlhVdEN0THFBRHFTNzZldjYvaWxncmsycTZlc3hIWmdmNUN5U2gzRk1jRys1amJFMFpOZGo0b2RIZER3V1BHY1pOTk8xTVBicnh0emRXNHMrdEk1SFBCd1FUVHp6aUtZM3YvN0hHbGhtUzIzZzkwVCtPTzVMMU51N01NdzNGdi9UeDFmOTcvRm5zQVlQdWk4L0Q0bkJCL29aWlIyMzB1b3E2N2F1UW9MYUIzN0lpbzNzRUFLNTJuUjM5cCt6UzEzSEZpaWxIZVl0T09hYmRDNzFqUXp6MlIrQUxCYmNyaldORitjZmFVd0xTcms0S210c1Q0VCtnSzlqRzdBS0tqdjkzWDFsY2ZVTk5WYWFudHJvcHFkZG5EQ2NJb2E3bGsyOVM5MisvNUNwT3ZRMDRWSjc5S1VlLzdpSS9IaDQwVTZjM1B5dVBqaG1XS044RzhGdm53MUEvem1YL3ZWNWgvVCtDWHN0Uk1VcDRrT0ZPalppVWxXQmtGUVlkQUxpdFJaWFJ6ZjNScVd1bWRnRjc5TlFEQk9hMlYvaVlTSEFBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIHJpZ2h0OiA1NXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy16b29tRXh0ZW5kcyB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFBQWdZMGhTVFFBQWVpVUFBSUNEQUFENS93QUFnT2tBQUhVd0FBRHFZQUFBT3BnQUFCZHZrbC9GUmdBQUJwdEpSRUZVZU5xc2wyMVFsTmNWeC8vL2N4OWhJaXB1QUpIYXNnSGxSZHcweGF5N3lLN3NtZzZzYjJEU2R0cVpkdUxVTkVObU9rMXRRdU00VTdVelR2c2hTUmxGWnpvTkNXU1NTVEpwKzZWTmtMQ0FlUUhCb0NDZ3FOQkUwd1VxTCtLdXdJaWlaWjkrZUhhM2FBUzNTZjh6TzgvTDNudCs5NXg3ejduM1lXbHBLVVFFSkFFZ2NoOStKb2xhOXhFQzJBREJWZ0FPS3F3Q1lBcUtEZ1VKQklIUEJXd0ZXUU5kYnlaRkJ3QUMwR0dJQUhRU2ozLzhISFJkaHpZYmREZndnNElqQXNHdklDZ1hBcm9ZQmlDRURrQkJBQ0Jab3lTVDRnRHdRcWg3bVE0Y0VraFFEMEVCSUlnZ1JNUUFoMkVpRXZFWUFHcmRSM1lTcUlZQ0lFRGFvdFZEZVludS9yeUVqU09yNDNQSGw4V21UQlBBNlBSUTdJV0pydmhUL3Via1UvN20xRXZYKzFLRVVoN1VnK1drUEVYZ2RVU2tSK3hyZDBOSjRxanI4QUVJOXBHQUk3bW83OG1IZm5GK1kvSzJLN2lIVWhldXZKRzZjT1VOei9MdkR3UG9icnBTbC9SdWYyVk95OVVQczRSU1RTQU53SDRZNDQ5RVZkbnQ5b2pISWVnaENIWUxnUituLzd6dDROcDMydElXWlU0aFNwbmpWazF0L2NhUGZPTzMvZisrTU5INVRWSmNpc29Fb280a3NnYnNYd1lmZFIxK2tRcGxRdUNGTlM4MlBwLzkrMTU4UlRrVEMwY2UwT0t1dFFlT3A1UE1FMHFjVUJxeUJtd0dPQzh2ejRBV1ZPeUU0Q1VxWU8vRGgrcDNwai8vQmI2bUhsbHFDeXhkOE9EVlQ2OSt1RktvT1lUU256Rmc3U0pwekhGTlFZV2lRclVJc0NOOVYrdU9oMzc1enoxNzlwU0dJMUZTVXVLMTIrMithR0R0N2UzbXVybzZUL2g1Nzk2OWxaZHZEclQrWmJBNm4wQjFuZlBWTjdlMFBqTWpJZ0lJZGtFQVIxSlIzMjl5RHZhRTArbC9oUUtBMVdyMWJkNjgyU3Npa1VXN0srTzNQZXNUTnZhU0FpWGFMaEdCdk84NlJGRW9KNEFkYWMrZUR4c2dpWktTRW05TlRZM241TW1UNW1qQkhSMGQ1dnI2ZXMrbVRadThTcW5JK3grcytPbDVqUm8wYXVYMWp0ZXBRYUVBQURLV1dJYmN5N1pHVW1iNzl1MWV1OTN1SSttdHJhMzFITGo1VEdEczlyQkpJQ0NObjFHUkNLR0NVSkFVdXp6dzZDZmJUQjZQeDd0MjdWb2ZBRy9ZWGw2Q2V5dzlMbXZJTjNVeFpVYWZLUkFDV3lDRUxjSFZQM3ZrNGZEYWJEWmYrMk4vRDlnK2ZzTEVFRlNvb0ZHRG9nWk5Ga0JSZ1NDc1RjV20wNjZqZ1JBVTRldC9GNXU5bnhSb3NtQ0xSbUUrUWRnU1hDTnpoVy9zOXJESjYzd1ZKeDc3VitWOFlTNlVOYVc4QmRPY3F6eCszVWp0MEY4QmNyMUdNSU1VNUN6SkhaK3JnNklHQ1lWMlBpbW95SUs2bHpJV3J4a1BUVkdtUm9xSkZDeUxUWm1lcTRNQjVmM0JWQURuYnBjUWt6U3RVUU1BazBZS0JQZnp4bGhBOTVOUVFlNDNRQm90QkVDQUZGeVpIbzZkejZDS0NpekFQRlBpdnpVV3F4bTJBcUlnbndrRnZaTm40dWN6R0szSGFoN3dwZXQ5OFVaODVSOGFLU2NJY1hZRVdwTUxreDhmdmxlSHBOamxBV3RUc2FrUWEwcFZLR2NKUXFNR1VxQ0hCdmZkanAvZ1RQNnh3RnpnODVQZHlhSDJKNFNVb3dLaXczODg5ZTRLQkFDblQ1ODJXNXVLVFYydXVzQWRVRmxnekJjRlFvRkdEVDM1SHdXKzgybWhxYWVueHd3QTRXdFlmUk5uVWtNWlVxc0pwRWtuOGNYVTV5a3RZdzJKanNUQ01RRHdlcjBla3Q2R2hnWlBVVkdSZDNmdTdxanFkVTlNajdtbHBjVkQwdHZTMHVLeFdDeVZBTkI1clMzeDhzM0JGRVVGZ1RUTHR1Wm5kUUhMQk1TZkI2cHladGZxTURRM056ZnFUY0ppc2ZpY1RxYzNCSSs4YnhoOUw4Y29yYXJNM2ZuRG9JVCtyQUNBVS83bTdNT2ZIYkNFd1FEUTJOam82ZXJxaW5xVE9IZnVYTmpqaUkyMyt5c3RaOGM3c21ta1dnVkpjTisrZlJBUmZMRGhsYWNFVXFWRVExbm03N3hQckhqU2gvK0RqbzNXbU4vcy82T0hFT2dJUHIyaDYzdFZ1cTVEdWQxdWtFVFdvSzN6b3JrelRpaU9Obi9US2xOTTRsajI0bStQZjEzbzJ3T1ZIcUdBNU1zQVhqS1ByRGFxbk12bFFualR6aHkwTmx3MGQ1b0k1cDN5TjYyYW1yayt2ZTVCNStoWGdiNDdXR1g1MitWM05nb0ZPdlFLQUdVa2tUcWNiWnk1WEM3WEhZZjR6RUZyM2FYVTdqaWg1dWlkUFBPdHZzbXppeFpyOFZNckhqQkhkZExzSGorWjlGYi9uOWExK1QvSkRhWGV5MElwRXpFS2tIblU4Smo3OSsrUGVFd1NTaW1RUkdQK0d6OGo1RFZGQlZLUXRqQmo2SkdsTnQvRDhZK09wTWRsVHBoaUVxY0I0dHF0c1ZqZmpVdExMa3gwSi9kT25qV1BUZytsRUFSSUVId2FRSlZRSVlnZ0FDQy9xeGk2cm44WkhMNFhFVFNzZjBNVTFIT2svQ0ZHWWdBd3NrVXFZNWVCaXRSeHpuNy9hMFYxRUVCd2Rxa042alBJN3k0eFBtSG1DNXVuYldkUVJNcVAyZDg2cUFOT2tzVTZndm1Bck5RUk5DbHFBQm5RZ1l1SzBrckkrd0NPQXlIM0RLL3ZxT1hoYWYzUEFPN21JUmpETlYyNUFBQUFBRWxGVGtTdVFtQ0MnKTtcXG4gIGJvdHRvbTogNTBweDtcXG4gIHJpZ2h0OiAxNXB4O1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6JDEpO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBBbGV4IG9uIDExLzYvMjAxNC5cclxuICovXG5mdW5jdGlvbiBrZXljaGFybShvcHRpb25zKSB7XG4gIHZhciBwcmV2ZW50RGVmYXVsdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCB8fCBmYWxzZTtcbiAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIgfHwgd2luZG93O1xuICB2YXIgX2V4cG9ydEZ1bmN0aW9ucyA9IHt9O1xuICB2YXIgX2JvdW5kID0ge1xuICAgIGtleWRvd246IHt9LFxuICAgIGtleXVwOiB7fVxuICB9O1xuICB2YXIgX2tleXMgPSB7fTtcbiAgdmFyIGk7IC8vIGEgLSB6XG5cbiAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtcbiAgICBfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtcbiAgICAgIGNvZGU6IDY1ICsgKGkgLSA5NyksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIEEgLSBaXG5cblxuICBmb3IgKGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gICAgX2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7XG4gICAgICBjb2RlOiBpLFxuICAgICAgc2hpZnQ6IHRydWVcbiAgICB9O1xuICB9IC8vIDAgLSA5XG5cblxuICBmb3IgKGkgPSAwOyBpIDw9IDk7IGkrKykge1xuICAgIF9rZXlzWycnICsgaV0gPSB7XG4gICAgICBjb2RlOiA0OCArIGksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIEYxIC0gRjEyXG5cblxuICBmb3IgKGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBfa2V5c1snRicgKyBpXSA9IHtcbiAgICAgIGNvZGU6IDExMSArIGksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIG51bTAgLSBudW05XG5cblxuICBmb3IgKGkgPSAwOyBpIDw9IDk7IGkrKykge1xuICAgIF9rZXlzWydudW0nICsgaV0gPSB7XG4gICAgICBjb2RlOiA5NiArIGksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIG51bXBhZCBtaXNjXG5cblxuICBfa2V5c1snbnVtKiddID0ge1xuICAgIGNvZGU6IDEwNixcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ251bSsnXSA9IHtcbiAgICBjb2RlOiAxMDcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydudW0tJ10gPSB7XG4gICAgY29kZTogMTA5LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snbnVtLyddID0ge1xuICAgIGNvZGU6IDExMSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ251bS4nXSA9IHtcbiAgICBjb2RlOiAxMTAsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07IC8vIGFycm93c1xuXG4gIF9rZXlzWydsZWZ0J10gPSB7XG4gICAgY29kZTogMzcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWyd1cCddID0ge1xuICAgIGNvZGU6IDM4LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sncmlnaHQnXSA9IHtcbiAgICBjb2RlOiAzOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2Rvd24nXSA9IHtcbiAgICBjb2RlOiA0MCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTsgLy8gZXh0cmEga2V5c1xuXG4gIF9rZXlzWydzcGFjZSddID0ge1xuICAgIGNvZGU6IDMyLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snZW50ZXInXSA9IHtcbiAgICBjb2RlOiAxMyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3NoaWZ0J10gPSB7XG4gICAgY29kZTogMTYsXG4gICAgc2hpZnQ6IHVuZGVmaW5lZFxuICB9O1xuICBfa2V5c1snZXNjJ10gPSB7XG4gICAgY29kZTogMjcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydiYWNrc3BhY2UnXSA9IHtcbiAgICBjb2RlOiA4LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sndGFiJ10gPSB7XG4gICAgY29kZTogOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2N0cmwnXSA9IHtcbiAgICBjb2RlOiAxNyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2FsdCddID0ge1xuICAgIGNvZGU6IDE4LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snZGVsZXRlJ10gPSB7XG4gICAgY29kZTogNDYsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydwYWdldXAnXSA9IHtcbiAgICBjb2RlOiAzMyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3BhZ2Vkb3duJ10gPSB7XG4gICAgY29kZTogMzQsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07IC8vIHN5bWJvbHNcblxuICBfa2V5c1snPSddID0ge1xuICAgIGNvZGU6IDE4NyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJy0nXSA9IHtcbiAgICBjb2RlOiAxODksXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWyddJ10gPSB7XG4gICAgY29kZTogMjIxLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snWyddID0ge1xuICAgIGNvZGU6IDIxOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcblxuICB2YXIgZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50LCAna2V5ZG93bicpO1xuICB9O1xuXG4gIHZhciB1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50LCAna2V5dXAnKTtcbiAgfTsgLy8gaGFuZGxlIHRoZSBhY3R1YWx5IGJvdW5kIGtleSB3aXRoIHRoZSBldmVudFxuXG5cbiAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB0eXBlKSB7XG4gICAgaWYgKF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJvdW5kW2ldLnNoaWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5zaGlmdEtleSA9PSB0cnVlKSB7XG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlKSB7XG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBiaW5kIGEga2V5IHRvIGEgY2FsbGJhY2tcblxuXG4gIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHlwZSA9ICdrZXlkb3duJztcbiAgICB9XG5cbiAgICBpZiAoX2tleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcbiAgICB9XG5cbiAgICBpZiAoX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcbiAgICB9XG5cbiAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXS5wdXNoKHtcbiAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgIHNoaWZ0OiBfa2V5c1trZXldLnNoaWZ0XG4gICAgfSk7XG4gIH07IC8vIGJpbmQgYWxsIGtleXMgdG8gYSBjYWxsIGJhY2sgKGRlbW8gcHVycG9zZXMpXG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLmJpbmRBbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xuICAgICAgaWYgKF9rZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kKGtleSwgY2FsbGJhY2ssIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gZ2V0IHRoZSBrZXkgbGFiZWwgZnJvbSBhbiBldmVudFxuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy5nZXRLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcbiAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSA9PSB0cnVlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gZmFsc2UgJiYgX2tleXNba2V5XS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUgJiYga2V5ID09ICdzaGlmdCcpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwidW5rbm93biBrZXksIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCI7XG4gIH07IC8vIHVuYmluZCBlaXRoZXIgYSBzcGVjaWZpYyBjYWxsYmFjayBmcm9tIGEga2V5IG9yIGFsbCBvZiB0aGVtIChieSBsZWF2aW5nIGNhbGxiYWNrIHVuZGVmaW5lZClcblxuXG4gIF9leHBvcnRGdW5jdGlvbnMudW5iaW5kID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgIH1cblxuICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgbmV3QmluZGluZ3MgPSBbXTtcbiAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdO1xuXG4gICAgICBpZiAoYm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCEoYm91bmRbaV0uZm4gPT0gY2FsbGJhY2sgJiYgYm91bmRbaV0uc2hpZnQgPT0gX2tleXNba2V5XS5zaGlmdCkpIHtcbiAgICAgICAgICAgIG5ld0JpbmRpbmdzLnB1c2goX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IG5ld0JpbmRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xuICAgIH1cbiAgfTsgLy8gcmVzZXQgYWxsIGJvdW5kIHZhcmlhYmxlcy5cblxuXG4gIF9leHBvcnRGdW5jdGlvbnMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2JvdW5kID0ge1xuICAgICAga2V5ZG93bjoge30sXG4gICAgICBrZXl1cDoge31cbiAgICB9O1xuICB9OyAvLyB1bmJpbmQgYWxsIGxpc3RlbmVycyBhbmQgcmVzZXQgYWxsIHZhcmlhYmxlcy5cblxuXG4gIF9leHBvcnRGdW5jdGlvbnMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYm91bmQgPSB7XG4gICAgICBrZXlkb3duOiB7fSxcbiAgICAgIGtleXVwOiB7fVxuICAgIH07XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duLCB0cnVlKTtcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cCwgdHJ1ZSk7XG4gIH07IC8vIGNyZWF0ZSBsaXN0ZW5lcnMuXG5cblxuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd24sIHRydWUpO1xuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cCwgdHJ1ZSk7IC8vIHJldHVybiB0aGUgcHVibGljIGZ1bmN0aW9ucy5cblxuICByZXR1cm4gX2V4cG9ydEZ1bmN0aW9ucztcbn1cblxuLyoqXG4gKiBOYXZpZ2F0aW9uIEhhbmRsZXJcbiAqL1xuXG52YXIgTmF2aWdhdGlvbkhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gTmF2aWdhdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOYXZpZ2F0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IHRydWU7XG5cbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlYWN0aXZhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOYXZpZ2F0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZWZyZXNoZXMgbmF2aWdhdGlvbiBhbmQgc2V0cyBrZXkgYmluZGluZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5hdmlnYXRpb25CdXR0b25zID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25zQ3JlYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmljb25zQ3JlYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNsZWFuTmF2aWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFuTmF2aWdhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbk5hdmlnYXRpb24oKSB7XG4gICAgICAvLyBjbGVhbiBoYW1tZXIgYmluZGluZ3NcbiAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgICAgfSAvLyBjbGVhbiB1cCBwcmV2aW91cyBuYXZpZ2F0aW9uIGl0ZW1zXG5cblxuICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkRPTSAmJiB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdICYmIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIG5vZGVzLiBUaGV5IGFyZSBkcmF3biBvdmVyIHRoZSByZXN0IG9mIHRoZSBub2RlcyBhbmQgYXJlIG5vdCBhZmZlY3RlZCBieSBzY2FsZSBhbmQgdHJhbnNsYXRpb25cbiAgICAgKiB0aGV5IGhhdmUgYSB0cmlnZ2VyRnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIG9uIGNsaWNrLiBJZiB0aGUgcG9zaXRpb24gb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMgaXMgZGVwZW5kZW50XG4gICAgICogb24gdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggb3IgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0LCB3ZSBmbGFnIGhvcml6b250YWxBbGlnbkxlZnQgYW5kIHZlcnRpY2FsQWxpZ25Ub3AgZmFsc2UuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHRoZSBsb2NhdGlvbiB3aWxsIGJlIGNvcnJlY3RlZCBieSB0aGUgX3JlbG9jYXRlTmF2aWdhdGlvbiBmdW5jdGlvbiBvbiBhIHNpemUgY2hhbmdlIG9mIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZE5hdmlnYXRpb25FbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY2xlYW5OYXZpZ2F0aW9uKCk7XG4gICAgICB0aGlzLm5hdmlnYXRpb25ET00gPSB7fTtcbiAgICAgIHZhciBuYXZpZ2F0aW9uRGl2cyA9IFtcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcInpvb21JblwiLCBcInpvb21PdXRcIiwgXCJ6b29tRXh0ZW5kc1wiXTtcbiAgICAgIHZhciBuYXZpZ2F0aW9uRGl2QWN0aW9ucyA9IFtcIl9tb3ZlVXBcIiwgXCJfbW92ZURvd25cIiwgXCJfbW92ZUxlZnRcIiwgXCJfbW92ZVJpZ2h0XCIsIFwiX3pvb21JblwiLCBcIl96b29tT3V0XCIsIFwiX2ZpdFwiXTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5jbGFzc05hbWUgPSBcInZpcy1uYXZpZ2F0aW9uXCI7XG4gICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYXZpZ2F0aW9uRGl2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXS5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLVwiICsgbmF2aWdhdGlvbkRpdnNbaV07XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0uYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSk7XG4gICAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuXG4gICAgICAgIGlmIChuYXZpZ2F0aW9uRGl2QWN0aW9uc1tpXSA9PT0gXCJfZml0XCIpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgICAgICBvblRvdWNoKGhhbW1lciwgYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5fZml0KS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgICAgIG9uVG91Y2goaGFtbWVyLCBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5iaW5kVG9SZWRyYXcpLmNhbGwoX2NvbnRleHQyLCB0aGlzLCBuYXZpZ2F0aW9uRGl2QWN0aW9uc1tpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lcik7XG4gICAgICB9IC8vIHVzZSBhIGhhbW1lciBmb3IgdGhlIHJlbGVhc2Ugc28gd2UgZG8gbm90IHJlcXVpcmUgdGhlIG9uZSB1c2VkIGluIHRoZSByZXN0IG9mIHRoZSBuZXR3b3JrXG4gICAgICAvLyB0aGUgb25lIHRoZSByZXN0IHVzZXMgY2FuIGJlIG92ZXJsb2FkZWQgYnkgdGhlIG1hbmlwdWxhdGlvbiBzeXN0ZW0uXG5cblxuICAgICAgdmFyIGhhbW1lckZyYW1lID0gbmV3IEhhbW1lcih0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICBvblJlbGVhc2UoaGFtbWVyRnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9zdG9wTW92ZW1lbnQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lckZyYW1lKTtcbiAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiaW5kVG9SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFRvUmVkcmF3KGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID0gYmluZCQ2KF9jb250ZXh0MyA9IHRoaXNbYWN0aW9uXSkuY2FsbChfY29udGV4dDMsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRGcm9tUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEZyb21SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgc3RvcHMgYWxsIG1vdmVtZW50IGluZHVjZWQgYnkgdGhlIG5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdCgpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNzAwKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB1Z2x5IGhhY2sgdG8gYXZvaWQgaGFtbWVyJ3MgZG91YmxlIGZpcmVpbmcgb2YgZXZlbnQgKGJlY2F1c2Ugd2UgdXNlIHJlbGVhc2U/KVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIsIHtcbiAgICAgICAgICBkdXJhdGlvbjogNzAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHN0b3BzIGFsbCBtb3ZlbWVudCBpbmR1Y2VkIGJ5IHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcE1vdmVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wTW92ZW1lbnQoKSB7XG4gICAgICBmb3IgKHZhciBib3VuZEFjdGlvbiBpbiB0aGlzLmJvdW5kRnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib3VuZEZ1bmN0aW9ucywgYm91bmRBY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2JvdW5kQWN0aW9uXSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVVwKCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlRG93bigpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlTGVmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUxlZnQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZVJpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlUmlnaHQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54IC09IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfem9vbUluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF96b29tSW4oKSB7XG4gICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlICogKDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcIitcIixcbiAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICBwb2ludGVyOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3pvb21PdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21PdXQoKSB7XG4gICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlIC8gKDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcIi1cIixcbiAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICBwb2ludGVyOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYmluZCBhbGwga2V5cyB1c2luZyBrZXljaGFybS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oe1xuICAgICAgICAgICAgY29udGFpbmVyOiB3aW5kb3csXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7XG4gICAgICAgICAgICBjb250YWluZXI6IHRoaXMuY2FudmFzLmZyYW1lLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMua2V5Y2hhcm0ucmVzZXQoKTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDUsIF9jb250ZXh0NiwgX2NvbnRleHQ3LCBfY29udGV4dDgsIF9jb250ZXh0OSwgX2NvbnRleHQxMCwgX2NvbnRleHQxMSwgX2NvbnRleHQxMiwgX2NvbnRleHQxMywgX2NvbnRleHQxNCwgX2NvbnRleHQxNSwgX2NvbnRleHQxNiwgX2NvbnRleHQxNywgX2NvbnRleHQxOCwgX2NvbnRleHQxOSwgX2NvbnRleHQyMCwgX2NvbnRleHQyMSwgX2NvbnRleHQyMiwgX2NvbnRleHQyMywgX2NvbnRleHQyNCwgX2NvbnRleHQyNSwgX2NvbnRleHQyNiwgX2NvbnRleHQyNztcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NCwgXCJ1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVVcFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQ1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDUsIFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NiwgXCJsZWZ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0NyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ3LCBcInJpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDggPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0OCwgXCI9XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDkgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0OSwgXCJudW0rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDEwID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEwLCBcIm51bS1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDExID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDExLCBcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDEyID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEyLCBcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDEzID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEzLCBcIl1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTQsIFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDE1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE1LCBcInBhZ2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxNiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNiwgXCJ1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDE3ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE3LCBcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZURvd25cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDE4ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE4LCBcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDE5ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE5LCBcInJpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjAgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjAsIFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDIxID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIxLCBcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyMiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMiwgXCJudW0tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDIzID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIzLCBcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjQsIFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyNSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyNSwgXCJdXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjYsIFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjcgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjcsIFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5hdmlnYXRpb25IYW5kbGVyO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQobywgbWluTGVuKSB7IHZhciBfY29udGV4dDE1OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MTUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQxNSwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ0KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBIYW5kbGVyIGZvciBpbnRlcmFjdGlvbnNcbiAqL1xuXG52YXIgSW50ZXJhY3Rpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcmFjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgdmFyIF9jb250ZXh0LCBfY29udGV4dDIsIF9jb250ZXh0MywgX2NvbnRleHQ0LCBfY29udGV4dDUsIF9jb250ZXh0NiwgX2NvbnRleHQ3LCBfY29udGV4dDgsIF9jb250ZXh0OSwgX2NvbnRleHQxMCwgX2NvbnRleHQxMSwgX2NvbnRleHQxMiwgX2NvbnRleHQxMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbkhhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIgPSBuZXcgTmF2aWdhdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKTsgLy8gYmluZCB0aGUgZXZlbnRzIGZyb20gaGFtbWVyIHRvIGZ1bmN0aW9ucyBpbiB0aGlzIG9iamVjdFxuXG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwID0gYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5vblRhcCkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2ggPSBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5vblRvdWNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwID0gYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMub25Eb3VibGVUYXApLmNhbGwoX2NvbnRleHQzLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkID0gYmluZCQ2KF9jb250ZXh0NCA9IHRoaXMub25Ib2xkKS5jYWxsKF9jb250ZXh0NCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0ID0gYmluZCQ2KF9jb250ZXh0NSA9IHRoaXMub25EcmFnU3RhcnQpLmNhbGwoX2NvbnRleHQ1LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnID0gYmluZCQ2KF9jb250ZXh0NiA9IHRoaXMub25EcmFnKS5jYWxsKF9jb250ZXh0NiwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZCA9IGJpbmQkNihfY29udGV4dDcgPSB0aGlzLm9uRHJhZ0VuZCkuY2FsbChfY29udGV4dDcsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwgPSBiaW5kJDYoX2NvbnRleHQ4ID0gdGhpcy5vbk1vdXNlV2hlZWwpLmNhbGwoX2NvbnRleHQ4LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaCA9IGJpbmQkNihfY29udGV4dDkgPSB0aGlzLm9uUGluY2gpLmNhbGwoX2NvbnRleHQ5LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUgPSBiaW5kJDYoX2NvbnRleHQxMCA9IHRoaXMub25Nb3VzZU1vdmUpLmNhbGwoX2NvbnRleHQxMCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZSA9IGJpbmQkNihfY29udGV4dDExID0gdGhpcy5vblJlbGVhc2UpLmNhbGwoX2NvbnRleHQxMSwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dCA9IGJpbmQkNihfY29udGV4dDEyID0gdGhpcy5vbkNvbnRleHQpLmNhbGwoX2NvbnRleHQxMiwgdGhpcyk7XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICB0aGlzLnBvcHVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlciA9IGJpbmQkNihfY29udGV4dDEzID0gdGhpcy5nZXRQb2ludGVyKS5jYWxsKF9jb250ZXh0MTMsIHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzcGVlZDoge1xuICAgICAgICAgIHg6IDEwLFxuICAgICAgICAgIHk6IDEwLFxuICAgICAgICAgIHpvb206IDAuMDJcbiAgICAgICAgfSxcbiAgICAgICAgYmluZFRvV2luZG93OiB0cnVlLFxuICAgICAgICBhdXRvRm9jdXM6IHRydWVcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgICB0b29sdGlwRGVsYXk6IDMwMCxcbiAgICAgIHpvb21WaWV3OiB0cnVlLFxuICAgICAgem9vbVNwZWVkOiAxXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJhY3Rpb25IYW5kbGVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnBvcHVwVGltZXIpO1xuICAgICAgICBkZWxldGUgX3RoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBleHRlbmQgYWxsIGJ1dCB0aGUgdmFsdWVzIGluIGZpZWxkc1xuICAgICAgICB2YXIgZmllbGRzID0gW1wiaGlkZUVkZ2VzT25EcmFnXCIsIFwiaGlkZUVkZ2VzT25ab29tXCIsIFwiaGlkZU5vZGVzT25EcmFnXCIsIFwia2V5Ym9hcmRcIiwgXCJtdWx0aXNlbGVjdFwiLCBcInNlbGVjdGFibGVcIiwgXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXTtcbiAgICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIG1lcmdlIHRoZSBrZXlib2FyZCBvcHRpb25zIGluLlxuXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwia2V5Ym9hcmRcIik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCkge1xuICAgICAgICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucy50b29sdGlwLCBvcHRpb25zLnRvb2x0aXApO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcC5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvb2x0aXAuY29sb3IgPSBwYXJzZUNvbG9yKG9wdGlvbnMudG9vbHRpcC5jb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gZnJvbSBhIHRvdWNoIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRvdWNoXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludGVyKHRvdWNoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0b3VjaC54IC0gZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyksXG4gICAgICAgIHk6IHRvdWNoLnkgLSBnZXRBYnNvbHV0ZVRvcCh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBzdGFydCBvZiBhIHRvdWNoIGdlc3R1cmUsIHN0b3JlIHRoZSBwb2ludGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Ub3VjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDUwKSB7XG4gICAgICAgIHRoaXMuZHJhZy5wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTsgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0YXAvY2xpY2sgZXZlbnQ6IHNlbGVjdC91bnNlbGVjdCBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uVGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGFwKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3QgJiYgKGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5jdHJsS2V5IHx8IGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5tZXRhS2V5KTtcbiAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIG11bHRpc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkb3VibGV0YXAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRG91YmxlVGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRvdWJsZUNsaWNrXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIGxvbmcgdGFwIGV2ZW50OiBtdWx0aSBzZWxlY3Qgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uSG9sZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhvbGQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdDtcbiAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIG11bHRpc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiaG9sZFwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0aGUgcmVsZWFzZSBvZiB0aGUgc2NyZWVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblJlbGVhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWxlYXNlKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJyZWxlYXNlXCIsIGV2ZW50LCBwb2ludGVyKTsgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbnRleHQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwib25jb250ZXh0XCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFuZCBkZXNlbGVjdCBub2RlcyBkZXBlbmRpbmcgY3VycmVudCBzZWxlY3Rpb24gY2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWRkPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tTZWxlY3Rpb25DaGFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyKSB7XG4gICAgICB2YXIgYWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKGFkZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T25Qb2ludChwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBub2RlIGFuZCBlZGdlIGlkJ3MgZnJvbSB0aGUgZmlyc3Qgc2V0IHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIHNlY29uZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19IGZpcnN0U2V0XG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fSBzZWNvbmRTZXRcbiAgICAgKiBAcmV0dXJucyB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZURpZmZlcmVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZURpZmZlcmVuY2UoZmlyc3RTZXQsIHNlY29uZFNldCkge1xuICAgICAgdmFyIGFycmF5RGlmZiA9IGZ1bmN0aW9uIGFycmF5RGlmZihmaXJzdEFyciwgc2Vjb25kQXJyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmlyc3RBcnJbaV07XG5cbiAgICAgICAgICBpZiAoaW5kZXhPZihzZWNvbmRBcnIpLmNhbGwoc2Vjb25kQXJyLCB2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiBhcnJheURpZmYoZmlyc3RTZXQubm9kZXMsIHNlY29uZFNldC5ub2RlcyksXG4gICAgICAgIGVkZ2VzOiBhcnJheURpZmYoZmlyc3RTZXQuZWRnZXMsIHNlY29uZFNldC5lZGdlcylcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IG9uRHJhZ1N0YXJ0LlxuICAgICAqIEl0IGlzIHNlcGFyYXRlZCBvdXQgYmVjYXVzZSB3ZSBjYW4gdGhlbiBvdmVybG9hZCBpdCBmb3IgdGhlIGRhdGFtYW5pcHVsYXRpb24gc3lzdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25EcmFnU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZHJhZ2dpbmcsIGRvIG5vdCBzdGFydFxuICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIG9uIHRvdWNoIHNjcmVlbnMgd2l0aCBtdWx0aXBsZSBmaW5nZXJzXG4gICAgICBpZiAodGhpcy5kcmFnLmRyYWdnaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy9pbiBjYXNlIHRoZSB0b3VjaCBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIGFuIGV4dGVybmFsIGRpdiwgZG8gdGhlIGluaXRpYWwgdG91Y2ggbm93LlxuXG5cbiAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaChldmVudCk7XG4gICAgICB9IC8vIG5vdGU6IGRyYWcucG9pbnRlciBpcyBzZXQgaW4gb25Ub3VjaCB0byBnZXQgdGhlIGluaXRpYWwgdG91Y2ggbG9jYXRpb25cblxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQodGhpcy5kcmFnLnBvaW50ZXIpO1xuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24gPSBbXTtcbiAgICAgIHRoaXMuZHJhZy50cmFuc2xhdGlvbiA9IGFzc2lnbiQyKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuXG4gICAgICB0aGlzLmRyYWcubm9kZUlkID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydCA9IHtcbiAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQgPSB7XG4gICAgICAgICAgeDogdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KSxcbiAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLmRyYWdOb2RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmRyYWcubm9kZUlkID0gbm9kZS5pZDsgLy8gc2VsZWN0IHRoZSBjbGlja2VkIG5vZGUgaWYgbm90IHlldCBzZWxlY3RlZFxuXG4gICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZS5pZF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhZnRlciBzZWxlY3QgdG8gY29udGFpbiB0aGUgbm9kZVxuXG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLCBldmVudCwgdGhpcy5kcmFnLnBvaW50ZXIpOyAvLyBjcmVhdGUgYW4gYXJyYXkgd2l0aCB0aGUgc2VsZWN0ZWQgbm9kZXMgYW5kIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFuZCBzdGF0dXNcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNCh0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHMgPSB7XG4gICAgICAgICAgICAgIGlkOiBfbm9kZS5pZCxcbiAgICAgICAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgICAgICAgIC8vIHN0b3JlIG9yaWdpbmFsIHgsIHksIHhGaXhlZCBhbmQgeUZpeGVkLCBtYWtlIHRoZSBub2RlIHRlbXBvcmFyaWx5IEZpeGVkXG4gICAgICAgICAgICAgIHg6IF9ub2RlLngsXG4gICAgICAgICAgICAgIHk6IF9ub2RlLnksXG4gICAgICAgICAgICAgIHhGaXhlZDogX25vZGUub3B0aW9ucy5maXhlZC54LFxuICAgICAgICAgICAgICB5Rml4ZWQ6IF9ub2RlLm9wdGlvbnMuZml4ZWQueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9ub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICBfbm9kZS5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnLnNlbGVjdGlvbi5wdXNoKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayBpZiBubyBub2RlIGlzIHNlbGVjdGVkIGFuZCB0aHVzIHRoZSB2aWV3IGlzIGRyYWdnZWQuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25EcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZyhldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmRyYWcucGluY2hlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHJlbW92ZSB0aGUgZm9jdXMgb24gbm9kZSBpZiBpdCBpcyBmb2N1c3NlZCBvbiBieSB0aGUgZm9jdXNPbk5vZGVcblxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwidW5sb2NrTm9kZVwiKTtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoICYmIHRoaXMub3B0aW9ucy5kcmFnTm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyKTsgLy8gY2FsY3VsYXRlIGRlbHRhJ3MgYW5kIG5ldyBsb2NhdGlvblxuXG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICB2YXIgZGVsdGFZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTsgLy8gdXBkYXRlIHBvc2l0aW9uIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuXG4gICAgICAgIGZvckVhY2gkMihzZWxlY3Rpb24pLmNhbGwoc2VsZWN0aW9uLCBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3Rpb24ubm9kZTsgLy8gb25seSBtb3ZlIHRoZSBub2RlIGlmIGl0IHdhcyBub3QgZml4ZWQgaW5pdGlhbGx5XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uLnhGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IF90aGlzMi5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueCkgKyBkZWx0YVgpO1xuICAgICAgICAgIH0gLy8gb25seSBtb3ZlIHRoZSBub2RlIGlmIGl0IHdhcyBub3QgZml4ZWQgaW5pdGlhbGx5XG5cblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ueUZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS55ID0gX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9ZY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi55KSArIGRlbHRhWSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gc3RhcnQgdGhlIHNpbXVsYXRpb24gb2YgdGhlIHBoeXNpY3NcblxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgc2VsZWN0aW9uIGJveFxuICAgICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIGlmIHRoZSBkcmFnIHdhcyBub3Qgc3RhcnRlZCBwcm9wZXJseSBiZWNhdXNlIHRoZSBjbGljayBzdGFydGVkIG91dHNpZGUgdGhlIG5ldHdvcmsgZGl2LCBzdGFydCBpdCBub3cuXG5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5lbmQgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgICAgeTogdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9IC8vIG1vdmUgdGhlIG5ldHdvcmtcblxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ1ZpZXcgPT09IHRydWUgJiYgIWV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpOyAvLyBpZiB0aGUgZHJhZyB3YXMgbm90IHN0YXJ0ZWQgcHJvcGVybHkgYmVjYXVzZSB0aGUgY2xpY2sgc3RhcnRlZCBvdXRzaWRlIHRoZSBuZXR3b3JrIGRpdiwgc3RhcnQgaXQgbm93LlxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMuZHJhZy5wb2ludGVyLng7XG4gICAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi54ICsgZGlmZlgsXG4gICAgICAgICAgICB5OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueSArIGRpZmZZXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRHJhZ0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdFbmQoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdykge1xuICAgICAgICB2YXIgX2NvbnRleHQxNDtcblxuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkJveFBvc2l0aW9uID0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkJveFBvc2l0aW9uTWluTWF4ID0ge1xuICAgICAgICAgIG1pblg6IE1hdGgubWluKHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LngsIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC54KSxcbiAgICAgICAgICBtaW5ZOiBNYXRoLm1pbihzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC55LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueSksXG4gICAgICAgICAgbWF4WDogTWF0aC5tYXgoc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueCwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLngpLFxuICAgICAgICAgIG1heFk6IE1hdGgubWF4KHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LnksIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC55KVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b0JlU2VsZWN0ZWROb2RlcyA9IGZpbHRlcihfY29udGV4dDE0ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MTQsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCA+PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5taW5YICYmIG5vZGUueCA8PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5tYXhYICYmIG5vZGUueSA+PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5taW5ZICYmIG5vZGUueSA8PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5tYXhZO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3JFYWNoJDIodG9CZVNlbGVjdGVkTm9kZXMpLmNhbGwodG9CZVNlbGVjdGVkTm9kZXMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yRWFjaCQyKHNlbGVjdGlvbikuY2FsbChzZWxlY3Rpb24sIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHhGaXhlZCBhbmQgeUZpeGVkXG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC54ID0gcy54Rml4ZWQ7XG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC55ID0gcy55Rml4ZWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcikpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIiwgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblBpbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGluY2goZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLmRyYWcucGluY2hlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLnBpbmNoW1wic2NhbGVcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpbmNoLnNjYWxlID0gMTtcbiAgICAgIH0gLy8gVE9ETzogZW5hYmxlZCBtb3Zpbmcgd2hpbGUgcGluY2hpbmc/XG5cblxuICAgICAgdmFyIHNjYWxlID0gdGhpcy5waW5jaC5zY2FsZSAqIGV2ZW50LnNjYWxlO1xuICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWm9vbSB0aGUgbmV0d29yayBpbiBvciBvdXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBhIG51bWJlciBhcm91bmQgMSwgYW5kIGJldHdlZW4gMC4wMSBhbmQgMTBcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgUG9zaXRpb24gb24gc2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbShzY2FsZSwgcG9pbnRlcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcblxuICAgICAgICBpZiAoc2NhbGUgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgc2NhbGUgPSAwLjAwMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYWxlID4gMTApIHtcbiAgICAgICAgICBzY2FsZSA9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5kcmFnZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHRoaXMuZHJhZy5wb2ludGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gKyB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IC8gMlxuXG5cbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiBwb2ludGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgICB2YXIgdHkgPSAoMSAtIHNjYWxlRnJhYykgKiBwb2ludGVyLnkgKyB0cmFuc2xhdGlvbi55ICogc2NhbGVGcmFjO1xuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiB0eCxcbiAgICAgICAgICB5OiB0eVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwcmVTY2FsZURyYWdQb2ludGVyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwb3N0U2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKHByZVNjYWxlRHJhZ1BvaW50ZXIpO1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnggPSBwb3N0U2NhbGVEcmFnUG9pbnRlci54O1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnkgPSBwb3N0U2NhbGVEcmFnUG9pbnRlci55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuXG4gICAgICAgIGlmIChzY2FsZU9sZCA8IHNjYWxlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBcIitcIixcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiLVwiLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb20gdGhlIHRpbWVsaW5lXG4gICAgICogU2VlIGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvXG4gICAgICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy9pc3N1ZXMvMjU2XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9ICBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAgICAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgICAgICBpZiAoZXZlbnQuZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgc2NhbGVcbiAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICBzY2FsZSAqPSAxICsgKGV2ZW50LmRlbHRhWSA8IDAgPyAxIDogLTEpICogKHRoaXMub3B0aW9ucy56b29tU3BlZWQgKiAwLjEpOyAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgbG9jYXRpb25cblxuICAgICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfSk7IC8vIGFwcGx5IHRoZSBuZXcgc2NhbGVcblxuICAgICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICAgIH0gLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbnMgY2F1c2VkIGJ5IG1vdXNlIHdoZWVsLlxuXG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW91c2UgbW92ZSBoYW5kbGVyIGZvciBjaGVja2luZyB3aGV0aGVyIHRoZSB0aXRsZSBtb3ZlcyBvdmVyIGEgbm9kZSB3aXRoIGEgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvcHVwVmlzaWJsZSA9IGZhbHNlOyAvLyBjaGVjayBpZiB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBub2RlIGlzIHN0aWxsIHNlbGVjdGVkXG5cbiAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpO1xuICAgICAgICB9IC8vIGlmIHRoZSBwb3B1cCB3YXMgbm90IGhpZGRlbiBhYm92ZVxuXG5cbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHBvcHVwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiB3ZSBiaW5kIHRoZSBrZXlib2FyZCB0byB0aGUgZGl2LCB3ZSBoYXZlIHRvIGhpZ2hsaWdodCBpdCB0byB1c2UgaXQuIFRoaXMgaGlnaGxpZ2h0cyBpdCBvbiBtb3VzZSBvdmVyLlxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYXV0b0ZvY3VzICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmZvY3VzKCk7XG4gICAgICB9IC8vIHN0YXJ0IGEgdGltZW91dCB0aGF0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIHBvc2l0aW9uZWQgYWJvdmUgYW4gZWxlbWVudFxuXG5cbiAgICAgIGlmIChwb3B1cFZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wb3B1cFRpbWVyKTsgLy8gc3RvcCBhbnkgcnVubmluZyBjYWxjdWxhdGlvblRpbWVyXG5cbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZHJhZy5kcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMucG9wdXBUaW1lciA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9jaGVja1Nob3dQb3B1cChwb2ludGVyKTtcbiAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMudG9vbHRpcERlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhZGRpbmcgaG92ZXIgaGlnaGxpZ2h0c1xuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmhvdmVyT2JqZWN0KGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZWxlbWVudCBvbiB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIG5ldHdvcmtcbiAgICAgKiAoYSBub2RlIG9yIGVkZ2UpLiBJZiBzbywgYW5kIGlmIHRoaXMgZWxlbWVudCBoYXMgYSB0aXRsZSxcbiAgICAgKiBzaG93IGEgcG9wdXAgd2luZG93IHdpdGggaXRzIHRpdGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tTaG93UG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KTtcblxuICAgICAgdmFyIHkgPSB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgYm90dG9tOiB5XG4gICAgICB9O1xuICAgICAgdmFyIHByZXZpb3VzUG9wdXBPYmpJZCA9IHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMucG9wdXBPYmouaWQ7XG4gICAgICB2YXIgbm9kZVVuZGVyQ3Vyc29yID0gZmFsc2U7XG4gICAgICB2YXIgcG9wdXBUeXBlID0gXCJub2RlXCI7IC8vIGNoZWNrIGlmIGEgbm9kZSBpcyB1bmRlciB0aGUgY3Vyc29yLlxuXG4gICAgICBpZiAodGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgbm9kZXMgZm9yIG92ZXJsYXAsIHNlbGVjdCB0aGUgdG9wIG9uZSBpbiBjYXNlIG9mIG11bHRpcGxlIG5vZGVzXG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICAgIGlmIChub2RlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5nZXRUaXRsZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdOb2Rlcy5wdXNoKG5vZGVJbmRpY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZSBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgICAgICB0aGlzLnBvcHVwT2JqID0gbm9kZXNbb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdXTsgLy8gaWYgeW91IGhvdmVyIG92ZXIgYSBub2RlLCB0aGUgdGl0bGUgb2YgdGhlIGVkZ2UgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNob3duLlxuXG4gICAgICAgICAgbm9kZVVuZGVyQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkICYmIG5vZGVVbmRlckN1cnNvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gc2VhcmNoIHRoZSBlZGdlcyBmb3Igb3ZlcmxhcFxuICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIGVkZ2U7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaV1dO1xuXG4gICAgICAgICAgaWYgKGVkZ2UuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUluZGljZXNbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IGVkZ2VzW292ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgcG9wdXBUeXBlID0gXCJlZGdlXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzaG93IHBvcHVwIG1lc3NhZ2Ugd2luZG93XG4gICAgICAgIGlmICh0aGlzLnBvcHVwT2JqLmlkICE9PSBwcmV2aW91c1BvcHVwT2JqSWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3B1cCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwID0gbmV3IFBvcHVwKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZSA9IHBvcHVwVHlwZTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQgPSB0aGlzLnBvcHVwT2JqLmlkOyAvLyBhZGp1c3QgYSBzbWFsbCBvZmZzZXQgc3VjaCB0aGF0IHRoZSBtb3VzZSBjdXJzb3IgaXMgbG9jYXRlZCBpbiB0aGVcbiAgICAgICAgICAvLyBib3R0b20gbGVmdCBsb2NhdGlvbiBvZiB0aGUgcG9wdXAsIGFuZCB5b3UgY2FuIGVhc2lseSBtb3ZlIG92ZXIgdGhlXG4gICAgICAgICAgLy8gcG9wdXAgYXJlYVxuXG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNldFRleHQodGhpcy5wb3B1cE9iai5nZXRUaXRsZSgpKTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic2hvd1BvcHVwXCIsIHRoaXMucG9wdXBPYmouaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5wb3B1cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cC5oaWRlKCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhpZGVQb3B1cFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcG9wdXAgbXVzdCBiZSBoaWRkZW4sIHdoaWNoIGlzIHRoZSBjYXNlIHdoZW4gdGhlIG1vdXNlIGlzIG5vXG4gICAgICogbG9uZ2VyIGhvdmVyaW5nIG9uIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrSGlkZVBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0hpZGVQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIHZhciBzdGlsbE9uT2JqID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdGlsbE9uT2JqID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7IC8vIGlmIHRoZSBtb3VzZSBpcyBzdGlsbCBvbmUgdGhlIG5vZGUsIHdlIGhhdmUgdG8gY2hlY2sgaWYgaXQgaXMgbm90IGFsc28gb24gb25lIHRoYXQgaXMgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgIC8vIHdlIGluaXRpYWxseSBvbmx5IGNoZWNrIHN0aWxsT25PYmogYmVjYXVzZSB0aGlzIGlzIG11Y2ggZmFzdGVyLlxuXG4gICAgICAgICAgaWYgKHN0aWxsT25PYmogPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBvdmVyTm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICAgICAgICBzdGlsbE9uT2JqID0gb3Zlck5vZGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3Zlck5vZGUuaWQgPT09IHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RpbGxPbk9iaiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cE9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3B1cC5oaWRlKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJoaWRlUG9wdXBcIik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludGVyYWN0aW9uSGFuZGxlcjtcbn0oKTtcblxudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHJlZGVmaW5lQWxsJDEgPSByZWRlZmluZUFsbCQzO1xudmFyIGdldFdlYWtEYXRhID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzLmdldFdlYWtEYXRhO1xudmFyIGFuT2JqZWN0ID0gYW5PYmplY3QkZDtcbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkajtcbnZhciBhbkluc3RhbmNlID0gYW5JbnN0YW5jZSQzO1xudmFyIGl0ZXJhdGUgPSBpdGVyYXRlJDM7XG52YXIgQXJyYXlJdGVyYXRpb25Nb2R1bGUgPSBhcnJheUl0ZXJhdGlvbjtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG52YXIgZmluZCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmQ7XG52YXIgZmluZEluZGV4ID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZEluZGV4O1xudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzJDEoW10uc3BsaWNlKTtcbnZhciBpZCA9IDA7IC8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xuXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uIChzdG9yZSkge1xuICByZXR1cm4gc3RvcmUuZnJvemVuIHx8IChzdG9yZS5mcm96ZW4gPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG5cbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudHJpZXMgPSBbXTtcbn07XG5cbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuXG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO2Vsc2UgdGhpcy5lbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHNwbGljZSh0aGlzLmVudHJpZXMsIGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG52YXIgY29sbGVjdGlvbldlYWskMSA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpZDogaWQrKyxcbiAgICAgICAgZnJvemVuOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHtcbiAgICAgICAgdGhhdDogdGhhdCxcbiAgICAgICAgQVNfRU5UUklFUzogSVNfTUFQXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuc2V0KGtleSwgdmFsdWUpO2Vsc2UgZGF0YVtzdGF0ZS5pZF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICByZWRlZmluZUFsbCQxKFByb3RvdHlwZSwge1xuICAgICAgLy8gYHsgV2Vha01hcCwgV2Vha1NldCB9LnByb3RvdHlwZS5kZWxldGUoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0JDEoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmIGhhc093bihkYXRhLCBzdGF0ZS5pZCkgJiYgZGVsZXRlIGRhdGFbc3RhdGUuaWRdO1xuICAgICAgfSxcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmhhc1xuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghaXNPYmplY3QkMShrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWRlZmluZUFsbCQxKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZ2V0XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblxuICAgICAgICBpZiAoaXNPYmplY3QkMShrZXkpKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuZ2V0KGtleSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3N0YXRlLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5zZXRcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5hZGRcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxufTtcblxudmFyIGdsb2JhbCQxID0gZ2xvYmFsJFA7XG52YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHJlZGVmaW5lQWxsID0gcmVkZWZpbmVBbGwkMztcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzO1xudmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uJDM7XG52YXIgY29sbGVjdGlvbldlYWsgPSBjb2xsZWN0aW9uV2VhayQxO1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkajtcbnZhciBpc0V4dGVuc2libGUgPSBvYmplY3RJc0V4dGVuc2libGU7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmVuZm9yY2U7XG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBJU19JRTExID0gIWdsb2JhbCQxLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbCQxO1xudmFyIEludGVybmFsV2Vha01hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07IC8vIGBXZWFrTWFwYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLWNvbnN0cnVjdG9yXG5cblxudmFyICRXZWFrTWFwID0gY29sbGVjdGlvbignV2Vha01hcCcsIHdyYXBwZXIsIGNvbGxlY3Rpb25XZWFrKTsgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuLy8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDg1XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkge1xuICBJbnRlcm5hbFdlYWtNYXAgPSBjb2xsZWN0aW9uV2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCAnV2Vha01hcCcsIHRydWUpO1xuICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLmVuYWJsZSgpO1xuICB2YXIgV2Vha01hcFByb3RvdHlwZSA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZURlbGV0ZSA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGVbJ2RlbGV0ZSddKTtcbiAgdmFyIG5hdGl2ZUhhcyA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuaGFzKTtcbiAgdmFyIG5hdGl2ZUdldCA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuZ2V0KTtcbiAgdmFyIG5hdGl2ZVNldCA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuc2V0KTtcbiAgcmVkZWZpbmVBbGwoV2Vha01hcFByb3RvdHlwZSwge1xuICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVEZWxldGUodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW5bJ2RlbGV0ZSddKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVEZWxldGUodGhpcywga2V5KTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuLmhhcyhrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlR2V0KHRoaXMsIGtleSkgOiBzdGF0ZS5mcm96ZW4uZ2V0KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVHZXQodGhpcywga2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgbmF0aXZlSGFzKHRoaXMsIGtleSkgPyBuYXRpdmVTZXQodGhpcywga2V5LCB2YWx1ZSkgOiBzdGF0ZS5mcm96ZW4uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIG5hdGl2ZVNldCh0aGlzLCBrZXksIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHBhdGggPSBwYXRoJHk7XG52YXIgd2Vha01hcCQyID0gcGF0aC5XZWFrTWFwO1xuXG52YXIgcGFyZW50JDEgPSB3ZWFrTWFwJDI7XG52YXIgd2Vha01hcCQxID0gcGFyZW50JDE7XG5cbnZhciB3ZWFrTWFwID0gd2Vha01hcCQxO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSksIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobywgbWluTGVuKSB7IHZhciBfY29udGV4dDI7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MiwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlcjtcbi8qKlxyXG4gKiBAcGFyYW0gcHJldlxyXG4gKiBAcGFyYW0gbmV4dFxyXG4gKi9cblxuZnVuY3Rpb24gZGlmZlNldHMocHJldiwgbmV4dCkge1xuICB2YXIgZGlmZiA9IG5ldyBzZXQoKTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhuZXh0KSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghcHJldi5oYXMoaXRlbSkpIHtcbiAgICAgICAgZGlmZi5hZGQoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gZGlmZjtcbn1cblxudmFyIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKTtcblxuICAgIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24uc2V0KHRoaXMsIG5ldyBzZXQoKSk7XG5cbiAgICBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbi5zZXQodGhpcywgbmV3IHNldCgpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgaXRlbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2l0ZW1zID0gaXRlbXM7IF9pIDwgX2l0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IF9pdGVtc1tfaV07XG5cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLmFkZChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGl0ZW1zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pdGVtczIgPSBpdGVtczsgX2kyIDwgX2l0ZW1zMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBpdGVtID0gX2l0ZW1zMltfaTJdO1xuXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5kZWxldGUoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhbmdlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZGVkOiBfdG9Db25zdW1hYmxlQXJyYXkoZGlmZlNldHMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIiksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSkpLFxuICAgICAgICBkZWxldGVkOiBfdG9Db25zdW1hYmxlQXJyYXkoZGlmZlNldHMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIFwiZlwiKSkpLFxuICAgICAgICBwcmV2aW91czogX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBzZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIikpKSxcbiAgICAgICAgY3VycmVudDogX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBzZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpKSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuZ2V0Q2hhbmdlcygpO1xuXG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSwgXCJmXCIpO1xuXG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBuZXcgc2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpKSwgXCJmXCIpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoY2hhbmdlcy5hZGRlZCksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoY2hhbmdlcy5kZWxldGVkKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9pdGVtID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgX2l0ZW0udW5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3I7XG59KCk7XG5cbl9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24gPSBuZXcgd2Vha01hcCgpLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiA9IG5ldyB3ZWFrTWFwKCk7XG52YXIgU2VsZWN0aW9uQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZWxlY3Rpb25BY2N1bXVsYXRvcigpIHtcbiAgICB2YXIgY29tbWl0SGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uQWNjdW11bGF0b3IpO1xuXG4gICAgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLnNldCh0aGlzLCBuZXcgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKCkpO1xuXG4gICAgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLnNldCh0aGlzLCBuZXcgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKCkpO1xuXG4gICAgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG5cbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyLCBjb21taXRIYW5kbGVyLCBcImZcIik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcInNpemVOb2Rlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZUVkZ2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlcygpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlcygpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlcygpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTtcblxuICAgICAgKF9jbGFzc1ByaXZhdGVGaWVsZEdlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKSkuYWRkLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlcygpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTI7XG5cbiAgICAgIChfY2xhc3NQcml2YXRlRmllbGRHZTIgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpKS5hZGQuYXBwbHkoX2NsYXNzUHJpdmF0ZUZpZWxkR2UyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVOb2Rlcyhub2RlKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmRlbGV0ZShub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlRWRnZXMoZWRnZSkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5kZWxldGUoZWRnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5jbGVhcigpO1xuXG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2UzLCBfY29udGV4dDtcblxuICAgICAgdmFyIHN1bW1hcnkgPSB7XG4gICAgICAgIG5vZGVzOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmNvbW1pdCgpLFxuICAgICAgICBlZGdlczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5jb21taXQoKVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIHJlc3RbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgKF9jbGFzc1ByaXZhdGVGaWVsZEdlMyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIsIFwiZlwiKSkuY2FsbC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZTMsIGNvbmNhdChfY29udGV4dCA9IFt0aGlzLCBzdW1tYXJ5XSkuY2FsbChfY29udGV4dCwgcmVzdCkpO1xuXG4gICAgICByZXR1cm4gc3VtbWFyeTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0aW9uQWNjdW11bGF0b3I7XG59KCk7XG5fU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMgPSBuZXcgd2Vha01hcCgpLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMgPSBuZXcgd2Vha01hcCgpLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlciA9IG5ldyB3ZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MzsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQzLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIFRoZSBoYW5kbGVyIGZvciBzZWxlY3Rpb25zXG4gKi9cblxudmFyIFNlbGVjdGlvbkhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gU2VsZWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbkhhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhczsgLy8gVE9ETzogQ29uc2lkZXIgZmlyaW5nIGFuIGV2ZW50IG9uIGFueSBjaGFuZ2UgdG8gdGhlIHNlbGVjdGlvbiwgbm90XG4gICAgLy8gb25seSB0aG9zZSBjYXVzZWQgYnkgY2xpY2tzIGFuZCB0YXBzLiBJdCB3b3VsZCBiZSBlYXN5IHRvIGltcGxlbWVudFxuICAgIC8vIG5vdyBhbmQgKGF0IGxlYXN0IHRvIG1lKSBpdCBzZWVtcyBsaWtlIHNvbWV0aGluZyB0aGF0IGNvdWxkIGJlXG4gICAgLy8gcXVpdGUgdXNlZnVsLlxuXG4gICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IgPSBuZXcgU2VsZWN0aW9uQWNjdW11bGF0b3IoKTtcbiAgICB0aGlzLmhvdmVyT2JqID0ge1xuICAgICAgbm9kZXM6IHt9LFxuICAgICAgZWRnZXM6IHt9XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcIm11bHRpc2VsZWN0XCIsIFwiaG92ZXJDb25uZWN0ZWRFZGdlc1wiLCBcInNlbGVjdGFibGVcIiwgXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZXMgdGhlIHNlbGVjdGlvbiBwYXJ0IG9mIHRoZSB0YXA7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE9uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T25Qb2ludChwb2ludGVyKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKSB8fCB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTsgLy8gdW5zZWxlY3QgYWZ0ZXIgZ2V0dGluZyB0aGUgb2JqZWN0cyBpbiBvcmRlciB0byByZXN0b3JlIHdpZHRoIGFuZCBoZWlnaHQuXG5cbiAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0QWRkaXRpb25hbE9uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgdmFyIHNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKSB8fCB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcblxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YW5kYXJkIGZpZWxkcyBmb3IgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciBPYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdEJhc2VFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcikge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHByb3BlcnRpZXNbXCJwb2ludGVyXCJdID0ge1xuICAgICAgICBET006IHtcbiAgICAgICAgICB4OiBwb2ludGVyLngsXG4gICAgICAgICAgeTogcG9pbnRlci55XG4gICAgICAgIH0sXG4gICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcilcbiAgICAgIH07XG4gICAgICBwcm9wZXJ0aWVzW1wiZXZlbnRcIl0gPSBldmVudDtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBldmVudCB3aGljaCB0aGUgdXNlciBjYW4gY2F0Y2guXG4gICAgICpcbiAgICAgKiBUaGlzIGFkZHMgc29tZSBleHRyYSBkYXRhIHRvIHRoZSBldmVudCB3aXRoIHJlc3BlY3QgdG8gY3Vyc29yIHBvc2l0aW9uIGFuZFxuICAgICAqIHNlbGVjdGVkIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgICAgICAgICAgICAgICAgICAgICAgICAgIE5hbWUgb2YgZXZlbnQgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciAgICAgICAgICAgIE9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IHVuZGVmaW5lZH0gb2xkU2VsZWN0aW9uICAgICAgICAgICAgIElmIHByZXNlbnQsIHNlbGVjdGlvbiBzdGF0ZSBiZWZvcmUgZXZlbnQgb2NjdXJlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IFtlbXB0eVNlbGVjdGlvbj1mYWxzZV0gIEluZGljYXRlIGlmIHNlbGVjdGlvbiBkYXRhIHNob3VsZCBiZSBwYXNzZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlQ2xpY2tFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUNsaWNrRXZlbnQoZXZlbnRUeXBlLCBldmVudCwgcG9pbnRlciwgb2xkU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgZW1wdHlTZWxlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICBpZiAoZW1wdHlTZWxlY3Rpb24gPT09IHRydWUpIHtcbiAgICAgICAgcHJvcGVydGllcy5ub2RlcyA9IFtdO1xuICAgICAgICBwcm9wZXJ0aWVzLmVkZ2VzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgcHJvcGVydGllcy5ub2RlcyA9IHRtcC5ub2RlcztcbiAgICAgICAgcHJvcGVydGllcy5lZGdlcyA9IHRtcC5lZGdlcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZFNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXNbXCJwcmV2aW91c1NlbGVjdGlvblwiXSA9IG9sZFNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PSBcImNsaWNrXCIpIHtcbiAgICAgICAgLy8gRm9yIHRoZSB0aW1lIGJlaW5nLCByZXN0cmljdCB0aGlzIGZ1bmN0aW9uYWxpdHkgdG9cbiAgICAgICAgLy8ganVzdCB0aGUgY2xpY2sgZXZlbnQuXG4gICAgICAgIHByb3BlcnRpZXMuaXRlbXMgPSB0aGlzLmdldENsaWNrZWRJdGVtcyhwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmNvbnRyb2xFZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllcy5jb250cm9sRWRnZSA9IGV2ZW50LmNvbnRyb2xFZGdlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KGV2ZW50VHlwZSwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzPXRoaXMub3B0aW9ucy5zZWxlY3RDb25uZWN0ZWRFZGdlc11cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0RWRnZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMub3B0aW9ucy5zZWxlY3RDb25uZWN0ZWRFZGdlcztcblxuICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodEVkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkX3NlbGVjdGlvbkFjY3VtO1xuXG4gICAgICAgICAgICAoX3RoaXMkX3NlbGVjdGlvbkFjY3VtID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IpLmFkZEVkZ2VzLmFwcGx5KF90aGlzJF9zZWxlY3Rpb25BY2N1bSwgX3RvQ29uc3VtYWJsZUFycmF5KG9iai5lZGdlcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmFkZE5vZGVzKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuYWRkRWRnZXMob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzZWxlY3RPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcblxuICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5pc092ZXJsYXBwaW5nV2l0aChvYmplY3QpKSB7XG4gICAgICAgICAgb3ZlcmxhcHBpbmdOb2Rlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHBvc2l0aW9uIG9iamVjdCBpbiBjYW52YXNzcGFjZSBmcm9tIGEgc2luZ2xlIHBvaW50IGluIHNjcmVlbnNwYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKSB7XG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBjYW52YXNQb3MueCAtIDEsXG4gICAgICAgIHRvcDogY2FudmFzUG9zLnkgKyAxLFxuICAgICAgICByaWdodDogY2FudmFzUG9zLnggKyAxLFxuICAgICAgICBib3R0b206IGNhbnZhc1Bvcy55IC0gMVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3Agbm9kZSBhdCB0aGUgcGFzc2VkIHBvaW50IChsaWtlIGEgY2xpY2spXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5Ob2RlPXRydWVdXG4gICAgICogQHJldHVybnMge05vZGUgfCB1bmRlZmluZWR9IG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQXQocG9pbnRlcikge1xuICAgICAgdmFyIHJldHVybk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIC8vIHdlIGZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gbmF2aWdhdGlvbiBjb250cm9scyBlbGVtZW50XG4gICAgICB2YXIgcG9zaXRpb25PYmplY3QgPSB0aGlzLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSB0aGlzLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb3NpdGlvbk9iamVjdCk7IC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGVcbiAgICAgIC8vIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuXG5cbiAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHJldHVybk5vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIGVkZ2VzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0LCBzZWxlY3RvciBpcyBhcm91bmQgY2VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG92ZXJsYXBwaW5nRWRnZXMgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcykge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuXG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge251bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG5cbiAgICAgIHRoaXMuX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcyk7XG5cbiAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVkZ2VzIG5lYXJlc3QgdG8gdGhlIHBhc3NlZCBwb2ludCAobGlrZSBhIGNsaWNrKVxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuRWRnZT10cnVlXVxuICAgICAqIEByZXR1cm5zIHtFZGdlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZUF0KHBvaW50ZXIpIHtcbiAgICAgIHZhciByZXR1cm5FZGdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVkZ2VzLCBwaWNrIGNsb3Nlc3Qgd2l0aGluIDEwXG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgbWluZGlzdCA9IDEwO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZSA9IG51bGw7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgeEZyb20gPSBlZGdlLmZyb20ueDtcbiAgICAgICAgICB2YXIgeUZyb20gPSBlZGdlLmZyb20ueTtcbiAgICAgICAgICB2YXIgeFRvID0gZWRnZS50by54O1xuICAgICAgICAgIHZhciB5VG8gPSBlZGdlLnRvLnk7XG4gICAgICAgICAgdmFyIGRpc3QgPSBlZGdlLmVkZ2VUeXBlLmdldERpc3RhbmNlVG9FZGdlKHhGcm9tLCB5RnJvbSwgeFRvLCB5VG8sIGNhbnZhc1Bvcy54LCBjYW52YXNQb3MueSk7XG5cbiAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZSA9IGVkZ2VJZDtcbiAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXR1cm5FZGdlID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5lZGdlc1tvdmVybGFwcGluZ0VkZ2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFRvSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRvSG92ZXIob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLmhvdmVyT2JqLm5vZGVzW29iai5pZF0gPSBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhvdmVyT2JqLmVkZ2VzW29iai5pZF0gPSBvYmo7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNpbmdsZSBvcHRpb24gZnJvbSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVGcm9tU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzJF9zZWxlY3Rpb25BY2N1bTI7XG5cbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlTm9kZXMob2JqKTtcblxuICAgICAgICAoX3RoaXMkX3NlbGVjdGlvbkFjY3VtMiA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5kZWxldGVFZGdlcy5hcHBseShfdGhpcyRfc2VsZWN0aW9uQWNjdW0yLCBfdG9Db25zdW1hYmxlQXJyYXkob2JqLmVkZ2VzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVFZGdlcyhvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBhbGwgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zZWxlY3RBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3RBbGwoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBub2Rlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVOb2RlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgZWRnZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZEVkZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5zaXplRWRnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaG92ZXJDb25uZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGhpZ2hsaWdodCBmcm9tIGEgbm9kZSBvciBlZGdlLCBpbiByZXNwb25zZSB0byBtb3VzZSBtb3ZlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcGFyYW0ge05vZGV8dmlzLkVkZ2V9IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0Qmx1ckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIHByb3BlcnRpZXMubm9kZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ck5vZGVcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy5lZGdlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyRWRnZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGhpZ2hsaWdodCBmb3IgYSBub2RlIG9yIGVkZ2UsIGluIHJlc3BvbnNlIHRvIG1vdXNlIG1vdmVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7Tm9kZXx2aXMuRWRnZX0gb2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGhvdmVyQ2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0SG92ZXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICB2YXIgaG92ZXJDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChvYmplY3QuaG92ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIG9iamVjdC5ob3ZlciA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihvYmplY3QpO1xuXG4gICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vZGUgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhvdmVyTm9kZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmVkZ2UgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhvdmVyRWRnZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG92ZXJDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFjdGlvbnMgaW4gcmVzcG9uc2UgdG8gYSBtb3VzZSBtb3ZlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciB8IG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhvdmVyT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyT2JqZWN0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcik7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmplY3QgPSB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvdmVyQ2hhbmdlZCA9IGZhbHNlOyAvLyByZW1vdmUgYWxsIG5vZGUgaG92ZXIgaGlnaGxpZ2h0c1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ob3Zlck9iai5ub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmoubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiBvYmplY3QuaWQgIT0gbm9kZUlkIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyByZW1vdmluZyBhbGwgZWRnZSBob3ZlciBoaWdobGlnaHRzXG5cblxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuaG92ZXJPYmouZWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhvdmVyT2JqLmVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGhvdmVyIGhhcyBiZWVuIGNoYW5nZWQgaGVyZSBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBiZWVuIGhvdmVyZWQgb3ZlciBvciBvZmZcbiAgICAgICAgICAvLyB3ZSB0aGVuIGRvIG5vdCB1c2UgdGhlIGVtaXRCbHVyRXZlbnQgbWV0aG9kIGhlcmUuXG4gICAgICAgICAgaWYgKGhvdmVyQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdLmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH0gLy8gaWYgdGhlIGJsdXIgcmVtYWlucyB0aGUgc2FtZSBhbmQgdGhlIG9iamVjdCBpcyB1bmRlZmluZWQgKG1vdXNlIG9mZikgb3IgYW5vdGhlclxuICAgICAgICAgIC8vIGVkZ2UgaGFzIGJlZW4gaG92ZXJlZCwgb3IgYW5vdGhlciBub2RlIGhhcyBiZWVuIGhvdmVyZWQgd2UgYmx1ciB0aGUgZWRnZS5cbiAgICAgICAgICBlbHNlIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIG9iamVjdC5pZCAhPSBlZGdlSWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiAhb2JqZWN0LmhvdmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBob3ZlcmVkRWRnZXNDb3VudCA9IGtleXMkNCh0aGlzLmhvdmVyT2JqLmVkZ2VzKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGhvdmVyZWROb2Rlc0NvdW50ID0ga2V5cyQ0KHRoaXMuaG92ZXJPYmoubm9kZXMpLmxlbmd0aDtcblxuICAgICAgICB2YXIgbmV3T25seUhvdmVyZWRFZGdlID0gb2JqZWN0IGluc3RhbmNlb2YgRWRnZSAmJiBob3ZlcmVkRWRnZXNDb3VudCA9PT0gMCAmJiBob3ZlcmVkTm9kZXNDb3VudCA9PT0gMDtcbiAgICAgICAgdmFyIG5ld09ubHlIb3ZlcmVkTm9kZSA9IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgaG92ZXJlZEVkZ2VzQ291bnQgPT09IDAgJiYgaG92ZXJlZE5vZGVzQ291bnQgPT09IDA7XG5cbiAgICAgICAgaWYgKGhvdmVyQ2hhbmdlZCB8fCBuZXdPbmx5SG92ZXJlZEVkZ2UgfHwgbmV3T25seUhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdGhpcy5lbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmIHRoaXMub3B0aW9ucy5ob3ZlckNvbm5lY3RlZEVkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5faG92ZXJDb25uZWN0ZWRFZGdlcyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXQgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGJ1dCBkb24ndCBlbWl0IGFueSBldmVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRXaXRob3V0RW1pdHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0V2l0aG91dEVtaXR0aW5nKCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbmQgZGVzZWxlY3Qgbm9kZXMgZGVwZW5kaW5nIGN1cnJlbnQgc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEZvciBjaGFuZ2luZyBub2Rlcywgc2VsZWN0L2Rlc2VsZWN0IGV2ZW50cyBhcmUgZmlyZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBGb3IgYSBnaXZlbiBlZGdlLCBpZiBvbmUgY29ubmVjdGluZyBub2RlIGlzIGRlc2VsZWN0ZWQgYW5kIHdpdGggdGhlXG4gICAgICogc2FtZSBjbGljayB0aGUgb3RoZXIgbm9kZSBpcyBzZWxlY3RlZCwgbm8gZXZlbnRzIGZvciB0aGUgZWRnZSB3aWxsIGZpcmUuIEl0XG4gICAgICogd2FzIHNlbGVjdGVkIGFuZCBpdCB3aWxsIHJlbWFpbiBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciAtIFRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZVxuICAgICAqIGNsaWNrLCB0YXAsIGRyYWdlbmTigKYgdGhhdCB0cmlnZ2VyZWQgdGhpcy5cbiAgICAgKiBAcGFyYW0ge1VJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRBbmRFbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdEFuZEVtaXQocG9pbnRlciwgZXZlbnQpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlcyA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuXG4gICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB7XG4gICAgICAgIG5vZGVzOiBzZWxlY3Rpb25DaGFuZ2VzLm5vZGVzLnByZXZpb3VzLFxuICAgICAgICBlZGdlczogc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5wcmV2aW91c1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMuZWRnZXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3RFZGdlXCIsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMubm9kZXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3ROb2RlXCIsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMubm9kZXMuYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdE5vZGVcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLmVkZ2VzLmFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RFZGdlXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSAvLyBmaXJlIHRoZSBzZWxlY3QgZXZlbnQgaWYgYW55dGhpbmcgaGFzIGJlZW4gc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZFxuXG5cbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBzZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgYW5kIGVkZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tub2RlczogQXJyYXkuPHN0cmluZz4sIGVkZ2VzOiBBcnJheS48c3RyaW5nPn19IEFycmF5cyB3aXRoIHRoZVxuICAgICAqIGlkcyBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiB0aGlzLmdldFNlbGVjdGVkTm9kZUlkcygpLFxuICAgICAgICBlZGdlczogdGhpcy5nZXRTZWxlY3RlZEVkZ2VJZHMoKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBpZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZE5vZGVJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlSWRzKCkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5pZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWRFZGdlSWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkRWRnZUlkcygpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgIHJldHVybiBtYXAkMyhfY29udGV4dDIgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuaWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48c3RyaW5nPiwgZWRnZXM6IEFycmF5LjxzdHJpbmc+fX0gc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc2VsZWN0aW9uLm5vZGVzICYmICFzZWxlY3Rpb24uZWRnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG5vZGVzIGFuZC9vciBlZGdlcyBwcm9wZXJ0aWVzXCIpO1xuICAgICAgfSAvLyBmaXJzdCB1bnNlbGVjdCBhbnkgc2VsZWN0ZWQgbm9kZSwgaWYgb3B0aW9uIGlzIHRydWUgb3IgdW5kZWZpbmVkXG5cblxuICAgICAgaWYgKG9wdGlvbnMudW5zZWxlY3RBbGwgfHwgb3B0aW9ucy51bnNlbGVjdEFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbi5ub2Rlcykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihzZWxlY3Rpb24ubm9kZXMpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGlkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm9kZSB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfSAvLyBkb24ndCBzZWxlY3QgZWRnZXMgd2l0aCBpdFxuXG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG5vZGUsIG9wdGlvbnMuaGlnaGxpZ2h0RWRnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb24uZWRnZXMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHNlbGVjdGlvbi5lZGdlcyksXG4gICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9pZCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW19pZF07XG5cbiAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWRnZSB3aXRoIGlkIFwiJyArIF9pZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3QoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG5cbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIG5vZGVzIHdpdGggdGhlIG9wdGlvbiB0byBoaWdobGlnaHQgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0Tm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0Tm9kZXMoc2VsZWN0aW9uKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0RWRnZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93IFwiU2VsZWN0aW9uIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBpZHNcIjtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgbm9kZXM6IHNlbGVjdGlvblxuICAgICAgfSwge1xuICAgICAgICBoaWdobGlnaHRFZGdlczogaGlnaGxpZ2h0RWRnZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEVkZ2VzKHNlbGVjdGlvbikge1xuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzXCI7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbih7XG4gICAgICAgIGVkZ2VzOiBzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0aW9uOiByZW1vdmUgaWRzIG9mIG5vZGVzIHdoaWNoIG5vIGxvbmdlciBleGlzdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBub2RlIGluIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldE5vZGVzKCkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlLmlkKSkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZU5vZGVzKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGVkZ2UgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2UuaWQpKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlRWRnZXMoZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB0aGUgdmlzdWFsIGVsZW1lbnRzIGNsaWNrZWQgd2hpY2ggYXJlIG9uIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEFsbCBlbGVtZW50cyBhcmUgcmV0dXJuZWQ7IHRoaXMgaW5jbHVkZXMgbm9kZXMsIGVkZ2VzIGFuZCB0aGVpciBsYWJlbHMuXG4gICAgICogVGhlIG9yZGVyIHJldHVybmVkIGlzIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIGkuZS4gZWxlbWVudCAwIG9mIHRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyB0aGUgdG9wbW9zdCBpdGVtIGNsaWNrZWQgb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGNvbnNpc3RzIG9mIGFuIGFycmF5IG9mIHRoZSBmb2xsb3dpbmcgcG9zc2libGUgZWxlbWVudHM6XG4gICAgICpcbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlciwgbGFiZWxJZDowfWAgIC0gbGFiZWwgb2Ygbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZTpudW1iZXIsIGxhYmVsSWQ6MH1gICAgIC0gbGFiZWwgb2YgZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKlxuICAgICAqICMjIE5PVEVTXG4gICAgICpcbiAgICAgKiAtIEN1cnJlbnRseSwgdGhlcmUgaXMgb25seSBvbmUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIGEgbm9kZSBvciBhbiBlZGdlLFxuICAgICAqICAgYnV0IHRoaXMgaXMgZXhwZWN0ZWQgdG8gY2hhbmdlIHNvbWV3aGVyZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIC0gU2luY2UgdGhlcmUgaXMgbm8gei1pbmRleGluZyB5ZXQsIGl0IGlzIG5vdCByZWFsbHkgcG9zc2libGUgdG8gc2V0IHRoZSBub2RlcyBhbmRcbiAgICAgKiAgIGVkZ2VzIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBGb3IgdGhlIHRpbWUgYmVpbmcsIG5vZGVzIGNvbWUgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludGVyICBtb3VzZSBwb3NpdGlvbiBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtfGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpY2tlZEl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWNrZWRJdGVtcyhwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHZhciBpdGVtcyA9IFtdOyAvLyBOb3RlIHJldmVyc2Ugb3JkZXI7IHdlIHdhbnQgdGhlIHRvcG1vc3QgY2xpY2tlZCBpdGVtcyB0byBiZSBmaXJzdCBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHNlbGVjdGVkIG5vZGVzIGFyZSBkaXNyZWdhcmRlZCBoZXJlOyB0aGVzZSBub3JtYWxseSBkaXNwbGF5IG9uIHRvcFxuXG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUuZ2V0SXRlbXNPblBvaW50KHBvaW50KTtcbiAgICAgICAgaXRlbXMucHVzaC5hcHBseShpdGVtcywgcmV0KTsgLy8gQXBwZW5kIHRoZSByZXR1cm4gdmFsdWUgdG8gdGhlIHJ1bm5pbmcgbGlzdC5cbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IGVkZ2VJbmRpY2VzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaV1dO1xuXG4gICAgICAgIHZhciBfcmV0ID0gZWRnZS5nZXRJdGVtc09uUG9pbnQocG9pbnQpO1xuXG4gICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIF9yZXQpOyAvLyBBcHBlbmQgdGhlIHJldHVybiB2YWx1ZSB0byB0aGUgcnVubmluZyBsaXN0LlxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlbGVjdGlvbkhhbmRsZXI7XG59KCk7XG5cbnZhciB0aW1zb3J0JDEgPSB7fTtcblxuLyoqKipcbiAqIFRoZSBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBNYXJjbyBaaWNjYXJkaVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICoqKiovXG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuICAoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHtcbiAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgfVxuICB9KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gICAgZXhwb3J0cy5zb3J0ID0gc29ydDtcblxuICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xuICAgIHZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xuICAgIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcbiAgICB2YXIgUE9XRVJTX09GX1RFTiA9IFsxZTAsIDFlMSwgMWUyLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTldO1xuXG4gICAgZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgICAgaWYgKHggPCAxZTUpIHtcbiAgICAgICAgaWYgKHggPCAxZTIpIHtcbiAgICAgICAgICByZXR1cm4geCA8IDFlMSA/IDAgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPCAxZTQpIHtcbiAgICAgICAgICByZXR1cm4geCA8IDFlMyA/IDIgOiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMWU3KSB7XG4gICAgICAgIHJldHVybiB4IDwgMWU2ID8gNSA6IDY7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMWU5KSB7XG4gICAgICAgIHJldHVybiB4IDwgMWU4ID8gNyA6IDg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiA5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFscGhhYmV0aWNhbENvbXBhcmUoYSwgYikge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh+fmEgPT09IGEgJiYgfn5iID09PSBiKSB7XG4gICAgICAgIGlmIChhID09PSAwIHx8IGIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA8IDAgfHwgYiA8IDApIHtcbiAgICAgICAgICBpZiAoYiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGEgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgIGIgPSAtYjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbCA9IGxvZzEwKGEpO1xuICAgICAgICB2YXIgYmwgPSBsb2cxMChiKTtcbiAgICAgICAgdmFyIHQgPSAwO1xuXG4gICAgICAgIGlmIChhbCA8IGJsKSB7XG4gICAgICAgICAgYSAqPSBQT1dFUlNfT0ZfVEVOW2JsIC0gYWwgLSAxXTtcbiAgICAgICAgICBiIC89IDEwO1xuICAgICAgICAgIHQgPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhbCA+IGJsKSB7XG4gICAgICAgICAgYiAqPSBQT1dFUlNfT0ZfVEVOW2FsIC0gYmwgLSAxXTtcbiAgICAgICAgICBhIC89IDEwO1xuICAgICAgICAgIHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFTdHIgPSBTdHJpbmcoYSk7XG4gICAgICB2YXIgYlN0ciA9IFN0cmluZyhiKTtcblxuICAgICAgaWYgKGFTdHIgPT09IGJTdHIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhU3RyIDwgYlN0ciA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICAgICAgdmFyIHIgPSAwO1xuXG4gICAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICByIHw9IG4gJiAxO1xuICAgICAgICBuID4+PSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbiArIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgICAgIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bkhpIC0gbG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gICAgICBoaS0tO1xuXG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICAgICAgYXJyYXlbbG8rK10gPSBhcnJheVtoaV07XG4gICAgICAgIGFycmF5W2hpLS1dID0gdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcbiAgICAgICAgdmFyIGxlZnQgPSBsbztcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhcnQ7XG5cbiAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgIHZhciBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgIH1cblxuICAgICAgbGFzdE9mZnNldCsrO1xuXG4gICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgIH1cblxuICAgICAgbGFzdE9mZnNldCsrO1xuXG4gICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIFRpbVNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1Tb3J0KTtcblxuICAgICAgICB0aGlzLmFycmF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5taW5HYWxsb3AgPSBERUZBVUxUX01JTl9HQUxMT1BJTkc7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy50bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMuc3RhY2tMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJ1blN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ydW5MZW5ndGggPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgMiAqIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIKSB7XG4gICAgICAgICAgdGhpcy50bXBTdG9yYWdlTGVuZ3RoID0gdGhpcy5sZW5ndGggPj4+IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRtcCA9IG5ldyBBcnJheSh0aGlzLnRtcFN0b3JhZ2VMZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YWNrTGVuZ3RoID0gdGhpcy5sZW5ndGggPCAxMjAgPyA1IDogdGhpcy5sZW5ndGggPCAxNTQyID8gMTAgOiB0aGlzLmxlbmd0aCA8IDExOTE1MSA/IDE5IDogNDA7XG4gICAgICAgIHRoaXMucnVuU3RhcnQgPSBuZXcgQXJyYXkodGhpcy5zdGFja0xlbmd0aCk7XG4gICAgICAgIHRoaXMucnVuTGVuZ3RoID0gbmV3IEFycmF5KHRoaXMuc3RhY2tMZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBUaW1Tb3J0LnByb3RvdHlwZS5wdXNoUnVuID0gZnVuY3Rpb24gcHVzaFJ1bihydW5TdGFydCwgcnVuTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucnVuU3RhcnRbdGhpcy5zdGFja1NpemVdID0gcnVuU3RhcnQ7XG4gICAgICAgIHRoaXMucnVuTGVuZ3RoW3RoaXMuc3RhY2tTaXplXSA9IHJ1bkxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgKz0gMTtcbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlUnVucyA9IGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5zdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgaWYgKG4gPj0gMSAmJiB0aGlzLnJ1bkxlbmd0aFtuIC0gMV0gPD0gdGhpcy5ydW5MZW5ndGhbbl0gKyB0aGlzLnJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHRoaXMucnVuTGVuZ3RoW24gLSAyXSA8PSB0aGlzLnJ1bkxlbmd0aFtuXSArIHRoaXMucnVuTGVuZ3RoW24gLSAxXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJ1bkxlbmd0aFtuXSA+IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tZXJnZUF0KG4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBUaW1Tb3J0LnByb3RvdHlwZS5mb3JjZU1lcmdlUnVucyA9IGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICBpZiAobiA+IDAgJiYgdGhpcy5ydW5MZW5ndGhbbiAtIDFdIDwgdGhpcy5ydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICBuLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tZXJnZUF0KG4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBUaW1Tb3J0LnByb3RvdHlwZS5tZXJnZUF0ID0gZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgc3RhcnQxID0gdGhpcy5ydW5TdGFydFtpXTtcbiAgICAgICAgdmFyIGxlbmd0aDEgPSB0aGlzLnJ1bkxlbmd0aFtpXTtcbiAgICAgICAgdmFyIHN0YXJ0MiA9IHRoaXMucnVuU3RhcnRbaSArIDFdO1xuICAgICAgICB2YXIgbGVuZ3RoMiA9IHRoaXMucnVuTGVuZ3RoW2kgKyAxXTtcbiAgICAgICAgdGhpcy5ydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgICAgICBpZiAoaSA9PT0gdGhpcy5zdGFja1NpemUgLSAzKSB7XG4gICAgICAgICAgdGhpcy5ydW5TdGFydFtpICsgMV0gPSB0aGlzLnJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICB0aGlzLnJ1bkxlbmd0aFtpICsgMV0gPSB0aGlzLnJ1bkxlbmd0aFtpICsgMl07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWNrU2l6ZS0tO1xuICAgICAgICB2YXIgayA9IGdhbGxvcFJpZ2h0KGFycmF5W3N0YXJ0Ml0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuICAgICAgICBzdGFydDEgKz0gaztcbiAgICAgICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICAgICAgdGhpcy5tZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBUaW1Tb3J0LnByb3RvdHlwZS5tZXJnZUxvdyA9IGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgdG1wID0gdGhpcy50bXA7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5HYWxsb3AgPSB0aGlzLm1pbkdhbGxvcDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IG1pbkdhbGxvcCk7XG5cbiAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG5cbiAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY291bnQyID0gZ2FsbG9wTGVmdCh0bXBbY3Vyc29yMV0sIGFycmF5LCBjdXJzb3IyLCBsZW5ndGgyLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgY3Vyc29yMiArPSBjb3VudDI7XG4gICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluR2FsbG9wLS07XG4gICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgbWluR2FsbG9wID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtaW5HYWxsb3AgKz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgICAgdGhpcy5taW5HYWxsb3AgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlSGlnaCA9IGZ1bmN0aW9uIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuY29tcGFyZTtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMudG1wO1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICAgICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICAgICAgdmFyIGRlc3QgPSBzdGFydDIgKyBsZW5ndGgyIC0gMTtcbiAgICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgICAgIHZhciBjdXN0b21EZXN0ID0gMDtcbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IHRoaXMubWluR2FsbG9wO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgbWluR2FsbG9wKTtcblxuICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSBjb3VudDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDI7XG4gICAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AtLTtcbiAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtaW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICBtaW5HYWxsb3AgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1pbkdhbGxvcCArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFRpbVNvcnQ7XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhbiBvbmx5IHNvcnQgYXJyYXlzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gYWxwaGFiZXRpY2FsQ29tcGFyZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbXBhcmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGkgPSBsbztcbiAgICAgICAgbG8gPSBjb21wYXJlO1xuICAgICAgICBjb21wYXJlID0gYWxwaGFiZXRpY2FsQ29tcGFyZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsbykge1xuICAgICAgICBsbyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGkpIHtcbiAgICAgICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gICAgICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgICBpZiAocmVtYWluaW5nIDwgREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuICAgICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcblxuICAgICAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgICAgIHRzLm1lcmdlUnVucygpO1xuICAgICAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgICAgICBsbyArPSBydW5MZW5ndGg7XG4gICAgICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gICAgICB0cy5mb3JjZU1lcmdlUnVucygpO1xuICAgIH1cbiAgfSk7XG59KSh0aW1zb3J0JDEpO1xuXG52YXIgdGltc29ydCA9IHRpbXNvcnQkMTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBJbnRlcmZhY2UgZGVmaW5pdGlvbiBmb3IgZGlyZWN0aW9uIHN0cmF0ZWd5IGNsYXNzZXMuXG4gKlxuICogVGhpcyBjbGFzcyBkZXNjcmliZXMgdGhlIGludGVyZmFjZSBmb3IgdGhlIFN0cmF0ZWd5XG4gKiBwYXR0ZXJuIGNsYXNzZXMgdXNlZCB0byBkaWZmZXJlbnRpYXRlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsXG4gKiBkaXJlY3Rpb24gb2YgaGllcmFyY2hpY2FsIHJlc3VsdHMuXG4gKlxuICogRm9yIGEgZ2l2ZW4gZGlyZWN0aW9uLCBvbmUgY29vcmRpbmF0ZSB3aWxsIGJlICdmaXhlZCcsIG1lYW5pbmcgdGhhdCBpdCBpc1xuICogZGV0ZXJtaW5lZCBieSBsZXZlbC5cbiAqIFRoZSBvdGhlciBjb29yZGluYXRlIGlzICd1bmZpeGVkJywgbWVhbmluZyB0aGF0IHRoZSBub2RlcyBvbiBhIGdpdmVuIGxldmVsXG4gKiBjYW4gc3RpbGwgbW92ZSBhbG9uZyB0aGF0IGNvb3JkaW5hdGUuIFNvOlxuICpcbiAqIC0gYHZlcnRpY2FsYCBsYXlvdXQ6IGB4YCB1bmZpeGVkLCBgeWAgZml4ZWQgcGVyIGxldmVsXG4gKiAtIGBob3Jpem9udGFsYCBsYXlvdXQ6IGB4YCBmaXhlZCBwZXIgbGV2ZWwsIGB5YCB1bmZpeGVkXG4gKlxuICogVGhlIGxvY2FsIG1ldGhvZHMgYXJlIHN0dWJzIGFuZCBzaG91bGQgYmUgcmVnYXJkZWQgYXMgYWJzdHJhY3QuXG4gKiBEZXJpdmVkIGNsYXNzZXMgKiptdXN0KiogaW1wbGVtZW50IGFsbCB0aGUgbWV0aG9kcyB0aGVtc2VsdmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIERpcmVjdGlvbkludGVyZmFjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpcmVjdGlvbkludGVyZmFjZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlyZWN0aW9uSW50ZXJmYWNlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEaXJlY3Rpb25JbnRlcmZhY2UsIFt7XG4gICAga2V5OiBcImFic3RyYWN0XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgZHVtbXkgY2FsbCB3aGljaCBpcyB1c2VkIHRvIHN1cHByZXNzIHRoZSBqc2RvYyBlcnJvcnMgb2YgdHlwZTpcbiAgICAgKlxuICAgICAqICAgXCIncGFyYW0nIGlzIGFzc2lnbmVkIGEgdmFsdWUgYnV0IG5ldmVyIHVzZWRcIlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFrZV91c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZV91c2UoKSB7Ly8gRG8gbm90aGluZyBzcGVjaWFsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgdG8gdXNlIHRvIHRyYW5zbGF0ZSBkeW5hbWljIGN1cnZlcyB0bywgaW4gdGhlIGNhc2Ugb2YgaGllcmFyY2hpY2FsIGxheW91dC5cbiAgICAgKiBEeW5hbWljIGN1cnZlcyBkbyBub3Qgd29yayBmb3IgdGhlc2UuXG4gICAgICpcbiAgICAgKiBUaGUgdmFsdWUgc2hvdWxkIGJlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGFjdHVhbCBkaXJlY3Rpb24gb2YgdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IERpcmVjdGlvbiwgZWl0aGVyICd2ZXJ0aWNhbCcgb3IgJ2hvcml6b250YWwnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVhZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIG9mIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRoYXQgaXMgbm90IGZpeGVkIGZvciB0aGlzIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xldmVsXSBpZiBzcGVjaWZpZWQsIHRoZSBoaWVyYXJjaHkgbGV2ZWwgdGhhdCB0aGlzIG5vZGUgc2hvdWxkIGJlIGZpeGVkIHRvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGUsIHBvc2l0aW9uLCBsZXZlbCk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2lkdGggb2YgYSB0cmVlLlxuICAgICAqXG4gICAgICogQSBgdHJlZWAgaGVyZSBpcyBhIHN1YnNldCBvZiBub2RlcyB3aXRoaW4gdGhlIG5ldHdvcmsgd2hpY2ggYXJlIG5vdCBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMsXG4gICAgICogb25seSBhbW9uZyB0aGVtc2VsdmVzLiBJbiBlc3NlbmNlLCBpdCBpcyBhIHN1Yi1uZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBudW1iZXIgb2YgYSB0cmVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIHdpZHRoIG9mIGEgdHJlZSBpbiB0aGUgdmlldyBjb29yZGluYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUoaW5kZXgpIHtcbiAgICAgIHRoaXMuZmFrZV91c2UoaW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydCBhcnJheSBvZiBub2RlcyBvbiB0aGUgdW5maXhlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6KiogY2hyb21lIGhhcyBub24tc3RhYmxlIHNvcnRpbmcgaW1wbGVtZW50YXRpb24sIHdoaWNoXG4gICAgICogaGFzIGEgdGVuZGVuY3kgdG8gY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkgaXRlbXMsXG4gICAgICogZXZlbiBpZiB0aGUgY3VzdG9tIHNvcnQgZnVuY3Rpb24gcmV0dXJucyAwLlxuICAgICAqXG4gICAgICogRm9yIHRoaXMgcmVhc29uLCBhbiBleHRlcm5hbCBzb3J0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQsXG4gICAgICogd2hpY2ggaGFzIHRoZSBhZGRlZCBiZW5lZml0IG9mIGJlaW5nIGZhc3RlciB0aGFuIHRoZSBzdGFuZGFyZFxuICAgICAqIHBsYXRmb3JtcyBpbXBsZW1lbnRhdGlvbi4gVGhpcyBoYXMgYmVlbiB2ZXJpZmllZCBvbiBgbm9kZS5qc2AsXG4gICAgICogYGZpcmVmb3hgIGFuZCBgY2hyb21lYCAoYWxsIGxpbnV4KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2RlQXJyYXkgYXJyYXkgb2Ygbm9kZXMgdG8gc29ydFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlQXJyYXkpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gdGhlIGZpeGVkIGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgdG8gdGhlIGdpdmVuIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIFRoZSBsZXZlbCB0byBmaXggdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXgobm9kZSwgbGV2ZWwpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgbGV2ZWwpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2Zmc2V0IHRvIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGUgb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGVJZH0gbm9kZUlkIElkIG9mIHRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmIE9mZnNldCB0byBhZGQgdG8gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGVJZCwgZGlmZik7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpcmVjdGlvbkludGVyZmFjZTtcbn0oKTtcbi8qKlxuICogVmVydGljYWwgU3RyYXRlZ3lcbiAqXG4gKiBDb29yZGluYXRlIGB5YCBpcyBmaXhlZCBvbiBsZXZlbHMsIGNvb3JkaW5hdGUgYHhgIGlzIHVuZml4ZWQuXG4gKlxuICogQGF1Z21lbnRzIERpcmVjdGlvbkludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBWZXJ0aWNhbFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlyZWN0aW9uSW50ZXJmYWNlKSB7XG4gIF9pbmhlcml0cyhWZXJ0aWNhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFZlcnRpY2FsU3RyYXRlZ3kpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IExheW91dEVuZ2luZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIFZlcnRpY2FsU3RyYXRlZ3kobGF5b3V0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlcnRpY2FsU3RyYXRlZ3kpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFZlcnRpY2FsU3RyYXRlZ3ksIFt7XG4gICAga2V5OiBcImN1cnZlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUueDtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5hZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS54ID0gcG9zaXRpb247XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUoaW5kZXgpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuZ2V0VHJlZVNpemUodGhpcy5sYXlvdXQuYm9keS5ub2RlcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXMubWluX3gsXG4gICAgICAgIG1heDogcmVzLm1heF94XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChub2RlQXJyYXkpIHtcbiAgICAgIHRpbXNvcnQuc29ydChub2RlQXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICBub2RlLnkgPSB0aGlzLmxheW91dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgIG5vZGUub3B0aW9ucy5maXhlZC55ID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMubGF5b3V0LmJvZHkubm9kZXNbbm9kZUlkXS54ICs9IGRpZmY7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZlcnRpY2FsU3RyYXRlZ3k7XG59KERpcmVjdGlvbkludGVyZmFjZSk7XG4vKipcbiAqIEhvcml6b250YWwgU3RyYXRlZ3lcbiAqXG4gKiBDb29yZGluYXRlIGB4YCBpcyBmaXhlZCBvbiBsZXZlbHMsIGNvb3JkaW5hdGUgYHlgIGlzIHVuZml4ZWQuXG4gKlxuICogQGF1Z21lbnRzIERpcmVjdGlvbkludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBIb3Jpem9udGFsU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXJlY3Rpb25JbnRlcmZhY2UyKSB7XG4gIF9pbmhlcml0cyhIb3Jpem9udGFsU3RyYXRlZ3ksIF9EaXJlY3Rpb25JbnRlcmZhY2UyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihIb3Jpem9udGFsU3RyYXRlZ3kpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IExheW91dEVuZ2luZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIEhvcml6b250YWxTdHJhdGVneShsYXlvdXQpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhvcml6b250YWxTdHJhdGVneSk7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyLmxheW91dCA9IGxheW91dDtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvcml6b250YWxTdHJhdGVneSwgW3tcbiAgICBrZXk6IFwiY3VydmVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUueTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5hZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS55ID0gcG9zaXRpb247XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUoaW5kZXgpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuZ2V0VHJlZVNpemUodGhpcy5sYXlvdXQuYm9keS5ub2RlcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXMubWluX3ksXG4gICAgICAgIG1heDogcmVzLm1heF95XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChub2RlQXJyYXkpIHtcbiAgICAgIHRpbXNvcnQuc29ydChub2RlQXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnkgLSBiLnk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICBub2RlLnggPSB0aGlzLmxheW91dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgIG5vZGUub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMubGF5b3V0LmJvZHkubm9kZXNbbm9kZUlkXS55ICs9IGRpZmY7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhvcml6b250YWxTdHJhdGVneTtcbn0oRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyICRldmVyeSA9IGFycmF5SXRlcmF0aW9uLmV2ZXJ5O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2V2ZXJ5Jyk7IC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcblxuJCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIVNUUklDVF9NRVRIT0Rcbn0sIHtcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGV2ZXJ5JDMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZXZlcnk7XG5cbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QgPSBldmVyeSQzO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZXZlcnkkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZXZlcnk7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgaXNQcm90b3R5cGVPZihBcnJheVByb3RvdHlwZSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuZXZlcnkgPyBtZXRob2QgOiBvd247XG59O1xuXG52YXIgcGFyZW50ID0gZXZlcnkkMjtcbnZhciBldmVyeSQxID0gcGFyZW50O1xuXG52YXIgZXZlcnkgPSBldmVyeSQxO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IHZhciBfY29udGV4dDk7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQ5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0OSwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQxKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKipcclxuICogVHJ5IHRvIGFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgY3ljbGljIOKAnGhpZXJhcmNoeeKAnS5cclxuICpcclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEBwYXJhbSBsZXZlbHMgLSBJZiBwcmVzZW50IGxldmVscyB3aWxsIGJlIGFkZGVkIHRvIGl0LCBpZiBub3QgYSBuZXcgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvbkN5Y2xpYyhub2RlcywgbGV2ZWxzKSB7XG4gIHZhciBlZGdlcyA9IG5ldyBzZXQoKTtcblxuICBmb3JFYWNoJDIobm9kZXMpLmNhbGwobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0O1xuXG4gICAgZm9yRWFjaCQyKF9jb250ZXh0ID0gbm9kZS5lZGdlcykuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICBlZGdlcy5hZGQoZWRnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZvckVhY2gkMihlZGdlcykuY2FsbChlZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgZnJvbUlkID0gZWRnZS5mcm9tLmlkO1xuICAgIHZhciB0b0lkID0gZWRnZS50by5pZDtcblxuICAgIGlmIChsZXZlbHNbZnJvbUlkXSA9PSBudWxsKSB7XG4gICAgICBsZXZlbHNbZnJvbUlkXSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsc1t0b0lkXSA9PSBudWxsIHx8IGxldmVsc1tmcm9tSWRdID49IGxldmVsc1t0b0lkXSkge1xuICAgICAgbGV2ZWxzW3RvSWRdID0gbGV2ZWxzW2Zyb21JZF0gKyAxO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxldmVscztcbn1cbi8qKlxyXG4gKiBBc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGhpZXJhcmNoeS4gTGVhdmVzIHdpbGwgYmUgbGluZWQgdXAgYXQgdGhlIGJvdHRvbSBhbmQgYWxsIG90aGVyIG5vZGVzIGFzIGNsb3NlIHRvIHRoZWlyIGNoaWxkcmVuIGFzIHBvc3NpYmxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25MZWF2ZXMobm9kZXMpIHtcbiAgcmV0dXJuIGZpbGxMZXZlbHNCeURpcmVjdGlvbiggLy8gUGljayBvbmx5IGxlYXZlcyAobm9kZXMgd2l0aG91dCBjaGlsZHJlbikuXG4gIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0MiwgX2NvbnRleHQzO1xuXG4gICAgcmV0dXJuIGV2ZXJ5KF9jb250ZXh0MiA9IGZpbHRlcihfY29udGV4dDMgPSBub2RlLmVkZ2VzIC8vIFRha2Ugb25seSB2aXNpYmxlIG5vZGVzIGludG8gYWNjb3VudC5cbiAgICApLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIG5vZGVzLmhhcyhlZGdlLnRvSWQpO1xuICAgIH0pIC8vIENoZWNrIHRoYXQgYWxsIGVkZ2VzIGxlYWQgdG8gdGhpcyBub2RlIChsZWFmKS5cbiAgICApLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UudG8gPT09IG5vZGU7XG4gICAgfSk7XG4gIH0sIC8vIFVzZSB0aGUgbG93ZXN0IGxldmVsLlxuICBmdW5jdGlvbiAobmV3TGV2ZWwsIG9sZExldmVsKSB7XG4gICAgcmV0dXJuIG9sZExldmVsID4gbmV3TGV2ZWw7XG4gIH0sIC8vIEdvIGFnYWluc3QgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMuXG4gIFwiZnJvbVwiLCBub2Rlcyk7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuIFJvb3RzIHdpbGwgYmUgbGluZWQgdXAgYXQgdGhlIHRvcCBhbmQgYWxsIG5vZGVzIGFzIGNsb3NlIHRvIHRoZWlyIHBhcmVudHMgYXMgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcmV0dXJucyBQb3B1bGF0ZWQgbm9kZSBsZXZlbHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25Sb290cyhub2Rlcykge1xuICByZXR1cm4gZmlsbExldmVsc0J5RGlyZWN0aW9uKCAvLyBQaWNrIG9ubHkgcm9vdHMgKG5vZGVzIHdpdGhvdXQgcGFyZW50cykuXG4gIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0NCwgX2NvbnRleHQ1O1xuXG4gICAgcmV0dXJuIGV2ZXJ5KF9jb250ZXh0NCA9IGZpbHRlcihfY29udGV4dDUgPSBub2RlLmVkZ2VzIC8vIFRha2Ugb25seSB2aXNpYmxlIG5vZGVzIGludG8gYWNjb3VudC5cbiAgICApLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIG5vZGVzLmhhcyhlZGdlLnRvSWQpO1xuICAgIH0pIC8vIENoZWNrIHRoYXQgYWxsIGVkZ2VzIGxlYWQgZnJvbSB0aGlzIG5vZGUgKHJvb3QpLlxuICAgICkuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5mcm9tID09PSBub2RlO1xuICAgIH0pO1xuICB9LCAvLyBVc2UgdGhlIGhpZ2hlc3QgbGV2ZWwuXG4gIGZ1bmN0aW9uIChuZXdMZXZlbCwgb2xkTGV2ZWwpIHtcbiAgICByZXR1cm4gb2xkTGV2ZWwgPCBuZXdMZXZlbDtcbiAgfSwgLy8gR28gaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMuXG4gIFwidG9cIiwgbm9kZXMpO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgaGllcmFyY2h5LlxyXG4gKlxyXG4gKiBAcGFyYW0gaXNFbnRyeU5vZGUgLSBDaGVja3MgYW5kIHJldHVybiB0cnVlIGlmIHRoZSBncmFwaCBzaG91bGQgYmUgdHJhdmVyc2VkIGZyb20gdGhpcyBub2RlLlxyXG4gKiBAcGFyYW0gc2hvdWxkTGV2ZWxCZVJlcGxhY2VkIC0gQ2hlY2tzIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGxldmVsIG9mIGdpdmVuIG5vZGUgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdGhlIG5ldyB2YWx1ZS5cclxuICogQHBhcmFtIGRpcmVjdGlvbiAtIFdoZXRlciB0aGUgZ3JhcGggc2hvdWxkIGJlIHRyYXZlcnNlZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcyBgXCJ0b1wiYCBvciBpbiB0aGUgb3RoZXIgd2F5IGBcImZyb21cImAuXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcmV0dXJucyBQb3B1bGF0ZWQgbm9kZSBsZXZlbHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb24oaXNFbnRyeU5vZGUsIHNob3VsZExldmVsQmVSZXBsYWNlZCwgZGlyZWN0aW9uLCBub2Rlcykge1xuICB2YXIgX2NvbnRleHQ2O1xuXG4gIHZhciBsZXZlbHMgPSBjcmVhdGUkNShudWxsKTsgLy8gSWYgYWN5Y2xpYywgdGhlIGdyYXBoIGNhbiBiZSB3YWxrZWQgdGhyb3VnaCB3aXRoIChtb3N0IGxpa2VseSB3YXkpIGZld2VyXG4gIC8vIHN0ZXBzIHRoYW4gdGhlIG51bWJlciBiZWxsb3cuIFRoZSBleGFjdCB2YWx1ZSBpc24ndCB0b28gaW1wb3J0YW50IGFzIGxvbmdcbiAgLy8gYXMgaXQncyBxdWljayB0byBjb21wdXRlIChkb2Vzbid0IGltcGFjdCBhY3ljbGljIGdyYXBocyB0b28gbXVjaCksIGlzXG4gIC8vIGhpZ2hlciB0aGFuIHRoZSBudW1iZXIgb2Ygc3RlcHMgYWN0dWFsbHkgbmVlZGVkIChkb2Vzbid0IGN1dCBvZmYgYmVmb3JlXG4gIC8vIGFjeWNsaWMgZ3JhcGggaXMgd2Fsa2VkIHRocm91Z2gpIGFuZCBwcmV2ZW50cyBpbmZpbml0ZSBsb29wcyAoY3V0cyBvZmYgZm9yXG4gIC8vIGN5Y2xpYyBncmFwaHMpLlxuXG5cbiAgdmFyIGxpbWl0ID0gcmVkdWNlKF9jb250ZXh0NiA9IF90b0NvbnN1bWFibGVBcnJheSh2YWx1ZXMobm9kZXMpLmNhbGwobm9kZXMpKSkuY2FsbChfY29udGV4dDYsIGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICByZXR1cm4gYWNjICsgMSArIG5vZGUuZWRnZXMubGVuZ3RoO1xuICB9LCAwKTtcblxuICB2YXIgZWRnZUlkUHJvcCA9IGRpcmVjdGlvbiArIFwiSWRcIjtcbiAgdmFyIG5ld0xldmVsRGlmZiA9IGRpcmVjdGlvbiA9PT0gXCJ0b1wiID8gMSA6IC0xO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG5vZGVzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgZW50cnlOb2RlSWQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICBlbnRyeU5vZGUgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgaWYgKCAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCB2aXNpYmxlLlxuICAgICAgIW5vZGVzLmhhcyhlbnRyeU5vZGVJZCkgfHwgLy8gU2tpcCBpZiB0aGUgbm9kZSBpcyBub3QgYW4gZW50cnkgbm9kZS5cbiAgICAgICFpc0VudHJ5Tm9kZShlbnRyeU5vZGUpKSB7XG4gICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICB9IC8vIExpbmUgdXAgYWxsIHRoZSBlbnRyeSBub2RlcyBvbiBsZXZlbCAwLlxuXG5cbiAgICAgIGxldmVsc1tlbnRyeU5vZGVJZF0gPSAwO1xuICAgICAgdmFyIHN0YWNrID0gW2VudHJ5Tm9kZV07XG4gICAgICB2YXIgZG9uZSA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NywgX2NvbnRleHQ4O1xuXG4gICAgICAgIGlmICghbm9kZXMuaGFzKGVudHJ5Tm9kZUlkKSkge1xuICAgICAgICAgIC8vIFNraXAgaWYgdGhlIG5vZGUgaXMgbm90IHZpc2libGUuXG4gICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdMZXZlbCA9IGxldmVsc1tub2RlLmlkXSArIG5ld0xldmVsRGlmZjtcblxuICAgICAgICBmb3JFYWNoJDIoX2NvbnRleHQ3ID0gZmlsdGVyKF9jb250ZXh0OCA9IG5vZGUuZWRnZXMpLmNhbGwoX2NvbnRleHQ4LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiAoLy8gSWdub3JlIGRpc2Nvbm5lY3RlZCBlZGdlcy5cbiAgICAgICAgICAgIGVkZ2UuY29ubmVjdGVkICYmIC8vIElnbm9yZSBjaXJjdWxhciBlZGdlcy5cbiAgICAgICAgICAgIGVkZ2UudG8gIT09IGVkZ2UuZnJvbSAmJiAvLyBJZ25vcmUgZWRnZXMgbGVhZGluZyB0byB0aGUgbm9kZSB0aGF0J3MgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIGVkZ2VbZGlyZWN0aW9uXSAhPT0gbm9kZSAmJiAvLyBJZ25vcmUgZWRnZXMgY29ubmVjdGluZyB0byBhbiBpbnZpc2libGUgbm9kZS5cbiAgICAgICAgICAgIG5vZGVzLmhhcyhlZGdlLnRvSWQpICYmIC8vIElnbm9yZSBlZGdlcyBjb25uZWN0aW5nIGZyb20gYW4gaW52aXNpYmxlIG5vZGUuXG4gICAgICAgICAgICBub2Rlcy5oYXMoZWRnZS5mcm9tSWQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSkpLmNhbGwoX2NvbnRleHQ3LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlW2VkZ2VJZFByb3BdO1xuICAgICAgICAgIHZhciBvbGRMZXZlbCA9IGxldmVsc1t0YXJnZXROb2RlSWRdO1xuXG4gICAgICAgICAgaWYgKG9sZExldmVsID09IG51bGwgfHwgc2hvdWxkTGV2ZWxCZVJlcGxhY2VkKG5ld0xldmVsLCBvbGRMZXZlbCkpIHtcbiAgICAgICAgICAgIGxldmVsc1t0YXJnZXROb2RlSWRdID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGVkZ2VbZGlyZWN0aW9uXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG9uZSA+IGxpbWl0KSB7XG4gICAgICAgICAgLy8gVGhpcyB3b3VsZCBydW4gZm9yZXZlciBvbiBhIGN5Y2xpYyBncmFwaC5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICB2OiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25DeWNsaWMobm9kZXMsIGxldmVscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrZG9uZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKG5vZGUgPSBzdGFjay5wb3AoKSkge1xuICAgICAgICB2YXIgX3JldDIgPSBfbG9vcDIoKTtcblxuICAgICAgICBpZiAoX3JldDIgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgIGlmIChfdHlwZW9mKF9yZXQyKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKF90eXBlb2YoX3JldCkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gbGV2ZWxzO1xufVxuXG4vKipcbiAqIFRoZXJlJ3MgYSBtaXgtdXAgd2l0aCB0ZXJtcyBpbiB0aGUgY29kZS4gRm9sbG93aW5nIGFyZSB0aGUgZm9ybWFsIGRlZmluaXRpb25zOlxuICpcbiAqICAgdHJlZSAgIC0gYSBzdHJpY3QgaGllcmFyY2hpY2FsIG5ldHdvcmssIGkuZS4gZXZlcnkgbm9kZSBoYXMgYXQgbW9zdCBvbmUgcGFyZW50XG4gKiAgIGZvcmVzdCAtIGEgY29sbGVjdGlvbiBvZiB0cmVlcy4gVGhlc2UgZGlzdGluY3QgdHJlZXMgYXJlIHRodXMgbm90IGNvbm5lY3RlZC5cbiAqXG4gKiBTbzpcbiAqIC0gaW4gYSBuZXR3b3JrIHRoYXQgaXMgbm90IGEgdHJlZSwgdGhlcmUgZXhpc3Qgbm9kZXMgd2l0aCBtdWx0aXBsZSBwYXJlbnRzLlxuICogLSBhIG5ldHdvcmsgY29uc2lzdGluZyBvZiB1bmNvbm5lY3RlZCBzdWItbmV0d29ya3MsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZVxuICogICBpcyBub3QgYSB0cmVlLCBpcyBub3QgYSBmb3Jlc3QuXG4gKlxuICogSW4gdGhlIGNvZGUsIHRoZSBkZWZpbml0aW9ucyBhcmU6XG4gKlxuICogICB0cmVlICAgLSBhbnkgZGlzY29ubmVjdGVkIHN1Yi1uZXR3b3JrLCBzdHJpY3QgaGllcmFyY2hpY2FsIG9yIG5vdC5cbiAqICAgZm9yZXN0IC0gYSBidW5jaCBvZiB0aGVzZSBzdWItbmV0d29ya3NcbiAqXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRyZWUgYW5kIG5vdC10cmVlIGlzIGltcG9ydGFudCBpbiB0aGUgY29kZSwgbm90YWJseSB3aXRoaW5cbiAqIHRvIHRoZSBibG9jay1zaGlmdGluZyBhbGdvcml0aG0uIFRoZSBhbGdvcml0aG0gYXNzdW1lcyBmb3JtYWwgdHJlZXMgYW5kIGZhaWxzXG4gKiBmb3Igbm90LXRyZWVzLCBvZnRlbiBpbiBhIHNwZWN0YWN1bGFyIG1hbm5lciAoc2VhcmNoIGZvciAnZXhwbG9kaW5nIG5ldHdvcmsnIGluIHRoZSBpc3N1ZXMpLlxuICpcbiAqIEluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIHRoZSBkZWZpbml0aW9ucyBpbiB0aGUgZm9sbG93aW5nIGNvZGUsIHRoZSBhZGplY3RpdmUgJ2Zvcm1hbCcgaXNcbiAqIHVzZWQuIElmICdmb3JtYWwnIGlzIGFic2VudCwgeW91IG11c3QgYXNzdW1lIHRoZSBub24tZm9ybWFsIGRlZmluaXRpb24uXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogTk9URVNcbiAqID09PT09XG4gKlxuICogQSBoaWVyYXJjaGljYWwgbGF5b3V0IGlzIGEgZGlmZmVyZW50IHRoaW5nIGZyb20gYSBoaWVyYXJjaGljYWwgbmV0d29yay5cbiAqIFRoZSBsYXlvdXQgaXMgYSB3YXkgdG8gYXJyYW5nZSB0aGUgbm9kZXMgaW4gdGhlIHZpZXc7IHRoaXMgY2FuIGJlIGRvbmVcbiAqIG9uIG5vbi1oaWVyYXJjaGljYWwgbmV0d29ya3MgYXMgd2VsbC4gVGhlIGNvbnZlcnNlIGlzIGFsc28gcG9zc2libGUuXG4gKi9cbi8qKlxuICogQ29udGFpbmVyIGZvciBkZXJpdmVkIGRhdGEgb24gY3VycmVudCBuZXR3b3JrLCByZWxhdGluZyB0byBoaWVyYXJjaHkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgSGllcmFyY2hpY2FsU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFN0YXR1cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsU3RhdHVzKTtcblxuICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2UgPSB7fTsgLy8gY2hpbGQgaWQncyBwZXIgbm9kZSBpZFxuXG4gICAgdGhpcy5wYXJlbnRSZWZlcmVuY2UgPSB7fTsgLy8gcGFyZW50IGlkJ3MgcGVyIG5vZGUgaWRcblxuICAgIHRoaXMudHJlZXMgPSB7fTsgLy8gdHJlZSBpZCBwZXIgbm9kZSBpZDsgaS5lLiB0byB3aGljaCB0cmVlIGRvZXMgZ2l2ZW4gbm9kZSBpZCBiZWxvbmdcblxuICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcgPSB7fTsgLy8gVGhlIG5vZGVzIHBlciBsZXZlbCwgaW4gdGhlIGRpc3BsYXkgb3JkZXJcblxuICAgIHRoaXMubGV2ZWxzID0ge307IC8vIGhpZXJhcmNoeSBsZXZlbCBwZXIgbm9kZSBpZFxuXG4gICAgdGhpcy5kaXN0cmlidXRpb25JbmRleCA9IHt9OyAvLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gdGhlIGxldmVsIHNvcnRpbmcgb3JkZXIsIHBlciBub2RlIGlkLlxuXG4gICAgdGhpcy5pc1RyZWUgPSBmYWxzZTsgLy8gVHJ1ZSBpZiBjdXJyZW50IG5ldHdvcmsgaXMgYSBmb3JtYWwgdHJlZVxuXG4gICAgdGhpcy50cmVlSW5kZXggPSAtMTsgLy8gSGlnaGVzdCB0cmVlIGlkIGluIGN1cnJlbnQgbmV0d29yay5cbiAgfVxuICAvKipcbiAgICogQWRkIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGdpdmVuIG5vZGVzIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGUuaWR9IHBhcmVudE5vZGVJZFxuICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkTm9kZUlkXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFN0YXR1cywgW3tcbiAgICBrZXk6IFwiYWRkUmVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRpb24ocGFyZW50Tm9kZUlkLCBjaGlsZE5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0ucHVzaChjaGlsZE5vZGVJZCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdLnB1c2gocGFyZW50Tm9kZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgZm9yIGEgZm9ybWFsIHRyZWUgb3IgZm9ybWFsIGZvcmVzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGNhc2UgaWYgZXZlcnkgbm9kZSBoYXMgYXQgbW9zdCBvbmUgcGFyZW50LlxuICAgICAqXG4gICAgICogUHJlOiBwYXJlbnRSZWZlcmVuY2UgaW5pdCdlZCBwcm9wZXJseSBmb3IgY3VycmVudCBuZXR3b3JrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0lmVHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0lmVHJlZSgpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5wYXJlbnRSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50UmVmZXJlbmNlW2ldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLmlzVHJlZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmlzVHJlZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNlcGFyYXRlIHRyZWVzIGluIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibnVtVHJlZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVtVHJlZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlSW5kZXggKyAxOyAvLyBUaGlzIGFzc3VtZXMgdGhlIGluZGV4ZXMgYXJlIGFzc2lnbmVkIGNvbnNlY2l0aXZlbHlcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgdHJlZSBpZCB0byBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdHJlZUlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmVlSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJlZUluZGV4KG5vZGUsIHRyZWVJZCkge1xuICAgICAgaWYgKHRyZWVJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIERvbid0IGJvdGhlclxuXG4gICAgICBpZiAodGhpcy50cmVlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudHJlZXNbbm9kZS5pZF0gPSB0cmVlSWQ7XG4gICAgICAgIHRoaXMudHJlZUluZGV4ID0gTWF0aC5tYXgodHJlZUlkLCB0aGlzLnRyZWVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSBsZXZlbCBmb3IgZ2l2ZW4gaWQgaXMgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIFNldHMgbGV2ZWwgdG8gemVybyBmb3IgZ2l2ZW4gbm9kZSBpZCBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5zdXJlTGV2ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlTGV2ZWwobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGV2ZWxzW25vZGVJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG1heGltdW0gbGV2ZWwgb2YgYSBicmFuY2guXG4gICAgICpcbiAgICAgKiBUT0RPOiBOZXZlciBlbnRlcmVkOyBmaW5kIGEgdGVzdCBjYXNlIHRvIHRlc3QgdGhpcyFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE1heExldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGFjY3VtdWxhdG9yID0ge307XG5cbiAgICAgIHZhciBfZ2V0TWF4TGV2ZWwgPSBmdW5jdGlvbiBfZ2V0TWF4TGV2ZWwobm9kZUlkKSB7XG4gICAgICAgIGlmIChhY2N1bXVsYXRvcltub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3Jbbm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZXZlbCA9IF90aGlzLmxldmVsc1tub2RlSWRdO1xuXG4gICAgICAgIGlmIChfdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMuY2hpbGRyZW5SZWZlcmVuY2Vbbm9kZUlkXTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gTWF0aC5tYXgobGV2ZWwsIF9nZXRNYXhMZXZlbChjaGlsZHJlbltpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFjY3VtdWxhdG9yW25vZGVJZF0gPSBsZXZlbDtcbiAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF9nZXRNYXhMZXZlbChub2RlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZUFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVCXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZXZlbERvd25zdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVCLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNldCBpbml0aWFsIGxldmVsXG4gICAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlQS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubGV2ZWxzW25vZGVBLmlkXSA9IDA7XG4gICAgICAgIH0gLy8gc2V0IGxldmVsXG5cblxuICAgICAgICB0aGlzLmxldmVsc1tub2RlQi5pZF0gPSB0aGlzLmxldmVsc1tub2RlQS5pZF0gKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbWFsbCB1dGlsIG1ldGhvZCB0byBzZXQgdGhlIG1pbmltdW0gbGV2ZWxzIG9mIHRoZSBub2RlcyB0byB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRNaW5MZXZlbFRvWmVyb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNaW5MZXZlbFRvWmVybyhub2Rlcykge1xuICAgICAgdmFyIG1pbkxldmVsID0gMWU5OyAvLyBnZXQgdGhlIG1pbmltdW0gbGV2ZWxcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtaW5MZXZlbCA9IE1hdGgubWluKHRoaXMubGV2ZWxzW25vZGVJZF0sIG1pbkxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc3VidHJhY3QgdGhlIG1pbmltdW0gZnJvbSB0aGUgc2V0IHNvIHdlIGhhdmUgYSByYW5nZSBzdGFydGluZyBmcm9tIDBcblxuXG4gICAgICBmb3IgKHZhciBfbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIF9ub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGV2ZWxzW19ub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGV2ZWxzW19ub2RlSWRdIC09IG1pbkxldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbiBhbmQgbWF4IHh5LWNvb3JkaW5hdGVzIG9mIGEgZ2l2ZW4gdHJlZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge3ttaW5feDogbnVtYmVyLCBtYXhfeDogbnVtYmVyLCBtaW5feTogbnVtYmVyLCBtYXhfeTogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKG5vZGVzLCBpbmRleCkge1xuICAgICAgdmFyIG1pbl94ID0gMWU5O1xuICAgICAgdmFyIG1heF94ID0gLTFlOTtcbiAgICAgIHZhciBtaW5feSA9IDFlOTtcbiAgICAgIHZhciBtYXhfeSA9IC0xZTk7XG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnRyZWVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50cmVlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLnRyZWVzW25vZGVJZF0gPT09IGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBtaW5feCA9IE1hdGgubWluKG5vZGUueCwgbWluX3gpO1xuICAgICAgICAgICAgbWF4X3ggPSBNYXRoLm1heChub2RlLngsIG1heF94KTtcbiAgICAgICAgICAgIG1pbl95ID0gTWF0aC5taW4obm9kZS55LCBtaW5feSk7XG4gICAgICAgICAgICBtYXhfeSA9IE1hdGgubWF4KG5vZGUueSwgbWF4X3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5feDogbWluX3gsXG4gICAgICAgIG1heF94OiBtYXhfeCxcbiAgICAgICAgbWluX3k6IG1pbl95LFxuICAgICAgICBtYXhfeTogbWF4X3lcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudChzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHdvIG5vZGVzIGhhdmUgYSBzYW1lIGFuY2VzdG9yIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzU2FtZVBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikge1xuICAgICAgdmFyIHBhcmVudHMxID0gdGhpcy5wYXJlbnRSZWZlcmVuY2Vbbm9kZTEuaWRdO1xuICAgICAgdmFyIHBhcmVudHMyID0gdGhpcy5wYXJlbnRSZWZlcmVuY2Vbbm9kZTIuaWRdO1xuXG4gICAgICBpZiAocGFyZW50czEgPT09IHVuZGVmaW5lZCB8fCBwYXJlbnRzMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmVudHMyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHBhcmVudHMxW2ldID09IHBhcmVudHMyW2pdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gbm9kZXMgYXJlIGluIHRoZSBzYW1lIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXMgc28sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5TYW1lU3ViTmV0d29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikge1xuICAgICAgcmV0dXJuIHRoaXMudHJlZXNbbm9kZTEuaWRdID09PSB0aGlzLnRyZWVzW25vZGUyLmlkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiB0aGUgZGlzdGluY3QgbGV2ZWxzIGluIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExldmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZXZlbHMoKSB7XG4gICAgICByZXR1cm4ga2V5cyQ0KHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub2RlIHRvIHRoZSBvcmRlcmluZyBwZXIgbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVG9PcmRlcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKSB7XG4gICAgICBpZiAodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNQcmVzZW50ID0gZmFsc2U7XG4gICAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcblxuICAgICAgZm9yICh2YXIgbiBpbiBjdXJMZXZlbCkge1xuICAgICAgICAvL2lmIChjdXJMZXZlbFtuXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICBpZiAoY3VyTGV2ZWxbbl0gPT09IG5vZGUpIHtcbiAgICAgICAgICBpc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQcmVzZW50KSB7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF0gPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaWVyYXJjaGljYWxTdGF0dXM7XG59KCk7XG4vKipcbiAqIFRoZSBMYXlvdXQgRW5naW5lXG4gKi9cblxuXG52YXIgTGF5b3V0RW5naW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBMYXlvdXRFbmdpbmUoYm9keSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXRFbmdpbmUpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTsgLy8gTWFrZSBzdXJlIHRoZXJlIGFsd2F5cyBpcyBzb21lIFJORyBiZWNhdXNlIHRoZSBzZXRPcHRpb25zIG1ldGhvZCB3b24ndFxuICAgIC8vIHNldCBpdCB1bmxlc3MgdGhlcmUncyBhIHNlZWQgZm9yIGl0LlxuXG4gICAgdGhpcy5fcmVzZXRSTkcoTWF0aC5yYW5kb20oKSArIFwiOlwiICsgbm93JDEoKSk7XG5cbiAgICB0aGlzLnNldFBoeXNpY3MgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnNCYWNrdXAgPSB7XG4gICAgICBwaHlzaWNzOiB7fVxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJhbmRvbVNlZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgY2x1c3RlclRocmVzaG9sZDogMTUwLFxuICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsZXZlbFNlcGFyYXRpb246IDE1MCxcbiAgICAgICAgbm9kZVNwYWNpbmc6IDEwMCxcbiAgICAgICAgdHJlZVNwYWNpbmc6IDIwMCxcbiAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogXCJVRFwiLFxuICAgICAgICAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgICBzb3J0TWV0aG9kOiBcImh1YnNpemVcIiAvLyBodWJzaXplLCBkaXJlY3RlZFxuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTGF5b3V0RW5naW5lLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGF5b3V0TmV0d29yaygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBnZXQgdGhlIHR5cGUgb2Ygc3RhdGljIHNtb290aCBjdXJ2ZSBpbiBjYXNlIGl0IGlzIHJlcXVpcmVkXG5cblxuICAgICAgICB2YXIgdHlwZSA9IF90aGlzMi5kaXJlY3Rpb24uY3VydmVUeXBlKCk7IC8vIGZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuXG5cbiAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgdHlwZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWxsT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaGllcmFyY2hpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbDtcbiAgICAgICAgdmFyIHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9IGhpZXJhcmNoaWNhbC5lbmFibGVkO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKFtcInJhbmRvbVNlZWRcIiwgXCJpbXByb3ZlZExheW91dFwiLCBcImNsdXN0ZXJUaHJlc2hvbGRcIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwiaGllcmFyY2hpY2FsXCIpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJhbmRvbVNlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0Uk5HKG9wdGlvbnMucmFuZG9tU2VlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoXCIsIHRydWUpO1xuICAgICAgICAgIH0gLy8gbWFrZSBzdXJlIHRoZSBsZXZlbCBzZXBhcmF0aW9uIGlzIHRoZSByaWdodCB3YXkgdXBcblxuXG4gICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiUkxcIiB8fCBoaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIkRVXCIpIHtcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICBoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiKTsgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsXG4gICAgICAgICAgLy8gd2UgYWRhcHQgdGhlIG90aGVyIG9wdGlvbnMgaWYgbmVlZGVkLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIG92ZXJyaWRkZW4gb3B0aW9ucyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIik7XG4gICAgICAgICAgICByZXR1cm4gZGVlcEV4dGVuZChhbGxPcHRpb25zLCB0aGlzLm9wdGlvbnNCYWNrdXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHdpdGggZ2l2ZW4gc2VlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBzZWVkIC0gVGhlIHNlZWQgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0aGUgdGhlIFJORy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNldFJOR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXRSTkcoc2VlZCkge1xuICAgICAgdGhpcy5pbml0aWFsUmFuZG9tU2VlZCA9IHNlZWQ7XG4gICAgICB0aGlzLl9ybmcgPSBBbGVhKHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoYWxsT3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgYmFja3VwUGh5c2ljcyA9IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzOyAvLyBzZXQgdGhlIHBoeXNpY3NcblxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQgfHwgYWxsT3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkLFxuICAgICAgICAgICAgc29sdmVyOiBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPSBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBiYWNrdXBQaHlzaWNzLmVuYWJsZWQ7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5zb2x2ZXIgPSBiYWNrdXBQaHlzaWNzLnNvbHZlciB8fCBcImJhcm5lc0h1dFwiO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoYWxsT3B0aW9ucy5waHlzaWNzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9IGFsbE9wdGlvbnMucGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQ7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5zb2x2ZXIgPSBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyIHx8IFwiYmFybmVzSHV0XCI7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzLnNvbHZlciA9IFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsT3B0aW9ucy5waHlzaWNzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gXCJiYXJuZXNIdXRcIjtcbiAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3MgPSB7XG4gICAgICAgICAgICBzb2x2ZXI6IFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcblxuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5kaXJlY3Rpb24uY3VydmVUeXBlKCk7IC8vIGRpc2FibGUgc21vb3RoIGN1cnZlcyBpZiBub3RoaW5nIGlzIGRlZmluZWQuIElmIHNtb290aCBjdXJ2ZXMgaGF2ZSBiZWVuIHR1cm5lZCBvbixcbiAgICAgICAgLy8gdHVybiB0aGVtIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG5cbiAgICAgICAgaWYgKGFsbE9wdGlvbnMuZWRnZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgICAgc21vb3RoOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0ge1xuICAgICAgICAgICAgICBlbmFibGVkOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoOyAvLyBhbGxvdyBjdXN0b20gdHlwZXMgZXhjZXB0IGZvciBkeW5hbWljXG5cbiAgICAgICAgICAgIGlmIChzbW9vdGgudHlwZSAhPT0gdW5kZWZpbmVkICYmIHNtb290aC50eXBlICE9PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgICAgICB0eXBlID0gc21vb3RoLnR5cGU7XG4gICAgICAgICAgICB9IC8vIFRPRE86IHRoaXMgaXMgb3B0aW9ucyBtZXJnaW5nOyBzZWUgaWYgdGhlIHN0YW5kYXJkIHJvdXRpbmVzIGNhbiBiZSB1c2VkIGhlcmUuXG5cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBzbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNtb290aC5lbmFibGVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNtb290aC50eXBlID09PSB1bmRlZmluZWQgPyBcImR5bmFtaWNcIiA6IHNtb290aC50eXBlLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogc21vb3RoLnJvdW5kbmVzcyxcbiAgICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9OyAvLyBOT1RFOiBDb3B5aW5nIGFuIG9iamVjdCB0byBzZWxmOyB0aGlzIGlzIGJhc2ljYWxseSBzZXR0aW5nIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgdmFyaWFibGVzXG5cbiAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0ge1xuICAgICAgICAgICAgICBlbmFibGVkOiBzbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNtb290aC5lbmFibGVkLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICByb3VuZG5lc3M6IHNtb290aC5yb3VuZG5lc3MgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBGb3JjZSBhbGwgZWRnZXMgaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cbiAgICAgICAgLy8gT25seSBhcHBsaWVzIHRvIGVkZ2VzIHRoYXQgZG8gbm90IHVzZSB0aGUgZ2xvYmFsIG9wdGlvbnMgZm9yIHNtb290aC5cblxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlc1wiLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBvc2l0aW9uSW5pdGlhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uSW5pdGlhbGx5KG5vZGVzQXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRSTkcodGhpcy5pbml0aWFsUmFuZG9tU2VlZCk7XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IG5vZGVzQXJyYXkubGVuZ3RoICsgNTA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuXG4gICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiB0aGlzLl9ybmcoKTtcblxuICAgICAgICAgIGlmIChub2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS55ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgS2FtYWRhIEthd2FpIHRvIHBvc2l0aW9uIG5vZGVzLiBUaGlzIGlzIHF1aXRlIGEgaGVhdnkgYWxnb3JpdGhtIHNvIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBub2RlcyB3ZVxuICAgICAqIGNsdXN0ZXIgdGhlbSBmaXJzdCB0byByZWR1Y2UgdGhlIGFtb3VudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxheW91dE5ldHdvcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0TmV0d29yaygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmltcHJvdmVkTGF5b3V0ID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzOyAvLyBmaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgS2FtYWRhIEthd2FpIHRvIGxheW91dC4gVGhlIHRocmVzaG9sZCBpcyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgdmlzaWJsZVxuICAgICAgICAvLyBub2RlcyBoYXZlIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHVzZSB0aGlzLlxuXG4gICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGljZXNbaV1dO1xuXG4gICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uIHdlIGNvbnRpbnVlXG5cblxuICAgICAgICBpZiAocG9zaXRpb25EZWZpbmVkIDwgMC41ICogaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgTUFYX0xFVkVMUyA9IDEwO1xuICAgICAgICAgIHZhciBsZXZlbCA9IDA7XG4gICAgICAgICAgdmFyIGNsdXN0ZXJUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuY2x1c3RlclRocmVzaG9sZDsgLy9cbiAgICAgICAgICAvLyBEZWZpbmUgdGhlIG9wdGlvbnMgZm9yIHRoZSBoaWRkZW4gY2x1c3RlciBub2Rlc1xuICAgICAgICAgIC8vIFRoZXNlIG9wdGlvbnMgZG9uJ3QgcHJvcGFnYXRlIG91dHNpZGUgdGhlIGNsdXN0ZXJpbmcgcGhhc2UuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBTb21lIG9wdGlvbnMgYXJlIGV4cGxpY2l0bHkgZGlzYWJsZWQsIGJlY2F1c2UgdGhleSBtYXkgYmUgc2V0IGluIGdyb3VwIG9yIGRlZmF1bHQgbm9kZSBvcHRpb25zLlxuICAgICAgICAgIC8vIFRoZSBjbHVzdGVycyBhcmUgbmV2ZXIgZGlzcGxheWVkLCBzbyBtb3N0IGV4cGxpY2l0IHNldHRpbmdzIGhlcmUgc2VydmUgYXMgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9ucy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBleHBsaWNpdCBzZXR0aW5nIG9mICdzaGFwZScgaXMgdG8gYXZvaWQgYHNoYXBlOiAnaW1hZ2UnYDsgaW1hZ2VzIGFyZSBub3QgcGFzc2VkIHRvIHRoZSBoaWRkZW5cbiAgICAgICAgICAvLyBjbHVzdGVyIG5vZGVzLCBsZWFkaW5nIHRvIGFuIGV4Y2VwdGlvbiBvbiBjcmVhdGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEFsbCBzZXR0aW5ncyBoZXJlIGFyZSBwZXJmb3JtYW5jZSByZWxhdGVkLCBleGNlcHQgd2hlbiBub3RlZCBvdGhlcndpc2UuXG4gICAgICAgICAgLy9cblxuICAgICAgICAgIHZhciBjbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllczoge1xuICAgICAgICAgICAgICBzaGFwZTogXCJlbGxpcHNlXCIsXG4gICAgICAgICAgICAgIC8vIEJ1Z2ZpeDogYXZvaWQgdHlwZSAnaW1hZ2UnLCBubyBpbWFnZXMgc3VwcGxpZWRcbiAgICAgICAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGxhYmVsIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGdyb3VwOiBcIlwiLFxuICAgICAgICAgICAgICAvLyBhdm9pZCBncm91cCBoYW5kbGluZ1xuICAgICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IGZhbHNlXG4gICAgICAgICAgICAgIH0gLy8gYXZvaWQgZm9udCBwcm9wYWdhdGlvblxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICAgICAgICAvLyBhdm9pZCBsYWJlbCBoYW5kbGluZ1xuICAgICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IGZhbHNlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGZvbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UgLy8gYXZvaWQgZHJhd2luZyBwZW5hbHR5IGZvciBjb21wbGV4IGVkZ2VzXG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07IC8vIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBub2Rlcywgd2UgY2x1c3RlciBiZWZvcmUgd2UgcnVuIHRoZSBhbGdvcml0aG0uXG4gICAgICAgICAgLy8gTk9URTogdGhpcyBwYXJ0IGZhaWxzIHRvIGZpbmQgY2x1c3RlcnMgZm9yIGxhcmdlIHNjYWxlLWZyZWUgbmV0d29ya3MsIHdoaWNoIHNob3VsZFxuICAgICAgICAgIC8vICAgICAgIGJlIGVhc2lseSBjbHVzdGVyYWJsZS5cbiAgICAgICAgICAvLyBUT0RPOiBleGFtaW5lIHdoeSB0aGlzIGlzIHNvXG5cbiAgICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRMZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCAmJiBsZXZlbCA8PSBNQVhfTEVWRUxTKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS50aW1lKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICBsZXZlbCArPSAxO1xuICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gaW5kaWNlcy5sZW5ndGg7IC8vIGlmIHRoZXJlIGFyZSBtYW55IG5vZGVzIHdlIGRvIGEgaHVic2l6ZSBjbHVzdGVyXG5cbiAgICAgICAgICAgICAgaWYgKGxldmVsICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3RlckJyaWRnZXMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKGNsdXN0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBhZnRlciA9IGluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGlmIChiZWZvcmUgPT0gYWZ0ZXIgJiYgbGV2ZWwgJSAzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2xheW91dEZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIG5ldHdvcmsgY291bGQgbm90IGJlIHBvc2l0aW9uZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBpbXByb3ZlZCBsYXlvdXQgYWxnb3JpdGhtLlwiICsgXCIgUGxlYXNlIGRpc2FibGUgaW1wcm92ZWRMYXlvdXQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IC8vY29uc29sZS50aW1lRW5kKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJlZm9yZSxsZXZlbCxhZnRlcik7XG5cbiAgICAgICAgICAgIH0gLy8gaW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIGVkZ2VzXG5cblxuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgIHNwcmluZ0xlbmd0aDogTWF0aC5tYXgoMTUwLCAyICogc3RhcnRMZW5ndGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGV2ZWwgPiBNQVhfTEVWRUxTKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGUgY2x1c3RlcmluZyBkaWRuJ3Qgc3VjY2VlZCB3aXRoaW4gdGhlIGFtb3VudCBvZiBpbnRlcmF0aW9ucyBhbGxvd2VkLFwiICsgXCIgcHJvZ3Jlc3Npbmcgd2l0aCBwYXJ0aWFsIHJlc3VsdC5cIik7XG4gICAgICAgICAgfSAvLyBwb3NpdGlvbiB0aGUgc3lzdGVtIGZvciB0aGVzZSBub2RlcyBhbmQgZWRnZXNcblxuXG4gICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc29sdmUoaW5kaWNlcywgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLCB0cnVlKTsgLy8gc2hpZnQgdG8gY2VudGVyIHBvaW50XG5cbiAgICAgICAgICB0aGlzLl9zaGlmdFRvQ2VudGVyKCk7IC8vIHBlcnR1cmIgdGhlIG5vZGVzIGEgbGl0dGxlIGJpdCB0byBmb3JjZSB0aGUgcGh5c2ljcyB0byBraWNrIGluXG5cblxuICAgICAgICAgIHZhciBvZmZzZXQgPSA3MDtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgLy8gT25seSBwZXJ0dXJiIHRoZSBub2RlcyB0aGF0IGFyZW4ndCBmaXhlZFxuICAgICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGljZXNbX2ldXTtcblxuICAgICAgICAgICAgaWYgKF9ub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgX25vZGUueCArPSAoMC41IC0gdGhpcy5fcm5nKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgICBfbm9kZS55ICs9ICgwLjUgLSB0aGlzLl9ybmcoKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyB1bmNsdXN0ZXIgYWxsIGNsdXN0ZXJzXG5cblxuICAgICAgICAgIHRoaXMuX2RlY2x1c3RlckFsbCgpOyAvLyByZXBvc2l0aW9uIGFsbCBiZXppZXIgbm9kZXMuXG5cblxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmUgYWxsIHRoZSBub2RlcyB0b3dhcmRzIHRvIHRoZSBjZW50ZXIgc28gZ3Jhdml0YXRpb25hbCBwdWxsIHdpbCBub3QgbW92ZSB0aGUgbm9kZXMgYXdheSBmcm9tIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hpZnRUb0NlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hpZnRUb0NlbnRlcigpIHtcbiAgICAgIHZhciByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlQ29yZSh0aGlzLmJvZHkubm9kZXMsIHRoaXMuYm9keS5ub2RlSW5kaWNlcyk7XG4gICAgICB2YXIgY2VudGVyID0gTmV0d29ya1V0aWwuZmluZENlbnRlcihyYW5nZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIG5vZGUueCAtPSBjZW50ZXIueDtcbiAgICAgICAgbm9kZS55IC09IGNlbnRlci55O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBjbHVzdGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZWNsdXN0ZXJBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY2x1c3RlckFsbCgpIHtcbiAgICAgIHZhciBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAoY2x1c3RlcnNQcmVzZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGNsdXN0ZXJzUHJlc2VudCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIodGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldLCB7fSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcnwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbGF5b3V0IHRoZSBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCB3YXkuXG4gICAgICogSXQgY2hlY2tzIGlmIHRoZSBub2RlIGRldGFpbHMgYXJlIHN1cHBsaWVkIGNvcnJlY3RseVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldHVwSGllcmFyY2hpY2FsTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBnZXQgdGhlIHNpemUgb2YgdGhlIGxhcmdlc3QgaHVicyBhbmQgY2hlY2sgaWYgdGhlIHVzZXIgaGFzIGRlZmluZWQgYSBsZXZlbCBmb3IgYSBub2RlLlxuICAgICAgICB2YXIgbm9kZSwgbm9kZUlkO1xuICAgICAgICB2YXIgZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgIHZhciB1bmRlZmluZWRMZXZlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbCA9IHt9O1xuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbCA9IG5ldyBIaWVyYXJjaGljYWxTdGF0dXMoKTtcblxuICAgICAgICBmb3IgKG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF0gPSBub2RlLm9wdGlvbnMubGV2ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmRlZmluZWRMZXZlbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHRoZSB1c2VyIGRlZmluZWQgc29tZSBsZXZlbHMgYnV0IG5vdCBhbGwsIGFsZXJ0IGFuZCBydW4gd2l0aG91dCBoaWVyYXJjaGljYWwgbGF5b3V0XG5cblxuICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUgJiYgZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdXNlIHRoZSBoaWVyYXJjaGljYWwgbGF5b3V0LCBub2RlcyByZXF1aXJlIGVpdGhlciBubyBwcmVkZWZpbmVkIGxldmVsc1wiICsgXCIgb3IgbGV2ZWxzIGhhdmUgdG8gYmUgZGVmaW5lZCBmb3IgYWxsIG5vZGVzLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZpbmUgbGV2ZWxzIGlmIHVuZGVmaW5lZCBieSB0aGUgdXNlcnMuIEJhc2VkIG9uIGh1YnNpemUuXG4gICAgICAgICAgaWYgKHVuZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgc29ydE1ldGhvZCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc29ydE1ldGhvZDtcblxuICAgICAgICAgICAgaWYgKHNvcnRNZXRob2QgPT09IFwiaHVic2l6ZVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0TWV0aG9kID09PSBcImRpcmVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydE1ldGhvZCA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gZmFsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBub2RlcyBidXQgbm8gZWRnZXNcblxuXG4gICAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcywgX25vZGVJZDIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmVuc3VyZUxldmVsKF9ub2RlSWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGNoZWNrIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlIG5vZGVzIHBlciBsZXZlbC5cblxuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHRoaXMuX2dldERpc3RyaWJ1dGlvbigpOyAvLyBnZXQgdGhlIHBhcmVudCBjaGlsZHJlbiByZWxhdGlvbnMuXG5cblxuICAgICAgICAgIHRoaXMuX2dlbmVyYXRlTWFwKCk7IC8vIHBsYWNlIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzLlxuXG5cbiAgICAgICAgICB0aGlzLl9wbGFjZU5vZGVzQnlIaWVyYXJjaHkoZGlzdHJpYnV0aW9uKTsgLy8gY29uZGVuc2UgdGhlIHdoaXRlc3BhY2UuXG5cblxuICAgICAgICAgIHRoaXMuX2NvbmRlbnNlSGllcmFyY2h5KCk7IC8vIHNoaWZ0IHRvIGNlbnRlciBzbyBncmF2aXR5IGRvZXMgbm90IGhhdmUgdG8gZG8gbXVjaFxuXG5cbiAgICAgICAgICB0aGlzLl9zaGlmdFRvQ2VudGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb25kZW5zZUhpZXJhcmNoeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uZGVuc2VIaWVyYXJjaHkoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gR2xvYmFsIHZhciBpbiB0aGlzIHNjb3BlIHRvIGRlZmluZSB3aGVuIHRoZSBtb3ZlbWVudCBoYXMgc3RvcHBlZC5cbiAgICAgIHZhciBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICB2YXIgYnJhbmNoZXMgPSB7fTsgLy8gZmlyc3Qgd2UgaGF2ZSBzb21lIG1ldGhvZHMgdG8gaGVscCBzaGlmdGluZyB0cmVlcyBhcm91bmQuXG4gICAgICAvLyB0aGUgbWFpbiBtZXRob2QgdG8gc2hpZnQgdGhlIHRyZWVzXG5cbiAgICAgIHZhciBzaGlmdFRyZWVzID0gZnVuY3Rpb24gc2hpZnRUcmVlcygpIHtcbiAgICAgICAgdmFyIHRyZWVTaXplcyA9IGdldFRyZWVTaXplcygpO1xuICAgICAgICB2YXIgc2hpZnRCeSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlU2l6ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSB0cmVlU2l6ZXNbaV0ubWF4IC0gdHJlZVNpemVzW2kgKyAxXS5taW47XG4gICAgICAgICAgc2hpZnRCeSArPSBkaWZmICsgX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnRyZWVTcGFjaW5nO1xuICAgICAgICAgIHNoaWZ0VHJlZShpICsgMSwgc2hpZnRCeSk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIHNoaWZ0IGEgc2luZ2xlIHRyZWUgYnkgYW4gb2Zmc2V0XG5cblxuICAgICAgdmFyIHNoaWZ0VHJlZSA9IGZ1bmN0aW9uIHNoaWZ0VHJlZShpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB0cmVlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwudHJlZXM7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRyZWVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0cmVlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRyZWVzW25vZGVJZF0gPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgIF90aGlzMy5kaXJlY3Rpb24uc2hpZnQobm9kZUlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gZ2V0IHRoZSB3aWR0aCBvZiBhbGwgdHJlZXNcblxuXG4gICAgICB2YXIgZ2V0VHJlZVNpemVzID0gZnVuY3Rpb24gZ2V0VHJlZVNpemVzKCkge1xuICAgICAgICB2YXIgdHJlZVdpZHRocyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLmhpZXJhcmNoaWNhbC5udW1UcmVlcygpOyBpKyspIHtcbiAgICAgICAgICB0cmVlV2lkdGhzLnB1c2goX3RoaXMzLmRpcmVjdGlvbi5nZXRUcmVlU2l6ZShpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJlZVdpZHRocztcbiAgICAgIH07IC8vIGdldCBhIG1hcCBvZiBhbGwgbm9kZXMgaW4gdGhpcyBicmFuY2hcblxuXG4gICAgICB2YXIgZ2V0QnJhbmNoTm9kZXMgPSBmdW5jdGlvbiBnZXRCcmFuY2hOb2Rlcyhzb3VyY2UsIG1hcCkge1xuICAgICAgICBpZiAobWFwW3NvdXJjZS5pZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbc291cmNlLmlkXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGdldEJyYW5jaE5vZGVzKF90aGlzMy5ib2R5Lm5vZGVzW2NoaWxkcmVuW2ldXSwgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGdldCBhIG1pbiBtYXggd2lkdGggYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBtb3ZlbWVudCBzcGFjZSBpdCBoYXMgb24gZWl0aGVyIHNpZGVzXG4gICAgICAvLyB3ZSB1c2UgbWluIG1heCB0ZXJtaW5vbG9neSBiZWNhdXNlIHdpZHRoIGFuZCBoZWlnaHQgY2FuIGludGVyY2hhbmdlIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsYXlvdXRcblxuXG4gICAgICB2YXIgZ2V0QnJhbmNoQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hNYXApIHtcbiAgICAgICAgdmFyIG1heExldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxZTk7XG4gICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWluID0gMWU5O1xuICAgICAgICB2YXIgbWF4ID0gLTFlOTtcblxuICAgICAgICBmb3IgKHZhciBicmFuY2hOb2RlIGluIGJyYW5jaE1hcCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYnJhbmNoTWFwLCBicmFuY2hOb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1ticmFuY2hOb2RlXTtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpOyAvLyBnZXQgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS5cblxuXG4gICAgICAgICAgICB2YXIgX3RoaXMzJF9nZXRTcGFjZUFyb3VuID0gX3RoaXMzLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgYnJhbmNoTWFwKSxcbiAgICAgICAgICAgICAgICBfdGhpczMkX2dldFNwYWNlQXJvdW4yID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMzJF9nZXRTcGFjZUFyb3VuLCAyKSxcbiAgICAgICAgICAgICAgICBtaW5TcGFjZU5vZGUgPSBfdGhpczMkX2dldFNwYWNlQXJvdW4yWzBdLFxuICAgICAgICAgICAgICAgIG1heFNwYWNlTm9kZSA9IF90aGlzMyRfZ2V0U3BhY2VBcm91bjJbMV07XG5cbiAgICAgICAgICAgIG1pblNwYWNlID0gTWF0aC5taW4obWluU3BhY2VOb2RlLCBtaW5TcGFjZSk7XG4gICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlTm9kZSwgbWF4U3BhY2UpOyAvLyB0aGUgd2lkdGggaXMgb25seSByZWxldmFudCBmb3IgdGhlIGxldmVscyB0d28gbm9kZXMgaGF2ZSBpbiBjb21tb24uIFRoaXMgaXMgd2h5IHdlIGZpbHRlciBvbiB0aGlzLlxuXG4gICAgICAgICAgICBpZiAobGV2ZWwgPD0gbWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ocG9zaXRpb24sIG1pbik7XG4gICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHBvc2l0aW9uLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWluLCBtYXgsIG1pblNwYWNlLCBtYXhTcGFjZV07XG4gICAgICB9OyAvLyBjaGVjayB3aGF0IHRoZSBtYXhpbXVtIGxldmVsIGlzIHRoZXNlIG5vZGVzIGhhdmUgaW4gY29tbW9uLlxuXG5cbiAgICAgIHZhciBnZXRDb2xsaXNpb25MZXZlbCA9IGZ1bmN0aW9uIGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgbWF4TGV2ZWwxID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChub2RlMS5pZCk7XG5cbiAgICAgICAgdmFyIG1heExldmVsMiA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TWF4TGV2ZWwobm9kZTIuaWQpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtYXhMZXZlbDEsIG1heExldmVsMik7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDb25kZW5zZSBlbGVtZW50cy4gVGhlc2UgY2FuIGJlIG5vZGVzIG9yIGJyYW5jaGVzIGRlcGVuZGluZyBvbiB0aGUgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGxldmVsc1xuICAgICAgICogQHBhcmFtIHsqfSBjZW50ZXJQYXJlbnRzXG4gICAgICAgKi9cblxuXG4gICAgICB2YXIgc2hpZnRFbGVtZW50c0Nsb3NlciA9IGZ1bmN0aW9uIHNoaWZ0RWxlbWVudHNDbG9zZXIoY2FsbGJhY2ssIGxldmVscywgY2VudGVyUGFyZW50cykge1xuICAgICAgICB2YXIgaGllciA9IF90aGlzMy5oaWVyYXJjaGljYWw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBoaWVyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcblxuICAgICAgICAgIGlmIChsZXZlbE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUxID0gbGV2ZWxOb2Rlc1tqXTtcbiAgICAgICAgICAgICAgdmFyIG5vZGUyID0gbGV2ZWxOb2Rlc1tqICsgMV07IC8vIE5PVEU6IGxvZ2ljIG1haW50YWluZWQgYXMgaXQgd2FzOyBpZiBub2RlcyBoYXZlIHNhbWUgYW5jZXN0b3IsXG4gICAgICAgICAgICAgIC8vICAgICAgIHRoZW4gb2YgY291cnNlIHRoZXkgYXJlIGluIHRoZSBzYW1lIHN1Yi1uZXR3b3JrLlxuXG4gICAgICAgICAgICAgIGlmIChoaWVyLmhhc1NhbWVQYXJlbnQobm9kZTEsIG5vZGUyKSAmJiBoaWVyLmluU2FtZVN1Yk5ldHdvcmsobm9kZTEsIG5vZGUyKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUxLCBub2RlMiwgY2VudGVyUGFyZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGNhbGxiYWNrIGZvciBzaGlmdGluZyBicmFuY2hlc1xuXG5cbiAgICAgIHZhciBicmFuY2hTaGlmdENhbGxiYWNrID0gZnVuY3Rpb24gYnJhbmNoU2hpZnRDYWxsYmFjayhub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgdmFyIGNlbnRlclBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICB2YXIgcG9zMSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTEpO1xuXG4gICAgICAgIHZhciBwb3MyID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlMik7XG5cbiAgICAgICAgdmFyIGRpZmZBYnMgPSBNYXRoLmFicyhwb3MyIC0gcG9zMSk7XG4gICAgICAgIHZhciBub2RlU3BhY2luZyA9IF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZzsgLy9jb25zb2xlLmxvZyhcIk5PVyBDSEVDS0lORzpcIiwgbm9kZTEuaWQsIG5vZGUyLmlkLCBkaWZmQWJzKTtcblxuICAgICAgICBpZiAoZGlmZkFicyA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMSA9IHt9O1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlczIgPSB7fTtcbiAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlMSwgYnJhbmNoTm9kZXMxKTtcbiAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlMiwgYnJhbmNoTm9kZXMyKTsgLy8gY2hlY2sgdGhlIGxhcmdlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYnJhbmNoZXNcblxuICAgICAgICAgIHZhciBtYXhMZXZlbCA9IGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMik7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTEgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZUJvdW5kYXJ5MiA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMiwgbWF4TGV2ZWwpO1xuICAgICAgICAgIHZhciBtYXgxID0gYnJhbmNoTm9kZUJvdW5kYXJ5MVsxXTtcbiAgICAgICAgICB2YXIgbWluMiA9IGJyYW5jaE5vZGVCb3VuZGFyeTJbMF07XG4gICAgICAgICAgdmFyIG1pblNwYWNlMiA9IGJyYW5jaE5vZGVCb3VuZGFyeTJbMl07IC8vY29uc29sZS5sb2cobm9kZTEuaWQsIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMSwgbWF4TGV2ZWwpLCBub2RlMi5pZCxcbiAgICAgICAgICAvLyAgICAgICAgICAgIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMiwgbWF4TGV2ZWwpLCBtYXhMZXZlbCk7XG5cbiAgICAgICAgICB2YXIgZGlmZkJyYW5jaCA9IE1hdGguYWJzKG1heDEgLSBtaW4yKTtcblxuICAgICAgICAgIGlmIChkaWZmQnJhbmNoID4gbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXgxIC0gbWluMiArIG5vZGVTcGFjaW5nO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgLW1pblNwYWNlMiArIG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIG9mZnNldCA9IC1taW5TcGFjZTIgKyBub2RlU3BhY2luZzsgLy9jb25zb2xlLmxvZyhcIlJFU0VUVElORyBPRkZTRVRcIiwgbWF4MSAtIG1pbjIgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nLCAtbWluU3BhY2UyLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU0hJRlRJTkdcIiwgbm9kZTIuaWQsIG9mZnNldCk7XG4gICAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlMi5pZCwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGNlbnRlclBhcmVudCA9PT0gdHJ1ZSkgX3RoaXMzLl9jZW50ZXJQYXJlbnQobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO30pXG5cbiAgICAgIH07XG5cbiAgICAgIHZhciBtaW5pbWl6ZUVkZ2VMZW5ndGggPSBmdW5jdGlvbiBtaW5pbWl6ZUVkZ2VMZW5ndGgoaXRlcmF0aW9ucywgbm9kZSkge1xuICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcInRzXCIsbm9kZS5pZCk7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkO1xuICAgICAgICB2YXIgYWxsRWRnZXMgPSBub2RlLmVkZ2VzO1xuICAgICAgICB2YXIgbm9kZUxldmVsID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZS5pZF07IC8vIGdhdGhlciBjb25zdGFudHNcblxuICAgICAgICB2YXIgQzIgPSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbjtcbiAgICAgICAgdmFyIHJlZmVyZW5jZU5vZGVzID0ge307XG4gICAgICAgIHZhciBhYm92ZUVkZ2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gYWxsRWRnZXNbaV07XG5cbiAgICAgICAgICBpZiAoZWRnZS50b0lkICE9IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS50b0lkID09IG5vZGVJZCA/IGVkZ2UuZnJvbSA6IGVkZ2UudG87XG4gICAgICAgICAgICByZWZlcmVuY2VOb2Rlc1thbGxFZGdlc1tpXS5pZF0gPSBvdGhlck5vZGU7XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tvdGhlck5vZGUuaWRdIDwgbm9kZUxldmVsKSB7XG4gICAgICAgICAgICAgIGFib3ZlRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuXG5cbiAgICAgICAgdmFyIGdldEZ4ID0gZnVuY3Rpb24gZ2V0RngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgIHN1bSArPSBhIC8gTWF0aC5zcXJ0KGEgKiBhICsgQzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07IC8vIGRvdWJseSBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG5cblxuICAgICAgICB2YXIgZ2V0REZ4ID0gZnVuY3Rpb24gZ2V0REZ4KHBvaW50LCBlZGdlcykge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICBzdW0gLT0gQzIgKiBNYXRoLnBvdyhhICogYSArIEMyLCAtMS41KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRHdWVzcyA9IGZ1bmN0aW9uIGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIGd1ZXNzID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTsgLy8gTmV3dG9uJ3MgbWV0aG9kIGZvciBvcHRpbWl6YXRpb25cblxuXG4gICAgICAgICAgdmFyIGd1ZXNzTWFwID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpdGVyYXRpb25zOyBfaTQrKykge1xuICAgICAgICAgICAgdmFyIGZ4ID0gZ2V0RngoZ3Vlc3MsIGVkZ2VzKTtcbiAgICAgICAgICAgIHZhciBkZnggPSBnZXRERngoZ3Vlc3MsIGVkZ2VzKTsgLy8gd2UgbGltaXQgdGhlIG1vdmVtZW50IHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuXG4gICAgICAgICAgICB2YXIgbGltaXQgPSA0MDtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IE1hdGgubWF4KC1saW1pdCwgTWF0aC5taW4obGltaXQsIE1hdGgucm91bmQoZnggLyBkZngpKSk7XG4gICAgICAgICAgICBndWVzcyA9IGd1ZXNzIC0gcmF0aW87IC8vIHJlZHVjZSBkdXBsaWNhdGVzXG5cbiAgICAgICAgICAgIGlmIChndWVzc01hcFtndWVzc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3Vlc3NNYXBbZ3Vlc3NdID0gX2k0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBndWVzcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW92ZUJyYW5jaCA9IGZ1bmN0aW9uIG1vdmVCcmFuY2goZ3Vlc3MpIHtcbiAgICAgICAgICAvLyBwb3NpdGlvbiBub2RlIGlmIHRoZXJlIGlzIHNwYWNlXG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIGNoZWNrIG1vdmFibGUgYXJlYSBvZiB0aGUgYnJhbmNoXG5cblxuICAgICAgICAgIGlmIChicmFuY2hlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMgPSB7fTtcbiAgICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUsIGJyYW5jaE5vZGVzKTtcbiAgICAgICAgICAgIGJyYW5jaGVzW25vZGUuaWRdID0gYnJhbmNoTm9kZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJyYW5jaEJvdW5kYXJ5ID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoZXNbbm9kZS5pZF0pO1xuICAgICAgICAgIHZhciBtaW5TcGFjZUJyYW5jaCA9IGJyYW5jaEJvdW5kYXJ5WzJdO1xuICAgICAgICAgIHZhciBtYXhTcGFjZUJyYW5jaCA9IGJyYW5jaEJvdW5kYXJ5WzNdO1xuICAgICAgICAgIHZhciBkaWZmID0gZ3Vlc3MgLSBub2RlUG9zaXRpb247IC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG5cbiAgICAgICAgICB2YXIgYnJhbmNoT2Zmc2V0ID0gMDtcblxuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gTWF0aC5taW4oZGlmZiwgbWF4U3BhY2VCcmFuY2ggLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IC1NYXRoLm1pbigtZGlmZiwgbWluU3BhY2VCcmFuY2ggLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChicmFuY2hPZmZzZXQgIT0gMCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vdmluZyBicmFuY2g6XCIsYnJhbmNoT2Zmc2V0LCBtYXhTcGFjZUJyYW5jaCwgbWluU3BhY2VCcmFuY2gpXG4gICAgICAgICAgICBfdGhpczMuX3NoaWZ0QmxvY2sobm9kZS5pZCwgYnJhbmNoT2Zmc2V0KTsgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcblxuXG4gICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1vdmVOb2RlID0gZnVuY3Rpb24gbW92ZU5vZGUoZ3Vlc3MpIHtcbiAgICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTsgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuXG5cbiAgICAgICAgICB2YXIgX3RoaXMzJF9nZXRTcGFjZUFyb3VuMyA9IF90aGlzMy5fZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUpLFxuICAgICAgICAgICAgICBfdGhpczMkX2dldFNwYWNlQXJvdW40ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMzJF9nZXRTcGFjZUFyb3VuMywgMiksXG4gICAgICAgICAgICAgIG1pblNwYWNlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuNFswXSxcbiAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfdGhpczMkX2dldFNwYWNlQXJvdW40WzFdO1xuXG4gICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjsgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcblxuICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1pbihub2RlUG9zaXRpb24gKyAobWF4U3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1heChub2RlUG9zaXRpb24gLSAobWluU3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICE9PSBub2RlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgTm9kZTpcIixkaWZmLCBtaW5TcGFjZSwgbWF4U3BhY2UpO1xuICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBuZXdQb3NpdGlvbik7IC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG5cblxuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFib3ZlRWRnZXMpO1xuICAgICAgICBtb3ZlQnJhbmNoKGd1ZXNzKTtcbiAgICAgICAgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhbGxFZGdlcyk7XG4gICAgICAgIG1vdmVOb2RlKGd1ZXNzKTsgLy99KVxuICAgICAgfTsgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuXG5cbiAgICAgIHZhciBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCA9IGZ1bmN0aW9uIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG5cbiAgICAgICAgbGV2ZWxzID0gcmV2ZXJzZShsZXZlbHMpLmNhbGwobGV2ZWxzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbal07XG4gICAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxldmVsTm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoKDEwMDAsIGxldmVsTm9kZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAgSU4gXCIgKyBpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuXG5cbiAgICAgIHZhciBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgPSBmdW5jdGlvbiBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcblxuICAgICAgICBsZXZlbHMgPSByZXZlcnNlKGxldmVscykuY2FsbChsZXZlbHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNoaWZ0RWxlbWVudHNDbG9zZXIoYnJhbmNoU2hpZnRDYWxsYmFjaywgbGV2ZWxzLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwIElOIFwiICsgKGkrMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBjZW50ZXIgYWxsIHBhcmVudHNcblxuXG4gICAgICB2YXIgY2VudGVyQWxsUGFyZW50cyA9IGZ1bmN0aW9uIGNlbnRlckFsbFBhcmVudHMoKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBfdGhpczMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3RoaXMzLmJvZHkubm9kZXMsIG5vZGVJZCkpIF90aGlzMy5fY2VudGVyUGFyZW50KF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBjZW50ZXIgYWxsIHBhcmVudHNcblxuXG4gICAgICB2YXIgY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwKCkge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcblxuICAgICAgICBsZXZlbHMgPSByZXZlcnNlKGxldmVscykuY2FsbChsZXZlbHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIF90aGlzMy5fY2VudGVyUGFyZW50KGxldmVsTm9kZXNbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gdGhlIGFjdHVhbCB3b3JrIGlzIGRvbmUgaGVyZS5cblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ibG9ja1NoaWZ0aW5nID09PSB0cnVlKSB7XG4gICAgICAgIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCg1KTtcbiAgICAgICAgY2VudGVyQWxsUGFyZW50cygpO1xuICAgICAgfSAvLyBtaW5pbWl6ZSBlZGdlIGxlbmd0aFxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoMjApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5wYXJlbnRDZW50cmFsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKTtcbiAgICAgIH1cblxuICAgICAgc2hpZnRUcmVlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGdpdmVzIHRoZSBzcGFjZSBhcm91bmQgdGhlIG5vZGUuIElGIGEgbWFwIGlzIHN1cHBsaWVkLCBpdCB3aWxsIG9ubHkgY2hlY2sgYWdhaW5zdCBub2RlcyBOT1QgaW4gdGhlIG1hcC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gb25seSBnZXQgdGhlIGRpc3RhbmNlcyB0byBub2RlcyBvdXRzaWRlIG9mIGEgYnJhbmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7Tm9kZS5pZDogdmlzLk5vZGV9fSBtYXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTcGFjZUFyb3VuZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBtYXApIHtcbiAgICAgIHZhciB1c2VNYXAgPSB0cnVlO1xuXG4gICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlTWFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF07XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuICAgICAgICB2YXIgb3JkZXJpbmcgPSB0aGlzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IG9yZGVyaW5nW2luZGV4IC0gMV07XG5cbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtwcmV2Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHByZXZOb2RlKTtcbiAgICAgICAgICAgIG1pblNwYWNlID0gcG9zaXRpb24gLSBwcmV2UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBvcmRlcmluZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROb2RlID0gb3JkZXJpbmdbaW5kZXggKyAxXTtcblxuICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW25leHROb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obmV4dE5vZGUpO1xuICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZSwgbmV4dFBvcyAtIHBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pblNwYWNlLCBtYXhTcGFjZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gY2VudGVyIGEgcGFyZW50IG5vZGUgYW5kIGNoZWNrIGlmIGl0IGRvZXMgbm90IGNyb3NzIG90aGVyIG5vZGVzIHdoZW4gaXQgZG9lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2VudGVyUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jZW50ZXJQYXJlbnQobm9kZSkge1xuICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtub2RlLmlkXSkge1xuICAgICAgICB2YXIgcGFyZW50cyA9IHRoaXMuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtub2RlLmlkXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRfZ2V0U3BhY2VBcm91bmQgPSB0aGlzLl9nZXRTcGFjZUFyb3VuZE5vZGUocGFyZW50Tm9kZSksXG4gICAgICAgICAgICAgICAgX3RoaXMkX2dldFNwYWNlQXJvdW5kMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRTcGFjZUFyb3VuZCwgMiksXG4gICAgICAgICAgICAgICAgbWluU3BhY2UgPSBfdGhpcyRfZ2V0U3BhY2VBcm91bmQyWzBdLFxuICAgICAgICAgICAgICAgIG1heFNwYWNlID0gX3RoaXMkX2dldFNwYWNlQXJvdW5kMlsxXTtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbiAtIG5ld1Bvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAoZGlmZiA8IDAgJiYgTWF0aC5hYnMoZGlmZikgPCBtYXhTcGFjZSAtIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgfHwgZGlmZiA+IDAgJiYgTWF0aC5hYnMoZGlmZikgPCBtaW5TcGFjZSAtIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24ocGFyZW50Tm9kZSwgbmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBsYWNlcyB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcyBiYXNlZCBvbiB0aGUgaGllcmFyY2hpYWwgZGlzdHJpYnV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRpc3RyaWJ1dGlvbiB8IG9idGFpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGlzLl9nZXREaXN0cmlidXRpb24oKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGxhY2VOb2Rlc0J5SGllcmFyY2h5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZU5vZGVzQnlIaWVyYXJjaHkoZGlzdHJpYnV0aW9uKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uZWROb2RlcyA9IHt9OyAvLyBzdGFydCBwbGFjaW5nIGFsbCB0aGUgbGV2ZWwgMCBub2RlcyBmaXJzdC4gVGhlbiByZWN1cnNpdmVseSBwb3NpdGlvbiB0aGVpciBicmFuY2hlcy5cblxuICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGlzdHJpYnV0aW9uLCBsZXZlbCkpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgICAgICAvLyBzb3J0IG5vZGVzIGluIGxldmVsIGJ5IHBvc2l0aW9uOlxuICAgICAgICAgIHZhciBub2RlQXJyYXkgPSBrZXlzJDQoZGlzdHJpYnV0aW9uW2xldmVsXSk7XG5cbiAgICAgICAgICBub2RlQXJyYXkgPSB0aGlzLl9pbmRleEFycmF5VG9Ob2Rlcyhub2RlQXJyYXkpO1xuXG4gICAgICAgICAgc29ydChfY29udGV4dCA9IHRoaXMuZGlyZWN0aW9uKS5jYWxsKF9jb250ZXh0LCBub2RlQXJyYXkpO1xuXG4gICAgICAgICAgdmFyIGhhbmRsZWROb2RlQ291bnQgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZUFycmF5W2ldO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBzcGFjaW5nICogaGFuZGxlZE5vZGVDb3VudDsgLy8gV2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG5cbiAgICAgICAgICAgICAgaWYgKGhhbmRsZWROb2RlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZUFycmF5W2kgLSAxXSkgKyBzcGFjaW5nO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24obm9kZSwgcG9zLCBsZXZlbCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpO1xuXG4gICAgICAgICAgICAgIGhhbmRsZWROb2RlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHJlY3Vyc2l2ZWx5IGNhbGxlZCBmdW5jdGlvbiB0byBlbnVtZXJhdGUgdGhlIGJyYW5jaGVzIGZyb20gdGhlIGxhcmdlc3QgaHVicyBhbmQgcGxhY2UgdGhlIG5vZGVzXG4gICAgICogb24gYSBYIHBvc2l0aW9uIHRoYXQgZW5zdXJlcyB0aGVyZSB3aWxsIGJlIG5vIG92ZXJsYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHBhcmVudElkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmVudExldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUJyYW5jaE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUJyYW5jaE5vZGVzKHBhcmVudElkLCBwYXJlbnRMZXZlbCkge1xuICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgdmFyIGNoaWxkUmVmID0gdGhpcy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdOyAvLyBpZiB0aGlzIGlzIG5vdCBhIHBhcmVudCwgY2FuY2VsIHRoZSBwbGFjaW5nLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCBtdWx0aXBsZSBwYXJlbnRzIHRvIG9uZSBjaGlsZC5cblxuICAgICAgaWYgKGNoaWxkUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBnZXQgYSBsaXN0IG9mIGNoaWxkTm9kZXNcblxuXG4gICAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaCh0aGlzLmJvZHkubm9kZXNbY2hpbGRSZWZbaV1dKTtcbiAgICAgIH0gLy8gdXNlIHRoZSBwb3NpdGlvbnMgdG8gb3JkZXIgdGhlIG5vZGVzLlxuXG5cbiAgICAgIHNvcnQoX2NvbnRleHQyID0gdGhpcy5kaXJlY3Rpb24pLmNhbGwoX2NvbnRleHQyLCBjaGlsZE5vZGVzKTsgLy8gcG9zaXRpb24gdGhlIGNoaWxkTm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBjaGlsZE5vZGVzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbX2k1XTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF07IC8vIGNoZWNrIGlmIHRoZSBjaGlsZCBub2RlIGlzIGJlbG93IHRoZSBwYXJlbnQgbm9kZSBhbmQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwb3NpdGlvbmVkLlxuXG4gICAgICAgIGlmIChjaGlsZE5vZGVMZXZlbCA+IHBhcmVudExldmVsICYmIHRoaXMucG9zaXRpb25lZE5vZGVzW2NoaWxkTm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgYW1vdW50IG9mIHNwYWNlIHJlcXVpcmVkIGZvciB0aGlzIG5vZGUuIElmIHBhcmVudCB0aGUgd2lkdGggaXMgYmFzZWQgb24gdGhlIGFtb3VudCBvZiBjaGlsZHJlbi5cbiAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgdmFyIHBvcyA9IHZvaWQgMDsgLy8gd2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy5cbiAgICAgICAgICAvLyBUaGUgZ2V0IGFuZCBzZXQgbWFrZSBzdXJlIHdlIGdldCBYIG9yIFlcblxuICAgICAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGVzW19pNSAtIDFdKSArIHNwYWNpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24oY2hpbGROb2RlLCBwb3MsIGNoaWxkTm9kZUxldmVsKTtcblxuICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShjaGlsZE5vZGUsIGNoaWxkTm9kZUxldmVsLCBwb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjZW50ZXIgdGhlIHBhcmVudCBub2Rlcy5cblxuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0Q2VudGVyUG9zaXRpb24oY2hpbGROb2Rlcyk7XG5cbiAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0sIGNlbnRlciwgcGFyZW50TGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgZm9yIG92ZXJsYXAgYW5kIGlmIHJlcXVpcmVkIHNoaWZ0cyB0aGUgYnJhbmNoLiBJdCBhbHNvIGtlZXBzIHJlY29yZHMgb2YgcG9zaXRpb25lZCBub2Rlcy5cbiAgICAgKiBGaW5hbGx5IGl0IHdpbGwgY2FsbCBfcGxhY2VCcmFuY2hOb2RlcyB0byBwbGFjZSB0aGUgYnJhbmNoIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcykge1xuICAgICAgLy8gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgZm9ybWFsIHRyZWVzIGFuZCBmb3JtYWwgZm9yZXN0c1xuICAgICAgLy8gRWFybHkgZXhpdCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZVxuICAgICAgaWYgKCF0aGlzLmhpZXJhcmNoaWNhbC5pc1RyZWUpIHJldHVybjsgLy8gaWYgb3ZlcmxhcCBoYXMgYmVlbiBkZXRlY3RlZCwgd2Ugc2hpZnQgdGhlIGJyYW5jaFxuXG4gICAgICBpZiAodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3RoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXV0pO1xuXG4gICAgICAgIGlmIChwb3MgLSBwcmV2aW91c1BvcyA8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IHByZXZpb3VzUG9zICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyAtIHBvcztcblxuICAgICAgICAgIHZhciBzaGFyZWRQYXJlbnQgPSB0aGlzLl9maW5kQ29tbW9uUGFyZW50KHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSwgbm9kZS5pZCk7XG5cbiAgICAgICAgICB0aGlzLl9zaGlmdEJsb2NrKHNoYXJlZFBhcmVudC53aXRoQ2hpbGQsIGRpZmYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSA9IG5vZGUuaWQ7IC8vIHN0b3JlIGNoYW5nZSBpbiBwb3NpdGlvbi5cblxuICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPSB0cnVlO1xuXG4gICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZXMgYW4gYXJyYXkgd2l0aCBub2RlIGluZGljZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAgICAgKiBVc2VkIGZvciBzb3J0aW5nIGJhc2VkIG9uIG5vZGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGUuaWQ+fSBpZEFycmF5XG4gICAgICogQHJldHVybnMge0FycmF5LjxOb2RlPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbmRleEFycmF5VG9Ob2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5kZXhBcnJheVRvTm9kZXMoaWRBcnJheSkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tpZEFycmF5W2ldXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBnZXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiBsZXZlbHMgYmFzZWQgb24gaHVic2l6ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RyaWJ1dGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdHJpYnV0aW9uKCkge1xuICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHt9O1xuICAgICAgdmFyIG5vZGVJZCwgbm9kZTsgLy8gd2UgZml4IFkgYmVjYXVzZSB0aGUgaGllcmFyY2h5IGlzIHZlcnRpY2FsLFxuICAgICAgLy8gd2UgZml4IFggc28gd2UgZG8gbm90IGdpdmUgYSBub2RlIGFuIHggcG9zaXRpb24gZm9yIGEgc2Vjb25kIHRpbWUuXG4gICAgICAvLyB0aGUgZml4IG9mIFggaXMgcmVtb3ZlZCBhZnRlciB0aGUgeCB2YWx1ZSBoYXMgYmVlbiBzZXQuXG5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLmZpeChub2RlLCBsZXZlbCk7XG5cbiAgICAgICAgICBpZiAoZGlzdHJpYnV0aW9uW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdHJpYnV0aW9uW2xldmVsXVtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFjdGl2ZSAoaS5lLiB2aXNpYmxlKSBlZGdlcyBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlPn0gQXJyYXkgb2YgZWRnZSBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFjdGl2ZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBY3RpdmVFZGdlcyhub2RlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yRWFjaCQxKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgaWYgKGluZGV4T2YoX2NvbnRleHQzID0gX3RoaXM0LmJvZHkuZWRnZUluZGljZXMpLmNhbGwoX2NvbnRleHQzLCBlZGdlLmlkKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1YnNpemVzIGZvciBhbGwgYWN0aXZlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEh1YlNpemVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplcygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgaHViU2l6ZXMgPSB7fTtcbiAgICAgIHZhciBub2RlSWRzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgZm9yRWFjaCQxKG5vZGVJZHMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgIHZhciBodWJTaXplID0gX3RoaXM1Ll9nZXRBY3RpdmVFZGdlcyhub2RlKS5sZW5ndGg7XG5cbiAgICAgICAgaHViU2l6ZXNbaHViU2l6ZV0gPSB0cnVlO1xuICAgICAgfSk7IC8vIE1ha2UgYW4gYXJyYXkgb2YgdGhlIHNpemUgc29ydGVkIGRlc2NlbmRpbmdcblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yRWFjaCQxKGh1YlNpemVzLCBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXN1bHQucHVzaChOdW1iZXIoc2l6ZSkpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvcnQodGltc29ydCkuY2FsbCh0aW1zb3J0LCByZXN1bHQsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGFsbG9jYXRlcyBub2RlcyBpbiBsZXZlbHMgYmFzZWQgb24gdGhlIHJlY3Vyc2l2ZSBicmFuY2hpbmcgZnJvbSB0aGUgbGFyZ2VzdCBodWJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgbGV2ZWxEb3duc3RyZWFtID0gZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgICBfdGhpczYuaGllcmFyY2hpY2FsLmxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGh1YlNpemVzID0gdGhpcy5fZ2V0SHViU2l6ZXMoKTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgaHViU2l6ZSA9IGh1YlNpemVzW2ldO1xuICAgICAgICBpZiAoaHViU2l6ZSA9PT0gMCkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgZm9yRWFjaCQxKF90aGlzNi5ib2R5Lm5vZGVJbmRpY2VzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczYuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgICAgaWYgKGh1YlNpemUgPT09IF90aGlzNi5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczYuX2NyYXdsTmV0d29yayhsZXZlbERvd25zdHJlYW0sIG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHViU2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChpKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogcmVsZWFzZSBmZWF0dXJlXG4gICAgICogVE9ETzogRGV0ZXJtaW5lIGlmIHRoaXMgZmVhdHVyZSBpcyBuZWVkZWQgYXQgYWxsXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaygpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgbWluTGV2ZWwgPSAxMDAwMDA7IC8vIFRPRE86IHRoaXMgc2hvdWxkIGNvbWUgZnJvbSBvcHRpb25zLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIFRoaXMgc2hvdWxkIGV2ZW50dWFsbHkgYmUgaW1wbGVtZW50ZWQgd2l0aCB0aGVzZSBwYXJhbWV0ZXJzIHVzZWQuXG5cbiAgICAgIHZhciBjdXN0b21DYWxsYmFjayA9IGZ1bmN0aW9uIGN1c3RvbUNhbGxiYWNrKG5vZGVBLCBub2RlQiwgZWRnZSkge307IC8vIFRPRE86IHBlcmhhcHMgbW92ZSB0byBIaWVyYXJjaGljYWxTdGF0dXMuXG4gICAgICAvLyAgICAgICBCdXQgSSBjdXJyZW50bHkgZG9uJ3Qgc2VlIHRoZSBwb2ludCwgdGhpcyBtZXRob2QgaXMgbm90IHVzZWQuXG5cblxuICAgICAgdmFyIGxldmVsQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBsZXZlbEJ5RGlyZWN0aW9uKG5vZGVBLCBub2RlQiwgZWRnZSkge1xuICAgICAgICB2YXIgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdOyAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuXG4gICAgICAgIGlmIChsZXZlbEEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxldmVsQSA9IF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVBLmlkXSA9IG1pbkxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmYgPSBjdXN0b21DYWxsYmFjayhOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZUEsIFwibm9kZVwiKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGVCLCBcIm5vZGVcIiksIE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhlZGdlLCBcImVkZ2VcIikpO1xuICAgICAgICBfdGhpczcuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQi5pZF0gPSBsZXZlbEEgKyBkaWZmO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGxldmVsQnlEaXJlY3Rpb24pO1xuXG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5zZXRNaW5MZXZlbFRvWmVybyh0aGlzLmJvZHkubm9kZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZSBub2RlcyBpbiBsZXZlbHMgYmFzZWQgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUxldmVsc0RpcmVjdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpIHtcbiAgICAgIHZhciBfY29udGV4dDQsXG4gICAgICAgICAgX3RoaXM4ID0gdGhpcztcblxuICAgICAgdmFyIG5vZGVzID0gcmVkdWNlKF9jb250ZXh0NCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChhY2MsIGlkKSB7XG4gICAgICAgIGFjYy5zZXQoaWQsIF90aGlzOC5ib2R5Lm5vZGVzW2lkXSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBuZXcgbWFwKCkpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zaGFrZVRvd2FyZHMgPT09IFwicm9vdHNcIikge1xuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHMgPSBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25Sb290cyhub2Rlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHMgPSBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25MZWF2ZXMobm9kZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5zZXRNaW5MZXZlbFRvWmVybyh0aGlzLmJvZHkubm9kZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvb2trZWVwaW5nIG9mIHBhcmVudCBhbmQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZU1hcCgpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgZmlsbEluUmVsYXRpb25zID0gZnVuY3Rpb24gZmlsbEluUmVsYXRpb25zKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICAgICAgICBpZiAoX3RoaXM5LmhpZXJhcmNoaWNhbC5sZXZlbHNbY2hpbGROb2RlLmlkXSA+IF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW3BhcmVudE5vZGUuaWRdKSB7XG4gICAgICAgICAgX3RoaXM5LmhpZXJhcmNoaWNhbC5hZGRSZWxhdGlvbihwYXJlbnROb2RlLmlkLCBjaGlsZE5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jcmF3bE5ldHdvcmsoZmlsbEluUmVsYXRpb25zKTtcblxuICAgICAgdGhpcy5oaWVyYXJjaGljYWwuY2hlY2tJZlRyZWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3Jhd2wgb3ZlciB0aGUgZW50aXJlIG5ldHdvcmsgYW5kIHVzZSBhIGNhbGxiYWNrIG9uIGVhY2ggbm9kZSBjb3VwbGUgdGhhdCBpcyBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1mdW5jdGlvbigpe31dICAgICAgICAgIHwgd2lsbCByZWNlaXZlIG5vZGVBLCBub2RlQiBhbmQgdGhlIGNvbm5lY3RpbmcgZWRnZS4gQSBhbmQgQiBhcmUgZGlzdGluY3QuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBzdGFydGluZ05vZGVJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3Jhd2xOZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmF3bE5ldHdvcmsoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuXG4gICAgICB2YXIgY3Jhd2xlciA9IGZ1bmN0aW9uIGNyYXdsZXIobm9kZSwgdHJlZSkge1xuICAgICAgICBpZiAocHJvZ3Jlc3Nbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMTAuaGllcmFyY2hpY2FsLnNldFRyZWVJbmRleChub2RlLCB0cmVlKTtcblxuICAgICAgICAgIHByb2dyZXNzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlO1xuXG4gICAgICAgICAgdmFyIGVkZ2VzID0gX3RoaXMxMC5fZ2V0QWN0aXZlRWRnZXMobm9kZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICc9PT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS5mcm9tO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPSBjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJyE9PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBjaGlsZE5vZGUsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHN0YXJ0aW5nTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ3Jhd2wgb3ZlciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIHRyZWVJbmRleCA9IDA7IC8vIFNlcnZlcyB0byBwYXNzIGEgdW5pcXVlIGlkIGZvciB0aGUgY3VycmVudCBkaXN0aW5jdCB0cmVlXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGNyYXdsZXIobm9kZSwgdHJlZUluZGV4KTtcbiAgICAgICAgICAgIHRyZWVJbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3Jhd2wgZnJvbSB0aGUgZ2l2ZW4gc3RhcnRpbmcgbm9kZVxuICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcblxuICAgICAgICBpZiAoX25vZGUyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBub3QgZm91bmQ6XCIsIHN0YXJ0aW5nTm9kZUlkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjcmF3bGVyKF9ub2RlMik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNoaWZ0IGEgYnJhbmNoIGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaGlmdEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdEJsb2NrKHBhcmVudElkLCBkaWZmKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuXG4gICAgICB2YXIgc2hpZnRlciA9IGZ1bmN0aW9uIHNoaWZ0ZXIocGFyZW50SWQpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzW3BhcmVudElkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzW3BhcmVudElkXSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMxMS5kaXJlY3Rpb24uc2hpZnQocGFyZW50SWQsIGRpZmYpO1xuXG4gICAgICAgIHZhciBjaGlsZFJlZiA9IF90aGlzMTEuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcblxuICAgICAgICBpZiAoY2hpbGRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNoaWZ0ZXIoY2hpbGRSZWZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2hpZnRlcihwYXJlbnRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBjb21tb24gcGFyZW50IGJldHdlZW4gYnJhbmNoZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkQVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGRCXG4gICAgICogQHJldHVybnMge3tmb3VuZFBhcmVudCwgd2l0aENoaWxkfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRDb21tb25QYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRDb21tb25QYXJlbnQoY2hpbGRBLCBjaGlsZEIpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIHBhcmVudHMgPSB7fTtcblxuICAgICAgdmFyIGl0ZXJhdGVQYXJlbnRzID0gZnVuY3Rpb24gaXRlcmF0ZVBhcmVudHMocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IF90aGlzMTIuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtjaGlsZF07XG5cbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG4gICAgICAgICAgICBwYXJlbnRzW3BhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBmaW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcblxuICAgICAgICBpZiAocGFyZW50UmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFJlZltpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm91bmRQYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgICB3aXRoQ2hpbGQ6IGNoaWxkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG5cbiAgICAgICAgICAgIGlmIChicmFuY2guZm91bmRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kUGFyZW50OiBudWxsLFxuICAgICAgICAgIHdpdGhDaGlsZDogY2hpbGRcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIGNoaWxkQSk7XG4gICAgICByZXR1cm4gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZEIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0cmF0ZWd5IHBhdHRlcm4gZm9yIGhhbmRsaW5nIHRoZSBjb29yZGluYXRlcyBnaXZlbiB0aGUgY3VycmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaW5kaXZpZHVhbCBpbnN0YW5jZXMgY29udGFpbiBhbGwgdGhlIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3BlY2lmaWMgdG8gYSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90VXBkYXRlPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREaXJlY3Rpb25TdHJhdGVneVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXJlY3Rpb25TdHJhdGVneSgpIHtcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiVURcIiB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJEVVwiO1xuXG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBWZXJ0aWNhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgSG9yaXpvbnRhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiBhIGJyYW5jaCBmcm9tIHRoZSBwYXNzZWQgbGlzdCBvZiBjaGlsZCBub2Rlc1xuICAgICAqXG4gICAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHBvc2l0aW9ucyBvZiBhbGwgdGhlIGNoaWxkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZXx2aXMuTm9kZS5pZD59IGNoaWxkTm9kZXMgIEFycmF5IG9mIGVpdGhlciBjaGlsZCBub2RlcyBvciBub2RlIGlkJ3NcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2VudGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpIHtcbiAgICAgIHZhciBtaW5Qb3MgPSAxZTk7XG4gICAgICB2YXIgbWF4UG9zID0gLTFlOTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaV0uaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBjaGlsZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oY2hpbGROb2RlKTtcbiAgICAgICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBwb3NpdGlvbik7XG4gICAgICAgIG1heFBvcyA9IE1hdGgubWF4KG1heFBvcywgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMC41ICogKG1pblBvcyArIG1heFBvcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheW91dEVuZ2luZTtcbn0oKTtcblxudmFyIGNzc18yNDh6ID0gXCJkaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24ge1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuXFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBib3JkZXItYm90dG9tOiAxcHg7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLWNvbG9yOiAjZDZkOWQ4O1xcbiAgYmFja2dyb3VuZDogI2ZmZmZmZjsgLyogT2xkIGJyb3dzZXJzICovXFxuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZmZmZmZmIDAlLFxcbiAgICAjZmNmY2ZjIDQ4JSxcXG4gICAgI2ZhZmFmYSA1MCUsXFxuICAgICNmY2ZjZmMgMTAwJVxcbiAgKTsgLyogRkYzLjYrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcbiAgICBsaW5lYXIsXFxuICAgIGxlZnQgdG9wLFxcbiAgICBsZWZ0IGJvdHRvbSxcXG4gICAgY29sb3Itc3RvcCgwJSwgI2ZmZmZmZiksXFxuICAgIGNvbG9yLXN0b3AoNDglLCAjZmNmY2ZjKSxcXG4gICAgY29sb3Itc3RvcCg1MCUsICNmYWZhZmEpLFxcbiAgICBjb2xvci1zdG9wKDEwMCUsICNmY2ZjZmMpXFxuICApOyAvKiBDaHJvbWUsU2FmYXJpNCsgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNmZmZmZmYgMCUsXFxuICAgICNmY2ZjZmMgNDglLFxcbiAgICAjZmFmYWZhIDUwJSxcXG4gICAgI2ZjZmNmYyAxMDAlXFxuICApOyAvKiBDaHJvbWUxMCssU2FmYXJpNS4xKyAqL1xcbiAgYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNmZmZmZmYgMCUsXFxuICAgICNmY2ZjZmMgNDglLFxcbiAgICAjZmFmYWZhIDUwJSxcXG4gICAgI2ZjZmNmYyAxMDAlXFxuICApOyAvKiBPcGVyYSAxMS4xMCsgKi9cXG4gIGJhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2ZmZmZmZiAwJSxcXG4gICAgI2ZjZmNmYyA0OCUsXFxuICAgICNmYWZhZmEgNTAlLFxcbiAgICAjZmNmY2ZjIDEwMCVcXG4gICk7IC8qIElFMTArICovXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxuICAgIHRvIGJvdHRvbSxcXG4gICAgI2ZmZmZmZiAwJSxcXG4gICAgI2ZjZmNmYyA0OCUsXFxuICAgICNmYWZhZmEgNTAlLFxcbiAgICAjZmNmY2ZjIDEwMCVcXG4gICk7IC8qIFczQyAqL1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoIHN0YXJ0Q29sb3JzdHI9JyNmZmZmZmYnLCBlbmRDb2xvcnN0cj0nI2ZjZmNmYycsR3JhZGllbnRUeXBlPTAgKTsgLyogSUU2LTkgKi9cXG5cXG4gIHBhZGRpbmctdG9wOiA0cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDI4cHg7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLWVkaXQtbW9kZSxcXG5kaXYudmlzLW5ldHdvcmsgYnV0dG9uLnZpcy1lZGl0LW1vZGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogNXB4O1xcbiAgaGVpZ2h0OiAzMHB4O1xcbn1cXG5cXG4vKiBGSVhNRTogc2hvdWxkbid0IHRoZSB2aXMtY2xvc2UgYnV0dG9uIGJlIGEgY2hpbGQgb2YgdGhlIHZpcy1tYW5pcHVsYXRpb24gZGl2PyAqL1xcblxcbmRpdi52aXMtbmV0d29yayBidXR0b24udmlzLWNsb3NlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDMwcHg7XFxuICBoZWlnaHQ6IDMwcHg7XFxuXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDIwcHggM3B4O1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBY0FBQUFIQ0FZQUFBREVVbGZUQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUR2R2FWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGdvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWlCNE9uaHRjSFJyUFNKQlpHOWlaU0JZVFZBZ1EyOXlaU0ExTGpVdFl6QXlNU0EzT1M0eE5UUTVNVEVzSURJd01UTXZNVEF2TWprdE1URTZORGM2TVRZZ0lDQWdJQ0FnSUNJK0NpQWdJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrQ2lBZ0lDQWdJRHh5WkdZNlJHVnpZM0pwY0hScGIyNGdjbVJtT21GaWIzVjBQU0lpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZUcxd1RVMDlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl0YlM4aUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uTjBSWFowUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdmMxUjVjR1V2VW1WemIzVnlZMlZGZG1WdWRDTWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVJqUFNKb2RIUndPaTh2Y0hWeWJDNXZjbWN2WkdNdlpXeGxiV1Z1ZEhNdk1TNHhMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02Y0dodmRHOXphRzl3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzQm9iM1J2YzJodmNDOHhMakF2SWdvZ0lDQWdJQ0FnSUNBZ0lDQjRiV3h1Y3pwMGFXWm1QU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNScFptWXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpYaHBaajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5bGVHbG1MekV1TUM4aVBnb2dJQ0FnSUNBZ0lDQThlRzF3T2tOeVpXRjBiM0pVYjI5c1BrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM2h0Y0RwRGNtVmhkRzl5Vkc5dmJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwRGNtVmhkR1ZFWVhSbFBqSXdNVFF0TURJdE1UUlVNVEU2TlRVNk16VXJNREU2TURBOEwzaHRjRHBEY21WaGRHVkVZWFJsUGdvZ0lDQWdJQ0FnSUNBOGVHMXdPazFsZEdGa1lYUmhSR0YwWlQ0eU1ERTBMVEF5TFRFMFZERXlPakExT2pFM0t6QXhPakF3UEM5NGJYQTZUV1YwWVdSaGRHRkVZWFJsUGdvZ0lDQWdJQ0FnSUNBOGVHMXdPazF2WkdsbWVVUmhkR1UrTWpBeE5DMHdNaTB4TkZReE1qb3dOVG94Tnlzd01Ub3dNRHd2ZUcxd09rMXZaR2xtZVVSaGRHVStDaUFnSUNBZ0lDQWdJRHg0YlhCTlRUcEpibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZOalUwWW1NNVltUXRNV0kyWWkxallqUmhMVGxsT1dRdE5XWTJNemd4TkRWalpqazBQQzk0YlhCTlRUcEpibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPams0TW1NMk1HSXdMV1V6WmpNdE1EazBNQzA0TWpVMExURmlaVGxpTldFMFpURTRNend2ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPams0TW1NMk1HSXdMV1V6WmpNdE1EazBNQzA0TWpVMExURmlaVGxpTldFMFpURTRNend2ZUcxd1RVMDZUM0pwWjJsdVlXeEViMk4xYldWdWRFbEVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZTR2x6ZEc5eWVUNEtJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcFRaWEUrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG1OeVpXRjBaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tbHVjM1JoYm1ObFNVUStlRzF3TG1scFpEbzVPREpqTmpCaU1DMWxNMll6TFRBNU5EQXRPREkxTkMweFltVTVZalZoTkdVeE9ETThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREl0TVRSVU1URTZOVFU2TXpVck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1ellYWmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qSXhPRFl4Tm1NMkxUTTFNV010TkRJME9TMDRZV0ZrTFdKa1pEUTJaVGN6TldFME5Ed3ZjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uZG9aVzQrTWpBeE5DMHdNaTB4TkZReE1UbzFOVG96TlNzd01Ub3dNRHd2YzNSRmRuUTZkMmhsYmo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21Ob1lXNW5aV1ErTHp3dmMzUkZkblE2WTJoaGJtZGxaRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbk5oZG1Wa1BDOXpkRVYyZERwaFkzUnBiMjQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBwYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2TmpVMFltTTVZbVF0TVdJMllpMWpZalJoTFRsbE9XUXROV1kyTXpneE5EVmpaamswUEM5emRFVjJkRHBwYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2ZDJobGJqNHlNREUwTFRBeUxURTBWREV5T2pBMU9qRTNLekF4T2pBd1BDOXpkRVYyZERwM2FHVnVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTBNZ0tGZHBibVJ2ZDNNcFBDOXpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZMmhoYm1kbFpENHZQQzl6ZEVWMmREcGphR0Z1WjJWa1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzSmtaanBzYVQ0S0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNlUyVnhQZ29nSUNBZ0lDQWdJQ0E4TDNodGNFMU5Pa2hwYzNSdmNuaytDaUFnSUNBZ0lDQWdJRHhrWXpwbWIzSnRZWFErYVcxaFoyVXZjRzVuUEM5a1l6cG1iM0p0WVhRK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQak04TDNCb2IzUnZjMmh2Y0RwRGIyeHZjazF2WkdVK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDV6VWtkQ0lFbEZRell4T1RZMkxUSXVNVHd2Y0dodmRHOXphRzl3T2tsRFExQnliMlpwYkdVK0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2s5eWFXVnVkR0YwYVc5dVBqRThMM1JwWm1ZNlQzSnBaVzUwWVhScGIyNCtDaUFnSUNBZ0lDQWdJRHgwYVdabU9saFNaWE52YkhWMGFXOXVQamN5TURBd01DOHhNREF3TUR3dmRHbG1aanBZVW1WemIyeDFkR2x2Ymo0S0lDQWdJQ0FnSUNBZ1BIUnBabVk2V1ZKbGMyOXNkWFJwYjI0K056SXdNREF3THpFd01EQXdQQzkwYVdabU9sbFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFNaWE52YkhWMGFXOXVWVzVwZEQ0eVBDOTBhV1ptT2xKbGMyOXNkWFJwYjI1VmJtbDBQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcERiMnh2Y2xOd1lXTmxQakU4TDJWNGFXWTZRMjlzYjNKVGNHRmpaVDRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBqYzhMMlY0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBRYVhobGJGbEVhVzFsYm5OcGIyNCtOend2WlhocFpqcFFhWGhsYkZsRWFXMWxibk5wYjI0K0NpQWdJQ0FnSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGdvZ0lDQThMM0prWmpwU1JFWStDand2ZURwNGJYQnRaWFJoUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW84UDNod1lXTnJaWFFnWlc1a1BTSjNJajgrY1pVWk13QUFBQ0JqU0ZKTkFBQjZKUUFBZ0lNQUFQbi9BQUNBNlFBQWRUQUFBT3BnQUFBNm1BQUFGMitTWDhWR0FBQUEyRWxFUVZSNDJnRExBRFQvQVMwdExVUUZCUVVWRnhjWHRQSHg4ZlBsNWVVTkNBZ0lUQ2twS2VzRUh4OGZHZ1lHQmpIKy92NGErUGo0cWdRRUJGVTZPam9kTVRFeHp3UVVGQlN2RUJBUUVmWDE5U0QxOWZWcU5EUTBDRWxKU2QvOS9mMnZBd0VCQWZybjUrZmtCd2NITFJZV0Znc1hGeGZ6Mjl2Ym85TFMwdXdERFEwTkRmUHo4MW9yS3lzWEl5TWorT0RnNEF2aDRlRWEvZjM5MWdNa0pDUllQejgvS1VoSVNPTUNBZ0toOGZIeEhSc2JHeDRVRkJRUUJEazVPZVk3T3p2N0NBZ0l0UGIyOXZNRUJBU2FKU1VsVFEwTkRlc0RBRXdwVDBLbzhSaTJBQUFBQUVsRlRrU3VRbUNDJyk7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgYnV0dG9uLnZpcy1jbG9zZTpob3ZlciB7XFxuICBvcGFjaXR5OiAwLjY7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbixcXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1lZGl0LW1vZGUgYnV0dG9uLnZpcy1idXR0b24ge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBmb250LWZhbWlseTogdmVyZGFuYTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMHB4IDBweDtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBoZWlnaHQ6IDI0cHg7XFxuICBtYXJnaW4tbGVmdDogMTBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBhZGRpbmc6IDBweCA4cHggMHB4IDhweDtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbjpob3ZlciB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbjphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCA4cHggcmdiYSgwLCAwLCAwLCAwLjUpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b24udmlzLWJhY2sge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJnQUFBQVlDQVlBQUFEZ2R6MzRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBRUVPYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZ284ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMalV0WXpBeU1TQTNPUzR4TlRRNU1URXNJREl3TVRNdk1UQXZNamt0TVRFNk5EYzZNVFlnSUNBZ0lDQWdJQ0krQ2lBZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SStDaUFnSUNBZ0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbmh0Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZaR005SW1oMGRIQTZMeTl3ZFhKc0xtOXlaeTlrWXk5bGJHVnRaVzUwY3k4eExqRXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUkZkblE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVVYyWlc1MEl5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbkJvYjNSdmMyaHZjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5d2FHOTBiM05vYjNBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZEdsbVpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzkwYVdabUx6RXVNQzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T21WNGFXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2WlhocFppOHhMakF2SWo0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBEY21WaGRHOXlWRzl2YkQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTBNZ0tGZHBibVJ2ZDNNcFBDOTRiWEE2UTNKbFlYUnZjbFJ2YjJ3K0NpQWdJQ0FnSUNBZ0lEeDRiWEE2UTNKbFlYUmxSR0YwWlQ0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5NGJYQTZRM0psWVhSbFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5aWFJoWkdGMFlVUmhkR1UrTWpBeE5DMHdNaTB3TkZReE5Ub3dNVG93T1Nzd01Ub3dNRHd2ZUcxd09rMWxkR0ZrWVhSaFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5iMlJwWm5sRVlYUmxQakl3TVRRdE1ESXRNRFJVTVRVNk1ERTZNRGtyTURFNk1EQThMM2h0Y0RwTmIyUnBabmxFWVhSbFBnb2dJQ0FnSUNBZ0lDQThaR002Wm05eWJXRjBQbWx0WVdkbEwzQnVaend2WkdNNlptOXliV0YwUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2U1c1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT21JMllqUXdNalZrTFRBeE5qUXRNelUwT0MxaE9UZGxMVFE0Wm1ZeE1XTTNOVFl6TXp3dmVHMXdUVTA2U1c1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2tSdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOTRiWEJOVFRwUGNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtZM0psWVhSbFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBuTmhkbVZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZSVUUyTUVFeU5FVXhPVGcwUlRNeE1VRkVRVVpGUmtVMlJVTXpNek5GTURNOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ERXRNak5VTVRrNk1UZzZNRGNyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFV6WWdLRmRwYm1SdmQzTXBQQzl6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WTJoaGJtZGxaRDR2UEM5emRFVjJkRHBqYUdGdVoyVmtQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMM0prWmpwc2FUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtjMkYyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbWx1YzNSaGJtTmxTVVErZUcxd0xtbHBaRHBtT1dRM09HWTRaQzFsTnpZMExUYzFORGd0T0RaaU55MWlObVExT0dNelpEZzJPVGM4TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURJdE1EUlVNVFU2TURFNk1Ea3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzTjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGphR0Z1WjJWa1BpODhMM04wUlhaME9tTm9ZVzVuWldRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1amIyNTJaWEowWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWm5KdmJTQmhjSEJzYVdOaGRHbHZiaTkyYm1RdVlXUnZZbVV1Y0dodmRHOXphRzl3SUhSdklHbHRZV2RsTDNCdVp6d3ZjM1JGZG5RNmNHRnlZVzFsZEdWeWN6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBtUmxjbWwyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWTI5dWRtVnlkR1ZrSUdaeWIyMGdZWEJ3YkdsallYUnBiMjR2ZG01a0xtRmtiMkpsTG5Cb2IzUnZjMmh2Y0NCMGJ5QnBiV0ZuWlM5d2JtYzhMM04wUlhaME9uQmhjbUZ0WlhSbGNuTStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNXpZWFpsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPbUkyWWpRd01qVmtMVEF4TmpRdE16VTBPQzFoT1RkbExUUTRabVl4TVdNM05UWXpNend2YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbmRvWlc0K01qQXhOQzB3TWkwd05GUXhOVG93TVRvd09Tc3dNVG93TUR3dmMzUkZkblE2ZDJobGJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblErUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tTm9ZVzVuWldRK0x6d3ZjM1JGZG5RNlkyaGhibWRsWkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdQQzk0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPbVk1WkRjNFpqaGtMV1UzTmpRdE56VTBPQzA0Tm1JM0xXSTJaRFU0WXpOa09EWTVOend2YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT21SdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2YzNSU1pXWTZaRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT205eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEZKbFpqcHZjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHd2ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjArQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBqTThMM0JvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUNXpVa2RDSUVsRlF6WXhPVFkyTFRJdU1Ud3ZjR2h2ZEc5emFHOXdPa2xEUTFCeWIyWnBiR1UrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGpFOEwzUnBabVk2VDNKcFpXNTBZWFJwYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lNREE1TUM4eE1EQXdNRHd2ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajRLSUNBZ0lDQWdJQ0FnUEhScFptWTZXVkpsYzI5c2RYUnBiMjQrTnpJd01Ea3dMekV3TURBd1BDOTBhV1ptT2xsU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwU1pYTnZiSFYwYVc5dVZXNXBkRDR5UEM5MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwRGIyeHZjbE53WVdObFBqRThMMlY0YVdZNlEyOXNiM0pUY0dGalpUNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WlJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV1VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrQ2lBZ0lEd3ZjbVJtT2xKRVJqNEtQQzk0T25odGNHMWxkR0UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDancvZUhCaFkydGxkQ0JsYm1ROUluY2lQejRqcTFVL0FBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBVlRTVVJCVkhqYW5GVmZURk5uRlArZDc3dmU4cWVWRmJCcnBjVmdSckNSRmlrRkJ5THh3U0FhRTMyb1JDSEQ2Sk14eGhobjhHMlJ4eEgzTXNPVGJ5WXNtQ0F4UE1tTU1ZdGtJVVltSzYwT08wcUFLMjNCRmxOb2IwdWgzeDdXUzVqTFpQcExibTYray9QOXpybTV2OTg1NVBGNFVGaFlDQUJnaklFeEJnQWdJcVJTcVJJaTZnRFFSa1ExUkdUQjN3Z1IwZThBSGdINFNhL1hSL0VCaUFpSlJBSjA0Y0lGNU9mbmc0ZzJuMGdrVWt4RU53RjBjODQzTHpIR1FFUVFRa0NMRXhFQTlBTG90VmdzVVFBUVFtZ05RaEpDYkY1a2pDRVVDbDBtb2o0dDVuYTdmVFUxTlVwVlZWWFVZckVrQVNBY0RoZThlZk9teE9meldTY21KcW9CZEJOUjk5TFMwaFd6MmR5bk5TU0VBRjI4ZUJHRmhZVmdqQ0VjRG45SFJEMUVoSU1IRDNvOUhzOWtXVmxaQWg5QktCUXFHQjRlZHI1OCtkS1orNkpiSnBPcEJ3QldWMWZCNitycUlNc3lJcEhJRmNaWUwyTU1yYTJ0WTVjdVhScmZ1WE5uQnR2QVlEQmszRzYzb3FwcVptNXV6Z3JnU0RLWmpCb01odWVaVEFiYzVYSWhGb3VWRXRGVHhoaU9IVHMyZHY3OGVTOCtFZnYzNzQrb3FwcVpuWjIxY3M1UEpKUEpQbG1Xa3l5bm5CdU1NVFEwTkhpN3VybyttVnlEeCtQeHVsd3U3MVpPbGtxbFNvbm9KaEdodmIzOXM4azFuRHg1MHNzNWh5UkpOOVBwZEtsRVJCMmFXalNWYUVpbFV2ekJnd2NPUlZFczVlWGxvWFBuemsxc1Y4QmtNaVVkRG9mUDcvZFhaN1BaRGlsbklodzRjR0JlUzFwYlcyUDM3dDF6QndLQmlrUWlVVVJFV0ZoWXNISE8wZDdldm0wUnU5MCsvK3JWcTJyTytYR0ppSnhFaE1yS3loZ0FqSTZPV29lSGg1dFdWbGErNEp6RFpyTzliVzV1bmh3Y0hHenorLzMybnA0ZSt4YURiZm9IQU14bWM2aWpvMk8wb3FJaUpra1NOalkySEJJUm1SbGpNSnZOeVdmUG5sbjcrL3RQTU1aUVhsNiswTmJXOXFLMnRqWWNqOGZsb2FFaHFLcHErSENrYkQzUHpNd1lCZ1lHME5YVjlVdXVzRm5hMmtFZ0VMQVFFUTRkT3ZTaXM3UHpONDFBcjlkbnJsMjdOcUNOa3YvQzNidDN6eTR0TFZtSUNKeHpFQkZKUkJRbW9yTEZ4Y1dDcXFxcTBQajRlTzNZMkpoYlVaVGRyYTJ0TDJwcmE4T0pSR0xIblR0M3prcVM5SytodUhVNEVoSE1abk1vR28wVzVPSWg3bks1ampMR0txMVc2OXZEaHc4clJxTXhNamMzdDJ0NWVYblg1T1JrbGMvbk0rZmw1U1ducHFhKzB1djFLL241K1dzNm5XNU5sdVhOZDE1ZTNwcE9wMXV6Mld5elo4NmNHUTBHZzZaQUlGQ1p6V1ovbFlqb2tSRGl1Ti92dDdXMHRNdzNOVFVwYnJkNzhQNzkrKzVnTUZnUmlVVEtIajU4V01ZWVEzVjE5ZXRUcDA1dHE2THA2V2tiNXh4Q2lFZmM3WFpQTThhNkZ4Y1hUZlgxOWEvMWVuMkdjeTVxYW1yZU5qWTIvcUdxNmpvUlplMTIrOVRwMDZlM0pZL0ZZZ1dQSHo4K21odnIzL0NXbHBiayt2cDZQbU9zZVdWbEJTNlhTOUdTSlVrU2RyczkzTkRROE9lK2ZmdkMvOGZKSXlNamRkRm85RXNpNnBWbGVWalQybTBBOEhxOXpxR2hJZWZuam9rblQ1NDRBNEdBTS9lRGJ4TVJlRk5URTBwS1NwS3Fxc2FJNlBqOC9MeFZWZFdNM1c2UGZDcjV4TVRFMXpsbFhTMHVMbjZhU3FYQUd4c2JvZFBwb05mcm42dXFDczc1RVVWUnJKRklaTWZldlhzWGRUcmR4c2VJRTRtRVBESXlVdS8zKyt0eW5kOHlHbzI5UklSME9nMjZmdjA2aW9xS3dCZ0Q1eHp2M3IyN3pCanJJeUpJa2dTSHd6RlpXVm1wN05tekoxWmFXcG9BZ0dnMFdxZ29TdkhNekl3MUdBdzZ0dmpoaXRGbzdOUFc1ZnYzNzBIZDNkMG9LQ2dBNTN6VFFNdkx5K1ZDaUt1U0pIMHJTZExtenRaeXRJV3Y1UlBSRDBUMFkzRng4ZHpXZmJ5NnVnb3BIby8vdzRtY2M4aXlQTWM1djVGT3A3L1Back9kUW9oV0luSUMyQzJFZ0JCaWdZaThRb2lmczlsc3YwNm5XeUlpYUZ4YWdYZzhqcjhHQUd4dUllN0xCZVdoQUFBQUFFbEZUa1N1UW1DQycpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gZGl2LnZpcy1ub25lOmhvdmVyIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggOHB4IHJnYmEoMCwgMCwgMCwgMCk7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBkaXYudmlzLW5vbmU6YWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggOHB4IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBkaXYudmlzLW5vbmUge1xcbiAgcGFkZGluZzogMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDIzcHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBkaXYubm90aWZpY2F0aW9uIHtcXG4gIG1hcmdpbjogMnB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbi52aXMtYWRkIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCZ0FBQUFZQ0FZQUFBRGdkejM0QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUVFT2FWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGdvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWlCNE9uaHRjSFJyUFNKQlpHOWlaU0JZVFZBZ1EyOXlaU0ExTGpVdFl6QXlNU0EzT1M0eE5UUTVNVEVzSURJd01UTXZNVEF2TWprdE1URTZORGM2TVRZZ0lDQWdJQ0FnSUNJK0NpQWdJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrQ2lBZ0lDQWdJRHh5WkdZNlJHVnpZM0pwY0hScGIyNGdjbVJtT21GaWIzVjBQU0lpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWdvZ0lDQWdJQ0FnSUNBZ0lDQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25Cb2IzUnZjMmh2Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOXdhRzkwYjNOb2IzQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9tVjRhV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdlpYaHBaaTh4TGpBdklqNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwRGNtVmhkRzl5Vkc5dmJENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1EwTWdLRmRwYm1SdmQzTXBQQzk0YlhBNlEzSmxZWFJ2Y2xSdmIydytDaUFnSUNBZ0lDQWdJRHg0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOTRiWEE2UTNKbFlYUmxSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOWlhSaFpHRjBZVVJoZEdVK01qQXhOQzB3TWkwd05GUXhORG8wTURveU9Tc3dNVG93TUR3dmVHMXdPazFsZEdGa1lYUmhSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOYjJScFpubEVZWFJsUGpJd01UUXRNREl0TURSVU1UUTZOREE2TWprck1ERTZNREE4TDNodGNEcE5iMlJwWm5sRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4WkdNNlptOXliV0YwUG1sdFlXZGxMM0J1Wnp3dlpHTTZabTl5YldGMFBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qVmtOV0l3Tm1Rd0xUVm1NakF0T0dFME5DMWhNekl3TFdabU1URXpNelF3TkRjMFlqd3ZlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmVHMXdUVTA2Ukc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2s5eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzk0YlhCTlRUcFBjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHg0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrWTNKbFlYUmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRFVjJkRHBwYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2ZDJobGJqNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOXpkRVYyZERwM2FHVnVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMklDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbk5oZG1Wa1BDOXpkRVYyZERwaFkzUnBiMjQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBwYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2UlVFMk1FRXlORVV4T1RnMFJUTXhNVUZFUVVaRlJrVTJSVU16TXpORk1ETThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREV0TWpOVU1UazZNVGc2TURjck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRVellnS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrYzJGMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRvMk9XVm1ZV0UxTlMwMVpUSTVMVEl6TkdVdFlUVXpNeTB4TkRreFlqTTFORE5tWW1FOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ESXRNRFJVTVRRNk5EQTZNamtyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBqYUdGdVoyVmtQaTg4TDNOMFJYWjBPbU5vWVc1blpXUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNWpiMjUyWlhKMFpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1puSnZiU0JoY0hCc2FXTmhkR2x2Ymk5MmJtUXVZV1J2WW1VdWNHaHZkRzl6YUc5d0lIUnZJR2x0WVdkbEwzQnVaend2YzNSRmRuUTZjR0Z5WVcxbGRHVnljejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbVJsY21sMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1kyOXVkbVZ5ZEdWa0lHWnliMjBnWVhCd2JHbGpZWFJwYjI0dmRtNWtMbUZrYjJKbExuQm9iM1J2YzJodmNDQjBieUJwYldGblpTOXdibWM4TDNOMFJYWjBPbkJoY21GdFpYUmxjbk0rQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pWa05XSXdObVF3TFRWbU1qQXRPR0UwTkMxaE16SXdMV1ptTVRFek16UXdORGMwWWp3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TkMwd01pMHdORlF4TkRvME1Eb3lPU3N3TVRvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbU5vWVc1blpXUStMend2YzNSRmRuUTZZMmhoYm1kbFpENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnUEM5NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOGMzUlNaV1k2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pZNVpXWmhZVFUxTFRWbE1qa3RNak0wWlMxaE5UTXpMVEUwT1RGaU16VTBNMlppWVR3dmMzUlNaV1k2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmMzUlNaV1k2Wkc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRGSmxaanB2Y21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR3dmVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQak04TDNCb2IzUnZjMmh2Y0RwRGIyeHZjazF2WkdVK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDV6VWtkQ0lFbEZRell4T1RZMkxUSXVNVHd2Y0dodmRHOXphRzl3T2tsRFExQnliMlpwYkdVK0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2s5eWFXVnVkR0YwYVc5dVBqRThMM1JwWm1ZNlQzSnBaVzUwWVhScGIyNCtDaUFnSUNBZ0lDQWdJRHgwYVdabU9saFNaWE52YkhWMGFXOXVQamN5TURBNU1DOHhNREF3TUR3dmRHbG1aanBZVW1WemIyeDFkR2x2Ymo0S0lDQWdJQ0FnSUNBZ1BIUnBabVk2V1ZKbGMyOXNkWFJwYjI0K056SXdNRGt3THpFd01EQXdQQzkwYVdabU9sbFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFNaWE52YkhWMGFXOXVWVzVwZEQ0eVBDOTBhV1ptT2xKbGMyOXNkWFJwYjI1VmJtbDBQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcERiMnh2Y2xOd1lXTmxQakU4TDJWNGFXWTZRMjlzYjNKVGNHRmpaVDRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV0VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFpSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQWdJRHd2Y21SbU9sSkVSajRLUEM5NE9uaHRjRzFsZEdFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2p3L2VIQmhZMnRsZENCbGJtUTlJbmNpUHo1V0txcDlBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQVlYU1VSQlZIamFmRlp0VUZUWEdYN2U5ejI3c3ZldU1Dd1lWOEVsckE3WVNGWUh0SlVQa2FhSTBhUnFHOHdQMDB6VXpsakRJTk5TQS8yUk90cE8yNFN4bmFobHhqWWQ3U1NqbVVreW1jeFlsRGhRUHpIR2lzRVZwOEh3WVdDVlZWZ0VzcnN1TG5MNzQrNXVxVEY5Wis3Y08vZDhQTzk1enZPODUxQmxaU1YwWFFjQU1ET1lHUUJBUkRoWDNKUm1NRFlad0xQTVdBekdIQUNZSWd3UzQ2b0JOQk53dE9MOEN3RThFa1NFVUNnRTJySmxDMncyRzRnbzhad28vYk1EZ25vRzZneExmQUFBWXZQRE1DQ3N6S1RBTUlBR0FoclduZjE1QUFBTXd3QVJJUktKZ0RadjNneTczUTRpQWpQanhJcjlWVk9NUmhiQVlLQjh6dnJPMGxscmZFc2RLd0xaZWs2WUFQU0Z2dFN1M0d0TGF3dTBaSjY2MjVTSEdCUUIxVDg4dDZNeHZvcGdNQWphdW5VcmRGMEhNK1A0eXYyN0RNWWVKbUIxUnFXM0puZjN0UVgycDBMNFA5RVh1cUVkN1BtRHArWHVNVTlzUmJ2WG5udDFUeHhBQ2dvS1lMVmFjYnpzUURVSkdrU0FUZTZxaTI4dVB0enVzTTZLeGllNk5ITEdVWDNseFZVTlg5U3RQSG5uNHd5M25qdVVZY3U2bjJwTmk2NmF2Y0VYbkJ5UC9udjhhaWFJeXJxejJnTzVBOSs5RkkxR0lmbjUrV2haZFRBZGpGTWt3TXZaT3k3dVduVEFPejNMNFlrNzFtM3Q2OWZkZlREb1VHVEJlSFRVZmlIUTZsbzdaMk9YSnZwREFDaEtlK2FPQ2RLUktXeFoyKzFxYjN5eWQzR1ltUmtRN0dRQlZzOTl3ZnY2b24zZVIyazRQZFRrREViSDdJdVM4L3N2bGQvNTYxUEpTL3BEazEvYnp3eDk0cHplN3hjNXYvSCtZUFk2cjVCQWtkckp6T0RUSzQ2bEU2UGVZRUp0N3UrOGorT1p3Q0JpRUFnQW9OZ0tKb0VRZjZQdk52ZHJYZ3Rab05oU2Y3cTBLWjNCMkFRbVZNemUwSm10NTRTL0RjRENWaWcyTmN2RVVHeEpBRTRQbCtZT3IwaXY2QlJTSVBBbUJlQlpBbUhsRTJzSDRwMXVocnExczBNbm5FUU1Cc2Y4d1JBU0FJQ1FRQ0NJVE4xWDcvc091YzBrZ09WcDMvZlBzMldIditjb0c3Z1FPSlVuTEdzVUNUeEVqUHpVb2hFQStOZklXVWR0eDArZWZ6QTFrU1NrSUd5QkFRTkNLZ0hBRUJBSjN1NzlVN2tpQWNXb2VtL2diNUZkMzNuckgza3ArU01XdHVBQitHbGxNSnhNakN4OVFSZ0EzdWlxTDVrd0hpVGxweGIzc21sZk1ER1lHUFAxaGNNQWtKdnM4U2NwZmRKc3BkaitNSzZQZis1K3UyOXZ5YjRsUjQrQkdFemlWRVNBa0VwdzZBdjFPaFVwSEN6NHFPWGJ6Rld6NE5jZGovdi9vMDhMdDkyT0REZ1pEQ0VGSllvVUdING16dWdQOTJwdVBUZjBwRDNIN3d2ZmRGWmRxU3huTXRXam9HQUFtRzlmT0x4andlc2RqVDIvWHpJUTdrczNzeWNZTVNFd0dITnRXZjVia1g1TmtZQ0pCeFVCWGlHVjBYSHZvc090NTRaZXkzM2ovSys4UDMzKyt2am5iaUdKYmJMRStKOVNBTkFiNm5KMkI3OXdjVXdFVEF3UVE3Zk1qUHpNdmZQOGphODdIVUlLTU9pYUFxTVpockdtTGRBeTc4ZVpyd3dzVFMwZU9iVHMrSWR0Z1ZhbnhCVUV4cUdiYjVWenJJSVNHSW9VWHNtcWJnRWhKbGRDUVdxUmYyN1N2UEFuL284WG1nTGhac1VrUjRsbDM3bWhrM245NFo0T2x6WS83TkxjWVpmbTdvMXoyelQ0dnN2VU5TWHFwckJDa21pVEZiUFg5MC9maDhHSVQyc2YrelRQZERNZjRkVm5OZzR6K0UwaXhzR2VCczlqZDVWaVNnTEhqQ2IvcGVhUitNRDNkNC9aSmcybGx5dUcyVnd5N1FXQXM4UE5ubjFmN3ZrR1NHeEF6RTZtaytreGt4L3AvNHVuZmZTQ1IwaEFvTDFFQkNZaVBOZFdOY3drTlFUQ1I3ZmVXWDZnKzdmL0E3SThyY3cvVTZVRWUwTmRyaGMvVzdtdEw5enRtcWxTZ3N0U1MvelRKMjhkYWxwT3BrUnJ5cndiaHdCQUNnc0xNV1BHRE9UNGxsM3F5ZXFBa0pUZENGN1AvQ3JVWS9Ha0xMMXJFKzJoVGJTSDgrMExiL1dFdWh6aHlhQTkwNWJsZjlWZC84OTVXblp3TEhyUGV2aXIvY3ZPQjFvTFlwVHRMcm02b1lHSU1ERXhBYXF0clVWS1NncVlHU0tDazBXSHE1aWtrV0VXdE5MMGltdjVxVVcrUmNsTFJqSnNyaEJBdUgxL1FMOFI3SFI0eHk1bmVzY3VQMjNFNmhPQTZtTHYrc2I0dVR3Nk9ncXFxNnVEcG1rUWtjU3Rvclg0WFJjTTFGalora3ZGRmpDSktVMVdwa05KSlVxSU10WDFSeUxlWDNKdFEwSlJobUdZWi9MMjdkdVJuSnljdUZHSVNPSjlwcWg1bHJCNmlZZ3FHT3hSck9hYTU0RGNabUt2a0p4azhKSEM5cktoK0tWaE9zRDQrRGorTXdBRElmOG41bTR4R3dBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1lZGl0LFxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLWVkaXQtbW9kZSBidXR0b24udmlzLWJ1dHRvbi52aXMtZWRpdCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmdBQUFBWUNBWUFBQURnZHozNEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFFRU9hVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnbzhlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqVXRZekF5TVNBM09TNHhOVFE1TVRFc0lESXdNVE12TVRBdk1qa3RNVEU2TkRjNk1UWWdJQ0FnSUNBZ0lDSStDaUFnSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0NpQWdJQ0FnSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uaHRjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSRmRuUTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpVVjJaVzUwSXlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uQm9iM1J2YzJodmNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzl3YUc5MGIzTm9iM0F2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVY0YVdZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZaWGhwWmk4eExqQXZJajRLSUNBZ0lDQWdJQ0FnUEhodGNEcERjbVZoZEc5eVZHOXZiRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nS0ZkcGJtUnZkM01wUEM5NGJYQTZRM0psWVhSdmNsUnZiMncrQ2lBZ0lDQWdJQ0FnSUR4NGJYQTZRM0psWVhSbFJHRjBaVDR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzk0YlhBNlEzSmxZWFJsUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTlpYUmhaR0YwWVVSaGRHVStNakF4TkMwd01pMHdOVlF4TkRveE1qb3lOU3N3TVRvd01Ed3ZlRzF3T2sxbGRHRmtZWFJoUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTmIyUnBabmxFWVhSbFBqSXdNVFF0TURJdE1EVlVNVFE2TVRJNk1qVXJNREU2TURBOEwzaHRjRHBOYjJScFpubEVZWFJsUGdvZ0lDQWdJQ0FnSUNBOFpHTTZabTl5YldGMFBtbHRZV2RsTDNCdVp6d3ZaR002Wm05eWJXRjBQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPalk1T1RNM1pHWmpMVEpqTnpRdFlUVTBZUzA1T1RJekxUUXlNbVpoTkROa01qbGpORHd2ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pa1J2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZlRzF3VFUwNlJHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5NGJYQk5UVHBQY21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K1kzSmxZWFJsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRVYyZERwcGJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmQyaGxiajR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzl6ZEVWMmREcDNhR1Z1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1ExTTJJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG5OaGRtVmtQQzl6ZEVWMmREcGhZM1JwYjI0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwcGJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNlJVRTJNRUV5TkVVeE9UZzBSVE14TVVGRVFVWkZSa1UyUlVNek16TkZNRE04TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURFdE1qTlVNVGs2TVRnNk1EY3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEVXpZZ0tGZHBibVJ2ZDNNcFBDOXpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZMmhoYm1kbFpENHZQQzl6ZEVWMmREcGphR0Z1WjJWa1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzSmtaanBzYVQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K2MyRjJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tbHVjM1JoYm1ObFNVUStlRzF3TG1scFpEb3pPV05oTnpFNVpDMDNZek5sTFRVeU5HRXRZbVkxTlMwM05HVm1NbU0xTXpFMFlUYzhMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREl0TURWVU1UUTZNVEk2TWpVck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwamFHRnVaMlZrUGk4OEwzTjBSWFowT21Ob1lXNW5aV1ErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajVqYjI1MlpYSjBaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStabkp2YlNCaGNIQnNhV05oZEdsdmJpOTJibVF1WVdSdlltVXVjR2h2ZEc5emFHOXdJSFJ2SUdsdFlXZGxMM0J1Wnp3dmMzUkZkblE2Y0dGeVlXMWxkR1Z5Y3o0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG1SbGNtbDJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStZMjl1ZG1WeWRHVmtJR1p5YjIwZ1lYQndiR2xqWVhScGIyNHZkbTVrTG1Ga2IySmxMbkJvYjNSdmMyaHZjQ0IwYnlCcGJXRm5aUzl3Ym1jOEwzTjBSWFowT25CaGNtRnRaWFJsY25NK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1ellYWmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qWTVPVE0zWkdaakxUSmpOelF0WVRVMFlTMDVPVEl6TFRReU1tWmhORE5rTWpsak5Ed3ZjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uZG9aVzQrTWpBeE5DMHdNaTB3TlZReE5Eb3hNam95TlNzd01Ub3dNRHd2YzNSRmRuUTZkMmhsYmo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21Ob1lXNW5aV1ErTHp3dmMzUkZkblE2WTJoaGJtZGxaRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ1BDOTRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThjM1JTWldZNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qTTVZMkUzTVRsa0xUZGpNMlV0TlRJMFlTMWlaalUxTFRjMFpXWXlZelV6TVRSaE56d3ZjM1JTWldZNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbVJ2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZjM1JTWldZNlpHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbTl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRkpsWmpwdmNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEd3ZlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMCtDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2UTI5c2IzSk5iMlJsUGpNOEwzQm9iM1J2YzJodmNEcERiMnh2Y2sxdlpHVStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2U1VORFVISnZabWxzWlQ1elVrZENJRWxGUXpZeE9UWTJMVEl1TVR3dmNHaHZkRzl6YUc5d09rbERRMUJ5YjJacGJHVStDaUFnSUNBZ0lDQWdJRHgwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQakU4TDNScFptWTZUM0pwWlc1MFlYUnBiMjQrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbGhTWlhOdmJIVjBhVzl1UGpjeU1EQTVNQzh4TURBd01Ed3ZkR2xtWmpwWVVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQSFJwWm1ZNldWSmxjMjlzZFhScGIyNCtOekl3TURrd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpFOEwyVjRhV1k2UTI5c2IzSlRjR0ZqWlQ0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dFUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3haUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXVVJwYldWdWMybHZiajRLSUNBZ0lDQWdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtDaUFnSUR3dmNtUm1PbEpFUmo0S1BDOTRPbmh0Y0cxbGRHRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0Nqdy9lSEJoWTJ0bGRDQmxibVE5SW5jaVB6NHlrbmluQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFZcFNVUkJWSGphZkZadFRGdm5GWDdPZWErTnVkaVkySHdhbTRDQmxnUXdYZEtSRURLVW9ZZzBqYlJKMjlSSjJWWjFtalJGVXhTcEEzVlRma3pKZmtRYlM3c3BVNnJ0eDVaMlV0cHBTY2phSHh2THVpYXRXaTJqTEVvTUlVRENoMjNnMmdiajcrdFB1UHZoT3VyYXdQbDFkYzk5bitjNTV6MzNmVjQ2Y2VJRVpGa0dBREF6aUFnQVFFUm9lLzlaSzRHUE0vQWNnYnNJWEFjQUJDZ012a2ZBcUFhODllRG9KeUY4TG9nSXFxcUNob2FHWURBWUhyOGtJdFM4dWM4aUlINmlBYTlJa0FvNUVBUVg4cHFtZ1VWQkNCZ2dZRmdEaHYwL0dBc0JnS1pwSUNKa01oblE0T0FnWkZrR0VZR1pVWG1wKzBjUytDS0J3V0EwRFZSUE9nNVpsMnE2emFIeUpsblZBTVFYVlRrd0hyVXFIMFhzdm4rdGRRQUFNUURncFBMUzJNVmlGWThya0dVWnpJemFTL3QveHFDekdnZ3R6OWU2OTd6c25LaG9MVXRpbTRqT3EvTEU2eDdYMG5zaDE2ZEVaNWEvTzNhMlNDQU9IandJblU2SHVqZDZUaEo0bUNEUStiMkcyMzJ2N3Y2dndhclBiUW44TUdsTXIrWDBrcEUzV3I1WnQ1aEw1SFBocVlTZFFJZktKK3loeERQS1dDNlhnK2p0N1VYRDViNUtCdDFrQ0hTODVMamQ4L09uM051cGZuaEZhWmo0cldmZjFCOThCMVIvaG5VbUtkMzZiZHRDTmw0ZzBlbjRlZE5FL2NYd0xxOHFNVE1JUEFRd21vL1d1SHZPYkE4KzljNThrL2RLdEQwVHlaV1hONVlHQTdlajdlcEt4c3BNLy83U29OT2RXYy9KeXEyd2l3aER6UHhUOGNQMGp5czNWTU03T21MMC83N3puNFlkdWkzYjh1aUswakQ3UnJBNzdjOVdkNTdjZWZQcEYrMlQ2YldzRlBXa2FpUFRDV3ZUc1pwSEZVK1hyUys4RzNBUjA4RjZYKzFGSnZCeFFRekhRT1drMlNtclc0RlBYL1UyTFZ3UHVEWmorZkpLbDJraFBwZXlBcUE5cnpSL1lxd3VpV1hYOHRhTi9DYWJHa3JWdXE5WUpsa1FRRGpPQUo1akFoejlWdDlXNE41L3JOcDhJK3Z0TVYvYVptNHpMblVOTnQwdXJkWW5GNjhIV29KajRXbzFtTEdVTlJyOExFZ0RnTnFlQ2g4eFFJS09zZ0M3aUFqVmU4M3JUOXpRYTh1Tk0yOHU3MGtzcGVzc3U4cTh6cS9WM05jWnBWemI5KzB6bVZoT3Z2dnJoYU1WenJKZzB6ZXE3eE1WQ0N3ZHBuV1NHQnFqVXlKd0xURmdidnhpZTN3MzF1b1dSMVk3NHI2MHJkeFpxclI4cTg1dDJXMk1HQ3AxMmJtL0tDM2h5YVNUaU1oeHVHcktjYWhxcGJqT2FET29FaE9Fb0ZxSlFDQ0p2cUE4NUk2YmZUZERqUWxmMmxieFZObFM2d3QxOXl5N2pSSFpabERucmluTmovNnNITWhuTncyT2djbzdPNzllNWZtL3hReXdSQkJDRUF1d240Z1E5NmJrWWo0Vnl1cTlOMVozQmo0T2Q1YnMwTVh0L2RaWjIxY3RpcUZhbjE3NHE5ODVQK0xmcCtVMWc3WERPTi8xY3RQNDU4V2xWakx5SmhPSVNaRTB3TTBTMVFmdVJDM2xUamtKQUtLRXROQzllSU9oU2g5eEhMWk9KUlpURnVYRHNFb1N0TGtSLzc2OHVtbXNhSkc5UGI5b2UrOUoreGFlU1Zva2lRRFNKcGhBbzV1YUJ1V2ppS1A0UVRxUzFjVVdVN2F5ZXNONjZ3dTIyZnJEMXZtVlc2R1c2VDh1OWVWakd5WnpzK3c3OE5xdTBhMm1idlZ1MUtFSlFBZ2VaUkwwbGlRWXl4K0dPbUtlUXB1MHJNWXNBSlBORUZHRDJkTG9kTEl5NmM5WXM3Rzh5ZVNVbDN0ZjIvWDNyY0JWSlNPdjM0bDNzQ0JvZ2k3ejFMSC9yQkhqbDRJSjkzL25jUUZBbmplSW1KRDBaOHp1Q3d1OXEzZGpEWHFUbEFLSUQ1eHYrOXQyUjhuOFZjVUZCbGpROEd5ZmU0MEJZQk00RHdETHQ4S3VlNzlaY0ZrYnpmRWRiVWJ2K29ONGM5S1R0c2ZtMU1iWVFxcWgrMnpyVlpZS3MvN0VmK2J5aW10MVBPWWlKaERoUEJGQklpSUVYaHhmczcvZGZZb0lGK2F1QmZZVEUvcGVieC9WOGhxQlAyT0R2RDM0eXZ1aC9XQ0FtVTc1Qng2c0lnYUkvdjUrNlBWNkpMcVVzWXI3ZHBEQW9laHMwaDczcEhUV3J2S2dUaFliUlN0OVVtU2plZjNNcGFVdkJ6NE83MlVtQURnVE9QSmd1R2lab3IrL0h5VWxKV0JtSkZ6K0Q4eFR0bFVpT3Bid3Btcm1yd2VlU1hyVCtnMTFrNFNCTjNSR0tVY0FWQ1ZkRmh5UDFucmVEYlkvL05QeUVYVWxVL1BwNFhZeWNHVDZWMFV4Mld3V2RPN2NPWlNXbGtJSThkaVg3U1BQTmdEYUtkYnhvTkF4d0FUQkFFa0VFZ1NXQ0VRQXFQQU13cXZNZENFd01PMHRWcVpwV3NHVFQ1OCtEYVBSK1BoR0lZUUFBQWdoMFA3QjNpb1cvQjBpR2lDR2l3WGJDdU9IRlNKeXM2QWJZRnllMlQreFdoVDNXWUpFSW9IL0RRQk13M2tlczhPSlBnQUFBQUJKUlU1RXJrSmdnZz09Jyk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLWVkaXQtbW9kZSBidXR0b24udmlzLWJ1dHRvbi52aXMtZWRpdC52aXMtZWRpdC1tb2RlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmY2ZjZmM7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b24udmlzLWNvbm5lY3Qge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJnQUFBQVlDQVlBQUFEZ2R6MzRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBRUVPYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZ284ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMalV0WXpBeU1TQTNPUzR4TlRRNU1URXNJREl3TVRNdk1UQXZNamt0TVRFNk5EYzZNVFlnSUNBZ0lDQWdJQ0krQ2lBZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SStDaUFnSUNBZ0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbmh0Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZaR005SW1oMGRIQTZMeTl3ZFhKc0xtOXlaeTlrWXk5bGJHVnRaVzUwY3k4eExqRXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUkZkblE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVVYyWlc1MEl5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbkJvYjNSdmMyaHZjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5d2FHOTBiM05vYjNBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZEdsbVpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzkwYVdabUx6RXVNQzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T21WNGFXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2WlhocFppOHhMakF2SWo0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBEY21WaGRHOXlWRzl2YkQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTBNZ0tGZHBibVJ2ZDNNcFBDOTRiWEE2UTNKbFlYUnZjbFJ2YjJ3K0NpQWdJQ0FnSUNBZ0lEeDRiWEE2UTNKbFlYUmxSR0YwWlQ0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5NGJYQTZRM0psWVhSbFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5aWFJoWkdGMFlVUmhkR1UrTWpBeE5DMHdNaTB3TkZReE5Eb3pPRG8xTnlzd01Ub3dNRHd2ZUcxd09rMWxkR0ZrWVhSaFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5iMlJwWm5sRVlYUmxQakl3TVRRdE1ESXRNRFJVTVRRNk16ZzZOVGNyTURFNk1EQThMM2h0Y0RwTmIyUnBabmxFWVhSbFBnb2dJQ0FnSUNBZ0lDQThaR002Wm05eWJXRjBQbWx0WVdkbEwzQnVaend2WkdNNlptOXliV0YwUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2U1c1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2psbVlqVXdNRFUwTFdFM09ERXRNV1EwT0MwNVpUbGxMVFUyWldRNVl6aGxZamRqTmp3dmVHMXdUVTA2U1c1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2tSdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOTRiWEJOVFRwUGNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtZM0psWVhSbFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBuTmhkbVZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZSVUUyTUVFeU5FVXhPVGcwUlRNeE1VRkVRVVpGUmtVMlJVTXpNek5GTURNOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ERXRNak5VTVRrNk1UZzZNRGNyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFV6WWdLRmRwYm1SdmQzTXBQQzl6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WTJoaGJtZGxaRDR2UEM5emRFVjJkRHBqYUdGdVoyVmtQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMM0prWmpwc2FUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtjMkYyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbWx1YzNSaGJtTmxTVVErZUcxd0xtbHBaRG8zWldSaE1qSTBNQzB5WVRReExUTmxORFF0WVdNMk15MWlOek5pWVRFNU9XSTNZMkU4TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURJdE1EUlVNVFE2TXpnNk5UY3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzTjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGphR0Z1WjJWa1BpODhMM04wUlhaME9tTm9ZVzVuWldRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1amIyNTJaWEowWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWm5KdmJTQmhjSEJzYVdOaGRHbHZiaTkyYm1RdVlXUnZZbVV1Y0dodmRHOXphRzl3SUhSdklHbHRZV2RsTDNCdVp6d3ZjM1JGZG5RNmNHRnlZVzFsZEdWeWN6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBtUmxjbWwyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWTI5dWRtVnlkR1ZrSUdaeWIyMGdZWEJ3YkdsallYUnBiMjR2ZG01a0xtRmtiMkpsTG5Cb2IzUnZjMmh2Y0NCMGJ5QnBiV0ZuWlM5d2JtYzhMM04wUlhaME9uQmhjbUZ0WlhSbGNuTStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNXpZWFpsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamxtWWpVd01EVTBMV0UzT0RFdE1XUTBPQzA1WlRsbExUVTJaV1E1WXpobFlqZGpOand2YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbmRvWlc0K01qQXhOQzB3TWkwd05GUXhORG96T0RvMU55c3dNVG93TUR3dmMzUkZkblE2ZDJobGJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblErUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tTm9ZVzVuWldRK0x6d3ZjM1JGZG5RNlkyaGhibWRsWkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdQQzk0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamRsWkdFeU1qUXdMVEpoTkRFdE0yVTBOQzFoWXpZekxXSTNNMkpoTVRrNVlqZGpZVHd2YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT21SdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2YzNSU1pXWTZaRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT205eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEZKbFpqcHZjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHd2ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjArQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBqTThMM0JvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUNXpVa2RDSUVsRlF6WXhPVFkyTFRJdU1Ud3ZjR2h2ZEc5emFHOXdPa2xEUTFCeWIyWnBiR1UrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGpFOEwzUnBabVk2VDNKcFpXNTBZWFJwYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lNREE1TUM4eE1EQXdNRHd2ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajRLSUNBZ0lDQWdJQ0FnUEhScFptWTZXVkpsYzI5c2RYUnBiMjQrTnpJd01Ea3dMekV3TURBd1BDOTBhV1ptT2xsU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwU1pYTnZiSFYwYVc5dVZXNXBkRDR5UEM5MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwRGIyeHZjbE53WVdObFBqRThMMlY0YVdZNlEyOXNiM0pUY0dGalpUNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WlJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV1VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrQ2lBZ0lEd3ZjbVJtT2xKRVJqNEtQQzk0T25odGNHMWxkR0UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDancvZUhCaFkydGxkQ0JsYm1ROUluY2lQejR1YnhzK0FBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBVXRTVVJCVkhqYWpKWi9iTlQxR2NkZnovUDUzUFY2QjRXN1ZsdExxZEFhcGxJT2lNT295eHhKQ1NzL0d2L3lCNGd6SnJvQW9zbW1Ea2x3a1lXUjBiUXNkbWt5a29valRwY3NXWUx4RC9sUlpkTVFrVEhSdGtMWlJxRzB0SVZlNzY2MnZUdTQzbjMyeC9WS1ovamg4OWNuMzgvenZON1A1L2w4OHp3ZjJibHpKejZmRHdBUlFVU20xbjhzMzFDTTAvVkFuYk5tc1VQdUFzRHBnRU8rQmc0QzcvL2l5djVodm1NaVFpcVZRcHFhbXZCNnZWTndFZUcxSlp0Q0JyWWkvTXJrQXdETmdqaHdBbGJ6SUNCTEEwckRiMCsvODM5QzZYUWFhV3hzcExDdzhEcDg2Y2JObXFWRkpRZGRFNkt6ZGpaOUQ4OWcrQjZmU3lDT2N5bjFueGlsK085eEtnNUhxV0ZTSEdYTGpyUDdXL0lDcVZRSzJiTm5EejZmRHhGaDY1S052eGJIRGhGNHJKajJiWFBvK0lHZmNXNWg1eEw0Zjk5UCtGQ0VNSUFvYjc1eDl0MGRBTWxrRWxOWFY0ZTFsdGVYYk5xaVFvTWFlT0ZPanJkVTg2OFNEMmx1WXlFUDZkVWgrc1ltU0hlT1U2R081WjhWTHg1K05OWnhJcFBKNUFTMkwzdXBST0NvQ3Z6OExvN3Zua2Y3N2NBSGhwaXoveklMOXZXejhMOHAvTnZ1cG1NMFE3cGpuQW9McXo4dERyYzhNblFxWVZVVmhWZEY0TEVnN2IrcnZEbjh3RERsSDBXb1BwdWtMSkltU0JhTXdqY0pxbXdXdHMyalBaTEcvOGt3WVZGZVZkWFhaY0ZmNHlWRGMyY05LZkJGbUQ5WCswbmNDUDU4RjQ4ZUcrRmVvMkNBVWt2czRkbDBWL3VKdmRYTGlpVit1dCsrbjdZTFNmeFBmTU1HNTRDaHpCM1dJZXNWV0IyaTgyYncxQVI2ZkpSN0M0VnNmWWl2NnUvazNBOW5FZ1A0elhrZThEaVlIeUFPTUsrUXhQSWduWjlHcVNIcjFpdFFKOERLMmZUZXJEUStTL2JIUlhRSmFIU0N3TklaMlhoKzcrUzNWQW13Tk1CQS90dVBadEVyZ0txdVVtZE1XSUZsUlVSdmRhbVJORVhHd0lXcmxQNDdwVE16TGl1bnhnaEdNd1RMdmNUV2xIQXA3N3M0UU5TcllNUXRzczZaTWdXcUNtNWNIb0RITzFuYms2Szh6RU44KzN6YXR2MkhuMWI1OUVxSlpkeG1ZVUVSZzlQOUt3cElpQU9UZFdVV0JYdUx6Qi92WkczUDFVbjRQTnAyZDFNYm15RDQ1VFdDeHVDc1FtMHg1NmJIR0hGWUVad3hvazd0b0FBOVNmdzNoQ2NvTC9OT3dpOVFPNXdtV08xajRKRWdaeFRrb2RtY1dSR2tmM3BjWDByOHhvQWFCaXhLdTRVNS94d25kTSswdHBBdlM2bVArUFpLMm5iMVVCdlBFS3dLTUxEdlBqNEVTR2M1NWxHeTMwM3NkSktRZFpCMnJrTWRjdEFCLzRnek4rL1EyRU5OZDRMeVVpL3hOK2JUdHF1WDJ0aGs1bms0d0kzZ0FGK09NTmNBMW5GUURmSytCWTVHcWJrd1dhYlRZNVFaaFhXbG5OeDFudHJZMVJ6ODdmdXZ3MjltL1NuOEorUFVHQUZqNVQxOWJhQTFJc3B1QlpwN2N4MXg0U3dHMWNFZitsZ1JTUk9zOGpHd2IrSHQ0UUIvR1NTc0FoWWFubzM5TFdJQnhORUliUDE0aFBEdWl5UzJWdEp1SFhRbEtLdnhNL2ppWERxL0QveFBsd2lmR01rSlpCMk5Jb0twcjY5bnhlaVp4TEhpY0ZTRlZXZkdxQmlkSVAzTFNqcldsdEQ5NEN5dWZGLzRrUWdQdVZ6Mkx6OTMrZERSYTlldTVRUThIZzgvaVhlZStEeTRDS01zN3hxbjRud0t6OUlpcmhRcW1WdUI0Mm04ZXkreDdMTW9ENmlBT043ODJlQ2hocW1SdVhmdlhnS0JBS3FLcXRJMC84bk5LclFJNEJWWVhrekhnelBwQzg4Z1d1SEwvY2FYcmhMb0dpTjBhcFNLcjBaWlJCWk03cTJ3NVpuTFIxb0FuSE9NalkwaHJhMnRGQlFVWUl5Wm1zdHZWVDFaNmVEbEF1RVZxN21lcnhtd3VlTlBEWHk5UHZ5YmpLUDVtY3RITGs0L1hUS1pSSnFibS9INy9WTncxVnlFTVliVzRGTjNXTldubmNoS295NXNIZVZHQlJYNlZXaTN5bUZ4N3IxMUl4OE1UWC95NUMyUlNQQy9BUUI2MWVyb3dicHFTd0FBQUFCSlJVNUVya0pnZ2c9PScpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b24udmlzLWRlbGV0ZSB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmdBQUFBWUNBWUFBQURnZHozNEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFFRU9hVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnbzhlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqVXRZekF5TVNBM09TNHhOVFE1TVRFc0lESXdNVE12TVRBdk1qa3RNVEU2TkRjNk1UWWdJQ0FnSUNBZ0lDSStDaUFnSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0NpQWdJQ0FnSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uaHRjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSRmRuUTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpVVjJaVzUwSXlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uQm9iM1J2YzJodmNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzl3YUc5MGIzTm9iM0F2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVY0YVdZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZaWGhwWmk4eExqQXZJajRLSUNBZ0lDQWdJQ0FnUEhodGNEcERjbVZoZEc5eVZHOXZiRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nS0ZkcGJtUnZkM01wUEM5NGJYQTZRM0psWVhSdmNsUnZiMncrQ2lBZ0lDQWdJQ0FnSUR4NGJYQTZRM0psWVhSbFJHRjBaVDR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzk0YlhBNlEzSmxZWFJsUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTlpYUmhaR0YwWVVSaGRHVStNakF4TkMwd01pMHdORlF4TkRvME1Ub3dOQ3N3TVRvd01Ed3ZlRzF3T2sxbGRHRmtZWFJoUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTmIyUnBabmxFWVhSbFBqSXdNVFF0TURJdE1EUlVNVFE2TkRFNk1EUXJNREU2TURBOEwzaHRjRHBOYjJScFpubEVZWFJsUGdvZ0lDQWdJQ0FnSUNBOFpHTTZabTl5YldGMFBtbHRZV2RsTDNCdVp6d3ZaR002Wm05eWJXRjBQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamMzTkRrelltVXhMVEV5WkdJdE9UZzBOQzFpTkRZeUxUZzJOR1ZtTkdJek16TTNNVHd2ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pa1J2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZlRzF3VFUwNlJHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5NGJYQk5UVHBQY21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K1kzSmxZWFJsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRVYyZERwcGJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmQyaGxiajR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzl6ZEVWMmREcDNhR1Z1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1ExTTJJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG5OaGRtVmtQQzl6ZEVWMmREcGhZM1JwYjI0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwcGJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNlJVRTJNRUV5TkVVeE9UZzBSVE14TVVGRVFVWkZSa1UyUlVNek16TkZNRE04TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURFdE1qTlVNVGs2TVRnNk1EY3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEVXpZZ0tGZHBibVJ2ZDNNcFBDOXpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZMmhoYm1kbFpENHZQQzl6ZEVWMmREcGphR0Z1WjJWa1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzSmtaanBzYVQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K2MyRjJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tbHVjM1JoYm1ObFNVUStlRzF3TG1scFpEb3dObUUzTldZd015MDRNRGRoTFdVek5HWXRZamsxWmkxalpHVTJNak0wTXpnNE9HWThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREl0TURSVU1UUTZOREU2TURRck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwamFHRnVaMlZrUGk4OEwzTjBSWFowT21Ob1lXNW5aV1ErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajVqYjI1MlpYSjBaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStabkp2YlNCaGNIQnNhV05oZEdsdmJpOTJibVF1WVdSdlltVXVjR2h2ZEc5emFHOXdJSFJ2SUdsdFlXZGxMM0J1Wnp3dmMzUkZkblE2Y0dGeVlXMWxkR1Z5Y3o0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG1SbGNtbDJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStZMjl1ZG1WeWRHVmtJR1p5YjIwZ1lYQndiR2xqWVhScGIyNHZkbTVrTG1Ga2IySmxMbkJvYjNSdmMyaHZjQ0IwYnlCcGJXRm5aUzl3Ym1jOEwzTjBSWFowT25CaGNtRnRaWFJsY25NK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1ellYWmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qYzNORGt6WW1VeExURXlaR0l0T1RnME5DMWlORFl5TFRnMk5HVm1OR0l6TXpNM01Ud3ZjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uZG9aVzQrTWpBeE5DMHdNaTB3TkZReE5EbzBNVG93TkNzd01Ub3dNRHd2YzNSRmRuUTZkMmhsYmo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21Ob1lXNW5aV1ErTHp3dmMzUkZkblE2WTJoaGJtZGxaRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ1BDOTRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThjM1JTWldZNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qQTJZVGMxWmpBekxUZ3dOMkV0WlRNMFppMWlPVFZtTFdOa1pUWXlNelF6T0RnNFpqd3ZjM1JTWldZNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbVJ2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZjM1JTWldZNlpHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbTl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRkpsWmpwdmNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEd3ZlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMCtDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2UTI5c2IzSk5iMlJsUGpNOEwzQm9iM1J2YzJodmNEcERiMnh2Y2sxdlpHVStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2U1VORFVISnZabWxzWlQ1elVrZENJRWxGUXpZeE9UWTJMVEl1TVR3dmNHaHZkRzl6YUc5d09rbERRMUJ5YjJacGJHVStDaUFnSUNBZ0lDQWdJRHgwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQakU4TDNScFptWTZUM0pwWlc1MFlYUnBiMjQrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbGhTWlhOdmJIVjBhVzl1UGpjeU1EQTVNQzh4TURBd01Ed3ZkR2xtWmpwWVVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQSFJwWm1ZNldWSmxjMjlzZFhScGIyNCtOekl3TURrd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpFOEwyVjRhV1k2UTI5c2IzSlRjR0ZqWlQ0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dFUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3haUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXVVJwYldWdWMybHZiajRLSUNBZ0lDQWdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtDaUFnSUR3dmNtUm1PbEpFUmo0S1BDOTRPbmh0Y0cxbGRHRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0Nqdy9lSEJoWTJ0bGRDQmxibVE5SW5jaVB6NGFZSnpZQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFZR1NVUkJWSGphbEpaN1VKVG5GY1ovNzNtLzcyUGRKWTFSYmhvUXA2bGtYUkF2bUlZeGRDVWFkTFZPb3pQTnRHT2JhcDFKc0tpcGppU2hiZG9SYmVLRWlRSHBRSzN4ajB4YTAzYWFtVGJhVEd5QVlWMVFHZXFGaStKeWlaRkxBbG1FU0JrV1JtUzNmeXpzbEdrbW5aNS92L004NzNPZTc1enp2cXFvcUFpYnpRYUFpS0NVQWtBcFJkSElLL05Gc3gyTlI5MW5PU0lMQUREb0p5ek5hTTR4eGJ0dlBIaDBpQytKaVlrSjFPSERoNG1KaVVFcEZTWFB2L3ppUEMyOFRJaVhEQ09TckFDbFFEU0Vwc0N3SlBJaHJFQlJRcGlTeXRYbFF3RGhjQmlsRlBmdTNVTVZGeGRqdDl1akZUemZjTEJBRENvRUVBRnIxWmJyck5qY2gydnRFSW1QQmdIb2I3ZlRjV0UrYlZYSk5KL05pRlFsRUdMdmllWEhLbVlxR0I4ZlJ4MDVjZ1NiellhSXNQdnl3VjhwS0ZhQTdmR3RMVHp6NjFZV3BvL3hWVEhRYnVmc3E1bGNlejl6V3VXaGs1bXZGd01FZzBIMCt2WHJNVTJUbjF3cDNDdENpUTVEakdkM0EvbS92OElEQ1pQOHI0aU5teVJyV3gvai81cWt0eWtacFhLekFqVkRWeFB6R3FlbXB0RHIxcTFqWDNOUm5JSmFyY0RLSzJoZ1IyVUxYUmZuY3Y3VVl2N3hwb3ZobmhpVzVNeitrZWZlU0tPNkxKMUExeHpFdWsvT2ptNG1SaWJwdVphTVpXM09DdFJVTkQ2ME5taUlDQ0lVU2hpc3g3YTJzTE1pUW40czc3dUVRZ0lhYm5xZGZISWxnVDEvcVFlZzh2czVkSGhkQ05CMXdZbjNSSWlDOTk1ajI2c3RqQWJzTkgrWWlaSkNFU25TMVkvWHhJWHU4cjRZSVB2L1ZrVnMzQ1RuVHkybXMzNHhybzErc3A5cG82c3hsVHUzNHVsdG1zUFZ2eTZpczg2RkNIZ08rRERzNDl6cGp1ZkJwQ0crc2VZT0M5T0hhVGlkaWVpY2I5b3VWQWhLdG91QXNlSTcxMG1hN3BMdXF3bWdZZkhxQUZ0KzZXZExvUS9MQmwxMUxtN1Z1ZEFhOHZiNzJQQ2luOVRsQVdJc0dHaExBQ0Qra1NBWm51c1lCaWkxWFFBUFlXRGxsdDZvdjJsckJrREJSMis2T2Z1YWsyLy8zTStHL1Q0d0FBUFc3ZlBoS2ZSVFZlcWs5cVFiRktSbURVVHhTM043UVlHWW13ekNrcWtsQkdsUERFY1ROditzZzl0TkNiVFh1dkJXdWpFMGJIclpqOUpFMUIvd1UxUG01UHdKTjZZQlM5YTJrVnZRRWNXbnJoNUdURkQzbHhrWWtxUk1nWVFsd1ZsZFV2RG5lbjczTEhUVXVxaXRkS00wZUFyOUFGUWZkMUoveW8yYUpuKzJzbjRXZG41cUVGT0RKc2tnQklqeDVUMHVDclFBMDhwbklqUzlQRVJEalBuZk9LWEFNRUJFQ1VvR0VJSEJqKzJ6a3Q3NlVRNmRYaGVHQWV2MytjZzc0S2Y2dUpQcWNpY2JmdW9uZDdjUHk0U09peTcrdEQ5bkZ2WnVyeDAwS09rM0NORUMrbUUrdmpTUEJjN0lXcWdxVGFQVDYwSU1jTy94c1hHYTNIZktqUmdSZGJsNy9LRGcwanR1YmplNmFIajdjN0ozZGdMUTJ6b1B3d1E5MVNvb09RZEFXMVZLVk1IdHkwa0E1QmI0OEJ5Y0puL0xqV0ZHYkx2NHRodnZiNTNrRnZqSitYRWRXa1BmalFWUi9DY05LWWdHTWM4Sld0NUZhMmorTUlQUHV5STJwYTRJb0hTa3Q2dkxJdVJhUTlxMzJraHp0NEdDeHROdTZrNDZHZWlJUjJsSWZEUVFzYWZQenExTEdSR0w5R2s5ZCt2cndld3ZmSFBRT29leFFWanhkQi9hdWsvem1hVU1kc2Z6NmJWVXRJYWxUN2J4dmVQMVpIaDZHUERQWWVTemVENjlrY3BJZnh5bUZXTE5ya2ErbGpoQlRXa1d3ejJKaUpUODRZSG56MmlQeDBQMjBQa21SRjVpNkhZaXdaRkpzbi9ZemRlemJ6RTNjUWliWTV4VjI2Nno2UmZYb2hha2IreEI5Q2phbkNEOXFUYlc3R3JrNFdWMzhWWm0wbDZkaFFpRXc5dGFIU3VEcXJTMEZJZkR3WE0zWDltSE1zdlJBay9zYXVEcFF5MzhQK0d0ek9UR0I5bUVwa0QwQzJkUzhuOHpPanFLOW5nOFdKWkZVK0pUamFzR3ZhQ05YUHB2SkJQb01sbTBPb0ROTWZXVnhPTmZXTlNVUFVaN1RVUTU2dENabFB3U2dNbkpTVlJwYVNteHNiRkUxcmF3ODJaeEFaWlJRVWlCWVVLR3A1VWxPWDJrckJ6bW9VVmppSUtoSGdlOXJmUG8rV2N5M1plWElZQVNnTDEvWDVSZk1YTXZqNDZPb3NyTHk3SFpiR2l0VVVvaEl1em9lbTBSb2ZBTGFPc2doZ1dHamt5ME1pSlRMOGIwbE92SThoTjFES1hLUDBqZDNUTlRXRGdjSmhnTW9vNGVQWXJENFlpK0ttYWVMbHBybnJ0WEZvOWgvQUFsRzFBcUU4eUZtQnJDK2pPMGJnSDlFVnBPLzFGMkRjNWcvL09Bc2JFeC9qMEFmK1VTc1F5bkwxVUFBQUFBU1VWT1JLNUNZSUk9Jyk7XFxufVxcbi8qIHRvcCByaWdodCBib3R0b20gbGVmdCAqL1xcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBkaXYudmlzLWxhYmVsLFxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLWVkaXQtbW9kZSBkaXYudmlzLWxhYmVsIHtcXG4gIG1hcmdpbjogMCAwIDAgMjNweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gZGl2LnZpcy1zZXBhcmF0b3ItbGluZSB7XFxuICBmbG9hdDogbGVmdDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAxcHg7XFxuICBoZWlnaHQ6IDIxcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmRiZGJkO1xcbiAgbWFyZ2luOiAwcHggN3B4IDAgMTVweDsgLyp0b3AgcmlnaHQgYm90dG9tIGxlZnQqL1xcbn1cXG5cXG4vKiBUT0RPOiBpcyB0aGlzIHJlZHVuZGFudD9cXG5kaXYubmV0d29yay1uYXZpZ2F0aW9uX3dyYXBwZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG4qL1xcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHopO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IHZhciBfY29udGV4dDMyOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDMyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MzIsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBDbGVhcnMgdGhlIHRvb2xiYXIgZGl2IGVsZW1lbnQgb2YgY2hpbGRyZW5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBNYW5pcHVsYXRpb25TeXN0ZW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0ge1NlbGVjdGlvbkhhbmRsZXJ9IHNlbGVjdGlvbkhhbmRsZXJcbiAgICogQHBhcmFtIHtJbnRlcmFjdGlvbkhhbmRsZXJ9IGludGVyYWN0aW9uSGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gTWFuaXB1bGF0aW9uU3lzdGVtKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlciwgaW50ZXJhY3Rpb25IYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQsXG4gICAgICAgIF9jb250ZXh0MjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYW5pcHVsYXRpb25TeXN0ZW0pO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyID0gaW50ZXJhY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVkaXRNb2RlRGl2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2xvc2VEaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZSA9IFtdO1xuICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zID0gW107XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMudGVtcG9yYXJ5SWRzID0ge1xuICAgICAgbm9kZXM6IFtdLFxuICAgICAgZWRnZXM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlLFxuICAgICAgYWRkTm9kZTogdHJ1ZSxcbiAgICAgIGFkZEVkZ2U6IHRydWUsXG4gICAgICBlZGl0Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgZWRpdEVkZ2U6IHRydWUsXG4gICAgICBkZWxldGVOb2RlOiB0cnVlLFxuICAgICAgZGVsZXRlRWRnZTogdHJ1ZSxcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGU6IHtcbiAgICAgICAgc2hhcGU6IFwiZG90XCIsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgYm9yZGVyOiBcIiMzYzNjM2NcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzA3Zjk2OFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIiMzYzNjM2NcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDJcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fY2xlYW4oKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLl9yZXN0b3JlKS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXREYXRhXCIsIGJpbmQkNihfY29udGV4dDIgPSB0aGlzLl9yZXN0b3JlKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBJZiBzb21ldGhpbmcgY2hhbmdlcyBpbiB0aGUgZGF0YSBkdXJpbmcgZWRpdGluZywgc3dpdGNoIGJhY2sgdG8gdGhlIGluaXRpYWwgZGF0YW1hbmlwdWxhdGlvbiBzdGF0ZSBhbmQgY2xvc2UgYWxsIGVkaXQgbW9kZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1hbmlwdWxhdGlvblN5c3RlbSwgW3tcbiAgICBrZXk6IFwiX3Jlc3RvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmUoKSB7XG4gICAgICBpZiAodGhpcy5pbk1vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBpZiAoYWxsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGFsbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBnbG9iYWxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGVzID0gYWxsT3B0aW9ucy5sb2NhbGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGVzID0gZ2xvYmFsT3B0aW9ucy5sb2NhbGVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGVkaXQtbW9kZS4gRHJhd3MgdGhlIERPTSByZXF1aXJlZCBhbmQgY2xlYW5zIHVwIGFmdGVyIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgRWRpdCBNb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbWFpbiB0b29sYmFyLiBSZW1vdmVzIGZ1bmN0aW9ucyBib3VuZCB0byB0aGUgc2VsZWN0IGV2ZW50LiBCaW5kcyBhbGwgdGhlIGJ1dHRvbnMgb2YgdGhlIHRvb2xiYXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd01hbmlwdWxhdG9yVG9vbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TWFuaXB1bGF0b3JUb29sYmFyKCkge1xuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7IC8vIHJlc2V0IGdsb2JhbCB2YXJpYWJsZXNcblxuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9OyAvLyBpZiB0aGUgZ3VpIGlzIGVuYWJsZWQsIGRyYXcgYWxsIGVsZW1lbnRzLlxuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDMsIF9jb250ZXh0NDtcblxuICAgICAgICAvLyBhIF9yZXN0b3JlIHdpbGwgaGlkZSB0aGVzZSBtZW51c1xuICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkRWRnZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUNvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3RlZFRvdGFsQ291bnQgPSBzZWxlY3RlZE5vZGVDb3VudCArIHNlbGVjdGVkRWRnZUNvdW50O1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHZhciBuZWVkU2VwZXJhdG9yID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZE5vZGVCdXR0b24obG9jYWxlKTtcblxuICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMSAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZUNvdW50ID09PSAxICYmIHNlbGVjdGVkTm9kZUNvdW50ID09PSAwICYmIHRoaXMub3B0aW9ucy5lZGl0RWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9IC8vIHJlbW92ZSBidXR0b25zXG5cblxuICAgICAgICBpZiAoc2VsZWN0ZWRUb3RhbENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID4gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgYmluZCQ2KF9jb250ZXh0MyA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7IC8vIHJlZnJlc2ggdGhpcyBiYXIgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiBzZWxlY3RlZFxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwic2VsZWN0XCIsIGJpbmQkNihfY29udGV4dDQgPSB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKSk7XG4gICAgICB9IC8vIHJlZHJhdyB0byBzaG93IGFueSBwb3NzaWJsZSBjaGFuZ2VzXG5cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgdG9vbGJhciBmb3IgYWRkaW5nIE5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlTW9kZSgpIHtcbiAgICAgIHZhciBfY29udGV4dDY7XG5cbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfSAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJhZGROb2RlXCI7XG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVtcImFkZERlc2NyaXB0aW9uXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJhZGREZXNjcmlwdGlvblwiXSk7IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgYmluZCQ2KF9jb250ZXh0NSA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQ1LCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcImNsaWNrXCIsIGJpbmQkNihfY29udGV4dDYgPSB0aGlzLl9wZXJmb3JtQWRkTm9kZSkuY2FsbChfY29udGV4dDYsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbCB0aGUgYm91bmQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIHRoZSBub2RlLiBUaGUgbm9kZSBoYXMgdG8gYmUgc2VsZWN0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlZGl0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0Tm9kZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzKClbMF07XG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbk1vZGUgPSBcImVkaXROb2RlXCI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkZWVwRXh0ZW5kKHt9LCBub2RlLm9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIGRhdGEueCA9IG5vZGUueDtcbiAgICAgICAgICAgIGRhdGEueSA9IG5vZGUueTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0Tm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXROb2RlKGRhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzMi5pbk1vZGUgPT09IFwiZWRpdE5vZGVcIikge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS51cGRhdGUoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXMyLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiZWRpdENsdXN0ZXJFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdENsdXN0ZXJFcnJvclwiXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIG5vZGVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgdG9vbGJhciB0byBjb25uZWN0IG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlTW9kZSgpIHtcbiAgICAgIHZhciBfY29udGV4dDgsIF9jb250ZXh0OSwgX2NvbnRleHQxMCwgX2NvbnRleHQxMSwgX2NvbnRleHQxMjtcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG5cblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5pbk1vZGUgPSBcImFkZEVkZ2VcIjtcblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQ3O1xuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiZWRnZURlc2NyaXB0aW9uXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGdlRGVzY3JpcHRpb25cIl0pOyAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cblxuXG4gICAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsIGJpbmQkNihfY29udGV4dDcgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0NywgdGhpcykpO1xuICAgICAgfSAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBmdW5jdGlvbnNcblxuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsIGJpbmQkNihfY29udGV4dDggPSB0aGlzLl9oYW5kbGVDb25uZWN0KS5jYWxsKF9jb250ZXh0OCwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdFbmRcIiwgYmluZCQ2KF9jb250ZXh0OSA9IHRoaXMuX2ZpbmlzaENvbm5lY3QpLmNhbGwoX2NvbnRleHQ5LCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1wiLCBiaW5kJDYoX2NvbnRleHQxMCA9IHRoaXMuX2RyYWdDb250cm9sTm9kZSkuY2FsbChfY29udGV4dDEwLCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uUmVsZWFzZVwiLCBiaW5kJDYoX2NvbnRleHQxMSA9IHRoaXMuX2ZpbmlzaENvbm5lY3QpLmNhbGwoX2NvbnRleHQxMSwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdTdGFydFwiLCBiaW5kJDYoX2NvbnRleHQxMiA9IHRoaXMuX2RyYWdTdGFydEVkZ2UpLmNhbGwoX2NvbnRleHQxMiwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkhvbGRcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gZWRpdCBlZGdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdEVkZ2VNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRFZGdlTW9kZSgpIHtcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiZWRpdEVkZ2VcIjtcblxuICAgICAgaWYgKF90eXBlb2YodGhpcy5vcHRpb25zLmVkaXRFZGdlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXRFZGdlLmVkaXRXaXRob3V0RHJhZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKClbMF07XG5cbiAgICAgICAgaWYgKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuXG4gICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKGVkZ2UuZnJvbS5pZCwgZWRnZS50by5pZCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQxMztcblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVtcImVkaXRFZGdlRGVzY3JpcHRpb25cIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRFZGdlRGVzY3JpcHRpb25cIl0pOyAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cblxuXG4gICAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsIGJpbmQkNihfY29udGV4dDEzID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDEzLCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKClbMF07XG5cbiAgICAgIGlmICh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTQsIF9jb250ZXh0MTUsIF9jb250ZXh0MTYsIF9jb250ZXh0MTc7XG5cbiAgICAgICAgdmFyIF9lZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdOyAvLyBjcmVhdGUgY29udHJvbCBub2Rlc1xuXG4gICAgICAgIHZhciBjb250cm9sTm9kZUZyb20gPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKF9lZGdlLmZyb20ueCwgX2VkZ2UuZnJvbS55KTtcblxuICAgICAgICB2YXIgY29udHJvbE5vZGVUbyA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUoX2VkZ2UudG8ueCwgX2VkZ2UudG8ueSk7XG5cbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChjb250cm9sTm9kZUZyb20uaWQpO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbY29udHJvbE5vZGVGcm9tLmlkXSA9IGNvbnRyb2xOb2RlRnJvbTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goY29udHJvbE5vZGVGcm9tLmlkKTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlVG8uaWRdID0gY29udHJvbE5vZGVUbztcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goY29udHJvbE5vZGVUby5pZCk7IC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIFVJIGZ1bmN0aW9ucywgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2YgX3RlbXBvcmFyeUJpbmRVSVxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVG91Y2hcIiwgYmluZCQ2KF9jb250ZXh0MTQgPSB0aGlzLl9jb250cm9sTm9kZVRvdWNoKS5jYWxsKF9jb250ZXh0MTQsIHRoaXMpKTsgLy8gdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRhcFwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkhvbGRcIiwgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnU3RhcnRcIiwgYmluZCQ2KF9jb250ZXh0MTUgPSB0aGlzLl9jb250cm9sTm9kZURyYWdTdGFydCkuY2FsbChfY29udGV4dDE1LCB0aGlzKSk7IC8vIHVzZWQgdG8gc2VsZWN0IGNvbnRyb2wgbm9kZVxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnXCIsIGJpbmQkNihfY29udGV4dDE2ID0gdGhpcy5fY29udHJvbE5vZGVEcmFnKS5jYWxsKF9jb250ZXh0MTYsIHRoaXMpKTsgLy8gdXNlZCB0byBkcmFnIGNvbnRyb2wgbm9kZVxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnRW5kXCIsIGJpbmQkNihfY29udGV4dDE3ID0gdGhpcy5fY29udHJvbE5vZGVEcmFnRW5kKS5jYWxsKF9jb250ZXh0MTcsIHRoaXMpKTsgLy8gdXNlZCB0byBjb25uZWN0IG9yIHJldmVydCBjb250cm9sIG5vZGVzXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbk1vdXNlTW92ZVwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgIC8vIGNyZWF0ZSBmdW5jdGlvbiB0byBwb3NpdGlvbiBjb250cm9sIG5vZGVzIGNvcnJlY3RseSBvbiBtb3ZlbWVudFxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgYmVjYXVzZSB3ZSB1c2UgdGhlIHRlbXBvcmFyeSBiaW5kXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoXCJiZWZvcmVEcmF3aW5nXCIsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25zID0gX2VkZ2UuZWRnZVR5cGUuZmluZEJvcmRlclBvc2l0aW9ucyhjdHgpO1xuXG4gICAgICAgICAgaWYgKGNvbnRyb2xOb2RlRnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS54ID0gcG9zaXRpb25zLmZyb20ueDtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS55ID0gcG9zaXRpb25zLmZyb20ueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVUby5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueCA9IHBvc2l0aW9ucy50by54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVUby55ID0gcG9zaXRpb25zLnRvLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWxldGUgZXZlcnl0aGluZyBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVTZWxlY3RlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiZGVsZXRlXCI7XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMoKTtcbiAgICAgIHZhciBzZWxlY3RlZEVkZ2VzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpO1xuICAgICAgdmFyIGRlbGV0ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbc2VsZWN0ZWROb2Rlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImRlbGV0ZUNsdXN0ZXJFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZGVsZXRlQ2x1c3RlckVycm9yXCJdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVOb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVOb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVFZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVsZXRlRnVuY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICBub2Rlczogc2VsZWN0ZWROb2RlcyxcbiAgICAgICAgICBlZGdlczogc2VsZWN0ZWRFZGdlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkZWxldGVGdW5jdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbihkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzMy5pbk1vZGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLmVkZ2VzKTtcblxuICAgICAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5ub2Rlcyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuXG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG5cbiAgICAgICAgICAgICAgX3RoaXMzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGRlbGV0ZSBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZEVkZ2VzKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfSAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogUFJJVkFURSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovL1xuXG4gICAgLyoqXG4gICAgICogZHJhdyBvciByZW1vdmUgdGhlIERPTVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBHVUlcbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVXcmFwcGVycygpO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCk7IC8vIGRpc2FibGUgdGhlIGd1aVxuXG5cbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgZGl2IG92ZXJsYXlzIHRoYXQgY29udGFpbiB0aGUgRE9NXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVdyYXBwZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVXcmFwcGVycygpIHtcbiAgICAgIC8vIGxvYWQgdGhlIG1hbmlwdWxhdG9yIEhUTUwgZWxlbWVudHMuIEFsbCBzdHlsaW5nIGRvbmUgaW4gY3NzLlxuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5jbGFzc05hbWUgPSBcInZpcy1tYW5pcHVsYXRpb25cIjtcblxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgfSAvLyBjb250YWluZXIgZm9yIHRoZSBlZGl0IGJ1dHRvbi5cblxuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LmNsYXNzTmFtZSA9IFwidmlzLWVkaXQtbW9kZVwiO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9IC8vIGNvbnRhaW5lciBmb3IgdGhlIGNsb3NlIGRpdiBidXR0b25cblxuXG4gICAgICBpZiAodGhpcy5jbG9zZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfdGhpcyRvcHRpb25zJGxvY2FsZXMsIF90aGlzJG9wdGlvbnMkbG9jYWxlczI7XG5cbiAgICAgICAgdGhpcy5jbG9zZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuY2xhc3NOYW1lID0gXCJ2aXMtY2xvc2VcIjtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIChfdGhpcyRvcHRpb25zJGxvY2FsZXMgPSAoX3RoaXMkb3B0aW9ucyRsb2NhbGVzMiA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zJGxvY2FsZXMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zJGxvY2FsZXMyW1wiY2xvc2VcIl0pICE9PSBudWxsICYmIF90aGlzJG9wdGlvbnMkbG9jYWxlcyAhPT0gdm9pZCAwID8gX3RoaXMkb3B0aW9ucyRsb2NhbGVzIDogdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNsb3NlXCJdKTtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jbG9zZURpdik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgbmV3IHRhcmdldCBub2RlLiBVc2VkIGZvciBjcmVhdGluZyBuZXcgZWRnZXMgYW5kIGVkaXRpbmcgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE5ld1RhcmdldE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE5ld1RhcmdldE5vZGUoeCwgeSkge1xuICAgICAgdmFyIGNvbnRyb2xOb2RlU3R5bGUgPSBkZWVwRXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuY29udHJvbE5vZGVTdHlsZSk7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLmlkID0gXCJ0YXJnZXROb2RlXCIgKyB2NCgpO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUucGh5c2ljcyA9IGZhbHNlO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS54ID0geDtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUueSA9IHk7IC8vIHdlIGhhdmUgdG8gZGVmaW5lIHRoZSBib3VuZGluZyBib3ggaW4gb3JkZXIgZm9yIHRoZSBub2RlcyB0byBiZSBkcmF3biBpbW1lZGlhdGVseVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShjb250cm9sTm9kZVN0eWxlKTtcbiAgICAgIG5vZGUuc2hhcGUuYm91bmRpbmdCb3ggPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHJpZ2h0OiB4LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIGJvdHRvbTogeVxuICAgICAgfTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGVkaXQgYnV0dG9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRWRpdEJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWRpdEJ1dHRvbigpIHtcbiAgICAgIHZhciBfY29udGV4dDE4O1xuXG4gICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoaWYgYXBwbGljYWJsZSlcbiAgICAgIHRoaXMuX2NsZWFuKCk7IC8vIHJlc2V0IHRoZSBtYW5pcHVsYXRpb25ET01cblxuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9OyAvLyBlbXB0eSB0aGUgZWRpdE1vZGVEaXZcblxuICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpOyAvLyBjcmVhdGUgdGhlIGNvbnRlbnRzIGZvciB0aGUgZWRpdE1vZGUgYnV0dG9uXG5cbiAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImVkaXRNb2RlXCIsIFwidmlzLWVkaXQgdmlzLWVkaXQtbW9kZVwiLCBsb2NhbGVbXCJlZGl0XCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0XCJdKTtcblxuICAgICAgdGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChidXR0b24pOyAvLyBiaW5kIGEgaGFtbWVyIGxpc3RlbmVyIHRvIHRoZSBidXR0b24sIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlLlxuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDE4ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDE4LCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gY2xlYW5zIHVwIGFmdGVyIGV2ZXJ5dGhpbmcgdGhpcyBtb2R1bGUgZG9lcy4gVGVtcG9yYXJ5IGVsZW1lbnRzLCBmdW5jdGlvbnMgYW5kIGV2ZW50cyBhcmUgcmVtb3ZlZCwgcGh5c2ljcyByZXN0b3JlZCwgaGFtbWVycyByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICAvLyBub3QgaW4gbW9kZVxuICAgICAgdGhpcy5pbk1vZGUgPSBmYWxzZTsgLy8gX2NsZWFuIHRoZSBkaXZzXG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5tYW5pcHVsYXRpb25EaXYpOyAvLyByZW1vdmVzIGFsbCB0aGUgYmluZGluZ3MgYW5kIG92ZXJsb2Fkc1xuXG4gICAgICAgIHRoaXMuX2NsZWFudXBET01FdmVudExpc3RlbmVycygpO1xuICAgICAgfSAvLyByZW1vdmUgdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7IC8vIHJlc3RvcmUgb3ZlcmxvYWRlZCBVSSBmdW5jdGlvbnNcblxuXG4gICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlVSXMoKTsgLy8gcmVtb3ZlIHRoZSB0ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1xuXG5cbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpOyAvLyByZXN0b3JlIHRoZSBwaHlzaWNzIGlmIHJlcXVpcmVkXG5cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc3RvcmVQaHlzaWNzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYWNoIGRvbSBlbGVtZW50IGhhcyBpdCdzIG93biBoYW1tZXIuIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMuIFRoaXMgY2xlYW5zIHRoZW0gdXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFudXBET01FdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW51cERPTUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF9jb250ZXh0MTk7XG5cbiAgICAgIC8vIF9jbGVhbiBET00gZXZlbnQgbGlzdGVuZXIgYmluZGluZ3NcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzcGxpY2UkMShfY29udGV4dDE5ID0gdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZSkuY2FsbChfY29udGV4dDE5LCAwKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIERPTSBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoaXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVNYW5pcHVsYXRpb25ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpIHtcbiAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICB0aGlzLl9jbGVhbigpOyAvLyBlbXB0eSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcblxuXG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuY2xvc2VEaXYpOyAvLyByZW1vdmUgdGhlIG1hbmlwdWxhdGlvbiBkaXZzXG5cbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZURpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmNsb3NlRGl2KTtcbiAgICAgIH0gLy8gc2V0IHRoZSByZWZlcmVuY2VzIHRvIHVuZGVmaW5lZFxuXG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY2xvc2VEaXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHNlcGVyYXRvciBsaW5lLiB0aGUgaW5kZXggaXMgdG8gZGlmZmVyZW50aWF0ZSBpbiB0aGUgbWFuaXB1bGF0aW9uIGRvbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0xXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlU2VwZXJhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVTZXBlcmF0b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIiArIGluZGV4XSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIiArIGluZGV4XS5jbGFzc05hbWUgPSBcInZpcy1zZXBhcmF0b3ItbGluZVwiO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIgKyBpbmRleF0pO1xuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBET00gZnVuY3Rpb25zIGZvciBidXR0b25zICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQWRkTm9kZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIwO1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiYWRkTm9kZVwiLCBcInZpcy1hZGRcIiwgbG9jYWxlW1wiYWRkTm9kZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkTm9kZVwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MjAgPSB0aGlzLmFkZE5vZGVNb2RlKS5jYWxsKF9jb250ZXh0MjAsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVBZGRFZGdlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjE7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJhZGRFZGdlXCIsIFwidmlzLWNvbm5lY3RcIiwgbG9jYWxlW1wiYWRkRWRnZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkRWRnZVwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MjEgPSB0aGlzLmFkZEVkZ2VNb2RlKS5jYWxsKF9jb250ZXh0MjEsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFZGl0Tm9kZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMjtcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImVkaXROb2RlXCIsIFwidmlzLWVkaXRcIiwgbG9jYWxlW1wiZWRpdE5vZGVcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXROb2RlXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQyMiA9IHRoaXMuZWRpdE5vZGUpLmNhbGwoX2NvbnRleHQyMiwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXRFZGdlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIzO1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdEVkZ2VcIiwgXCJ2aXMtZWRpdFwiLCBsb2NhbGVbXCJlZGl0RWRnZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdEVkZ2VcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDIzID0gdGhpcy5lZGl0RWRnZU1vZGUpLmNhbGwoX2NvbnRleHQyMywgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZURlbGV0ZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjQ7XG5cbiAgICAgIHZhciBkZWxldGVCdG5DbGFzcztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgZGVsZXRlQnRuQ2xhc3MgPSBcInZpcy1kZWxldGUtcnRsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVCdG5DbGFzcyA9IFwidmlzLWRlbGV0ZVwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZGVsZXRlXCIsIGRlbGV0ZUJ0bkNsYXNzLCBsb2NhbGVbXCJkZWxcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImRlbFwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MjQgPSB0aGlzLmRlbGV0ZVNlbGVjdGVkKS5jYWxsKF9jb250ZXh0MjQsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVCYWNrQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjU7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJiYWNrXCIsIFwidmlzLWJhY2tcIiwgbG9jYWxlW1wiYmFja1wiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYmFja1wiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MjUgPSB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIpLmNhbGwoX2NvbnRleHQyNSwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtsYWJlbH0gbGFiZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxDbGFzc05hbWVcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvbihpZCwgY2xhc3NOYW1lLCBsYWJlbCkge1xuICAgICAgdmFyIGxhYmVsQ2xhc3NOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcInZpcy1sYWJlbFwiO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiRGl2XCJdLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiBcIiArIGNsYXNzTmFtZTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJMYWJlbFwiXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0uY2xhc3NOYW1lID0gbGFiZWxDbGFzc05hbWU7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0uaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiRGl2XCJdLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJMYWJlbFwiXSk7XG4gICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRGVzY3JpcHRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlc2NyaXB0aW9uKGxhYmVsKSB7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdLmNsYXNzTmFtZSA9IFwidmlzLW5vbmVcIjtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wiZGVzY3JpcHRpb25MYWJlbFwiXS5pbm5lclRleHQgPSBsYWJlbDtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW1wiZGVzY3JpcHRpb25MYWJlbFwiXSk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFbmQgb2YgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBiaW5kcyBhbiBldmVudCB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdGVtcG9yYXJ5QmluZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kRXZlbnQoZXZlbnQsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGJvdW5kRnVuY3Rpb246IG5ld0Z1bmN0aW9uXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKGV2ZW50LCBuZXdGdW5jdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgb3ZlcnJpZGVzIGFuIFVJIGZ1bmN0aW9uIHVudGlsIGNsZWFudXAgYnkgdGhlIGNsZWFuIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gVUlmdW5jdGlvbk5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdGVtcG9yYXJ5QmluZFVJXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kVUkoVUlmdW5jdGlvbk5hbWUsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbVUlmdW5jdGlvbk5hbWVdID0gdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSA9IG5ld0Z1bmN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiBcIiArIFVJZnVuY3Rpb25OYW1lICsgXCIgcG9zc2libGUgYXJlOiBcIiArIHN0cmluZ2lmeSQxKGtleXMkNCh0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIG92ZXJyaWRkZW4gVUkgZnVuY3Rpb25zIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91bmJpbmRUZW1wb3JhcnlVSXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeVVJcygpIHtcbiAgICAgIGZvciAodmFyIGZ1bmN0aW9uTmFtZSBpbiB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucywgZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tmdW5jdGlvbk5hbWVdID0gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgdGhlIGV2ZW50cyBjcmVhdGVkIGJ5IF90ZW1wb3JhcnlCaW5kRXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlFdmVudHMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uZXZlbnQ7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ib3VuZEZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBib3VuZEZ1bmN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGFuIGhhbW1lciBpbnN0YW5jZSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYm91bmRGdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRFbGVtZW50RXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRWxlbWVudEV2ZW50cyhkb21FbGVtZW50LCBib3VuZEZ1bmN0aW9uKSB7XG4gICAgICAvLyBCaW5kIHRvdWNoIGV2ZW50cy5cbiAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKGRvbUVsZW1lbnQsIHt9KTtcbiAgICAgIG9uVG91Y2goaGFtbWVyLCBib3VuZEZ1bmN0aW9uKTtcblxuICAgICAgdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIH0pOyAvLyBCaW5kIGtleWJvYXJkIGV2ZW50cy5cblxuXG4gICAgICB2YXIga2V5dXBMaXN0ZW5lciA9IGZ1bmN0aW9uIGtleXVwTGlzdGVuZXIoX3JlZikge1xuICAgICAgICB2YXIga2V5Q29kZSA9IF9yZWYua2V5Q29kZSxcbiAgICAgICAgICAgIGtleSA9IF9yZWYua2V5O1xuXG4gICAgICAgIGlmIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiIHx8IGtleUNvZGUgPT09IDEzIHx8IGtleUNvZGUgPT09IDMyKSB7XG4gICAgICAgICAgYm91bmRGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrZXl1cExpc3RlbmVyLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGtleXVwTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWF0bHkgY2xlYW4gdXAgdGVtcG9yYXJ5IGVkZ2VzIGFuZCBub2Rlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKSB7XG4gICAgICAvLyBfY2xlYW4gdGVtcG9yYXJ5IGVkZ2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI2O1xuXG4gICAgICAgIHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXV0uZGlzY29ubmVjdCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXTtcblxuICAgICAgICB2YXIgaW5kZXhUZW1wRWRnZSA9IGluZGV4T2YoX2NvbnRleHQyNiA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDI2LCB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXSk7XG5cbiAgICAgICAgaWYgKGluZGV4VGVtcEVkZ2UgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0Mjc7XG5cbiAgICAgICAgICBzcGxpY2UkMShfY29udGV4dDI3ID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjcsIGluZGV4VGVtcEVkZ2UsIDEpO1xuICAgICAgICB9XG4gICAgICB9IC8vIF9jbGVhbiB0ZW1wb3Jhcnkgbm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI4O1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldXTtcblxuICAgICAgICB2YXIgaW5kZXhUZW1wTm9kZSA9IGluZGV4T2YoX2NvbnRleHQyOCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDI4LCB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV0pO1xuXG4gICAgICAgIGlmIChpbmRleFRlbXBOb2RlICE9PSAtMSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDI5O1xuXG4gICAgICAgICAgc3BsaWNlJDEoX2NvbnRleHQyOSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDI5LCBpbmRleFRlbXBOb2RlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRlbXBvcmFyeUlkcyA9IHtcbiAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICBlZGdlczogW11cbiAgICAgIH07XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiB0aGUgdG91Y2ggaXMgdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbml0aWFsIGNsaWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlVG91Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlVG91Y2goZXZlbnQpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uID0gYXNzaWduJDIoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoZSBkcmFnIHN0YXJ0IGlzIHVzZWQgdG8gbWFyayBvbmUgb2YgdGhlIGNvbnRyb2wgbm9kZXMgYXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWdTdGFydCgpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG5cbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgdmFyIHRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXTtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGZyb21TZWxlY3QgPSBmcm9tLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgdmFyIHRvU2VsZWN0ID0gdG8uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG5cbiAgICAgIGlmIChmcm9tU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IGZyb207XG4gICAgICAgIGVkZ2UuZWRnZVR5cGUuZnJvbSA9IGZyb207XG4gICAgICB9IGVsc2UgaWYgKHRvU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHRvO1xuICAgICAgICBlZGdlLmVkZ2VUeXBlLnRvID0gdG87XG4gICAgICB9IC8vIHdlIHVzZSB0aGUgc2VsZWN0aW9uIHRvIGZpbmQgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBXZSBleHBsaWNpdGx5IHNlbGVjdCBpdCBoZXJlLlxuXG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkcmFnZ2luZyB0aGUgY29udHJvbCBub2RlcyBvciB0aGUgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnKGV2ZW50KSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGlzYWJsZVBoeXNpY3NcIik7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLnggPSBwb3MueDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLnkgPSBwb3MueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9uRHJhZyhldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25uZWN0aW5nIG9yIHJlc3RvcmluZyB0aGUgY29udHJvbCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVEcmFnRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWdFbmQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07IC8vIGlmIHRoZSBub2RlIHRoYXQgd2FzIGRyYWdnZWQgaXMgbm90IGEgY29udHJvbCBub2RlLCByZXR1cm5cblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgREVzZWxlY3QgdGhlIGNvbnRyb2wgbm9kZSBoZXJlLlxuXG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZUlkc1tpXSAhPT0gdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHBlcmZvcm0gdGhlIGNvbm5lY3Rpb25cblxuXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTtcblxuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQgPT09IGZyb20uaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShub2RlLmlkLCBlZGdlLnRvLmlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKGVkZ2UuZnJvbS5pZCwgbm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnVwZGF0ZUVkZ2VUeXBlKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXN0b3JlUGh5c2ljc1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoZSBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2VsZWN0aW9uIGV2ZW50LiBJdCBjaGVja3MgaWYgeW91IHdhbnQgdG8gY29ubmVjdCBhIGNsdXN0ZXIgYW5kIGNoYW5nZXMgdGhlIGRlc2NyaXB0aW9uXG4gICAgICogdG8gd2FsayB0aGUgdXNlciB0aHJvdWdoIHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3QoZXZlbnQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwMCkge1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IGFzc2lnbiQyKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLmRyYWcucG9pbnRlciA9IHRoaXMubGFzdFRvdWNoOyAvLyBEcmFnIHBvaW50ZXIgaXMgbm90IHVwZGF0ZWQgd2hlbiBhZGRpbmcgZWRnZXNcblxuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5kcmFnLnRyYW5zbGF0aW9uID0gdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb247XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY3JlYXRlRWRnZUVycm9yXCJdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbm9kZSB0aGUgdGVtcG9yYXJ5IGxpbmUgY2FuIGxvb2sgYXRcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShub2RlLngsIG5vZGUueSk7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0YXJnZXROb2RlLmlkXSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaCh0YXJnZXROb2RlLmlkKTsgLy8gY3JlYXRlIGEgdGVtcG9yYXJ5IGVkZ2VcblxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25FZGdlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlKHtcbiAgICAgICAgICAgICAgaWQ6IFwiY29ubmVjdGlvbkVkZ2VcIiArIHY0KCksXG4gICAgICAgICAgICAgIGZyb206IG5vZGUuaWQsXG4gICAgICAgICAgICAgIHRvOiB0YXJnZXROb2RlLmlkLFxuICAgICAgICAgICAgICBwaHlzaWNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnRpbnVvdXNcIixcbiAgICAgICAgICAgICAgICByb3VuZG5lc3M6IDAuNVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tjb25uZWN0aW9uRWRnZS5pZF0gPSBjb25uZWN0aW9uRWRnZTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGNvbm5lY3Rpb25FZGdlLmlkKTtcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2godGFyZ2V0Tm9kZS5pZCk7XG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlcy5wdXNoKGNvbm5lY3Rpb25FZGdlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmFnQ29udHJvbE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdDb250cm9sTm9kZShldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpOyAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuXG5cbiAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICB9IC8vIGdldCB0aGUgb3ZlcmxhcHBpbmcgbm9kZSBidXQgTk9UIHRoZSB0ZW1wb3Jhcnkgbm9kZTtcblxuXG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MzA7XG5cbiAgICAgICAgLy8gaWYgdGhlIG5vZGUgaWQgaXMgTk9UIGEgdGVtcG9yYXJ5IG5vZGUsIGFjY2VwdCB0aGUgbm9kZS5cbiAgICAgICAgaWYgKGluZGV4T2YoX2NvbnRleHQzMCA9IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzKS5jYWxsKF9jb250ZXh0MzAsIG92ZXJsYXBwaW5nTm9kZUlkc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LmNvbnRyb2xFZGdlID0ge1xuICAgICAgICBmcm9tOiBjb25uZWN0RnJvbUlkLFxuICAgICAgICB0bzogbm9kZSA/IG5vZGUuaWQgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY29udHJvbE5vZGVEcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTsgLy8gdGhlcmUgaXMgb25seSBvbmUgdGVtcCBub2RlIGluIHRoZSBhZGQgZWRnZSBtb2RlLlxuXG4gICAgICAgIHRhcmdldE5vZGUueCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICAgIHRhcmdldE5vZGUueSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0aGUgbmV3IGVkZ2UgdG8gdGhlIHRhcmdldCBpZiBvbmUgZXhpc3RzLCBvdGhlcndpc2UgcmVtb3ZlIHRlbXAgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5pc2hDb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5pc2hDb25uZWN0KGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7IC8vIHJlbWVtYmVyIHRoZSBlZGdlIGlkXG5cblxuICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbm5lY3RGcm9tSWQgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZDtcbiAgICAgIH0gLy8gZ2V0IHRoZSBvdmVybGFwcGluZyBub2RlIGJ1dCBOT1QgdGhlIHRlbXBvcmFyeSBub2RlO1xuXG5cbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzMTtcblxuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAoaW5kZXhPZihfY29udGV4dDMxID0gdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMpLmNhbGwoX2NvbnRleHQzMSwgb3ZlcmxhcHBpbmdOb2RlSWRzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2xlYW4gdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlcy5cblxuXG4gICAgICB0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpOyAvLyBwZXJmb3JtIHRoZSBjb25uZWN0aW9uXG5cblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY3JlYXRlRWRnZUVycm9yXCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2Nvbm5lY3RGcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW25vZGUuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1BZGRFZGdlKGNvbm5lY3RGcm9tSWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHtcbiAgICAgICAgZnJvbTogY29ubmVjdEZyb21JZCxcbiAgICAgICAgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ0VuZFwiLCBldmVudCwgcG9pbnRlcik7IC8vIE5vIG5lZWQgdG8gZG8gX2dlbmVyYXRlY2xpY2tldmVudCgnZHJhZ0VuZCcpIGhlcmUsIHRoZSByZWd1bGFyIGRyYWdFbmQgZXZlbnQgZmlyZXMuXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmFnU3RhcnRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmFnU3RhcnRFZGdlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQZXJmb3JtaW5nIGFsbCB0aGUgYWN0dWFsIGRhdGEgbWFuaXB1bGF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbm9kZSBvbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xpY2tEYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtQWRkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdjQoKSxcbiAgICAgICAgeDogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLngsXG4gICAgICAgIHk6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy55LFxuICAgICAgICBsYWJlbDogXCJuZXdcIlxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkTm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkTm9kZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczQuaW5Nb2RlID09PSBcImFkZE5vZGVcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgX3RoaXM0LmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpczQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgYWRkIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0d28gbm9kZXMgd2l0aCBhIG5ldyBlZGdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBzb3VyY2VOb2RlSWRcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHRhcmdldE5vZGVJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybUFkZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWRcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZEVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZEVkZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFkZEVkZ2UoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM1LmluTW9kZSA9PT0gXCJhZGRFZGdlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIF90aGlzNS5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcblxuICAgICAgICAgICAgICBfdGhpczUuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgICAgIF90aGlzNS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBjb25uZWN0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc291cmNlTm9kZUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0YXJnZXROb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1FZGl0RWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUVkaXRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCxcbiAgICAgICAgZnJvbTogc291cmNlTm9kZUlkLFxuICAgICAgICB0bzogdGFyZ2V0Tm9kZUlkLFxuICAgICAgICBsYWJlbDogdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0KHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQpLmxhYmVsXG4gICAgICB9O1xuICAgICAgdmFyIGVlRnVuY3QgPSB0aGlzLm9wdGlvbnMuZWRpdEVkZ2U7XG5cbiAgICAgIGlmIChfdHlwZW9mKGVlRnVuY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGVlRnVuY3QgPSBlZUZ1bmN0LmVkaXRXaXRob3V0RHJhZztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlZUZ1bmN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGVlRnVuY3QubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZWVGdW5jdChkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhID09PSBudWxsIHx8IGZpbmFsaXplZERhdGEgPT09IHVuZGVmaW5lZCB8fCBfdGhpczYuaW5Nb2RlICE9PSBcImVkaXRFZGdlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmVkZ2VzW2RlZmF1bHREYXRhLmlkXS51cGRhdGVFZGdlVHlwZSgpO1xuXG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG5cbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcblxuICAgICAgICAgICAgICBfdGhpczYuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgICAgIF90aGlzNi5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGRlZmF1bHREYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYW5pcHVsYXRpb25TeXN0ZW07XG59KCk7XG5cbi8qKlxyXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXHJcbiAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cclxuICpcclxuICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXHJcbiAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xyXG4gKi9cbnZhciBzdHJpbmcgPSBcInN0cmluZ1wiO1xudmFyIGJvb2wgPSBcImJvb2xlYW5cIjtcbnZhciBudW1iZXIgPSBcIm51bWJlclwiO1xudmFyIGFycmF5ID0gXCJhcnJheVwiO1xudmFyIG9iamVjdCA9IFwib2JqZWN0XCI7IC8vIHNob3VsZCBvbmx5IGJlIGluIGEgX190eXBlX18gcHJvcGVydHlcblxudmFyIGRvbSA9IFwiZG9tXCI7XG52YXIgYW55ID0gXCJhbnlcIjsgLy8gTGlzdCBvZiBlbmRwb2ludHNcblxudmFyIGVuZFBvaW50cyA9IFtcImFycm93XCIsIFwiYmFyXCIsIFwiYm94XCIsIFwiY2lyY2xlXCIsIFwiY3Jvd1wiLCBcImN1cnZlXCIsIFwiZGlhbW9uZFwiLCBcImltYWdlXCIsIFwiaW52X2N1cnZlXCIsIFwiaW52X3RyaWFuZ2xlXCIsIFwidHJpYW5nbGVcIiwgXCJ2ZWVcIl07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gLS0gVGhlIF9fKl9fIGZvcm1hdCBpcyB1c2VkIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIGFjdHVhbCBvcHRpb24gbmFtZXMuICovXG5cbnZhciBub2RlT3B0aW9ucyA9IHtcbiAgYm9yZGVyV2lkdGg6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICBib3JkZXJXaWR0aFNlbGVjdGVkOiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGJyb2tlbkltYWdlOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGNob3Nlbjoge1xuICAgIGxhYmVsOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgbm9kZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgYm9yZGVyOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGhpZ2hsaWdodDoge1xuICAgICAgYm9yZGVyOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgaG92ZXI6IHtcbiAgICAgIGJvcmRlcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfVxuICB9LFxuICBvcGFjaXR5OiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGZpeGVkOiB7XG4gICAgeDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgeToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgZm9udDoge1xuICAgIGFsaWduOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgZmFjZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzdHJva2VXaWR0aDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgdmFkanVzdDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG11bHRpOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGJvbGQ6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBib2xkaXRhbDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1vZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0YWw6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBtb25vOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9XG4gIH0sXG4gIGdyb3VwOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGhlaWdodENvbnN0cmFpbnQ6IHtcbiAgICBtaW5pbXVtOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgdmFsaWduOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICBoaWRkZW46IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGljb246IHtcbiAgICBmYWNlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgY29kZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHdlaWdodDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBpZDoge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIGltYWdlOiB7XG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICB1bnNlbGVjdGVkOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9XG4gIH0sXG4gIGltYWdlUGFkZGluZzoge1xuICAgIHRvcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICBsYWJlbDoge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGxldmVsOiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIG1hcmdpbjoge1xuICAgIHRvcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICBtYXNzOiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgcGh5c2ljczoge1xuICAgIGJvb2xlYW46IGJvb2xcbiAgfSxcbiAgc2NhbGluZzoge1xuICAgIG1pbjoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBtaW46IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXhWaXNpYmxlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZHJhd1RocmVzaG9sZDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgc2hhZG93OiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgeDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBzaGFwZToge1xuICAgIHN0cmluZzogW1wiY3VzdG9tXCIsIFwiZWxsaXBzZVwiLCBcImNpcmNsZVwiLCBcImRhdGFiYXNlXCIsIFwiYm94XCIsIFwidGV4dFwiLCBcImltYWdlXCIsIFwiY2lyY3VsYXJJbWFnZVwiLCBcImRpYW1vbmRcIiwgXCJkb3RcIiwgXCJzdGFyXCIsIFwidHJpYW5nbGVcIiwgXCJ0cmlhbmdsZURvd25cIiwgXCJzcXVhcmVcIiwgXCJpY29uXCIsIFwiaGV4YWdvblwiXVxuICB9LFxuICBjdHhSZW5kZXJlcjoge1xuICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgYm9yZGVyRGFzaGVzOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgYXJyYXk6IGFycmF5XG4gICAgfSxcbiAgICBib3JkZXJSYWRpdXM6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB1c2VJbWFnZVNpemU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHVzZUJvcmRlcldpdGhJbWFnZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgY29vcmRpbmF0ZU9yaWdpbjoge1xuICAgICAgc3RyaW5nOiBbXCJjZW50ZXJcIiwgXCJ0b3AtbGVmdFwiXVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBzaXplOiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBkb206IGRvbSxcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgdmFsdWU6IHtcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgbWluaW11bToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG1heGltdW06IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9XG4gIH0sXG4gIHg6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICB5OiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgX190eXBlX186IHtcbiAgICBvYmplY3Q6IG9iamVjdFxuICB9XG59O1xudmFyIGFsbE9wdGlvbnMgPSB7XG4gIGNvbmZpZ3VyZToge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGZpbHRlcjoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICBkb206IGRvbVxuICAgIH0sXG4gICAgc2hvd0J1dHRvbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH1cbiAgfSxcbiAgZWRnZXM6IHtcbiAgICBhcnJvd3M6IHtcbiAgICAgIHRvOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlRmFjdG9yOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0cmluZzogZW5kUG9pbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlSGVpZ2h0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VXaWR0aDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWlkZGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlRmFjdG9yOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0cmluZzogZW5kUG9pbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlV2lkdGg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBpbWFnZUhlaWdodDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZnJvbToge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZUZhY3Rvcjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdHJpbmc6IGVuZFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZVdpZHRoOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIHN0cmluZzogW1wiZnJvbVwiLCBcInRvXCIsIFwibWlkZGxlXCJdLFxuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZW5kUG9pbnRPZmZzZXQ6IHtcbiAgICAgIGZyb206IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB0bzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfVxuICAgIH0sXG4gICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgYXJyYXk6IGFycmF5XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIGNob3Nlbjoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIGVkZ2U6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGluaGVyaXQ6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJib3RoXCJdLFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgZGFzaGVzOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgYXJyYXk6IGFycmF5XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBhbGlnbjoge1xuICAgICAgICBzdHJpbmc6IFtcImhvcml6b250YWxcIiwgXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl1cbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbXVsdGk6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBib2xkOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9ubzoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZGVuOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBob3ZlcldpZHRoOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBsZW5ndGg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBwaHlzaWNzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBtaW46IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBtYXhWaXNpYmxlOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiB7XG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCIsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYW5nbGU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBzbW9vdGg6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJkeW5hbWljXCIsIFwiY29udGludW91c1wiLCBcImRpc2NyZXRlXCIsIFwiZGlhZ29uYWxDcm9zc1wiLCBcInN0cmFpZ2h0Q3Jvc3NcIiwgXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJjdXJ2ZWRDV1wiLCBcImN1cnZlZENDV1wiLCBcImN1YmljQmV6aWVyXCJdXG4gICAgICB9LFxuICAgICAgcm91bmRuZXNzOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZm9yY2VEaXJlY3Rpb246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJub25lXCJdLFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB3aWR0aENvbnN0cmFpbnQ6IHtcbiAgICAgIG1heGltdW06IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBncm91cHM6IHtcbiAgICB1c2VEZWZhdWx0R3JvdXBzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBfX2FueV9fOiBub2RlT3B0aW9ucyxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgZHJhZ05vZGVzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBkcmFnVmlldzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaGlkZUVkZ2VzT25EcmFnOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBoaWRlRWRnZXNPblpvb206IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhpZGVOb2Rlc09uRHJhZzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaG92ZXI6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBzcGVlZDoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiaW5kVG9XaW5kb3c6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGF1dG9Gb2N1czoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIG11bHRpc2VsZWN0OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2VsZWN0YWJsZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhvdmVyQ29ubmVjdGVkRWRnZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHRvb2x0aXBEZWxheToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHpvb21WaWV3OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB6b29tU3BlZWQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGxheW91dDoge1xuICAgIHJhbmRvbVNlZWQ6IHtcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIixcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGltcHJvdmVkTGF5b3V0OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBjbHVzdGVyVGhyZXNob2xkOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBsZXZlbFNlcGFyYXRpb246IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlU3BhY2luZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHRyZWVTcGFjaW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYmxvY2tTaGlmdGluZzoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgZWRnZU1pbmltaXphdGlvbjoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbjoge1xuICAgICAgICBzdHJpbmc6IFtcIlVEXCIsIFwiRFVcIiwgXCJMUlwiLCBcIlJMXCJdXG4gICAgICB9LFxuICAgICAgc29ydE1ldGhvZDoge1xuICAgICAgICBzdHJpbmc6IFtcImh1YnNpemVcIiwgXCJkaXJlY3RlZFwiXVxuICAgICAgfSxcbiAgICAgIHNoYWtlVG93YXJkczoge1xuICAgICAgICBzdHJpbmc6IFtcImxlYXZlc1wiLCBcInJvb3RzXCJdXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgbWFuaXB1bGF0aW9uOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaW5pdGlhbGx5QWN0aXZlOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBhZGROb2RlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgYWRkRWRnZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGVkaXROb2RlOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBlZGl0RWRnZToge1xuICAgICAgZWRpdFdpdGhvdXREcmFnOiB7XG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlTm9kZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGRlbGV0ZUVkZ2U6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBjb250cm9sTm9kZVN0eWxlOiBub2RlT3B0aW9ucyxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBub2Rlczogbm9kZU9wdGlvbnMsXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIHRoZXRhOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhdm9pZE92ZXJsYXA6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgdGhldGE6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlRGlzdGFuY2U6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG5vZGVEaXN0YW5jZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhdm9pZE92ZXJsYXA6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgbWF4VmVsb2NpdHk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtaW5WZWxvY2l0eToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHNvbHZlcjoge1xuICAgICAgc3RyaW5nOiBbXCJiYXJuZXNIdXRcIiwgXCJyZXB1bHNpb25cIiwgXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIiwgXCJmb3JjZUF0bGFzMkJhc2VkXCJdXG4gICAgfSxcbiAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBpdGVyYXRpb25zOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgdXBkYXRlSW50ZXJ2YWw6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBvbmx5RHluYW1pY0VkZ2VzOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBmaXQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICB0aW1lc3RlcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGFkYXB0aXZlVGltZXN0ZXA6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHdpbmQ6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIC8vZ2xvYmFscyA6XG4gIGF1dG9SZXNpemU6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGNsaWNrVG9Vc2U6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGxvY2FsZToge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIGxvY2FsZXM6IHtcbiAgICBfX2FueV9fOiB7XG4gICAgICBhbnk6IGFueVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBoZWlnaHQ6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICB3aWR0aDoge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIF9fdHlwZV9fOiB7XG4gICAgb2JqZWN0OiBvYmplY3RcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5cbi8qKlxyXG4gKiBUaGlzIHByb3ZpZGVzIHJhbmdlcywgaW5pdGlhbCB2YWx1ZXMsIHN0ZXBzIGFuZCBkcm9wZG93biBtZW51IGNob2ljZXMgZm9yIHRoZVxyXG4gKiBjb25maWd1cmF0aW9uLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBDaGVja2JveDogYGJvb2xlYW5gXHJcbiAqICAgVGhlIHZhbHVlIHN1cGxsaWVkIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cclxuICpcclxuICogVGV4dCBmaWVsZDogYHN0cmluZ2BcclxuICogICBUaGUgcGFzc2VkIHRleHQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlLiBBbnkgdGV4dCB3aWxsIGJlXHJcbiAqICAgYWNjZXB0ZWQgYWZ0ZXJ3YXJkcy5cclxuICpcclxuICogTnVtYmVyIHJhbmdlOiBgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1gXHJcbiAqICAgVGhlIG1lYW5pbmdzIGFyZSBgW2luaXRpYWwgdmFsdWUsIG1pbiwgbWF4LCBzdGVwXWAuXHJcbiAqXHJcbiAqIERyb3Bkb3duOiBgW0V4Y2x1ZGU8c3RyaW5nLCBcImNvbG9yXCI+LCAuLi4oc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbilbXV1gXHJcbiAqICAgVHJhbnNsYXRpb25zIGZvciBwZW9wbGUgd2l0aCBwb29yIHVuZGVyc3RhbmRpbmcgb2YgVHlwZVNjcmlwdDogdGhlIGZpcnN0XHJcbiAqICAgdmFsdWUgYWx3YXlzIGhhcyB0byBiZSBhIHN0cmluZyBidXQgbmV2ZXIgYFwiY29sb3JcImAsIHRoZSByZXN0IGNhbiBiZSBhbnlcclxuICogICBjb21iaW5hdGlvbiBvZiBzdHJpbmdzLCBudW1iZXJzIGFuZCBib29sZWFucy5cclxuICpcclxuICogQ29sb3IgcGlja2VyOiBgW1wiY29sb3JcIiwgc3RyaW5nXWBcclxuICogICBUaGUgZmlyc3QgdmFsdWUgc2F5cyB0aGlzIHdpbGwgYmUgYSBjb2xvciBwaWNrZXIgbm90IGEgZHJvcGRvd24gbWVudS4gVGhlXHJcbiAqICAgbmV4dCB2YWx1ZSBpcyB0aGUgaW5pdGlhbCBjb2xvci5cclxuICovXG5cbnZhciBjb25maWd1cmVPcHRpb25zID0ge1xuICBub2Rlczoge1xuICAgIGJvcmRlcldpZHRoOiBbMSwgMCwgMTAsIDFdLFxuICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IFsyLCAwLCAxMCwgMV0sXG4gICAgY29sb3I6IHtcbiAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCIjOTdDMkZDXCJdLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiNEMkU1RkZcIl1cbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFtcImNvbG9yXCIsIFwiIzJCN0NFOVwiXSxcbiAgICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCIjRDJFNUZGXCJdXG4gICAgICB9XG4gICAgfSxcbiAgICBvcGFjaXR5OiBbMCwgMCwgMSwgMC4xXSxcbiAgICBmaXhlZDoge1xuICAgICAgeDogZmFsc2UsXG4gICAgICB5OiBmYWxzZVxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgY29sb3I6IFtcImNvbG9yXCIsIFwiIzM0MzQzNFwiXSxcbiAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSxcbiAgICAgIGZhY2U6IFtcImFyaWFsXCIsIFwidmVyZGFuYVwiLCBcInRhaG9tYVwiXSxcbiAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwibm9uZVwiXSxcbiAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLFxuICAgICAgc3Ryb2tlQ29sb3I6IFtcImNvbG9yXCIsIFwiI2ZmZmZmZlwiXVxuICAgIH0sXG4gICAgLy9ncm91cDogJ3N0cmluZycsXG4gICAgaGlkZGVuOiBmYWxzZSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgLy9pY29uOiB7XG4gICAgLy8gIGZhY2U6ICdzdHJpbmcnLCAgLy8nRm9udEF3ZXNvbWUnLFxuICAgIC8vICBjb2RlOiAnc3RyaW5nJywgIC8vJ1xcdWYwMDcnLFxuICAgIC8vICBzaXplOiBbNTAsIDAsIDIwMCwgMV0sICAvLzUwLFxuICAgIC8vICBjb2xvcjogWydjb2xvcicsJyMyQjdDRTknXSAgIC8vJyNhYTAwZmYnXG4gICAgLy99LFxuICAgIC8vaW1hZ2U6ICdzdHJpbmcnLCAvLyAtLT4gVVJMXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxMCwgMCwgMjAwLCAxXSxcbiAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4VmlzaWJsZTogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc2hhcGU6IFtcImVsbGlwc2VcIiwgXCJib3hcIiwgXCJjaXJjbGVcIiwgXCJkYXRhYmFzZVwiLCBcImRpYW1vbmRcIiwgXCJkb3RcIiwgXCJzcXVhcmVcIiwgXCJzdGFyXCIsIFwidGV4dFwiLCBcInRyaWFuZ2xlXCIsIFwidHJpYW5nbGVEb3duXCIsIFwiaGV4YWdvblwiXSxcbiAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICBib3JkZXJSYWRpdXM6IFs2LCAwLCAyMCwgMV0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZVxuICAgIH0sXG4gICAgc2l6ZTogWzI1LCAwLCAyMDAsIDFdXG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSxcbiAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICB9LFxuICAgICAgbWlkZGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLFxuICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgIH0sXG4gICAgICBmcm9tOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLFxuICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZFBvaW50T2Zmc2V0OiB7XG4gICAgICBmcm9tOiBbMCwgLTEwLCAxMCwgMV0sXG4gICAgICB0bzogWzAsIC0xMCwgMTAsIDFdXG4gICAgfSxcbiAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRydWUsXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiBbXCJjb2xvclwiLCBcIiM4NDg0ODRcIl0sXG4gICAgICBoaWdobGlnaHQ6IFtcImNvbG9yXCIsIFwiIzg0ODQ4NFwiXSxcbiAgICAgIGhvdmVyOiBbXCJjb2xvclwiLCBcIiM4NDg0ODRcIl0sXG4gICAgICBpbmhlcml0OiBbXCJmcm9tXCIsIFwidG9cIiwgXCJib3RoXCIsIHRydWUsIGZhbHNlXSxcbiAgICAgIG9wYWNpdHk6IFsxLCAwLCAxLCAwLjA1XVxuICAgIH0sXG4gICAgZGFzaGVzOiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjMzQzNDM0XCJdLFxuICAgICAgc2l6ZTogWzE0LCAwLCAxMDAsIDFdLFxuICAgICAgZmFjZTogW1wiYXJpYWxcIiwgXCJ2ZXJkYW5hXCIsIFwidGFob21hXCJdLFxuICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCJub25lXCJdLFxuICAgICAgc3Ryb2tlV2lkdGg6IFsyLCAwLCA1MCwgMV0sXG4gICAgICBzdHJva2VDb2xvcjogW1wiY29sb3JcIiwgXCIjZmZmZmZmXCJdLFxuICAgICAgYWxpZ246IFtcImhvcml6b250YWxcIiwgXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl1cbiAgICB9LFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgaG92ZXJXaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgbWF4OiBbMTUsIDAsIDEwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICBzaXplOiBbMjAsIDAsIDIwMCwgMV0sXG4gICAgICBhbmdsZTogW01hdGguUEkgLyAyLCAtNiAqIE1hdGguUEksIDYgKiBNYXRoLlBJLCBNYXRoLlBJIC8gOF0sXG4gICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB0cnVlXG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgdHlwZTogW1wiZHluYW1pY1wiLCBcImNvbnRpbnVvdXNcIiwgXCJkaXNjcmV0ZVwiLCBcImRpYWdvbmFsQ3Jvc3NcIiwgXCJzdHJhaWdodENyb3NzXCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiY3VydmVkQ1dcIiwgXCJjdXJ2ZWRDQ1dcIiwgXCJjdWJpY0JlemllclwiXSxcbiAgICAgIGZvcmNlRGlyZWN0aW9uOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJub25lXCJdLFxuICAgICAgcm91bmRuZXNzOiBbMC41LCAwLCAxLCAwLjA1XVxuICAgIH0sXG4gICAgd2lkdGg6IFsxLCAwLCAzMCwgMV1cbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAgLy9yYW5kb21TZWVkOiBbMCwgMCwgNTAwLCAxXSxcbiAgICAvL2ltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBsZXZlbFNlcGFyYXRpb246IFsxNTAsIDIwLCA1MDAsIDVdLFxuICAgICAgbm9kZVNwYWNpbmc6IFsxMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgdHJlZVNwYWNpbmc6IFsyMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHRydWUsXG4gICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgIGRpcmVjdGlvbjogW1wiVURcIiwgXCJEVVwiLCBcIkxSXCIsIFwiUkxcIl0sXG4gICAgICBzb3J0TWV0aG9kOiBbXCJodWJzaXplXCIsIFwiZGlyZWN0ZWRcIl0sXG4gICAgICBzaGFrZVRvd2FyZHM6IFtcImxlYXZlc1wiLCBcInJvb3RzXCJdIC8vIGxlYXZlcywgcm9vdHNcblxuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2UsXG4gICAgaG92ZXI6IGZhbHNlLFxuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHNwZWVkOiB7XG4gICAgICAgIHg6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB5OiBbMTAsIDAsIDQwLCAxXSxcbiAgICAgICAgem9vbTogWzAuMDIsIDAsIDAuMSwgMC4wMDVdXG4gICAgICB9LFxuICAgICAgYmluZFRvV2luZG93OiB0cnVlLFxuICAgICAgYXV0b0ZvY3VzOiB0cnVlXG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICB0b29sdGlwRGVsYXk6IFszMDAsIDAsIDEwMDAsIDI1XSxcbiAgICB6b29tVmlldzogdHJ1ZSxcbiAgICB6b29tU3BlZWQ6IFsxLCAwLjEsIDIsIDAuMV1cbiAgfSxcbiAgbWFuaXB1bGF0aW9uOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZVxuICB9LFxuICBwaHlzaWNzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIHRoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiBbLTIwMDAsIC0zMDAwMCwgMCwgNTBdLFxuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjMsIDAsIDEwLCAwLjA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzk1LCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA0LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICB0aGV0YTogWzAuNSwgMC4xLCAxLCAwLjA1XSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy01MCwgLTUwMCwgMCwgMV0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMDEsIDAsIDEsIDAuMDA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzk1LCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA4LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjQsIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIHJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjIsIDAsIDEwLCAwLjA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzIwMCwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wNSwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBub2RlRGlzdGFuY2U6IFsxMDAsIDAsIDUwMCwgNV0sXG4gICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjIsIDAsIDEwLCAwLjA1XSxcbiAgICAgIHNwcmluZ0xlbmd0aDogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wMSwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBub2RlRGlzdGFuY2U6IFsxMjAsIDAsIDUwMCwgNV0sXG4gICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV0sXG4gICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgbWF4VmVsb2NpdHk6IFs1MCwgMCwgMTUwLCAxXSxcbiAgICBtaW5WZWxvY2l0eTogWzAuMSwgMC4wMSwgMC41LCAwLjAxXSxcbiAgICBzb2x2ZXI6IFtcImJhcm5lc0h1dFwiLCBcImZvcmNlQXRsYXMyQmFzZWRcIiwgXCJyZXB1bHNpb25cIiwgXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIl0sXG4gICAgdGltZXN0ZXA6IFswLjUsIDAuMDEsIDEsIDAuMDFdLFxuICAgIHdpbmQ6IHtcbiAgICAgIHg6IFswLCAtMTAsIDEwLCAwLjFdLFxuICAgICAgeTogWzAsIC0xMCwgMTAsIDAuMV1cbiAgICB9IC8vYWRhcHRpdmVUaW1lc3RlcDogdHJ1ZVxuXG4gIH1cbn07XG52YXIgY29uZmlndXJhdG9ySGlkZU9wdGlvbiA9IGZ1bmN0aW9uIGNvbmZpZ3VyYXRvckhpZGVPcHRpb24ocGFyZW50UGF0aCwgb3B0aW9uTmFtZSwgb3B0aW9ucykge1xuICB2YXIgX2NvbnRleHQ7XG5cbiAgaWYgKGluY2x1ZGVzKHBhcmVudFBhdGgpLmNhbGwocGFyZW50UGF0aCwgXCJwaHlzaWNzXCIpICYmIGluY2x1ZGVzKF9jb250ZXh0ID0gY29uZmlndXJlT3B0aW9ucy5waHlzaWNzLnNvbHZlcikuY2FsbChfY29udGV4dCwgb3B0aW9uTmFtZSkgJiYgb3B0aW9ucy5waHlzaWNzLnNvbHZlciAhPT0gb3B0aW9uTmFtZSAmJiBvcHRpb25OYW1lICE9PSBcIndpbmRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIG9wdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Y29uZmlndXJhdG9ySGlkZU9wdGlvbjogY29uZmlndXJhdG9ySGlkZU9wdGlvbixcblx0YWxsT3B0aW9uczogYWxsT3B0aW9ucyxcblx0Y29uZmlndXJlT3B0aW9uczogY29uZmlndXJlT3B0aW9uc1xufSk7XG5cbi8qKlxuICogIFRoZSBGbG95ZOKAk1dhcnNoYWxsIGFsZ29yaXRobSBpcyBhbiBhbGdvcml0aG0gZm9yIGZpbmRpbmcgc2hvcnRlc3QgcGF0aHMgaW5cbiAqICBhIHdlaWdodGVkIGdyYXBoIHdpdGggcG9zaXRpdmUgb3IgbmVnYXRpdmUgZWRnZSB3ZWlnaHRzIChidXQgd2l0aCBubyBuZWdhdGl2ZVxuICogIGN5Y2xlcykuIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxveWTigJNXYXJzaGFsbF9hbGdvcml0aG1cbiAqL1xudmFyIEZsb3lkV2Fyc2hhbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gRmxveWRXYXJzaGFsbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxveWRXYXJzaGFsbCk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc0FycmF5XG4gICAqIEBwYXJhbSB7QXJyYXkuPEVkZ2U+fSBlZGdlc0FycmF5XG4gICAqIEByZXR1cm5zIHt7fX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRmxveWRXYXJzaGFsbCwgW3tcbiAgICBrZXk6IFwiZ2V0RGlzdGFuY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlcyhib2R5LCBub2Rlc0FycmF5LCBlZGdlc0FycmF5KSB7XG4gICAgICB2YXIgRF9tYXRyaXggPSB7fTtcbiAgICAgIHZhciBlZGdlcyA9IGJvZHkuZWRnZXM7IC8vIHByZXBhcmUgbWF0cml4IHdpdGggbGFyZ2UgbnVtYmVyc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHt9O1xuICAgICAgICBEX21hdHJpeFtub2RlXSA9IGNlbGw7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2VsbFtub2Rlc0FycmF5W2pdXSA9IGkgPT0gaiA/IDAgOiAxZTk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcHV0IHRoZSB3ZWlnaHRzIGZvciB0aGUgZWRnZXMgaW4uIFRoaXMgYXNzdW1lcyB1bmlkaXJlY3Rpb25hbGl0eS5cblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXNBcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlc0FycmF5W19pXV07IC8vIGVkZ2UgaGFzIHRvIGJlIGNvbm5lY3RlZCBpZiBpdCBjb3VudHMgdG8gdGhlIGRpc3RhbmNlcy4gSWYgaXQgaXMgY29ubmVjdGVkIHRvIGlubmVyIGNsdXN0ZXJzIGl0IHdpbGwgY3Jhc2ggc28gd2UgYWxzbyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgRF9tYXRyaXhcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgRF9tYXRyaXhbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgRF9tYXRyaXhbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgRF9tYXRyaXhbZWRnZS5mcm9tSWRdW2VkZ2UudG9JZF0gPSAxO1xuICAgICAgICAgIERfbWF0cml4W2VkZ2UudG9JZF1bZWRnZS5mcm9tSWRdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZXNBcnJheS5sZW5ndGg7IC8vIEFkYXB0ZWQgRmxveWRXYXJzaGFsbCBiYXNlZCBvbiB1bmlkaXJlY3Rpb25hbGl0eSB0byBncmVhdGx5IHJlZHVjZSBjb21wbGV4aXR5LlxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5vZGVDb3VudDsgaysrKSB7XG4gICAgICAgIHZhciBrbm9kZSA9IG5vZGVzQXJyYXlba107XG4gICAgICAgIHZhciBrY29sbSA9IERfbWF0cml4W2tub2RlXTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlQ291bnQgLSAxOyBfaTIrKykge1xuICAgICAgICAgIHZhciBpbm9kZSA9IG5vZGVzQXJyYXlbX2kyXTtcbiAgICAgICAgICB2YXIgaWNvbG0gPSBEX21hdHJpeFtpbm9kZV07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaiA9IF9pMiArIDE7IF9qIDwgbm9kZUNvdW50OyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgam5vZGUgPSBub2Rlc0FycmF5W19qXTtcbiAgICAgICAgICAgIHZhciBqY29sbSA9IERfbWF0cml4W2pub2RlXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoLm1pbihpY29sbVtqbm9kZV0sIGljb2xtW2tub2RlXSArIGtjb2xtW2pub2RlXSk7XG4gICAgICAgICAgICBpY29sbVtqbm9kZV0gPSB2YWw7XG4gICAgICAgICAgICBqY29sbVtpbm9kZV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEX21hdHJpeDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmxveWRXYXJzaGFsbDtcbn0oKTtcblxuLyoqXG4gKiBLYW1hZGFLYXdhaSBwb3NpdGlvbnMgdGhlIG5vZGVzIGluaXRpYWxseSBiYXNlZCBvblxuICpcbiAqIFwiQU4gQUxHT1JJVEhNIEZPUiBEUkFXSU5HIEdFTkVSQUwgVU5ESVJFQ1RFRCBHUkFQSFNcIlxuICogLS0gVG9taWhpc2EgS0FNQURBIGFuZCBTYXRvcnUgS0FXQUkgaW4gMTk4OVxuICpcbiAqIFBvc3NpYmxlIG9wdGltaXphdGlvbnMgaW4gdGhlIGRpc3RhbmNlIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXBsZW1lbnRlZC5cbiAqL1xuXG52YXIgS2FtYWRhS2F3YWkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VTdHJlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gS2FtYWRhS2F3YWkoYm9keSwgZWRnZUxlbmd0aCwgZWRnZVN0cmVuZ3RoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEthbWFkYUthd2FpKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5zcHJpbmdMZW5ndGggPSBlZGdlTGVuZ3RoO1xuICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBlZGdlU3RyZW5ndGg7XG4gICAgdGhpcy5kaXN0YW5jZVNvbHZlciA9IG5ldyBGbG95ZFdhcnNoYWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIE5vdCBzdXJlIGlmIG5lZWRlZCBidXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZSBzcHJpbmcgbGVuZ3RoIGFuZCBzcHJpbmcgY29uc3RhbnRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoS2FtYWRhS2F3YWksIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zcHJpbmdMZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IG9wdGlvbnMuc3ByaW5nTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQpIHtcbiAgICAgICAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gb3B0aW9ucy5zcHJpbmdDb25zdGFudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHZpcy5FZGdlPn0gZWRnZXNBcnJheVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZUNsdXN0ZXJzPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUobm9kZXNBcnJheSwgZWRnZXNBcnJheSkge1xuICAgICAgdmFyIGlnbm9yZUNsdXN0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIC8vIGdldCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBEX21hdHJpeCA9IHRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSk7IC8vIGRpc3RhbmNlIG1hdHJpeFxuICAgICAgLy8gZ2V0IHRoZSBMIE1hdHJpeFxuXG4gICAgICB0aGlzLl9jcmVhdGVMX21hdHJpeChEX21hdHJpeCk7IC8vIGdldCB0aGUgSyBNYXRyaXhcblxuXG4gICAgICB0aGlzLl9jcmVhdGVLX21hdHJpeChEX21hdHJpeCk7IC8vIGluaXRpYWwgRSBNYXRyaXhcblxuXG4gICAgICB0aGlzLl9jcmVhdGVFX21hdHJpeCgpOyAvLyBjYWxjdWxhdGUgcG9zaXRpb25zXG5cblxuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDE7XG4gICAgICB2YXIgaW5uZXJUaHJlc2hvbGQgPSAxO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCgxMDAwLCBNYXRoLm1pbigxMCAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsIDYwMDApKTtcbiAgICAgIHZhciBtYXhJbm5lckl0ZXJhdGlvbnMgPSA1O1xuICAgICAgdmFyIG1heEVuZXJneSA9IDFlOTtcbiAgICAgIHZhciBoaWdoRV9ub2RlSWQgPSAwLFxuICAgICAgICAgIGRFX2R4ID0gMCxcbiAgICAgICAgICBkRV9keSA9IDAsXG4gICAgICAgICAgZGVsdGFfbSA9IDAsXG4gICAgICAgICAgc3ViSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgIHdoaWxlIChtYXhFbmVyZ3kgPiB0aHJlc2hvbGQgJiYgaXRlcmF0aW9ucyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuXG4gICAgICAgIHZhciBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIgPSB0aGlzLl9nZXRIaWdoZXN0RW5lcmd5Tm9kZShpZ25vcmVDbHVzdGVycyk7XG5cbiAgICAgICAgdmFyIF90aGlzJF9nZXRIaWdoZXN0RW5lcjIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0SGlnaGVzdEVuZXIsIDQpO1xuXG4gICAgICAgIGhpZ2hFX25vZGVJZCA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbMF07XG4gICAgICAgIG1heEVuZXJneSA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbMV07XG4gICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlsyXTtcbiAgICAgICAgZEVfZHkgPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzNdO1xuICAgICAgICBkZWx0YV9tID0gbWF4RW5lcmd5O1xuICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcblxuICAgICAgICB3aGlsZSAoZGVsdGFfbSA+IGlubmVyVGhyZXNob2xkICYmIHN1Ykl0ZXJhdGlvbnMgPCBtYXhJbm5lckl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBzdWJJdGVyYXRpb25zICs9IDE7XG5cbiAgICAgICAgICB0aGlzLl9tb3ZlTm9kZShoaWdoRV9ub2RlSWQsIGRFX2R4LCBkRV9keSk7XG5cbiAgICAgICAgICB2YXIgX3RoaXMkX2dldEVuZXJneSA9IHRoaXMuX2dldEVuZXJneShoaWdoRV9ub2RlSWQpO1xuXG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEVuZXJneSwgMyk7XG5cbiAgICAgICAgICBkZWx0YV9tID0gX3RoaXMkX2dldEVuZXJneTJbMF07XG4gICAgICAgICAgZEVfZHggPSBfdGhpcyRfZ2V0RW5lcmd5MlsxXTtcbiAgICAgICAgICBkRV9keSA9IF90aGlzJF9nZXRFbmVyZ3kyWzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbm9kZSB3aXRoIHRoZSBoaWdoZXN0IGVuZXJneVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVDbHVzdGVyc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEhpZ2hlc3RFbmVyZ3lOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIaWdoZXN0RW5lcmd5Tm9kZShpZ25vcmVDbHVzdGVycykge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbWF4RW5lcmd5ID0gMDtcbiAgICAgIHZhciBtYXhFbmVyZ3lOb2RlSWQgPSBub2Rlc0FycmF5WzBdO1xuICAgICAgdmFyIGRFX2R4X21heCA9IDAsXG4gICAgICAgICAgZEVfZHlfbWF4ID0gMDtcblxuICAgICAgZm9yICh2YXIgbm9kZUlkeCA9IDA7IG5vZGVJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbm9kZUlkeCsrKSB7XG4gICAgICAgIHZhciBtID0gbm9kZXNBcnJheVtub2RlSWR4XTsgLy8gYnkgbm90IGV2YWx1YXRpbmcgbm9kZXMgd2l0aCBwcmVkZWZpbmVkIHBvc2l0aW9ucyB3ZSBzaG91bGQgb25seSBtb3ZlIG5vZGVzIHRoYXQgaGF2ZSBubyBwb3NpdGlvbnMuXG5cbiAgICAgICAgaWYgKG5vZGVzW21dLnByZWRlZmluZWRQb3NpdGlvbiAhPT0gdHJ1ZSB8fCBub2Rlc1ttXS5pc0NsdXN0ZXIgPT09IHRydWUgJiYgaWdub3JlQ2x1c3RlcnMgPT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC54ICE9PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0RW5lcmd5MyA9IHRoaXMuX2dldEVuZXJneShtKSxcbiAgICAgICAgICAgICAgX3RoaXMkX2dldEVuZXJneTQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0RW5lcmd5MywgMyksXG4gICAgICAgICAgICAgIGRlbHRhX20gPSBfdGhpcyRfZ2V0RW5lcmd5NFswXSxcbiAgICAgICAgICAgICAgZEVfZHggPSBfdGhpcyRfZ2V0RW5lcmd5NFsxXSxcbiAgICAgICAgICAgICAgZEVfZHkgPSBfdGhpcyRfZ2V0RW5lcmd5NFsyXTtcblxuICAgICAgICAgIGlmIChtYXhFbmVyZ3kgPCBkZWx0YV9tKSB7XG4gICAgICAgICAgICBtYXhFbmVyZ3kgPSBkZWx0YV9tO1xuICAgICAgICAgICAgbWF4RW5lcmd5Tm9kZUlkID0gbTtcbiAgICAgICAgICAgIGRFX2R4X21heCA9IGRFX2R4O1xuICAgICAgICAgICAgZEVfZHlfbWF4ID0gZEVfZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbWF4RW5lcmd5Tm9kZUlkLCBtYXhFbmVyZ3ksIGRFX2R4X21heCwgZEVfZHlfbWF4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBlbmVyZ3kgb2YgYSBzaW5nbGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBtXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RW5lcmd5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbmVyZ3kobSkge1xuICAgICAgdmFyIF90aGlzJEVfc3VtcyRtID0gX3NsaWNlZFRvQXJyYXkodGhpcy5FX3N1bXNbbV0sIDIpLFxuICAgICAgICAgIGRFX2R4ID0gX3RoaXMkRV9zdW1zJG1bMF0sXG4gICAgICAgICAgZEVfZHkgPSBfdGhpcyRFX3N1bXMkbVsxXTtcblxuICAgICAgdmFyIGRlbHRhX20gPSBNYXRoLnNxcnQoTWF0aC5wb3coZEVfZHgsIDIpICsgTWF0aC5wb3coZEVfZHksIDIpKTtcbiAgICAgIHJldHVybiBbZGVsdGFfbSwgZEVfZHgsIGRFX2R5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgbm9kZSBiYXNlZCBvbiBpdCdzIGVuZXJneVxuICAgICAqIHRoZSBkeCBhbmQgZHkgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGluZWFyIHN5c3RlbSBwcm9wb3NlZCBieSBLYW1hZGEgYW5kIEthd2FpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVOb2RlKG0sIGRFX2R4LCBkRV9keSkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZDJFX2R4MiA9IDA7XG4gICAgICB2YXIgZDJFX2R4ZHkgPSAwO1xuICAgICAgdmFyIGQyRV9keTIgPSAwO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBrbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuXG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuXG4gICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgdmFyIGttYXQgPSBrbVtpXTtcbiAgICAgICAgICB2YXIgbG1hdCA9IGxtW2ldO1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGgucG93KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpLCAxLjUpO1xuICAgICAgICAgIGQyRV9keDIgKz0ga21hdCAqICgxIC0gbG1hdCAqIE1hdGgucG93KHlfbSAtIHlfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgZDJFX2R4ZHkgKz0ga21hdCAqIChsbWF0ICogKHhfbSAtIHhfaSkgKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBkMkVfZHkyICs9IGttYXQgKiAoMSAtIGxtYXQgKiBNYXRoLnBvdyh4X20gLSB4X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2UgdGhlIHZhcmlhYmxlIG5hbWVzIGVhc2llciB0byBtYWtlIHRoZSBzb2x2aW5nIG9mIHRoZSBsaW5lYXIgc3lzdGVtIGVhc2llciB0byByZWFkXG5cblxuICAgICAgdmFyIEEgPSBkMkVfZHgyLFxuICAgICAgICAgIEIgPSBkMkVfZHhkeSxcbiAgICAgICAgICBDID0gZEVfZHgsXG4gICAgICAgICAgRCA9IGQyRV9keTIsXG4gICAgICAgICAgRSA9IGRFX2R5OyAvLyBzb2x2ZSB0aGUgbGluZWFyIHN5c3RlbSBmb3IgZHggYW5kIGR5XG5cbiAgICAgIHZhciBkeSA9IChDIC8gQSArIEUgLyBCKSAvIChCIC8gQSAtIEQgLyBCKTtcbiAgICAgIHZhciBkeCA9IC0oQiAqIGR5ICsgQykgLyBBOyAvLyBtb3ZlIHRoZSBub2RlXG5cbiAgICAgIG5vZGVzW21dLnggKz0gZHg7XG4gICAgICBub2Rlc1ttXS55ICs9IGR5OyAvLyBSZWNhbGN1bGF0ZSBFX21hdHJpeCAoc2hvdWxkIGJlIGluY3JlbWVudGFsKVxuXG4gICAgICB0aGlzLl91cGRhdGVFX21hdHJpeChtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBMIG1hdHJpeDogZWRnZSBsZW5ndGggdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVMX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VMZW5ndGggPSB0aGlzLnNwcmluZ0xlbmd0aDtcbiAgICAgIHRoaXMuTF9tYXRyaXggPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuTF9tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZUxlbmd0aCAqIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSyBtYXRyaXg6IHNwcmluZyBjb25zdGFudHMgdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVLX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VTdHJlbmd0aCA9IHRoaXMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICB0aGlzLktfbWF0cml4ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGVkZ2VTdHJlbmd0aCAqIE1hdGgucG93KERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dLCAtMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBtYXRyaXggd2l0aCBhbGwgZW5lcmdpZXMgYmV0d2VlbiBub2Rlc1xuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRV9tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVfbWF0cml4KCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB0aGlzLkVfbWF0cml4ID0ge307XG4gICAgICB0aGlzLkVfc3VtcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBtSWR4ID0gMDsgbUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBtSWR4KyspIHtcbiAgICAgICAgdGhpcy5FX21hdHJpeFtub2Rlc0FycmF5W21JZHhdXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbUlkeCA9IDA7IF9tSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IF9tSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W19tSWR4XTtcbiAgICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgICB2YXIgZEVfZHggPSAwO1xuICAgICAgICB2YXIgZEVfZHkgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlJZHggPSBfbUlkeDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG5cbiAgICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgICB0aGlzLkVfbWF0cml4W21dW2lJZHhdID0gW3RoaXMuS19tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kpICogZGVub21pbmF0b3IpLCB0aGlzLktfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKV07XG4gICAgICAgICAgICB0aGlzLkVfbWF0cml4W2ldW19tSWR4XSA9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF07XG4gICAgICAgICAgICBkRV9keCArPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdWzBdO1xuICAgICAgICAgICAgZEVfZHkgKz0gdGhpcy5FX21hdHJpeFttXVtpSWR4XVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9TdG9yZSBzdW1cblxuXG4gICAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBtZXRob2QsIGp1c3QgZG9pbmcgc2luZ2xlIGNvbHVtbiAocm93cyBhcmUgYXV0by11cGRhdGVkKSAodXBkYXRlIGFsbCBzdW1zKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUVfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVFX21hdHJpeChtKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBjb2xtID0gdGhpcy5FX21hdHJpeFttXTtcbiAgICAgIHZhciBrY29sbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbGNvbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICB2YXIgZEVfZHkgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuXG4gICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgLy9LZWVwIG9sZCBlbmVyZ3kgdmFsdWUgZm9yIHN1bSBtb2RpZmljYXRpb24gYmVsb3dcbiAgICAgICAgICB2YXIgY2VsbCA9IGNvbG1baUlkeF07XG4gICAgICAgICAgdmFyIG9sZER4ID0gY2VsbFswXTtcbiAgICAgICAgICB2YXIgb2xkRHkgPSBjZWxsWzFdOyAvL0NhbGMgbmV3IGVuZXJneTpcblxuICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgdmFyIGR4ID0ga2NvbG1baV0gKiAoeF9tIC0geF9pIC0gbGNvbG1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICB2YXIgZHkgPSBrY29sbVtpXSAqICh5X20gLSB5X2kgLSBsY29sbVtpXSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGNvbG1baUlkeF0gPSBbZHgsIGR5XTtcbiAgICAgICAgICBkRV9keCArPSBkeDtcbiAgICAgICAgICBkRV9keSArPSBkeTsgLy9hZGQgbmV3IGVuZXJneSB0byBzdW0gb2YgZWFjaCBjb2x1bW5cblxuICAgICAgICAgIHZhciBzdW0gPSB0aGlzLkVfc3Vtc1tpXTtcbiAgICAgICAgICBzdW1bMF0gKz0gZHggLSBvbGREeDtcbiAgICAgICAgICBzdW1bMV0gKz0gZHkgLSBvbGREeTtcbiAgICAgICAgfVxuICAgICAgfSAvL1N0b3JlIHN1bSBhdCAtMSBpbmRleFxuXG5cbiAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEthbWFkYUthd2FpO1xufSgpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldHdvcmsgdmlzdWFsaXphdGlvbiwgZGlzcGxheWluZyBub2RlcyBhbmQgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICBUaGUgRE9NIGVsZW1lbnQgaW4gd2hpY2ggdGhlIE5ldHdvcmsgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY3JlYXRlZC4gTm9ybWFsbHkgYSBkaXYgZWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gZWRnZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgT3B0aW9uc1xuICogQGNsYXNzIE5ldHdvcmtcbiAqL1xuXG5mdW5jdGlvbiBOZXR3b3JrKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2NvbnRleHQsXG4gICAgICBfY29udGV4dDIsXG4gICAgICBfY29udGV4dDMsXG4gICAgICBfY29udGV4dDQsXG4gICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yXCIpO1xuICB9IC8vIHNldCBjb25zdGFudCB2YWx1ZXNcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIGxvY2FsZTogXCJlblwiLFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgY2xpY2tUb1VzZTogZmFsc2VcbiAgfTtcblxuICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAvKipcbiAgICogQ29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiAnZWRnZXMnIGFuZCAnbm9kZXMnIGNvbnRhaW4gdGhlIGZ1bGwgZGVmaW5pdGlvbnMgb2YgYWxsIHRoZSBuZXR3b3JrIGVsZW1lbnRzLlxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnIGNvbnRhaW4gdGhlIGlkJ3Mgb2YgdGhlIGFjdGl2ZSBlbGVtZW50cy5cbiAgICpcbiAgICogVGhlIGRpc3RpbmN0aW9uIGlzIGltcG9ydGFudCwgYmVjYXVzZSBhIGRlZmluZWQgbm9kZSBuZWVkIG5vdCBiZSBhY3RpdmUsIGkuZS5cbiAgICogdmlzaWJsZSBvbiB0aGUgY2FudmFzLiBUaGlzIGhhcHBlbnMgaW4gcGFydGljdWxhciB3aGVuIGNsdXN0ZXJzIGFyZSBkZWZpbmVkLCBpblxuICAgKiB0aGF0IGNhc2UgdGhlcmUgd2lsbCBiZSBub2RlcyBhbmQgZWRnZXMgbm90IGRpc3BsYXllZC5cbiAgICogVGhlIGJvdHRvbSBsaW5lIGlzIHRoYXQgYWxsIGNvZGUgd2l0aCBhY3Rpb25zIHJlbGF0ZWQgdG8gdmlzaWJpbGl0eSwgKm11c3QqIHVzZVxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnLCBub3QgJ25vZGVzJyBhbmQgJ2VkZ2VzJyBkaXJlY3RseS5cbiAgICovXG5cblxuICB0aGlzLmJvZHkgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIGZvbGxvd2luZyBmaWVsZHNcbiAgICBub2Rlczoge30sXG4gICAgbm9kZUluZGljZXM6IFtdLFxuICAgIGVkZ2VzOiB7fSxcbiAgICBlZGdlSW5kaWNlczogW10sXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IGJpbmQkNihfY29udGV4dCA9IHRoaXMub24pLmNhbGwoX2NvbnRleHQsIHRoaXMpLFxuICAgICAgb2ZmOiBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5vZmYpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSxcbiAgICAgIGVtaXQ6IGJpbmQkNihfY29udGV4dDMgPSB0aGlzLmVtaXQpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSxcbiAgICAgIG9uY2U6IGJpbmQkNihfY29udGV4dDQgPSB0aGlzLm9uY2UpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKVxuICAgIH0sXG4gICAgZXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgIG9uVGFwOiBmdW5jdGlvbiBvblRhcCgpIHt9LFxuICAgICAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaCgpIHt9LFxuICAgICAgb25Eb3VibGVUYXA6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKCkge30sXG4gICAgICBvbkhvbGQ6IGZ1bmN0aW9uIG9uSG9sZCgpIHt9LFxuICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge30sXG4gICAgICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9LFxuICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7fSxcbiAgICAgIG9uTW91c2VXaGVlbDogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCkge30sXG4gICAgICBvblBpbmNoOiBmdW5jdGlvbiBvblBpbmNoKCkge30sXG4gICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoKSB7fSxcbiAgICAgIG9uUmVsZWFzZTogZnVuY3Rpb24gb25SZWxlYXNlKCkge30sXG4gICAgICBvbkNvbnRleHQ6IGZ1bmN0aW9uIG9uQ29udGV4dCgpIHt9XG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBub2RlczogbnVsbCxcbiAgICAgIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgICAgZWRnZXM6IG51bGwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG5cbiAgICB9LFxuICAgIGZ1bmN0aW9uczoge1xuICAgICAgY3JlYXRlTm9kZTogZnVuY3Rpb24gY3JlYXRlTm9kZSgpIHt9LFxuICAgICAgY3JlYXRlRWRnZTogZnVuY3Rpb24gY3JlYXRlRWRnZSgpIHt9LFxuICAgICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gZ2V0UG9pbnRlcigpIHt9XG4gICAgfSxcbiAgICBtb2R1bGVzOiB7fSxcbiAgICB2aWV3OiB7XG4gICAgICBzY2FsZTogMSxcbiAgICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGlvbkJveDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cbiAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTsgLy8gc2V0dGluZyB1cCBhbGwgbW9kdWxlc1xuXG4gIHRoaXMuaW1hZ2VzID0gbmV3IEltYWdlcyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gIH0pOyAvLyBvYmplY3Qgd2l0aCBpbWFnZXNcblxuICB0aGlzLmdyb3VwcyA9IG5ldyBHcm91cHMoKTsgLy8gb2JqZWN0IHdpdGggZ3JvdXBzXG5cbiAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMuYm9keSk7IC8vIERPTSBoYW5kbGVyXG5cbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gbmV3IFNlbGVjdGlvbkhhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIFNlbGVjdGlvbiBoYW5kbGVyXG5cbiAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBuZXcgSW50ZXJhY3Rpb25IYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIEludGVyYWN0aW9uIGhhbmRsZXIgaGFuZGxlcyBhbGwgdGhlIGhhbW1lciBiaW5kaW5ncyAodGhhdCBhcmUgYm91bmQgYnkgY2FudmFzKSwga2V5XG5cbiAgdGhpcy52aWV3ID0gbmV3IFZpZXcodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIGNhbWVyYSBoYW5kbGVyLCBkb2VzIGFuaW1hdGlvbnMgYW5kIHpvb21zXG5cbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gcmVuZGVyZXIsIHN0YXJ0cyByZW5kZXJsb29wLCBoYXMgZXZlbnRzIHRoYXQgbW9kdWxlcyBjYW4gaG9vayBpbnRvXG5cbiAgdGhpcy5waHlzaWNzID0gbmV3IFBoeXNpY3NFbmdpbmUodGhpcy5ib2R5KTsgLy8gcGh5c2ljcyBlbmdpbmUsIGRvZXMgYWxsIHRoZSBzaW11bGF0aW9uc1xuXG4gIHRoaXMubGF5b3V0RW5naW5lID0gbmV3IExheW91dEVuZ2luZSh0aGlzLmJvZHkpOyAvLyBsYXlvdXQgZW5naW5lIGZvciBpbml0YWwgbGF5b3V0IGFuZCBoaWVyYXJjaGljYWwgbGF5b3V0XG5cbiAgdGhpcy5jbHVzdGVyaW5nID0gbmV3IENsdXN0ZXJFbmdpbmUodGhpcy5ib2R5KTsgLy8gY2x1c3RlcmluZyBhcGlcblxuICB0aGlzLm1hbmlwdWxhdGlvbiA9IG5ldyBNYW5pcHVsYXRpb25TeXN0ZW0odGhpcy5ib2R5LCB0aGlzLmNhbnZhcywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gIHRoaXMubm9kZXNIYW5kbGVyID0gbmV3IE5vZGVzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gIHRoaXMuZWRnZXNIYW5kbGVyID0gbmV3IEVkZ2VzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3Vwcyk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBlZGdlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJrYW1hZGFLYXdhaVwiXSA9IG5ldyBLYW1hZGFLYXdhaSh0aGlzLmJvZHksIDE1MCwgMC4wNSk7IC8vIExheW91dGluZyBhbGdvcml0aG0uXG5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJjbHVzdGVyaW5nXCJdID0gdGhpcy5jbHVzdGVyaW5nOyAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50c1xuXG4gIHRoaXMuY2FudmFzLl9jcmVhdGUoKTsgLy8gYXBwbHkgb3B0aW9uc1xuXG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBsb2FkIGRhdGEgKHRoZSBkaXNhYmxlIHN0YXJ0IHZhcmlhYmxlIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGVuYWJsZWQgY2x1c3RlcmluZylcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59IC8vIEV4dGVuZCBOZXR3b3JrIHdpdGggYW4gRW1pdHRlciBtaXhpblxuXG5FbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcbi8qKlxuICogU2V0IG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5cbk5ldHdvcmsucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7IC8vIFRoaXMgZW5zdXJlcyB0aGF0IG9wdGlvbnMgaGFuZGxpbmcgZG9lc24ndCBjcmFzaCBpbiB0aGUgaGFuZGxpbmdcbiAgfVxuXG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXJyb3JGb3VuZCA9IFZhbGlkYXRvci52YWxpZGF0ZShvcHRpb25zLCBhbGxPcHRpb25zKTtcblxuICAgIGlmIChlcnJvckZvdW5kID09PSB0cnVlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC5cIiwgVkFMSURBVE9SX1BSSU5UX1NUWUxFKTtcbiAgICB9IC8vIGNvcHkgdGhlIGdsb2JhbCBmaWVsZHMgb3ZlclxuXG5cbiAgICB2YXIgZmllbGRzID0gW1wibG9jYWxlXCIsIFwibG9jYWxlc1wiLCBcImNsaWNrVG9Vc2VcIl07XG4gICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIG5vcm1hbGl6ZSB0aGUgbG9jYWxlIG9yIHVzZSBFbmdsaXNoXG5cbiAgICBpZiAob3B0aW9ucy5sb2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5sb2NhbGUgPSBub3JtYWxpemVMYW5ndWFnZUNvZGUob3B0aW9ucy5sb2NhbGVzIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzLCBvcHRpb25zLmxvY2FsZSk7XG4gICAgfSAvLyB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBjYW4gYWRhcHQgdGhlIGVkZ2VzIGFuZCB0aGUgcGh5c2ljcyB0byBpdCdzIG93biBvcHRpb25zIGJlY2F1c2Ugbm90IGFsbCBjb21iaW5hdGlvbnMgd29yayB3aXRoIHRoZSBoaWVyYXJpY2hpY2FsIHN5c3RlbS5cblxuXG4gICAgb3B0aW9ucyA9IHRoaXMubGF5b3V0RW5naW5lLnNldE9wdGlvbnMob3B0aW9ucy5sYXlvdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2FudmFzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIG9wdGlvbnMgZm9yIGNhbnZhcyBhcmUgaW4gZ2xvYmFsc1xuICAgIC8vIHBhc3MgdGhlIG9wdGlvbnMgdG8gdGhlIG1vZHVsZXNcblxuICAgIHRoaXMuZ3JvdXBzLnNldE9wdGlvbnMob3B0aW9ucy5ncm91cHMpO1xuICAgIHRoaXMubm9kZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5ub2Rlcyk7XG4gICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmVkZ2VzKTtcbiAgICB0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyhvcHRpb25zLnBoeXNpY3MpO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uLnNldE9wdGlvbnMob3B0aW9ucy5tYW5pcHVsYXRpb24sIG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7IC8vIG1hbmlwdWxhdGlvbiB1c2VzIHRoZSBsb2NhbGVzIGluIHRoZSBnbG9iYWxzXG5cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGFyZSBpbiBpbnRlcmFjdGlvblxuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHNlbGVjdGlvbiBhcmUgaW4gaW50ZXJhY3Rpb25cbiAgICAvLyByZWxvYWQgdGhlIHNldHRpbmdzIG9mIHRoZSBub2RlcyB0byBhcHBseSBjaGFuZ2VzIGluIGdyb3VwcyB0aGF0IGFyZSBub3QgcmVmZXJlbmNlZCBieSBwb2ludGVyLlxuXG4gICAgaWYgKG9wdGlvbnMuZ3JvdXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoTm9kZXNcIik7XG4gICAgfSAvLyB0aGVzZSB0d28gZG8gbm90IGhhdmUgb3B0aW9ucyBhdCB0aGUgbW9tZW50LCBoZXJlIGZvciBjb21wbGV0ZW5lc3NcbiAgICAvL3RoaXMudmlldy5zZXRPcHRpb25zKG9wdGlvbnMudmlldyk7XG4gICAgLy90aGlzLmNsdXN0ZXJpbmcuc2V0T3B0aW9ucyhvcHRpb25zLmNsdXN0ZXJpbmcpO1xuXG5cbiAgICBpZiAoXCJjb25maWd1cmVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmJvZHkuY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zLCB0aGlzLmNhbnZhcy5waXhlbFJhdGlvLCBjb25maWd1cmF0b3JIaWRlT3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG4gICAgfSAvLyBpZiB0aGUgY29uZmlndXJhdGlvbiBzeXN0ZW0gaXMgZW5hYmxlZCwgY29weSBhbGwgb3B0aW9ucyBhbmQgcHV0IHRoZW0gaW50byB0aGUgY29uZmlnIHN5c3RlbVxuXG5cbiAgICBpZiAodGhpcy5jb25maWd1cmF0b3IgJiYgdGhpcy5jb25maWd1cmF0b3Iub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB2YXIgbmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgZWRnZXM6IHt9LFxuICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge30sXG4gICAgICAgIG1hbmlwdWxhdGlvbjoge30sXG4gICAgICAgIHBoeXNpY3M6IHt9LFxuICAgICAgICBnbG9iYWw6IHt9XG4gICAgICB9O1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5ub2RlcywgdGhpcy5ub2Rlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmVkZ2VzLCB0aGlzLmVkZ2VzSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTsgLy8gbG9hZCB0aGUgc2VsZWN0aW9uSGFuZGxlciBhbmQgcmVuZGVyIGRlZmF1bHQgb3B0aW9ucyBpbiB0byB0aGUgaW50ZXJhY3Rpb24gZ3JvdXBcblxuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5tYW5pcHVsYXRpb24sIHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5waHlzaWNzLCB0aGlzLnBoeXNpY3Mub3B0aW9ucyk7IC8vIGxvYWQgZ2xvYmFscyBpbnRvIHRoZSBnbG9iYWwgb2JqZWN0XG5cbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLmNhbnZhcy5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyhuZXR3b3JrT3B0aW9ucyk7XG4gICAgfSAvLyBoYW5kbGUgbmV0d29yayBnbG9iYWwgb3B0aW9uc1xuXG5cbiAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7IC8vIHN0YXJ0IHRoZSBwaHlzaWNzIHNpbXVsYXRpb24uIENhbiBiZSBzYWZlbHkgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgfVxufTtcbi8qKlxuICogVXBkYXRlIHRoZSB2aXNpYmxlIG5vZGVzIGFuZCBlZGdlcyBsaXN0IHdpdGggdGhlIG1vc3QgcmVjZW50IG5vZGUgc3RhdGUuXG4gKlxuICogVmlzaWJsZSBub2RlcyBhcmUgc3RvcmVkIGluIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5cbiAqIFZpc2libGUgZWRnZXMgYXJlIHN0b3JlZCBpbiB0aGlzLmJvZHkuZWRnZUluZGljZXMuXG4gKiBBIG5vZGUgb3IgZWRnZXMgaXMgdmlzaWJsZSBpZiBpdCBpcyBub3QgaGlkZGVuIG9yIGNsdXN0ZXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZpc2libGVJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzID0gW107XG4gIHRoaXMuYm9keS5lZGdlSW5kaWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgIGlmICghdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZE5vZGUobm9kZUlkKSAmJiBub2Rlc1tub2RlSWRdLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07IC8vIEl0IGNhbiBoYXBwZW4gdGhhdCB0aGlzIGlzIGV4ZWN1dGVkICphZnRlciogYSBub2RlIGVkZ2UgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgIC8vIGJ1dCAqYmVmb3JlKiB0aGUgZWRnZSBpdHNlbGYgaGFzIGJlZW4gcmVtb3ZlZC4gVGFraW5nIHRoaXMgaW50byBhY2NvdW50LlxuXG4gICAgICB2YXIgZnJvbU5vZGUgPSBub2Rlc1tlZGdlLmZyb21JZF07XG4gICAgICB2YXIgdG9Ob2RlID0gbm9kZXNbZWRnZS50b0lkXTtcbiAgICAgIHZhciBlZGdlTm9kZXNQcmVzZW50ID0gZnJvbU5vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUgIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpc1Zpc2libGUgPSAhdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSAmJiBlZGdlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiBlZGdlTm9kZXNQcmVzZW50ICYmIGZyb21Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiAvLyBBbHNvIGhpZGRlbiBpZiBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgYXJlIGhpZGRlblxuICAgICAgdG9Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZTsgLy8gaWRlbVxuXG4gICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQmluZCBhbGwgZXZlbnRzXG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5iaW5kRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIC8vIFRoaXMgZXZlbnQgd2lsbCB0cmlnZ2VyIGEgcmVidWlsZGluZyBvZiB0aGUgY2FjaGUgZXZlcnl0aGluZy5cbiAgLy8gVXNlZCB3aGVuIG5vZGVzIG9yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLlxuICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMzLmVkZ2VzSGFuZGxlci5fdXBkYXRlU3RhdGUoKTtcblxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgfSk7IC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YVVwZGF0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIC8vIE9yZGVyIGltcG9ydGFudCBpbiBmb2xsb3dpbmcgYmxvY2tcbiAgICBfdGhpczMuY2x1c3RlcmluZy5fdXBkYXRlU3RhdGUoKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5ub2Rlcyk7XG5cbiAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkuZWRnZXMpOyAvLyBzdGFydCBzaW11bGF0aW9uIChjYW4gYmUgY2FsbGVkIHNhZmVseSwgZXZlbiBpZiBhbHJlYWR5IHJ1bm5pbmcpXG5cblxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcblxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICB9KTtcbn07XG4vKipcbiAqIFNldCBub2RlcyBhbmQgZWRnZXMsIGFuZCBvcHRpb25hbGx5IG9wdGlvbnMgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtub2Rlc10gQXJyYXkgd2l0aCBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW2VkZ2VzXSBBcnJheSB3aXRoIGVkZ2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2RvdF0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgZm9ybWF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2dlcGhpXSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIGdlcGhpIEpTT04gZm9ybWF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09wdGlvbnN9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBvcHRpb25zXG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gcmVzZXQgdGhlIHBoeXNpY3MgZW5naW5lLlxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzZXRQaHlzaWNzXCIpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2V0RGF0YVwiKTsgLy8gdW5zZWxlY3QgYWxsIHRvIGVuc3VyZSBubyBzZWxlY3Rpb25zIGZyb20gb2xkIGRhdGEgYXJlIGNhcnJpZWQgb3Zlci5cblxuICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcblxuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCAmJiAoZGF0YS5ub2RlcyB8fCBkYXRhLmVkZ2VzKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRGF0YSBtdXN0IGNvbnRhaW4gZWl0aGVyIHBhcmFtZXRlciBcImRvdFwiIG9yICcgKyAnIHBhcmFtZXRlciBwYWlyIFwibm9kZXNcIiBhbmQgXCJlZGdlc1wiLCBidXQgbm90IGJvdGguJyk7XG4gIH0gLy8gc2V0IG9wdGlvbnNcblxuXG4gIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7IC8vIHNldCBhbGwgZGF0YVxuXG4gIGlmIChkYXRhICYmIGRhdGEuZG90KSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGRvdCBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGF0aWMgY29udmVydERvdCBtZXRob2QgdG8gY29udmVydCBET1QgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0RG90KGRvdFN0cmluZyk7XCIpOyAvLyBwYXJzZSBET1QgZmlsZVxuXG4gICAgdmFyIGRvdERhdGEgPSBET1RUb0dyYXBoKGRhdGEuZG90KTtcbiAgICB0aGlzLnNldERhdGEoZG90RGF0YSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5nZXBoaSkge1xuICAgIC8vIHBhcnNlIERPVCBmaWxlXG4gICAgY29uc29sZS53YXJuKFwiVGhlIGdlcGhpIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0R2VwaGkgbWV0aG9kIHRvIGNvbnZlcnQgZ2VwaGkgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0R2VwaGkoZ2VwaGlKc29uKTtcIik7XG4gICAgdmFyIGdlcGhpRGF0YSA9IHBhcnNlR2VwaGkoZGF0YS5nZXBoaSk7XG4gICAgdGhpcy5zZXREYXRhKGdlcGhpRGF0YSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZXNIYW5kbGVyLnNldERhdGEoZGF0YSAmJiBkYXRhLm5vZGVzLCB0cnVlKTtcbiAgICB0aGlzLmVkZ2VzSGFuZGxlci5zZXREYXRhKGRhdGEgJiYgZGF0YS5lZGdlcywgdHJ1ZSk7XG4gIH0gLy8gZW1pdCBjaGFuZ2UgaW4gZGF0YVxuXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTsgLy8gZW1pdCBkYXRhIGxvYWRlZFxuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUxvYWRlZFwiKTsgLy8gZmluZCBhIHN0YWJsZSBwb3NpdGlvbiBvciBzdGFydCBhbmltYXRpbmcgdG8gYSBzdGFibGUgcG9zaXRpb25cblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFBoeXNpY3NcIik7XG59O1xuLyoqXG4gKiBDbGVhbnMgdXAgYWxsIGJpbmRpbmdzIG9mIHRoZSBuZXR3b3JrLCByZW1vdmluZyBpdCBmdWxseSBmcm9tIHRoZSBtZW1vcnkgSUYgdGhlIHZhcmlhYmxlIGlzIHNldCB0byBudWxsIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqIHZhciBuZXR3b3JrID0gbmV3IHZpcy5OZXR3b3JrKC4uKTtcbiAqIG5ldHdvcmsuZGVzdHJveSgpO1xuICogbmV0d29yayA9IG51bGw7XG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGVzdHJveVwiKTsgLy8gY2xlYXIgZXZlbnRzXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gIHRoaXMub2ZmKCk7IC8vIGRlbGV0ZSBtb2R1bGVzXG5cbiAgZGVsZXRlIHRoaXMuZ3JvdXBzO1xuICBkZWxldGUgdGhpcy5jYW52YXM7XG4gIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbkhhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMudmlldztcbiAgZGVsZXRlIHRoaXMucmVuZGVyZXI7XG4gIGRlbGV0ZSB0aGlzLnBoeXNpY3M7XG4gIGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZTtcbiAgZGVsZXRlIHRoaXMuY2x1c3RlcmluZztcbiAgZGVsZXRlIHRoaXMubWFuaXB1bGF0aW9uO1xuICBkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmVkZ2VzSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuY29uZmlndXJhdG9yO1xuICBkZWxldGUgdGhpcy5pbWFnZXM7XG5cbiAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkgY29udGludWU7XG4gICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICB9XG5cbiAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZUlkKSkgY29udGludWU7XG4gICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICB9IC8vIHJlbW92ZSB0aGUgY29udGFpbmVyIGFuZCBldmVyeXRoaW5nIGluc2lkZSBpdCByZWN1cnNpdmVseVxuXG5cbiAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuYm9keS5jb250YWluZXIpO1xufTtcbi8qKlxuICogVXBkYXRlIHRoZSB2YWx1ZXMgb2YgYWxsIG9iamVjdCBpbiB0aGUgZ2l2ZW4gYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSByYW5nZSBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0cyBtdXN0IGhhdmUgYSBtZXRob2QgZ2V0VmFsdWUoKSBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVSYW5nZShtaW4sIG1heCkuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBpZDsgLy8gZGV0ZXJtaW5lIHRoZSByYW5nZSBvZiB0aGUgb2JqZWN0c1xuXG4gIHZhciB2YWx1ZU1pbiA9IHVuZGVmaW5lZDtcbiAgdmFyIHZhbHVlTWF4ID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVUb3RhbCA9IDA7XG5cbiAgZm9yIChpZCBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaWQpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbaWRdLmdldFZhbHVlKCk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlTWluID0gdmFsdWVNaW4gPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogTWF0aC5taW4odmFsdWUsIHZhbHVlTWluKTtcbiAgICAgICAgdmFsdWVNYXggPSB2YWx1ZU1heCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1heCh2YWx1ZSwgdmFsdWVNYXgpO1xuICAgICAgICB2YWx1ZVRvdGFsICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBhZGp1c3QgdGhlIHJhbmdlIG9mIGFsbCBvYmplY3RzXG5cblxuICBpZiAodmFsdWVNaW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpZCkpIHtcbiAgICAgICAgb2JqW2lkXS5zZXRWYWx1ZVJhbmdlKHZhbHVlTWluLCB2YWx1ZU1heCwgdmFsdWVUb3RhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgTmV0d29yayBpcyBhY3RpdmUuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLmFjdGl2YXRvciB8fCB0aGlzLmFjdGl2YXRvci5hY3RpdmU7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuc2V0U2l6ZS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmNhbnZhc1RvRE9NID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuY2FudmFzVG9ET00uYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5ET010b0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcbi8qKlxuICogTm9kZXMgY2FuIGJlIGluIGNsdXN0ZXJzLiBDbHVzdGVycyBjYW4gYWxzbyBiZSBpbiBjbHVzdGVycy4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuZCBhcnJheSBvZlxuICogbm9kZUlkcyBzaG93aW5nIHdoZXJlIHRoZSBub2RlIGlzLlxuICpcbiAqIElmIGFueSBub2RlSWQgaW4gdGhlIGNoYWluLCBlc3BlY2lhbGx5IHRoZSBmaXJzdCBwYXNzZWQgaW4gYXMgYSBwYXJhbWV0ZXIsIGlzIG5vdCBwcmVzZW50IGluXG4gKiB0aGUgY3VycmVudCBub2RlcyBsaXN0LCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqXG4gKiBFeGFtcGxlOlxuICogY2x1c3RlciAnQScgY29udGFpbnMgY2x1c3RlciAnQicsXG4gKiBjbHVzdGVyICdCJyBjb250YWlucyBjbHVzdGVyICdDJyxcbiAqIGNsdXN0ZXIgJ0MnIGNvbnRhaW5zIG5vZGUgJ2ZyZWQnLlxuICogYGpzbmV0d29yay5jbHVzdGVyaW5nLmZpbmROb2RlKCdmcmVkJylgIHdpbGwgcmV0dXJuIGBbJ0EnLCdCJywnQycsJ2ZyZWQnXWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmZpbmROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmZpbmROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmlzQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5pc0NsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUub3BlbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVzSW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldE5vZGVzSW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5Q29ubmVjdGlvbi5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlIdWJzaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUh1YnNpemUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUudXBkYXRlQ2x1c3RlcmVkTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVDbHVzdGVyZWROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldENsdXN0ZXJlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldENsdXN0ZXJlZEVkZ2VzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEJhc2VFZGdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldEJhc2VFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEJhc2VFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZXMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUudXBkYXRlRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kIHdpbGwgY2x1c3RlciBhbGwgbm9kZXMgd2l0aCAxIGVkZ2Ugd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbm5lY3RlZCBub2RlLlxuICogVGhlIG9wdGlvbnMgb2JqZWN0IGlzIGV4cGxhaW5lZCBpbiBmdWxsIDxhIGRhdGEtc2Nyb2xsPVwiXCIgZGF0YS1vcHRpb25zPVwieyAmcXVvdDtlYXNpbmcmcXVvdDs6ICZxdW90O2Vhc2VJbkN1YmljJnF1b3Q7IH1cIiBocmVmPVwiI29wdGlvbnNPYmplY3RcIj5iZWxvdzwvYT4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJPdXRsaWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFNlZWQuYXBwbHkodGhpcy5sYXlvdXRFbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5lbmFibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVuYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZGlzYWJsZUVkaXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGlzYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGROb2RlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUud2FybihcIkRlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgZWRpdE5vZGUgaW5zdGVhZCBvZiBlZGl0Tm9kZU1vZGUuXCIpO1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5hZGRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZWRpdEVkZ2VNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZGVsZXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kZWxldGVTZWxlY3RlZC5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb24uYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zdG9yZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUubW92ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5tb3ZlTm9kZS5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Qm91bmRpbmdCb3guYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChvYmplY3RJZCkge1xuICBpZiAodGhpcy5ib2R5Lm5vZGVzW29iamVjdElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWRFZGdlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnN0YXJ0U2ltdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFydFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RvcFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc3RhYmlsaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YWJpbGl6ZS5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Tm9kZUF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuXG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEVkZ2VBdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2UgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0RWRnZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcblxuICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlZGdlLmlkO1xuICB9XG5cbiAgcmV0dXJuIGVkZ2U7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3ROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3ROb2Rlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3RFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS51bnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdFdpdGhvdXRFbWl0dGluZy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIpO1xuICB0aGlzLnJlZHJhdygpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZWRyYXcuYXBwbHkodGhpcy5yZW5kZXJlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmdldFNjYWxlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFZpZXdQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5nZXRWaWV3UG9zaXRpb24uYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmZpdC5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcubW92ZVRvLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmZvY3VzLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnJlbGVhc2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LnJlbGVhc2VOb2RlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldE9wdGlvbnNGcm9tQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgIG9wdGlvbnMgPSB0aGlzLmNvbmZpZ3VyYXRvci5nZXRPcHRpb25zLmFwcGx5KHRoaXMuY29uZmlndXJhdG9yKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxudmFyIHBhcnNlRE9UTmV0d29yayA9IERPVFRvR3JhcGg7XG4vLyBvdmVyZmxvdyBpbiBVTUQgYnVpbGRzLiBUaGV5IGFsbCBleHBvcnQgdmlzIG5hbWVzcGFjZSB0aGVyZWZvcmUgcmVleHBvcnRpbmdcbi8vIGxlYWRzIHRvIGxvYWRpbmcgdmlzIHRvIGxvYWQgdmlzIHRvIGxvYWQgdmlz4oCmXG5cbmV4cG9ydCB7IERhdGFTZXQsIERhdGFWaWV3LCBOZXR3b3JrLCBJbWFnZXMgYXMgTmV0d29ya0ltYWdlcywgUXVldWUsIGluZGV4IGFzIGRhdGEsIGRvdHBhcnNlciBhcyBuZXR3b3JrRE9UUGFyc2VyLCBnZXBoaVBhcnNlciBhcyBuZXR3b3JrR2VwaGlQYXJzZXIsIG9wdGlvbnMgYXMgbmV0d29ya09wdGlvbnMsIHBhcnNlRE9UTmV0d29yaywgcGFyc2VHZXBoaSBhcyBwYXJzZUdlcGhpTmV0d29yayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzLW5ldHdvcmsuanMubWFwXG4iLCJleHBvcnQgKiBmcm9tIFwiLi9lc21cIjtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX187XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCIiLCIvLyBtb2R1bGUgY2FjaGUgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvdmlzX2xzdHJpZS50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==